{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: Block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: Invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: Cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: Pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: Pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: Pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: Pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: Line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: Line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\n#ifdef FEAT_PATH_EXTRA\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\n#endif\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\n#endif\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\n#endif\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: Undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: Undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#endif\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: Fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_here[]\n\tINIT(= N_(\"E578: Not allowed to change text here\"));\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n// E614 unused\n// E615 unused\n// E616 unused\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: Missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: Missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: Invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: Invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: Invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: Invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: Invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: Invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: Invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: Invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: Invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: Invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: Invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: Invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: Invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: Invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: Invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: Invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: Invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n# ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: Expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: Text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type[]\n\tINIT(= N_(\"E1008: Missing <type>\"));\nEXTERN char e_missing_gt_after_type[]\n\tINIT(= N_(\"E1009: Missing > after type\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n# ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n# endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n * Multibyte extensions partly by Sung-Hoon Baek\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * mbyte.c: Code specifically for handling multi-byte characters.\n *\n * The encoding used in the core is set with 'encoding'.  When 'encoding' is\n * changed, the following four variables are set (for speed).\n * Currently these types of character encodings are supported:\n *\n * \"enc_dbcs\"\t    When non-zero it tells the type of double byte character\n *\t\t    encoding (Chinese, Korean, Japanese, etc.).\n *\t\t    The cell width on the display is equal to the number of\n *\t\t    bytes.  (exception: DBCS_JPNU with first byte 0x8e)\n *\t\t    Recognizing the first or second byte is difficult, it\n *\t\t    requires checking a byte sequence from the start.\n * \"enc_utf8\"\t    When TRUE use Unicode characters in UTF-8 encoding.\n *\t\t    The cell width on the display needs to be determined from\n *\t\t    the character value.\n *\t\t    Recognizing bytes is easy: 0xxx.xxxx is a single-byte\n *\t\t    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading\n *\t\t    byte of a multi-byte character.\n *\t\t    To make things complicated, up to six composing characters\n *\t\t    are allowed.  These are drawn on top of the first char.\n *\t\t    For most editing the sequence of bytes with composing\n *\t\t    characters included is considered to be one character.\n * \"enc_unicode\"    When 2 use 16-bit Unicode characters (or UTF-16).\n *\t\t    When 4 use 32-but Unicode characters.\n *\t\t    Internally characters are stored in UTF-8 encoding to\n *\t\t    avoid NUL bytes.  Conversion happens when doing I/O.\n *\t\t    \"enc_utf8\" will also be TRUE.\n *\n * \"has_mbyte\" is set when \"enc_dbcs\" or \"enc_utf8\" is non-zero.\n *\n * If none of these is TRUE, 8-bit bytes are used for a character.  The\n * encoding isn't currently specified (TODO).\n *\n * 'encoding' specifies the encoding used in the core.  This is in registers,\n * text manipulation, buffers, etc.  Conversion has to be done when characters\n * in another encoding are received or send:\n *\n *\t\t       clipboard\n *\t\t\t   ^\n *\t\t\t   | (2)\n *\t\t\t   V\n *\t\t   +---------------+\n *\t      (1)  |\t\t   | (3)\n *  keyboard ----->|\t core\t   |-----> display\n *\t\t   |\t\t   |\n *\t\t   +---------------+\n *\t\t\t   ^\n *\t\t\t   | (4)\n *\t\t\t   V\n *\t\t\t file\n *\n * (1) Typed characters arrive in the current locale.  Conversion is to be\n *     done when 'encoding' is different from 'termencoding'.\n * (2) Text will be made available with the encoding specified with\n *     'encoding'.  If this is not sufficient, system-specific conversion\n *     might be required.\n * (3) For the GUI the correct font must be selected, no conversion done.\n *     Otherwise, conversion is to be done when 'encoding' differs from\n *     'termencoding'.  (Different in the GTK+ 2 port -- 'termencoding'\n *     is always used for both input and output and must always be set to\n *     \"utf-8\".  gui_mch_init() does this automatically.)\n * (4) The encoding of the file is specified with 'fileencoding'.  Conversion\n *     is to be done when it's different from 'encoding'.\n *\n * The viminfo file is a special case: Only text is converted, not file names.\n * Vim scripts may contain an \":encoding\" command.  This has an effect for\n * some commands, like \":menutrans\"\n */\n\n#include \"vim.h\"\n\n#ifdef WIN32UNIX\n# ifndef WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n# endif\n# if defined(FEAT_GUI) || defined(FEAT_XCLIPBOARD)\n#  ifdef __CYGWIN__\n    // ControlMask from <X11/X.h> (included in \"vim.h\") is conflicting with\n    // <w32api/windows.h> (included in <X11/Xwindows.h>).\n#   undef ControlMask\n#  endif\n#  include <X11/Xwindows.h>\n#  define WINBYTE wBYTE\n# else\n#  include <windows.h>\n#  define WINBYTE BYTE\n# endif\n# ifdef WIN32\n#  undef WIN32\t    // Some windows.h define WIN32, we don't want that here.\n# endif\n#else\n# define WINBYTE BYTE\n#endif\n\n#if (defined(MSWIN) || defined(WIN32UNIX)) && !defined(__MINGW32__)\n# include <winnls.h>\n#endif\n\n#ifdef FEAT_GUI_X11\n# include <X11/Intrinsic.h>\n#endif\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n# if !defined(HAVE_MBLEN) && !defined(mblen)\n#  define mblen _Xmblen\n# endif\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#if 0\n// This has been disabled, because several people reported problems with the\n// wcwidth() and iswprint() library functions, esp. for Hebrew.\n# ifdef __STDC_ISO_10646__\n#  define USE_WCHAR_FUNCTIONS\n# endif\n#endif\n\nstatic int dbcs_char2len(int c);\nstatic int dbcs_char2bytes(int c, char_u *buf);\nstatic int dbcs_ptr2len(char_u *p);\nstatic int dbcs_ptr2len_len(char_u *p, int size);\nstatic int utf_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_char2cells(int c);\nstatic int dbcs_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_ptr2char(char_u *p);\nstatic int dbcs_head_off(char_u *base, char_u *p);\n#ifdef FEAT_EVAL\nstatic int cw_value(int c);\n#endif\n\n/*\n * Lookup table to quickly get the length in bytes of a UTF-8 character from\n * the first byte of a UTF-8 string.\n * Bytes which are illegal when used as the first byte have a 1.\n * The NUL byte has length 1.\n */\nstatic char utf8len_tab[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,\n};\n\n/*\n * Like utf8len_tab above, but using a zero for illegal lead bytes.\n */\nstatic char utf8len_tab_zero[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,\n};\n\n\n/*\n * Canonical encoding names and their properties.\n * \"iso-8859-n\" is handled by enc_canonize() directly.\n */\nstatic struct\n{   char *name;\t\tint prop;\t\tint codepage;}\nenc_canon_table[] =\n{\n#define IDX_LATIN_1\t0\n    {\"latin1\",\t\tENC_8BIT + ENC_LATIN1,\t1252},\n#define IDX_ISO_2\t1\n    {\"iso-8859-2\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_3\t2\n    {\"iso-8859-3\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_4\t3\n    {\"iso-8859-4\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_5\t4\n    {\"iso-8859-5\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_6\t5\n    {\"iso-8859-6\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_7\t6\n    {\"iso-8859-7\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_8\t7\n    {\"iso-8859-8\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_9\t8\n    {\"iso-8859-9\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_10\t9\n    {\"iso-8859-10\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_11\t10\n    {\"iso-8859-11\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_13\t11\n    {\"iso-8859-13\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_14\t12\n    {\"iso-8859-14\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_15\t13\n    {\"iso-8859-15\",\tENC_8BIT + ENC_LATIN9,\t0},\n#define IDX_KOI8_R\t14\n    {\"koi8-r\",\t\tENC_8BIT,\t\t0},\n#define IDX_KOI8_U\t15\n    {\"koi8-u\",\t\tENC_8BIT,\t\t0},\n#define IDX_UTF8\t16\n    {\"utf-8\",\t\tENC_UNICODE,\t\t0},\n#define IDX_UCS2\t17\n    {\"ucs-2\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},\n#define IDX_UCS2LE\t18\n    {\"ucs-2le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},\n#define IDX_UTF16\t19\n    {\"utf-16\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},\n#define IDX_UTF16LE\t20\n    {\"utf-16le\",\tENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},\n#define IDX_UCS4\t21\n    {\"ucs-4\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},\n#define IDX_UCS4LE\t22\n    {\"ucs-4le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},\n\n    // For debugging DBCS encoding on Unix.\n#define IDX_DEBUG\t23\n    {\"debug\",\t\tENC_DBCS,\t\tDBCS_DEBUG},\n#define IDX_EUC_JP\t24\n    {\"euc-jp\",\t\tENC_DBCS,\t\tDBCS_JPNU},\n#define IDX_SJIS\t25\n    {\"sjis\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_EUC_KR\t26\n    {\"euc-kr\",\t\tENC_DBCS,\t\tDBCS_KORU},\n#define IDX_EUC_CN\t27\n    {\"euc-cn\",\t\tENC_DBCS,\t\tDBCS_CHSU},\n#define IDX_EUC_TW\t28\n    {\"euc-tw\",\t\tENC_DBCS,\t\tDBCS_CHTU},\n#define IDX_BIG5\t29\n    {\"big5\",\t\tENC_DBCS,\t\tDBCS_CHT},\n\n    // MS-DOS and MS-Windows codepages are included here, so that they can be\n    // used on Unix too.  Most of them are similar to ISO-8859 encodings, but\n    // not exactly the same.\n#define IDX_CP437\t30\n    {\"cp437\",\t\tENC_8BIT,\t\t437}, // like iso-8859-1\n#define IDX_CP737\t31\n    {\"cp737\",\t\tENC_8BIT,\t\t737}, // like iso-8859-7\n#define IDX_CP775\t32\n    {\"cp775\",\t\tENC_8BIT,\t\t775}, // Baltic\n#define IDX_CP850\t33\n    {\"cp850\",\t\tENC_8BIT,\t\t850}, // like iso-8859-4\n#define IDX_CP852\t34\n    {\"cp852\",\t\tENC_8BIT,\t\t852}, // like iso-8859-1\n#define IDX_CP855\t35\n    {\"cp855\",\t\tENC_8BIT,\t\t855}, // like iso-8859-2\n#define IDX_CP857\t36\n    {\"cp857\",\t\tENC_8BIT,\t\t857}, // like iso-8859-5\n#define IDX_CP860\t37\n    {\"cp860\",\t\tENC_8BIT,\t\t860}, // like iso-8859-9\n#define IDX_CP861\t38\n    {\"cp861\",\t\tENC_8BIT,\t\t861}, // like iso-8859-1\n#define IDX_CP862\t39\n    {\"cp862\",\t\tENC_8BIT,\t\t862}, // like iso-8859-1\n#define IDX_CP863\t40\n    {\"cp863\",\t\tENC_8BIT,\t\t863}, // like iso-8859-8\n#define IDX_CP865\t41\n    {\"cp865\",\t\tENC_8BIT,\t\t865}, // like iso-8859-1\n#define IDX_CP866\t42\n    {\"cp866\",\t\tENC_8BIT,\t\t866}, // like iso-8859-5\n#define IDX_CP869\t43\n    {\"cp869\",\t\tENC_8BIT,\t\t869}, // like iso-8859-7\n#define IDX_CP874\t44\n    {\"cp874\",\t\tENC_8BIT,\t\t874}, // Thai\n#define IDX_CP932\t45\n    {\"cp932\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_CP936\t46\n    {\"cp936\",\t\tENC_DBCS,\t\tDBCS_CHS},\n#define IDX_CP949\t47\n    {\"cp949\",\t\tENC_DBCS,\t\tDBCS_KOR},\n#define IDX_CP950\t48\n    {\"cp950\",\t\tENC_DBCS,\t\tDBCS_CHT},\n#define IDX_CP1250\t49\n    {\"cp1250\",\t\tENC_8BIT,\t\t1250}, // Czech, Polish, etc.\n#define IDX_CP1251\t50\n    {\"cp1251\",\t\tENC_8BIT,\t\t1251}, // Cyrillic\n    // cp1252 is considered to be equal to latin1\n#define IDX_CP1253\t51\n    {\"cp1253\",\t\tENC_8BIT,\t\t1253}, // Greek\n#define IDX_CP1254\t52\n    {\"cp1254\",\t\tENC_8BIT,\t\t1254}, // Turkish\n#define IDX_CP1255\t53\n    {\"cp1255\",\t\tENC_8BIT,\t\t1255}, // Hebrew\n#define IDX_CP1256\t54\n    {\"cp1256\",\t\tENC_8BIT,\t\t1256}, // Arabic\n#define IDX_CP1257\t55\n    {\"cp1257\",\t\tENC_8BIT,\t\t1257}, // Baltic\n#define IDX_CP1258\t56\n    {\"cp1258\",\t\tENC_8BIT,\t\t1258}, // Vietnamese\n\n#define IDX_MACROMAN\t57\n    {\"macroman\",\tENC_8BIT + ENC_MACROMAN, 0},\t// Mac OS\n#define IDX_DECMCS\t58\n    {\"dec-mcs\",\t\tENC_8BIT,\t\t0},\t// DEC MCS\n#define IDX_HPROMAN8\t59\n    {\"hp-roman8\",\tENC_8BIT,\t\t0},\t// HP Roman8\n#define IDX_COUNT\t60\n};\n\n/*\n * Aliases for encoding names.\n */\nstatic struct\n{   char *name;\t\tint canon;}\nenc_alias_table[] =\n{\n    {\"ansi\",\t\tIDX_LATIN_1},\n    {\"iso-8859-1\",\tIDX_LATIN_1},\n    {\"iso-8859\",\tIDX_LATIN_1},\n    {\"latin2\",\t\tIDX_ISO_2},\n    {\"latin3\",\t\tIDX_ISO_3},\n    {\"latin4\",\t\tIDX_ISO_4},\n    {\"cyrillic\",\tIDX_ISO_5},\n    {\"arabic\",\t\tIDX_ISO_6},\n    {\"greek\",\t\tIDX_ISO_7},\n#ifdef MSWIN\n    {\"hebrew\",\t\tIDX_CP1255},\n#else\n    {\"hebrew\",\t\tIDX_ISO_8},\n#endif\n    {\"latin5\",\t\tIDX_ISO_9},\n    {\"turkish\",\t\tIDX_ISO_9}, // ?\n    {\"latin6\",\t\tIDX_ISO_10},\n    {\"nordic\",\t\tIDX_ISO_10}, // ?\n    {\"thai\",\t\tIDX_ISO_11}, // ?\n    {\"latin7\",\t\tIDX_ISO_13},\n    {\"latin8\",\t\tIDX_ISO_14},\n    {\"latin9\",\t\tIDX_ISO_15},\n    {\"utf8\",\t\tIDX_UTF8},\n    {\"unicode\",\t\tIDX_UCS2},\n    {\"ucs2\",\t\tIDX_UCS2},\n    {\"ucs2be\",\t\tIDX_UCS2},\n    {\"ucs-2be\",\t\tIDX_UCS2},\n    {\"ucs2le\",\t\tIDX_UCS2LE},\n    {\"utf16\",\t\tIDX_UTF16},\n    {\"utf16be\",\t\tIDX_UTF16},\n    {\"utf-16be\",\tIDX_UTF16},\n    {\"utf16le\",\t\tIDX_UTF16LE},\n    {\"ucs4\",\t\tIDX_UCS4},\n    {\"ucs4be\",\t\tIDX_UCS4},\n    {\"ucs-4be\",\t\tIDX_UCS4},\n    {\"ucs4le\",\t\tIDX_UCS4LE},\n    {\"utf32\",\t\tIDX_UCS4},\n    {\"utf-32\",\t\tIDX_UCS4},\n    {\"utf32be\",\t\tIDX_UCS4},\n    {\"utf-32be\",\tIDX_UCS4},\n    {\"utf32le\",\t\tIDX_UCS4LE},\n    {\"utf-32le\",\tIDX_UCS4LE},\n    {\"932\",\t\tIDX_CP932},\n    {\"949\",\t\tIDX_CP949},\n    {\"936\",\t\tIDX_CP936},\n    {\"gbk\",\t\tIDX_CP936},\n    {\"950\",\t\tIDX_CP950},\n    {\"eucjp\",\t\tIDX_EUC_JP},\n    {\"unix-jis\",\tIDX_EUC_JP},\n    {\"ujis\",\t\tIDX_EUC_JP},\n    {\"shift-jis\",\tIDX_SJIS},\n    {\"pck\",\t\tIDX_SJIS},\t// Sun: PCK\n    {\"euckr\",\t\tIDX_EUC_KR},\n    {\"5601\",\t\tIDX_EUC_KR},\t// Sun: KS C 5601\n    {\"euccn\",\t\tIDX_EUC_CN},\n    {\"gb2312\",\t\tIDX_EUC_CN},\n    {\"euctw\",\t\tIDX_EUC_TW},\n#if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n    {\"japan\",\t\tIDX_CP932},\n    {\"korea\",\t\tIDX_CP949},\n    {\"prc\",\t\tIDX_CP936},\n    {\"chinese\",\t\tIDX_CP936},\n    {\"taiwan\",\t\tIDX_CP950},\n    {\"big5\",\t\tIDX_CP950},\n#else\n    {\"japan\",\t\tIDX_EUC_JP},\n    {\"korea\",\t\tIDX_EUC_KR},\n    {\"prc\",\t\tIDX_EUC_CN},\n    {\"chinese\",\t\tIDX_EUC_CN},\n    {\"taiwan\",\t\tIDX_EUC_TW},\n    {\"cp950\",\t\tIDX_BIG5},\n    {\"950\",\t\tIDX_BIG5},\n#endif\n    {\"mac\",\t\tIDX_MACROMAN},\n    {\"mac-roman\",\tIDX_MACROMAN},\n    {NULL,\t\t0}\n};\n\n#ifndef CP_UTF8\n# define CP_UTF8 65001\t// magic number from winnls.h\n#endif\n\n/*\n * Find encoding \"name\" in the list of canonical encoding names.\n * Returns -1 if not found.\n */\n    static int\nenc_canon_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; i < IDX_COUNT; ++i)\n\tif (STRCMP(name, enc_canon_table[i].name) == 0)\n\t    return i;\n    return -1;\n}\n\n\n/*\n * Find canonical encoding \"name\" in the list and return its properties.\n * Returns 0 if not found.\n */\n    int\nenc_canon_props(char_u *name)\n{\n    int\t\ti;\n\n    i = enc_canon_search(name);\n    if (i >= 0)\n\treturn enc_canon_table[i].prop;\n#ifdef MSWIN\n    if (name[0] == 'c' && name[1] == 'p' && VIM_ISDIGIT(name[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)name + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1) // some single-byte encoding\n\t\treturn ENC_8BIT;\n\t    if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t\t// must be a DBCS encoding\n\t\treturn ENC_DBCS;\n\t}\n\treturn 0;\n    }\n#endif\n    if (STRNCMP(name, \"2byte-\", 6) == 0)\n\treturn ENC_DBCS;\n    if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)\n\treturn ENC_8BIT;\n    return 0;\n}\n\n/*\n * Set up for using multi-byte characters.\n * Called in three cases:\n * - by main() to initialize (p_enc == NULL)\n * - by set_init_1() after 'encoding' was set to its default.\n * - by do_set() when 'encoding' has been set.\n * p_enc must have been passed through enc_canonize() already.\n * Sets the \"enc_unicode\", \"enc_utf8\", \"enc_dbcs\" and \"has_mbyte\" flags.\n * Fills mb_bytelen_tab[] and returns NULL when there are no problems.\n * When there is something wrong: Returns an error message and doesn't change\n * anything.\n */\n    char *\nmb_init(void)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\tn;\n    int\t\tenc_dbcs_new = 0;\n#if defined(USE_ICONV) && !defined(MSWIN) && !defined(WIN32UNIX) \\\n\t&& !defined(MACOS_CONVERT)\n# define LEN_FROM_CONV\n    vimconv_T\tvimconv;\n    char_u\t*p;\n#endif\n\n    if (p_enc == NULL)\n    {\n\t// Just starting up: set the whole table to one's.\n\tfor (i = 0; i < 256; ++i)\n\t    mb_bytelen_tab[i] = 1;\n\tinput_conv.vc_type = CONV_NONE;\n\tinput_conv.vc_factor = 1;\n\toutput_conv.vc_type = CONV_NONE;\n\treturn NULL;\n    }\n\n#ifdef MSWIN\n    if (p_enc[0] == 'c' && p_enc[1] == 'p' && VIM_ISDIGIT(p_enc[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)p_enc + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1)\n\t    {\n\t\t// some single-byte encoding\n\t\tenc_unicode = 0;\n\t\tenc_utf8 = FALSE;\n\t    }\n\t    else if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t    {\n\t\t// must be a DBCS encoding, check below\n\t\tenc_dbcs_new = atoi((char *)p_enc + 2);\n\t    }\n\t    else\n\t\tgoto codepage_invalid;\n\t}\n\telse if (GetLastError() == ERROR_INVALID_PARAMETER)\n\t{\ncodepage_invalid:\n\t    return N_(e_not_valid_codepage);\n\t}\n    }\n#endif\n    else if (STRNCMP(p_enc, \"8bit-\", 5) == 0\n\t    || STRNCMP(p_enc, \"iso-8859-\", 9) == 0)\n    {\n\t// Accept any \"8bit-\" or \"iso-8859-\" name.\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n    {\n#ifdef MSWIN\n\t// Windows: accept only valid codepage numbers, check below.\n\tif (p_enc[6] != 'c' || p_enc[7] != 'p'\n\t\t\t      || (enc_dbcs_new = atoi((char *)p_enc + 8)) == 0)\n\t    return e_invalid_argument;\n#else\n\t// Unix: accept any \"2byte-\" name, assume current locale.\n\tenc_dbcs_new = DBCS_2BYTE;\n#endif\n    }\n    else if ((idx = enc_canon_search(p_enc)) >= 0)\n    {\n\ti = enc_canon_table[idx].prop;\n\tif (i & ENC_UNICODE)\n\t{\n\t    // Unicode\n\t    enc_utf8 = TRUE;\n\t    if (i & (ENC_2BYTE | ENC_2WORD))\n\t\tenc_unicode = 2;\n\t    else if (i & ENC_4BYTE)\n\t\tenc_unicode = 4;\n\t    else\n\t\tenc_unicode = 0;\n\t}\n\telse if (i & ENC_DBCS)\n\t{\n\t    // 2byte, handle below\n\t    enc_dbcs_new = enc_canon_table[idx].codepage;\n\t}\n\telse\n\t{\n\t    // Must be 8-bit.\n\t    enc_unicode = 0;\n\t    enc_utf8 = FALSE;\n\t}\n    }\n    else    // Don't know what encoding this is, reject it.\n\treturn e_invalid_argument;\n\n    if (enc_dbcs_new != 0)\n    {\n#ifdef MSWIN\n\t// Check if the DBCS code page is OK.\n\tif (!IsValidCodePage(enc_dbcs_new))\n\t    goto codepage_invalid;\n#endif\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    enc_dbcs = enc_dbcs_new;\n    has_mbyte = (enc_dbcs != 0 || enc_utf8);\n\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    enc_codepage = encname2codepage(p_enc);\n    enc_latin9 = (STRCMP(p_enc, \"iso-8859-15\") == 0);\n#endif\n\n    // Detect an encoding that uses latin1 characters.\n    enc_latin1like = (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t|| STRCMP(p_enc, \"iso-8859-15\") == 0);\n\n    /*\n     * Set the function pointers.\n     */\n    if (enc_utf8)\n    {\n\tmb_ptr2len = utfc_ptr2len;\n\tmb_ptr2len_len = utfc_ptr2len_len;\n\tmb_char2len = utf_char2len;\n\tmb_char2bytes = utf_char2bytes;\n\tmb_ptr2cells = utf_ptr2cells;\n\tmb_ptr2cells_len = utf_ptr2cells_len;\n\tmb_char2cells = utf_char2cells;\n\tmb_off2cells = utf_off2cells;\n\tmb_ptr2char = utf_ptr2char;\n\tmb_head_off = utf_head_off;\n    }\n    else if (enc_dbcs != 0)\n    {\n\tmb_ptr2len = dbcs_ptr2len;\n\tmb_ptr2len_len = dbcs_ptr2len_len;\n\tmb_char2len = dbcs_char2len;\n\tmb_char2bytes = dbcs_char2bytes;\n\tmb_ptr2cells = dbcs_ptr2cells;\n\tmb_ptr2cells_len = dbcs_ptr2cells_len;\n\tmb_char2cells = dbcs_char2cells;\n\tmb_off2cells = dbcs_off2cells;\n\tmb_ptr2char = dbcs_ptr2char;\n\tmb_head_off = dbcs_head_off;\n    }\n    else\n    {\n\tmb_ptr2len = latin_ptr2len;\n\tmb_ptr2len_len = latin_ptr2len_len;\n\tmb_char2len = latin_char2len;\n\tmb_char2bytes = latin_char2bytes;\n\tmb_ptr2cells = latin_ptr2cells;\n\tmb_ptr2cells_len = latin_ptr2cells_len;\n\tmb_char2cells = latin_char2cells;\n\tmb_off2cells = latin_off2cells;\n\tmb_ptr2char = latin_ptr2char;\n\tmb_head_off = latin_head_off;\n    }\n\n    /*\n     * Fill the mb_bytelen_tab[] for MB_BYTE2LEN().\n     */\n#ifdef LEN_FROM_CONV\n    // When 'encoding' is different from the current locale mblen() won't\n    // work.  Use conversion to \"utf-8\" instead.\n    vimconv.vc_type = CONV_NONE;\n    if (enc_dbcs)\n    {\n\tp = enc_locale();\n\tif (p == NULL || STRCMP(p, p_enc) != 0)\n\t{\n\t    convert_setup(&vimconv, p_enc, (char_u *)\"utf-8\");\n\t    vimconv.vc_fail = TRUE;\n\t}\n\tvim_free(p);\n    }\n#endif\n\n    for (i = 0; i < 256; ++i)\n    {\n\t// Our own function to reliably check the length of UTF-8 characters,\n\t// independent of mblen().\n\tif (enc_utf8)\n\t    n = utf8len_tab[i];\n\telse if (enc_dbcs == 0)\n\t    n = 1;\n\telse\n\t{\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t    // enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows\n\t    // CodePage identifier, which we can pass directly in to Windows\n\t    // API\n\t    n = IsDBCSLeadByteEx(enc_dbcs, (WINBYTE)i) ? 2 : 1;\n#else\n# if defined(__amigaos4__) || defined(__ANDROID__) || \\\n\t\t\t\t   !(defined(HAVE_MBLEN) || defined(X_LOCALE))\n\t    /*\n\t     * if mblen() is not available, character which MSB is turned on\n\t     * are treated as leading byte character. (note : This assumption\n\t     * is not always true.)\n\t     */\n\t    n = (i & 0x80) ? 2 : 1;\n# else\n\t    char buf[MB_MAXBYTES + 1];\n\n\t    if (i == NUL)\t// just in case mblen() can't handle \"\"\n\t\tn = 1;\n\t    else\n\t    {\n\t\tbuf[0] = i;\n\t\tbuf[1] = 0;\n#  ifdef LEN_FROM_CONV\n\t\tif (vimconv.vc_type != CONV_NONE)\n\t\t{\n\t\t    /*\n\t\t     * string_convert() should fail when converting the first\n\t\t     * byte of a double-byte character.\n\t\t     */\n\t\t    p = string_convert(&vimconv, (char_u *)buf, NULL);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tvim_free(p);\n\t\t\tn = 1;\n\t\t    }\n\t\t    else\n\t\t\tn = 2;\n\t\t}\n\t\telse\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * mblen() should return -1 for invalid (means the leading\n\t\t     * multibyte) character.  However there are some platforms\n\t\t     * where mblen() returns 0 for invalid character.\n\t\t     * Therefore, following condition includes 0.\n\t\t     */\n\t\t    vim_ignored = mblen(NULL, 0);  // First reset the state.\n\t\t    if (mblen(buf, (size_t)1) <= 0)\n\t\t\tn = 2;\n\t\t    else\n\t\t\tn = 1;\n\t\t}\n\t    }\n# endif\n#endif\n\t}\n\n\tmb_bytelen_tab[i] = n;\n    }\n\n#ifdef LEN_FROM_CONV\n    convert_setup(&vimconv, NULL, NULL);\n#endif\n\n    // The cell width depends on the type of multi-byte characters.\n    (void)init_chartab();\n\n    // When enc_utf8 is set or reset, (de)allocate ScreenLinesUC[]\n    screenalloc(FALSE);\n\n    // When using Unicode, set default for 'fileencodings'.\n    if (enc_utf8 && !option_was_set((char_u *)\"fencs\"))\n\tset_fencs_unicode();\n\n#if defined(HAVE_BIND_TEXTDOMAIN_CODESET) && defined(FEAT_GETTEXT)\n    // GNU gettext 0.10.37 supports this feature: set the codeset used for\n    // translated messages independently from the current locale.\n    (void)bind_textdomain_codeset(VIMPACKAGE,\n\t\t\t\t\t  enc_utf8 ? \"utf-8\" : (char *)p_enc);\n#endif\n\n#ifdef MSWIN\n    // When changing 'encoding' while starting up, then convert the command\n    // line arguments from the active codepage to 'encoding'.\n    if (starting != 0)\n\tfix_arg_enc();\n#endif\n\n    // Fire an autocommand to let people do custom font setup. This must be\n    // after Vim has been setup for the new encoding.\n    apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)\"\", FALSE, curbuf);\n\n#ifdef FEAT_SPELL\n    // Need to reload spell dictionaries\n    spell_reload();\n#endif\n\n    return NULL;\n}\n\n/*\n * Return the size of the BOM for the current buffer:\n * 0 - no BOM\n * 2 - UCS-2 or UTF-16 BOM\n * 4 - UCS-4 BOM\n * 3 - UTF-8 BOM\n */\n    int\nbomb_size(void)\n{\n    int n = 0;\n\n    if (curbuf->b_p_bomb && !curbuf->b_p_bin)\n    {\n\tif (*curbuf->b_p_fenc == NUL)\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tif (enc_unicode != 0)\n\t\t    n = enc_unicode;\n\t\telse\n\t\t    n = 3;\n\t    }\n\t}\n\telse if (STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0)\n\t    n = 3;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-2\", 5) == 0\n\t\t|| STRNCMP(curbuf->b_p_fenc, \"utf-16\", 6) == 0)\n\t    n = 2;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-4\", 5) == 0)\n\t    n = 4;\n    }\n    return n;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Remove all BOM from \"s\" by moving remaining text.\n */\n    void\nremove_bom(char_u *s)\n{\n    if (enc_utf8)\n    {\n\tchar_u *p = s;\n\n\twhile ((p = vim_strbyte(p, 0xef)) != NULL)\n\t{\n\t    if (p[1] == 0xbb && p[2] == 0xbf)\n\t\tSTRMOVE(p, p + 3);\n\t    else\n\t\t++p;\n\t}\n    }\n}\n#endif\n\n/*\n * Get class of pointer:\n * 0 for blank or NUL\n * 1 for punctuation\n * 2 for an (ASCII) word character\n * >2 for other word characters\n */\n    int\nmb_get_class(char_u *p)\n{\n    return mb_get_class_buf(p, curbuf);\n}\n\n    int\nmb_get_class_buf(char_u *p, buf_T *buf)\n{\n    if (MB_BYTE2LEN(p[0]) == 1)\n    {\n\tif (p[0] == NUL || VIM_ISWHITE(p[0]))\n\t    return 0;\n\tif (vim_iswordc_buf(p[0], buf))\n\t    return 2;\n\treturn 1;\n    }\n    if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)\n\treturn dbcs_class(p[0], p[1]);\n    if (enc_utf8)\n\treturn utf_class_buf(utf_ptr2char(p), buf);\n    return 0;\n}\n\n/*\n * Get class of a double-byte character.  This always returns 3 or bigger.\n * TODO: Should return 1 for punctuation.\n */\n    int\ndbcs_class(unsigned lead, unsigned trail)\n{\n    switch (enc_dbcs)\n    {\n\t// please add classify routine for your language in here\n\n\tcase DBCS_JPNU:\t// ?\n\tcase DBCS_JPN:\n\t    {\n\t\t// JIS code classification\n\t\tunsigned char lb = lead;\n\t\tunsigned char tb = trail;\n\n\t\t// convert process code to JIS\n# if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n\t\t// process code is SJIS\n\t\tif (lb <= 0x9f)\n\t\t    lb = (lb - 0x81) * 2 + 0x21;\n\t\telse\n\t\t    lb = (lb - 0xc1) * 2 + 0x21;\n\t\tif (tb <= 0x7e)\n\t\t    tb -= 0x1f;\n\t\telse if (tb <= 0x9e)\n\t\t    tb -= 0x20;\n\t\telse\n\t\t{\n\t\t    tb -= 0x7e;\n\t\t    lb += 1;\n\t\t}\n# else\n\t\t/*\n\t\t * XXX: Code page identification can not use with all\n\t\t *\t    system! So, some other encoding information\n\t\t *\t    will be needed.\n\t\t *\t    In japanese: SJIS,EUC,UNICODE,(JIS)\n\t\t *\t    Note that JIS-code system don't use as\n\t\t *\t    process code in most system because it uses\n\t\t *\t    escape sequences(JIS is context depend encoding).\n\t\t */\n\t\t// assume process code is JAPANESE-EUC\n\t\tlb &= 0x7f;\n\t\ttb &= 0x7f;\n# endif\n\t\t// exceptions\n\t\tswitch (lb << 8 | tb)\n\t\t{\n\t\t    case 0x2121: // ZENKAKU space\n\t\t\treturn 0;\n\t\t    case 0x2122: // TOU-TEN (Japanese comma)\n\t\t    case 0x2123: // KU-TEN (Japanese period)\n\t\t    case 0x2124: // ZENKAKU comma\n\t\t    case 0x2125: // ZENKAKU period\n\t\t\treturn 1;\n\t\t    case 0x213c: // prolongedsound handled as KATAKANA\n\t\t\treturn 13;\n\t\t}\n\t\t// sieved by KU code\n\t\tswitch (lb)\n\t\t{\n\t\t    case 0x21:\n\t\t    case 0x22:\n\t\t\t// special symbols\n\t\t\treturn 10;\n\t\t    case 0x23:\n\t\t\t// alphanumeric\n\t\t\treturn 11;\n\t\t    case 0x24:\n\t\t\t// hiragana\n\t\t\treturn 12;\n\t\t    case 0x25:\n\t\t\t// katakana\n\t\t\treturn 13;\n\t\t    case 0x26:\n\t\t\t// greek\n\t\t\treturn 14;\n\t\t    case 0x27:\n\t\t\t// russian\n\t\t\treturn 15;\n\t\t    case 0x28:\n\t\t\t// lines\n\t\t\treturn 16;\n\t\t    default:\n\t\t\t// kanji\n\t\t\treturn 17;\n\t\t}\n\t    }\n\n\tcase DBCS_KORU:\t// ?\n\tcase DBCS_KOR:\n\t    {\n\t\t// KS code classification\n\t\tunsigned char c1 = lead;\n\t\tunsigned char c2 = trail;\n\n\t\t/*\n\t\t * 20 : Hangul\n\t\t * 21 : Hanja\n\t\t * 22 : Symbols\n\t\t * 23 : Alphanumeric/Roman Letter (Full width)\n\t\t * 24 : Hangul Letter(Alphabet)\n\t\t * 25 : Roman Numeral/Greek Letter\n\t\t * 26 : Box Drawings\n\t\t * 27 : Unit Symbols\n\t\t * 28 : Circled/Parenthesized Letter\n\t\t * 29 : Hiragana/Katakana\n\t\t * 30 : Cyrillic Letter\n\t\t */\n\n\t\tif (c1 >= 0xB0 && c1 <= 0xC8)\n\t\t    // Hangul\n\t\t    return 20;\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t\telse if (c1 <= 0xA0 || c2 <= 0xA0)\n\t\t    // Extended Hangul Region : MS UHC(Unified Hangul Code)\n\t\t    // c1: 0x81-0xA0 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE\n\t\t    // c1: 0xA1-0xC6 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xA0\n\t\t    return 20;\n#endif\n\n\t\telse if (c1 >= 0xCA && c1 <= 0xFD)\n\t\t    // Hanja\n\t\t    return 21;\n\t\telse switch (c1)\n\t\t{\n\t\t    case 0xA1:\n\t\t    case 0xA2:\n\t\t\t// Symbols\n\t\t\treturn 22;\n\t\t    case 0xA3:\n\t\t\t// Alphanumeric\n\t\t\treturn 23;\n\t\t    case 0xA4:\n\t\t\t// Hangul Letter(Alphabet)\n\t\t\treturn 24;\n\t\t    case 0xA5:\n\t\t\t// Roman Numeral/Greek Letter\n\t\t\treturn 25;\n\t\t    case 0xA6:\n\t\t\t// Box Drawings\n\t\t\treturn 26;\n\t\t    case 0xA7:\n\t\t\t// Unit Symbols\n\t\t\treturn 27;\n\t\t    case 0xA8:\n\t\t    case 0xA9:\n\t\t\tif (c2 <= 0xAF)\n\t\t\t    return 25;  // Roman Letter\n\t\t\telse if (c2 >= 0xF6)\n\t\t\t    return 22;  // Symbols\n\t\t\telse\n\t\t\t    // Circled/Parenthesized Letter\n\t\t\t    return 28;\n\t\t    case 0xAA:\n\t\t    case 0xAB:\n\t\t\t// Hiragana/Katakana\n\t\t\treturn 29;\n\t\t    case 0xAC:\n\t\t\t// Cyrillic Letter\n\t\t\treturn 30;\n\t\t}\n\t    }\n\tdefault:\n\t    break;\n    }\n    return 3;\n}\n\n/*\n * mb_char2len() function pointer.\n * Return length in bytes of character \"c\".\n * Returns 1 for a single-byte character.\n */\n    int\nlatin_char2len(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2len(\n    int\t\tc)\n{\n    if (c >= 0x100)\n\treturn 2;\n    return 1;\n}\n\n/*\n * mb_char2bytes() function pointer.\n * Convert a character to its bytes.\n * Returns the length in bytes.\n */\n    int\nlatin_char2bytes(int c, char_u *buf)\n{\n    buf[0] = c;\n    return 1;\n}\n\n    static int\ndbcs_char2bytes(int c, char_u *buf)\n{\n    if (c >= 0x100)\n    {\n\tbuf[0] = (unsigned)c >> 8;\n\tbuf[1] = c;\n\t// Never use a NUL byte, it causes lots of trouble.  It's an invalid\n\t// character anyway.\n\tif (buf[1] == NUL)\n\t    buf[1] = '\\n';\n\treturn 2;\n    }\n    buf[0] = c;\n    return 1;\n}\n\n/*\n * mb_ptr2len() function pointer.\n * Get byte length of character at \"*p\" but stop at a NUL.\n * For UTF-8 this includes following composing characters.\n * Returns 0 when *p is NUL.\n */\n    int\nlatin_ptr2len(char_u *p)\n{\n return MB_BYTE2LEN(*p);\n}\n\n    static int\ndbcs_ptr2len(\n    char_u\t*p)\n{\n    int\t\tlen;\n\n    // Check if second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\n/*\n * mb_ptr2len_len() function pointer.\n * Like mb_ptr2len(), but limit to read \"size\" bytes.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nlatin_ptr2len_len(char_u *p, int size)\n{\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    return 1;\n}\n\n    static int\ndbcs_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (size == 1)\n\treturn 1;\n    // Check that second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\nstruct interval\n{\n    long first;\n    long last;\n};\n\n/*\n * Return TRUE if \"c\" is in \"table[size / sizeof(struct interval)]\".\n */\n    static int\nintable(struct interval *table, size_t size, int c)\n{\n    int mid, bot, top;\n\n    // first quick check for Latin1 etc. characters\n    if (c < table[0].first)\n\treturn FALSE;\n\n    // binary search in table\n    bot = 0;\n    top = (int)(size / sizeof(struct interval) - 1);\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Sorted list of non-overlapping intervals of East Asian Ambiguous\n// characters, generated with ../runtime/tools/unicode.vim.\nstatic struct interval ambiguous[] =\n{\n    {0x00a1, 0x00a1},\n    {0x00a4, 0x00a4},\n    {0x00a7, 0x00a8},\n    {0x00aa, 0x00aa},\n    {0x00ad, 0x00ae},\n    {0x00b0, 0x00b4},\n    {0x00b6, 0x00ba},\n    {0x00bc, 0x00bf},\n    {0x00c6, 0x00c6},\n    {0x00d0, 0x00d0},\n    {0x00d7, 0x00d8},\n    {0x00de, 0x00e1},\n    {0x00e6, 0x00e6},\n    {0x00e8, 0x00ea},\n    {0x00ec, 0x00ed},\n    {0x00f0, 0x00f0},\n    {0x00f2, 0x00f3},\n    {0x00f7, 0x00fa},\n    {0x00fc, 0x00fc},\n    {0x00fe, 0x00fe},\n    {0x0101, 0x0101},\n    {0x0111, 0x0111},\n    {0x0113, 0x0113},\n    {0x011b, 0x011b},\n    {0x0126, 0x0127},\n    {0x012b, 0x012b},\n    {0x0131, 0x0133},\n    {0x0138, 0x0138},\n    {0x013f, 0x0142},\n    {0x0144, 0x0144},\n    {0x0148, 0x014b},\n    {0x014d, 0x014d},\n    {0x0152, 0x0153},\n    {0x0166, 0x0167},\n    {0x016b, 0x016b},\n    {0x01ce, 0x01ce},\n    {0x01d0, 0x01d0},\n    {0x01d2, 0x01d2},\n    {0x01d4, 0x01d4},\n    {0x01d6, 0x01d6},\n    {0x01d8, 0x01d8},\n    {0x01da, 0x01da},\n    {0x01dc, 0x01dc},\n    {0x0251, 0x0251},\n    {0x0261, 0x0261},\n    {0x02c4, 0x02c4},\n    {0x02c7, 0x02c7},\n    {0x02c9, 0x02cb},\n    {0x02cd, 0x02cd},\n    {0x02d0, 0x02d0},\n    {0x02d8, 0x02db},\n    {0x02dd, 0x02dd},\n    {0x02df, 0x02df},\n    {0x0300, 0x036f},\n    {0x0391, 0x03a1},\n    {0x03a3, 0x03a9},\n    {0x03b1, 0x03c1},\n    {0x03c3, 0x03c9},\n    {0x0401, 0x0401},\n    {0x0410, 0x044f},\n    {0x0451, 0x0451},\n    {0x2010, 0x2010},\n    {0x2013, 0x2016},\n    {0x2018, 0x2019},\n    {0x201c, 0x201d},\n    {0x2020, 0x2022},\n    {0x2024, 0x2027},\n    {0x2030, 0x2030},\n    {0x2032, 0x2033},\n    {0x2035, 0x2035},\n    {0x203b, 0x203b},\n    {0x203e, 0x203e},\n    {0x2074, 0x2074},\n    {0x207f, 0x207f},\n    {0x2081, 0x2084},\n    {0x20ac, 0x20ac},\n    {0x2103, 0x2103},\n    {0x2105, 0x2105},\n    {0x2109, 0x2109},\n    {0x2113, 0x2113},\n    {0x2116, 0x2116},\n    {0x2121, 0x2122},\n    {0x2126, 0x2126},\n    {0x212b, 0x212b},\n    {0x2153, 0x2154},\n    {0x215b, 0x215e},\n    {0x2160, 0x216b},\n    {0x2170, 0x2179},\n    {0x2189, 0x2189},\n    {0x2190, 0x2199},\n    {0x21b8, 0x21b9},\n    {0x21d2, 0x21d2},\n    {0x21d4, 0x21d4},\n    {0x21e7, 0x21e7},\n    {0x2200, 0x2200},\n    {0x2202, 0x2203},\n    {0x2207, 0x2208},\n    {0x220b, 0x220b},\n    {0x220f, 0x220f},\n    {0x2211, 0x2211},\n    {0x2215, 0x2215},\n    {0x221a, 0x221a},\n    {0x221d, 0x2220},\n    {0x2223, 0x2223},\n    {0x2225, 0x2225},\n    {0x2227, 0x222c},\n    {0x222e, 0x222e},\n    {0x2234, 0x2237},\n    {0x223c, 0x223d},\n    {0x2248, 0x2248},\n    {0x224c, 0x224c},\n    {0x2252, 0x2252},\n    {0x2260, 0x2261},\n    {0x2264, 0x2267},\n    {0x226a, 0x226b},\n    {0x226e, 0x226f},\n    {0x2282, 0x2283},\n    {0x2286, 0x2287},\n    {0x2295, 0x2295},\n    {0x2299, 0x2299},\n    {0x22a5, 0x22a5},\n    {0x22bf, 0x22bf},\n    {0x2312, 0x2312},\n    {0x2460, 0x24e9},\n    {0x24eb, 0x254b},\n    {0x2550, 0x2573},\n    {0x2580, 0x258f},\n    {0x2592, 0x2595},\n    {0x25a0, 0x25a1},\n    {0x25a3, 0x25a9},\n    {0x25b2, 0x25b3},\n    {0x25b6, 0x25b7},\n    {0x25bc, 0x25bd},\n    {0x25c0, 0x25c1},\n    {0x25c6, 0x25c8},\n    {0x25cb, 0x25cb},\n    {0x25ce, 0x25d1},\n    {0x25e2, 0x25e5},\n    {0x25ef, 0x25ef},\n    {0x2605, 0x2606},\n    {0x2609, 0x2609},\n    {0x260e, 0x260f},\n    {0x261c, 0x261c},\n    {0x261e, 0x261e},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2660, 0x2661},\n    {0x2663, 0x2665},\n    {0x2667, 0x266a},\n    {0x266c, 0x266d},\n    {0x266f, 0x266f},\n    {0x269e, 0x269f},\n    {0x26bf, 0x26bf},\n    {0x26c6, 0x26cd},\n    {0x26cf, 0x26d3},\n    {0x26d5, 0x26e1},\n    {0x26e3, 0x26e3},\n    {0x26e8, 0x26e9},\n    {0x26eb, 0x26f1},\n    {0x26f4, 0x26f4},\n    {0x26f6, 0x26f9},\n    {0x26fb, 0x26fc},\n    {0x26fe, 0x26ff},\n    {0x273d, 0x273d},\n    {0x2776, 0x277f},\n    {0x2b56, 0x2b59},\n    {0x3248, 0x324f},\n    {0xe000, 0xf8ff},\n    {0xfe00, 0xfe0f},\n    {0xfffd, 0xfffd},\n    {0x1f100, 0x1f10a},\n    {0x1f110, 0x1f12d},\n    {0x1f130, 0x1f169},\n    {0x1f170, 0x1f18d},\n    {0x1f18f, 0x1f190},\n    {0x1f19b, 0x1f1ac},\n    {0xe0100, 0xe01ef},\n    {0xf0000, 0xffffd},\n    {0x100000, 0x10fffd}\n};\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_char2cells() with different argument type for libvterm.\n */\n    int\nutf_uint2cells(UINT32_T c)\n{\n    if (c >= 0x100 && utf_iscomposing((int)c))\n\treturn 0;\n    return utf_char2cells((int)c);\n}\n#endif\n\n/*\n * For UTF-8 character \"c\" return 2 for a double-width character, 1 for others.\n * Returns 4 or 6 for an unprintable character.\n * Is only correct for characters >= 0x80.\n * When p_ambw is \"double\", return 2 for a character with East Asian Width\n * class 'A'(mbiguous).\n */\n    int\nutf_char2cells(int c)\n{\n    // Sorted list of non-overlapping intervals of East Asian double width\n    // characters, generated with ../runtime/tools/unicode.vim.\n    static struct interval doublewidth[] =\n    {\n\t{0x1100, 0x115f},\n\t{0x231a, 0x231b},\n\t{0x2329, 0x232a},\n\t{0x23e9, 0x23ec},\n\t{0x23f0, 0x23f0},\n\t{0x23f3, 0x23f3},\n\t{0x25fd, 0x25fe},\n\t{0x2614, 0x2615},\n\t{0x2648, 0x2653},\n\t{0x267f, 0x267f},\n\t{0x2693, 0x2693},\n\t{0x26a1, 0x26a1},\n\t{0x26aa, 0x26ab},\n\t{0x26bd, 0x26be},\n\t{0x26c4, 0x26c5},\n\t{0x26ce, 0x26ce},\n\t{0x26d4, 0x26d4},\n\t{0x26ea, 0x26ea},\n\t{0x26f2, 0x26f3},\n\t{0x26f5, 0x26f5},\n\t{0x26fa, 0x26fa},\n\t{0x26fd, 0x26fd},\n\t{0x2705, 0x2705},\n\t{0x270a, 0x270b},\n\t{0x2728, 0x2728},\n\t{0x274c, 0x274c},\n\t{0x274e, 0x274e},\n\t{0x2753, 0x2755},\n\t{0x2757, 0x2757},\n\t{0x2795, 0x2797},\n\t{0x27b0, 0x27b0},\n\t{0x27bf, 0x27bf},\n\t{0x2b1b, 0x2b1c},\n\t{0x2b50, 0x2b50},\n\t{0x2b55, 0x2b55},\n\t{0x2e80, 0x2e99},\n\t{0x2e9b, 0x2ef3},\n\t{0x2f00, 0x2fd5},\n\t{0x2ff0, 0x2ffb},\n\t{0x3000, 0x303e},\n\t{0x3041, 0x3096},\n\t{0x3099, 0x30ff},\n\t{0x3105, 0x312f},\n\t{0x3131, 0x318e},\n\t{0x3190, 0x31e3},\n\t{0x31f0, 0x321e},\n\t{0x3220, 0x3247},\n\t{0x3250, 0x4dbf},\n\t{0x4e00, 0xa48c},\n\t{0xa490, 0xa4c6},\n\t{0xa960, 0xa97c},\n\t{0xac00, 0xd7a3},\n\t{0xf900, 0xfaff},\n\t{0xfe10, 0xfe19},\n\t{0xfe30, 0xfe52},\n\t{0xfe54, 0xfe66},\n\t{0xfe68, 0xfe6b},\n\t{0xff01, 0xff60},\n\t{0xffe0, 0xffe6},\n\t{0x16fe0, 0x16fe3},\n\t{0x16ff0, 0x16ff1},\n\t{0x17000, 0x187f7},\n\t{0x18800, 0x18cd5},\n\t{0x18d00, 0x18d08},\n\t{0x1b000, 0x1b11e},\n\t{0x1b150, 0x1b152},\n\t{0x1b164, 0x1b167},\n\t{0x1b170, 0x1b2fb},\n\t{0x1f004, 0x1f004},\n\t{0x1f0cf, 0x1f0cf},\n\t{0x1f18e, 0x1f18e},\n\t{0x1f191, 0x1f19a},\n\t{0x1f200, 0x1f202},\n\t{0x1f210, 0x1f23b},\n\t{0x1f240, 0x1f248},\n\t{0x1f250, 0x1f251},\n\t{0x1f260, 0x1f265},\n\t{0x1f300, 0x1f320},\n\t{0x1f32d, 0x1f335},\n\t{0x1f337, 0x1f37c},\n\t{0x1f37e, 0x1f393},\n\t{0x1f3a0, 0x1f3ca},\n\t{0x1f3cf, 0x1f3d3},\n\t{0x1f3e0, 0x1f3f0},\n\t{0x1f3f4, 0x1f3f4},\n\t{0x1f3f8, 0x1f43e},\n\t{0x1f440, 0x1f440},\n\t{0x1f442, 0x1f4fc},\n\t{0x1f4ff, 0x1f53d},\n\t{0x1f54b, 0x1f54e},\n\t{0x1f550, 0x1f567},\n\t{0x1f57a, 0x1f57a},\n\t{0x1f595, 0x1f596},\n\t{0x1f5a4, 0x1f5a4},\n\t{0x1f5fb, 0x1f64f},\n\t{0x1f680, 0x1f6c5},\n\t{0x1f6cc, 0x1f6cc},\n\t{0x1f6d0, 0x1f6d2},\n\t{0x1f6d5, 0x1f6d7},\n\t{0x1f6eb, 0x1f6ec},\n\t{0x1f6f4, 0x1f6fc},\n\t{0x1f7e0, 0x1f7eb},\n\t{0x1f90c, 0x1f93a},\n\t{0x1f93c, 0x1f945},\n\t{0x1f947, 0x1f978},\n\t{0x1f97a, 0x1f9cb},\n\t{0x1f9cd, 0x1f9ff},\n\t{0x1fa70, 0x1fa74},\n\t{0x1fa78, 0x1fa7a},\n\t{0x1fa80, 0x1fa86},\n\t{0x1fa90, 0x1faa8},\n\t{0x1fab0, 0x1fab6},\n\t{0x1fac0, 0x1fac2},\n\t{0x1fad0, 0x1fad6},\n\t{0x20000, 0x2fffd},\n\t{0x30000, 0x3fffd}\n    };\n\n    // Sorted list of non-overlapping intervals of Emoji characters that don't\n    // have ambiguous or double width,\n    // based on http://unicode.org/emoji/charts/emoji-list.html\n    static struct interval emoji_wide[] =\n    {\n\t{0x23ed, 0x23ef},\n\t{0x23f1, 0x23f2},\n\t{0x23f8, 0x23fa},\n\t{0x24c2, 0x24c2},\n\t{0x261d, 0x261d},\n\t{0x26c8, 0x26c8},\n\t{0x26cf, 0x26cf},\n\t{0x26d1, 0x26d1},\n\t{0x26d3, 0x26d3},\n\t{0x26e9, 0x26e9},\n\t{0x26f0, 0x26f1},\n\t{0x26f7, 0x26f9},\n\t{0x270c, 0x270d},\n\t{0x2934, 0x2935},\n\t{0x1f170, 0x1f189},\n\t{0x1f1e6, 0x1f1ff},\n\t{0x1f321, 0x1f321},\n\t{0x1f324, 0x1f32c},\n\t{0x1f336, 0x1f336},\n\t{0x1f37d, 0x1f37d},\n\t{0x1f396, 0x1f397},\n\t{0x1f399, 0x1f39b},\n\t{0x1f39e, 0x1f39f},\n\t{0x1f3cb, 0x1f3ce},\n\t{0x1f3d4, 0x1f3df},\n\t{0x1f3f3, 0x1f3f5},\n\t{0x1f3f7, 0x1f3f7},\n\t{0x1f43f, 0x1f43f},\n\t{0x1f441, 0x1f441},\n\t{0x1f4fd, 0x1f4fd},\n\t{0x1f549, 0x1f54a},\n\t{0x1f56f, 0x1f570},\n\t{0x1f573, 0x1f579},\n\t{0x1f587, 0x1f587},\n\t{0x1f58a, 0x1f58d},\n\t{0x1f590, 0x1f590},\n\t{0x1f5a5, 0x1f5a5},\n\t{0x1f5a8, 0x1f5a8},\n\t{0x1f5b1, 0x1f5b2},\n\t{0x1f5bc, 0x1f5bc},\n\t{0x1f5c2, 0x1f5c4},\n\t{0x1f5d1, 0x1f5d3},\n\t{0x1f5dc, 0x1f5de},\n\t{0x1f5e1, 0x1f5e1},\n\t{0x1f5e3, 0x1f5e3},\n\t{0x1f5e8, 0x1f5e8},\n\t{0x1f5ef, 0x1f5ef},\n\t{0x1f5f3, 0x1f5f3},\n\t{0x1f5fa, 0x1f5fa},\n\t{0x1f6cb, 0x1f6cf},\n\t{0x1f6e0, 0x1f6e5},\n\t{0x1f6e9, 0x1f6e9},\n\t{0x1f6f0, 0x1f6f0},\n\t{0x1f6f3, 0x1f6f3}\n\n#ifdef MACOS_X\n\t// Include SF Symbols characters, which should be rendered as\n\t// double-width. All of them are in the Supplementary Private Use\n\t// Area-B range. The exact range was determined by downloading the \"SF\n\t// Symbols\" app from Apple, and then selecting all symbols, copying\n\t// them out, and inspecting the unicode values of them.\n\t, {0x100000, 0x100d7f}\n#endif\n    };\n\n    if (c >= 0x100)\n    {\n#if defined(FEAT_EVAL) || defined(USE_WCHAR_FUNCTIONS)\n\tint\tn;\n#endif\n\n#ifdef FEAT_EVAL\n\tn = cw_value(c);\n\tif (n != 0)\n\t    return n;\n#endif\n\n#ifdef USE_WCHAR_FUNCTIONS\n\t/*\n\t * Assume the library function wcwidth() works better than our own\n\t * stuff.  It should return 1 for ambiguous width chars!\n\t */\n\tn = wcwidth(c);\n\n\tif (n < 0)\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (n > 1)\n\t    return n;\n#else\n\tif (!utf_printable(c))\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (intable(doublewidth, sizeof(doublewidth), c))\n\t    return 2;\n#endif\n\tif (p_emoji && intable(emoji_wide, sizeof(emoji_wide), c))\n\t    return 2;\n    }\n\n    // Characters below 0x100 are influenced by 'isprint' option\n    else if (c >= 0x80 && !vim_isprintc(c))\n\treturn 4;\t\t// unprintable, displays <xx>\n\n    if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, sizeof(ambiguous), c))\n\treturn 2;\n\n    return 1;\n}\n\n/*\n * mb_ptr2cells() function pointer.\n * Return the number of display cells character at \"*p\" occupies.\n * This doesn't take care of unprintable characters, use ptr2cells() for that.\n */\n    int\nlatin_ptr2cells(char_u *p UNUSED)\n{\n    return 1;\n}\n\n    int\nutf_ptr2cells(\n    char_u\t*p)\n{\n    int\t\tc;\n\n    // Need to convert to a character number.\n    if (*p >= 0x80)\n    {\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    int\ndbcs_ptr2cells(char_u *p)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_ptr2cells_len() function pointer.\n * Like mb_ptr2cells(), but limit string length to \"size\".\n * For an empty string or truncated character returns 1.\n */\n    int\nlatin_ptr2cells_len(char_u *p UNUSED, int size UNUSED)\n{\n    return 1;\n}\n\n    static int\nutf_ptr2cells_len(char_u *p, int size)\n{\n    int\t\tc;\n\n    // Need to convert to a wide character.\n    if (size > 0 && *p >= 0x80)\n    {\n\tif (utf_ptr2len_len(p, size) < utf8len_tab[*p])\n\t    return 1;  // truncated\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    static int\ndbcs_ptr2cells_len(char_u *p, int size)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_char2cells() function pointer.\n * Return the number of display cells character \"c\" occupies.\n * Only takes care of multi-byte chars, not \"^C\" and such.\n */\n    int\nlatin_char2cells(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2cells(int c)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\treturn 1;\n    // use the first byte\n    return MB_BYTE2LEN((unsigned)c >> 8);\n}\n\n/*\n * Return the number of cells occupied by string \"p\".\n * Stop at a NUL character.  When \"len\" >= 0 stop at character \"p[len]\".\n */\n    int\nmb_string2cells(char_u *p, int len)\n{\n    int i;\n    int clen = 0;\n\n    for (i = 0; (len < 0 || i < len) && p[i] != NUL; i += (*mb_ptr2len)(p + i))\n\tclen += (*mb_ptr2cells)(p + i);\n    return clen;\n}\n\n/*\n * mb_off2cells() function pointer.\n * Return number of display cells for char at ScreenLines[off].\n * We make sure that the offset used is less than \"max_off\".\n */\n    int\nlatin_off2cells(unsigned off UNUSED, unsigned max_off UNUSED)\n{\n    return 1;\n}\n\n    int\ndbcs_off2cells(unsigned off, unsigned max_off)\n{\n    // never check beyond end of the line\n    if (off >= max_off)\n\treturn 1;\n\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(ScreenLines[off]);\n}\n\n    int\nutf_off2cells(unsigned off, unsigned max_off)\n{\n    return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;\n}\n\n/*\n * mb_ptr2char() function pointer.\n * Convert a byte sequence into a character.\n */\n    int\nlatin_ptr2char(char_u *p)\n{\n    return *p;\n}\n\n    static int\ndbcs_ptr2char(char_u *p)\n{\n    if (MB_BYTE2LEN(*p) > 1 && p[1] != NUL)\n\treturn (p[0] << 8) + p[1];\n    return *p;\n}\n\n/*\n * Convert a UTF-8 byte sequence to a character number.\n * If the sequence is illegal or truncated by a NUL the first byte is\n * returned.\n * For an overlong sequence this may return zero.\n * Does not include composing characters, of course.\n */\n    int\nutf_ptr2char(char_u *p)\n{\n    int\t\tlen;\n\n    if (p[0] < 0x80)\t// be quick for ASCII\n\treturn p[0];\n\n    len = utf8len_tab_zero[p[0]];\n    if (len > 1 && (p[1] & 0xc0) == 0x80)\n    {\n\tif (len == 2)\n\t    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n\tif ((p[2] & 0xc0) == 0x80)\n\t{\n\t    if (len == 3)\n\t\treturn ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n\t\t    + (p[2] & 0x3f);\n\t    if ((p[3] & 0xc0) == 0x80)\n\t    {\n\t\tif (len == 4)\n\t\t    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n\t\t\t+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);\n\t\tif ((p[4] & 0xc0) == 0x80)\n\t\t{\n\t\t    if (len == 5)\n\t\t\treturn ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n\t\t\t    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n\t\t\t    + (p[4] & 0x3f);\n\t\t    if ((p[5] & 0xc0) == 0x80 && len == 6)\n\t\t\treturn ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n\t\t\t    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n\t\t\t    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);\n\t\t}\n\t    }\n\t}\n    }\n    // Illegal value, just return the first byte\n    return p[0];\n}\n\n/*\n * Convert a UTF-8 byte sequence to a wide character.\n * String is assumed to be terminated by NUL or after \"n\" bytes, whichever\n * comes first.\n * The function is safe in the sense that it never accesses memory beyond the\n * first \"n\" bytes of \"s\".\n *\n * On success, returns decoded codepoint, advances \"s\" to the beginning of\n * next character and decreases \"n\" accordingly.\n *\n * If end of string was reached, returns 0 and, if \"n\" > 0, advances \"s\" past\n * NUL byte.\n *\n * If byte sequence is illegal or incomplete, returns -1 and does not advance\n * \"s\".\n */\n    static int\nutf_safe_read_char_adv(char_u **s, size_t *n)\n{\n    int\t\tc, k;\n\n    if (*n == 0) // end of buffer\n\treturn 0;\n\n    k = utf8len_tab_zero[**s];\n\n    if (k == 1)\n    {\n\t// ASCII character or NUL\n\t(*n)--;\n\treturn *(*s)++;\n    }\n\n    if ((size_t)k <= *n)\n    {\n\t// We have a multibyte sequence and it isn't truncated by buffer\n\t// limits so utf_ptr2char() is safe to use. Or the first byte is\n\t// illegal (k=0), and it's also safe to use utf_ptr2char().\n\tc = utf_ptr2char(*s);\n\n\t// On failure, utf_ptr2char() returns the first byte, so here we\n\t// check equality with the first byte. The only non-ASCII character\n\t// which equals the first byte of its own UTF-8 representation is\n\t// U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.\n\t// It's safe even if n=1, else we would have k=2 > n.\n\tif (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83))\n\t{\n\t    // byte sequence was successfully decoded\n\t    *s += k;\n\t    *n -= k;\n\t    return c;\n\t}\n    }\n\n    // byte sequence is incomplete or illegal\n    return -1;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are skipped!\n */\n    int\nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are returned as separate characters.\n */\n    int\nmb_cptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    if (enc_utf8)\n\t*pp += utf_ptr2len(*pp);\n    else\n\t*pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\n/*\n * Check if the character pointed to by \"p2\" is a composing character when it\n * comes after \"p1\".  For Arabic sometimes \"ab\" is replaced with \"c\", which\n * behaves like a composing character.\n */\n    int\nutf_composinglike(char_u *p1, char_u *p2)\n{\n    int\t\tc2;\n\n    c2 = utf_ptr2char(p2);\n    if (utf_iscomposing(c2))\n\treturn TRUE;\n    if (!arabic_maycombine(c2))\n\treturn FALSE;\n    return arabic_combine(utf_ptr2char(p1), c2);\n}\n#endif\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.\n */\n    int\nutfc_ptr2char(\n    char_u\t*p,\n    int\t\t*pcc)\t// return: composing chars, last one is 0\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len(p);\n\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len(p + len);\n\t    if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.  Use no more than p[maxlen].\n */\n    int\nutfc_ptr2char_len(\n    char_u\t*p,\n    int\t\t*pcc,\t// return: composing chars, last one is 0\n    int\t\tmaxlen)\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len_len(p, maxlen);\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && len < maxlen\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len_len(p + len, maxlen - len);\n\t    if (len >= maxlen\n\t\t    || p[len] < 0x80\n\t\t    || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert the character at screen position \"off\" to a sequence of bytes.\n * Includes the composing characters.\n * \"buf\" must at least have the length MB_MAXBYTES + 1.\n * Only to be used when ScreenLinesUC[off] != 0.\n * Returns the produced number of bytes.\n */\n    int\nutfc_char2bytes(int off, char_u *buf)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    len = utf_char2bytes(ScreenLinesUC[off], buf);\n    for (i = 0; i < Screen_mco; ++i)\n    {\n\tif (ScreenLinesC[i][off] == 0)\n\t    break;\n\tlen += utf_char2bytes(ScreenLinesC[i][off], buf + len);\n    }\n    return len;\n}\n\n/*\n * Get the length of a UTF-8 byte sequence, not including any following\n * composing characters.\n * Returns 0 for \"\".\n * Returns 1 for an illegal byte sequence.\n */\n    int\nutf_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    if (*p == NUL)\n\treturn 0;\n    len = utf8len_tab[*p];\n    for (i = 1; i < len; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return length of UTF-8 character, obtained from the first byte.\n * \"b\" must be between 0 and 255!\n * Returns 1 for an invalid first byte value.\n */\n    int\nutf_byte2len(int b)\n{\n    return utf8len_tab[b];\n}\n\n/*\n * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any\n * following composing characters.\n * Returns 1 for \"\".\n * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).\n * Returns number > \"size\" for an incomplete byte sequence.\n * Never returns zero.\n */\n    int\nutf_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tm;\n\n    len = utf8len_tab[*p];\n    if (len == 1)\n\treturn 1;\t// NUL, ascii or illegal lead byte\n    if (len > size)\n\tm = size;\t// incomplete byte sequence.\n    else\n\tm = len;\n    for (i = 1; i < m; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p\" takes.\n * This includes following composing characters.\n */\n    int\nutfc_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\tb0 = *p;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (b0 == NUL)\n\treturn 0;\n    if (b0 < 0x80 && p[1] < 0x80)\t// be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len(p);\n\n    // Check for illegal byte.\n    if (len == 1 && b0 >= 0x80)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    for (;;)\n    {\n\tif (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    return len;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += utf_ptr2len(p + len);\n    }\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\"\n * takes.  This includes following composing characters.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nutfc_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) // be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len_len(p, size);\n\n    // Check for illegal byte and incomplete byte sequence.\n    if ((len == 1 && p[0] >= 0x80) || len > size)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    while (len < size)\n    {\n\tint\tlen_next_char;\n\n\tif (p[len] < 0x80)\n\t    break;\n\n\t/*\n\t * Next character length should not go beyond size to ensure that\n\t * UTF_COMPOSINGLIKE(...) does not read beyond size.\n\t */\n\tlen_next_char = utf_ptr2len_len(p + len, size - len);\n\tif (len_next_char > size - len)\n\t    break;\n\n\tif (!UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    break;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += len_next_char;\n    }\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of character \"c\" takes.\n * This does not include composing characters.\n */\n    int\nutf_char2len(int c)\n{\n    if (c < 0x80)\n\treturn 1;\n    if (c < 0x800)\n\treturn 2;\n    if (c < 0x10000)\n\treturn 3;\n    if (c < 0x200000)\n\treturn 4;\n    if (c < 0x4000000)\n\treturn 5;\n    return 6;\n}\n\n/*\n * Convert Unicode character \"c\" to UTF-8 string in \"buf[]\".\n * Returns the number of bytes.\n */\n    int\nutf_char2bytes(int c, char_u *buf)\n{\n    if (c < 0x80)\t\t// 7 bits\n    {\n\tbuf[0] = c;\n\treturn 1;\n    }\n    if (c < 0x800)\t\t// 11 bits\n    {\n\tbuf[0] = 0xc0 + ((unsigned)c >> 6);\n\tbuf[1] = 0x80 + (c & 0x3f);\n\treturn 2;\n    }\n    if (c < 0x10000)\t\t// 16 bits\n    {\n\tbuf[0] = 0xe0 + ((unsigned)c >> 12);\n\tbuf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[2] = 0x80 + (c & 0x3f);\n\treturn 3;\n    }\n    if (c < 0x200000)\t\t// 21 bits\n    {\n\tbuf[0] = 0xf0 + ((unsigned)c >> 18);\n\tbuf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[3] = 0x80 + (c & 0x3f);\n\treturn 4;\n    }\n    if (c < 0x4000000)\t\t// 26 bits\n    {\n\tbuf[0] = 0xf8 + ((unsigned)c >> 24);\n\tbuf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[4] = 0x80 + (c & 0x3f);\n\treturn 5;\n    }\n\t\t\t\t// 31 bits\n    buf[0] = 0xfc + ((unsigned)c >> 30);\n    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[5] = 0x80 + (c & 0x3f);\n    return 6;\n}\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_iscomposing() with different argument type for libvterm.\n */\n    int\nutf_iscomposing_uint(UINT32_T c)\n{\n    return utf_iscomposing((int)c);\n}\n#endif\n\n/*\n * Return TRUE if \"c\" is a composing UTF-8 character.  This means it will be\n * drawn on top of the preceding character.\n * Based on code from Markus Kuhn.\n */\n    int\nutf_iscomposing(int c)\n{\n    // Sorted list of non-overlapping intervals.\n    // Generated by ../runtime/tools/unicode.vim.\n    static struct interval combining[] =\n    {\n\t{0x0300, 0x036f},\n\t{0x0483, 0x0489},\n\t{0x0591, 0x05bd},\n\t{0x05bf, 0x05bf},\n\t{0x05c1, 0x05c2},\n\t{0x05c4, 0x05c5},\n\t{0x05c7, 0x05c7},\n\t{0x0610, 0x061a},\n\t{0x064b, 0x065f},\n\t{0x0670, 0x0670},\n\t{0x06d6, 0x06dc},\n\t{0x06df, 0x06e4},\n\t{0x06e7, 0x06e8},\n\t{0x06ea, 0x06ed},\n\t{0x0711, 0x0711},\n\t{0x0730, 0x074a},\n\t{0x07a6, 0x07b0},\n\t{0x07eb, 0x07f3},\n\t{0x07fd, 0x07fd},\n\t{0x0816, 0x0819},\n\t{0x081b, 0x0823},\n\t{0x0825, 0x0827},\n\t{0x0829, 0x082d},\n\t{0x0859, 0x085b},\n\t{0x08d3, 0x08e1},\n\t{0x08e3, 0x0903},\n\t{0x093a, 0x093c},\n\t{0x093e, 0x094f},\n\t{0x0951, 0x0957},\n\t{0x0962, 0x0963},\n\t{0x0981, 0x0983},\n\t{0x09bc, 0x09bc},\n\t{0x09be, 0x09c4},\n\t{0x09c7, 0x09c8},\n\t{0x09cb, 0x09cd},\n\t{0x09d7, 0x09d7},\n\t{0x09e2, 0x09e3},\n\t{0x09fe, 0x09fe},\n\t{0x0a01, 0x0a03},\n\t{0x0a3c, 0x0a3c},\n\t{0x0a3e, 0x0a42},\n\t{0x0a47, 0x0a48},\n\t{0x0a4b, 0x0a4d},\n\t{0x0a51, 0x0a51},\n\t{0x0a70, 0x0a71},\n\t{0x0a75, 0x0a75},\n\t{0x0a81, 0x0a83},\n\t{0x0abc, 0x0abc},\n\t{0x0abe, 0x0ac5},\n\t{0x0ac7, 0x0ac9},\n\t{0x0acb, 0x0acd},\n\t{0x0ae2, 0x0ae3},\n\t{0x0afa, 0x0aff},\n\t{0x0b01, 0x0b03},\n\t{0x0b3c, 0x0b3c},\n\t{0x0b3e, 0x0b44},\n\t{0x0b47, 0x0b48},\n\t{0x0b4b, 0x0b4d},\n\t{0x0b55, 0x0b57},\n\t{0x0b62, 0x0b63},\n\t{0x0b82, 0x0b82},\n\t{0x0bbe, 0x0bc2},\n\t{0x0bc6, 0x0bc8},\n\t{0x0bca, 0x0bcd},\n\t{0x0bd7, 0x0bd7},\n\t{0x0c00, 0x0c04},\n\t{0x0c3e, 0x0c44},\n\t{0x0c46, 0x0c48},\n\t{0x0c4a, 0x0c4d},\n\t{0x0c55, 0x0c56},\n\t{0x0c62, 0x0c63},\n\t{0x0c81, 0x0c83},\n\t{0x0cbc, 0x0cbc},\n\t{0x0cbe, 0x0cc4},\n\t{0x0cc6, 0x0cc8},\n\t{0x0cca, 0x0ccd},\n\t{0x0cd5, 0x0cd6},\n\t{0x0ce2, 0x0ce3},\n\t{0x0d00, 0x0d03},\n\t{0x0d3b, 0x0d3c},\n\t{0x0d3e, 0x0d44},\n\t{0x0d46, 0x0d48},\n\t{0x0d4a, 0x0d4d},\n\t{0x0d57, 0x0d57},\n\t{0x0d62, 0x0d63},\n\t{0x0d81, 0x0d83},\n\t{0x0dca, 0x0dca},\n\t{0x0dcf, 0x0dd4},\n\t{0x0dd6, 0x0dd6},\n\t{0x0dd8, 0x0ddf},\n\t{0x0df2, 0x0df3},\n\t{0x0e31, 0x0e31},\n\t{0x0e34, 0x0e3a},\n\t{0x0e47, 0x0e4e},\n\t{0x0eb1, 0x0eb1},\n\t{0x0eb4, 0x0ebc},\n\t{0x0ec8, 0x0ecd},\n\t{0x0f18, 0x0f19},\n\t{0x0f35, 0x0f35},\n\t{0x0f37, 0x0f37},\n\t{0x0f39, 0x0f39},\n\t{0x0f3e, 0x0f3f},\n\t{0x0f71, 0x0f84},\n\t{0x0f86, 0x0f87},\n\t{0x0f8d, 0x0f97},\n\t{0x0f99, 0x0fbc},\n\t{0x0fc6, 0x0fc6},\n\t{0x102b, 0x103e},\n\t{0x1056, 0x1059},\n\t{0x105e, 0x1060},\n\t{0x1062, 0x1064},\n\t{0x1067, 0x106d},\n\t{0x1071, 0x1074},\n\t{0x1082, 0x108d},\n\t{0x108f, 0x108f},\n\t{0x109a, 0x109d},\n\t{0x135d, 0x135f},\n\t{0x1712, 0x1714},\n\t{0x1732, 0x1734},\n\t{0x1752, 0x1753},\n\t{0x1772, 0x1773},\n\t{0x17b4, 0x17d3},\n\t{0x17dd, 0x17dd},\n\t{0x180b, 0x180d},\n\t{0x1885, 0x1886},\n\t{0x18a9, 0x18a9},\n\t{0x1920, 0x192b},\n\t{0x1930, 0x193b},\n\t{0x1a17, 0x1a1b},\n\t{0x1a55, 0x1a5e},\n\t{0x1a60, 0x1a7c},\n\t{0x1a7f, 0x1a7f},\n\t{0x1ab0, 0x1ac0},\n\t{0x1b00, 0x1b04},\n\t{0x1b34, 0x1b44},\n\t{0x1b6b, 0x1b73},\n\t{0x1b80, 0x1b82},\n\t{0x1ba1, 0x1bad},\n\t{0x1be6, 0x1bf3},\n\t{0x1c24, 0x1c37},\n\t{0x1cd0, 0x1cd2},\n\t{0x1cd4, 0x1ce8},\n\t{0x1ced, 0x1ced},\n\t{0x1cf4, 0x1cf4},\n\t{0x1cf7, 0x1cf9},\n\t{0x1dc0, 0x1df9},\n\t{0x1dfb, 0x1dff},\n\t{0x20d0, 0x20f0},\n\t{0x2cef, 0x2cf1},\n\t{0x2d7f, 0x2d7f},\n\t{0x2de0, 0x2dff},\n\t{0x302a, 0x302f},\n\t{0x3099, 0x309a},\n\t{0xa66f, 0xa672},\n\t{0xa674, 0xa67d},\n\t{0xa69e, 0xa69f},\n\t{0xa6f0, 0xa6f1},\n\t{0xa802, 0xa802},\n\t{0xa806, 0xa806},\n\t{0xa80b, 0xa80b},\n\t{0xa823, 0xa827},\n\t{0xa82c, 0xa82c},\n\t{0xa880, 0xa881},\n\t{0xa8b4, 0xa8c5},\n\t{0xa8e0, 0xa8f1},\n\t{0xa8ff, 0xa8ff},\n\t{0xa926, 0xa92d},\n\t{0xa947, 0xa953},\n\t{0xa980, 0xa983},\n\t{0xa9b3, 0xa9c0},\n\t{0xa9e5, 0xa9e5},\n\t{0xaa29, 0xaa36},\n\t{0xaa43, 0xaa43},\n\t{0xaa4c, 0xaa4d},\n\t{0xaa7b, 0xaa7d},\n\t{0xaab0, 0xaab0},\n\t{0xaab2, 0xaab4},\n\t{0xaab7, 0xaab8},\n\t{0xaabe, 0xaabf},\n\t{0xaac1, 0xaac1},\n\t{0xaaeb, 0xaaef},\n\t{0xaaf5, 0xaaf6},\n\t{0xabe3, 0xabea},\n\t{0xabec, 0xabed},\n\t{0xfb1e, 0xfb1e},\n\t{0xfe00, 0xfe0f},\n\t{0xfe20, 0xfe2f},\n\t{0x101fd, 0x101fd},\n\t{0x102e0, 0x102e0},\n\t{0x10376, 0x1037a},\n\t{0x10a01, 0x10a03},\n\t{0x10a05, 0x10a06},\n\t{0x10a0c, 0x10a0f},\n\t{0x10a38, 0x10a3a},\n\t{0x10a3f, 0x10a3f},\n\t{0x10ae5, 0x10ae6},\n\t{0x10d24, 0x10d27},\n\t{0x10eab, 0x10eac},\n\t{0x10f46, 0x10f50},\n\t{0x11000, 0x11002},\n\t{0x11038, 0x11046},\n\t{0x1107f, 0x11082},\n\t{0x110b0, 0x110ba},\n\t{0x11100, 0x11102},\n\t{0x11127, 0x11134},\n\t{0x11145, 0x11146},\n\t{0x11173, 0x11173},\n\t{0x11180, 0x11182},\n\t{0x111b3, 0x111c0},\n\t{0x111c9, 0x111cc},\n\t{0x111ce, 0x111cf},\n\t{0x1122c, 0x11237},\n\t{0x1123e, 0x1123e},\n\t{0x112df, 0x112ea},\n\t{0x11300, 0x11303},\n\t{0x1133b, 0x1133c},\n\t{0x1133e, 0x11344},\n\t{0x11347, 0x11348},\n\t{0x1134b, 0x1134d},\n\t{0x11357, 0x11357},\n\t{0x11362, 0x11363},\n\t{0x11366, 0x1136c},\n\t{0x11370, 0x11374},\n\t{0x11435, 0x11446},\n\t{0x1145e, 0x1145e},\n\t{0x114b0, 0x114c3},\n\t{0x115af, 0x115b5},\n\t{0x115b8, 0x115c0},\n\t{0x115dc, 0x115dd},\n\t{0x11630, 0x11640},\n\t{0x116ab, 0x116b7},\n\t{0x1171d, 0x1172b},\n\t{0x1182c, 0x1183a},\n\t{0x11930, 0x11935},\n\t{0x11937, 0x11938},\n\t{0x1193b, 0x1193e},\n\t{0x11940, 0x11940},\n\t{0x11942, 0x11943},\n\t{0x119d1, 0x119d7},\n\t{0x119da, 0x119e0},\n\t{0x119e4, 0x119e4},\n\t{0x11a01, 0x11a0a},\n\t{0x11a33, 0x11a39},\n\t{0x11a3b, 0x11a3e},\n\t{0x11a47, 0x11a47},\n\t{0x11a51, 0x11a5b},\n\t{0x11a8a, 0x11a99},\n\t{0x11c2f, 0x11c36},\n\t{0x11c38, 0x11c3f},\n\t{0x11c92, 0x11ca7},\n\t{0x11ca9, 0x11cb6},\n\t{0x11d31, 0x11d36},\n\t{0x11d3a, 0x11d3a},\n\t{0x11d3c, 0x11d3d},\n\t{0x11d3f, 0x11d45},\n\t{0x11d47, 0x11d47},\n\t{0x11d8a, 0x11d8e},\n\t{0x11d90, 0x11d91},\n\t{0x11d93, 0x11d97},\n\t{0x11ef3, 0x11ef6},\n\t{0x16af0, 0x16af4},\n\t{0x16b30, 0x16b36},\n\t{0x16f4f, 0x16f4f},\n\t{0x16f51, 0x16f87},\n\t{0x16f8f, 0x16f92},\n\t{0x16fe4, 0x16fe4},\n\t{0x16ff0, 0x16ff1},\n\t{0x1bc9d, 0x1bc9e},\n\t{0x1d165, 0x1d169},\n\t{0x1d16d, 0x1d172},\n\t{0x1d17b, 0x1d182},\n\t{0x1d185, 0x1d18b},\n\t{0x1d1aa, 0x1d1ad},\n\t{0x1d242, 0x1d244},\n\t{0x1da00, 0x1da36},\n\t{0x1da3b, 0x1da6c},\n\t{0x1da75, 0x1da75},\n\t{0x1da84, 0x1da84},\n\t{0x1da9b, 0x1da9f},\n\t{0x1daa1, 0x1daaf},\n\t{0x1e000, 0x1e006},\n\t{0x1e008, 0x1e018},\n\t{0x1e01b, 0x1e021},\n\t{0x1e023, 0x1e024},\n\t{0x1e026, 0x1e02a},\n\t{0x1e130, 0x1e136},\n\t{0x1e2ec, 0x1e2ef},\n\t{0x1e8d0, 0x1e8d6},\n\t{0x1e944, 0x1e94a},\n\t{0xe0100, 0xe01ef}\n    };\n\n    return intable(combining, sizeof(combining), c);\n}\n\n/*\n * Return TRUE for characters that can be displayed in a normal way.\n * Only for characters of 0x100 and above!\n */\n    int\nutf_printable(int c)\n{\n#ifdef USE_WCHAR_FUNCTIONS\n    /*\n     * Assume the iswprint() library function works better than our own stuff.\n     */\n    return iswprint(c);\n#else\n    // Sorted list of non-overlapping intervals.\n    // 0xd800-0xdfff is reserved for UTF-16, actually illegal.\n    static struct interval nonprint[] =\n    {\n\t{0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},\n\t{0x2060, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},\n\t{0xfffe, 0xffff}\n    };\n\n    return !intable(nonprint, sizeof(nonprint), c);\n#endif\n}\n\n// Sorted list of non-overlapping intervals of all Emoji characters,\n// based on http://unicode.org/emoji/charts/emoji-list.html\n// Generated by ../runtime/tools/unicode.vim.\n// Excludes 0x00a9 and 0x00ae because they are considered latin1.\nstatic struct interval emoji_all[] =\n{\n    {0x203c, 0x203c},\n    {0x2049, 0x2049},\n    {0x2122, 0x2122},\n    {0x2139, 0x2139},\n    {0x2194, 0x2199},\n    {0x21a9, 0x21aa},\n    {0x231a, 0x231b},\n    {0x2328, 0x2328},\n    {0x23cf, 0x23cf},\n    {0x23e9, 0x23f3},\n    {0x23f8, 0x23fa},\n    {0x24c2, 0x24c2},\n    {0x25aa, 0x25ab},\n    {0x25b6, 0x25b6},\n    {0x25c0, 0x25c0},\n    {0x25fb, 0x25fe},\n    {0x2600, 0x2604},\n    {0x260e, 0x260e},\n    {0x2611, 0x2611},\n    {0x2614, 0x2615},\n    {0x2618, 0x2618},\n    {0x261d, 0x261d},\n    {0x2620, 0x2620},\n    {0x2622, 0x2623},\n    {0x2626, 0x2626},\n    {0x262a, 0x262a},\n    {0x262e, 0x262f},\n    {0x2638, 0x263a},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2648, 0x2653},\n    {0x265f, 0x2660},\n    {0x2663, 0x2663},\n    {0x2665, 0x2666},\n    {0x2668, 0x2668},\n    {0x267b, 0x267b},\n    {0x267e, 0x267f},\n    {0x2692, 0x2697},\n    {0x2699, 0x2699},\n    {0x269b, 0x269c},\n    {0x26a0, 0x26a1},\n    {0x26a7, 0x26a7},\n    {0x26aa, 0x26ab},\n    {0x26b0, 0x26b1},\n    {0x26bd, 0x26be},\n    {0x26c4, 0x26c5},\n    {0x26c8, 0x26c8},\n    {0x26ce, 0x26cf},\n    {0x26d1, 0x26d1},\n    {0x26d3, 0x26d4},\n    {0x26e9, 0x26ea},\n    {0x26f0, 0x26f5},\n    {0x26f7, 0x26fa},\n    {0x26fd, 0x26fd},\n    {0x2702, 0x2702},\n    {0x2705, 0x2705},\n    {0x2708, 0x270d},\n    {0x270f, 0x270f},\n    {0x2712, 0x2712},\n    {0x2714, 0x2714},\n    {0x2716, 0x2716},\n    {0x271d, 0x271d},\n    {0x2721, 0x2721},\n    {0x2728, 0x2728},\n    {0x2733, 0x2734},\n    {0x2744, 0x2744},\n    {0x2747, 0x2747},\n    {0x274c, 0x274c},\n    {0x274e, 0x274e},\n    {0x2753, 0x2755},\n    {0x2757, 0x2757},\n    {0x2763, 0x2764},\n    {0x2795, 0x2797},\n    {0x27a1, 0x27a1},\n    {0x27b0, 0x27b0},\n    {0x27bf, 0x27bf},\n    {0x2934, 0x2935},\n    {0x2b05, 0x2b07},\n    {0x2b1b, 0x2b1c},\n    {0x2b50, 0x2b50},\n    {0x2b55, 0x2b55},\n    {0x3030, 0x3030},\n    {0x303d, 0x303d},\n    {0x3297, 0x3297},\n    {0x3299, 0x3299},\n    {0x1f004, 0x1f004},\n    {0x1f0cf, 0x1f0cf},\n    {0x1f170, 0x1f171},\n    {0x1f17e, 0x1f17f},\n    {0x1f18e, 0x1f18e},\n    {0x1f191, 0x1f19a},\n    {0x1f1e6, 0x1f1ff},\n    {0x1f201, 0x1f202},\n    {0x1f21a, 0x1f21a},\n    {0x1f22f, 0x1f22f},\n    {0x1f232, 0x1f23a},\n    {0x1f250, 0x1f251},\n    {0x1f300, 0x1f321},\n    {0x1f324, 0x1f393},\n    {0x1f396, 0x1f397},\n    {0x1f399, 0x1f39b},\n    {0x1f39e, 0x1f3f0},\n    {0x1f3f3, 0x1f3f5},\n    {0x1f3f7, 0x1f4fd},\n    {0x1f4ff, 0x1f53d},\n    {0x1f549, 0x1f54e},\n    {0x1f550, 0x1f567},\n    {0x1f56f, 0x1f570},\n    {0x1f573, 0x1f57a},\n    {0x1f587, 0x1f587},\n    {0x1f58a, 0x1f58d},\n    {0x1f590, 0x1f590},\n    {0x1f595, 0x1f596},\n    {0x1f5a4, 0x1f5a5},\n    {0x1f5a8, 0x1f5a8},\n    {0x1f5b1, 0x1f5b2},\n    {0x1f5bc, 0x1f5bc},\n    {0x1f5c2, 0x1f5c4},\n    {0x1f5d1, 0x1f5d3},\n    {0x1f5dc, 0x1f5de},\n    {0x1f5e1, 0x1f5e1},\n    {0x1f5e3, 0x1f5e3},\n    {0x1f5e8, 0x1f5e8},\n    {0x1f5ef, 0x1f5ef},\n    {0x1f5f3, 0x1f5f3},\n    {0x1f5fa, 0x1f64f},\n    {0x1f680, 0x1f6c5},\n    {0x1f6cb, 0x1f6d2},\n    {0x1f6d5, 0x1f6d7},\n    {0x1f6e0, 0x1f6e5},\n    {0x1f6e9, 0x1f6e9},\n    {0x1f6eb, 0x1f6ec},\n    {0x1f6f0, 0x1f6f0},\n    {0x1f6f3, 0x1f6fc},\n    {0x1f7e0, 0x1f7eb},\n    {0x1f90c, 0x1f93a},\n    {0x1f93c, 0x1f945},\n    {0x1f947, 0x1f978},\n    {0x1f97a, 0x1f9cb},\n    {0x1f9cd, 0x1f9ff},\n    {0x1fa70, 0x1fa74},\n    {0x1fa78, 0x1fa7a},\n    {0x1fa80, 0x1fa86},\n    {0x1fa90, 0x1faa8},\n    {0x1fab0, 0x1fab6},\n    {0x1fac0, 0x1fac2},\n    {0x1fad0, 0x1fad6}\n};\n\n/*\n * Get class of a Unicode character.\n * 0: white space\n * 1: punctuation\n * 2 or bigger: some class of word character.\n */\n    int\nutf_class(int c)\n{\n    return utf_class_buf(c, curbuf);\n}\n\n    int\nutf_class_buf(int c, buf_T *buf)\n{\n    // sorted list of non-overlapping intervals\n    static struct clinterval\n    {\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int class;\n    } classes[] =\n    {\n\t{0x037e, 0x037e, 1},\t\t// Greek question mark\n\t{0x0387, 0x0387, 1},\t\t// Greek ano teleia\n\t{0x055a, 0x055f, 1},\t\t// Armenian punctuation\n\t{0x0589, 0x0589, 1},\t\t// Armenian full stop\n\t{0x05be, 0x05be, 1},\n\t{0x05c0, 0x05c0, 1},\n\t{0x05c3, 0x05c3, 1},\n\t{0x05f3, 0x05f4, 1},\n\t{0x060c, 0x060c, 1},\n\t{0x061b, 0x061b, 1},\n\t{0x061f, 0x061f, 1},\n\t{0x066a, 0x066d, 1},\n\t{0x06d4, 0x06d4, 1},\n\t{0x0700, 0x070d, 1},\t\t// Syriac punctuation\n\t{0x0964, 0x0965, 1},\n\t{0x0970, 0x0970, 1},\n\t{0x0df4, 0x0df4, 1},\n\t{0x0e4f, 0x0e4f, 1},\n\t{0x0e5a, 0x0e5b, 1},\n\t{0x0f04, 0x0f12, 1},\n\t{0x0f3a, 0x0f3d, 1},\n\t{0x0f85, 0x0f85, 1},\n\t{0x104a, 0x104f, 1},\t\t// Myanmar punctuation\n\t{0x10fb, 0x10fb, 1},\t\t// Georgian punctuation\n\t{0x1361, 0x1368, 1},\t\t// Ethiopic punctuation\n\t{0x166d, 0x166e, 1},\t\t// Canadian Syl. punctuation\n\t{0x1680, 0x1680, 0},\n\t{0x169b, 0x169c, 1},\n\t{0x16eb, 0x16ed, 1},\n\t{0x1735, 0x1736, 1},\n\t{0x17d4, 0x17dc, 1},\t\t// Khmer punctuation\n\t{0x1800, 0x180a, 1},\t\t// Mongolian punctuation\n\t{0x2000, 0x200b, 0},\t\t// spaces\n\t{0x200c, 0x2027, 1},\t\t// punctuation and symbols\n\t{0x2028, 0x2029, 0},\n\t{0x202a, 0x202e, 1},\t\t// punctuation and symbols\n\t{0x202f, 0x202f, 0},\n\t{0x2030, 0x205e, 1},\t\t// punctuation and symbols\n\t{0x205f, 0x205f, 0},\n\t{0x2060, 0x27ff, 1},\t\t// punctuation and symbols\n\t{0x2070, 0x207f, 0x2070},\t// superscript\n\t{0x2080, 0x2094, 0x2080},\t// subscript\n\t{0x20a0, 0x27ff, 1},\t\t// all kinds of symbols\n\t{0x2800, 0x28ff, 0x2800},\t// braille\n\t{0x2900, 0x2998, 1},\t\t// arrows, brackets, etc.\n\t{0x29d8, 0x29db, 1},\n\t{0x29fc, 0x29fd, 1},\n\t{0x2e00, 0x2e7f, 1},\t\t// supplemental punctuation\n\t{0x3000, 0x3000, 0},\t\t// ideographic space\n\t{0x3001, 0x3020, 1},\t\t// ideographic punctuation\n\t{0x3030, 0x3030, 1},\n\t{0x303d, 0x303d, 1},\n\t{0x3040, 0x309f, 0x3040},\t// Hiragana\n\t{0x30a0, 0x30ff, 0x30a0},\t// Katakana\n\t{0x3300, 0x9fff, 0x4e00},\t// CJK Ideographs\n\t{0xac00, 0xd7a3, 0xac00},\t// Hangul Syllables\n\t{0xf900, 0xfaff, 0x4e00},\t// CJK Ideographs\n\t{0xfd3e, 0xfd3f, 1},\n\t{0xfe30, 0xfe6b, 1},\t\t// punctuation forms\n\t{0xff00, 0xff0f, 1},\t\t// half/fullwidth ASCII\n\t{0xff1a, 0xff20, 1},\t\t// half/fullwidth ASCII\n\t{0xff3b, 0xff40, 1},\t\t// half/fullwidth ASCII\n\t{0xff5b, 0xff65, 1},\t\t// half/fullwidth ASCII\n\t{0x1d000, 0x1d24f, 1},\t\t// Musical notation\n\t{0x1d400, 0x1d7ff, 1},\t\t// Mathematical Alphanumeric Symbols\n\t{0x1f000, 0x1f2ff, 1},\t\t// Game pieces; enclosed characters\n\t{0x1f300, 0x1f9ff, 1},\t\t// Many symbol blocks\n\t{0x20000, 0x2a6df, 0x4e00},\t// CJK Ideographs\n\t{0x2a700, 0x2b73f, 0x4e00},\t// CJK Ideographs\n\t{0x2b740, 0x2b81f, 0x4e00},\t// CJK Ideographs\n\t{0x2f800, 0x2fa1f, 0x4e00},\t// CJK Ideographs\n    };\n\n    int bot = 0;\n    int top = ARRAY_LENGTH(classes) - 1;\n    int mid;\n\n    // First quick check for Latin1 characters, use 'iskeyword'.\n    if (c < 0x100)\n    {\n\tif (c == ' ' || c == '\\t' || c == NUL || c == 0xa0)\n\t    return 0;\t    // blank\n\tif (vim_iswordc_buf(c, buf))\n\t    return 2;\t    // word character\n\treturn 1;\t    // punctuation\n    }\n\n    // emoji\n    if (intable(emoji_all, sizeof(emoji_all), c))\n\treturn 3;\n\n    // binary search in table\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (classes[mid].last < (unsigned int)c)\n\t    bot = mid + 1;\n\telse if (classes[mid].first > (unsigned int)c)\n\t    top = mid - 1;\n\telse\n\t    return (int)classes[mid].class;\n    }\n\n    // most other characters are \"word\" characters\n    return 2;\n}\n\n    int\nutf_ambiguous_width(int c)\n{\n    return c >= 0x80 && (intable(ambiguous, sizeof(ambiguous), c)\n\t    || intable(emoji_all, sizeof(emoji_all), c));\n}\n\n/*\n * Code for Unicode case-dependent operations.  Based on notes in\n * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt\n * This code uses simple case folding, not full case folding.\n * Last updated for Unicode 5.2.\n */\n\n/*\n * The following tables are built by ../runtime/tools/unicode.vim.\n * They must be in numeric order, because we use binary search.\n * An entry such as {0x41,0x5a,1,32} means that Unicode characters in the\n * range from 0x41 to 0x5a inclusive, stepping by 1, are changed to\n * folded/upper/lower by adding 32.\n */\ntypedef struct\n{\n    int rangeStart;\n    int rangeEnd;\n    int step;\n    int offset;\n} convertStruct;\n\nstatic convertStruct foldCase[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xb5,0xb5,-1,775},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x17f,0x17f,-1,-268},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x345,0x345,-1,116},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3c2,0x3c2,-1,1},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d0,0x3d0,-1,-30},\n\t{0x3d1,0x3d1,-1,-25},\n\t{0x3d5,0x3d5,-1,-15},\n\t{0x3d6,0x3d6,-1,-22},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f0,0x3f0,-1,-54},\n\t{0x3f1,0x3f1,-1,-48},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f5,0x3f5,-1,-64},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6222},\n\t{0x1c81,0x1c81,-1,-6221},\n\t{0x1c82,0x1c82,-1,-6212},\n\t{0x1c83,0x1c84,1,-6210},\n\t{0x1c85,0x1c85,-1,-6211},\n\t{0x1c86,0x1c86,-1,-6204},\n\t{0x1c87,0x1c87,-1,-6180},\n\t{0x1c88,0x1c88,-1,35267},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9b,0x1e9b,-1,-58},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fbe,0x1fbe,-1,-7173},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\n/*\n * Generic conversion function for case operations.\n * Return the converted equivalent of \"a\", which is a UCS-4 character.  Use\n * the given conversion \"table\".  Uses binary search on \"table\".\n */\n    static int\nutf_convert(\n    int\t\t\ta,\n    convertStruct\ttable[],\n    int\t\t\ttableSize)\n{\n    int start, mid, end; // indices into table\n    int entries = tableSize / sizeof(convertStruct);\n\n    start = 0;\n    end = entries;\n    while (start < end)\n    {\n\t// need to search further\n\tmid = (end + start) / 2;\n\tif (table[mid].rangeEnd < a)\n\t    start = mid + 1;\n\telse\n\t    end = mid;\n    }\n    if (start < entries\n\t    && table[start].rangeStart <= a\n\t    && a <= table[start].rangeEnd\n\t    && (a - table[start].rangeStart) % table[start].step == 0)\n\treturn (a + table[start].offset);\n    else\n\treturn a;\n}\n\n/*\n * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses\n * simple case folding.\n */\n    int\nutf_fold(int a)\n{\n    if (a < 0x80)\n\t// be fast for ASCII\n\treturn a >= 0x41 && a <= 0x5a ? a + 32 : a;\n    return utf_convert(a, foldCase, (int)sizeof(foldCase));\n}\n\nstatic convertStruct toLower[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x130,0x130,-1,-199},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13a0,0x13ef,1,38864},\n\t{0x13f0,0x13f5,1,8},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\nstatic convertStruct toUpper[] =\n{\n\t{0x61,0x7a,1,-32},\n\t{0xb5,0xb5,-1,743},\n\t{0xe0,0xf6,1,-32},\n\t{0xf8,0xfe,1,-32},\n\t{0xff,0xff,-1,121},\n\t{0x101,0x12f,2,-1},\n\t{0x131,0x131,-1,-232},\n\t{0x133,0x137,2,-1},\n\t{0x13a,0x148,2,-1},\n\t{0x14b,0x177,2,-1},\n\t{0x17a,0x17e,2,-1},\n\t{0x17f,0x17f,-1,-300},\n\t{0x180,0x180,-1,195},\n\t{0x183,0x185,2,-1},\n\t{0x188,0x18c,4,-1},\n\t{0x192,0x192,-1,-1},\n\t{0x195,0x195,-1,97},\n\t{0x199,0x199,-1,-1},\n\t{0x19a,0x19a,-1,163},\n\t{0x19e,0x19e,-1,130},\n\t{0x1a1,0x1a5,2,-1},\n\t{0x1a8,0x1ad,5,-1},\n\t{0x1b0,0x1b4,4,-1},\n\t{0x1b6,0x1b9,3,-1},\n\t{0x1bd,0x1bd,-1,-1},\n\t{0x1bf,0x1bf,-1,56},\n\t{0x1c5,0x1c5,-1,-1},\n\t{0x1c6,0x1c6,-1,-2},\n\t{0x1c8,0x1c8,-1,-1},\n\t{0x1c9,0x1c9,-1,-2},\n\t{0x1cb,0x1cb,-1,-1},\n\t{0x1cc,0x1cc,-1,-2},\n\t{0x1ce,0x1dc,2,-1},\n\t{0x1dd,0x1dd,-1,-79},\n\t{0x1df,0x1ef,2,-1},\n\t{0x1f2,0x1f2,-1,-1},\n\t{0x1f3,0x1f3,-1,-2},\n\t{0x1f5,0x1f9,4,-1},\n\t{0x1fb,0x21f,2,-1},\n\t{0x223,0x233,2,-1},\n\t{0x23c,0x23c,-1,-1},\n\t{0x23f,0x240,1,10815},\n\t{0x242,0x247,5,-1},\n\t{0x249,0x24f,2,-1},\n\t{0x250,0x250,-1,10783},\n\t{0x251,0x251,-1,10780},\n\t{0x252,0x252,-1,10782},\n\t{0x253,0x253,-1,-210},\n\t{0x254,0x254,-1,-206},\n\t{0x256,0x257,1,-205},\n\t{0x259,0x259,-1,-202},\n\t{0x25b,0x25b,-1,-203},\n\t{0x25c,0x25c,-1,42319},\n\t{0x260,0x260,-1,-205},\n\t{0x261,0x261,-1,42315},\n\t{0x263,0x263,-1,-207},\n\t{0x265,0x265,-1,42280},\n\t{0x266,0x266,-1,42308},\n\t{0x268,0x268,-1,-209},\n\t{0x269,0x269,-1,-211},\n\t{0x26a,0x26a,-1,42308},\n\t{0x26b,0x26b,-1,10743},\n\t{0x26c,0x26c,-1,42305},\n\t{0x26f,0x26f,-1,-211},\n\t{0x271,0x271,-1,10749},\n\t{0x272,0x272,-1,-213},\n\t{0x275,0x275,-1,-214},\n\t{0x27d,0x27d,-1,10727},\n\t{0x280,0x280,-1,-218},\n\t{0x282,0x282,-1,42307},\n\t{0x283,0x283,-1,-218},\n\t{0x287,0x287,-1,42282},\n\t{0x288,0x288,-1,-218},\n\t{0x289,0x289,-1,-69},\n\t{0x28a,0x28b,1,-217},\n\t{0x28c,0x28c,-1,-71},\n\t{0x292,0x292,-1,-219},\n\t{0x29d,0x29d,-1,42261},\n\t{0x29e,0x29e,-1,42258},\n\t{0x345,0x345,-1,84},\n\t{0x371,0x373,2,-1},\n\t{0x377,0x377,-1,-1},\n\t{0x37b,0x37d,1,130},\n\t{0x3ac,0x3ac,-1,-38},\n\t{0x3ad,0x3af,1,-37},\n\t{0x3b1,0x3c1,1,-32},\n\t{0x3c2,0x3c2,-1,-31},\n\t{0x3c3,0x3cb,1,-32},\n\t{0x3cc,0x3cc,-1,-64},\n\t{0x3cd,0x3ce,1,-63},\n\t{0x3d0,0x3d0,-1,-62},\n\t{0x3d1,0x3d1,-1,-57},\n\t{0x3d5,0x3d5,-1,-47},\n\t{0x3d6,0x3d6,-1,-54},\n\t{0x3d7,0x3d7,-1,-8},\n\t{0x3d9,0x3ef,2,-1},\n\t{0x3f0,0x3f0,-1,-86},\n\t{0x3f1,0x3f1,-1,-80},\n\t{0x3f2,0x3f2,-1,7},\n\t{0x3f3,0x3f3,-1,-116},\n\t{0x3f5,0x3f5,-1,-96},\n\t{0x3f8,0x3fb,3,-1},\n\t{0x430,0x44f,1,-32},\n\t{0x450,0x45f,1,-80},\n\t{0x461,0x481,2,-1},\n\t{0x48b,0x4bf,2,-1},\n\t{0x4c2,0x4ce,2,-1},\n\t{0x4cf,0x4cf,-1,-15},\n\t{0x4d1,0x52f,2,-1},\n\t{0x561,0x586,1,-48},\n\t{0x10d0,0x10fa,1,3008},\n\t{0x10fd,0x10ff,1,3008},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6254},\n\t{0x1c81,0x1c81,-1,-6253},\n\t{0x1c82,0x1c82,-1,-6244},\n\t{0x1c83,0x1c84,1,-6242},\n\t{0x1c85,0x1c85,-1,-6243},\n\t{0x1c86,0x1c86,-1,-6236},\n\t{0x1c87,0x1c87,-1,-6181},\n\t{0x1c88,0x1c88,-1,35266},\n\t{0x1d79,0x1d79,-1,35332},\n\t{0x1d7d,0x1d7d,-1,3814},\n\t{0x1d8e,0x1d8e,-1,35384},\n\t{0x1e01,0x1e95,2,-1},\n\t{0x1e9b,0x1e9b,-1,-59},\n\t{0x1ea1,0x1eff,2,-1},\n\t{0x1f00,0x1f07,1,8},\n\t{0x1f10,0x1f15,1,8},\n\t{0x1f20,0x1f27,1,8},\n\t{0x1f30,0x1f37,1,8},\n\t{0x1f40,0x1f45,1,8},\n\t{0x1f51,0x1f57,2,8},\n\t{0x1f60,0x1f67,1,8},\n\t{0x1f70,0x1f71,1,74},\n\t{0x1f72,0x1f75,1,86},\n\t{0x1f76,0x1f77,1,100},\n\t{0x1f78,0x1f79,1,128},\n\t{0x1f7a,0x1f7b,1,112},\n\t{0x1f7c,0x1f7d,1,126},\n\t{0x1f80,0x1f87,1,8},\n\t{0x1f90,0x1f97,1,8},\n\t{0x1fa0,0x1fa7,1,8},\n\t{0x1fb0,0x1fb1,1,8},\n\t{0x1fb3,0x1fb3,-1,9},\n\t{0x1fbe,0x1fbe,-1,-7205},\n\t{0x1fc3,0x1fc3,-1,9},\n\t{0x1fd0,0x1fd1,1,8},\n\t{0x1fe0,0x1fe1,1,8},\n\t{0x1fe5,0x1fe5,-1,7},\n\t{0x1ff3,0x1ff3,-1,9},\n\t{0x214e,0x214e,-1,-28},\n\t{0x2170,0x217f,1,-16},\n\t{0x2184,0x2184,-1,-1},\n\t{0x24d0,0x24e9,1,-26},\n\t{0x2c30,0x2c5e,1,-48},\n\t{0x2c61,0x2c61,-1,-1},\n\t{0x2c65,0x2c65,-1,-10795},\n\t{0x2c66,0x2c66,-1,-10792},\n\t{0x2c68,0x2c6c,2,-1},\n\t{0x2c73,0x2c76,3,-1},\n\t{0x2c81,0x2ce3,2,-1},\n\t{0x2cec,0x2cee,2,-1},\n\t{0x2cf3,0x2cf3,-1,-1},\n\t{0x2d00,0x2d25,1,-7264},\n\t{0x2d27,0x2d2d,6,-7264},\n\t{0xa641,0xa66d,2,-1},\n\t{0xa681,0xa69b,2,-1},\n\t{0xa723,0xa72f,2,-1},\n\t{0xa733,0xa76f,2,-1},\n\t{0xa77a,0xa77c,2,-1},\n\t{0xa77f,0xa787,2,-1},\n\t{0xa78c,0xa791,5,-1},\n\t{0xa793,0xa793,-1,-1},\n\t{0xa794,0xa794,-1,48},\n\t{0xa797,0xa7a9,2,-1},\n\t{0xa7b5,0xa7bf,2,-1},\n\t{0xa7c3,0xa7c8,5,-1},\n\t{0xa7ca,0xa7f6,44,-1},\n\t{0xab53,0xab53,-1,-928},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff41,0xff5a,1,-32},\n\t{0x10428,0x1044f,1,-40},\n\t{0x104d8,0x104fb,1,-40},\n\t{0x10cc0,0x10cf2,1,-64},\n\t{0x118c0,0x118df,1,-32},\n\t{0x16e60,0x16e7f,1,-32},\n\t{0x1e922,0x1e943,1,-34}\n};\n\n/*\n * Return the upper-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_toupper(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style toupper().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(a);\n\n#if defined(HAVE_TOWUPPER) && defined(__STDC_ISO_10646__)\n    // If towupper() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towupper(a);\n#endif\n\n    // For characters below 128 use locale sensitive toupper().\n    if (a < 128)\n\treturn TOUPPER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toUpper, (int)sizeof(toUpper));\n}\n\n    int\nutf_islower(int a)\n{\n    // German sharp s is lower case but has no upper case equivalent.\n    return (utf_toupper(a) != a) || a == 0xdf;\n}\n\n/*\n * Return the lower-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_tolower(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style tolower().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(a);\n\n#if defined(HAVE_TOWLOWER) && defined(__STDC_ISO_10646__)\n    // If towlower() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towlower(a);\n#endif\n\n    // For characters below 128 use locale sensitive tolower().\n    if (a < 128)\n\treturn TOLOWER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toLower, (int)sizeof(toLower));\n}\n\n    int\nutf_isupper(int a)\n{\n    return (utf_tolower(a) != a);\n}\n\n    static int\nutf_strnicmp(\n    char_u      *s1,\n    char_u      *s2,\n    size_t      n1,\n    size_t      n2)\n{\n    int\t\tc1, c2, cdiff;\n    char_u\tbuffer[6];\n\n    for (;;)\n    {\n\tc1 = utf_safe_read_char_adv(&s1, &n1);\n\tc2 = utf_safe_read_char_adv(&s2, &n2);\n\n\tif (c1 <= 0 || c2 <= 0)\n\t    break;\n\n\tif (c1 == c2)\n\t    continue;\n\n\tcdiff = utf_fold(c1) - utf_fold(c2);\n\tif (cdiff != 0)\n\t    return cdiff;\n    }\n\n    // some string ended or has an incomplete/illegal character sequence\n\n    if (c1 == 0 || c2 == 0)\n    {\n\t// some string ended. shorter string is smaller\n\tif (c1 == 0 && c2 == 0)\n\t    return 0;\n\treturn c1 == 0 ? -1 : 1;\n    }\n\n    // Continue with bytewise comparison to produce some result that\n    // would make comparison operations involving this function transitive.\n    //\n    // If only one string had an error, comparison should be made with\n    // folded version of the other string. In this case it is enough\n    // to fold just one character to determine the result of comparison.\n\n    if (c1 != -1 && c2 == -1)\n    {\n\tn1 = utf_char2bytes(utf_fold(c1), buffer);\n\ts1 = buffer;\n    }\n    else if (c2 != -1 && c1 == -1)\n    {\n\tn2 = utf_char2bytes(utf_fold(c2), buffer);\n\ts2 = buffer;\n    }\n\n    while (n1 > 0 && n2 > 0 && *s1 != NUL && *s2 != NUL)\n    {\n\tcdiff = (int)(*s1) - (int)(*s2);\n\tif (cdiff != 0)\n\t    return cdiff;\n\n\ts1++;\n\ts2++;\n\tn1--;\n\tn2--;\n    }\n\n    if (n1 > 0 && *s1 == NUL)\n\tn1 = 0;\n    if (n2 > 0 && *s2 == NUL)\n\tn2 = 0;\n\n    if (n1 == 0 && n2 == 0)\n\treturn 0;\n    return n1 == 0 ? -1 : 1;\n}\n\n/*\n * Version of strnicmp() that handles multi-byte characters.\n * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can\n * probably use strnicmp(), because there are no ASCII characters in the\n * second byte.\n * Returns zero if s1 and s2 are equal (ignoring case), the difference between\n * two characters otherwise.\n */\n    int\nmb_strnicmp(char_u *s1, char_u *s2, size_t nn)\n{\n    int\t\ti, l;\n    int\t\tcdiff;\n    int\t\tn = (int)nn;\n\n    if (enc_utf8)\n    {\n\treturn utf_strnicmp(s1, s2, nn, nn);\n    }\n    else\n    {\n\tfor (i = 0; i < n; i += l)\n\t{\n\t    if (s1[i] == NUL && s2[i] == NUL)\t// both strings end\n\t\treturn 0;\n\n\t    l = (*mb_ptr2len)(s1 + i);\n\t    if (l <= 1)\n\t    {\n\t\t// Single byte: first check normally, then with ignore case.\n\t\tif (s1[i] != s2[i])\n\t\t{\n\t\t    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);\n\t\t    if (cdiff != 0)\n\t\t\treturn cdiff;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// For non-Unicode multi-byte don't ignore case.\n\t\tif (l > n - i)\n\t\t    l = n - i;\n\t\tcdiff = STRNCMP(s1 + i, s2 + i, l);\n\t\tif (cdiff != 0)\n\t\t    return cdiff;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what\n * 'encoding' has been set to.\n */\n    void\nshow_utf8(void)\n{\n    int\t\tlen;\n    int\t\trlen = 0;\n    char_u\t*line;\n    int\t\tclen;\n    int\t\ti;\n\n    // Get the byte length of the char under the cursor, including composing\n    // characters.\n    line = ml_get_cursor();\n    len = utfc_ptr2len(line);\n    if (len == 0)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    clen = 0;\n    for (i = 0; i < len; ++i)\n    {\n\tif (clen == 0)\n\t{\n\t    // start of (composing) character, get its length\n\t    if (i > 0)\n\t    {\n\t\tSTRCPY(IObuff + rlen, \"+ \");\n\t\trlen += 2;\n\t    }\n\t    clen = utf_ptr2len(line + i);\n\t}\n\tsprintf((char *)IObuff + rlen, \"%02x \",\n\t\t(line[i] == NL) ? NUL : line[i]);  // NUL is stored as NL\n\t--clen;\n\trlen += (int)STRLEN(IObuff + rlen);\n\tif (rlen > IOSIZE - 20)\n\t    break;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * mb_head_off() function pointer.\n * Return offset from \"p\" to the first byte of the character it points into.\n * If \"p\" points to the NUL at the end of the string return 0.\n * Returns 0 when already at the first byte of a character.\n */\n    int\nlatin_head_off(char_u *base UNUSED, char_u *p UNUSED)\n{\n    return 0;\n}\n\n    static int\ndbcs_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    if (p <= base || MB_BYTE2LEN(p[-1]) == 1 || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    q = base;\n    while (q < p)\n\tq += dbcs_ptr2len(q);\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Special version of dbcs_head_off() that works for ScreenLines[], where\n * single-width DBCS_JPNU characters are stored separately.\n */\n    int\ndbcs_screen_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    // For euc-jp an 0x8e byte in the previous cell always means we have a\n    // lead byte in the current cell.\n    if (p <= base\n\t    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)\n\t    || MB_BYTE2LEN(p[-1]) == 1\n\t    || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    // For DBCS_JPNU look out for 0x8e, which means the second byte is not\n    // stored as the next byte.\n    q = base;\n    while (q < p)\n    {\n\tif (enc_dbcs == DBCS_JPNU && *q == 0x8e)\n\t    ++q;\n\telse\n\t    q += dbcs_ptr2len(q);\n    }\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Return offset from \"p\" to the start of a character, including composing\n * characters.  \"base\" must be the start of the string, which must be NUL\n * terminated.\n */\n    int\nutf_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    char_u\t*j;\n#endif\n\n    if (*p < 0x80)\t\t// be quick for ASCII\n\treturn 0;\n\n    // Skip backwards over trailing bytes: 10xx.xxxx\n    // Skip backwards again if on a composing char.\n    for (q = p; ; --q)\n    {\n\t// Move s to the last byte of this char.\n\tfor (s = q; (s[1] & 0xc0) == 0x80; ++s)\n\t    ;\n\t// Move q to the first byte of this char.\n\twhile (q > base && (*q & 0xc0) == 0x80)\n\t    --q;\n\t// Check for illegal sequence. Do allow an illegal byte after where we\n\t// started.\n\tlen = utf8len_tab[*q];\n\tif (len != (int)(s - q + 1) && len != (int)(p - q + 1))\n\t    return 0;\n\n\tif (q <= base)\n\t    break;\n\n\tc = utf_ptr2char(q);\n\tif (utf_iscomposing(c))\n\t    continue;\n\n#ifdef FEAT_ARABIC\n\tif (arabic_maycombine(c))\n\t{\n\t    // Advance to get a sneak-peak at the next char\n\t    j = q;\n\t    --j;\n\t    // Move j to the first byte of this char.\n\t    while (j > base && (*j & 0xc0) == 0x80)\n\t\t--j;\n\t    if (arabic_combine(utf_ptr2char(j), c))\n\t\tcontinue;\n\t}\n#endif\n\tbreak;\n    }\n\n    return (int)(p - q);\n}\n\n/*\n * Whether space is NOT allowed before/after 'c'.\n */\n    int\nutf_eat_space(int cc)\n{\n    return ((cc >= 0x2000 && cc <= 0x206F)\t// General punctuations\n\t || (cc >= 0x2e00 && cc <= 0x2e7f)\t// Supplemental punctuations\n\t || (cc >= 0x3000 && cc <= 0x303f)\t// CJK symbols and punctuations\n\t || (cc >= 0xff01 && cc <= 0xff0f)\t// Full width ASCII punctuations\n\t || (cc >= 0xff1a && cc <= 0xff20)\t// ..\n\t || (cc >= 0xff3b && cc <= 0xff40)\t// ..\n\t || (cc >= 0xff5b && cc <= 0xff65));\t// ..\n}\n\n/*\n * Whether line break is allowed before \"cc\".\n */\n    int\nutf_allow_break_before(int cc)\n{\n    static const int BOL_prohibition_punct[] =\n    {\n\t'!',\n\t'%',\n\t')',\n\t',',\n\t':',\n\t';',\n\t'>',\n\t'?',\n\t']',\n\t'}',\n\t0x2019, // \u2019 right single quotation mark\n\t0x201d, // \u201d right double quotation mark\n\t0x2020, // \u2020 dagger\n\t0x2021, // \u2021 double dagger\n\t0x2026, // \u2026 horizontal ellipsis\n\t0x2030, // \u2030 per mille sign\n\t0x2031, // \u2031 per then thousand sign\n\t0x203c, // \u203c double exclamation mark\n\t0x2047, // \u2047 double question mark\n\t0x2048, // \u2048 question exclamation mark\n\t0x2049, // \u2049 exclamation question mark\n\t0x2103, // \u2103 degree celsius\n\t0x2109, // \u2109 degree fahrenheit\n\t0x3001, // \u3001 ideographic comma\n\t0x3002, // \u3002 ideographic full stop\n\t0x3009, // \u3009 right angle bracket\n\t0x300b, // \u300b right double angle bracket\n\t0x300d, // \u300d right corner bracket\n\t0x300f, // \u300f right white corner bracket\n\t0x3011, // \u3011 right black lenticular bracket\n\t0x3015, // \u3015 right tortoise shell bracket\n\t0x3017, // \u3017 right white lenticular bracket\n\t0x3019, // \u3019 right white tortoise shell bracket\n\t0x301b, // \u301b right white square bracket\n\t0xff01, // \uff01 fullwidth exclamation mark\n\t0xff09, // \uff09 fullwidth right parenthesis\n\t0xff0c, // \uff0c fullwidth comma\n\t0xff0e, // \uff0e fullwidth full stop\n\t0xff1a, // \uff1a fullwidth colon\n\t0xff1b, // \uff1b fullwidth semicolon\n\t0xff1f, // \uff1f fullwidth question mark\n\t0xff3d, // \uff3d fullwidth right square bracket\n\t0xff5d, // \uff5d fullwidth right curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(BOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == BOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > BOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != BOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed after \"cc\".\n */\n    static int\nutf_allow_break_after(int cc)\n{\n    static const int EOL_prohibition_punct[] =\n    {\n\t'(',\n\t'<',\n\t'[',\n\t'`',\n\t'{',\n\t//0x2014, // \u2014 em dash\n\t0x2018, // \u2018 left single quotation mark\n\t0x201c, // \u201c left double quotation mark\n\t//0x2053, // \uff5e swung dash\n\t0x3008, // \u3008 left angle bracket\n\t0x300a, // \u300a left double angle bracket\n\t0x300c, // \u300c left corner bracket\n\t0x300e, // \u300e left white corner bracket\n\t0x3010, // \u3010 left black lenticular bracket\n\t0x3014, // \u3014 left tortoise shell bracket\n\t0x3016, // \u3016 left white lenticular bracket\n\t0x3018, // \u3018 left white tortoise shell bracket\n\t0x301a, // \u301a left white square bracket\n\t0xff08, // \uff08 fullwidth left parenthesis\n\t0xff3b, // \uff3b fullwidth left square bracket\n\t0xff5b, // \uff5b fullwidth left curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(EOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == EOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > EOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != EOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed between \"cc\" and \"ncc\".\n */\n    int\nutf_allow_break(int cc, int ncc)\n{\n    // don't break between two-letter punctuations\n    if (cc == ncc\n\t    && (cc == 0x2014 // em dash\n\t\t|| cc == 0x2026)) // horizontal ellipsis\n\treturn FALSE;\n\n    return utf_allow_break_after(cc) && utf_allow_break_before(ncc);\n}\n\n/*\n * Copy a character from \"*fp\" to \"*tp\" and advance the pointers.\n */\n    void\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n/*\n * Return the offset from \"p\" to the first byte of a character.  When \"p\" is\n * at the start of a character 0 is returned, otherwise the offset to the next\n * character.  Can start anywhere in a stream of bytes.\n */\n    int\nmb_off_next(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (enc_utf8)\n    {\n\tif (*p < 0x80)\t\t// be quick for ASCII\n\t    return 0;\n\n\t// Find the next character that isn't 10xx.xxxx\n\tfor (i = 0; (p[i] & 0xc0) == 0x80; ++i)\n\t    ;\n\tif (i > 0)\n\t{\n\t    // Check for illegal sequence.\n\t    for (j = 0; p - j > base; ++j)\n\t\tif ((p[-j] & 0xc0) != 0x80)\n\t\t    break;\n\t    if (utf8len_tab[p[-j]] != i + j)\n\t\treturn 0;\n\t}\n\treturn i;\n    }\n\n    // Only need to check if we're on a trail byte, it doesn't matter if we\n    // want the offset to the next or current character.\n    return (*mb_head_off)(base, p);\n}\n\n/*\n * Return the offset from \"p\" to the last byte of the character it points\n * into.  Can start anywhere in a stream of bytes.\n * Composing characters are not included.\n */\n    int\nmb_tail_off(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (*p == NUL)\n\treturn 0;\n\n    if (enc_utf8)\n    {\n\t// Find the last character that is 10xx.xxxx\n\tfor (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)\n\t    ;\n\t// Check for illegal sequence.\n\tfor (j = 0; p - j > base; ++j)\n\t    if ((p[-j] & 0xc0) != 0x80)\n\t\tbreak;\n\tif (utf8len_tab[p[-j]] != i + j + 1)\n\t    return 0;\n\treturn i;\n    }\n\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_head_off(base, p);\n}\n\n/*\n * Find the next illegal byte sequence.\n */\n    void\nutf_find_illegal(void)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*p;\n    int\t\tlen;\n    vimconv_T\tvimconv;\n    char_u\t*tofree = NULL;\n\n    vimconv.vc_type = CONV_NONE;\n    if (enc_utf8 && (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT))\n    {\n\t// 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n\t// possibly a utf-8 file with illegal bytes.  Setup for conversion\n\t// from utf-8 to 'fileencoding'.\n\tconvert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n    }\n\n    curwin->w_cursor.coladd = 0;\n    for (;;)\n    {\n\tp = ml_get_cursor();\n\tif (vimconv.vc_type != CONV_NONE)\n\t{\n\t    vim_free(tofree);\n\t    tofree = string_convert(&vimconv, p, NULL);\n\t    if (tofree == NULL)\n\t\tbreak;\n\t    p = tofree;\n\t}\n\n\twhile (*p != NUL)\n\t{\n\t    // Illegal means that there are not enough trail bytes (checked by\n\t    // utf_ptr2len()) or too many of them (overlong sequence).\n\t    len = utf_ptr2len(p);\n\t    if (*p >= 0x80 && (len == 1\n\t\t\t\t     || utf_char2len(utf_ptr2char(p)) != len))\n\t    {\n\t\tif (vimconv.vc_type == CONV_NONE)\n\t\t    curwin->w_cursor.col += (colnr_T)(p - ml_get_cursor());\n\t\telse\n\t\t{\n\t\t    int\t    l;\n\n\t\t    len = (int)(p - tofree);\n\t\t    for (p = ml_get_cursor(); *p != NUL && len-- > 0; p += l)\n\t\t    {\n\t\t\tl = utf_ptr2len(p);\n\t\t\tcurwin->w_cursor.col += l;\n\t\t    }\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    p += len;\n\t}\n\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t    break;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // didn't find it: don't move and beep\n    curwin->w_cursor = pos;\n    beep_flush();\n\ntheend:\n    vim_free(tofree);\n    convert_setup(&vimconv, NULL, NULL);\n}\n\n#if defined(FEAT_GUI_GTK) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" is a valid utf-8 string.\n * When \"end\" is NULL stop at the first NUL.\n * When \"end\" is positive stop there.\n */\n    int\nutf_valid_string(char_u *s, char_u *end)\n{\n    int\t\tl;\n    char_u\t*p = s;\n\n    while (end == NULL ? *p != NUL : p < end)\n    {\n\tl = utf8len_tab_zero[*p];\n\tif (l == 0)\n\t    return FALSE;\t// invalid lead byte\n\tif (end != NULL && p + l > end)\n\t    return FALSE;\t// incomplete byte sequence\n\t++p;\n\twhile (--l > 0)\n\t    if ((*p++ & 0xc0) != 0x80)\n\t\treturn FALSE;\t// invalid trail byte\n    }\n    return TRUE;\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Special version of mb_tail_off() for use in ScreenLines[].\n */\n    int\ndbcs_screen_tail_off(char_u *base, char_u *p)\n{\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    // For euc-jp an 0x8e byte always means we have a lead byte in the current\n    // cell.\n    if (*p == NUL || p[1] == NUL\n\t    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t    || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_screen_head_off(base, p);\n}\n#endif\n\n/*\n * If the cursor moves on an trail byte, set the cursor on the lead byte.\n * Thus it moves left if necessary.\n * Return TRUE when the cursor was adjusted.\n */\n    void\nmb_adjust_cursor(void)\n{\n    mb_adjustpos(curbuf, &curwin->w_cursor);\n}\n\n/*\n * Adjust position \"*lp\" to point to the first byte of a multi-byte character.\n * If it points to a tail byte it's moved backwards to the head byte.\n */\n    void\nmb_adjustpos(buf_T *buf, pos_T *lp)\n{\n    char_u\t*p;\n\n    if (lp->col > 0 || lp->coladd > 1)\n    {\n\tp = ml_get_buf(buf, lp->lnum, FALSE);\n\tif (*p == NUL || (int)STRLEN(p) < lp->col)\n\t    lp->col = 0;\n\telse\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t// Reset \"coladd\" when the cursor would be on the right half of a\n\t// double-wide character.\n\tif (lp->coladd == 1\n\t\t&& p[lp->col] != TAB\n\t\t&& vim_isprintc((*mb_ptr2char)(p + lp->col))\n\t\t&& ptr2cells(p + lp->col) > 1)\n\t    lp->coladd = 0;\n    }\n}\n\n/*\n * Return a pointer to the character before \"*p\", if there is one.\n */\n    char_u *\nmb_prevptr(\n    char_u *line,\t// start of the string\n    char_u *p)\n{\n    if (p > line)\n\tMB_PTR_BACK(line, p);\n    return p;\n}\n\n/*\n * Return the character length of \"str\".  Each multi-byte character (with\n * following composing characters) counts as one.\n */\n    int\nmb_charlen(char_u *str)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    if (p == NULL)\n\treturn 0;\n\n    for (count = 0; *p != NUL; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Like mb_charlen() but for a string with specified length.\n */\n    int\nmb_charlen_len(char_u *str, int len)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    for (count = 0; *p != NUL && p < str + len; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Try to un-escape a multi-byte character.\n * Used for the \"to\" and \"from\" part of a mapping.\n * Return the un-escaped string if it is a multi-byte character, and advance\n * \"pp\" to just after the bytes that formed it.\n * Return NULL if no multi-byte char was found.\n */\n    char_u *\nmb_unescape(char_u **pp)\n{\n    static char_u\tbuf[6];\n    int\t\t\tn;\n    int\t\t\tm = 0;\n    char_u\t\t*str = *pp;\n\n    // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI\n    // KS_EXTRA KE_CSI to CSI.\n    // Maximum length of a utf-8 character is 4 bytes.\n    for (n = 0; str[n] != NUL && m < 4; ++n)\n    {\n\tif (str[n] == K_SPECIAL\n\t\t&& str[n + 1] == KS_SPECIAL\n\t\t&& str[n + 2] == KE_FILLER)\n\t{\n\t    buf[m++] = K_SPECIAL;\n\t    n += 2;\n\t}\n\telse if ((str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t    || str[n] == CSI\n# endif\n\t\t )\n\t\t&& str[n + 1] == KS_EXTRA\n\t\t&& str[n + 2] == (int)KE_CSI)\n\t{\n\t    buf[m++] = CSI;\n\t    n += 2;\n\t}\n\telse if (str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t|| str[n] == CSI\n# endif\n\t\t)\n\t    break;\t\t// a special key can't be a multibyte char\n\telse\n\t    buf[m++] = str[n];\n\tbuf[m] = NUL;\n\n\t// Return a multi-byte character if it's found.  An illegal sequence\n\t// will result in a 1 here.\n\tif ((*mb_ptr2len)(buf) > 1)\n\t{\n\t    *pp = str + n + 1;\n\t    return buf;\n\t}\n\n\t// Bail out quickly for ASCII.\n\tif (buf[0] < 128)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if the character at \"row\"/\"col\" on the screen is the left side\n * of a double-width character.\n * Caller must make sure \"row\" and \"col\" are not invalid!\n */\n    int\nmb_lefthalve(int row, int col)\n{\n    return (*mb_off2cells)(LineOffset[row] + col,\n\t\t\t\t\tLineOffset[row] + screen_Columns) > 1;\n}\n\n/*\n * Correct a position on the screen, if it's the right half of a double-wide\n * char move it to the left half.  Returns the corrected column.\n */\n    int\nmb_fix_col(int col, int row)\n{\n    int off;\n\n    col = check_col(col);\n    row = check_row(row);\n    off = LineOffset[row] + col;\n    if (has_mbyte && ScreenLines != NULL && col > 0\n\t    && ((enc_dbcs\n\t\t    && ScreenLines[off] != NUL\n\t\t    && dbcs_screen_head_off(ScreenLines + LineOffset[row],\n\t\t\t\t\t ScreenLines + off))\n\t\t|| (enc_utf8 && ScreenLines[off] == 0\n\t\t\t\t\t\t  && ScreenLinesUC[off] == 0)))\n\treturn col - 1;\n    return col;\n}\n\nstatic int enc_alias_search(char_u *name);\n\n/*\n * Skip the Vim specific head of a 'encoding' name.\n */\n    char_u *\nenc_skip(char_u *p)\n{\n    if (STRNCMP(p, \"2byte-\", 6) == 0)\n\treturn p + 6;\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\treturn p + 5;\n    return p;\n}\n\n/*\n * Find the canonical name for encoding \"enc\".\n * When the name isn't recognized, returns \"enc\" itself, but with all lower\n * case characters and '_' replaced with '-'.\n * Returns an allocated string.  NULL for out-of-memory.\n */\n    char_u *\nenc_canonize(char_u *enc)\n{\n    char_u\t*r;\n    char_u\t*p, *s;\n    int\t\ti;\n\n    if (STRCMP(enc, \"default\") == 0)\n    {\n#ifdef MSWIN\n\t// Use the system encoding, the default is always utf-8.\n\tr = enc_locale();\n#else\n\t// Use the default encoding as it's found by set_init_1().\n\tr = get_encoding_default();\n#endif\n\tif (r == NULL)\n\t    r = (char_u *)ENC_DFLT;\n\treturn vim_strsave(r);\n    }\n\n    // copy \"enc\" to allocated memory, with room for two '-'\n    r = alloc(STRLEN(enc) + 3);\n    if (r != NULL)\n    {\n\t// Make it all lower case and replace '_' with '-'.\n\tp = r;\n\tfor (s = enc; *s != NUL; ++s)\n\t{\n\t    if (*s == '_')\n\t\t*p++ = '-';\n\t    else\n\t\t*p++ = TOLOWER_ASC(*s);\n\t}\n\t*p = NUL;\n\n\t// Skip \"2byte-\" and \"8bit-\".\n\tp = enc_skip(r);\n\n\t// Change \"microsoft-cp\" to \"cp\".  Used in some spell files.\n\tif (STRNCMP(p, \"microsoft-cp\", 12) == 0)\n\t    STRMOVE(p, p + 10);\n\n\t// \"iso8859\" -> \"iso-8859\"\n\tif (STRNCMP(p, \"iso8859\", 7) == 0)\n\t{\n\t    STRMOVE(p + 4, p + 3);\n\t    p[3] = '-';\n\t}\n\n\t// \"iso-8859n\" -> \"iso-8859-n\"\n\tif (STRNCMP(p, \"iso-8859\", 8) == 0 && isdigit(p[8]))\n\t{\n\t    STRMOVE(p + 9, p + 8);\n\t    p[8] = '-';\n\t}\n\n\t// \"latin-N\" -> \"latinN\"\n\tif (STRNCMP(p, \"latin-\", 6) == 0)\n\t    STRMOVE(p + 5, p + 6);\n\n\tif (enc_canon_search(p) >= 0)\n\t{\n\t    // canonical name can be used unmodified\n\t    if (p != r)\n\t\tSTRMOVE(r, p);\n\t}\n\telse if ((i = enc_alias_search(p)) >= 0)\n\t{\n\t    // alias recognized, get canonical name\n\t    vim_free(r);\n\t    r = vim_strsave((char_u *)enc_canon_table[i].name);\n\t}\n    }\n    return r;\n}\n\n/*\n * Search for an encoding alias of \"name\".\n * Returns -1 when not found.\n */\n    static int\nenc_alias_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; enc_alias_table[i].name != NULL; ++i)\n\tif (STRCMP(name, enc_alias_table[i].name) == 0)\n\t    return enc_alias_table[i].canon;\n    return -1;\n}\n\n\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n/*\n * Get the canonicalized encoding from the specified locale string \"locale\"\n * or from the environment variables LC_ALL, LC_CTYPE and LANG.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale_env(char *locale)\n{\n    char\t*s = locale;\n    char\t*p;\n    int\t\ti;\n    char\tbuf[50];\n\n    if (s == NULL || *s == NUL)\n\tif ((s = getenv(\"LC_ALL\")) == NULL || *s == NUL)\n\t    if ((s = getenv(\"LC_CTYPE\")) == NULL || *s == NUL)\n\t\ts = getenv(\"LANG\");\n\n    if (s == NULL || *s == NUL)\n\treturn NULL;\n\n    // The most generic locale format is:\n    // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]\n    // If there is a '.' remove the part before it.\n    // if there is something after the codeset, remove it.\n    // Make the name lowercase and replace '_' with '-'.\n    // Exception: \"ja_JP.EUC\" == \"euc-jp\", \"zh_CN.EUC\" = \"euc-cn\",\n    // \"ko_KR.EUC\" == \"euc-kr\"\n    if ((p = (char *)vim_strchr((char_u *)s, '.')) != NULL)\n    {\n\tif (p > s + 2 && STRNICMP(p + 1, \"EUC\", 3) == 0\n\t\t\t&& !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_')\n\t{\n\t    // copy \"XY.EUC\" to \"euc-XY\" to buf[10]\n\t    STRCPY(buf + 10, \"euc-\");\n\t    buf[14] = p[-2];\n\t    buf[15] = p[-1];\n\t    buf[16] = 0;\n\t    s = buf + 10;\n\t}\n\telse\n\t    s = p + 1;\n    }\n    for (i = 0; i < (int)sizeof(buf) - 1 && s[i] != NUL; ++i)\n    {\n\tif (s[i] == '_' || s[i] == '-')\n\t    buf[i] = '-';\n\telse if (isalnum((int)s[i]))\n\t    buf[i] = TOLOWER_ASC(s[i]);\n\telse\n\t    break;\n    }\n    buf[i] = NUL;\n\n    return enc_canonize((char_u *)buf);\n}\n#endif\n\n/*\n * Get the canonicalized encoding of the current locale.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale(void)\n{\n#ifdef MSWIN\n    char\tbuf[50];\n    long\tacp = GetACP();\n\n    if (acp == 1200)\n\tSTRCPY(buf, \"ucs-2le\");\n    else if (acp == 1252)\t    // cp1252 is used as latin1\n\tSTRCPY(buf, \"latin1\");\n    else if (acp == 65001)\n\tSTRCPY(buf, \"utf-8\");\n    else\n\tsprintf(buf, \"cp%ld\", acp);\n\n    return enc_canonize((char_u *)buf);\n#else\n    char\t*s;\n\n# ifdef HAVE_NL_LANGINFO_CODESET\n    if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)\n# endif\n# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n\tif ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)\n# endif\n\t    s = NULL;\n\n    return enc_locale_env(s);\n#endif\n}\n\n# if defined(MSWIN) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n/*\n * Convert an encoding name to an MS-Windows codepage.\n * Returns zero if no codepage can be figured out.\n */\n    int\nencname2codepage(char_u *name)\n{\n    int\t\tcp;\n    char_u\t*p = name;\n    int\t\tidx;\n\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\tp += 5;\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n\tp += 6;\n\n    if (p[0] == 'c' && p[1] == 'p')\n\tcp = atoi((char *)p + 2);\n    else if ((idx = enc_canon_search(p)) >= 0)\n\tcp = enc_canon_table[idx].codepage;\n    else\n\treturn 0;\n    if (IsValidCodePage(cp))\n\treturn cp;\n    return 0;\n}\n# endif\n\n# if defined(USE_ICONV) || defined(PROTO)\n\n/*\n * Call iconv_open() with a check if iconv() works properly (there are broken\n * versions).\n * Returns (void *)-1 if failed.\n * (should return iconv_t, but that causes problems with prototypes).\n */\n    void *\nmy_iconv_open(char_u *to, char_u *from)\n{\n    iconv_t\tfd;\n#define ICONV_TESTLEN 400\n    char_u\ttobuf[ICONV_TESTLEN];\n    char\t*p;\n    size_t\ttolen;\n    static int\ticonv_ok = -1;\n\n    if (iconv_ok == FALSE)\n\treturn (void *)-1;\t// detected a broken iconv() previously\n\n#ifdef DYNAMIC_ICONV\n    // Check if the iconv.dll can be found.\n    if (!iconv_enabled(TRUE))\n\treturn (void *)-1;\n#endif\n\n    fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));\n\n    if (fd != (iconv_t)-1 && iconv_ok == -1)\n    {\n\t/*\n\t * Do a dummy iconv() call to check if it actually works.  There is a\n\t * version of iconv() on Linux that is broken.  We can't ignore it,\n\t * because it's wide-spread.  The symptoms are that after outputting\n\t * the initial shift state the \"to\" pointer is NULL and conversion\n\t * stops for no apparent reason after about 8160 characters.\n\t */\n\tp = (char *)tobuf;\n\ttolen = ICONV_TESTLEN;\n\t(void)iconv(fd, NULL, NULL, &p, &tolen);\n\tif (p == NULL)\n\t{\n\t    iconv_ok = FALSE;\n\t    iconv_close(fd);\n\t    fd = (iconv_t)-1;\n\t}\n\telse\n\t    iconv_ok = TRUE;\n    }\n\n    return (void *)fd;\n}\n\n/*\n * Convert the string \"str[slen]\" with iconv().\n * If \"unconvlenp\" is not NULL handle the string ending in an incomplete\n * sequence and set \"*unconvlenp\" to the length of it.\n * Returns the converted string in allocated memory.  NULL for an error.\n * If resultlenp is not NULL, sets it to the result length in bytes.\n */\n    static char_u *\niconv_string(\n    vimconv_T\t*vcp,\n    char_u\t*str,\n    int\t\tslen,\n    int\t\t*unconvlenp,\n    int\t\t*resultlenp)\n{\n    const char\t*from;\n    size_t\tfromlen;\n    char\t*to;\n    size_t\ttolen;\n    size_t\tlen = 0;\n    size_t\tdone = 0;\n    char_u\t*result = NULL;\n    char_u\t*p;\n    int\t\tl;\n\n    from = (char *)str;\n    fromlen = slen;\n    for (;;)\n    {\n\tif (len == 0 || ICONV_ERRNO == ICONV_E2BIG)\n\t{\n\t    // Allocate enough room for most conversions.  When re-allocating\n\t    // increase the buffer size.\n\t    len = len + fromlen * 2 + 40;\n\t    p = alloc(len);\n\t    if (p != NULL && done > 0)\n\t\tmch_memmove(p, result, done);\n\t    vim_free(result);\n\t    result = p;\n\t    if (result == NULL)\t// out of memory\n\t\tbreak;\n\t}\n\n\tto = (char *)result + done;\n\ttolen = len - done - 2;\n\t// Avoid a warning for systems with a wrong iconv() prototype by\n\t// casting the second argument to void *.\n\tif (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t\t\t\t\t\t!= (size_t)-1)\n\t{\n\t    // Finished, append a NUL.\n\t    *to = NUL;\n\t    break;\n\t}\n\n\t// Check both ICONV_EINVAL and EINVAL, because the dynamically loaded\n\t// iconv library may use one of them.\n\tif (!vcp->vc_fail && unconvlenp != NULL\n\t\t&& (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Handle an incomplete sequence at the end.\n\t    *to = NUL;\n\t    *unconvlenp = (int)fromlen;\n\t    break;\n\t}\n\n\t// Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded\n\t// iconv library may use one of them.\n\telse if (!vcp->vc_fail\n\t\t&& (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ\n\t\t    || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Can't convert: insert a '?' and skip a character.  This assumes\n\t    // conversion from 'encoding' to something else.  In other\n\t    // situations we don't know what to skip anyway.\n\t    *to++ = '?';\n\t    if ((*mb_ptr2cells)((char_u *)from) > 1)\n\t\t*to++ = '?';\n\t    if (enc_utf8)\n\t\tl = utfc_ptr2len_len((char_u *)from, (int)fromlen);\n\t    else\n\t    {\n\t\tl = (*mb_ptr2len)((char_u *)from);\n\t\tif (l > (int)fromlen)\n\t\t    l = (int)fromlen;\n\t    }\n\t    from += l;\n\t    fromlen -= l;\n\t}\n\telse if (ICONV_ERRNO != ICONV_E2BIG)\n\t{\n\t    // conversion failed\n\t    VIM_CLEAR(result);\n\t    break;\n\t}\n\t// Not enough room or skipping illegal sequence.\n\tdone = to - (char *)result;\n    }\n\n    if (resultlenp != NULL && result != NULL)\n\t*resultlenp = (int)(to - (char *)result);\n    return result;\n}\n\n#  if defined(DYNAMIC_ICONV) || defined(PROTO)\n/*\n * Dynamically load the \"iconv.dll\" on Win32.\n */\n\n#   ifndef DYNAMIC_ICONV\t    // must be generating prototypes\n#    define HINSTANCE int\n#   endif\nstatic HINSTANCE hIconvDLL = 0;\nstatic HINSTANCE hMsvcrtDLL = 0;\n\n#   ifndef DYNAMIC_ICONV_DLL\n#    define DYNAMIC_ICONV_DLL \"iconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT1 \"libiconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT2 \"libiconv2.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT3 \"libiconv-2.dll\"\n#   endif\n#   ifndef DYNAMIC_MSVCRT_DLL\n#    define DYNAMIC_MSVCRT_DLL \"msvcrt.dll\"\n#   endif\n\n/*\n * Try opening the iconv.dll and return TRUE if iconv() can be used.\n */\n    int\niconv_enabled(int verbose)\n{\n    if (hIconvDLL != 0 && hMsvcrtDLL != 0)\n\treturn TRUE;\n\n    // The iconv DLL file goes under different names, try them all.\n    // Do the \"2\" version first, it's newer.\n#ifdef DYNAMIC_ICONV_DLL_ALT2\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT2);\n#endif\n#ifdef DYNAMIC_ICONV_DLL_ALT3\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT3);\n#endif\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);\n#ifdef DYNAMIC_ICONV_DLL_ALT1\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT1);\n#endif\n\n    if (hIconvDLL != 0)\n\thMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);\n    if (hIconvDLL == 0 || hMsvcrtDLL == 0)\n    {\n\t// Only give the message when 'verbose' is set, otherwise it might be\n\t// done whenever a conversion is attempted.\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_str_str),\n\t\t    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL,\n\t\t    GetWin32Error());\n\t    verbose_leave();\n\t}\n\ticonv_end();\n\treturn FALSE;\n    }\n\n    iconv\t= (void *)GetProcAddress(hIconvDLL, \"libiconv\");\n    iconv_open\t= (void *)GetProcAddress(hIconvDLL, \"libiconv_open\");\n    iconv_close\t= (void *)GetProcAddress(hIconvDLL, \"libiconv_close\");\n    iconvctl\t= (void *)GetProcAddress(hIconvDLL, \"libiconvctl\");\n    iconv_errno\t= get_dll_import_func(hIconvDLL, \"_errno\");\n    if (iconv_errno == NULL)\n\ticonv_errno = (void *)GetProcAddress(hMsvcrtDLL, \"_errno\");\n    if (iconv == NULL || iconv_open == NULL || iconv_close == NULL\n\t    || iconvctl == NULL || iconv_errno == NULL)\n    {\n\ticonv_end();\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_function_str), \"for libiconv\");\n\t    verbose_leave();\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n    void\niconv_end(void)\n{\n    // Don't use iconv() when inputting or outputting characters.\n    if (input_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&input_conv, NULL, NULL);\n    if (output_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&output_conv, NULL, NULL);\n\n    if (hIconvDLL != 0)\n\tFreeLibrary(hIconvDLL);\n    if (hMsvcrtDLL != 0)\n\tFreeLibrary(hMsvcrtDLL);\n    hIconvDLL = 0;\n    hMsvcrtDLL = 0;\n}\n#  endif // DYNAMIC_ICONV\n# endif // USE_ICONV\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getimstatus()\" function\n */\n    void\nf_getimstatus(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# if defined(HAVE_INPUT_METHOD)\n    rettv->vval.v_number = im_get_status();\n# endif\n}\n\n/*\n * iconv() function\n */\n    void\nf_iconv(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*from, *to, *str;\n    vimconv_T\tvimconv;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string(&argvars[0]);\n    from = enc_canonize(enc_skip(tv_get_string_buf(&argvars[1], buf1)));\n    to = enc_canonize(enc_skip(tv_get_string_buf(&argvars[2], buf2)));\n    vimconv.vc_type = CONV_NONE;\n    convert_setup(&vimconv, from, to);\n\n    // If the encodings are equal, no conversion needed.\n    if (vimconv.vc_type == CONV_NONE)\n\trettv->vval.v_string = vim_strsave(str);\n    else\n\trettv->vval.v_string = string_convert(&vimconv, str, NULL);\n\n    convert_setup(&vimconv, NULL, NULL);\n    vim_free(from);\n    vim_free(to);\n}\n#endif\n\n/*\n * Setup \"vcp\" for conversion from \"from\" to \"to\".\n * The names must have been made canonical with enc_canonize().\n * vcp->vc_type must have been initialized to CONV_NONE.\n * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8\n * instead).\n * Afterwards invoke with \"from\" and \"to\" equal to NULL to cleanup.\n * Return FAIL when conversion is not supported, OK otherwise.\n */\n    int\nconvert_setup(vimconv_T *vcp, char_u *from, char_u *to)\n{\n    return convert_setup_ext(vcp, from, TRUE, to, TRUE);\n}\n\n/*\n * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all\n * \"from\" unicode charsets be considered utf-8.  Same for \"to\".\n */\n    int\nconvert_setup_ext(\n    vimconv_T\t*vcp,\n    char_u\t*from,\n    int\t\tfrom_unicode_is_utf8,\n    char_u\t*to,\n    int\t\tto_unicode_is_utf8)\n{\n    int\t\tfrom_prop;\n    int\t\tto_prop;\n    int\t\tfrom_is_utf8;\n    int\t\tto_is_utf8;\n\n    // Reset to no conversion.\n#ifdef USE_ICONV\n    if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)\n\ticonv_close(vcp->vc_fd);\n#endif\n    vcp->vc_type = CONV_NONE;\n    vcp->vc_factor = 1;\n    vcp->vc_fail = FALSE;\n\n    // No conversion when one of the names is empty or they are equal.\n    if (from == NULL || *from == NUL || to == NULL || *to == NUL\n\t\t\t\t\t\t     || STRCMP(from, to) == 0)\n\treturn OK;\n\n    from_prop = enc_canon_props(from);\n    to_prop = enc_canon_props(to);\n    if (from_unicode_is_utf8)\n\tfrom_is_utf8 = from_prop & ENC_UNICODE;\n    else\n\tfrom_is_utf8 = from_prop == ENC_UNICODE;\n    if (to_unicode_is_utf8)\n\tto_is_utf8 = to_prop & ENC_UNICODE;\n    else\n\tto_is_utf8 = to_prop == ENC_UNICODE;\n\n    if ((from_prop & ENC_LATIN1) && to_is_utf8)\n    {\n\t// Internal latin1 -> utf-8 conversion.\n\tvcp->vc_type = CONV_TO_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN9) && to_is_utf8)\n    {\n\t// Internal latin9 -> utf-8 conversion.\n\tvcp->vc_type = CONV_9_TO_UTF8;\n\tvcp->vc_factor = 3;\t// up to three as long (euro sign)\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN1))\n    {\n\t// Internal utf-8 -> latin1 conversion.\n\tvcp->vc_type = CONV_TO_LATIN1;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN9))\n    {\n\t// Internal utf-8 -> latin9 conversion.\n\tvcp->vc_type = CONV_TO_LATIN9;\n    }\n#ifdef MSWIN\n    // Win32-specific codepage <-> codepage conversion without iconv.\n    else if ((from_is_utf8 || encname2codepage(from) > 0)\n\t    && (to_is_utf8 || encname2codepage(to) > 0))\n    {\n\tvcp->vc_type = CONV_CODEPAGE;\n\tvcp->vc_factor = 2;\t// up to twice as long\n\tvcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);\n\tvcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);\n    }\n#endif\n#ifdef MACOS_CONVERT\n    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))\n    {\n\tvcp->vc_type = CONV_MAC_LATIN1;\n    }\n    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)\n    {\n\tvcp->vc_type = CONV_MAC_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_LATIN1_MAC;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_UTF8_MAC;\n    }\n#endif\n#ifdef USE_ICONV\n    else\n    {\n\t// Use iconv() for conversion.\n\tvcp->vc_fd = (iconv_t)my_iconv_open(\n\t\tto_is_utf8 ? (char_u *)\"utf-8\" : to,\n\t\tfrom_is_utf8 ? (char_u *)\"utf-8\" : from);\n\tif (vcp->vc_fd != (iconv_t)-1)\n\t{\n\t    vcp->vc_type = CONV_ICONV;\n\t    vcp->vc_factor = 4;\t// could be longer too...\n\t}\n    }\n#endif\n    if (vcp->vc_type == CONV_NONE)\n\treturn FAIL;\n\n    return OK;\n}\n\n#if defined(FEAT_GUI) || defined(AMIGA) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Do conversion on typed input characters in-place.\n * The input and output are not NUL terminated!\n * Returns the length after conversion.\n */\n    int\nconvert_input(char_u *ptr, int len, int maxlen)\n{\n    return convert_input_safe(ptr, len, maxlen, NULL, NULL);\n}\n#endif\n\n/*\n * Like convert_input(), but when there is an incomplete byte sequence at the\n * end return that as an allocated string in \"restp\" and set \"*restlenp\" to\n * the length.  If \"restp\" is NULL it is not used.\n */\n    int\nconvert_input_safe(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tmaxlen,\n    char_u\t**restp,\n    int\t\t*restlenp)\n{\n    char_u\t*d;\n    int\t\tdlen = len;\n    int\t\tunconvertlen = 0;\n\n    d = string_convert_ext(&input_conv, ptr, &dlen,\n\t\t\t\t\trestp == NULL ? NULL : &unconvertlen);\n    if (d != NULL)\n    {\n\tif (dlen <= maxlen)\n\t{\n\t    if (unconvertlen > 0)\n\t    {\n\t\t// Move the unconverted characters to allocated memory.\n\t\t*restp = alloc(unconvertlen);\n\t\tif (*restp != NULL)\n\t\t    mch_memmove(*restp, ptr + len - unconvertlen, unconvertlen);\n\t\t*restlenp = unconvertlen;\n\t    }\n\t    mch_memmove(ptr, d, dlen);\n\t}\n\telse\n\t    // result is too long, keep the unconverted text (the caller must\n\t    // have done something wrong!)\n\t    dlen = len;\n\tvim_free(d);\n    }\n    return dlen;\n}\n\n/*\n * Convert text \"ptr[*lenp]\" according to \"vcp\".\n * Returns the result in allocated memory and sets \"*lenp\".\n * When \"lenp\" is NULL, use NUL terminated strings.\n * Illegal chars are often changed to \"?\", unless vcp->vc_fail is set.\n * When something goes wrong, NULL is returned and \"*lenp\" is unchanged.\n */\n    char_u *\nstring_convert(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp)\n{\n    return string_convert_ext(vcp, ptr, lenp, NULL);\n}\n\n/*\n * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is\n * an incomplete sequence at the end it is not converted and \"*unconvlenp\" is\n * set to the number of remaining bytes.\n */\n    char_u *\nstring_convert_ext(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp,\n    int\t\t*unconvlenp)\n{\n    char_u\t*retval = NULL;\n    char_u\t*d;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tl;\n    int\t\tc;\n\n    if (lenp == NULL)\n\tlen = (int)STRLEN(ptr);\n    else\n\tlen = *lenp;\n    if (len == 0)\n\treturn vim_strsave((char_u *)\"\");\n\n    switch (vcp->vc_type)\n    {\n\tcase CONV_TO_UTF8:\t// latin1 to utf-8 conversion\n\t    retval = alloc(len * 2 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tif (c < 0x80)\n\t\t    *d++ = c;\n\t\telse\n\t\t{\n\t\t    *d++ = 0xc0 + ((unsigned)c >> 6);\n\t\t    *d++ = 0x80 + (c & 0x3f);\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_9_TO_UTF8:\t// latin9 to utf-8 conversion\n\t    retval = alloc(len * 3 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tswitch (c)\n\t\t{\n\t\t    case 0xa4: c = 0x20ac; break;   // euro\n\t\t    case 0xa6: c = 0x0160; break;   // S hat\n\t\t    case 0xa8: c = 0x0161; break;   // S -hat\n\t\t    case 0xb4: c = 0x017d; break;   // Z hat\n\t\t    case 0xb8: c = 0x017e; break;   // Z -hat\n\t\t    case 0xbc: c = 0x0152; break;   // OE\n\t\t    case 0xbd: c = 0x0153; break;   // oe\n\t\t    case 0xbe: c = 0x0178; break;   // Y\n\t\t}\n\t\td += utf_char2bytes(c, d);\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_TO_LATIN1:\t// utf-8 to latin1 conversion\n\tcase CONV_TO_LATIN9:\t// utf-8 to latin9 conversion\n\t    retval = alloc(len + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tl = utf_ptr2len_len(ptr + i, len - i);\n\t\tif (l == 0)\n\t\t    *d++ = NUL;\n\t\telse if (l == 1)\n\t\t{\n\t\t    int l_w = utf8len_tab_zero[ptr[i]];\n\n\t\t    if (l_w == 0)\n\t\t    {\n\t\t\t// Illegal utf-8 byte cannot be converted\n\t\t\tvim_free(retval);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (unconvlenp != NULL && l_w > len - i)\n\t\t    {\n\t\t\t// Incomplete sequence at the end.\n\t\t\t*unconvlenp = len - i;\n\t\t\tbreak;\n\t\t    }\n\t\t    *d++ = ptr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = utf_ptr2char(ptr + i);\n\t\t    if (vcp->vc_type == CONV_TO_LATIN9)\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 0x20ac: c = 0xa4; break;   // euro\n\t\t\t    case 0x0160: c = 0xa6; break;   // S hat\n\t\t\t    case 0x0161: c = 0xa8; break;   // S -hat\n\t\t\t    case 0x017d: c = 0xb4; break;   // Z hat\n\t\t\t    case 0x017e: c = 0xb8; break;   // Z -hat\n\t\t\t    case 0x0152: c = 0xbc; break;   // OE\n\t\t\t    case 0x0153: c = 0xbd; break;   // oe\n\t\t\t    case 0x0178: c = 0xbe; break;   // Y\n\t\t\t    case 0xa4:\n\t\t\t    case 0xa6:\n\t\t\t    case 0xa8:\n\t\t\t    case 0xb4:\n\t\t\t    case 0xb8:\n\t\t\t    case 0xbc:\n\t\t\t    case 0xbd:\n\t\t\t    case 0xbe: c = 0x100; break; // not in latin9\n\t\t\t}\n\t\t    if (!utf_iscomposing(c))\t// skip composing chars\n\t\t    {\n\t\t\tif (c < 0x100)\n\t\t\t    *d++ = c;\n\t\t\telse if (vcp->vc_fail)\n\t\t\t{\n\t\t\t    vim_free(retval);\n\t\t\t    return NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    *d++ = 0xbf;\n\t\t\t    if (utf_char2cells(c) > 1)\n\t\t\t\t*d++ = '?';\n\t\t\t}\n\t\t    }\n\t\t    i += l - 1;\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n# ifdef MACOS_CONVERT\n\tcase CONV_MAC_LATIN1:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'l', unconvlenp);\n\t    break;\n\n\tcase CONV_LATIN1_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'l', 'm', unconvlenp);\n\t    break;\n\n\tcase CONV_MAC_UTF8:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'u', unconvlenp);\n\t    break;\n\n\tcase CONV_UTF8_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'u', 'm', unconvlenp);\n\t    break;\n# endif\n\n# ifdef USE_ICONV\n\tcase CONV_ICONV:\t// conversion with output_conv.vc_fd\n\t    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);\n\t    break;\n# endif\n# ifdef MSWIN\n\tcase CONV_CODEPAGE:\t\t// codepage -> codepage\n\t{\n\t    int\t\tretlen;\n\t    int\t\ttmp_len;\n\t    short_u\t*tmp;\n\n\t    // 1. codepage/UTF-8  ->  ucs-2.\n\t    if (vcp->vc_cpfrom == 0)\n\t\ttmp_len = utf8_to_utf16(ptr, len, NULL, NULL);\n\t    else\n\t    {\n\t\ttmp_len = MultiByteToWideChar(vcp->vc_cpfrom,\n\t\t\t\t\tunconvlenp ? MB_ERR_INVALID_CHARS : 0,\n\t\t\t\t\t(char *)ptr, len, 0, 0);\n\t\tif (tmp_len == 0\n\t\t\t&& GetLastError() == ERROR_NO_UNICODE_TRANSLATION)\n\t\t{\n\t\t    if (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\t    if (unconvlenp != NULL)\n\t\t\t*unconvlenp = len;\n\t\t    retval = alloc(1);\n\t\t    if (retval)\n\t\t\tretval[0] = NUL;\n\t\t    return retval;\n\t\t}\n\t    }\n\t    tmp = ALLOC_MULT(short_u, tmp_len);\n\t    if (tmp == NULL)\n\t\tbreak;\n\t    if (vcp->vc_cpfrom == 0)\n\t\tutf8_to_utf16(ptr, len, tmp, unconvlenp);\n\t    else\n\t\tMultiByteToWideChar(vcp->vc_cpfrom, 0,\n\t\t\t(char *)ptr, len, tmp, tmp_len);\n\n\t    // 2. ucs-2  ->  codepage/UTF-8.\n\t    if (vcp->vc_cpto == 0)\n\t\tretlen = utf16_to_utf8(tmp, tmp_len, NULL);\n\t    else\n\t\tretlen = WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t\t    tmp, tmp_len, 0, 0, 0, 0);\n\t    retval = alloc(retlen + 1);\n\t    if (retval != NULL)\n\t    {\n\t\tif (vcp->vc_cpto == 0)\n\t\t    utf16_to_utf8(tmp, tmp_len, retval);\n\t\telse\n\t\t    WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t  tmp, tmp_len,\n\t\t\t\t\t  (char *)retval, retlen, 0, 0);\n\t\tretval[retlen] = NUL;\n\t\tif (lenp != NULL)\n\t\t    *lenp = retlen;\n\t    }\n\t    vim_free(tmp);\n\t    break;\n\t}\n# endif\n    }\n\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Table set by setcellwidths().\n */\ntypedef struct\n{\n    long    first;\n    long    last;\n    char    width;\n} cw_interval_T;\n\nstatic cw_interval_T\t*cw_table = NULL;\nstatic size_t\t\tcw_table_size = 0;\n\n/*\n * Return 1 or 2 when \"c\" is in the cellwidth table.\n * Return 0 if not.\n */\n    static int\ncw_value(int c)\n{\n    int mid, bot, top;\n\n    if (cw_table == NULL)\n\treturn 0;\n\n    // first quick check for Latin1 etc. characters\n    if (c < cw_table[0].first)\n\treturn 0;\n\n    // binary search in table\n    bot = 0;\n    top = (int)cw_table_size - 1;\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (cw_table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (cw_table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return cw_table[mid].width;\n    }\n    return 0;\n}\n\n    static int\ntv_nr_compare(const void *a1, const void *a2)\n{\n    listitem_T *li1 = *(listitem_T **)a1;\n    listitem_T *li2 = *(listitem_T **)a2;\n\n    return li1->li_tv.vval.v_number - li2->li_tv.vval.v_number;\n}\n\n    void\nf_setcellwidths(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    list_T\t    *l;\n    listitem_T\t    *li;\n    int\t\t    item;\n    int\t\t    i;\n    listitem_T\t    **ptrs;\n    cw_interval_T   *table;\n    cw_interval_T   *cw_table_save;\n    size_t\t    cw_table_size_save;\n\n    if (in_vim9script() && check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn;\n    }\n    l = argvars[0].vval.v_list;\n    if (l->lv_len == 0)\n    {\n\t// Clearing the table.\n\tvim_free(cw_table);\n\tcw_table = NULL;\n\tcw_table_size = 0;\n\treturn;\n    }\n\n    ptrs = ALLOC_MULT(listitem_T *, l->lv_len);\n    if (ptrs == NULL)\n\treturn;\n\n    // Check that all entries are a list with three numbers, the range is\n    // valid and the cell width is valid.\n    item = 0;\n    for (li = l->lv_first; li != NULL; li = li->li_next)\n    {\n\tlistitem_T *lili;\n\tvarnumber_T n1;\n\n\tif (li->li_tv.v_type != VAR_LIST || li->li_tv.vval.v_list == NULL)\n\t{\n\t    semsg(_(e_list_item_nr_is_not_list), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\n\tlili = li->li_tv.vval.v_list->lv_first;\n\tptrs[item] = lili;\n\tfor (i = 0; lili != NULL; lili = lili->li_next, ++i)\n\t{\n\t    if (lili->li_tv.v_type != VAR_NUMBER)\n\t\tbreak;\n\t    if (i == 0)\n\t    {\n\t\tn1 = lili->li_tv.vval.v_number;\n\t\tif (n1 < 0x100)\n\t\t{\n\t\t    emsg(_(e_only_values_of_0x100_and_higher_supported));\n\t\t    vim_free(ptrs);\n\t\t    return;\n\t\t}\n\t    }\n\t    else if (i == 1 && lili->li_tv.vval.v_number < n1)\n\t    {\n\t\tsemsg(_(e_list_item_nr_range_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t    else if (i == 2 && (lili->li_tv.vval.v_number < 1\n\t\t\t\t\t     || lili->li_tv.vval.v_number > 2))\n\t    {\n\t\tsemsg(_(e_list_item_nr_cell_width_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t}\n\tif (i != 3)\n\t{\n\t    semsg(_(e_list_item_nr_does_not_contain_3_numbers), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\t++item;\n    }\n\n    // Sort the list on the first number.\n    qsort((void *)ptrs, (size_t)l->lv_len, sizeof(listitem_T *), tv_nr_compare);\n\n    table = ALLOC_MULT(cw_interval_T, l->lv_len);\n    if (table == NULL)\n    {\n\tvim_free(ptrs);\n\treturn;\n    }\n\n    // Store the items in the new table.\n    item = 0;\n    for (item = 0; item < l->lv_len; ++item)\n    {\n\tlistitem_T\t*lili = ptrs[item];\n\tvarnumber_T\tn1;\n\n\tn1 = lili->li_tv.vval.v_number;\n\tif (item > 0 && n1 <= table[item - 1].last)\n\t{\n\t    semsg(_(e_overlapping_ranges_for_nr), (long)n1);\n\t    vim_free(ptrs);\n\t    vim_free(table);\n\t    return;\n\t}\n\ttable[item].first = n1;\n\tlili = lili->li_next;\n\ttable[item].last = lili->li_tv.vval.v_number;\n\tlili = lili->li_next;\n\ttable[item].width = lili->li_tv.vval.v_number;\n    }\n\n    vim_free(ptrs);\n\n    cw_table_save = cw_table;\n    cw_table_size_save = cw_table_size;\n    cw_table = table;\n    cw_table_size = l->lv_len;\n\n    // Check that the new value does not conflict with 'fillchars' or\n    // 'listchars'.\n    if (set_chars_option(curwin, &p_fcs) != NULL)\n    {\n\temsg(_(e_conflicts_with_value_of_fillchars));\n\tcw_table = cw_table_save;\n\tcw_table_size = cw_table_size_save;\n\tvim_free(table);\n\treturn;\n    }\n    else\n    {\n\ttabpage_T\t*tp;\n\twin_T\t*wp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t{\n\t    if (set_chars_option(wp, &wp->w_p_lcs) != NULL)\n\t    {\n\t\temsg((e_conflicts_with_value_of_listchars));\n\t\tcw_table = cw_table_save;\n\t\tcw_table_size = cw_table_size_save;\n\t\tvim_free(table);\n\t\treturn;\n\t    }\n\t}\n    }\n\n    vim_free(cw_table_save);\n}\n\n    void\nf_charclass(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || argvars[0].vval.v_string == NULL)\n\treturn;\n    rettv->vval.v_number = mb_get_class(argvars[0].vval.v_string);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellfile.c: code for reading and writing spell files.\n *\n * See spell.c for information about spell checking.\n */\n\n/*\n * Vim spell file format: <HEADER>\n *\t\t\t  <SECTIONS>\n *\t\t\t  <LWORDTREE>\n *\t\t\t  <KWORDTREE>\n *\t\t\t  <PREFIXTREE>\n *\n * <HEADER>: <fileID> <versionnr>\n *\n * <fileID>     8 bytes    \"VIMspell\"\n * <versionnr>  1 byte\t    VIMSPELLVERSION\n *\n *\n * Sections make it possible to add information to the .spl file without\n * making it incompatible with previous versions.  There are two kinds of\n * sections:\n * 1. Not essential for correct spell checking.  E.g. for making suggestions.\n *    These are skipped when not supported.\n * 2. Optional information, but essential for spell checking when present.\n *    E.g. conditions for affixes.  When this section is present but not\n *    supported an error message is given.\n *\n * <SECTIONS>: <section> ... <sectionend>\n *\n * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n *\n * <sectionID>\t  1 byte    number from 0 to 254 identifying the section\n *\n * <sectionflags> 1 byte    SNF_REQUIRED: this section is required for correct\n *\t\t\t\t\t    spell checking\n *\n * <sectionlen>   4 bytes   length of section contents, MSB first\n *\n * <sectionend>\t  1 byte    SN_END\n *\n *\n * sectionID == SN_INFO: <infotext>\n * <infotext>\t N bytes    free format text with spell file info (version,\n *\t\t\t    website, etc)\n *\n * sectionID == SN_REGION: <regionname> ...\n * <regionname>\t 2 bytes    Up to MAXREGIONS region names: ca, au, etc.  Lower\n *\t\t\t    case.  First <regionname> is region 1.\n *\n * sectionID == SN_CHARFLAGS: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * <charflagslen> 1 byte    Number of bytes in <charflags> (should be 128).\n * <charflags>  N bytes     List of flags (first one is for character 128):\n *\t\t\t    0x01  word character\tCF_WORD\n *\t\t\t    0x02  upper-case character\tCF_UPPER\n * <folcharslen>  2 bytes   Number of bytes in <folchars>.\n * <folchars>     N bytes   Folded characters, first one is for character 128.\n *\n * sectionID == SN_MIDWORD: <midword>\n * <midword>     N bytes    Characters that are word characters only when used\n *\t\t\t    in the middle of a word.\n *\n * sectionID == SN_PREFCOND: <prefcondcnt> <prefcond> ...\n * <prefcondcnt> 2 bytes    Number of <prefcond> items following.\n * <prefcond> : <condlen> <condstr>\n * <condlen>\t1 byte\t    Length of <condstr>.\n * <condstr>\tN bytes\t    Condition for the prefix.\n *\n * sectionID == SN_REP: <repcount> <rep> ...\n * <repcount>\t 2 bytes    number of <rep> items, MSB first.\n * <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n * <repfromlen>\t 1 byte\t    length of <repfrom>\n * <repfrom>\t N bytes    \"from\" part of replacement\n * <reptolen>\t 1 byte\t    length of <repto>\n * <repto>\t N bytes    \"to\" part of replacement\n *\n * sectionID == SN_REPSAL: <repcount> <rep> ...\n *   just like SN_REP but for soundfolded words\n *\n * sectionID == SN_SAL: <salflags> <salcount> <sal> ...\n * <salflags>\t 1 byte\t    flags for soundsalike conversion:\n *\t\t\t    SAL_F0LLOWUP\n *\t\t\t    SAL_COLLAPSE\n *\t\t\t    SAL_REM_ACCENTS\n * <salcount>    2 bytes    number of <sal> items following\n * <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n * <salfromlen>\t 1 byte\t    length of <salfrom>\n * <salfrom>\t N bytes    \"from\" part of soundsalike\n * <saltolen>\t 1 byte\t    length of <salto>\n * <salto>\t N bytes    \"to\" part of soundsalike\n *\n * sectionID == SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * <sofofromlen> 2 bytes    length of <sofofrom>\n * <sofofrom>\t N bytes    \"from\" part of soundfold\n * <sofotolen>\t 2 bytes    length of <sofoto>\n * <sofoto>\t N bytes    \"to\" part of soundfold\n *\n * sectionID == SN_SUGFILE: <timestamp>\n * <timestamp>   8 bytes    time in seconds that must match with .sug file\n *\n * sectionID == SN_NOSPLITSUGS: nothing\n\t *\n * sectionID == SN_NOCOMPOUNDSUGS: nothing\n *\n * sectionID == SN_WORDS: <word> ...\n * <word>\t N bytes    NUL terminated common word\n *\n * sectionID == SN_MAP: <mapstr>\n * <mapstr>\t N bytes    String with sequences of similar characters,\n *\t\t\t    separated by slashes.\n *\n * sectionID == SN_COMPOUND: <compmax> <compminlen> <compsylmax> <compoptions>\n *\t\t\t\t<comppatcount> <comppattern> ... <compflags>\n * <compmax>     1 byte\t    Maximum nr of words in compound word.\n * <compminlen>  1 byte\t    Minimal word length for compounding.\n * <compsylmax>  1 byte\t    Maximum nr of syllables in compound word.\n * <compoptions> 2 bytes    COMP_ flags.\n * <comppatcount> 2 bytes   number of <comppattern> following\n * <compflags>   N bytes    Flags from COMPOUNDRULE items, separated by\n *\t\t\t    slashes.\n *\n * <comppattern>: <comppatlen> <comppattext>\n * <comppatlen>\t 1 byte\t    length of <comppattext>\n * <comppattext> N bytes    end or begin chars from CHECKCOMPOUNDPATTERN\n *\n * sectionID == SN_NOBREAK: (empty, its presence is what matters)\n *\n * sectionID == SN_SYLLABLE: <syllable>\n * <syllable>    N bytes    String from SYLLABLE item.\n *\n * <LWORDTREE>: <wordtree>\n *\n * <KWORDTREE>: <wordtree>\n *\n * <PREFIXTREE>: <wordtree>\n *\n *\n * <wordtree>: <nodecount> <nodedata> ...\n *\n * <nodecount>\t4 bytes\t    Number of nodes following.  MSB first.\n *\n * <nodedata>: <siblingcount> <sibling> ...\n *\n * <siblingcount> 1 byte    Number of siblings in this node.  The siblings\n *\t\t\t    follow in sorted order.\n *\n * <sibling>: <byte> [ <nodeidx> <xbyte>\n *\t\t      | <flags> [<flags2>] [<region>] [<affixID>]\n *\t\t      | [<pflags>] <affixID> <prefcondnr> ]\n *\n * <byte>\t1 byte\t    Byte value of the sibling.  Special cases:\n *\t\t\t    BY_NOFLAGS: End of word without flags and for all\n *\t\t\t\t\tregions.\n *\t\t\t\t\tFor PREFIXTREE <affixID> and\n *\t\t\t\t\t<prefcondnr> follow.\n *\t\t\t    BY_FLAGS:   End of word, <flags> follow.\n *\t\t\t\t\tFor PREFIXTREE <pflags>, <affixID>\n *\t\t\t\t\tand <prefcondnr> follow.\n *\t\t\t    BY_FLAGS2:  End of word, <flags> and <flags2>\n *\t\t\t\t\tfollow.  Not used in PREFIXTREE.\n *\t\t\t    BY_INDEX:   Child of sibling is shared, <nodeidx>\n *\t\t\t\t\tand <xbyte> follow.\n *\n * <nodeidx>\t3 bytes\t    Index of child for this sibling, MSB first.\n *\n * <xbyte>\t1 byte\t    byte value of the sibling.\n *\n * <flags>\t1 byte\t    bitmask of:\n *\t\t\t    WF_ALLCAP\tword must have only capitals\n *\t\t\t    WF_ONECAP   first char of word must be capital\n *\t\t\t    WF_KEEPCAP\tkeep-case word\n *\t\t\t    WF_FIXCAP   keep-case word, all caps not allowed\n *\t\t\t    WF_RARE\trare word\n *\t\t\t    WF_BANNED\tbad word\n *\t\t\t    WF_REGION\t<region> follows\n *\t\t\t    WF_AFX\t<affixID> follows\n *\n * <flags2>\t1 byte\t    Bitmask of:\n *\t\t\t    WF_HAS_AFF >> 8   word includes affix\n *\t\t\t    WF_NEEDCOMP >> 8  word only valid in compound\n *\t\t\t    WF_NOSUGGEST >> 8  word not used for suggestions\n *\t\t\t    WF_COMPROOT >> 8  word already a compound\n *\t\t\t    WF_NOCOMPBEF >> 8 no compounding before this word\n *\t\t\t    WF_NOCOMPAFT >> 8 no compounding after this word\n *\n * <pflags>\t1 byte\t    bitmask of:\n *\t\t\t    WFP_RARE\trare prefix\n *\t\t\t    WFP_NC\tnon-combining prefix\n *\t\t\t    WFP_UP\tletter after prefix made upper case\n *\n * <region>\t1 byte\t    Bitmask for regions in which word is valid.  When\n *\t\t\t    omitted it's valid in all regions.\n *\t\t\t    Lowest bit is for region 1.\n *\n * <affixID>\t1 byte\t    ID of affix that can be used with this word.  In\n *\t\t\t    PREFIXTREE used for the required prefix ID.\n *\n * <prefcondnr>\t2 bytes\t    Prefix condition number, index in <prefcond> list\n *\t\t\t    from HEADER.\n *\n * All text characters are in 'encoding', but stored as single bytes.\n */\n\n/*\n * Vim .sug file format:  <SUGHEADER>\n *\t\t\t  <SUGWORDTREE>\n *\t\t\t  <SUGTABLE>\n *\n * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n *\n * <fileID>     6 bytes     \"VIMsug\"\n * <versionnr>  1 byte      VIMSUGVERSION\n * <timestamp>  8 bytes     timestamp that must match with .spl file\n *\n *\n * <SUGWORDTREE>: <wordtree>  (see above, no flags or region used)\n *\n *\n * <SUGTABLE>: <sugwcount> <sugline> ...\n *\n * <sugwcount>\t4 bytes\t    number of <sugline> following\n *\n * <sugline>: <sugnr> ... NUL\n *\n * <sugnr>:     X bytes     word number that results in this soundfolded word,\n *\t\t\t    stored as an offset to the previous number in as\n *\t\t\t    few bytes as possible, see offset2bytes())\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n// Special byte values for <byte>.  Some are only used in the tree for\n// postponed prefixes, some only in the other trees.  This is a bit messy...\n#define BY_NOFLAGS\t0\t// end of word without flags or region; for\n\t\t\t\t// postponed prefix: no <pflags>\n#define BY_INDEX\t1\t// child is shared, index follows\n#define BY_FLAGS\t2\t// end of word, <flags> byte follows; for\n\t\t\t\t// postponed prefix: <pflags> follows\n#define BY_FLAGS2\t3\t// end of word, <flags> and <flags2> bytes\n\t\t\t\t// follow; never used in prefix tree\n#define BY_SPECIAL  BY_FLAGS2\t// highest special byte value\n\n#define ZERO_FLAG\t65009\t// used when flag is zero: \"0\"\n\n// Flags used in .spl file for soundsalike flags.\n#define SAL_F0LLOWUP\t\t1\n#define SAL_COLLAPSE\t\t2\n#define SAL_REM_ACCENTS\t\t4\n\n#define VIMSPELLMAGIC \"VIMspell\"  // string at start of Vim spell file\n#define VIMSPELLMAGICL 8\n#define VIMSPELLVERSION 50\n\n// Section IDs.  Only renumber them when VIMSPELLVERSION changes!\n#define SN_REGION\t0\t// <regionname> section\n#define SN_CHARFLAGS\t1\t// charflags section\n#define SN_MIDWORD\t2\t// <midword> section\n#define SN_PREFCOND\t3\t// <prefcond> section\n#define SN_REP\t\t4\t// REP items section\n#define SN_SAL\t\t5\t// SAL items section\n#define SN_SOFO\t\t6\t// soundfolding section\n#define SN_MAP\t\t7\t// MAP items section\n#define SN_COMPOUND\t8\t// compound words section\n#define SN_SYLLABLE\t9\t// syllable section\n#define SN_NOBREAK\t10\t// NOBREAK section\n#define SN_SUGFILE\t11\t// timestamp for .sug file\n#define SN_REPSAL\t12\t// REPSAL items section\n#define SN_WORDS\t13\t// common words\n#define SN_NOSPLITSUGS\t14\t// don't split word for suggestions\n#define SN_INFO\t\t15\t// info section\n#define SN_NOCOMPOUNDSUGS 16\t// don't compound for suggestions\n#define SN_END\t\t255\t// end of sections\n\n#define SNF_REQUIRED\t1\t// <sectionflags>: required section\n\n#define CF_WORD\t\t0x01\n#define CF_UPPER\t0x02\n\n/*\n * Loop through all the siblings of a node (including the node)\n */\n#define FOR_ALL_NODE_SIBLINGS(node, np) \\\n    for ((np) = (node); (np) != NULL; (np) = (np)->wn_sibling)\n\nstatic int set_spell_finish(spelltab_T\t*new_st);\nstatic int write_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv);\nstatic int read_region_section(FILE *fd, slang_T *slang, int len);\nstatic int read_charflags_section(FILE *fd);\nstatic int read_prefcond_section(FILE *fd, slang_T *lp);\nstatic int read_rep_section(FILE *fd, garray_T *gap, short *first);\nstatic int read_sal_section(FILE *fd, slang_T *slang);\nstatic int read_words_section(FILE *fd, slang_T *lp, int len);\nstatic int read_sofo_section(FILE *fd, slang_T *slang);\nstatic int read_compound(FILE *fd, slang_T *slang, int len);\nstatic int set_sofo(slang_T *lp, char_u *from, char_u *to);\nstatic void set_sal_first(slang_T *lp);\nstatic int *mb_str2wide(char_u *s);\nstatic int spell_read_tree(FILE *fd, char_u **bytsp, long *bytsp_len, idx_T **idxsp, int prefixtree, int prefixcnt);\nstatic idx_T read_tree_node(FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr);\nstatic void set_spell_charflags(char_u *flags, int cnt, char_u *upp);\nstatic int set_spell_chartab(char_u *fol, char_u *low, char_u *upp);\nstatic void set_map_str(slang_T *lp, char_u *map);\n\n\nstatic char *e_afftrailing = N_(\"Trailing text in %s line %d: %s\");\nstatic char *e_affname = N_(\"Affix name too long in %s line %d: %s\");\nstatic char *msg_compressing = N_(\"Compressing word tree...\");\n\n/*\n * Load one spell file and store the info into a slang_T.\n *\n * This is invoked in three ways:\n * - From spell_load_cb() to load a spell file for the first time.  \"lang\" is\n *   the language name, \"old_lp\" is NULL.  Will allocate an slang_T.\n * - To reload a spell file that was changed.  \"lang\" is NULL and \"old_lp\"\n *   points to the existing slang_T.\n * - Just after writing a .spl file; it's read back to produce the .sug file.\n *   \"old_lp\" is NULL and \"lang\" is NULL.  Will allocate an slang_T.\n *\n * Returns the slang_T the spell file was loaded into.  NULL for error.\n */\n    slang_T *\nspell_load_file(\n    char_u\t*fname,\n    char_u\t*lang,\n    slang_T\t*old_lp,\n    int\t\tsilent)\t\t// no error if file doesn't exist\n{\n    FILE\t*fd;\n    char_u\tbuf[VIMSPELLMAGICL];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tn;\n    int\t\tlen;\n    slang_T\t*lp = NULL;\n    int\t\tc = 0;\n    int\t\tres;\n    int\t\tdid_estack_push = FALSE;\n    ESTACK_CHECK_DECLARATION\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tif (!silent)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse if (p_verbose > 2)\n\t{\n\t    verbose_enter();\n\t    smsg((const char *)e_cant_open_file_str, fname);\n\t    verbose_leave();\n\t}\n\tgoto endFAIL;\n    }\n    if (p_verbose > 2)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading spell file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    if (old_lp == NULL)\n    {\n\tlp = slang_alloc(lang);\n\tif (lp == NULL)\n\t    goto endFAIL;\n\n\t// Remember the file name, used to reload the file when it's updated.\n\tlp->sl_fname = vim_strsave(fname);\n\tif (lp->sl_fname == NULL)\n\t    goto endFAIL;\n\n\t// Check for .add.spl (_add.spl for VMS).\n\tlp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;\n    }\n    else\n\tlp = old_lp;\n\n    // Set sourcing_name, so that error messages mention the file name.\n    estack_push(ETYPE_SPELL, fname, 0);\n    ESTACK_CHECK_SETUP\n    did_estack_push = TRUE;\n\n    /*\n     * <HEADER>: <fileID>\n     */\n    for (i = 0; i < VIMSPELLMAGICL; ++i)\n\tbuf[i] = getc(fd);\t\t\t\t// <fileID>\n    if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)\n    {\n\temsg(_(e_this_does_not_look_like_spell_file));\n\tgoto endFAIL;\n    }\n    c = getc(fd);\t\t\t\t\t// <versionnr>\n    if (c < VIMSPELLVERSION)\n    {\n\temsg(_(e_old_spell_file_needs_to_be_updated));\n\tgoto endFAIL;\n    }\n    else if (c > VIMSPELLVERSION)\n    {\n\temsg(_(e_spell_file_is_for_newer_version_of_vim));\n\tgoto endFAIL;\n    }\n\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n     */\n    for (;;)\n    {\n\tn = getc(fd);\t\t\t    // <sectionID> or <sectionend>\n\tif (n == SN_END)\n\t    break;\n\tc = getc(fd);\t\t\t\t\t// <sectionflags>\n\tlen = get4c(fd);\t\t\t\t// <sectionlen>\n\tif (len < 0)\n\t    goto truncerr;\n\n\tres = 0;\n\tswitch (n)\n\t{\n\t    case SN_INFO:\n\t\tlp->sl_info = read_string(fd, len);\t// <infotext>\n\t\tif (lp->sl_info == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_REGION:\n\t\tres = read_region_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_CHARFLAGS:\n\t\tres = read_charflags_section(fd);\n\t\tbreak;\n\n\t    case SN_MIDWORD:\n\t\tlp->sl_midword = read_string(fd, len);\t// <midword>\n\t\tif (lp->sl_midword == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_PREFCOND:\n\t\tres = read_prefcond_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_REP:\n\t\tres = read_rep_section(fd, &lp->sl_rep, lp->sl_rep_first);\n\t\tbreak;\n\n\t    case SN_REPSAL:\n\t\tres = read_rep_section(fd, &lp->sl_repsal, lp->sl_repsal_first);\n\t\tbreak;\n\n\t    case SN_SAL:\n\t\tres = read_sal_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_SOFO:\n\t\tres = read_sofo_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_MAP:\n\t\tp = read_string(fd, len);\t\t// <mapstr>\n\t\tif (p == NULL)\n\t\t    goto endFAIL;\n\t\tset_map_str(lp, p);\n\t\tvim_free(p);\n\t\tbreak;\n\n\t    case SN_WORDS:\n\t\tres = read_words_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_SUGFILE:\n\t\tlp->sl_sugtime = get8ctime(fd);\t\t// <timestamp>\n\t\tbreak;\n\n\t    case SN_NOSPLITSUGS:\n\t\tlp->sl_nosplitsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_NOCOMPOUNDSUGS:\n\t\tlp->sl_nocompoundsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_COMPOUND:\n\t\tres = read_compound(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_NOBREAK:\n\t\tlp->sl_nobreak = TRUE;\n\t\tbreak;\n\n\t    case SN_SYLLABLE:\n\t\tlp->sl_syllable = read_string(fd, len);\t// <syllable>\n\t\tif (lp->sl_syllable == NULL)\n\t\t    goto endFAIL;\n\t\tif (init_syl_tab(lp) != OK)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    default:\n\t\t// Unsupported section.  When it's required give an error\n\t\t// message.  When it's not required skip the contents.\n\t\tif (c & SNF_REQUIRED)\n\t\t{\n\t\t    emsg(_(e_unsupported_section_in_spell_file));\n\t\t    goto endFAIL;\n\t\t}\n\t\twhile (--len >= 0)\n\t\t    if (getc(fd) < 0)\n\t\t\tgoto truncerr;\n\t\tbreak;\n\t}\nsomeerror:\n\tif (res == SP_FORMERROR)\n\t{\n\t    emsg(_(e_format_error_in_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_TRUNCERROR)\n\t{\ntruncerr:\n\t    emsg(_(e_truncated_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_OTHERERROR)\n\t    goto endFAIL;\n    }\n\n    // <LWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_fbyts, &lp->sl_fbyts_len,\n\t\t\t\t\t\t      &lp->sl_fidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <KWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_kbyts, NULL, &lp->sl_kidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <PREFIXTREE>\n    res = spell_read_tree(fd, &lp->sl_pbyts, NULL, &lp->sl_pidxs, TRUE,\n\t\t\t\t\t\t\t    lp->sl_prefixcnt);\n    if (res != 0)\n\tgoto someerror;\n\n    // For a new file link it in the list of spell files.\n    if (old_lp == NULL && lang != NULL)\n    {\n\tlp->sl_next = first_lang;\n\tfirst_lang = lp;\n    }\n\n    goto endOK;\n\nendFAIL:\n    if (lang != NULL)\n\t// truncating the name signals the error to spell_load_lang()\n\t*lang = NUL;\n    if (lp != NULL && old_lp == NULL)\n\tslang_free(lp);\n    lp = NULL;\n\nendOK:\n    if (fd != NULL)\n\tfclose(fd);\n    if (did_estack_push)\n    {\n\tESTACK_CHECK_NOW\n\testack_pop();\n    }\n\n    return lp;\n}\n\n/*\n * Fill in the wordcount fields for a trie.\n * Returns the total number of words.\n */\n    static void\ntree_count_words(char_u *byts, idx_T *idxs)\n{\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    int\t\twordcount[MAXWLEN];\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    fast_breakcheck();\n\t}\n\telse\n\t{\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// End of word, count it.\n\t\t++wordcount[depth];\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).\n\t\twhile (byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper to count the words.\n\t\t++depth;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Load the .sug files for languages that have one and weren't loaded yet.\n */\n    void\nsuggest_load_files(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    char_u\t*dotp;\n    FILE\t*fd;\n    char_u\tbuf[MAXWLEN];\n    int\t\ti;\n    time_t\ttimestamp;\n    int\t\twcount;\n    int\t\twordnr;\n    garray_T\tga;\n    int\t\tc;\n\n    // Do this for all languages that support sound folding.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sugtime != 0 && !slang->sl_sugloaded)\n\t{\n\t    // Change \".spl\" to \".sug\" and open the file.  When the file isn't\n\t    // found silently skip it.  Do set \"sl_sugloaded\" so that we\n\t    // don't try again and again.\n\t    slang->sl_sugloaded = TRUE;\n\n\t    dotp = vim_strrchr(slang->sl_fname, '.');\n\t    if (dotp == NULL || fnamecmp(dotp, \".spl\") != 0)\n\t\tcontinue;\n\t    STRCPY(dotp, \".sug\");\n\t    fd = mch_fopen((char *)slang->sl_fname, \"r\");\n\t    if (fd == NULL)\n\t\tgoto nextone;\n\n\t    /*\n\t     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n\t     */\n\t    for (i = 0; i < VIMSUGMAGICL; ++i)\n\t\tbuf[i] = getc(fd);\t\t\t// <fileID>\n\t    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)\n\t    {\n\t\tsemsg(_(e_this_does_not_look_like_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    c = getc(fd);\t\t\t\t// <versionnr>\n\t    if (c < VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_old_sug_file_needs_to_be_updated_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    else if (c > VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_sug_file_is_for_newer_version_of_vim_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    // Check the timestamp, it must be exactly the same as the one in\n\t    // the .spl file.  Otherwise the word numbers won't match.\n\t    timestamp = get8ctime(fd);\t\t\t// <timestamp>\n\t    if (timestamp != slang->sl_sugtime)\n\t    {\n\t\tsemsg(_(e_sug_file_doesnt_match_spl_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGWORDTREE>: <wordtree>\n\t     * Read the trie with the soundfolded words.\n\t     */\n\t    if (spell_read_tree(fd, &slang->sl_sbyts, NULL, &slang->sl_sidxs,\n\t\t\t\t\t\t\t       FALSE, 0) != 0)\n\t    {\nsomeerror:\n\t\tsemsg(_(e_error_while_reading_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tslang_clear_sug(slang);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGTABLE>: <sugwcount> <sugline> ...\n\t     *\n\t     * Read the table with word numbers.  We use a file buffer for\n\t     * this, because it's so much like a file with lines.  Makes it\n\t     * possible to swap the info and save on memory use.\n\t     */\n\t    slang->sl_sugbuf = open_spellbuf();\n\t    if (slang->sl_sugbuf == NULL)\n\t\tgoto someerror;\n\t\t\t\t\t\t\t    // <sugwcount>\n\t    wcount = get4c(fd);\n\t    if (wcount < 0)\n\t\tgoto someerror;\n\n\t    // Read all the wordnr lists into the buffer, one NUL terminated\n\t    // list per line.\n\t    ga_init2(&ga, 1, 100);\n\t    for (wordnr = 0; wordnr < wcount; ++wordnr)\n\t    {\n\t\tga.ga_len = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    c = getc(fd);\t\t\t    // <sugline>\n\t\t    if (c < 0 || ga_grow(&ga, 1) == FAIL)\n\t\t\tgoto someerror;\n\t\t    ((char_u *)ga.ga_data)[ga.ga_len++] = c;\n\t\t    if (c == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,\n\t\t\t\t\t ga.ga_data, ga.ga_len, TRUE) == FAIL)\n\t\t    goto someerror;\n\t    }\n\t    ga_clear(&ga);\n\n\t    /*\n\t     * Need to put word counts in the word tries, so that we can find\n\t     * a word by its number.\n\t     */\n\t    tree_count_words(slang->sl_fbyts, slang->sl_fidxs);\n\t    tree_count_words(slang->sl_sbyts, slang->sl_sidxs);\n\nnextone:\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    STRCPY(dotp, \".spl\");\n\t}\n    }\n}\n\n\n/*\n * Read a length field from \"fd\" in \"cnt_bytes\" bytes.\n * Allocate memory, read the string into it and add a NUL at the end.\n * Returns NULL when the count is zero.\n * Sets \"*cntp\" to SP_*ERROR when there is an error, length of the result\n * otherwise.\n */\n    static char_u *\nread_cnt_string(FILE *fd, int cnt_bytes, int *cntp)\n{\n    int\t\tcnt = 0;\n    int\t\ti;\n    char_u\t*str;\n\n    // read the length bytes, MSB first\n    for (i = 0; i < cnt_bytes; ++i)\n    {\n\tint c = getc(fd);\n\n\tif (c == EOF)\n\t{\n\t    *cntp = SP_TRUNCERROR;\n\t    return NULL;\n\t}\n\tcnt = (cnt << 8) + (unsigned)c;\n    }\n    *cntp = cnt;\n    if (cnt == 0)\n\treturn NULL;\t    // nothing to read, return NULL\n\n    str = read_string(fd, cnt);\n    if (str == NULL)\n\t*cntp = SP_OTHERERROR;\n    return str;\n}\n\n/*\n * Read SN_REGION: <regionname> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_region_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\ti;\n\n    if (len > MAXREGIONS * 2)\n\treturn SP_FORMERROR;\n    for (i = 0; i < len; ++i)\n\tlp->sl_regions[i] = getc(fd);\t\t\t// <regionname>\n    lp->sl_regions[len] = NUL;\n    return 0;\n}\n\n/*\n * Read SN_CHARFLAGS section: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * Return SP_*ERROR flags.\n */\n    static int\nread_charflags_section(FILE *fd)\n{\n    char_u\t*flags;\n    char_u\t*fol;\n    int\t\tflagslen, follen;\n\n    // <charflagslen> <charflags>\n    flags = read_cnt_string(fd, 1, &flagslen);\n    if (flagslen < 0)\n\treturn flagslen;\n\n    // <folcharslen> <folchars>\n    fol = read_cnt_string(fd, 2, &follen);\n    if (follen < 0)\n    {\n\tvim_free(flags);\n\treturn follen;\n    }\n\n    // Set the word-char flags and fill SPELL_ISUPPER() table.\n    if (flags != NULL && fol != NULL)\n\tset_spell_charflags(flags, flagslen, fol);\n\n    vim_free(flags);\n    vim_free(fol);\n\n    // When <charflagslen> is zero then <fcharlen> must also be zero.\n    if ((flags == NULL) != (fol == NULL))\n\treturn SP_FORMERROR;\n    return 0;\n}\n\n/*\n * Read SN_PREFCOND section.\n * Return SP_*ERROR flags.\n */\n    static int\nread_prefcond_section(FILE *fd, slang_T *lp)\n{\n    int\t\tcnt;\n    int\t\ti;\n    int\t\tn;\n    char_u\t*p;\n    char_u\tbuf[MAXWLEN + 1];\n\n    // <prefcondcnt> <prefcond> ...\n    cnt = get2c(fd);\t\t\t\t\t// <prefcondcnt>\n    if (cnt <= 0)\n\treturn SP_FORMERROR;\n\n    lp->sl_prefprog = ALLOC_CLEAR_MULT(regprog_T *, cnt);\n    if (lp->sl_prefprog == NULL)\n\treturn SP_OTHERERROR;\n    lp->sl_prefixcnt = cnt;\n\n    for (i = 0; i < cnt; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tn = getc(fd);\t\t\t\t\t// <condlen>\n\tif (n < 0 || n >= MAXWLEN)\n\t    return SP_FORMERROR;\n\n\t// When <condlen> is zero we have an empty condition.  Otherwise\n\t// compile the regexp program used to check for the condition.\n\tif (n > 0)\n\t{\n\t    buf[0] = '^';\t    // always match at one position only\n\t    p = buf + 1;\n\t    while (n-- > 0)\n\t\t*p++ = getc(fd);\t\t\t// <condstr>\n\t    *p = NUL;\n\t    lp->sl_prefprog[i] = vim_regcomp(buf, RE_MAGIC + RE_STRING);\n\t}\n    }\n    return 0;\n}\n\n/*\n * Read REP or REPSAL items section from \"fd\": <repcount> <rep> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_rep_section(FILE *fd, garray_T *gap, short *first)\n{\n    int\t\tcnt;\n    fromto_T\t*ftp;\n    int\t\ti;\n\n    cnt = get2c(fd);\t\t\t\t\t// <repcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    if (ga_grow(gap, cnt) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[gap->ga_len];\n\tftp->ft_from = read_cnt_string(fd, 1, &i);\n\tif (i < 0)\n\t    return i;\n\tif (i == 0)\n\t    return SP_FORMERROR;\n\tftp->ft_to = read_cnt_string(fd, 1, &i);\n\tif (i <= 0)\n\t{\n\t    vim_free(ftp->ft_from);\n\t    if (i < 0)\n\t\treturn i;\n\t    return SP_FORMERROR;\n\t}\n    }\n\n    // Fill the first-index table.\n    for (i = 0; i < 256; ++i)\n\tfirst[i] = -1;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[i];\n\tif (first[*ftp->ft_from] == -1)\n\t    first[*ftp->ft_from] = i;\n    }\n    return 0;\n}\n\n/*\n * Read SN_SAL section: <salflags> <salcount> <sal> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_sal_section(FILE *fd, slang_T *slang)\n{\n    int\t\ti;\n    int\t\tcnt;\n    garray_T\t*gap;\n    salitem_T\t*smp;\n    int\t\tccnt;\n    char_u\t*p;\n\n    slang->sl_sofo = FALSE;\n\n    i = getc(fd);\t\t\t\t// <salflags>\n    if (i & SAL_F0LLOWUP)\n\tslang->sl_followup = TRUE;\n    if (i & SAL_COLLAPSE)\n\tslang->sl_collapse = TRUE;\n    if (i & SAL_REM_ACCENTS)\n\tslang->sl_rem_accents = TRUE;\n\n    cnt = get2c(fd);\t\t\t\t// <salcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    gap = &slang->sl_sal;\n    ga_init2(gap, sizeof(salitem_T), 10);\n    if (ga_grow(gap, cnt + 1) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tint\tc = NUL;\n\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tccnt = getc(fd);\t\t\t// <salfromlen>\n\tif (ccnt < 0)\n\t    return SP_TRUNCERROR;\n\tif ((p = alloc(ccnt + 2)) == NULL)\n\t    return SP_OTHERERROR;\n\tsmp->sm_lead = p;\n\n\t// Read up to the first special char into sm_lead.\n\tfor (i = 0; i < ccnt; ++i)\n\t{\n\t    c = getc(fd);\t\t\t// <salfrom>\n\t    if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)\n\t\tbreak;\n\t    *p++ = c;\n\t}\n\tsmp->sm_leadlen = (int)(p - smp->sm_lead);\n\t*p++ = NUL;\n\n\t// Put (abc) chars in sm_oneof, if any.\n\tif (c == '(')\n\t{\n\t    smp->sm_oneof = p;\n\t    for (++i; i < ccnt; ++i)\n\t    {\n\t\tc = getc(fd);\t\t\t// <salfrom>\n\t\tif (c == ')')\n\t\t    break;\n\t\t*p++ = c;\n\t    }\n\t    *p++ = NUL;\n\t    if (++i < ccnt)\n\t\tc = getc(fd);\n\t}\n\telse\n\t    smp->sm_oneof = NULL;\n\n\t// Any following chars go in sm_rules.\n\tsmp->sm_rules = p;\n\tif (i < ccnt)\n\t    // store the char we got while checking for end of sm_lead\n\t    *p++ = c;\n\tfor (++i; i < ccnt; ++i)\n\t    *p++ = getc(fd);\t\t\t// <salfrom>\n\t*p++ = NUL;\n\n\t// <saltolen> <salto>\n\tsmp->sm_to = read_cnt_string(fd, 1, &ccnt);\n\tif (ccnt < 0)\n\t{\n\t    vim_free(smp->sm_lead);\n\t    return ccnt;\n\t}\n\n\tif (has_mbyte)\n\t{\n\t    // convert the multi-byte strings to wide char strings\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = mb_charlen(smp->sm_lead);\n\t    if (smp->sm_oneof == NULL)\n\t\tsmp->sm_oneof_w = NULL;\n\t    else\n\t\tsmp->sm_oneof_w = mb_str2wide(smp->sm_oneof);\n\t    if (smp->sm_to == NULL)\n\t\tsmp->sm_to_w = NULL;\n\t    else\n\t\tsmp->sm_to_w = mb_str2wide(smp->sm_to);\n\t    if (smp->sm_lead_w == NULL\n\t\t    || (smp->sm_oneof_w == NULL && smp->sm_oneof != NULL)\n\t\t    || (smp->sm_to_w == NULL && smp->sm_to != NULL))\n\t    {\n\t\tvim_free(smp->sm_lead);\n\t\tvim_free(smp->sm_to);\n\t\tvim_free(smp->sm_lead_w);\n\t\tvim_free(smp->sm_oneof_w);\n\t\tvim_free(smp->sm_to_w);\n\t\treturn SP_OTHERERROR;\n\t    }\n\t}\n    }\n\n    if (gap->ga_len > 0)\n    {\n\t// Add one extra entry to mark the end with an empty sm_lead.  Avoids\n\t// that we need to check the index every time.\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tif ((p = alloc(1)) == NULL)\n\t    return SP_OTHERERROR;\n\tp[0] = NUL;\n\tsmp->sm_lead = p;\n\tsmp->sm_leadlen = 0;\n\tsmp->sm_oneof = NULL;\n\tsmp->sm_rules = p;\n\tsmp->sm_to = NULL;\n\tif (has_mbyte)\n\t{\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = 0;\n\t    smp->sm_oneof_w = NULL;\n\t    smp->sm_to_w = NULL;\n\t}\n\t++gap->ga_len;\n    }\n\n    // Fill the first-index table.\n    set_sal_first(slang);\n\n    return 0;\n}\n\n/*\n * Read SN_WORDS: <word> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_words_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\tdone = 0;\n    int\t\ti;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    while (done < len)\n    {\n\t// Read one word at a time.\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t\treturn SP_TRUNCERROR;\n\t    word[i] = c;\n\t    if (word[i] == NUL)\n\t\tbreak;\n\t    if (i == MAXWLEN - 1)\n\t\treturn SP_FORMERROR;\n\t}\n\n\t// Init the count to 10.\n\tcount_common_word(lp, word, -1, 10);\n\tdone += i + 1;\n    }\n    return 0;\n}\n\n/*\n * SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * Return SP_*ERROR flags.\n */\n    static int\nread_sofo_section(FILE *fd, slang_T *slang)\n{\n    int\t\tcnt;\n    char_u\t*from, *to;\n    int\t\tres;\n\n    slang->sl_sofo = TRUE;\n\n    // <sofofromlen> <sofofrom>\n    from = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n\treturn cnt;\n\n    // <sofotolen> <sofoto>\n    to = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n    {\n\tvim_free(from);\n\treturn cnt;\n    }\n\n    // Store the info in slang->sl_sal and/or slang->sl_sal_first.\n    if (from != NULL && to != NULL)\n\tres = set_sofo(slang, from, to);\n    else if (from != NULL || to != NULL)\n\tres = SP_FORMERROR;    // only one of two strings is an error\n    else\n\tres = 0;\n\n    vim_free(from);\n    vim_free(to);\n    return res;\n}\n\n/*\n * Read the compound section from the .spl file:\n *\t<compmax> <compminlen> <compsylmax> <compoptions> <compflags>\n * Returns SP_*ERROR flags.\n */\n    static int\nread_compound(FILE *fd, slang_T *slang, int len)\n{\n    int\t\ttodo = len;\n    int\t\tc;\n    int\t\tatstart;\n    char_u\t*pat;\n    char_u\t*pp;\n    char_u\t*cp;\n    char_u\t*ap;\n    char_u\t*crp;\n    int\t\tcnt;\n    garray_T\t*gap;\n\n    if (todo < 2)\n\treturn SP_FORMERROR;\t// need at least two bytes\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compmax>\n    if (c < 2)\n\tc = MAXWLEN;\n    slang->sl_compmax = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compminlen>\n    if (c < 1)\n\tc = 0;\n    slang->sl_compminlen = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compsylmax>\n    if (c < 1)\n\tc = MAXWLEN;\n    slang->sl_compsylmax = c;\n\n    c = getc(fd);\t\t\t\t\t// <compoptions>\n    if (c != 0)\n\tungetc(c, fd);\t    // be backwards compatible with Vim 7.0b\n    else\n    {\n\t--todo;\n\tc = getc(fd);\t    // only use the lower byte for now\n\t--todo;\n\tslang->sl_compoptions = c;\n\n\tgap = &slang->sl_comppat;\n\tc = get2c(fd);\t\t\t\t\t// <comppatcount>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\ttodo -= 2;\n\tga_init2(gap, sizeof(char_u *), c);\n\tif (ga_grow(gap, c) == OK)\n\t    while (--c >= 0)\n\t    {\n\t\t((char_u **)(gap->ga_data))[gap->ga_len++] =\n\t\t\t\t\t\t  read_cnt_string(fd, 1, &cnt);\n\t\t\t\t\t    // <comppatlen> <comppattext>\n\t\tif (cnt < 0)\n\t\t    return cnt;\n\t\ttodo -= cnt + 1;\n\t    }\n    }\n    if (todo < 0)\n\treturn SP_FORMERROR;\n\n    // Turn the COMPOUNDRULE items into a regexp pattern:\n    // \"a[bc]/a*b+\" -> \"^\\(a[bc]\\|a*b\\+\\)$\".\n    // Inserting backslashes may double the length, \"^\\(\\)$<Nul>\" is 7 bytes.\n    // Conversion to utf-8 may double the size.\n    c = todo * 2 + 7;\n    if (enc_utf8)\n\tc += todo * 2;\n    pat = alloc(c);\n    if (pat == NULL)\n\treturn SP_OTHERERROR;\n\n    // We also need a list of all flags that can appear at the start and one\n    // for all flags.\n    cp = alloc(todo + 1);\n    if (cp == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compstartflags = cp;\n    *cp = NUL;\n\n    ap = alloc(todo + 1);\n    if (ap == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compallflags = ap;\n    *ap = NUL;\n\n    // And a list of all patterns in their original form, for checking whether\n    // compounding may work in match_compoundrule().  This is freed when we\n    // encounter a wildcard, the check doesn't work then.\n    crp = alloc(todo + 1);\n    slang->sl_comprules = crp;\n\n    pp = pat;\n    *pp++ = '^';\n    *pp++ = '\\\\';\n    *pp++ = '(';\n\n    atstart = 1;\n    while (todo-- > 0)\n    {\n\tc = getc(fd);\t\t\t\t\t// <compflags>\n\tif (c == EOF)\n\t{\n\t    vim_free(pat);\n\t    return SP_TRUNCERROR;\n\t}\n\n\t// Add all flags to \"sl_compallflags\".\n\tif (vim_strchr((char_u *)\"?*+[]/\", c) == NULL\n\t\t&& !byte_in_str(slang->sl_compallflags, c))\n\t{\n\t    *ap++ = c;\n\t    *ap = NUL;\n\t}\n\n\tif (atstart != 0)\n\t{\n\t    // At start of item: copy flags to \"sl_compstartflags\".  For a\n\t    // [abc] item set \"atstart\" to 2 and copy up to the ']'.\n\t    if (c == '[')\n\t\tatstart = 2;\n\t    else if (c == ']')\n\t\tatstart = 0;\n\t    else\n\t    {\n\t\tif (!byte_in_str(slang->sl_compstartflags, c))\n\t\t{\n\t\t    *cp++ = c;\n\t\t    *cp = NUL;\n\t\t}\n\t\tif (atstart == 1)\n\t\t    atstart = 0;\n\t    }\n\t}\n\n\t// Copy flag to \"sl_comprules\", unless we run into a wildcard.\n\tif (crp != NULL)\n\t{\n\t    if (c == '?' || c == '+' || c == '*')\n\t    {\n\t\tVIM_CLEAR(slang->sl_comprules);\n\t\tcrp = NULL;\n\t    }\n\t    else\n\t\t*crp++ = c;\n\t}\n\n\tif (c == '/')\t    // slash separates two items\n\t{\n\t    *pp++ = '\\\\';\n\t    *pp++ = '|';\n\t    atstart = 1;\n\t}\n\telse\t\t    // normal char, \"[abc]\" and '*' are copied as-is\n\t{\n\t    if (c == '?' || c == '+' || c == '~')\n\t\t*pp++ = '\\\\';\t    // \"a?\" becomes \"a\\?\", \"a+\" becomes \"a\\+\"\n\t    if (enc_utf8)\n\t\tpp += mb_char2bytes(c, pp);\n\t    else\n\t\t*pp++ = c;\n\t}\n    }\n\n    *pp++ = '\\\\';\n    *pp++ = ')';\n    *pp++ = '$';\n    *pp = NUL;\n\n    if (crp != NULL)\n\t*crp = NUL;\n\n    slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);\n    vim_free(pat);\n    if (slang->sl_compprog == NULL)\n\treturn SP_FORMERROR;\n\n    return 0;\n}\n\n/*\n * Set the SOFOFROM and SOFOTO items in language \"lp\".\n * Returns SP_*ERROR flags when there is something wrong.\n */\n    static int\nset_sofo(slang_T *lp, char_u *from, char_u *to)\n{\n    int\t\ti;\n\n    garray_T\t*gap;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tc;\n    int\t\t*inp;\n\n    if (has_mbyte)\n    {\n\t// Use \"sl_sal\" as an array with 256 pointers to a list of wide\n\t// characters.  The index is the low byte of the character.\n\t// The list contains from-to pairs with a terminating NUL.\n\t// sl_sal_first[] is used for latin1 \"from\" characters.\n\tgap = &lp->sl_sal;\n\tga_init2(gap, sizeof(int *), 1);\n\tif (ga_grow(gap, 256) == FAIL)\n\t    return SP_OTHERERROR;\n\tvim_memset(gap->ga_data, 0, sizeof(int *) * 256);\n\tgap->ga_len = 256;\n\n\t// First count the number of items for each list.  Temporarily use\n\t// sl_sal_first[] for this.\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    MB_CPTR_ADV(s);\n\t    if (c >= 256)\n\t\t++lp->sl_sal_first[c & 0xff];\n\t}\n\tif (*p != NUL || *s != NUL)\t    // lengths differ\n\t    return SP_FORMERROR;\n\n\t// Allocate the lists.\n\tfor (i = 0; i < 256; ++i)\n\t    if (lp->sl_sal_first[i] > 0)\n\t    {\n\t\tp = alloc(sizeof(int) * (lp->sl_sal_first[i] * 2 + 1));\n\t\tif (p == NULL)\n\t\t    return SP_OTHERERROR;\n\t\t((int **)gap->ga_data)[i] = (int *)p;\n\t\t*(int *)p = 0;\n\t    }\n\n\t// Put the characters up to 255 in sl_sal_first[] the rest in a sl_sal\n\t// list.\n\tvim_memset(lp->sl_sal_first, 0, sizeof(salfirst_T) * 256);\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    i = mb_cptr2char_adv(&s);\n\t    if (c >= 256)\n\t    {\n\t\t// Append the from-to chars at the end of the list with\n\t\t// the low byte.\n\t\tinp = ((int **)gap->ga_data)[c & 0xff];\n\t\twhile (*inp != 0)\n\t\t    ++inp;\n\t\t*inp++ = c;\t\t// from char\n\t\t*inp++ = i;\t\t// to char\n\t\t*inp++ = NUL;\t\t// NUL at the end\n\t    }\n\t    else\n\t\t// mapping byte to char is done in sl_sal_first[]\n\t\tlp->sl_sal_first[c] = i;\n\t}\n    }\n    else\n    {\n\t// mapping bytes to bytes is done in sl_sal_first[]\n\tif (STRLEN(from) != STRLEN(to))\n\t    return SP_FORMERROR;\n\n\tfor (i = 0; to[i] != NUL; ++i)\n\t    lp->sl_sal_first[from[i]] = to[i];\n\tlp->sl_sal.ga_len = 1;\t\t// indicates we have soundfolding\n    }\n\n    return 0;\n}\n\n/*\n * Fill the first-index table for \"lp\".\n */\n    static void\nset_sal_first(slang_T *lp)\n{\n    salfirst_T\t*sfirst;\n    int\t\ti;\n    salitem_T\t*smp;\n    int\t\tc;\n    garray_T\t*gap = &lp->sl_sal;\n\n    sfirst = lp->sl_sal_first;\n    for (i = 0; i < 256; ++i)\n\tsfirst[i] = -1;\n    smp = (salitem_T *)gap->ga_data;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tif (has_mbyte)\n\t    // Use the lowest byte of the first character.  For latin1 it's\n\t    // the character, for other encodings it should differ for most\n\t    // characters.\n\t    c = *smp[i].sm_lead_w & 0xff;\n\telse\n\t    c = *smp[i].sm_lead;\n\tif (sfirst[c] == -1)\n\t{\n\t    sfirst[c] = i;\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\tn;\n\n\t\t// Make sure all entries with this byte are following each\n\t\t// other.  Move the ones that are in the wrong position.  Do\n\t\t// keep the same ordering!\n\t\twhile (i + 1 < gap->ga_len\n\t\t\t\t       && (*smp[i + 1].sm_lead_w & 0xff) == c)\n\t\t    // Skip over entry with same index byte.\n\t\t    ++i;\n\n\t\tfor (n = 1; i + n < gap->ga_len; ++n)\n\t\t    if ((*smp[i + n].sm_lead_w & 0xff) == c)\n\t\t    {\n\t\t\tsalitem_T  tsal;\n\n\t\t\t// Move entry with same index byte after the entries\n\t\t\t// we already found.\n\t\t\t++i;\n\t\t\t--n;\n\t\t\ttsal = smp[i + n];\n\t\t\tmch_memmove(smp + i + 1, smp + i,\n\t\t\t\t\t\t       sizeof(salitem_T) * n);\n\t\t\tsmp[i] = tsal;\n\t\t    }\n\t    }\n\t}\n    }\n}\n\n/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */\n    static int *\nmb_str2wide(char_u *s)\n{\n    int\t\t*res;\n    char_u\t*p;\n    int\t\ti = 0;\n\n    res = ALLOC_MULT(int, mb_charlen(s) + 1);\n    if (res != NULL)\n    {\n\tfor (p = s; *p != NUL; )\n\t    res[i++] = mb_ptr2char_adv(&p);\n\tres[i] = NUL;\n    }\n    return res;\n}\n\n/*\n * Read a tree from the .spl or .sug file.\n * Allocates the memory and stores pointers in \"bytsp\" and \"idxsp\".\n * This is skipped when the tree has zero length.\n * Returns zero when OK, SP_ value for an error.\n */\n    static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    long\t*bytsp_len,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t// TRUE for the prefix tree\n    int\t\tprefixcnt)\t// when \"prefixtree\" is TRUE: prefix count\n{\n    long\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    // The tree size was computed when writing the file, so that we can\n    // allocate it as one long block. <nodecount>\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= LONG_MAX / (long)sizeof(int))\n\t// Invalid length, multiply with sizeof(int) would overflow.\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t// Allocate the byte array.\n\tbp = alloc(len);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tif (bytsp_len != NULL)\n\t    *bytsp_len = len;\n\n\t// Allocate the index array.\n\tip = lalloc_clear(len * sizeof(int), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t// Recursively read the tree and store it in the array.\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}\n\n/*\n * Read one row of siblings from the spell file and store it in the byte array\n * \"byts\" and index array \"idxs\".  Recursively read the children.\n *\n * NOTE: The code here must match put_node()!\n *\n * Returns the index (>= 0) following the siblings.\n * Returns SP_TRUNCERROR if the file is shorter than expected.\n * Returns SP_FORMERROR if there is a format error.\n */\n    static idx_T\nread_tree_node(\n    FILE\t*fd,\n    char_u\t*byts,\n    idx_T\t*idxs,\n    int\t\tmaxidx,\t\t    // size of arrays\n    idx_T\tstartidx,\t    // current index in \"byts\" and \"idxs\"\n    int\t\tprefixtree,\t    // TRUE for reading PREFIXTREE\n    int\t\tmaxprefcondnr)\t    // maximum for <prefcondnr>\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tn;\n    idx_T\tidx = startidx;\n    int\t\tc;\n    int\t\tc2;\n#define SHARED_MASK\t0x8000000\n\n    len = getc(fd);\t\t\t\t\t// <siblingcount>\n    if (len <= 0)\n\treturn SP_TRUNCERROR;\n\n    if (startidx + len >= maxidx)\n\treturn SP_FORMERROR;\n    byts[idx++] = len;\n\n    // Read the byte values, flag/region bytes and shared indexes.\n    for (i = 1; i <= len; ++i)\n    {\n\tc = getc(fd);\t\t\t\t\t// <byte>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\tif (c <= BY_SPECIAL)\n\t{\n\t    if (c == BY_NOFLAGS && !prefixtree)\n\t    {\n\t\t// No flags, all regions.\n\t\tidxs[idx] = 0;\n\t\tc = 0;\n\t    }\n\t    else if (c != BY_INDEX)\n\t    {\n\t\tif (prefixtree)\n\t\t{\n\t\t    // Read the optional pflags byte, the prefix ID and the\n\t\t    // condition nr.  In idxs[] store the prefix ID in the low\n\t\t    // byte, the condition index shifted up 8 bits, the flags\n\t\t    // shifted up 24 bits.\n\t\t    if (c == BY_FLAGS)\n\t\t\tc = getc(fd) << 24;\t\t// <pflags>\n\t\t    else\n\t\t\tc = 0;\n\n\t\t    c |= getc(fd);\t\t\t// <affixID>\n\n\t\t    n = get2c(fd);\t\t\t// <prefcondnr>\n\t\t    if (n >= maxprefcondnr)\n\t\t\treturn SP_FORMERROR;\n\t\t    c |= (n << 8);\n\t\t}\n\t\telse // c must be BY_FLAGS or BY_FLAGS2\n\t\t{\n\t\t    // Read flags and optional region and prefix ID.  In\n\t\t    // idxs[] the flags go in the low two bytes, region above\n\t\t    // that and prefix ID above the region.\n\t\t    c2 = c;\n\t\t    c = getc(fd);\t\t\t// <flags>\n\t\t    if (c2 == BY_FLAGS2)\n\t\t\tc = (getc(fd) << 8) + c;\t// <flags2>\n\t\t    if (c & WF_REGION)\n\t\t\tc = (getc(fd) << 16) + c;\t// <region>\n\t\t    if (c & WF_AFX)\n\t\t\tc = (getc(fd) << 24) + c;\t// <affixID>\n\t\t}\n\n\t\tidxs[idx] = c;\n\t\tc = 0;\n\t    }\n\t    else // c == BY_INDEX\n\t    {\n\t\t\t\t\t\t\t// <nodeidx>\n\t\tn = get3c(fd);\n\t\tif (n < 0 || n >= maxidx)\n\t\t    return SP_FORMERROR;\n\t\tidxs[idx] = n + SHARED_MASK;\n\t\tc = getc(fd);\t\t\t\t// <xbyte>\n\t    }\n\t}\n\tbyts[idx++] = c;\n    }\n\n    // Recursively read the children for non-shared siblings.\n    // Skip the end-of-word ones (zero byte value) and the shared ones (and\n    // remove SHARED_MASK)\n    for (i = 1; i <= len; ++i)\n\tif (byts[startidx + i] != 0)\n\t{\n\t    if (idxs[startidx + i] & SHARED_MASK)\n\t\tidxs[startidx + i] &= ~SHARED_MASK;\n\t    else\n\t    {\n\t\tidxs[startidx + i] = idx;\n\t\tidx = read_tree_node(fd, byts, idxs, maxidx, idx,\n\t\t\t\t\t\t     prefixtree, maxprefcondnr);\n\t\tif (idx < 0)\n\t\t    break;\n\t    }\n\t}\n\n    return idx;\n}\n\n/*\n * Reload the spell file \"fname\" if it's loaded.\n */\n    static void\nspell_reload_one(\n    char_u\t*fname,\n    int\t\tadded_word)\t// invoked through \"zg\"\n{\n    slang_T\t*slang;\n    int\t\tdidit = FALSE;\n\n    FOR_ALL_SPELL_LANGS(slang)\n    {\n\tif (fullpathcmp(fname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t{\n\t    slang_clear(slang);\n\t    if (spell_load_file(fname, NULL, slang, FALSE) == NULL)\n\t\t// reloading failed, clear the language\n\t\tslang_clear(slang);\n\t    redraw_all_later(SOME_VALID);\n\t    didit = TRUE;\n\t}\n    }\n\n    // When \"zg\" was used and the file wasn't loaded yet, should redo\n    // 'spelllang' to load it now.\n    if (added_word && !didit)\n\tdid_set_spelllang(curwin);\n}\n\n\n/*\n * Functions for \":mkspell\".\n */\n\n#define MAXLINELEN  500\t\t// Maximum length in bytes of a line in a .aff\n\t\t\t\t// and .dic file.\n/*\n * Main structure to store the contents of a \".aff\" file.\n */\ntypedef struct afffile_S\n{\n    char_u\t*af_enc;\t// \"SET\", normalized, alloc'ed string or NULL\n    int\t\taf_flagtype;\t// AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG\n    unsigned\taf_rare;\t// RARE ID for rare word\n    unsigned\taf_keepcase;\t// KEEPCASE ID for keep-case word\n    unsigned\taf_bad;\t\t// BAD ID for banned word\n    unsigned\taf_needaffix;\t// NEEDAFFIX ID\n    unsigned\taf_circumfix;\t// CIRCUMFIX ID\n    unsigned\taf_needcomp;\t// NEEDCOMPOUND ID\n    unsigned\taf_comproot;\t// COMPOUNDROOT ID\n    unsigned\taf_compforbid;\t// COMPOUNDFORBIDFLAG ID\n    unsigned\taf_comppermit;\t// COMPOUNDPERMITFLAG ID\n    unsigned\taf_nosuggest;\t// NOSUGGEST ID\n    int\t\taf_pfxpostpone;\t// postpone prefixes without chop string and\n\t\t\t\t// without flags\n    int\t\taf_ignoreextra;\t// IGNOREEXTRA present\n    hashtab_T\taf_pref;\t// hashtable for prefixes, affheader_T\n    hashtab_T\taf_suff;\t// hashtable for suffixes, affheader_T\n    hashtab_T\taf_comp;\t// hashtable for compound flags, compitem_T\n} afffile_T;\n\n#define AFT_CHAR\t0\t// flags are one character\n#define AFT_LONG\t1\t// flags are two characters\n#define AFT_CAPLONG\t2\t// flags are one or two characters\n#define AFT_NUM\t\t3\t// flags are numbers, comma separated\n\ntypedef struct affentry_S affentry_T;\n// Affix entry from \".aff\" file.  Used for prefixes and suffixes.\nstruct affentry_S\n{\n    affentry_T\t*ae_next;\t// next affix with same name/number\n    char_u\t*ae_chop;\t// text to chop off basic word (can be NULL)\n    char_u\t*ae_add;\t// text to add to basic word (can be NULL)\n    char_u\t*ae_flags;\t// flags on the affix (can be NULL)\n    char_u\t*ae_cond;\t// condition (NULL for \".\")\n    regprog_T\t*ae_prog;\t// regexp program for ae_cond or NULL\n    char\tae_compforbid;\t// COMPOUNDFORBIDFLAG found\n    char\tae_comppermit;\t// COMPOUNDPERMITFLAG found\n};\n\n#define AH_KEY_LEN 17\t\t// 2 x 8 bytes + NUL\n\n// Affix header from \".aff\" file.  Used for af_pref and af_suff.\ntypedef struct affheader_S\n{\n    char_u\tah_key[AH_KEY_LEN]; // key for hashtab == name of affix\n    unsigned\tah_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tah_newID;\t// prefix ID after renumbering; 0 if not used\n    int\t\tah_combine;\t// suffix may combine with prefix\n    int\t\tah_follows;\t// another affix block should be following\n    affentry_T\t*ah_first;\t// first affix entry\n} affheader_T;\n\n#define HI2AH(hi)   ((affheader_T *)(hi)->hi_key)\n\n// Flag used in compound items.\ntypedef struct compitem_S\n{\n    char_u\tci_key[AH_KEY_LEN]; // key for hashtab == name of compound\n    unsigned\tci_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tci_newID;\t// affix ID after renumbering.\n} compitem_T;\n\n#define HI2CI(hi)   ((compitem_T *)(hi)->hi_key)\n\n/*\n * Structure that is used to store the items in the word tree.  This avoids\n * the need to keep track of each allocated thing, everything is freed all at\n * once after \":mkspell\" is done.\n * Note: \"sb_next\" must be just before \"sb_data\" to make sure the alignment of\n * \"sb_data\" is correct for systems where pointers must be aligned on\n * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).\n */\n#define  SBLOCKSIZE 16000\t// size of sb_data\ntypedef struct sblock_S sblock_T;\nstruct sblock_S\n{\n    int\t\tsb_used;\t// nr of bytes already in use\n    sblock_T\t*sb_next;\t// next block in list\n    char_u\tsb_data[1];\t// data, actually longer\n};\n\n/*\n * A node in the tree.\n */\ntypedef struct wordnode_S wordnode_T;\nstruct wordnode_S\n{\n    union   // shared to save space\n    {\n\tchar_u\thashkey[6];\t// the hash key, only used while compressing\n\tint\tindex;\t\t// index in written nodes (valid after first\n\t\t\t\t// round)\n    } wn_u1;\n    union   // shared to save space\n    {\n\twordnode_T *next;\t// next node with same hash key\n\twordnode_T *wnode;\t// parent node that will write this node\n    } wn_u2;\n    wordnode_T\t*wn_child;\t// child (next byte in word)\n    wordnode_T  *wn_sibling;\t// next sibling (alternate byte in word,\n\t\t\t\t// always sorted)\n    int\t\twn_refs;\t// Nr. of references to this node.  Only\n\t\t\t\t// relevant for first node in a list of\n\t\t\t\t// siblings, in following siblings it is\n\t\t\t\t// always one.\n    char_u\twn_byte;\t// Byte for this node. NUL for word end\n\n    // Info for when \"wn_byte\" is NUL.\n    // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n    // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n    // \"wn_region\" the LSW of the wordnr.\n    char_u\twn_affixID;\t// supported/required prefix ID or 0\n    short_u\twn_flags;\t// WF_ flags\n    short\twn_region;\t// region mask\n\n#ifdef SPELL_PRINTTREE\n    int\t\twn_nr;\t\t// sequence nr for printing\n#endif\n};\n\n#define WN_MASK\t 0xffff\t\t// mask relevant bits of \"wn_flags\"\n\n#define HI2WN(hi)    (wordnode_T *)((hi)->hi_key)\n\n/*\n * Info used while reading the spell files.\n */\ntypedef struct spellinfo_S\n{\n    wordnode_T\t*si_foldroot;\t// tree with case-folded words\n    long\tsi_foldwcount;\t// nr of words in si_foldroot\n\n    wordnode_T\t*si_keeproot;\t// tree with keep-case words\n    long\tsi_keepwcount;\t// nr of words in si_keeproot\n\n    wordnode_T\t*si_prefroot;\t// tree with postponed prefixes\n\n    long\tsi_sugtree;\t// creating the soundfolding trie\n\n    sblock_T\t*si_blocks;\t// memory blocks used\n    long\tsi_blocks_cnt;\t// memory blocks allocated\n    int\t\tsi_did_emsg;\t// TRUE when ran out of memory\n\n    long\tsi_compress_cnt;    // words to add before lowering\n\t\t\t\t    // compression limit\n    wordnode_T\t*si_first_free; // List of nodes that have been freed during\n\t\t\t\t// compression, linked by \"wn_child\" field.\n    long\tsi_free_count;\t// number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n    int\t\tsi_wordnode_nr;\t// sequence nr for nodes\n#endif\n    buf_T\t*si_spellbuf;\t// buffer used to store soundfold word table\n\n    int\t\tsi_ascii;\t// handling only ASCII words\n    int\t\tsi_add;\t\t// addition file\n    int\t\tsi_clear_chartab;   // when TRUE clear char tables\n    int\t\tsi_region;\t// region mask\n    vimconv_T\tsi_conv;\t// for conversion to 'encoding'\n    int\t\tsi_memtot;\t// runtime memory used\n    int\t\tsi_verbose;\t// verbose messages\n    int\t\tsi_msg_count;\t// number of words added since last message\n    char_u\t*si_info;\t// info text chars or NULL\n    int\t\tsi_region_count; // number of regions supported (1 when there\n\t\t\t\t // are no regions)\n    char_u\tsi_region_name[MAXREGIONS * 2 + 1];\n\t\t\t\t// region names; used only if\n\t\t\t\t// si_region_count > 1)\n\n    garray_T\tsi_rep;\t\t// list of fromto_T entries from REP lines\n    garray_T\tsi_repsal;\t// list of fromto_T entries from REPSAL lines\n    garray_T\tsi_sal;\t\t// list of fromto_T entries from SAL lines\n    char_u\t*si_sofofr;\t// SOFOFROM text\n    char_u\t*si_sofoto;\t// SOFOTO text\n    int\t\tsi_nosugfile;\t// NOSUGFILE item found\n    int\t\tsi_nosplitsugs;\t// NOSPLITSUGS item found\n    int\t\tsi_nocompoundsugs; // NOCOMPOUNDSUGS item found\n    int\t\tsi_followup;\t// soundsalike: ?\n    int\t\tsi_collapse;\t// soundsalike: ?\n    hashtab_T\tsi_commonwords;\t// hashtable for common words\n    time_t\tsi_sugtime;\t// timestamp for .sug file\n    int\t\tsi_rem_accents;\t// soundsalike: remove accents\n    garray_T\tsi_map;\t\t// MAP info concatenated\n    char_u\t*si_midword;\t// MIDWORD chars or NULL\n    int\t\tsi_compmax;\t// max nr of words for compounding\n    int\t\tsi_compminlen;\t// minimal length for compounding\n    int\t\tsi_compsylmax;\t// max nr of syllables for compounding\n    int\t\tsi_compoptions;\t// COMP_ flags\n    garray_T\tsi_comppat;\t// CHECKCOMPOUNDPATTERN items, each stored as\n\t\t\t\t// a string\n    char_u\t*si_compflags;\t// flags used for compounding\n    char_u\tsi_nobreak;\t// NOBREAK\n    char_u\t*si_syllable;\t// syllable string\n    garray_T\tsi_prefcond;\t// table with conditions for postponed\n\t\t\t\t// prefixes, each stored as a string\n    int\t\tsi_newprefID;\t// current value for ah_newID\n    int\t\tsi_newcompID;\t// current value for compound ID\n} spellinfo_T;\n\nstatic int is_aff_rule(char_u **items, int itemcnt, char *rulename, int\t mincount);\nstatic void aff_process_flags(afffile_T *affile, affentry_T *entry);\nstatic int spell_info_item(char_u *s);\nstatic unsigned affitem2flag(int flagtype, char_u *item, char_u\t*fname, int lnum);\nstatic unsigned get_affitem(int flagtype, char_u **pp);\nstatic void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags);\nstatic void check_renumber(spellinfo_T *spin);\nstatic void aff_check_number(int spinval, int affval, char *name);\nstatic void aff_check_string(char_u *spinval, char_u *affval, char *name);\nstatic int str_equal(char_u *s1, char_u\t*s2);\nstatic void add_fromto(spellinfo_T *spin, garray_T *gap, char_u\t*from, char_u *to);\nstatic int sal_to_bool(char_u *s);\nstatic int get_affix_flags(afffile_T *affile, char_u *afflist);\nstatic int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic int store_aff_word(spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen);\nstatic void *getroom(spellinfo_T *spin, size_t len, int align);\nstatic char_u *getroom_save(spellinfo_T *spin, char_u *s);\nstatic int store_word(spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix);\nstatic int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID);\nstatic wordnode_T *get_wordnode(spellinfo_T *spin);\nstatic void free_wordnode(spellinfo_T *spin, wordnode_T *n);\nstatic void wordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name);\nstatic long node_compress(spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, long *tot);\nstatic int node_equal(wordnode_T *n1, wordnode_T *n2);\nstatic void clear_node(wordnode_T *node);\nstatic int put_node(FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree);\nstatic int sug_filltree(spellinfo_T *spin, slang_T *slang);\nstatic int sug_maketable(spellinfo_T *spin);\nstatic int sug_filltable(spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap);\nstatic int offset2bytes(int nr, char_u *buf);\nstatic void sug_write(spellinfo_T *spin, char_u *fname);\nstatic void spell_message(spellinfo_T *spin, char_u *str);\nstatic void init_spellfile(void);\n\n// In the postponed prefixes tree wn_flags is used to store the WFP_ flags,\n// but it must be negative to indicate the prefix tree to tree_add_word().\n// Use a negative number with the lower 8 bits zero.\n#define PFX_FLAGS\t(-256)\n\n// flags for \"condit\" argument of store_aff_word()\n#define CONDIT_COMB\t1\t// affix must combine\n#define CONDIT_CFIX\t2\t// affix must have CIRCUMFIX flag\n#define CONDIT_SUF\t4\t// add a suffix for matching flags\n#define CONDIT_AFF\t8\t// word already has an affix\n\n/*\n * Tunable parameters for when the tree is compressed.  Filled from the\n * 'mkspellmem' option.\n */\nstatic long compress_start = 30000;\t// memory / SBLOCKSIZE\nstatic long compress_inc = 100;\t\t// memory / SBLOCKSIZE\nstatic long compress_added = 500000;\t// word count\n\n/*\n * Check the 'mkspellmem' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\".\n */\n    int\nspell_check_msm(void)\n{\n    char_u\t*p = p_msm;\n    long\tstart = 0;\n    long\tincr = 0;\n    long\tadded = 0;\n\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    // block count = (value * 1024) / SBLOCKSIZE (but avoid overflow)\n    start = (getdigits(&p) * 10) / (SBLOCKSIZE / 102);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    added = getdigits(&p) * 1024;\n    if (*p != NUL)\n\treturn FAIL;\n\n    if (start == 0 || incr == 0 || added == 0 || incr > start)\n\treturn FAIL;\n\n    compress_start = start;\n    compress_inc = incr;\n    compress_added = added;\n    return OK;\n}\n\n#ifdef SPELL_PRINTTREE\n/*\n * For debugging the tree code: print the current tree in a (more or less)\n * readable format, so that we can see what happens when adding a word and/or\n * compressing the tree.\n * Based on code from Olaf Seibert.\n */\n#define PRINTLINESIZE\t1000\n#define PRINTWIDTH\t6\n\n#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\\n\t    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)\n\nstatic char line1[PRINTLINESIZE];\nstatic char line2[PRINTLINESIZE];\nstatic char line3[PRINTLINESIZE];\n\n    static void\nspell_clear_flags(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tnp->wn_u1.index = FALSE;\n\tspell_clear_flags(np->wn_child);\n    }\n}\n\n    static void\nspell_print_node(wordnode_T *node, int depth)\n{\n    if (node->wn_u1.index)\n    {\n\t// Done this node before, print the reference.\n\tPRINTSOME(line1, depth, \"(%d)\", node->wn_nr, 0);\n\tPRINTSOME(line2, depth, \"    \", 0, 0);\n\tPRINTSOME(line3, depth, \"    \", 0, 0);\n\tmsg(line1);\n\tmsg(line2);\n\tmsg(line3);\n    }\n    else\n    {\n\tnode->wn_u1.index = TRUE;\n\n\tif (node->wn_byte != NUL)\n\t{\n\t    if (node->wn_child != NULL)\n\t\tPRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);\n\t    else\n\t\t// Cannot happen?\n\t\tPRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);\n\t}\n\telse\n\t    PRINTSOME(line1, depth, \" $    \", 0, 0);\n\n\tPRINTSOME(line2, depth, \"%d/%d    \", node->wn_nr, node->wn_refs);\n\n\tif (node->wn_sibling != NULL)\n\t    PRINTSOME(line3, depth, \" |    \", 0, 0);\n\telse\n\t    PRINTSOME(line3, depth, \"      \", 0, 0);\n\n\tif (node->wn_byte == NUL)\n\t{\n\t    msg(line1);\n\t    msg(line2);\n\t    msg(line3);\n\t}\n\n\t// do the children\n\tif (node->wn_byte != NUL && node->wn_child != NULL)\n\t    spell_print_node(node->wn_child, depth + 1);\n\n\t// do the siblings\n\tif (node->wn_sibling != NULL)\n\t{\n\t    // get rid of all parent details except |\n\t    STRCPY(line1, line3);\n\t    STRCPY(line2, line3);\n\t    spell_print_node(node->wn_sibling, depth);\n\t}\n    }\n}\n\n    static void\nspell_print_tree(wordnode_T *root)\n{\n    if (root != NULL)\n    {\n\t// Clear the \"wn_u1.index\" fields, used to remember what has been\n\t// done.\n\tspell_clear_flags(root);\n\n\t// Recursively print the tree.\n\tspell_print_node(root, 0);\n    }\n}\n#endif // SPELL_PRINTTREE\n\n/*\n * Read the affix file \"fname\".\n * Returns an afffile_T, NULL for complete failure.\n */\n    static afffile_T *\nspell_read_aff(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    afffile_T\t*aff;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n#define MAXITEMCNT  30\n    char_u\t*(items[MAXITEMCNT]);\n    int\t\titemcnt;\n    char_u\t*p;\n    int\t\tlnum = 0;\n    affheader_T\t*cur_aff = NULL;\n    int\t\tdid_postpone_prefix = FALSE;\n    int\t\taff_todo = 0;\n    hashtab_T\t*tp;\n    char_u\t*low = NULL;\n    char_u\t*fol = NULL;\n    char_u\t*upp = NULL;\n    int\t\tdo_rep;\n    int\t\tdo_repsal;\n    int\t\tdo_sal;\n    int\t\tdo_mapline;\n    int\t\tfound_map = FALSE;\n    hashitem_T\t*hi;\n    int\t\tl;\n    int\t\tcompminlen = 0;\t\t// COMPOUNDMIN value\n    int\t\tcompsylmax = 0;\t\t// COMPOUNDSYLMAX value\n    int\t\tcompoptions = 0;\t// COMP_ flags\n    int\t\tcompmax = 0;\t\t// COMPOUNDWORDMAX value\n    char_u\t*compflags = NULL;\t// COMPOUNDFLAG and COMPOUNDRULE\n\t\t\t\t\t// concatenated\n    char_u\t*midword = NULL;\t// MIDWORD value\n    char_u\t*syllable = NULL;\t// SYLLABLE value\n    char_u\t*sofofrom = NULL;\t// SOFOFROM value\n    char_u\t*sofoto = NULL;\t\t// SOFOTO value\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn NULL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading affix file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // Only do REP lines when not done in another .aff file already.\n    do_rep = spin->si_rep.ga_len == 0;\n\n    // Only do REPSAL lines when not done in another .aff file already.\n    do_repsal = spin->si_repsal.ga_len == 0;\n\n    // Only do SAL lines when not done in another .aff file already.\n    do_sal = spin->si_sal.ga_len == 0;\n\n    // Only do MAP lines when not done in another .aff file already.\n    do_mapline = spin->si_map.ga_len == 0;\n\n    /*\n     * Allocate and init the afffile_T structure.\n     */\n    aff = (afffile_T *)getroom(spin, sizeof(afffile_T), TRUE);\n    if (aff == NULL)\n    {\n\tfclose(fd);\n\treturn NULL;\n    }\n    hash_init(&aff->af_pref);\n    hash_init(&aff->af_suff);\n    hash_init(&aff->af_comp);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\t// Split the line up in white separated items.  Put a NUL after each\n\t// item.\n\titemcnt = 0;\n\tfor (p = line; ; )\n\t{\n\t    while (*p != NUL && *p <= ' ')  // skip white space and CR/NL\n\t\t++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    if (itemcnt == MAXITEMCNT)\t    // too many items\n\t\tbreak;\n\t    items[itemcnt++] = p;\n\t    // A few items have arbitrary text argument, don't split them.\n\t    if (itemcnt == 2 && spell_info_item(items[0]))\n\t\twhile (*p >= ' ' || *p == TAB)    // skip until CR/NL\n\t\t    ++p;\n\t    else\n\t\twhile (*p > ' ')    // skip until white space or CR/NL\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *p++ = NUL;\n\t}\n\n\t// Handle non-empty lines.\n\tif (itemcnt > 0)\n\t{\n\t    if (is_aff_rule(items, itemcnt, \"SET\", 2) && aff->af_enc == NULL)\n\t    {\n\t\t// Setup for conversion from \"ENC\" to 'encoding'.\n\t\taff->af_enc = enc_canonize(items[1]);\n\t\tif (aff->af_enc != NULL && !spin->si_ascii\n\t\t\t&& convert_setup(&spin->si_conv, aff->af_enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t    smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t       fname, aff->af_enc, p_enc);\n\t\tspin->si_conv.vc_fail = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FLAG\", 2)\n\t\t\t\t\t      && aff->af_flagtype == AFT_CHAR)\n\t    {\n\t\tif (STRCMP(items[1], \"long\") == 0)\n\t\t    aff->af_flagtype = AFT_LONG;\n\t\telse if (STRCMP(items[1], \"num\") == 0)\n\t\t    aff->af_flagtype = AFT_NUM;\n\t\telse if (STRCMP(items[1], \"caplong\") == 0)\n\t\t    aff->af_flagtype = AFT_CAPLONG;\n\t\telse\n\t\t    smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t\tif (aff->af_rare != 0\n\t\t\t|| aff->af_keepcase != 0\n\t\t\t|| aff->af_bad != 0\n\t\t\t|| aff->af_needaffix != 0\n\t\t\t|| aff->af_circumfix != 0\n\t\t\t|| aff->af_needcomp != 0\n\t\t\t|| aff->af_comproot != 0\n\t\t\t|| aff->af_nosuggest != 0\n\t\t\t|| compflags != NULL\n\t\t\t|| aff->af_suff.ht_used > 0\n\t\t\t|| aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"FLAG after using flags in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t    }\n\t    else if (spell_info_item(items[0]))\n\t    {\n\t\t    p = (char_u *)getroom(spin,\n\t\t\t    (spin->si_info == NULL ? 0 : STRLEN(spin->si_info))\n\t\t\t    + STRLEN(items[0])\n\t\t\t    + STRLEN(items[1]) + 3, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (spin->si_info != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, spin->si_info);\n\t\t\t    STRCAT(p, \"\\n\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[0]);\n\t\t\tSTRCAT(p, \" \");\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tspin->si_info = p;\n\t\t    }\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MIDWORD\", 2)\n\t\t\t\t\t\t\t   && midword == NULL)\n\t    {\n\t\tmidword = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"TRY\", 2))\n\t    {\n\t\t// ignored, we look in the tree for what chars may appear\n\t    }\n\t    // TODO: remove \"RAR\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"RARE\", 2))\n\t\t\t\t\t\t\t && aff->af_rare == 0)\n\t    {\n\t\taff->af_rare = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    // TODO: remove \"KEP\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))\n\t\t\t\t\t\t     && aff->af_keepcase == 0)\n\t    {\n\t\taff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"FORBIDDENWORD\", 2))\n\t\t\t\t\t\t\t  && aff->af_bad == 0)\n\t    {\n\t\taff->af_bad = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)\n\t\t\t\t\t\t    && aff->af_needaffix == 0)\n\t    {\n\t\taff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)\n\t\t\t\t\t\t    && aff->af_circumfix == 0)\n\t    {\n\t\taff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)\n\t\t\t\t\t\t    && aff->af_nosuggest == 0)\n\t    {\n\t\taff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"ONLYINCOMPOUND\", 2))\n\t\t\t\t\t\t     && aff->af_needcomp == 0)\n\t    {\n\t\taff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)\n\t\t\t\t\t\t     && aff->af_comproot == 0)\n\t    {\n\t\taff->af_comproot = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_compforbid == 0)\n\t    {\n\t\taff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDPERMITFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_comppermit == 0)\n\t    {\n\t\taff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFLAG\", 2)\n\t\t\t\t\t\t\t && compflags == NULL)\n\t    {\n\t\t// Turn flag \"c\" into COMPOUNDRULE compatible string \"c+\",\n\t\t// \"Na\" into \"Na+\", \"1234\" into \"1234+\".\n\t\tp = getroom(spin, STRLEN(items[1]) + 2, FALSE);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCPY(p, items[1]);\n\t\t    STRCAT(p, \"+\");\n\t\t    compflags = p;\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULES\", 2))\n\t    {\n\t\t// We don't use the count, but do check that it's a number and\n\t\t// not COMPOUNDRULE mistyped.\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULE\", 2))\n\t    {\n\t\t// Don't use the first rule if it is a number.\n\t\tif (compflags != NULL || *skipdigits(items[1]) != NUL)\n\t\t{\n\t\t    // Concatenate this string to previously defined ones,\n\t\t    // using a slash to separate them.\n\t\t    l = (int)STRLEN(items[1]) + 1;\n\t\t    if (compflags != NULL)\n\t\t\tl += (int)STRLEN(compflags) + 1;\n\t\t    p = getroom(spin, l, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (compflags != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, compflags);\n\t\t\t    STRCAT(p, \"/\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tcompflags = p;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDWORDMAX\", 2)\n\t\t\t\t\t\t\t      && compmax == 0)\n\t    {\n\t\tcompmax = atoi((char *)items[1]);\n\t\tif (compmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDMIN\", 2)\n\t\t\t\t\t\t\t   && compminlen == 0)\n\t    {\n\t\tcompminlen = atoi((char *)items[1]);\n\t\tif (compminlen == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDSYLMAX\", 2)\n\t\t\t\t\t\t\t   && compsylmax == 0)\n\t    {\n\t\tcompsylmax = atoi((char *)items[1]);\n\t\tif (compsylmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDDUP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKDUP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDREP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKREP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDCASE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKCASE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDTRIPLE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKTRIPLE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))\n\t    {\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 3))\n\t    {\n\t\tgarray_T    *gap = &spin->si_comppat;\n\t\tint\t    i;\n\n\t\t// Only add the couple if it isn't already there.\n\t\tfor (i = 0; i < gap->ga_len - 1; i += 2)\n\t\t    if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0\n\t\t\t    && STRCMP(((char_u **)(gap->ga_data))[i + 1],\n\t\t\t\t\t\t\t       items[2]) == 0)\n\t\t\tbreak;\n\t\tif (i >= gap->ga_len && ga_grow(gap, 2) == OK)\n\t\t{\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[1]);\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SYLLABLE\", 2)\n\t\t\t\t\t\t\t  && syllable == NULL)\n\t    {\n\t\tsyllable = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOBREAK\", 1))\n\t    {\n\t\tspin->si_nobreak = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSPLITSUGS\", 1))\n\t    {\n\t\tspin->si_nosplitsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOCOMPOUNDSUGS\", 1))\n\t    {\n\t\tspin->si_nocompoundsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGFILE\", 1))\n\t    {\n\t\tspin->si_nosugfile = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"PFXPOSTPONE\", 1))\n\t    {\n\t\taff->af_pfxpostpone = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"IGNOREEXTRA\", 1))\n\t    {\n\t\taff->af_ignoreextra = TRUE;\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo == 0\n\t\t    && itemcnt >= 4)\n\t    {\n\t\tint\tlasti = 4;\n\t\tchar_u\tkey[AH_KEY_LEN];\n\n\t\tif (*items[0] == 'P')\n\t\t    tp = &aff->af_pref;\n\t\telse\n\t\t    tp = &aff->af_suff;\n\n\t\t// Myspell allows the same affix name to be used multiple\n\t\t// times.  The affix files that do this have an undocumented\n\t\t// \"S\" flag on all but the last block, thus we check for that\n\t\t// and store it in ah_follows.\n\t\tvim_strncpy(key, items[1], AH_KEY_LEN - 1);\n\t\thi = hash_find(tp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    cur_aff = HI2AH(hi);\n\t\t    if (cur_aff->ah_combine != (*items[2] == 'Y'))\n\t\t\tsmsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),\n\t\t\t\t\t\t   fname, lnum, items[1]);\n\t\t    if (!cur_aff->ah_follows)\n\t\t\tsmsg(_(\"Duplicate affix in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // New affix letter.\n\t\t    cur_aff = (affheader_T *)getroom(spin,\n\t\t\t\t\t\t   sizeof(affheader_T), TRUE);\n\t\t    if (cur_aff == NULL)\n\t\t\tbreak;\n\t\t    cur_aff->ah_flag = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    if (cur_aff->ah_flag == 0 || STRLEN(items[1]) >= AH_KEY_LEN)\n\t\t\tbreak;\n\t\t    if (cur_aff->ah_flag == aff->af_bad\n\t\t\t    || cur_aff->ah_flag == aff->af_rare\n\t\t\t    || cur_aff->ah_flag == aff->af_keepcase\n\t\t\t    || cur_aff->ah_flag == aff->af_needaffix\n\t\t\t    || cur_aff->ah_flag == aff->af_circumfix\n\t\t\t    || cur_aff->ah_flag == aff->af_nosuggest\n\t\t\t    || cur_aff->ah_flag == aff->af_needcomp\n\t\t\t    || cur_aff->ah_flag == aff->af_comproot)\n\t\t\tsmsg(_(\"Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t    STRCPY(cur_aff->ah_key, items[1]);\n\t\t    hash_add(tp, cur_aff->ah_key);\n\n\t\t    cur_aff->ah_combine = (*items[2] == 'Y');\n\t\t}\n\n\t\t// Check for the \"S\" flag, which apparently means that another\n\t\t// block with the same affix name is following.\n\t\tif (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0)\n\t\t{\n\t\t    ++lasti;\n\t\t    cur_aff->ah_follows = TRUE;\n\t\t}\n\t\telse\n\t\t    cur_aff->ah_follows = FALSE;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter.\n\t\tif (itemcnt > lasti && *items[lasti] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\tif (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)\n\t\t    smsg(_(\"Expected Y or N in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[2]);\n\n\t\tif (*items[0] == 'P' && aff->af_pfxpostpone)\n\t\t{\n\t\t    if (cur_aff->ah_newID == 0)\n\t\t    {\n\t\t\t// Use a new number in the .spl file later, to be able\n\t\t\t// to handle multiple .aff files.\n\t\t\tcheck_renumber(spin);\n\t\t\tcur_aff->ah_newID = ++spin->si_newprefID;\n\n\t\t\t// We only really use ah_newID if the prefix is\n\t\t\t// postponed.  We know that only after handling all\n\t\t\t// the items.\n\t\t\tdid_postpone_prefix = FALSE;\n\t\t    }\n\t\t    else\n\t\t\t// Did use the ID in a previous block.\n\t\t\tdid_postpone_prefix = TRUE;\n\t\t}\n\n\t\taff_todo = atoi((char *)items[3]);\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo > 0\n\t\t    && STRCMP(cur_aff->ah_key, items[1]) == 0\n\t\t    && itemcnt >= 5)\n\t    {\n\t\taffentry_T\t*aff_entry;\n\t\tint\t\tupper = FALSE;\n\t\tint\t\tlasti = 5;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter,\n\t\t// unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.\n\t\tif (itemcnt > lasti\n\t\t\t&& !aff->af_ignoreextra\n\t\t\t&& *items[lasti] != '#'\n\t\t\t&& (STRCMP(items[lasti], \"-\") != 0\n\t\t\t\t\t\t     || itemcnt != lasti + 1))\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\t// New item for an affix letter.\n\t\t--aff_todo;\n\t\taff_entry = (affentry_T *)getroom(spin,\n\t\t\t\t\t\t    sizeof(affentry_T), TRUE);\n\t\tif (aff_entry == NULL)\n\t\t    break;\n\n\t\tif (STRCMP(items[2], \"0\") != 0)\n\t\t    aff_entry->ae_chop = getroom_save(spin, items[2]);\n\t\tif (STRCMP(items[3], \"0\") != 0)\n\t\t{\n\t\t    aff_entry->ae_add = getroom_save(spin, items[3]);\n\n\t\t    // Recognize flags on the affix: abcd/XYZ\n\t\t    aff_entry->ae_flags = vim_strchr(aff_entry->ae_add, '/');\n\t\t    if (aff_entry->ae_flags != NULL)\n\t\t    {\n\t\t\t*aff_entry->ae_flags++ = NUL;\n\t\t\taff_process_flags(aff, aff_entry);\n\t\t    }\n\t\t}\n\n\t\t// Don't use an affix entry with non-ASCII characters when\n\t\t// \"spin->si_ascii\" is TRUE.\n\t\tif (!spin->si_ascii || !(has_non_ascii(aff_entry->ae_chop)\n\t\t\t\t\t  || has_non_ascii(aff_entry->ae_add)))\n\t\t{\n\t\t    aff_entry->ae_next = cur_aff->ah_first;\n\t\t    cur_aff->ah_first = aff_entry;\n\n\t\t    if (STRCMP(items[4], \".\") != 0)\n\t\t    {\n\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\taff_entry->ae_cond = getroom_save(spin, items[4]);\n\t\t\tif (*items[0] == 'P')\n\t\t\t    sprintf((char *)buf, \"^%s\", items[4]);\n\t\t\telse\n\t\t\t    sprintf((char *)buf, \"%s$\", items[4]);\n\t\t\taff_entry->ae_prog = vim_regcomp(buf,\n\t\t\t\t\t    RE_MAGIC + RE_STRING + RE_STRICT);\n\t\t\tif (aff_entry->ae_prog == NULL)\n\t\t\t    smsg(_(\"Broken condition in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[4]);\n\t\t    }\n\n\t\t    // For postponed prefixes we need an entry in si_prefcond\n\t\t    // for the condition.  Use an existing one if possible.\n\t\t    // Can't be done for an affix with flags, ignoring\n\t\t    // COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG.\n\t\t    if (*items[0] == 'P' && aff->af_pfxpostpone\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t    {\n\t\t\t// When the chop string is one lower-case letter and\n\t\t\t// the add string ends in the upper-case letter we set\n\t\t\t// the \"upper\" flag, clear \"ae_chop\" and remove the\n\t\t\t// letters from \"ae_add\".  The condition must either\n\t\t\t// be empty or start with the same letter.\n\t\t\tif (aff_entry->ae_chop != NULL\n\t\t\t\t&& aff_entry->ae_add != NULL\n\t\t\t\t&& aff_entry->ae_chop[(*mb_ptr2len)(\n\t\t\t\t\t\t   aff_entry->ae_chop)] == NUL)\n\t\t\t{\n\t\t\t    int\t\tc, c_up;\n\n\t\t\t    c = PTR2CHAR(aff_entry->ae_chop);\n\t\t\t    c_up = SPELL_TOUPPER(c);\n\t\t\t    if (c_up != c\n\t\t\t\t    && (aff_entry->ae_cond == NULL\n\t\t\t\t\t|| PTR2CHAR(aff_entry->ae_cond) == c))\n\t\t\t    {\n\t\t\t\tp = aff_entry->ae_add\n\t\t\t\t\t\t  + STRLEN(aff_entry->ae_add);\n\t\t\t\tMB_PTR_BACK(aff_entry->ae_add, p);\n\t\t\t\tif (PTR2CHAR(p) == c_up)\n\t\t\t\t{\n\t\t\t\t    upper = TRUE;\n\t\t\t\t    aff_entry->ae_chop = NULL;\n\t\t\t\t    *p = NUL;\n\n\t\t\t\t    // The condition is matched with the\n\t\t\t\t    // actual word, thus must check for the\n\t\t\t\t    // upper-case letter.\n\t\t\t\t    if (aff_entry->ae_cond != NULL)\n\t\t\t\t    {\n\t\t\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\t\t\tif (has_mbyte)\n\t\t\t\t\t{\n\t\t\t\t\t    onecap_copy(items[4], buf, TRUE);\n\t\t\t\t\t    aff_entry->ae_cond = getroom_save(\n\t\t\t\t\t\t\t\t   spin, buf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t    *aff_entry->ae_cond = c_up;\n\t\t\t\t\tif (aff_entry->ae_cond != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    sprintf((char *)buf, \"^%s\",\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t\t\t    vim_regfree(aff_entry->ae_prog);\n\t\t\t\t\t    aff_entry->ae_prog = vim_regcomp(\n\t\t\t\t\t\t    buf, RE_MAGIC + RE_STRING);\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (aff_entry->ae_chop == NULL\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t\t{\n\t\t\t    int\t\tidx;\n\t\t\t    char_u\t**pp;\n\t\t\t    int\t\tn;\n\n\t\t\t    // Find a previously used condition.\n\t\t\t    for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;\n\t\t\t\t\t\t\t\t\t--idx)\n\t\t\t    {\n\t\t\t\tp = ((char_u **)spin->si_prefcond.ga_data)[idx];\n\t\t\t\tif (str_equal(p, aff_entry->ae_cond))\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (idx < 0 && ga_grow(&spin->si_prefcond, 1) == OK)\n\t\t\t    {\n\t\t\t\t// Not found, add a new condition.\n\t\t\t\tidx = spin->si_prefcond.ga_len++;\n\t\t\t\tpp = ((char_u **)spin->si_prefcond.ga_data)\n\t\t\t\t\t\t\t\t\t+ idx;\n\t\t\t\tif (aff_entry->ae_cond == NULL)\n\t\t\t\t    *pp = NULL;\n\t\t\t\telse\n\t\t\t\t    *pp = getroom_save(spin,\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t    }\n\n\t\t\t    // Add the prefix to the prefix tree.\n\t\t\t    if (aff_entry->ae_add == NULL)\n\t\t\t\tp = (char_u *)\"\";\n\t\t\t    else\n\t\t\t\tp = aff_entry->ae_add;\n\n\t\t\t    // PFX_FLAGS is a negative number, so that\n\t\t\t    // tree_add_word() knows this is the prefix tree.\n\t\t\t    n = PFX_FLAGS;\n\t\t\t    if (!cur_aff->ah_combine)\n\t\t\t\tn |= WFP_NC;\n\t\t\t    if (upper)\n\t\t\t\tn |= WFP_UP;\n\t\t\t    if (aff_entry->ae_comppermit)\n\t\t\t\tn |= WFP_COMPPERMIT;\n\t\t\t    if (aff_entry->ae_compforbid)\n\t\t\t\tn |= WFP_COMPFORBID;\n\t\t\t    tree_add_word(spin, p, spin->si_prefroot, n,\n\t\t\t\t\t\t      idx, cur_aff->ah_newID);\n\t\t\t    did_postpone_prefix = TRUE;\n\t\t\t}\n\n\t\t\t// Didn't actually use ah_newID, backup si_newprefID.\n\t\t\tif (aff_todo == 0 && !did_postpone_prefix)\n\t\t\t{\n\t\t\t    --spin->si_newprefID;\n\t\t\t    cur_aff->ah_newID = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FOL\", 2) && fol == NULL)\n\t    {\n\t\tfol = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"LOW\", 2) && low == NULL)\n\t    {\n\t\tlow = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"UPP\", 2) && upp == NULL)\n\t    {\n\t\tupp = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"REP\", 2)\n\t\t     || is_aff_rule(items, itemcnt, \"REPSAL\", 2))\n\t    {\n\t\t// Ignore REP/REPSAL count\n\t\tif (!isdigit(*items[1]))\n\t\t    smsg(_(\"Expected REP(SAL) count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((STRCMP(items[0], \"REP\") == 0\n\t\t\t|| STRCMP(items[0], \"REPSAL\") == 0)\n\t\t    && itemcnt >= 3)\n\t    {\n\t\t// REP/REPSAL item\n\t\t// Myspell ignores extra arguments, we require it starts with\n\t\t// # to detect mistakes.\n\t\tif (itemcnt > 3 && items[3][0] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[3]);\n\t\tif (items[0][3] == 'S' ? do_repsal : do_rep)\n\t\t{\n\t\t    // Replace underscore with space (can't include a space\n\t\t    // directly).\n\t\t    for (p = items[1]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    for (p = items[2]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    add_fromto(spin, items[0][3] == 'S'\n\t\t\t\t\t ? &spin->si_repsal\n\t\t\t\t\t : &spin->si_rep, items[1], items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MAP\", 2))\n\t    {\n\t\t// MAP item or count\n\t\tif (!found_map)\n\t\t{\n\t\t    // First line contains the count.\n\t\t    found_map = TRUE;\n\t\t    if (!isdigit(*items[1]))\n\t\t\tsmsg(_(\"Expected MAP count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t}\n\t\telse if (do_mapline)\n\t\t{\n\t\t    int\t\tc;\n\n\t\t    // Check that every character appears only once.\n\t\t    for (p = items[1]; *p != NUL; )\n\t\t    {\n\t\t\tc = mb_ptr2char_adv(&p);\n\t\t\tif ((spin->si_map.ga_len > 0\n\t\t\t\t    && vim_strchr(spin->si_map.ga_data, c)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t\t|| vim_strchr(p, c) != NULL)\n\t\t\t    smsg(_(\"Duplicate character in MAP in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    }\n\n\t\t    // We simply concatenate all the MAP strings, separated by\n\t\t    // slashes.\n\t\t    ga_concat(&spin->si_map, items[1]);\n\t\t    ga_append(&spin->si_map, '/');\n\t\t}\n\t    }\n\t    // Accept \"SAL from to\" and \"SAL from to  #comment\".\n\t    else if (is_aff_rule(items, itemcnt, \"SAL\", 3))\n\t    {\n\t\tif (do_sal)\n\t\t{\n\t\t    // SAL item (sounds-a-like)\n\t\t    // Either one of the known keys or a from-to pair.\n\t\t    if (STRCMP(items[1], \"followup\") == 0)\n\t\t\tspin->si_followup = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"collapse_result\") == 0)\n\t\t\tspin->si_collapse = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"remove_accents\") == 0)\n\t\t\tspin->si_rem_accents = sal_to_bool(items[2]);\n\t\t    else\n\t\t\t// when \"to\" is \"_\" it means empty\n\t\t\tadd_fromto(spin, &spin->si_sal, items[1],\n\t\t\t\t     STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"\n\t\t\t\t\t\t\t\t: items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOFROM\", 2)\n\t\t\t\t\t\t\t  && sofofrom == NULL)\n\t    {\n\t\tsofofrom = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOTO\", 2)\n\t\t\t\t\t\t\t    && sofoto == NULL)\n\t    {\n\t\tsofoto = getroom_save(spin, items[1]);\n\t    }\n\t    else if (STRCMP(items[0], \"COMMON\") == 0)\n\t    {\n\t\tint\ti;\n\n\t\tfor (i = 1; i < itemcnt; ++i)\n\t\t{\n\t\t    if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,\n\t\t\t\t\t\t\t\t   items[i])))\n\t\t    {\n\t\t\tp = vim_strsave(items[i]);\n\t\t\tif (p == NULL)\n\t\t\t    break;\n\t\t\thash_add(&spin->si_commonwords, p);\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tsmsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[0]);\n\t}\n    }\n\n    if (fol != NULL || low != NULL || upp != NULL)\n    {\n\tif (spin->si_clear_chartab)\n\t{\n\t    // Clear the char type tables, don't want to use any of the\n\t    // currently used spell properties.\n\t    init_spell_chartab();\n\t    spin->si_clear_chartab = FALSE;\n\t}\n\n\t/*\n\t * Don't write a word table for an ASCII file, so that we don't check\n\t * for conflicts with a word table that matches 'encoding'.\n\t * Don't write one for utf-8 either, we use utf_*() and\n\t * mb_get_class(), the list of chars in the file will be incomplete.\n\t */\n\tif (!spin->si_ascii && !enc_utf8)\n\t{\n\t    if (fol == NULL || low == NULL || upp == NULL)\n\t\tsmsg(_(\"Missing FOL/LOW/UPP line in %s\"), fname);\n\t    else\n\t\t(void)set_spell_chartab(fol, low, upp);\n\t}\n\n\tvim_free(fol);\n\tvim_free(low);\n\tvim_free(upp);\n    }\n\n    // Use compound specifications of the .aff file for the spell info.\n    if (compmax != 0)\n    {\n\taff_check_number(spin->si_compmax, compmax, \"COMPOUNDWORDMAX\");\n\tspin->si_compmax = compmax;\n    }\n\n    if (compminlen != 0)\n    {\n\taff_check_number(spin->si_compminlen, compminlen, \"COMPOUNDMIN\");\n\tspin->si_compminlen = compminlen;\n    }\n\n    if (compsylmax != 0)\n    {\n\tif (syllable == NULL)\n\t    smsg(_(\"COMPOUNDSYLMAX used without SYLLABLE\"));\n\taff_check_number(spin->si_compsylmax, compsylmax, \"COMPOUNDSYLMAX\");\n\tspin->si_compsylmax = compsylmax;\n    }\n\n    if (compoptions != 0)\n    {\n\taff_check_number(spin->si_compoptions, compoptions, \"COMPOUND options\");\n\tspin->si_compoptions |= compoptions;\n    }\n\n    if (compflags != NULL)\n\tprocess_compflags(spin, aff, compflags);\n\n    // Check that we didn't use too many renumbered flags.\n    if (spin->si_newcompID < spin->si_newprefID)\n    {\n\tif (spin->si_newcompID == 127 || spin->si_newcompID == 255)\n\t    msg(_(\"Too many postponed prefixes\"));\n\telse if (spin->si_newprefID == 0 || spin->si_newprefID == 127)\n\t    msg(_(\"Too many compound flags\"));\n\telse\n\t    msg(_(\"Too many postponed prefixes and/or compound flags\"));\n    }\n\n    if (syllable != NULL)\n    {\n\taff_check_string(spin->si_syllable, syllable, \"SYLLABLE\");\n\tspin->si_syllable = syllable;\n    }\n\n    if (sofofrom != NULL || sofoto != NULL)\n    {\n\tif (sofofrom == NULL || sofoto == NULL)\n\t    smsg(_(\"Missing SOFO%s line in %s\"),\n\t\t\t\t     sofofrom == NULL ? \"FROM\" : \"TO\", fname);\n\telse if (spin->si_sal.ga_len > 0)\n\t    smsg(_(\"Both SAL and SOFO lines in %s\"), fname);\n\telse\n\t{\n\t    aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");\n\t    aff_check_string(spin->si_sofoto, sofoto, \"SOFOTO\");\n\t    spin->si_sofofr = sofofrom;\n\t    spin->si_sofoto = sofoto;\n\t}\n    }\n\n    if (midword != NULL)\n    {\n\taff_check_string(spin->si_midword, midword, \"MIDWORD\");\n\tspin->si_midword = midword;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n    return aff;\n}\n\n/*\n * Return TRUE when items[0] equals \"rulename\", there are \"mincount\" items or\n * a comment is following after item \"mincount\".\n */\n    static int\nis_aff_rule(\n    char_u\t**items,\n    int\t\titemcnt,\n    char\t*rulename,\n    int\t\tmincount)\n{\n    return (STRCMP(items[0], rulename) == 0\n\t    && (itemcnt == mincount\n\t\t|| (itemcnt > mincount && items[mincount][0] == '#')));\n}\n\n/*\n * For affix \"entry\" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from\n * ae_flags to ae_comppermit and ae_compforbid.\n */\n    static void\naff_process_flags(afffile_T *affile, affentry_T *entry)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n\n    if (entry->ae_flags != NULL\n\t\t&& (affile->af_compforbid != 0 || affile->af_comppermit != 0))\n    {\n\tfor (p = entry->ae_flags; *p != NUL; )\n\t{\n\t    prevp = p;\n\t    flag = get_affitem(affile->af_flagtype, &p);\n\t    if (flag == affile->af_comppermit || flag == affile->af_compforbid)\n\t    {\n\t\tSTRMOVE(prevp, p);\n\t\tp = prevp;\n\t\tif (flag == affile->af_comppermit)\n\t\t    entry->ae_comppermit = TRUE;\n\t\telse\n\t\t    entry->ae_compforbid = TRUE;\n\t    }\n\t    if (affile->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n\tif (*entry->ae_flags == NUL)\n\t    entry->ae_flags = NULL;\t// nothing left\n    }\n}\n\n/*\n * Return TRUE if \"s\" is the name of an info item in the affix file.\n */\n    static int\nspell_info_item(char_u *s)\n{\n    return STRCMP(s, \"NAME\") == 0\n\t|| STRCMP(s, \"HOME\") == 0\n\t|| STRCMP(s, \"VERSION\") == 0\n\t|| STRCMP(s, \"AUTHOR\") == 0\n\t|| STRCMP(s, \"EMAIL\") == 0\n\t|| STRCMP(s, \"COPYRIGHT\") == 0;\n}\n\n/*\n * Turn an affix flag name into a number, according to the FLAG type.\n * returns zero for failure.\n */\n    static unsigned\naffitem2flag(\n    int\t\tflagtype,\n    char_u\t*item,\n    char_u\t*fname,\n    int\t\tlnum)\n{\n    unsigned\tres;\n    char_u\t*p = item;\n\n    res = get_affitem(flagtype, &p);\n    if (res == 0)\n    {\n\tif (flagtype == AFT_NUM)\n\t    smsg(_(\"Flag is not a number in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n\telse\n\t    smsg(_(\"Illegal flag in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n    }\n    if (*p != NUL)\n    {\n\tsmsg(_(e_affname), fname, lnum, item);\n\treturn 0;\n    }\n\n    return res;\n}\n\n/*\n * Get one affix name from \"*pp\" and advance the pointer.\n * Returns ZERO_FLAG for \"0\".\n * Returns zero for an error, still advances the pointer then.\n */\n    static unsigned\nget_affitem(int flagtype, char_u **pp)\n{\n    int\t\tres;\n\n    if (flagtype == AFT_NUM)\n    {\n\tif (!VIM_ISDIGIT(**pp))\n\t{\n\t    ++*pp;\t// always advance, avoid getting stuck\n\t    return 0;\n\t}\n\tres = getdigits(pp);\n\tif (res == 0)\n\t    res = ZERO_FLAG;\n    }\n    else\n    {\n\tres = mb_ptr2char_adv(pp);\n\tif (flagtype == AFT_LONG || (flagtype == AFT_CAPLONG\n\t\t\t\t\t\t && res >= 'A' && res <= 'Z'))\n\t{\n\t    if (**pp == NUL)\n\t\treturn 0;\n\t    res = mb_ptr2char_adv(pp) + (res << 16);\n\t}\n    }\n    return res;\n}\n\n/*\n * Process the \"compflags\" string used in an affix file and append it to\n * spin->si_compflags.\n * The processing involves changing the affix names to ID numbers, so that\n * they fit in one byte.\n */\n    static void\nprocess_compflags(\n    spellinfo_T\t*spin,\n    afffile_T\t*aff,\n    char_u\t*compflags)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n    compitem_T\t*ci;\n    int\t\tid;\n    int\t\tlen;\n    char_u\t*tp;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    // Make room for the old and the new compflags, concatenated with a / in\n    // between.  Processing it makes it shorter, but we don't know by how\n    // much, thus allocate the maximum.\n    len = (int)STRLEN(compflags) + 1;\n    if (spin->si_compflags != NULL)\n\tlen += (int)STRLEN(spin->si_compflags) + 1;\n    p = getroom(spin, len, FALSE);\n    if (p == NULL)\n\treturn;\n    if (spin->si_compflags != NULL)\n    {\n\tSTRCPY(p, spin->si_compflags);\n\tSTRCAT(p, \"/\");\n    }\n    spin->si_compflags = p;\n    tp = p + STRLEN(p);\n\n    for (p = compflags; *p != NUL; )\n    {\n\tif (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)\n\t    // Copy non-flag characters directly.\n\t    *tp++ = *p++;\n\telse\n\t{\n\t    // First get the flag number, also checks validity.\n\t    prevp = p;\n\t    flag = get_affitem(aff->af_flagtype, &p);\n\t    if (flag != 0)\n\t    {\n\t\t// Find the flag in the hashtable.  If it was used before, use\n\t\t// the existing ID.  Otherwise add a new entry.\n\t\tvim_strncpy(key, prevp, p - prevp);\n\t\thi = hash_find(&aff->af_comp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    id = HI2CI(hi)->ci_newID;\n\t\telse\n\t\t{\n\t\t    ci = (compitem_T *)getroom(spin, sizeof(compitem_T), TRUE);\n\t\t    if (ci == NULL)\n\t\t\tbreak;\n\t\t    STRCPY(ci->ci_key, key);\n\t\t    ci->ci_flag = flag;\n\t\t    // Avoid using a flag ID that has a special meaning in a\n\t\t    // regexp (also inside []).\n\t\t    do\n\t\t    {\n\t\t\tcheck_renumber(spin);\n\t\t\tid = spin->si_newcompID--;\n\t\t    } while (vim_strchr((char_u *)\"/?*+[]\\\\-^\", id) != NULL);\n\t\t    ci->ci_newID = id;\n\t\t    hash_add(&aff->af_comp, ci->ci_key);\n\t\t}\n\t\t*tp++ = id;\n\t    }\n\t    if (aff->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n    }\n\n    *tp = NUL;\n}\n\n/*\n * Check that the new IDs for postponed affixes and compounding don't overrun\n * each other.  We have almost 255 available, but start at 0-127 to avoid\n * using two bytes for utf-8.  When the 0-127 range is used up go to 128-255.\n * When that is used up an error message is given.\n */\n    static void\ncheck_renumber(spellinfo_T *spin)\n{\n    if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)\n    {\n\tspin->si_newprefID = 127;\n\tspin->si_newcompID = 255;\n    }\n}\n\n/*\n * Return TRUE if flag \"flag\" appears in affix list \"afflist\".\n */\n    static int\nflag_in_afflist(int flagtype, char_u *afflist, unsigned flag)\n{\n    char_u\t*p;\n    unsigned\tn;\n\n    switch (flagtype)\n    {\n\tcase AFT_CHAR:\n\t    return vim_strchr(afflist, flag) != NULL;\n\n\tcase AFT_CAPLONG:\n\tcase AFT_LONG:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = mb_ptr2char_adv(&p);\n\t\tif ((flagtype == AFT_LONG || (n >= 'A' && n <= 'Z'))\n\t\t\t\t\t\t\t\t && *p != NUL)\n\t\t    n = mb_ptr2char_adv(&p) + (n << 16);\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t    }\n\t    break;\n\n\tcase AFT_NUM:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = getdigits(&p);\n\t\tif (n == 0)\n\t\t    n = ZERO_FLAG;\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t\tif (*p != NUL)\t// skip over comma\n\t\t    ++p;\n\t    }\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" numbers are set and not the same.\n */\n    static void\naff_check_number(int spinval, int affval, char *name)\n{\n    if (spinval != 0 && spinval != affval)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" strings are set and not the same.\n */\n    static void\naff_check_string(char_u *spinval, char_u *affval, char *name)\n{\n    if (spinval != NULL && STRCMP(spinval, affval) != 0)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Return TRUE if strings \"s1\" and \"s2\" are equal.  Also consider both being\n * NULL as equal.\n */\n    static int\nstr_equal(char_u *s1, char_u *s2)\n{\n    if (s1 == NULL || s2 == NULL)\n\treturn s1 == s2;\n    return STRCMP(s1, s2) == 0;\n}\n\n/*\n * Add a from-to item to \"gap\".  Used for REP and SAL items.\n * They are stored case-folded.\n */\n    static void\nadd_fromto(\n    spellinfo_T\t*spin,\n    garray_T\t*gap,\n    char_u\t*from,\n    char_u\t*to)\n{\n    fromto_T\t*ftp;\n    char_u\tword[MAXWLEN];\n\n    if (ga_grow(gap, 1) == OK)\n    {\n\tftp = ((fromto_T *)gap->ga_data) + gap->ga_len;\n\t(void)spell_casefold(curwin, from, (int)STRLEN(from), word, MAXWLEN);\n\tftp->ft_from = getroom_save(spin, word);\n\t(void)spell_casefold(curwin, to, (int)STRLEN(to), word, MAXWLEN);\n\tftp->ft_to = getroom_save(spin, word);\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Convert a boolean argument in a SAL line to TRUE or FALSE;\n */\n    static int\nsal_to_bool(char_u *s)\n{\n    return STRCMP(s, \"1\") == 0 || STRCMP(s, \"true\") == 0;\n}\n\n/*\n * Free the structure filled by spell_read_aff().\n */\n    static void\nspell_free_aff(afffile_T *aff)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n\n    vim_free(aff->af_enc);\n\n    // All this trouble to free the \"ae_prog\" items...\n    for (ht = &aff->af_pref; ; ht = &aff->af_suff)\n    {\n\ttodo = (int)ht->ht_used;\n\tfor (hi = ht->ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tah = HI2AH(hi);\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t    vim_regfree(ae->ae_prog);\n\t    }\n\t}\n\tif (ht == &aff->af_suff)\n\t    break;\n    }\n\n    hash_clear(&aff->af_pref);\n    hash_clear(&aff->af_suff);\n    hash_clear(&aff->af_comp);\n}\n\n/*\n * Read dictionary file \"fname\".\n * Returns OK or FAIL;\n */\n    static int\nspell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)\n{\n    hashtab_T\tht;\n    char_u\tline[MAXLINELEN];\n    char_u\t*p;\n    char_u\t*afflist;\n    char_u\tstore_afflist[MAXWLEN];\n    int\t\tpfxlen;\n    int\t\tneed_affix;\n    char_u\t*dw;\n    char_u\t*pc;\n    char_u\t*w;\n    int\t\tl;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    FILE\t*fd;\n    int\t\tlnum = 1;\n    int\t\tnon_ascii = 0;\n    int\t\tretval = OK;\n    char_u\tmessage[MAXLINELEN + MAXWLEN];\n    int\t\tflags;\n    int\t\tduplicate = 0;\n    time_T\tlast_msg_time = 0;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // The hashtable is only used to detect duplicated words.\n    hash_init(&ht);\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Reading dictionary file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // start with a message for the first line\n    spin->si_msg_count = 999999;\n\n    // Read and ignore the first line: word count.\n    if (vim_fgets(line, MAXLINELEN, fd) || !vim_isdigit(*skipwhite(line)))\n\tsemsg(_(e_no_word_count_in_str), fname);\n\n    /*\n     * Read all the lines in the file one by one.\n     * The words are converted to 'encoding' here, before being added to\n     * the hashtable.\n     */\n    while (!vim_fgets(line, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\tif (line[0] == '#' || line[0] == '/')\n\t    continue;\t// comment line\n\n\t// Remove CR, LF and white space from the end.  White space halfway\n\t// the word is kept to allow e.g., \"et al.\".\n\tl = (int)STRLEN(line);\n\twhile (l > 0 && line[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty line\n\tline[l] = NUL;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, line, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\tcontinue;\n\t    }\n\t    w = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    w = line;\n\t}\n\n\t// Truncate the word at the \"/\", set \"afflist\" to what follows.\n\t// Replace \"\\/\" by \"/\" and \"\\\\\" by \"\\\".\n\tafflist = NULL;\n\tfor (p = w; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (*p == '\\\\' && (p[1] == '\\\\' || p[1] == '/'))\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '/')\n\t    {\n\t\t*p = NUL;\n\t\tafflist = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(w))\n\t{\n\t    ++non_ascii;\n\t    vim_free(pc);\n\t    continue;\n\t}\n\n\t// This takes time, print a message every 10000 words, but not more\n\t// often than once per second.\n\tif (spin->si_verbose && spin->si_msg_count > 10000)\n\t{\n\t    spin->si_msg_count = 0;\n\t    if (vim_time() > last_msg_time)\n\t    {\n\t\tlast_msg_time = vim_time();\n\t\tvim_snprintf((char *)message, sizeof(message),\n\t\t\t_(\"line %6d, word %6ld - %s\"),\n\t\t\t   lnum, spin->si_foldwcount + spin->si_keepwcount, w);\n\t\tmsg_start();\n\t\tmsg_outtrans_long_attr(message, 0);\n\t\tmsg_clr_eos();\n\t\tmsg_didout = FALSE;\n\t\tmsg_col = 0;\n\t\tout_flush();\n\t    }\n\t}\n\n\t// Store the word in the hashtable to be able to find duplicates.\n\tdw = getroom_save(spin, w);\n\tif (dw == NULL)\n\t{\n\t    retval = FAIL;\n\t    vim_free(pc);\n\t    break;\n\t}\n\n\thash = hash_hash(dw);\n\thi = hash_lookup(&ht, dw, hash);\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    if (p_verbose > 0)\n\t\tsmsg(_(\"Duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    else if (duplicate == 0)\n\t\tsmsg(_(\"First duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    ++duplicate;\n\t}\n\telse\n\t    hash_add_item(&ht, hi, dw, hash);\n\n\tflags = 0;\n\tstore_afflist[0] = NUL;\n\tpfxlen = 0;\n\tneed_affix = FALSE;\n\tif (afflist != NULL)\n\t{\n\t    // Extract flags from the affix list.\n\t    flags |= get_affix_flags(affile, afflist);\n\n\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_needaffix))\n\t\tneed_affix = TRUE;\n\n\t    if (affile->af_pfxpostpone)\n\t\t// Need to store the list of prefix IDs with the word.\n\t\tpfxlen = get_pfxlist(affile, afflist, store_afflist);\n\n\t    if (spin->si_compflags != NULL)\n\t\t// Need to store the list of compound flags with the word.\n\t\t// Concatenate them to the list of prefix IDs.\n\t\tget_compflags(affile, afflist, store_afflist + pfxlen);\n\t}\n\n\t// Add the word to the word tree(s).\n\tif (store_word(spin, dw, flags, spin->si_region,\n\t\t\t\t\t   store_afflist, need_affix) == FAIL)\n\t    retval = FAIL;\n\n\tif (afflist != NULL)\n\t{\n\t    // Find all matching suffixes and add the resulting words.\n\t    // Additionally do matching prefixes that combine.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t   &affile->af_suff, &affile->af_pref,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\n\t    // Find all matching prefixes and add the resulting words.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t  &affile->af_pref, NULL,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\t}\n\n\tvim_free(pc);\n    }\n\n    if (duplicate > 0)\n\tsmsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);\n    if (spin->si_ascii && non_ascii > 0)\n\tsmsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),\n\t\t\t\t\t\t\t    non_ascii, fname);\n    hash_clear(&ht);\n\n    fclose(fd);\n    return retval;\n}\n\n/*\n * Check for affix flags in \"afflist\" that are turned into word flags.\n * Return WF_ flags.\n */\n    static int\nget_affix_flags(afffile_T *affile, char_u *afflist)\n{\n    int\t\tflags = 0;\n\n    if (affile->af_keepcase != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_keepcase))\n\tflags |= WF_KEEPCAP | WF_FIXCAP;\n    if (affile->af_rare != 0 && flag_in_afflist(\n\t\t\t       affile->af_flagtype, afflist, affile->af_rare))\n\tflags |= WF_RARE;\n    if (affile->af_bad != 0 && flag_in_afflist(\n\t\t\t\taffile->af_flagtype, afflist, affile->af_bad))\n\tflags |= WF_BANNED;\n    if (affile->af_needcomp != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_needcomp))\n\tflags |= WF_NEEDCOMP;\n    if (affile->af_comproot != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_comproot))\n\tflags |= WF_COMPROOT;\n    if (affile->af_nosuggest != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_nosuggest))\n\tflags |= WF_NOSUGGEST;\n    return flags;\n}\n\n/*\n * Get the list of prefix IDs from the affix list \"afflist\".\n * Used for PFXPOSTPONE.\n * Put the resulting flags in \"store_afflist[MAXWLEN]\" with a terminating NUL\n * and return the number of affixes.\n */\n    static int\nget_pfxlist(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    int\t\tid;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a postponed prefix flag if it appears in \"af_pref\"\n\t    // and its ID is not zero.\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_pref, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tid = HI2AH(hi)->ah_newID;\n\t\tif (id != 0)\n\t\t    store_afflist[cnt++] = id;\n\t    }\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n    return cnt;\n}\n\n/*\n * Get the list of compound IDs from the affix list \"afflist\" that are used\n * for compound words.\n * Puts the flags in \"store_afflist[]\".\n */\n    static void\nget_compflags(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a compound flag if it appears in \"af_comp\".\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_comp, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\tstore_afflist[cnt++] = HI2CI(hi)->ci_newID;\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n}\n\n/*\n * Apply affixes to a word and store the resulting words.\n * \"ht\" is the hashtable with affentry_T that need to be applied, either\n * prefixes or suffixes.\n * \"xht\", when not NULL, is the prefix hashtable, to be used additionally on\n * the resulting words for combining affixes.\n *\n * Returns FAIL when out of memory.\n */\n    static int\nstore_aff_word(\n    spellinfo_T\t*spin,\t\t// spell info\n    char_u\t*word,\t\t// basic word start\n    char_u\t*afflist,\t// list of names of supported affixes\n    afffile_T\t*affile,\n    hashtab_T\t*ht,\n    hashtab_T\t*xht,\n    int\t\tcondit,\t\t// CONDIT_SUF et al.\n    int\t\tflags,\t\t// flags for the word\n    char_u\t*pfxlist,\t// list of prefix IDs\n    int\t\tpfxlen)\t\t// nr of flags in \"pfxlist\" for prefixes, rest\n\t\t\t\t// is compound flags\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n    char_u\tnewword[MAXWLEN];\n    int\t\tretval = OK;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tuse_flags;\n    char_u\t*use_pfxlist;\n    int\t\tuse_pfxlen;\n    int\t\tneed_affix;\n    char_u\tstore_afflist[MAXWLEN];\n    char_u\tpfx_pfxlist[MAXWLEN];\n    size_t\twordlen = STRLEN(word);\n    int\t\tuse_condit;\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ah = HI2AH(hi);\n\n\t    // Check that the affix combines, if required, and that the word\n\t    // supports this affix.\n\t    if (((condit & CONDIT_COMB) == 0 || ah->ah_combine)\n\t\t    && flag_in_afflist(affile->af_flagtype, afflist,\n\t\t\t\t\t\t\t\t ah->ah_flag))\n\t    {\n\t\t// Loop over all affix entries with this name.\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t{\n\t\t    // Check the condition.  It's not logical to match case\n\t\t    // here, but it is required for compatibility with\n\t\t    // Myspell.\n\t\t    // Another requirement from Myspell is that the chop\n\t\t    // string is shorter than the word itself.\n\t\t    // For prefixes, when \"PFXPOSTPONE\" was used, only do\n\t\t    // prefixes with a chop string and/or flags.\n\t\t    // When a previously added affix had CIRCUMFIX this one\n\t\t    // must have it too, if it had not then this one must not\n\t\t    // have one either.\n\t\t    if ((xht != NULL || !affile->af_pfxpostpone\n\t\t\t\t|| ae->ae_chop != NULL\n\t\t\t\t|| ae->ae_flags != NULL)\n\t\t\t    && (ae->ae_chop == NULL\n\t\t\t\t|| STRLEN(ae->ae_chop) < wordlen)\n\t\t\t    && (ae->ae_prog == NULL\n\t\t\t\t|| vim_regexec_prog(&ae->ae_prog, FALSE,\n\t\t\t\t\t\t\t    word, (colnr_T)0))\n\t\t\t    && (((condit & CONDIT_CFIX) == 0)\n\t\t\t\t== ((condit & CONDIT_AFF) == 0\n\t\t\t\t    || ae->ae_flags == NULL\n\t\t\t\t    || !flag_in_afflist(affile->af_flagtype,\n\t\t\t\t\tae->ae_flags, affile->af_circumfix))))\n\t\t    {\n\t\t\t// Match.  Remove the chop and add the affix.\n\t\t\tif (xht == NULL)\n\t\t\t{\n\t\t\t    // prefix: chop/add at the start of the word\n\t\t\t    if (ae->ae_add == NULL)\n\t\t\t\t*newword = NUL;\n\t\t\t    else\n\t\t\t\tvim_strncpy(newword, ae->ae_add, MAXWLEN - 1);\n\t\t\t    p = word;\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Skip chop string.\n\t\t\t\tif (has_mbyte)\n\t\t\t\t{\n\t\t\t\t    i = mb_charlen(ae->ae_chop);\n\t\t\t\t    for ( ; i > 0; --i)\n\t\t\t\t\tMB_PTR_ADV(p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    p += STRLEN(ae->ae_chop);\n\t\t\t    }\n\t\t\t    STRCAT(newword, p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // suffix: chop/add at the end of the word\n\t\t\t    vim_strncpy(newword, word, MAXWLEN - 1);\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Remove chop string.\n\t\t\t\tp = newword + STRLEN(newword);\n\t\t\t\ti = (int)MB_CHARLEN(ae->ae_chop);\n\t\t\t\tfor ( ; i > 0; --i)\n\t\t\t\t    MB_PTR_BACK(newword, p);\n\t\t\t\t*p = NUL;\n\t\t\t    }\n\t\t\t    if (ae->ae_add != NULL)\n\t\t\t\tSTRCAT(newword, ae->ae_add);\n\t\t\t}\n\n\t\t\tuse_flags = flags;\n\t\t\tuse_pfxlist = pfxlist;\n\t\t\tuse_pfxlen = pfxlen;\n\t\t\tneed_affix = FALSE;\n\t\t\tuse_condit = condit | CONDIT_COMB | CONDIT_AFF;\n\t\t\tif (ae->ae_flags != NULL)\n\t\t\t{\n\t\t\t    // Extract flags from the affix list.\n\t\t\t    use_flags |= get_affix_flags(affile, ae->ae_flags);\n\n\t\t\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_needaffix))\n\t\t\t\tneed_affix = TRUE;\n\n\t\t\t    // When there is a CIRCUMFIX flag the other affix\n\t\t\t    // must also have it and we don't add the word\n\t\t\t    // with one affix.\n\t\t\t    if (affile->af_circumfix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_circumfix))\n\t\t\t    {\n\t\t\t\tuse_condit |= CONDIT_CFIX;\n\t\t\t\tif ((condit & CONDIT_CFIX) == 0)\n\t\t\t\t    need_affix = TRUE;\n\t\t\t    }\n\n\t\t\t    if (affile->af_pfxpostpone\n\t\t\t\t\t\t|| spin->si_compflags != NULL)\n\t\t\t    {\n\t\t\t\tif (affile->af_pfxpostpone)\n\t\t\t\t    // Get prefix IDS from the affix list.\n\t\t\t\t    use_pfxlen = get_pfxlist(affile,\n\t\t\t\t\t\t ae->ae_flags, store_afflist);\n\t\t\t\telse\n\t\t\t\t    use_pfxlen = 0;\n\t\t\t\tuse_pfxlist = store_afflist;\n\n\t\t\t\t// Combine the prefix IDs. Avoid adding the\n\t\t\t\t// same ID twice.\n\t\t\t\tfor (i = 0; i < pfxlen; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = 0; j < use_pfxlen; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j == use_pfxlen)\n\t\t\t\t\tuse_pfxlist[use_pfxlen++] = pfxlist[i];\n\t\t\t\t}\n\n\t\t\t\tif (spin->si_compflags != NULL)\n\t\t\t\t    // Get compound IDS from the affix list.\n\t\t\t\t    get_compflags(affile, ae->ae_flags,\n\t\t\t\t\t\t  use_pfxlist + use_pfxlen);\n\n\t\t\t\t// Combine the list of compound flags.\n\t\t\t\t// Concatenate them to the prefix IDs list.\n\t\t\t\t// Avoid adding the same ID twice.\n\t\t\t\tfor (i = pfxlen; pfxlist[i] != NUL; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = use_pfxlen;\n\t\t\t\t\t\t   use_pfxlist[j] != NUL; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (use_pfxlist[j] == NUL)\n\t\t\t\t    {\n\t\t\t\t\tuse_pfxlist[j++] = pfxlist[i];\n\t\t\t\t\tuse_pfxlist[j] = NUL;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// Obey a \"COMPOUNDFORBIDFLAG\" of the affix: don't\n\t\t\t// use the compound flags.\n\t\t\tif (use_pfxlist != NULL && ae->ae_compforbid)\n\t\t\t{\n\t\t\t    vim_strncpy(pfx_pfxlist, use_pfxlist, use_pfxlen);\n\t\t\t    use_pfxlist = pfx_pfxlist;\n\t\t\t}\n\n\t\t\t// When there are postponed prefixes...\n\t\t\tif (spin->si_prefroot != NULL\n\t\t\t\t&& spin->si_prefroot->wn_sibling != NULL)\n\t\t\t{\n\t\t\t    // ... add a flag to indicate an affix was used.\n\t\t\t    use_flags |= WF_HAS_AFF;\n\n\t\t\t    // ... don't use a prefix list if combining\n\t\t\t    // affixes is not allowed.  But do use the\n\t\t\t    // compound flags after them.\n\t\t\t    if (!ah->ah_combine && use_pfxlist != NULL)\n\t\t\t\tuse_pfxlist += use_pfxlen;\n\t\t\t}\n\n\t\t\t// When compounding is supported and there is no\n\t\t\t// \"COMPOUNDPERMITFLAG\" then forbid compounding on the\n\t\t\t// side where the affix is applied.\n\t\t\tif (spin->si_compflags != NULL && !ae->ae_comppermit)\n\t\t\t{\n\t\t\t    if (xht != NULL)\n\t\t\t\tuse_flags |= WF_NOCOMPAFT;\n\t\t\t    else\n\t\t\t\tuse_flags |= WF_NOCOMPBEF;\n\t\t\t}\n\n\t\t\t// Store the modified word.\n\t\t\tif (store_word(spin, newword, use_flags,\n\t\t\t\t\t\t spin->si_region, use_pfxlist,\n\t\t\t\t\t\t\t  need_affix) == FAIL)\n\t\t\t    retval = FAIL;\n\n\t\t\t// When added a prefix or a first suffix and the affix\n\t\t\t// has flags may add a(nother) suffix.  RECURSIVE!\n\t\t\tif ((condit & CONDIT_SUF) && ae->ae_flags != NULL)\n\t\t\t    if (store_aff_word(spin, newword, ae->ae_flags,\n\t\t\t\t\taffile, &affile->af_suff, xht,\n\t\t\t\t\t   use_condit & (xht == NULL\n\t\t\t\t\t\t\t? ~0 :  ~CONDIT_SUF),\n\t\t\t\t      use_flags, use_pfxlist, pfxlen) == FAIL)\n\t\t\t\tretval = FAIL;\n\n\t\t\t// When added a suffix and combining is allowed also\n\t\t\t// try adding a prefix additionally.  Both for the\n\t\t\t// word flags and for the affix flags.  RECURSIVE!\n\t\t\tif (xht != NULL && ah->ah_combine)\n\t\t\t{\n\t\t\t    if (store_aff_word(spin, newword,\n\t\t\t\t\tafflist, affile,\n\t\t\t\t\txht, NULL, use_condit,\n\t\t\t\t\tuse_flags, use_pfxlist,\n\t\t\t\t\tpfxlen) == FAIL\n\t\t\t\t    || (ae->ae_flags != NULL\n\t\t\t\t\t&& store_aff_word(spin, newword,\n\t\t\t\t\t    ae->ae_flags, affile,\n\t\t\t\t\t    xht, NULL, use_condit,\n\t\t\t\t\t    use_flags, use_pfxlist,\n\t\t\t\t\t    pfxlen) == FAIL))\n\t\t\t\tretval = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a file with a list of words.\n */\n    static int\nspell_read_wordfile(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    long\tlnum = 0;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tretval = OK;\n    int\t\tdid_word = FALSE;\n    int\t\tnon_ascii = 0;\n    int\t\tflags;\n    int\t\tregionmask;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading word file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Remove CR, LF and white space from the end.\n\tl = (int)STRLEN(rline);\n\twhile (l > 0 && rline[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty or blank line\n\trline[l] = NUL;\n\n\t// Convert from \"/encoding={encoding}\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %ld: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\tif (*line == '/')\n\t{\n\t    ++line;\n\t    if (STRNCMP(line, \"encoding=\", 9) == 0)\n\t    {\n\t\tif (spin->si_conv.vc_type != CONV_NONE)\n\t\t    smsg(_(\"Duplicate /encoding= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse if (did_word)\n\t\t    smsg(_(\"/encoding= line after word ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse\n\t\t{\n\t\t    char_u\t*enc;\n\n\t\t    // Setup for conversion to 'encoding'.\n\t\t    line += 9;\n\t\t    enc = enc_canonize(line);\n\t\t    if (enc != NULL && !spin->si_ascii\n\t\t\t    && convert_setup(&spin->si_conv, enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t\tsmsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t\t\t  fname, line, p_enc);\n\t\t    vim_free(enc);\n\t\t    spin->si_conv.vc_fail = TRUE;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (STRNCMP(line, \"regions=\", 8) == 0)\n\t    {\n\t\tif (spin->si_region_count > 1)\n\t\t    smsg(_(\"Duplicate /regions= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\telse\n\t\t{\n\t\t    line += 8;\n\t\t    if (STRLEN(line) > MAXREGIONS * 2)\n\t\t\tsmsg(_(\"Too many regions in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\t    else\n\t\t    {\n\t\t\tspin->si_region_count = (int)STRLEN(line) / 2;\n\t\t\tSTRCPY(spin->si_region_name, line);\n\n\t\t\t// Adjust the mask for a word valid in all regions.\n\t\t\tspin->si_region = (1 << spin->si_region_count) - 1;\n\t\t    }\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    smsg(_(\"/ line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t    continue;\n\t}\n\n\tflags = 0;\n\tregionmask = spin->si_region;\n\n\t// Check for flags and region after a slash.\n\tp = vim_strchr(line, '/');\n\tif (p != NULL)\n\t{\n\t    *p++ = NUL;\n\t    while (*p != NUL)\n\t    {\n\t\tif (*p == '=')\t\t// keep-case word\n\t\t    flags |= WF_KEEPCAP | WF_FIXCAP;\n\t\telse if (*p == '!')\t// Bad, bad, wicked word.\n\t\t    flags |= WF_BANNED;\n\t\telse if (*p == '?')\t// Rare word.\n\t\t    flags |= WF_RARE;\n\t\telse if (VIM_ISDIGIT(*p)) // region number(s)\n\t\t{\n\t\t    if ((flags & WF_REGION) == 0)   // first one\n\t\t\tregionmask = 0;\n\t\t    flags |= WF_REGION;\n\n\t\t    l = *p - '0';\n\t\t    if (l == 0 || l > spin->si_region_count)\n\t\t    {\n\t\t\tsmsg(_(\"Invalid region nr in %s line %ld: %s\"),\n\t\t\t\t\t\t\t  fname, lnum, p);\n\t\t\tbreak;\n\t\t    }\n\t\t    regionmask |= 1 << (l - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    smsg(_(\"Unrecognized flags in %s line %ld: %s\"),\n\t\t\t\t\t\t\t      fname, lnum, p);\n\t\t    break;\n\t\t}\n\t\t++p;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(line))\n\t{\n\t    ++non_ascii;\n\t    continue;\n\t}\n\n\t// Normal word: store it.\n\tif (store_word(spin, line, flags, regionmask, NULL, FALSE) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    break;\n\t}\n\tdid_word = TRUE;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n\n    if (spin->si_ascii && non_ascii > 0)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t  _(\"Ignored %d words with non-ASCII characters\"), non_ascii);\n\tspell_message(spin, IObuff);\n    }\n\n    return retval;\n}\n\n/*\n * Get part of an sblock_T, \"len\" bytes long.\n * This avoids calling free() for every little struct we use (and keeping\n * track of them).\n * The memory is cleared to all zeros.\n * Returns NULL when out of memory.\n */\n    static void *\ngetroom(\n    spellinfo_T *spin,\n    size_t\tlen,\t\t// length needed\n    int\t\talign)\t\t// align for pointer\n{\n    char_u\t*p;\n    sblock_T\t*bl = spin->si_blocks;\n\n    if (align && bl != NULL)\n\t// Round size up for alignment.  On some systems structures need to be\n\t// aligned to the size of a pointer (e.g., SPARC).\n\tbl->sb_used = (bl->sb_used + sizeof(char *) - 1)\n\t\t\t\t\t\t      & ~(sizeof(char *) - 1);\n\n    if (bl == NULL || bl->sb_used + len > SBLOCKSIZE)\n    {\n\tif (len >= SBLOCKSIZE)\n\t    bl = NULL;\n\telse\n\t    // Allocate a block of memory. It is not freed until much later.\n\t    bl = alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);\n\tif (bl == NULL)\n\t{\n\t    if (!spin->si_did_emsg)\n\t    {\n\t\temsg(_(e_insufficient_memory_word_list_will_be_incomplete));\n\t\tspin->si_did_emsg = TRUE;\n\t    }\n\t    return NULL;\n\t}\n\tbl->sb_next = spin->si_blocks;\n\tspin->si_blocks = bl;\n\tbl->sb_used = 0;\n\t++spin->si_blocks_cnt;\n    }\n\n    p = bl->sb_data + bl->sb_used;\n    bl->sb_used += (int)len;\n\n    return p;\n}\n\n/*\n * Make a copy of a string into memory allocated with getroom().\n * Returns NULL when out of memory.\n */\n    static char_u *\ngetroom_save(spellinfo_T *spin, char_u *s)\n{\n    char_u\t*sc;\n\n    sc = (char_u *)getroom(spin, STRLEN(s) + 1, FALSE);\n    if (sc != NULL)\n\tSTRCPY(sc, s);\n    return sc;\n}\n\n\n/*\n * Free the list of allocated sblock_T.\n */\n    static void\nfree_blocks(sblock_T *bl)\n{\n    sblock_T\t*next;\n\n    while (bl != NULL)\n    {\n\tnext = bl->sb_next;\n\tvim_free(bl);\n\tbl = next;\n    }\n}\n\n/*\n * Allocate the root of a word tree.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nwordtree_alloc(spellinfo_T *spin)\n{\n    return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n}\n\n/*\n * Store a word in the tree(s).\n * Always store it in the case-folded tree.  For a keep-case word this is\n * useful when the word can also be used with all caps (no WF_FIXCAP flag) and\n * used to find suggestions.\n * For a keep-case word also store it in the keep-case tree.\n * When \"pfxlist\" is not NULL store the word for each postponed prefix ID and\n * compound flag.\n */\n    static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}\n\n/*\n * Add word \"word\" to a word tree at \"root\".\n * When \"flags\" < 0 we are adding to the prefix tree where \"flags\" is used for\n * \"rare\" and \"region\" is the condition nr.\n * Returns FAIL when out of memory.\n */\n    static int\ntree_add_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    wordnode_T\t*root,\n    int\t\tflags,\n    int\t\tregion,\n    int\t\taffixID)\n{\n    wordnode_T\t*node = root;\n    wordnode_T\t*np;\n    wordnode_T\t*copyp, **copyprev;\n    wordnode_T\t**prev = NULL;\n    int\t\ti;\n\n    // Add each byte of the word to the tree, including the NUL at the end.\n    for (i = 0; ; ++i)\n    {\n\t// When there is more than one reference to this node we need to make\n\t// a copy, so that we can modify it.  Copy the whole list of siblings\n\t// (we don't optimize for a partly shared list of siblings).\n\tif (node != NULL && node->wn_refs > 1)\n\t{\n\t    --node->wn_refs;\n\t    copyprev = prev;\n\t    FOR_ALL_NODE_SIBLINGS(node, copyp)\n\t    {\n\t\t// Allocate a new node and copy the info.\n\t\tnp = get_wordnode(spin);\n\t\tif (np == NULL)\n\t\t    return FAIL;\n\t\tnp->wn_child = copyp->wn_child;\n\t\tif (np->wn_child != NULL)\n\t\t    ++np->wn_child->wn_refs;\t// child gets extra ref\n\t\tnp->wn_byte = copyp->wn_byte;\n\t\tif (np->wn_byte == NUL)\n\t\t{\n\t\t    np->wn_flags = copyp->wn_flags;\n\t\t    np->wn_region = copyp->wn_region;\n\t\t    np->wn_affixID = copyp->wn_affixID;\n\t\t}\n\n\t\t// Link the new node in the list, there will be one ref.\n\t\tnp->wn_refs = 1;\n\t\tif (copyprev != NULL)\n\t\t    *copyprev = np;\n\t\tcopyprev = &np->wn_sibling;\n\n\t\t// Let \"node\" point to the head of the copied list.\n\t\tif (copyp == node)\n\t\t    node = np;\n\t    }\n\t}\n\n\t// Look for the sibling that has the same character.  They are sorted\n\t// on byte value, thus stop searching when a sibling is found with a\n\t// higher byte value.  For zero bytes (end of word) the sorting is\n\t// done on flags and then on affixID.\n\twhile (node != NULL\n\t\t&& (node->wn_byte < word[i]\n\t\t    || (node->wn_byte == NUL\n\t\t\t&& (flags < 0\n\t\t\t    ? node->wn_affixID < (unsigned)affixID\n\t\t\t    : (node->wn_flags < (unsigned)(flags & WN_MASK)\n\t\t\t\t|| (node->wn_flags == (flags & WN_MASK)\n\t\t\t\t    && (spin->si_sugtree\n\t\t\t\t\t? (node->wn_region & 0xffff) < region\n\t\t\t\t\t: node->wn_affixID\n\t\t\t\t\t\t    < (unsigned)affixID)))))))\n\t{\n\t    prev = &node->wn_sibling;\n\t    node = *prev;\n\t}\n\tif (node == NULL\n\t\t|| node->wn_byte != word[i]\n\t\t|| (word[i] == NUL\n\t\t    && (flags < 0\n\t\t\t|| spin->si_sugtree\n\t\t\t|| node->wn_flags != (flags & WN_MASK)\n\t\t\t|| node->wn_affixID != affixID)))\n\t{\n\t    // Allocate a new node.\n\t    np = get_wordnode(spin);\n\t    if (np == NULL)\n\t\treturn FAIL;\n\t    np->wn_byte = word[i];\n\n\t    // If \"node\" is NULL this is a new child or the end of the sibling\n\t    // list: ref count is one.  Otherwise use ref count of sibling and\n\t    // make ref count of sibling one (matters when inserting in front\n\t    // of the list of siblings).\n\t    if (node == NULL)\n\t\tnp->wn_refs = 1;\n\t    else\n\t    {\n\t\tnp->wn_refs = node->wn_refs;\n\t\tnode->wn_refs = 1;\n\t    }\n\t    if (prev != NULL)\n\t\t*prev = np;\n\t    np->wn_sibling = node;\n\t    node = np;\n\t}\n\n\tif (word[i] == NUL)\n\t{\n\t    node->wn_flags = flags;\n\t    node->wn_region |= region;\n\t    node->wn_affixID = affixID;\n\t    break;\n\t}\n\tprev = &node->wn_child;\n\tnode = *prev;\n    }\n#ifdef SPELL_PRINTTREE\n    smsg(\"Added \\\"%s\\\"\", word);\n    spell_print_tree(root->wn_sibling);\n#endif\n\n    // count nr of words added since last message\n    ++spin->si_msg_count;\n\n    if (spin->si_compress_cnt > 1)\n    {\n\tif (--spin->si_compress_cnt == 1)\n\t    // Did enough words to lower the block count limit.\n\t    spin->si_blocks_cnt += compress_inc;\n    }\n\n    /*\n     * When we have allocated lots of memory we need to compress the word tree\n     * to free up some room.  But compression is slow, and we might actually\n     * need that room, thus only compress in the following situations:\n     * 1. When not compressed before (si_compress_cnt == 0): when using\n     *    \"compress_start\" blocks.\n     * 2. When compressed before and used \"compress_inc\" blocks before\n     *    adding \"compress_added\" words (si_compress_cnt > 1).\n     * 3. When compressed before, added \"compress_added\" words\n     *    (si_compress_cnt == 1) and the number of free nodes drops below the\n     *    maximum word length.\n     */\n#ifndef SPELL_COMPRESS_ALLWAYS\n    if (spin->si_compress_cnt == 1\n\t    ? spin->si_free_count < MAXWLEN\n\t    : spin->si_blocks_cnt >= compress_start)\n#endif\n    {\n\t// Decrement the block counter.  The effect is that we compress again\n\t// when the freed up room has been used and another \"compress_inc\"\n\t// blocks have been allocated.  Unless \"compress_added\" words have\n\t// been added, then the limit is put back again.\n\tspin->si_blocks_cnt -= compress_inc;\n\tspin->si_compress_cnt = compress_added;\n\n\tif (spin->si_verbose)\n\t{\n\t    msg_start();\n\t    msg_puts(_(msg_compressing));\n\t    msg_clr_eos();\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    out_flush();\n\t}\n\n\t// Compress both trees.  Either they both have many nodes, which makes\n\t// compression useful, or one of them is small, which means\n\t// compression goes fast.  But when filling the soundfold word tree\n\t// there is no keep-case tree.\n\twordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\tif (affixID >= 0)\n\t    wordtree_compress(spin, spin->si_keeproot, \"keep-case\");\n    }\n\n    return OK;\n}\n\n/*\n * Get a wordnode_T, either from the list of previously freed nodes or\n * allocate a new one.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nget_wordnode(spellinfo_T *spin)\n{\n    wordnode_T *n;\n\n    if (spin->si_first_free == NULL)\n\tn = (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n    else\n    {\n\tn = spin->si_first_free;\n\tspin->si_first_free = n->wn_child;\n\tCLEAR_POINTER(n);\n\t--spin->si_free_count;\n    }\n#ifdef SPELL_PRINTTREE\n    if (n != NULL)\n\tn->wn_nr = ++spin->si_wordnode_nr;\n#endif\n    return n;\n}\n\n/*\n * Decrement the reference count on a node (which is the head of a list of\n * siblings).  If the reference count becomes zero free the node and its\n * siblings.\n * Returns the number of nodes actually freed.\n */\n    static int\nderef_wordnode(spellinfo_T *spin, wordnode_T *node)\n{\n    wordnode_T\t*np;\n    int\t\tcnt = 0;\n\n    if (--node->wn_refs == 0)\n    {\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    if (np->wn_child != NULL)\n\t\tcnt += deref_wordnode(spin, np->wn_child);\n\t    free_wordnode(spin, np);\n\t    ++cnt;\n\t}\n\t++cnt;\t    // length field\n    }\n    return cnt;\n}\n\n/*\n * Free a wordnode_T for re-use later.\n * Only the \"wn_child\" field becomes invalid.\n */\n    static void\nfree_wordnode(spellinfo_T *spin, wordnode_T *n)\n{\n    n->wn_child = spin->si_first_free;\n    spin->si_first_free = n;\n    ++spin->si_free_count;\n}\n\n/*\n * Compress a tree: find tails that are identical and can be shared.\n */\n    static void\nwordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name)\n{\n    hashtab_T\t    ht;\n    long\t    n;\n    long\t    tot = 0;\n    long\t    perc;\n\n    // Skip the root itself, it's not actually used.  The first sibling is the\n    // start of the tree.\n    if (root->wn_sibling != NULL)\n    {\n\thash_init(&ht);\n\tn = node_compress(spin, root->wn_sibling, &ht, &tot);\n\n#ifndef SPELL_PRINTTREE\n\tif (spin->si_verbose || p_verbose > 2)\n#endif\n\t{\n\t    if (tot > 1000000)\n\t\tperc = (tot - n) / (tot / 100);\n\t    else if (tot == 0)\n\t\tperc = 0;\n\t    else\n\t\tperc = (tot - n) * 100 / tot;\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t       _(\"Compressed %s: %ld of %ld nodes; %ld (%ld%%) remaining\"),\n\t\t\t\t\t\t       name, n, tot, tot - n, perc);\n\t    spell_message(spin, IObuff);\n\t}\n#ifdef SPELL_PRINTTREE\n\tspell_print_tree(root->wn_sibling);\n#endif\n\thash_clear(&ht);\n    }\n}\n\n/*\n * Compress a node, its siblings and its children, depth first.\n * Returns the number of compressed nodes.\n */\n    static long\nnode_compress(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    hashtab_T\t*ht,\n    long\t*tot)\t    // total count of nodes before compressing,\n\t\t\t    // incremented while going through the tree\n{\n    wordnode_T\t*np;\n    wordnode_T\t*tp;\n    wordnode_T\t*child;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    long\tlen = 0;\n    unsigned\tnr, n;\n    long\tcompressed = 0;\n\n    /*\n     * Go through the list of siblings.  Compress each child and then try\n     * finding an identical child to replace it.\n     * Note that with \"child\" we mean not just the node that is pointed to,\n     * but the whole list of siblings of which the child node is the first.\n     */\n    for (np = node; np != NULL && !got_int; np = np->wn_sibling)\n    {\n\t++len;\n\tif ((child = np->wn_child) != NULL)\n\t{\n\t    // Compress the child first.  This fills hashkey.\n\t    compressed += node_compress(spin, child, ht, tot);\n\n\t    // Try to find an identical child.\n\t    hash = hash_hash(child->wn_u1.hashkey);\n\t    hi = hash_lookup(ht, child->wn_u1.hashkey, hash);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// There are children we encountered before with a hash value\n\t\t// identical to the current child.  Now check if there is one\n\t\t// that is really identical.\n\t\tfor (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)\n\t\t    if (node_equal(child, tp))\n\t\t    {\n\t\t\t// Found one!  Now use that child in place of the\n\t\t\t// current one.  This means the current child and all\n\t\t\t// its siblings is unlinked from the tree.\n\t\t\t++tp->wn_refs;\n\t\t\tcompressed += deref_wordnode(spin, child);\n\t\t\tnp->wn_child = tp;\n\t\t\tbreak;\n\t\t    }\n\t\tif (tp == NULL)\n\t\t{\n\t\t    // No other child with this hash value equals the child of\n\t\t    // the node, add it to the linked list after the first\n\t\t    // item.\n\t\t    tp = HI2WN(hi);\n\t\t    child->wn_u2.next = tp->wn_u2.next;\n\t\t    tp->wn_u2.next = child;\n\t\t}\n\t    }\n\t    else\n\t\t// No other child has this hash value, add it to the\n\t\t// hashtable.\n\t\thash_add_item(ht, hi, child->wn_u1.hashkey, hash);\n\t}\n    }\n    *tot += len + 1;\t// add one for the node that stores the length\n\n    /*\n     * Make a hash key for the node and its siblings, so that we can quickly\n     * find a lookalike node.  This must be done after compressing the sibling\n     * list, otherwise the hash key would become invalid by the compression.\n     */\n    node->wn_u1.hashkey[0] = len;\n    nr = 0;\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == NUL)\n\t    // end node: use wn_flags, wn_region and wn_affixID\n\t    n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);\n\telse\n\t    // byte node: use the byte value and the child pointer\n\t    n = (unsigned)(np->wn_byte + ((long_u)np->wn_child << 8));\n\tnr = nr * 101 + n;\n    }\n\n    // Avoid NUL bytes, it terminates the hash key.\n    n = nr & 0xff;\n    node->wn_u1.hashkey[1] = n == 0 ? 1 : n;\n    n = (nr >> 8) & 0xff;\n    node->wn_u1.hashkey[2] = n == 0 ? 1 : n;\n    n = (nr >> 16) & 0xff;\n    node->wn_u1.hashkey[3] = n == 0 ? 1 : n;\n    n = (nr >> 24) & 0xff;\n    node->wn_u1.hashkey[4] = n == 0 ? 1 : n;\n    node->wn_u1.hashkey[5] = NUL;\n\n    // Check for CTRL-C pressed now and then.\n    veryfast_breakcheck();\n\n    return compressed;\n}\n\n/*\n * Return TRUE when two nodes have identical siblings and children.\n */\n    static int\nnode_equal(wordnode_T *n1, wordnode_T *n2)\n{\n    wordnode_T\t*p1;\n    wordnode_T\t*p2;\n\n    for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;\n\t\t\t\t     p1 = p1->wn_sibling, p2 = p2->wn_sibling)\n\tif (p1->wn_byte != p2->wn_byte\n\t\t|| (p1->wn_byte == NUL\n\t\t    ? (p1->wn_flags != p2->wn_flags\n\t\t\t|| p1->wn_region != p2->wn_region\n\t\t\t|| p1->wn_affixID != p2->wn_affixID)\n\t\t    : (p1->wn_child != p2->wn_child)))\n\t    break;\n\n    return p1 == NULL && p2 == NULL;\n}\n\nstatic int rep_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the REP items on \"from\" string.\n */\n    static int\nrep_compare(const void *s1, const void *s2)\n{\n    fromto_T\t*p1 = (fromto_T *)s1;\n    fromto_T\t*p2 = (fromto_T *)s2;\n\n    return STRCMP(p1->ft_from, p2->ft_from);\n}\n\n/*\n * Write the Vim .spl file \"fname\".\n * Return FAIL or OK;\n */\n    static int\nwrite_vim_spell(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    int\t\tregionmask;\n    int\t\tround;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\ti;\n    int\t\tl;\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    char_u\t*p;\n    int\t\trr;\n    int\t\tretval = OK;\n    size_t\tfwv = 1;  // collect return value of fwrite() to avoid\n\t\t\t  // warnings from picky compiler\n\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // <HEADER>: <fileID> <versionnr>\n\t\t\t\t\t\t\t    // <fileID>\n    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);\n    if (fwv != (size_t)1)\n\t// Catch first write error, don't try writing more.\n\tgoto theend;\n\n    putc(VIMSPELLVERSION, fd);\t\t\t\t    // <versionnr>\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     */\n\n    // SN_INFO: <infotext>\n    if (spin->si_info != NULL)\n    {\n\tputc(SN_INFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_info);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); // <infotext>\n    }\n\n    // SN_REGION: <regionname> ...\n    // Write the region names only if there is more than one.\n    if (spin->si_region_count > 1)\n    {\n\tputc(SN_REGION, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\tl = spin->si_region_count * 2;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <regionname> ...\n\tregionmask = (1 << spin->si_region_count) - 1;\n    }\n    else\n\tregionmask = 0;\n\n    // SN_CHARFLAGS: <charflagslen> <charflags> <folcharslen> <folchars>\n    //\n    // The table with character flags and the table for case folding.\n    // This makes sure the same characters are recognized as word characters\n    // when generating and when using a spell file.\n    // Skip this for ASCII, the table may conflict with the one used for\n    // 'encoding'.\n    // Also skip this for an .add.spl file, the main spell file must contain\n    // the table (avoids that it conflicts).  File is shorter too.\n    if (!spin->si_ascii && !spin->si_add)\n    {\n\tchar_u\tfolchars[128 * 8];\n\tint\tflags;\n\n\tputc(SN_CHARFLAGS, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\t// Form the <folchars> string first, we need to know its length.\n\tl = 0;\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tl += mb_char2bytes(spelltab.st_fold[i], folchars + l);\n\t    else\n\t\tfolchars[l++] = spelltab.st_fold[i];\n\t}\n\tput_bytes(fd, (long_u)(1 + 128 + 2 + l), 4);\t// <sectionlen>\n\n\tfputc(128, fd);\t\t\t\t\t// <charflagslen>\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    flags = 0;\n\t    if (spelltab.st_isw[i])\n\t\tflags |= CF_WORD;\n\t    if (spelltab.st_isu[i])\n\t\tflags |= CF_UPPER;\n\t    fputc(flags, fd);\t\t\t\t// <charflags>\n\t}\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <folcharslen>\n\tfwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); // <folchars>\n    }\n\n    // SN_MIDWORD: <midword>\n    if (spin->si_midword != NULL)\n    {\n\tputc(SN_MIDWORD, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_midword);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);\n\t\t\t\t\t\t\t// <midword>\n    }\n\n    // SN_PREFCOND: <prefcondcnt> <prefcond> ...\n    if (spin->si_prefcond.ga_len > 0)\n    {\n\tputc(SN_PREFCOND, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\tl = write_spell_prefcond(NULL, &spin->si_prefcond, &fwv);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\twrite_spell_prefcond(fd, &spin->si_prefcond, &fwv);\n    }\n\n    // SN_REP: <repcount> <rep> ...\n    // SN_SAL: <salflags> <salcount> <sal> ...\n    // SN_REPSAL: <repcount> <rep> ...\n\n    // round 1: SN_REP section\n    // round 2: SN_SAL section (unless SN_SOFO is used)\n    // round 3: SN_REPSAL section\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    gap = &spin->si_rep;\n\telse if (round == 2)\n\t{\n\t    // Don't write SN_SAL when using a SN_SOFO section\n\t    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n\t\tcontinue;\n\t    gap = &spin->si_sal;\n\t}\n\telse\n\t    gap = &spin->si_repsal;\n\n\t// Don't write the section if there are no items.\n\tif (gap->ga_len == 0)\n\t    continue;\n\n\t// Sort the REP/REPSAL items.\n\tif (round != 2)\n\t    qsort(gap->ga_data, (size_t)gap->ga_len,\n\t\t\t\t\t       sizeof(fromto_T), rep_compare);\n\n\ti = round == 1 ? SN_REP : (round == 2 ? SN_SAL : SN_REPSAL);\n\tputc(i, fd);\t\t\t\t\t// <sectionID>\n\n\t// This is for making suggestions, section is not required.\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// Compute the length of what follows.\n\tl = 2;\t    // count <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    l += 1 + (int)STRLEN(ftp->ft_from);  // count <*fromlen> and <*from>\n\t    l += 1 + (int)STRLEN(ftp->ft_to);    // count <*tolen> and <*to>\n\t}\n\tif (round == 2)\n\t    ++l;\t// count <salflags>\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\tif (round == 2)\n\t{\n\t    i = 0;\n\t    if (spin->si_followup)\n\t\ti |= SAL_F0LLOWUP;\n\t    if (spin->si_collapse)\n\t\ti |= SAL_COLLAPSE;\n\t    if (spin->si_rem_accents)\n\t\ti |= SAL_REM_ACCENTS;\n\t    putc(i, fd);\t\t\t// <salflags>\n\t}\n\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t// <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n\t    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    for (rr = 1; rr <= 2; ++rr)\n\t    {\n\t\tp = rr == 1 ? ftp->ft_from : ftp->ft_to;\n\t\tl = (int)STRLEN(p);\n\t\tputc(l, fd);\n\t\tif (l > 0)\n\t\t    fwv &= fwrite(p, l, (size_t)1, fd);\n\t    }\n\t}\n\n    }\n\n    // SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n    // This is for making suggestions, section is not required.\n    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n    {\n\tputc(SN_SOFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_sofofr);\n\tput_bytes(fd, (long_u)(l + STRLEN(spin->si_sofoto) + 4), 4);\n\t\t\t\t\t\t\t// <sectionlen>\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofofromlen>\n\tfwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); // <sofofrom>\n\n\tl = (int)STRLEN(spin->si_sofoto);\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofotolen>\n\tfwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); // <sofoto>\n    }\n\n    // SN_WORDS: <word> ...\n    // This is for making suggestions, section is not required.\n    if (spin->si_commonwords.ht_used > 0)\n    {\n\tputc(SN_WORDS, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// round 1: count the bytes\n\t// round 2: write the bytes\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    int\t\ttodo;\n\t    int\t\tlen = 0;\n\t    hashitem_T\t*hi;\n\n\t    todo = (int)spin->si_commonwords.ht_used;\n\t    for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    l = (int)STRLEN(hi->hi_key) + 1;\n\t\t    len += l;\n\t\t    if (round == 2)\t\t\t// <word>\n\t\t\tfwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);\n\t\t    --todo;\n\t\t}\n\t    if (round == 1)\n\t\tput_bytes(fd, (long_u)len, 4);\t\t// <sectionlen>\n\t}\n    }\n\n    // SN_MAP: <mapstr>\n    // This is for making suggestions, section is not required.\n    if (spin->si_map.ga_len > 0)\n    {\n\tputc(SN_MAP, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tl = spin->si_map.ga_len;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <mapstr>\n    }\n\n    // SN_SUGFILE: <timestamp>\n    // This is used to notify that a .sug file may be available and at the\n    // same time allows for checking that a .sug file that is found matches\n    // with this .spl file.  That's because the word numbers must be exactly\n    // right.\n    if (!spin->si_nosugfile\n\t    && (spin->si_sal.ga_len > 0\n\t\t     || (spin->si_sofofr != NULL && spin->si_sofoto != NULL)))\n    {\n\tputc(SN_SUGFILE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)8, 4);\t\t\t// <sectionlen>\n\n\t// Set si_sugtime and write it to the file.\n\tspin->si_sugtime = time(NULL);\n\tput_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n    }\n\n    // SN_NOSPLITSUGS: nothing\n    // This is used to notify that no suggestions with word splits are to be\n    // made.\n    if (spin->si_nosplitsugs)\n    {\n\tputc(SN_NOSPLITSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_NOCOMPUNDSUGS: nothing\n    // This is used to notify that no suggestions with compounds are to be\n    // made.\n    if (spin->si_nocompoundsugs)\n    {\n\tputc(SN_NOCOMPOUNDSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_COMPOUND: compound info.\n    // We don't mark it required, when not supported all compound words will\n    // be bad words.\n    if (spin->si_compflags != NULL)\n    {\n\tputc(SN_COMPOUND, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_compflags);\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t    l += (int)STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;\n\tput_bytes(fd, (long_u)(l + 7), 4);\t\t// <sectionlen>\n\n\tputc(spin->si_compmax, fd);\t\t\t// <compmax>\n\tputc(spin->si_compminlen, fd);\t\t\t// <compminlen>\n\tputc(spin->si_compsylmax, fd);\t\t\t// <compsylmax>\n\tputc(0, fd);\t\t// for Vim 7.0b compatibility\n\tputc(spin->si_compoptions, fd);\t\t\t// <compoptions>\n\tput_bytes(fd, (long_u)spin->si_comppat.ga_len, 2);\n\t\t\t\t\t\t\t// <comppatcount>\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t{\n\t    p = ((char_u **)(spin->si_comppat.ga_data))[i];\n\t    putc((int)STRLEN(p), fd);\t\t\t// <comppatlen>\n\t    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);\n\t\t\t\t\t\t\t// <comppattext>\n\t}\n\t\t\t\t\t\t\t// <compflags>\n\tfwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),\n\t\t\t\t\t\t\t       (size_t)1, fd);\n    }\n\n    // SN_NOBREAK: NOBREAK flag\n    if (spin->si_nobreak)\n    {\n\tputc(SN_NOBREAK, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// It's empty, the presence of the section flags the feature.\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_SYLLABLE: syllable info.\n    // We don't mark it required, when not supported syllables will not be\n    // counted.\n    if (spin->si_syllable != NULL)\n    {\n\tputc(SN_SYLLABLE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_syllable);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <syllable>\n    }\n\n    // end of <SECTIONS>\n    putc(SN_END, fd);\t\t\t\t\t// <sectionend>\n\n\n    /*\n     * <LWORDTREE>  <KWORDTREE>  <PREFIXTREE>\n     */\n    spin->si_memtot = 0;\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    tree = spin->si_foldroot->wn_sibling;\n\telse if (round == 2)\n\t    tree = spin->si_keeproot->wn_sibling;\n\telse\n\t    tree = spin->si_prefroot->wn_sibling;\n\n\t// Clear the index and wnode fields in the tree.\n\tclear_node(tree);\n\n\t// Count the number of nodes.  Needed to be able to allocate the\n\t// memory when reading the nodes.  Also fills in index for shared\n\t// nodes.\n\tnodecount = put_node(NULL, tree, 0, regionmask, round == 3);\n\n\t// number of nodes in 4 bytes\n\tput_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n\tspin->si_memtot += nodecount + nodecount * sizeof(int);\n\n\t// Write the nodes.\n\t(void)put_node(fd, tree, 0, regionmask, round == 3);\n    }\n\n    // Write another byte to check for errors (file system full).\n    if (putc(0, fd) == EOF)\n\tretval = FAIL;\ntheend:\n    if (fclose(fd) == EOF)\n\tretval = FAIL;\n\n    if (fwv != (size_t)1)\n\tretval = FAIL;\n    if (retval == FAIL)\n\temsg(_(e_error_while_writing));\n\n    return retval;\n}\n\n/*\n * Clear the index and wnode fields of \"node\", it siblings and its\n * children.  This is needed because they are a union with other items to save\n * space.\n */\n    static void\nclear_node(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    if (node != NULL)\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    np->wn_u1.index = 0;\n\t    np->wn_u2.wnode = NULL;\n\n\t    if (np->wn_byte != NUL)\n\t\tclear_node(np->wn_child);\n\t}\n}\n\n\n/*\n * Dump a word tree at node \"node\".\n *\n * This first writes the list of possible bytes (siblings).  Then for each\n * byte recursively write the children.\n *\n * NOTE: The code here must match the code in read_tree_node(), since\n * assumptions are made about the indexes (so that we don't have to write them\n * in the file).\n *\n * Returns the number of nodes used.\n */\n    static int\nput_node(\n    FILE\t*fd,\t\t// NULL when only counting\n    wordnode_T\t*node,\n    int\t\tidx,\n    int\t\tregionmask,\n    int\t\tprefixtree)\t// TRUE for PREFIXTREE\n{\n    int\t\tnewindex = idx;\n    int\t\tsiblingcount = 0;\n    wordnode_T\t*np;\n    int\t\tflags;\n\n    // If \"node\" is zero the tree is empty.\n    if (node == NULL)\n\treturn 0;\n\n    // Store the index where this node is written.\n    node->wn_u1.index = idx;\n\n    // Count the number of siblings.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\t++siblingcount;\n\n    // Write the sibling count.\n    if (fd != NULL)\n\tputc(siblingcount, fd);\t\t\t\t// <siblingcount>\n\n    // Write each sibling byte and optionally extra info.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == 0)\n\t{\n\t    if (fd != NULL)\n\t    {\n\t\t// For a NUL byte (end of word) write the flags etc.\n\t\tif (prefixtree)\n\t\t{\n\t\t    // In PREFIXTREE write the required affixID and the\n\t\t    // associated condition nr (stored in wn_region).  The\n\t\t    // byte value is misused to store the \"rare\" and \"not\n\t\t    // combining\" flags\n\t\t    if (np->wn_flags == (short_u)PFX_FLAGS)\n\t\t\tputc(BY_NOFLAGS, fd);\t\t// <byte>\n\t\t    else\n\t\t    {\n\t\t\tputc(BY_FLAGS, fd);\t\t// <byte>\n\t\t\tputc(np->wn_flags, fd);\t\t// <pflags>\n\t\t    }\n\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    put_bytes(fd, (long_u)np->wn_region, 2); // <prefcondnr>\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For word trees we write the flag/region items.\n\t\t    flags = np->wn_flags;\n\t\t    if (regionmask != 0 && np->wn_region != regionmask)\n\t\t\tflags |= WF_REGION;\n\t\t    if (np->wn_affixID != 0)\n\t\t\tflags |= WF_AFX;\n\t\t    if (flags == 0)\n\t\t    {\n\t\t\t// word without flags or region\n\t\t\tputc(BY_NOFLAGS, fd);\t\t\t// <byte>\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (np->wn_flags >= 0x100)\n\t\t\t{\n\t\t\t    putc(BY_FLAGS2, fd);\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t    putc((unsigned)flags >> 8, fd);\t// <flags2>\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    putc(BY_FLAGS, fd);\t\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t}\n\t\t\tif (flags & WF_REGION)\n\t\t\t    putc(np->wn_region, fd);\t\t// <region>\n\t\t\tif (flags & WF_AFX)\n\t\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if (np->wn_child->wn_u1.index != 0\n\t\t\t\t\t && np->wn_child->wn_u2.wnode != node)\n\t    {\n\t\t// The child is written elsewhere, write the reference.\n\t\tif (fd != NULL)\n\t\t{\n\t\t    putc(BY_INDEX, fd);\t\t\t// <byte>\n\t\t\t\t\t\t\t// <nodeidx>\n\t\t    put_bytes(fd, (long_u)np->wn_child->wn_u1.index, 3);\n\t\t}\n\t    }\n\t    else if (np->wn_child->wn_u2.wnode == NULL)\n\t\t// We will write the child below and give it an index.\n\t\tnp->wn_child->wn_u2.wnode = node;\n\n\t    if (fd != NULL)\n\t\tif (putc(np->wn_byte, fd) == EOF) // <byte> or <xbyte>\n\t\t{\n\t\t    emsg(_(e_error_while_writing));\n\t\t    return 0;\n\t\t}\n\t}\n    }\n\n    // Space used in the array when reading: one for each sibling and one for\n    // the count.\n    newindex += siblingcount + 1;\n\n    // Recursively dump the children of each sibling.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\tif (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)\n\t    newindex = put_node(fd, np->wn_child, newindex, regionmask,\n\t\t\t\t\t\t\t\t  prefixtree);\n\n    return newindex;\n}\n\n\n/*\n * \":mkspell [-ascii] outfile  infile ...\"\n * \":mkspell [-ascii] addfile\"\n */\n    void\nex_mkspell(exarg_T *eap)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    char_u\t*arg = eap->arg;\n    int\t\tascii = FALSE;\n\n    if (STRNCMP(arg, \"-ascii\", 6) == 0)\n    {\n\tascii = TRUE;\n\targ = skipwhite(arg + 6);\n    }\n\n    // Expand all the remaining arguments (e.g., $VIMRUNTIME).\n    if (get_arglist_exp(arg, &fcount, &fnames, FALSE) == OK)\n    {\n\tmkspell(fcount, fnames, ascii, eap->forceit, FALSE);\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Create the .sug file.\n * Uses the soundfold info in \"spin\".\n * Writes the file with the name \"wfname\", with \".spl\" changed to \".sug\".\n */\n    static void\nspell_make_sugfile(spellinfo_T *spin, char_u *wfname)\n{\n    char_u\t*fname = NULL;\n    int\t\tlen;\n    slang_T\t*slang;\n    int\t\tfree_slang = FALSE;\n\n    /*\n     * Read back the .spl file that was written.  This fills the required\n     * info for soundfolding.  This also uses less memory than the\n     * pointer-linked version of the trie.  And it avoids having two versions\n     * of the code for the soundfolding stuff.\n     * It might have been done already by spell_reload_one().\n     */\n    FOR_ALL_SPELL_LANGS(slang)\n\tif (fullpathcmp(wfname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t    break;\n    if (slang == NULL)\n    {\n\tspell_message(spin, (char_u *)_(\"Reading back spell file...\"));\n\tslang = spell_load_file(wfname, NULL, NULL, FALSE);\n\tif (slang == NULL)\n\t    return;\n\tfree_slang = TRUE;\n    }\n\n    /*\n     * Clear the info in \"spin\" that is used.\n     */\n    spin->si_blocks = NULL;\n    spin->si_blocks_cnt = 0;\n    spin->si_compress_cnt = 0;\t    // will stay at 0 all the time\n    spin->si_free_count = 0;\n    spin->si_first_free = NULL;\n    spin->si_foldwcount = 0;\n\n    /*\n     * Go through the trie of good words, soundfold each word and add it to\n     * the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));\n    if (sug_filltree(spin, slang) == FAIL)\n\tgoto theend;\n\n    /*\n     * Create the table which links each soundfold word with a list of the\n     * good words it may come from.  Creates buffer \"spin->si_spellbuf\".\n     * This also removes the wordnr from the NUL byte entries to make\n     * compression possible.\n     */\n    if (sug_maketable(spin) == FAIL)\n\tgoto theend;\n\n    smsg(_(\"Number of words after soundfolding: %ld\"),\n\t\t\t\t (long)spin->si_spellbuf->b_ml.ml_line_count);\n\n    /*\n     * Compress the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(msg_compressing));\n    wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\n    /*\n     * Write the .sug file.\n     * Make the file name by changing \".spl\" to \".sug\".\n     */\n    fname = alloc(MAXPATHL);\n    if (fname == NULL)\n\tgoto theend;\n    vim_strncpy(fname, wfname, MAXPATHL - 1);\n    len = (int)STRLEN(fname);\n    fname[len - 2] = 'u';\n    fname[len - 1] = 'g';\n    sug_write(spin, fname);\n\ntheend:\n    vim_free(fname);\n    if (free_slang)\n\tslang_free(slang);\n    free_blocks(spin->si_blocks);\n    close_spellbuf(spin->si_spellbuf);\n}\n\n/*\n * Build the soundfold trie for language \"slang\".\n */\n    static int\nsug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}\n\n/*\n * Make the table that links each word in the soundfold trie to the words it\n * can be produced from.\n * This is not unlike lines in a file, thus use a memfile to be able to access\n * the table efficiently.\n * Returns FAIL when out of memory.\n */\n    static int\nsug_maketable(spellinfo_T *spin)\n{\n    garray_T\tga;\n    int\t\tres = OK;\n\n    // Allocate a buffer, open a memline for it and create the swap file\n    // (uses a temp file, not a .swp file).\n    spin->si_spellbuf = open_spellbuf();\n    if (spin->si_spellbuf == NULL)\n\treturn FAIL;\n\n    // Use a buffer to store the line info, avoids allocating many small\n    // pieces of memory.\n    ga_init2(&ga, 1, 100);\n\n    // recursively go through the tree\n    if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)\n\tres = FAIL;\n\n    ga_clear(&ga);\n    return res;\n}\n\n/*\n * Fill the table for one node and its children.\n * Returns the wordnr at the start of the node.\n * Returns -1 when out of memory.\n */\n    static int\nsug_filltable(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    int\t\tstartwordnr,\n    garray_T\t*gap)\t    // place to store line of numbers\n{\n    wordnode_T\t*p, *np;\n    int\t\twordnr = startwordnr;\n    int\t\tnr;\n    int\t\tprev_nr;\n\n    FOR_ALL_NODE_SIBLINGS(node, p)\n    {\n\tif (p->wn_byte == NUL)\n\t{\n\t    gap->ga_len = 0;\n\t    prev_nr = 0;\n\t    for (np = p; np != NULL && np->wn_byte == NUL; np = np->wn_sibling)\n\t    {\n\t\tif (ga_grow(gap, 10) == FAIL)\n\t\t    return -1;\n\n\t\tnr = (np->wn_flags << 16) + (np->wn_region & 0xffff);\n\t\t// Compute the offset from the previous nr and store the\n\t\t// offset in a way that it takes a minimum number of bytes.\n\t\t// It's a bit like utf-8, but without the need to mark\n\t\t// following bytes.\n\t\tnr -= prev_nr;\n\t\tprev_nr += nr;\n\t\tgap->ga_len += offset2bytes(nr,\n\t\t\t\t\t (char_u *)gap->ga_data + gap->ga_len);\n\t    }\n\n\t    // add the NUL byte\n\t    ((char_u *)gap->ga_data)[gap->ga_len++] = NUL;\n\n\t    if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,\n\t\t\t\t     gap->ga_data, gap->ga_len, TRUE) == FAIL)\n\t\treturn -1;\n\t    ++wordnr;\n\n\t    // Remove extra NUL entries, we no longer need them. We don't\n\t    // bother freeing the nodes, they won't be reused anyway.\n\t    while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)\n\t\tp->wn_sibling = p->wn_sibling->wn_sibling;\n\n\t    // Clear the flags on the remaining NUL node, so that compression\n\t    // works a lot better.\n\t    p->wn_flags = 0;\n\t    p->wn_region = 0;\n\t}\n\telse\n\t{\n\t    wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);\n\t    if (wordnr == -1)\n\t\treturn -1;\n\t}\n    }\n    return wordnr;\n}\n\n/*\n * Convert an offset into a minimal number of bytes.\n * Similar to utf_char2byters, but use 8 bits in followup bytes and avoid NUL\n * bytes.\n */\n    static int\noffset2bytes(int nr, char_u *buf)\n{\n    int\t    rem;\n    int\t    b1, b2, b3, b4;\n\n    // Split the number in parts of base 255.  We need to avoid NUL bytes.\n    b1 = nr % 255 + 1;\n    rem = nr / 255;\n    b2 = rem % 255 + 1;\n    rem = rem / 255;\n    b3 = rem % 255 + 1;\n    b4 = rem / 255 + 1;\n\n    if (b4 > 1 || b3 > 0x1f)\t// 4 bytes\n    {\n\tbuf[0] = 0xe0 + b4;\n\tbuf[1] = b3;\n\tbuf[2] = b2;\n\tbuf[3] = b1;\n\treturn 4;\n    }\n    if (b3 > 1 || b2 > 0x3f )\t// 3 bytes\n    {\n\tbuf[0] = 0xc0 + b3;\n\tbuf[1] = b2;\n\tbuf[2] = b1;\n\treturn 3;\n    }\n    if (b2 > 1 || b1 > 0x7f )\t// 2 bytes\n    {\n\tbuf[0] = 0x80 + b2;\n\tbuf[1] = b1;\n\treturn 2;\n    }\n\t\t\t\t// 1 byte\n    buf[0] = b1;\n    return 1;\n}\n\n/*\n * Write the .sug file in \"fname\".\n */\n    static void\nsug_write(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\twcount;\n    char_u\t*line;\n    linenr_T\tlnum;\n    int\t\tlen;\n\n    // Create the file.  Note that an existing file is silently overwritten!\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Writing suggestion file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n     */\n    if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) // <fileID>\n    {\n\temsg(_(e_error_while_writing));\n\tgoto theend;\n    }\n    putc(VIMSUGVERSION, fd);\t\t\t\t// <versionnr>\n\n    // Write si_sugtime to the file.\n    put_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n\n    /*\n     * <SUGWORDTREE>\n     */\n    spin->si_memtot = 0;\n    tree = spin->si_foldroot->wn_sibling;\n\n    // Clear the index and wnode fields in the tree.\n    clear_node(tree);\n\n    // Count the number of nodes.  Needed to be able to allocate the\n    // memory when reading the nodes.  Also fills in index for shared\n    // nodes.\n    nodecount = put_node(NULL, tree, 0, 0, FALSE);\n\n    // number of nodes in 4 bytes\n    put_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n    spin->si_memtot += nodecount + nodecount * sizeof(int);\n\n    // Write the nodes.\n    (void)put_node(fd, tree, 0, 0, FALSE);\n\n    /*\n     * <SUGTABLE>: <sugwcount> <sugline> ...\n     */\n    wcount = spin->si_spellbuf->b_ml.ml_line_count;\n    put_bytes(fd, (long_u)wcount, 4);\t// <sugwcount>\n\n    for (lnum = 1; lnum <= (linenr_T)wcount; ++lnum)\n    {\n\t// <sugline>: <sugnr> ... NUL\n\tline = ml_get_buf(spin->si_spellbuf, lnum, FALSE);\n\tlen = (int)STRLEN(line) + 1;\n\tif (fwrite(line, (size_t)len, (size_t)1, fd) == 0)\n\t{\n\t    emsg(_(e_error_while_writing));\n\t    goto theend;\n\t}\n\tspin->si_memtot += len;\n    }\n\n    // Write another byte to check for errors.\n    if (putc(0, fd) == EOF)\n\temsg(_(e_error_while_writing));\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);\n    spell_message(spin, IObuff);\n\ntheend:\n    // close the file\n    fclose(fd);\n}\n\n\n/*\n * Create a Vim spell file from one or more word lists.\n * \"fnames[0]\" is the output file name.\n * \"fnames[fcount - 1]\" is the last input file name.\n * Exception: when \"fnames[0]\" ends in \".add\" it's used as the input file name\n * and \".spl\" is appended to make the output file name.\n */\n    void\nmkspell(\n    int\t\tfcount,\n    char_u\t**fnames,\n    int\t\tascii,\t\t    // -ascii argument given\n    int\t\tover_write,\t    // overwrite existing output file\n    int\t\tadded_word)\t    // invoked through \"zg\"\n{\n    char_u\t*fname = NULL;\n    char_u\t*wfname;\n    char_u\t**innames;\n    int\t\tincount;\n    afffile_T\t*(afile[MAXREGIONS]);\n    int\t\ti;\n    int\t\tlen;\n    stat_T\tst;\n    int\t\terror = FALSE;\n    spellinfo_T spin;\n\n    CLEAR_FIELD(spin);\n    spin.si_verbose = !added_word;\n    spin.si_ascii = ascii;\n    spin.si_followup = TRUE;\n    spin.si_rem_accents = TRUE;\n    ga_init2(&spin.si_rep, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_repsal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_sal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_map, sizeof(char_u), 100);\n    ga_init2(&spin.si_comppat, sizeof(char_u *), 20);\n    ga_init2(&spin.si_prefcond, sizeof(char_u *), 50);\n    hash_init(&spin.si_commonwords);\n    spin.si_newcompID = 127;\t// start compound ID at first maximum\n\n    // default: fnames[0] is output file, following are input files\n    // When \"fcount\" is 1 there is only one file.\n    innames = &fnames[fcount == 1 ? 0 : 1];\n    incount = fcount - 1;\n\n    wfname = alloc(MAXPATHL);\n    if (wfname == NULL)\n\treturn;\n\n    if (fcount >= 1)\n    {\n\tlen = (int)STRLEN(fnames[0]);\n\tif (fcount == 1 && len > 4 && STRCMP(fnames[0] + len - 4, \".add\") == 0)\n\t{\n\t    // For \":mkspell path/en.latin1.add\" output file is\n\t    // \"path/en.latin1.add.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, \"%s.spl\", fnames[0]);\n\t}\n\telse if (fcount == 1)\n\t{\n\t    // For \":mkspell path/vim\" output file is \"path/vim.latin1.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\t}\n\telse if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)\n\t{\n\t    // Name ends in \".spl\", use as the file name.\n\t    vim_strncpy(wfname, fnames[0], MAXPATHL - 1);\n\t}\n\telse\n\t    // Name should be language, make the file name from it.\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\n\t// Check for .ascii.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)\n\t    spin.si_ascii = TRUE;\n\n\t// Check for .add.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)\n\t    spin.si_add = TRUE;\n    }\n\n    if (incount <= 0)\n\temsg(_(e_invalid_argument));\t// need at least output and input names\n    else if (vim_strchr(gettail(wfname), '_') != NULL)\n\temsg(_(e_output_file_name_must_not_have_region_name));\n    else if (incount > MAXREGIONS)\n\tsemsg(_(e_only_up_to_nr_regions_supported), MAXREGIONS);\n    else\n    {\n\t// Check for overwriting before doing things that may take a lot of\n\t// time.\n\tif (!over_write && mch_stat((char *)wfname, &st) >= 0)\n\t{\n\t    emsg(_(e_file_exists));\n\t    goto theend;\n\t}\n\tif (mch_isdir(wfname))\n\t{\n\t    semsg(_(e_str_is_directory), wfname);\n\t    goto theend;\n\t}\n\n\tfname = alloc(MAXPATHL);\n\tif (fname == NULL)\n\t    goto theend;\n\n\t/*\n\t * Init the aff and dic pointers.\n\t * Get the region names if there are more than 2 arguments.\n\t */\n\tfor (i = 0; i < incount; ++i)\n\t{\n\t    afile[i] = NULL;\n\n\t    if (incount > 1)\n\t    {\n\t\tlen = (int)STRLEN(innames[i]);\n\t\tif (STRLEN(gettail(innames[i])) < 5\n\t\t\t\t\t\t|| innames[i][len - 3] != '_')\n\t\t{\n\t\t    semsg(_(e_invalid_region_in_str), innames[i]);\n\t\t    goto theend;\n\t\t}\n\t\tspin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);\n\t\tspin.si_region_name[i * 2 + 1] =\n\t\t\t\t\t     TOLOWER_ASC(innames[i][len - 1]);\n\t    }\n\t}\n\tspin.si_region_count = incount;\n\n\tspin.si_foldroot = wordtree_alloc(&spin);\n\tspin.si_keeproot = wordtree_alloc(&spin);\n\tspin.si_prefroot = wordtree_alloc(&spin);\n\tif (spin.si_foldroot == NULL\n\t\t|| spin.si_keeproot == NULL\n\t\t|| spin.si_prefroot == NULL)\n\t{\n\t    free_blocks(spin.si_blocks);\n\t    goto theend;\n\t}\n\n\t// When not producing a .add.spl file clear the character table when\n\t// we encounter one in the .aff file.  This means we dump the current\n\t// one in the .spl file if the .aff file doesn't define one.  That's\n\t// better than guessing the contents, the table will match a\n\t// previously loaded spell file.\n\tif (!spin.si_add)\n\t    spin.si_clear_chartab = TRUE;\n\n\t/*\n\t * Read all the .aff and .dic files.\n\t * Text is converted to 'encoding'.\n\t * Words are stored in the case-folded and keep-case trees.\n\t */\n\tfor (i = 0; i < incount && !error; ++i)\n\t{\n\t    spin.si_conv.vc_type = CONV_NONE;\n\t    spin.si_region = 1 << i;\n\n\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.aff\", innames[i]);\n\t    if (mch_stat((char *)fname, &st) >= 0)\n\t    {\n\t\t// Read the .aff file.  Will init \"spin->si_conv\" based on the\n\t\t// \"SET\" line.\n\t\tafile[i] = spell_read_aff(&spin, fname);\n\t\tif (afile[i] == NULL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // Read the .dic file and store the words in the trees.\n\t\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",\n\t\t\t\t\t\t\t\t  innames[i]);\n\t\t    if (spell_read_dic(&spin, fname, afile[i]) == FAIL)\n\t\t\terror = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// No .aff file, try reading the file as a word list.  Store\n\t\t// the words in the trees.\n\t\tif (spell_read_wordfile(&spin, innames[i]) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\n\t    // Free any conversion stuff.\n\t    convert_setup(&spin.si_conv, NULL, NULL);\n\t}\n\n\tif (spin.si_compflags != NULL && spin.si_nobreak)\n\t    msg(_(\"Warning: both compounding and NOBREAK specified\"));\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Combine tails in the tree.\n\t     */\n\t    spell_message(&spin, (char_u *)_(msg_compressing));\n\t    wordtree_compress(&spin, spin.si_foldroot, \"case-folded\");\n\t    wordtree_compress(&spin, spin.si_keeproot, \"keep-case\");\n\t    wordtree_compress(&spin, spin.si_prefroot, \"prefixes\");\n\t}\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Write the info in the spell file.\n\t     */\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t      _(\"Writing spell file %s...\"), wfname);\n\t    spell_message(&spin, IObuff);\n\n\t    error = write_vim_spell(&spin, wfname) == FAIL;\n\n\t    spell_message(&spin, (char_u *)_(\"Done!\"));\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);\n\t    spell_message(&spin, IObuff);\n\n\t    /*\n\t     * If the file is loaded need to reload it.\n\t     */\n\t    if (!error)\n\t\tspell_reload_one(wfname, added_word);\n\t}\n\n\t// Free the allocated memory.\n\tga_clear(&spin.si_rep);\n\tga_clear(&spin.si_repsal);\n\tga_clear(&spin.si_sal);\n\tga_clear(&spin.si_map);\n\tga_clear(&spin.si_comppat);\n\tga_clear(&spin.si_prefcond);\n\thash_clear_all(&spin.si_commonwords, 0);\n\n\t// Free the .aff file structures.\n\tfor (i = 0; i < incount; ++i)\n\t    if (afile[i] != NULL)\n\t\tspell_free_aff(afile[i]);\n\n\t// Free all the bits and pieces at once.\n\tfree_blocks(spin.si_blocks);\n\n\t/*\n\t * If there is soundfolding info and no NOSUGFILE item create the\n\t * .sug file with the soundfolded word trie.\n\t */\n\tif (spin.si_sugtime != 0 && !error && !got_int)\n\t    spell_make_sugfile(&spin, wfname);\n\n    }\n\ntheend:\n    vim_free(fname);\n    vim_free(wfname);\n}\n\n/*\n * Display a message for spell file processing when 'verbose' is set or using\n * \":mkspell\".  \"str\" can be IObuff.\n */\n    static void\nspell_message(spellinfo_T *spin, char_u *str)\n{\n    if (spin->si_verbose || p_verbose > 2)\n    {\n\tif (!spin->si_verbose)\n\t    verbose_enter();\n\tmsg((char *)str);\n\tout_flush();\n\tif (!spin->si_verbose)\n\t    verbose_leave();\n    }\n}\n\n/*\n * \":[count]spellgood  {word}\"\n * \":[count]spellwrong {word}\"\n * \":[count]spellundo  {word}\"\n * \":[count]spellrare  {word}\"\n */\n    void\nex_spell(exarg_T *eap)\n{\n    spell_add_word(eap->arg, (int)STRLEN(eap->arg),\n\t\teap->cmdidx == CMD_spellwrong ? SPELL_ADD_BAD :\n\t\teap->cmdidx == CMD_spellrare ? SPELL_ADD_RARE : SPELL_ADD_GOOD,\n\t\t\t\t   eap->forceit ? 0 : (int)eap->line2,\n\t\t\t\t   eap->cmdidx == CMD_spellundo);\n}\n\n/*\n * Add \"word[len]\" to 'spellfile' as a good, rare or bad word.\n */\n    void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}\n\n/*\n * Initialize 'spellfile' for the current buffer.\n */\n    static void\ninit_spellfile(void)\n{\n    char_u\t*buf;\n    int\t\tl;\n    char_u\t*fname;\n    char_u\t*rtp;\n    char_u\t*lend;\n    int\t\taspath = FALSE;\n    char_u\t*lstart = curbuf->b_s.b_p_spl;\n\n    if (*curwin->w_s->b_p_spl != NUL && curwin->w_s->b_langp.ga_len > 0)\n    {\n\tbuf = alloc(MAXPATHL);\n\tif (buf == NULL)\n\t    return;\n\n\t// Find the end of the language name.  Exclude the region.  If there\n\t// is a path separator remember the start of the tail.\n\tfor (lend = curwin->w_s->b_p_spl; *lend != NUL\n\t\t\t&& vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)\n\t    if (vim_ispathsep(*lend))\n\t    {\n\t\taspath = TRUE;\n\t\tlstart = lend + 1;\n\t    }\n\n\t// Loop over all entries in 'runtimepath'.  Use the first one where we\n\t// are allowed to write.\n\trtp = p_rtp;\n\twhile (*rtp != NUL)\n\t{\n\t    if (aspath)\n\t\t// Use directory of an entry with path, e.g., for\n\t\t// \"/dir/lg.utf-8.spl\" use \"/dir\".\n\t\tvim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t    lstart - curbuf->b_s.b_p_spl - 1);\n\t    else\n\t\t// Copy the path from 'runtimepath' to buf[].\n\t\tcopy_option_part(&rtp, buf, MAXPATHL, \",\");\n\t    if (filewritable(buf) == 2)\n\t    {\n\t\t// Use the first language name from 'spelllang' and the\n\t\t// encoding used in the first loaded .spl file.\n\t\tif (aspath)\n\t\t    vim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t\t  lend - curbuf->b_s.b_p_spl);\n\t\telse\n\t\t{\n\t\t    // Create the \"spell\" directory if it doesn't exist yet.\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l, \"/spell\");\n\t\t    if (filewritable(buf) != 2)\n\t\t\tvim_mkdir(buf, 0755);\n\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l,\n\t\t\t\t \"/%.*s\", (int)(lend - lstart), lstart);\n\t\t}\n\t\tl = (int)STRLEN(buf);\n\t\tfname = LANGP_ENTRY(curwin->w_s->b_langp, 0)\n\t\t\t\t\t\t\t ->lp_slang->sl_fname;\n\t\tvim_snprintf((char *)buf + l, MAXPATHL - l, \".%s.add\",\n\t\t\tfname != NULL\n\t\t\t  && strstr((char *)gettail(fname), \".ascii.\") != NULL\n\t\t\t\t       ? (char_u *)\"ascii\" : spell_enc());\n\t\tset_option_value_give_err((char_u *)\"spellfile\",\n\t\t\t\t\t\t\t   0L, buf, OPT_LOCAL);\n\t\tbreak;\n\t    }\n\t    aspath = FALSE;\n\t}\n\n\tvim_free(buf);\n    }\n}\n\n\n\n/*\n * Set the spell character tables from strings in the affix file.\n */\n    static int\nset_spell_chartab(char_u *fol, char_u *low, char_u *upp)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    char_u\t*pf = fol, *pl = low, *pu = upp;\n    int\t\tf, l, u;\n\n    clear_spell_chartab(&new_st);\n\n    while (*pf != NUL)\n    {\n\tif (*pl == NUL || *pu == NUL)\n\t{\n\t    emsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\t    return FAIL;\n\t}\n\tf = mb_ptr2char_adv(&pf);\n\tl = mb_ptr2char_adv(&pl);\n\tu = mb_ptr2char_adv(&pu);\n\n\t// Every character that appears is a word character.\n\tif (f < 256)\n\t    new_st.st_isw[f] = TRUE;\n\tif (l < 256)\n\t    new_st.st_isw[l] = TRUE;\n\tif (u < 256)\n\t    new_st.st_isw[u] = TRUE;\n\n\t// if \"LOW\" and \"FOL\" are not the same the \"LOW\" char needs\n\t// case-folding\n\tif (l < 256 && l != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[l] = f;\n\t}\n\n\t// if \"UPP\" and \"FOL\" are not the same the \"UPP\" char needs\n\t// case-folding, it's upper case and the \"UPP\" is the upper case of\n\t// \"FOL\" .\n\tif (u < 256 && u != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[u] = f;\n\t    new_st.st_isu[u] = TRUE;\n\t    new_st.st_upper[f] = u;\n\t}\n    }\n\n    if (*pl != NUL || *pu != NUL)\n    {\n\temsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\treturn FAIL;\n    }\n\n    return set_spell_finish(&new_st);\n}\n\n/*\n * Set the spell character tables from strings in the .spl file.\n */\n    static void\nset_spell_charflags(\n    char_u\t*flags,\n    int\t\tcnt,\t    // length of \"flags\"\n    char_u\t*fol)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    int\t\ti;\n    char_u\t*p = fol;\n    int\t\tc;\n\n    clear_spell_chartab(&new_st);\n\n    for (i = 0; i < 128; ++i)\n    {\n\tif (i < cnt)\n\t{\n\t    new_st.st_isw[i + 128] = (flags[i] & CF_WORD) != 0;\n\t    new_st.st_isu[i + 128] = (flags[i] & CF_UPPER) != 0;\n\t}\n\n\tif (*p != NUL)\n\t{\n\t    c = mb_ptr2char_adv(&p);\n\t    new_st.st_fold[i + 128] = c;\n\t    if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)\n\t\tnew_st.st_upper[c] = i + 128;\n\t}\n    }\n\n    (void)set_spell_finish(&new_st);\n}\n\n    static int\nset_spell_finish(spelltab_T *new_st)\n{\n    int\t\ti;\n\n    if (did_set_spelltab)\n    {\n\t// check that it's the same table\n\tfor (i = 0; i < 256; ++i)\n\t{\n\t    if (spelltab.st_isw[i] != new_st->st_isw[i]\n\t\t    || spelltab.st_isu[i] != new_st->st_isu[i]\n\t\t    || spelltab.st_fold[i] != new_st->st_fold[i]\n\t\t    || spelltab.st_upper[i] != new_st->st_upper[i])\n\t    {\n\t\temsg(_(e_word_characters_differ_between_spell_files));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// copy the new spelltab into the one being used\n\tspelltab = *new_st;\n\tdid_set_spelltab = TRUE;\n    }\n\n    return OK;\n}\n\n/*\n * Write the table with prefix conditions to the .spl file.\n * When \"fd\" is NULL only count the length of what is written and return it.\n */\n    static int\nwrite_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv)\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ttotlen;\n\n    if (fd != NULL)\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t    // <prefcondcnt>\n\n    totlen = 2 + gap->ga_len; // length of <prefcondcnt> and <condlen> bytes\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tp = ((char_u **)gap->ga_data)[i];\n\tif (p != NULL)\n\t{\n\t    len = (int)STRLEN(p);\n\t    if (fd != NULL)\n\t    {\n\t\tfputc(len, fd);\n\t\t*fwv &= fwrite(p, (size_t)len, (size_t)1, fd);\n\t    }\n\t    totlen += len;\n\t}\n\telse if (fd != NULL)\n\t    fputc(0, fd);\n    }\n\n    return totlen;\n}\n\n/*\n * Use map string \"map\" for languages \"lp\".\n */\n    static void\nset_map_str(slang_T *lp, char_u *map)\n{\n    char_u\t*p;\n    int\t\theadc = 0;\n    int\t\tc;\n    int\t\ti;\n\n    if (*map == NUL)\n    {\n\tlp->sl_has_map = FALSE;\n\treturn;\n    }\n    lp->sl_has_map = TRUE;\n\n    // Init the array and hash tables empty.\n    for (i = 0; i < 256; ++i)\n\tlp->sl_map_array[i] = 0;\n    hash_init(&lp->sl_map_hash);\n\n    /*\n     * The similar characters are stored separated with slashes:\n     * \"aaa/bbb/ccc/\".  Fill sl_map_array[c] with the character before c and\n     * before the same slash.  For characters above 255 sl_map_hash is used.\n     */\n    for (p = map; *p != NUL; )\n    {\n\tc = mb_cptr2char_adv(&p);\n\tif (c == '/')\n\t    headc = 0;\n\telse\n\t{\n\t    if (headc == 0)\n\t\t headc = c;\n\n\t    // Characters above 255 don't fit in sl_map_array[], put them in\n\t    // the hash table.  Each entry is the char, a NUL the headchar and\n\t    // a NUL.\n\t    if (c >= 256)\n\t    {\n\t\tint\t    cl = mb_char2len(c);\n\t\tint\t    headcl = mb_char2len(headc);\n\t\tchar_u\t    *b;\n\t\thash_T\t    hash;\n\t\thashitem_T  *hi;\n\n\t\tb = alloc(cl + headcl + 2);\n\t\tif (b == NULL)\n\t\t    return;\n\t\tmb_char2bytes(c, b);\n\t\tb[cl] = NUL;\n\t\tmb_char2bytes(headc, b + cl + 1);\n\t\tb[cl + 1 + headcl] = NUL;\n\t\thash = hash_hash(b);\n\t\thi = hash_lookup(&lp->sl_map_hash, b, hash);\n\t\tif (HASHITEM_EMPTY(hi))\n\t\t    hash_add_item(&lp->sl_map_hash, hi, b, hash);\n\t\telse\n\t\t{\n\t\t    // This should have been checked when generating the .spl\n\t\t    // file.\n\t\t    emsg(_(e_duplicate_char_in_map_entry));\n\t\t    vim_free(b);\n\t\t}\n\t    }\n\t    else\n\t\tlp->sl_map_array[c] = headc;\n\t}\n    }\n}\n\n#endif  // FEAT_SPELL\n", "\" Test for spell checking with 'encoding' set to utf-8\n\nsource check.vim\nCheckFeature spell\n\nscriptencoding utf-8\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.utf-8.add')\n  call delete('Xtest.utf-8.add.spl')\n  call delete('Xtest.utf-8.spl')\n  call delete('Xtest.utf-8.sug')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\u00eb\u00e9\u00e8\u00ea\u00ef\u00ee\u00e4\u00e0\u00e2\u00f6\u00fc\u00fb'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"LOW  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"UPP  \u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00ff\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\"\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=utf-8\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.utf-8.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  %bwipe!\n  call setline(1, ['', \"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  %bwipe!\nendfunc\n\nfunc Test_spell_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\u00E9\\u00F4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u00ffn\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_spell_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\u00E9\\u00F4l\",\n        \\ [\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_spell_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\u00EF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\u00EF barm\\u00EF m\\u00EFfoo m\\u00EFbar m\\u00EFm\\u00EF lala m\\u00EFla lam\\u00EF foola labar\",\n        \\ [\"foo\", \"m\\u00EF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\u00EF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\u00EF\", \"foo\"]],\n        \\   [\"foom\\u00EF\", [\"foo m\\u00EF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\u00EF\", [\"barfoo\", \"m\\u00EF\", \"barbar\"]],\n        \\   [\"m\\u00EFfoo\", [\"m\\u00EF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\u00EFbar\", [\"foobar\", \"barbar\", \"m\\u00EF\"]],\n        \\   [\"m\\u00EFm\\u00EF\", [\"m\\u00EF m\\u00EF\", \"m\\u00EF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\u00EFla\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"lam\\u00EF\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\" Test affix flags with two characters\nfunc Test_spell_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\u00E9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\u00E9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\u00E9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\u00E9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\u00E9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\u00E9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\u00E9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\u00E9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_spell_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_spell_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_spell_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\" Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_spell_sal_and_addition()\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.utf-8.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u00ffn\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.utf-8.add\")\n  mkspell! Xtest.utf-8.add.spl Xtest.utf-8.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.utf-8.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.utf-8.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.utf-8.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_no_crash_with_weird_text()\n  new\n  let lines =<< trim END\n      r<sfile>\n      \u0080\n\n\n      \u0080\n  END\n  call setline(1, lines)\n  exe \"%norm \\<C-v>ez=>\\<C-v>wzG\"\n\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: Block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: Invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: Cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: Pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: Pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: Pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: Pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: Line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: Line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\n#ifdef FEAT_PATH_EXTRA\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\n#endif\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\n#endif\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\n#endif\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: Undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: Undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\n#ifdef FEAT_SEARCHPATH\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#endif\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: Fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_here[]\n\tINIT(= N_(\"E578: Not allowed to change text here\"));\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n// E614 unused\n// E615 unused\n// E616 unused\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: Missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: Missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: Invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: Invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: Invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: Invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: Invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: Invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: Invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: Invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: Invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: Invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: Invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: Invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: Invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: Invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: Invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: Invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: Invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n# ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: Expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: Text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type[]\n\tINIT(= N_(\"E1008: Missing <type>\"));\nEXTERN char e_missing_gt_after_type[]\n\tINIT(= N_(\"E1009: Missing > after type\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n# ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n# endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_illegal_character_in_word[]\n\tINIT(= N_(\"E1280: Illegal character in word\"));\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n * Multibyte extensions partly by Sung-Hoon Baek\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * mbyte.c: Code specifically for handling multi-byte characters.\n *\n * The encoding used in the core is set with 'encoding'.  When 'encoding' is\n * changed, the following four variables are set (for speed).\n * Currently these types of character encodings are supported:\n *\n * \"enc_dbcs\"\t    When non-zero it tells the type of double byte character\n *\t\t    encoding (Chinese, Korean, Japanese, etc.).\n *\t\t    The cell width on the display is equal to the number of\n *\t\t    bytes.  (exception: DBCS_JPNU with first byte 0x8e)\n *\t\t    Recognizing the first or second byte is difficult, it\n *\t\t    requires checking a byte sequence from the start.\n * \"enc_utf8\"\t    When TRUE use Unicode characters in UTF-8 encoding.\n *\t\t    The cell width on the display needs to be determined from\n *\t\t    the character value.\n *\t\t    Recognizing bytes is easy: 0xxx.xxxx is a single-byte\n *\t\t    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading\n *\t\t    byte of a multi-byte character.\n *\t\t    To make things complicated, up to six composing characters\n *\t\t    are allowed.  These are drawn on top of the first char.\n *\t\t    For most editing the sequence of bytes with composing\n *\t\t    characters included is considered to be one character.\n * \"enc_unicode\"    When 2 use 16-bit Unicode characters (or UTF-16).\n *\t\t    When 4 use 32-but Unicode characters.\n *\t\t    Internally characters are stored in UTF-8 encoding to\n *\t\t    avoid NUL bytes.  Conversion happens when doing I/O.\n *\t\t    \"enc_utf8\" will also be TRUE.\n *\n * \"has_mbyte\" is set when \"enc_dbcs\" or \"enc_utf8\" is non-zero.\n *\n * If none of these is TRUE, 8-bit bytes are used for a character.  The\n * encoding isn't currently specified (TODO).\n *\n * 'encoding' specifies the encoding used in the core.  This is in registers,\n * text manipulation, buffers, etc.  Conversion has to be done when characters\n * in another encoding are received or send:\n *\n *\t\t       clipboard\n *\t\t\t   ^\n *\t\t\t   | (2)\n *\t\t\t   V\n *\t\t   +---------------+\n *\t      (1)  |\t\t   | (3)\n *  keyboard ----->|\t core\t   |-----> display\n *\t\t   |\t\t   |\n *\t\t   +---------------+\n *\t\t\t   ^\n *\t\t\t   | (4)\n *\t\t\t   V\n *\t\t\t file\n *\n * (1) Typed characters arrive in the current locale.  Conversion is to be\n *     done when 'encoding' is different from 'termencoding'.\n * (2) Text will be made available with the encoding specified with\n *     'encoding'.  If this is not sufficient, system-specific conversion\n *     might be required.\n * (3) For the GUI the correct font must be selected, no conversion done.\n *     Otherwise, conversion is to be done when 'encoding' differs from\n *     'termencoding'.  (Different in the GTK+ 2 port -- 'termencoding'\n *     is always used for both input and output and must always be set to\n *     \"utf-8\".  gui_mch_init() does this automatically.)\n * (4) The encoding of the file is specified with 'fileencoding'.  Conversion\n *     is to be done when it's different from 'encoding'.\n *\n * The viminfo file is a special case: Only text is converted, not file names.\n * Vim scripts may contain an \":encoding\" command.  This has an effect for\n * some commands, like \":menutrans\"\n */\n\n#include \"vim.h\"\n\n#ifdef WIN32UNIX\n# ifndef WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n# endif\n# if defined(FEAT_GUI) || defined(FEAT_XCLIPBOARD)\n#  ifdef __CYGWIN__\n    // ControlMask from <X11/X.h> (included in \"vim.h\") is conflicting with\n    // <w32api/windows.h> (included in <X11/Xwindows.h>).\n#   undef ControlMask\n#  endif\n#  include <X11/Xwindows.h>\n#  define WINBYTE wBYTE\n# else\n#  include <windows.h>\n#  define WINBYTE BYTE\n# endif\n# ifdef WIN32\n#  undef WIN32\t    // Some windows.h define WIN32, we don't want that here.\n# endif\n#else\n# define WINBYTE BYTE\n#endif\n\n#if (defined(MSWIN) || defined(WIN32UNIX)) && !defined(__MINGW32__)\n# include <winnls.h>\n#endif\n\n#ifdef FEAT_GUI_X11\n# include <X11/Intrinsic.h>\n#endif\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n# if !defined(HAVE_MBLEN) && !defined(mblen)\n#  define mblen _Xmblen\n# endif\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#if 0\n// This has been disabled, because several people reported problems with the\n// wcwidth() and iswprint() library functions, esp. for Hebrew.\n# ifdef __STDC_ISO_10646__\n#  define USE_WCHAR_FUNCTIONS\n# endif\n#endif\n\nstatic int dbcs_char2len(int c);\nstatic int dbcs_char2bytes(int c, char_u *buf);\nstatic int dbcs_ptr2len(char_u *p);\nstatic int dbcs_ptr2len_len(char_u *p, int size);\nstatic int utf_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_char2cells(int c);\nstatic int dbcs_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_ptr2char(char_u *p);\nstatic int dbcs_head_off(char_u *base, char_u *p);\n#ifdef FEAT_EVAL\nstatic int cw_value(int c);\n#endif\n\n/*\n * Lookup table to quickly get the length in bytes of a UTF-8 character from\n * the first byte of a UTF-8 string.\n * Bytes which are illegal when used as the first byte have a 1.\n * The NUL byte has length 1.\n */\nstatic char utf8len_tab[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,\n};\n\n/*\n * Like utf8len_tab above, but using a zero for illegal lead bytes.\n */\nstatic char utf8len_tab_zero[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,\n};\n\n\n/*\n * Canonical encoding names and their properties.\n * \"iso-8859-n\" is handled by enc_canonize() directly.\n */\nstatic struct\n{   char *name;\t\tint prop;\t\tint codepage;}\nenc_canon_table[] =\n{\n#define IDX_LATIN_1\t0\n    {\"latin1\",\t\tENC_8BIT + ENC_LATIN1,\t1252},\n#define IDX_ISO_2\t1\n    {\"iso-8859-2\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_3\t2\n    {\"iso-8859-3\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_4\t3\n    {\"iso-8859-4\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_5\t4\n    {\"iso-8859-5\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_6\t5\n    {\"iso-8859-6\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_7\t6\n    {\"iso-8859-7\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_8\t7\n    {\"iso-8859-8\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_9\t8\n    {\"iso-8859-9\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_10\t9\n    {\"iso-8859-10\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_11\t10\n    {\"iso-8859-11\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_13\t11\n    {\"iso-8859-13\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_14\t12\n    {\"iso-8859-14\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_15\t13\n    {\"iso-8859-15\",\tENC_8BIT + ENC_LATIN9,\t0},\n#define IDX_KOI8_R\t14\n    {\"koi8-r\",\t\tENC_8BIT,\t\t0},\n#define IDX_KOI8_U\t15\n    {\"koi8-u\",\t\tENC_8BIT,\t\t0},\n#define IDX_UTF8\t16\n    {\"utf-8\",\t\tENC_UNICODE,\t\t0},\n#define IDX_UCS2\t17\n    {\"ucs-2\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},\n#define IDX_UCS2LE\t18\n    {\"ucs-2le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},\n#define IDX_UTF16\t19\n    {\"utf-16\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},\n#define IDX_UTF16LE\t20\n    {\"utf-16le\",\tENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},\n#define IDX_UCS4\t21\n    {\"ucs-4\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},\n#define IDX_UCS4LE\t22\n    {\"ucs-4le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},\n\n    // For debugging DBCS encoding on Unix.\n#define IDX_DEBUG\t23\n    {\"debug\",\t\tENC_DBCS,\t\tDBCS_DEBUG},\n#define IDX_EUC_JP\t24\n    {\"euc-jp\",\t\tENC_DBCS,\t\tDBCS_JPNU},\n#define IDX_SJIS\t25\n    {\"sjis\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_EUC_KR\t26\n    {\"euc-kr\",\t\tENC_DBCS,\t\tDBCS_KORU},\n#define IDX_EUC_CN\t27\n    {\"euc-cn\",\t\tENC_DBCS,\t\tDBCS_CHSU},\n#define IDX_EUC_TW\t28\n    {\"euc-tw\",\t\tENC_DBCS,\t\tDBCS_CHTU},\n#define IDX_BIG5\t29\n    {\"big5\",\t\tENC_DBCS,\t\tDBCS_CHT},\n\n    // MS-DOS and MS-Windows codepages are included here, so that they can be\n    // used on Unix too.  Most of them are similar to ISO-8859 encodings, but\n    // not exactly the same.\n#define IDX_CP437\t30\n    {\"cp437\",\t\tENC_8BIT,\t\t437}, // like iso-8859-1\n#define IDX_CP737\t31\n    {\"cp737\",\t\tENC_8BIT,\t\t737}, // like iso-8859-7\n#define IDX_CP775\t32\n    {\"cp775\",\t\tENC_8BIT,\t\t775}, // Baltic\n#define IDX_CP850\t33\n    {\"cp850\",\t\tENC_8BIT,\t\t850}, // like iso-8859-4\n#define IDX_CP852\t34\n    {\"cp852\",\t\tENC_8BIT,\t\t852}, // like iso-8859-1\n#define IDX_CP855\t35\n    {\"cp855\",\t\tENC_8BIT,\t\t855}, // like iso-8859-2\n#define IDX_CP857\t36\n    {\"cp857\",\t\tENC_8BIT,\t\t857}, // like iso-8859-5\n#define IDX_CP860\t37\n    {\"cp860\",\t\tENC_8BIT,\t\t860}, // like iso-8859-9\n#define IDX_CP861\t38\n    {\"cp861\",\t\tENC_8BIT,\t\t861}, // like iso-8859-1\n#define IDX_CP862\t39\n    {\"cp862\",\t\tENC_8BIT,\t\t862}, // like iso-8859-1\n#define IDX_CP863\t40\n    {\"cp863\",\t\tENC_8BIT,\t\t863}, // like iso-8859-8\n#define IDX_CP865\t41\n    {\"cp865\",\t\tENC_8BIT,\t\t865}, // like iso-8859-1\n#define IDX_CP866\t42\n    {\"cp866\",\t\tENC_8BIT,\t\t866}, // like iso-8859-5\n#define IDX_CP869\t43\n    {\"cp869\",\t\tENC_8BIT,\t\t869}, // like iso-8859-7\n#define IDX_CP874\t44\n    {\"cp874\",\t\tENC_8BIT,\t\t874}, // Thai\n#define IDX_CP932\t45\n    {\"cp932\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_CP936\t46\n    {\"cp936\",\t\tENC_DBCS,\t\tDBCS_CHS},\n#define IDX_CP949\t47\n    {\"cp949\",\t\tENC_DBCS,\t\tDBCS_KOR},\n#define IDX_CP950\t48\n    {\"cp950\",\t\tENC_DBCS,\t\tDBCS_CHT},\n#define IDX_CP1250\t49\n    {\"cp1250\",\t\tENC_8BIT,\t\t1250}, // Czech, Polish, etc.\n#define IDX_CP1251\t50\n    {\"cp1251\",\t\tENC_8BIT,\t\t1251}, // Cyrillic\n    // cp1252 is considered to be equal to latin1\n#define IDX_CP1253\t51\n    {\"cp1253\",\t\tENC_8BIT,\t\t1253}, // Greek\n#define IDX_CP1254\t52\n    {\"cp1254\",\t\tENC_8BIT,\t\t1254}, // Turkish\n#define IDX_CP1255\t53\n    {\"cp1255\",\t\tENC_8BIT,\t\t1255}, // Hebrew\n#define IDX_CP1256\t54\n    {\"cp1256\",\t\tENC_8BIT,\t\t1256}, // Arabic\n#define IDX_CP1257\t55\n    {\"cp1257\",\t\tENC_8BIT,\t\t1257}, // Baltic\n#define IDX_CP1258\t56\n    {\"cp1258\",\t\tENC_8BIT,\t\t1258}, // Vietnamese\n\n#define IDX_MACROMAN\t57\n    {\"macroman\",\tENC_8BIT + ENC_MACROMAN, 0},\t// Mac OS\n#define IDX_DECMCS\t58\n    {\"dec-mcs\",\t\tENC_8BIT,\t\t0},\t// DEC MCS\n#define IDX_HPROMAN8\t59\n    {\"hp-roman8\",\tENC_8BIT,\t\t0},\t// HP Roman8\n#define IDX_COUNT\t60\n};\n\n/*\n * Aliases for encoding names.\n */\nstatic struct\n{   char *name;\t\tint canon;}\nenc_alias_table[] =\n{\n    {\"ansi\",\t\tIDX_LATIN_1},\n    {\"iso-8859-1\",\tIDX_LATIN_1},\n    {\"iso-8859\",\tIDX_LATIN_1},\n    {\"latin2\",\t\tIDX_ISO_2},\n    {\"latin3\",\t\tIDX_ISO_3},\n    {\"latin4\",\t\tIDX_ISO_4},\n    {\"cyrillic\",\tIDX_ISO_5},\n    {\"arabic\",\t\tIDX_ISO_6},\n    {\"greek\",\t\tIDX_ISO_7},\n#ifdef MSWIN\n    {\"hebrew\",\t\tIDX_CP1255},\n#else\n    {\"hebrew\",\t\tIDX_ISO_8},\n#endif\n    {\"latin5\",\t\tIDX_ISO_9},\n    {\"turkish\",\t\tIDX_ISO_9}, // ?\n    {\"latin6\",\t\tIDX_ISO_10},\n    {\"nordic\",\t\tIDX_ISO_10}, // ?\n    {\"thai\",\t\tIDX_ISO_11}, // ?\n    {\"latin7\",\t\tIDX_ISO_13},\n    {\"latin8\",\t\tIDX_ISO_14},\n    {\"latin9\",\t\tIDX_ISO_15},\n    {\"utf8\",\t\tIDX_UTF8},\n    {\"unicode\",\t\tIDX_UCS2},\n    {\"ucs2\",\t\tIDX_UCS2},\n    {\"ucs2be\",\t\tIDX_UCS2},\n    {\"ucs-2be\",\t\tIDX_UCS2},\n    {\"ucs2le\",\t\tIDX_UCS2LE},\n    {\"utf16\",\t\tIDX_UTF16},\n    {\"utf16be\",\t\tIDX_UTF16},\n    {\"utf-16be\",\tIDX_UTF16},\n    {\"utf16le\",\t\tIDX_UTF16LE},\n    {\"ucs4\",\t\tIDX_UCS4},\n    {\"ucs4be\",\t\tIDX_UCS4},\n    {\"ucs-4be\",\t\tIDX_UCS4},\n    {\"ucs4le\",\t\tIDX_UCS4LE},\n    {\"utf32\",\t\tIDX_UCS4},\n    {\"utf-32\",\t\tIDX_UCS4},\n    {\"utf32be\",\t\tIDX_UCS4},\n    {\"utf-32be\",\tIDX_UCS4},\n    {\"utf32le\",\t\tIDX_UCS4LE},\n    {\"utf-32le\",\tIDX_UCS4LE},\n    {\"932\",\t\tIDX_CP932},\n    {\"949\",\t\tIDX_CP949},\n    {\"936\",\t\tIDX_CP936},\n    {\"gbk\",\t\tIDX_CP936},\n    {\"950\",\t\tIDX_CP950},\n    {\"eucjp\",\t\tIDX_EUC_JP},\n    {\"unix-jis\",\tIDX_EUC_JP},\n    {\"ujis\",\t\tIDX_EUC_JP},\n    {\"shift-jis\",\tIDX_SJIS},\n    {\"pck\",\t\tIDX_SJIS},\t// Sun: PCK\n    {\"euckr\",\t\tIDX_EUC_KR},\n    {\"5601\",\t\tIDX_EUC_KR},\t// Sun: KS C 5601\n    {\"euccn\",\t\tIDX_EUC_CN},\n    {\"gb2312\",\t\tIDX_EUC_CN},\n    {\"euctw\",\t\tIDX_EUC_TW},\n#if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n    {\"japan\",\t\tIDX_CP932},\n    {\"korea\",\t\tIDX_CP949},\n    {\"prc\",\t\tIDX_CP936},\n    {\"chinese\",\t\tIDX_CP936},\n    {\"taiwan\",\t\tIDX_CP950},\n    {\"big5\",\t\tIDX_CP950},\n#else\n    {\"japan\",\t\tIDX_EUC_JP},\n    {\"korea\",\t\tIDX_EUC_KR},\n    {\"prc\",\t\tIDX_EUC_CN},\n    {\"chinese\",\t\tIDX_EUC_CN},\n    {\"taiwan\",\t\tIDX_EUC_TW},\n    {\"cp950\",\t\tIDX_BIG5},\n    {\"950\",\t\tIDX_BIG5},\n#endif\n    {\"mac\",\t\tIDX_MACROMAN},\n    {\"mac-roman\",\tIDX_MACROMAN},\n    {NULL,\t\t0}\n};\n\n#ifndef CP_UTF8\n# define CP_UTF8 65001\t// magic number from winnls.h\n#endif\n\n/*\n * Find encoding \"name\" in the list of canonical encoding names.\n * Returns -1 if not found.\n */\n    static int\nenc_canon_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; i < IDX_COUNT; ++i)\n\tif (STRCMP(name, enc_canon_table[i].name) == 0)\n\t    return i;\n    return -1;\n}\n\n\n/*\n * Find canonical encoding \"name\" in the list and return its properties.\n * Returns 0 if not found.\n */\n    int\nenc_canon_props(char_u *name)\n{\n    int\t\ti;\n\n    i = enc_canon_search(name);\n    if (i >= 0)\n\treturn enc_canon_table[i].prop;\n#ifdef MSWIN\n    if (name[0] == 'c' && name[1] == 'p' && VIM_ISDIGIT(name[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)name + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1) // some single-byte encoding\n\t\treturn ENC_8BIT;\n\t    if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t\t// must be a DBCS encoding\n\t\treturn ENC_DBCS;\n\t}\n\treturn 0;\n    }\n#endif\n    if (STRNCMP(name, \"2byte-\", 6) == 0)\n\treturn ENC_DBCS;\n    if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)\n\treturn ENC_8BIT;\n    return 0;\n}\n\n/*\n * Set up for using multi-byte characters.\n * Called in three cases:\n * - by main() to initialize (p_enc == NULL)\n * - by set_init_1() after 'encoding' was set to its default.\n * - by do_set() when 'encoding' has been set.\n * p_enc must have been passed through enc_canonize() already.\n * Sets the \"enc_unicode\", \"enc_utf8\", \"enc_dbcs\" and \"has_mbyte\" flags.\n * Fills mb_bytelen_tab[] and returns NULL when there are no problems.\n * When there is something wrong: Returns an error message and doesn't change\n * anything.\n */\n    char *\nmb_init(void)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\tn;\n    int\t\tenc_dbcs_new = 0;\n#if defined(USE_ICONV) && !defined(MSWIN) && !defined(WIN32UNIX) \\\n\t&& !defined(MACOS_CONVERT)\n# define LEN_FROM_CONV\n    vimconv_T\tvimconv;\n    char_u\t*p;\n#endif\n\n    if (p_enc == NULL)\n    {\n\t// Just starting up: set the whole table to one's.\n\tfor (i = 0; i < 256; ++i)\n\t    mb_bytelen_tab[i] = 1;\n\tinput_conv.vc_type = CONV_NONE;\n\tinput_conv.vc_factor = 1;\n\toutput_conv.vc_type = CONV_NONE;\n\treturn NULL;\n    }\n\n#ifdef MSWIN\n    if (p_enc[0] == 'c' && p_enc[1] == 'p' && VIM_ISDIGIT(p_enc[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)p_enc + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1)\n\t    {\n\t\t// some single-byte encoding\n\t\tenc_unicode = 0;\n\t\tenc_utf8 = FALSE;\n\t    }\n\t    else if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t    {\n\t\t// must be a DBCS encoding, check below\n\t\tenc_dbcs_new = atoi((char *)p_enc + 2);\n\t    }\n\t    else\n\t\tgoto codepage_invalid;\n\t}\n\telse if (GetLastError() == ERROR_INVALID_PARAMETER)\n\t{\ncodepage_invalid:\n\t    return N_(e_not_valid_codepage);\n\t}\n    }\n#endif\n    else if (STRNCMP(p_enc, \"8bit-\", 5) == 0\n\t    || STRNCMP(p_enc, \"iso-8859-\", 9) == 0)\n    {\n\t// Accept any \"8bit-\" or \"iso-8859-\" name.\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n    {\n#ifdef MSWIN\n\t// Windows: accept only valid codepage numbers, check below.\n\tif (p_enc[6] != 'c' || p_enc[7] != 'p'\n\t\t\t      || (enc_dbcs_new = atoi((char *)p_enc + 8)) == 0)\n\t    return e_invalid_argument;\n#else\n\t// Unix: accept any \"2byte-\" name, assume current locale.\n\tenc_dbcs_new = DBCS_2BYTE;\n#endif\n    }\n    else if ((idx = enc_canon_search(p_enc)) >= 0)\n    {\n\ti = enc_canon_table[idx].prop;\n\tif (i & ENC_UNICODE)\n\t{\n\t    // Unicode\n\t    enc_utf8 = TRUE;\n\t    if (i & (ENC_2BYTE | ENC_2WORD))\n\t\tenc_unicode = 2;\n\t    else if (i & ENC_4BYTE)\n\t\tenc_unicode = 4;\n\t    else\n\t\tenc_unicode = 0;\n\t}\n\telse if (i & ENC_DBCS)\n\t{\n\t    // 2byte, handle below\n\t    enc_dbcs_new = enc_canon_table[idx].codepage;\n\t}\n\telse\n\t{\n\t    // Must be 8-bit.\n\t    enc_unicode = 0;\n\t    enc_utf8 = FALSE;\n\t}\n    }\n    else    // Don't know what encoding this is, reject it.\n\treturn e_invalid_argument;\n\n    if (enc_dbcs_new != 0)\n    {\n#ifdef MSWIN\n\t// Check if the DBCS code page is OK.\n\tif (!IsValidCodePage(enc_dbcs_new))\n\t    goto codepage_invalid;\n#endif\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    enc_dbcs = enc_dbcs_new;\n    has_mbyte = (enc_dbcs != 0 || enc_utf8);\n\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    enc_codepage = encname2codepage(p_enc);\n    enc_latin9 = (STRCMP(p_enc, \"iso-8859-15\") == 0);\n#endif\n\n    // Detect an encoding that uses latin1 characters.\n    enc_latin1like = (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t|| STRCMP(p_enc, \"iso-8859-15\") == 0);\n\n    /*\n     * Set the function pointers.\n     */\n    if (enc_utf8)\n    {\n\tmb_ptr2len = utfc_ptr2len;\n\tmb_ptr2len_len = utfc_ptr2len_len;\n\tmb_char2len = utf_char2len;\n\tmb_char2bytes = utf_char2bytes;\n\tmb_ptr2cells = utf_ptr2cells;\n\tmb_ptr2cells_len = utf_ptr2cells_len;\n\tmb_char2cells = utf_char2cells;\n\tmb_off2cells = utf_off2cells;\n\tmb_ptr2char = utf_ptr2char;\n\tmb_head_off = utf_head_off;\n    }\n    else if (enc_dbcs != 0)\n    {\n\tmb_ptr2len = dbcs_ptr2len;\n\tmb_ptr2len_len = dbcs_ptr2len_len;\n\tmb_char2len = dbcs_char2len;\n\tmb_char2bytes = dbcs_char2bytes;\n\tmb_ptr2cells = dbcs_ptr2cells;\n\tmb_ptr2cells_len = dbcs_ptr2cells_len;\n\tmb_char2cells = dbcs_char2cells;\n\tmb_off2cells = dbcs_off2cells;\n\tmb_ptr2char = dbcs_ptr2char;\n\tmb_head_off = dbcs_head_off;\n    }\n    else\n    {\n\tmb_ptr2len = latin_ptr2len;\n\tmb_ptr2len_len = latin_ptr2len_len;\n\tmb_char2len = latin_char2len;\n\tmb_char2bytes = latin_char2bytes;\n\tmb_ptr2cells = latin_ptr2cells;\n\tmb_ptr2cells_len = latin_ptr2cells_len;\n\tmb_char2cells = latin_char2cells;\n\tmb_off2cells = latin_off2cells;\n\tmb_ptr2char = latin_ptr2char;\n\tmb_head_off = latin_head_off;\n    }\n\n    /*\n     * Fill the mb_bytelen_tab[] for MB_BYTE2LEN().\n     */\n#ifdef LEN_FROM_CONV\n    // When 'encoding' is different from the current locale mblen() won't\n    // work.  Use conversion to \"utf-8\" instead.\n    vimconv.vc_type = CONV_NONE;\n    if (enc_dbcs)\n    {\n\tp = enc_locale();\n\tif (p == NULL || STRCMP(p, p_enc) != 0)\n\t{\n\t    convert_setup(&vimconv, p_enc, (char_u *)\"utf-8\");\n\t    vimconv.vc_fail = TRUE;\n\t}\n\tvim_free(p);\n    }\n#endif\n\n    for (i = 0; i < 256; ++i)\n    {\n\t// Our own function to reliably check the length of UTF-8 characters,\n\t// independent of mblen().\n\tif (enc_utf8)\n\t    n = utf8len_tab[i];\n\telse if (enc_dbcs == 0)\n\t    n = 1;\n\telse\n\t{\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t    // enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows\n\t    // CodePage identifier, which we can pass directly in to Windows\n\t    // API\n\t    n = IsDBCSLeadByteEx(enc_dbcs, (WINBYTE)i) ? 2 : 1;\n#else\n# if defined(__amigaos4__) || defined(__ANDROID__) || \\\n\t\t\t\t   !(defined(HAVE_MBLEN) || defined(X_LOCALE))\n\t    /*\n\t     * if mblen() is not available, character which MSB is turned on\n\t     * are treated as leading byte character. (note : This assumption\n\t     * is not always true.)\n\t     */\n\t    n = (i & 0x80) ? 2 : 1;\n# else\n\t    char buf[MB_MAXBYTES + 1];\n\n\t    if (i == NUL)\t// just in case mblen() can't handle \"\"\n\t\tn = 1;\n\t    else\n\t    {\n\t\tbuf[0] = i;\n\t\tbuf[1] = 0;\n#  ifdef LEN_FROM_CONV\n\t\tif (vimconv.vc_type != CONV_NONE)\n\t\t{\n\t\t    /*\n\t\t     * string_convert() should fail when converting the first\n\t\t     * byte of a double-byte character.\n\t\t     */\n\t\t    p = string_convert(&vimconv, (char_u *)buf, NULL);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tvim_free(p);\n\t\t\tn = 1;\n\t\t    }\n\t\t    else\n\t\t\tn = 2;\n\t\t}\n\t\telse\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * mblen() should return -1 for invalid (means the leading\n\t\t     * multibyte) character.  However there are some platforms\n\t\t     * where mblen() returns 0 for invalid character.\n\t\t     * Therefore, following condition includes 0.\n\t\t     */\n\t\t    vim_ignored = mblen(NULL, 0);  // First reset the state.\n\t\t    if (mblen(buf, (size_t)1) <= 0)\n\t\t\tn = 2;\n\t\t    else\n\t\t\tn = 1;\n\t\t}\n\t    }\n# endif\n#endif\n\t}\n\n\tmb_bytelen_tab[i] = n;\n    }\n\n#ifdef LEN_FROM_CONV\n    convert_setup(&vimconv, NULL, NULL);\n#endif\n\n    // The cell width depends on the type of multi-byte characters.\n    (void)init_chartab();\n\n    // When enc_utf8 is set or reset, (de)allocate ScreenLinesUC[]\n    screenalloc(FALSE);\n\n    // When using Unicode, set default for 'fileencodings'.\n    if (enc_utf8 && !option_was_set((char_u *)\"fencs\"))\n\tset_fencs_unicode();\n\n#if defined(HAVE_BIND_TEXTDOMAIN_CODESET) && defined(FEAT_GETTEXT)\n    // GNU gettext 0.10.37 supports this feature: set the codeset used for\n    // translated messages independently from the current locale.\n    (void)bind_textdomain_codeset(VIMPACKAGE,\n\t\t\t\t\t  enc_utf8 ? \"utf-8\" : (char *)p_enc);\n#endif\n\n#ifdef MSWIN\n    // When changing 'encoding' while starting up, then convert the command\n    // line arguments from the active codepage to 'encoding'.\n    if (starting != 0)\n\tfix_arg_enc();\n#endif\n\n    // Fire an autocommand to let people do custom font setup. This must be\n    // after Vim has been setup for the new encoding.\n    apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)\"\", FALSE, curbuf);\n\n#ifdef FEAT_SPELL\n    // Need to reload spell dictionaries\n    spell_reload();\n#endif\n\n    return NULL;\n}\n\n/*\n * Return the size of the BOM for the current buffer:\n * 0 - no BOM\n * 2 - UCS-2 or UTF-16 BOM\n * 4 - UCS-4 BOM\n * 3 - UTF-8 BOM\n */\n    int\nbomb_size(void)\n{\n    int n = 0;\n\n    if (curbuf->b_p_bomb && !curbuf->b_p_bin)\n    {\n\tif (*curbuf->b_p_fenc == NUL)\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tif (enc_unicode != 0)\n\t\t    n = enc_unicode;\n\t\telse\n\t\t    n = 3;\n\t    }\n\t}\n\telse if (STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0)\n\t    n = 3;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-2\", 5) == 0\n\t\t|| STRNCMP(curbuf->b_p_fenc, \"utf-16\", 6) == 0)\n\t    n = 2;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-4\", 5) == 0)\n\t    n = 4;\n    }\n    return n;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Remove all BOM from \"s\" by moving remaining text.\n */\n    void\nremove_bom(char_u *s)\n{\n    if (enc_utf8)\n    {\n\tchar_u *p = s;\n\n\twhile ((p = vim_strbyte(p, 0xef)) != NULL)\n\t{\n\t    if (p[1] == 0xbb && p[2] == 0xbf)\n\t\tSTRMOVE(p, p + 3);\n\t    else\n\t\t++p;\n\t}\n    }\n}\n#endif\n\n/*\n * Get class of pointer:\n * 0 for blank or NUL\n * 1 for punctuation\n * 2 for an (ASCII) word character\n * >2 for other word characters\n */\n    int\nmb_get_class(char_u *p)\n{\n    return mb_get_class_buf(p, curbuf);\n}\n\n    int\nmb_get_class_buf(char_u *p, buf_T *buf)\n{\n    if (MB_BYTE2LEN(p[0]) == 1)\n    {\n\tif (p[0] == NUL || VIM_ISWHITE(p[0]))\n\t    return 0;\n\tif (vim_iswordc_buf(p[0], buf))\n\t    return 2;\n\treturn 1;\n    }\n    if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)\n\treturn dbcs_class(p[0], p[1]);\n    if (enc_utf8)\n\treturn utf_class_buf(utf_ptr2char(p), buf);\n    return 0;\n}\n\n/*\n * Get class of a double-byte character.  This always returns 3 or bigger.\n * TODO: Should return 1 for punctuation.\n */\n    int\ndbcs_class(unsigned lead, unsigned trail)\n{\n    switch (enc_dbcs)\n    {\n\t// please add classify routine for your language in here\n\n\tcase DBCS_JPNU:\t// ?\n\tcase DBCS_JPN:\n\t    {\n\t\t// JIS code classification\n\t\tunsigned char lb = lead;\n\t\tunsigned char tb = trail;\n\n\t\t// convert process code to JIS\n# if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n\t\t// process code is SJIS\n\t\tif (lb <= 0x9f)\n\t\t    lb = (lb - 0x81) * 2 + 0x21;\n\t\telse\n\t\t    lb = (lb - 0xc1) * 2 + 0x21;\n\t\tif (tb <= 0x7e)\n\t\t    tb -= 0x1f;\n\t\telse if (tb <= 0x9e)\n\t\t    tb -= 0x20;\n\t\telse\n\t\t{\n\t\t    tb -= 0x7e;\n\t\t    lb += 1;\n\t\t}\n# else\n\t\t/*\n\t\t * XXX: Code page identification can not use with all\n\t\t *\t    system! So, some other encoding information\n\t\t *\t    will be needed.\n\t\t *\t    In japanese: SJIS,EUC,UNICODE,(JIS)\n\t\t *\t    Note that JIS-code system don't use as\n\t\t *\t    process code in most system because it uses\n\t\t *\t    escape sequences(JIS is context depend encoding).\n\t\t */\n\t\t// assume process code is JAPANESE-EUC\n\t\tlb &= 0x7f;\n\t\ttb &= 0x7f;\n# endif\n\t\t// exceptions\n\t\tswitch (lb << 8 | tb)\n\t\t{\n\t\t    case 0x2121: // ZENKAKU space\n\t\t\treturn 0;\n\t\t    case 0x2122: // TOU-TEN (Japanese comma)\n\t\t    case 0x2123: // KU-TEN (Japanese period)\n\t\t    case 0x2124: // ZENKAKU comma\n\t\t    case 0x2125: // ZENKAKU period\n\t\t\treturn 1;\n\t\t    case 0x213c: // prolongedsound handled as KATAKANA\n\t\t\treturn 13;\n\t\t}\n\t\t// sieved by KU code\n\t\tswitch (lb)\n\t\t{\n\t\t    case 0x21:\n\t\t    case 0x22:\n\t\t\t// special symbols\n\t\t\treturn 10;\n\t\t    case 0x23:\n\t\t\t// alphanumeric\n\t\t\treturn 11;\n\t\t    case 0x24:\n\t\t\t// hiragana\n\t\t\treturn 12;\n\t\t    case 0x25:\n\t\t\t// katakana\n\t\t\treturn 13;\n\t\t    case 0x26:\n\t\t\t// greek\n\t\t\treturn 14;\n\t\t    case 0x27:\n\t\t\t// russian\n\t\t\treturn 15;\n\t\t    case 0x28:\n\t\t\t// lines\n\t\t\treturn 16;\n\t\t    default:\n\t\t\t// kanji\n\t\t\treturn 17;\n\t\t}\n\t    }\n\n\tcase DBCS_KORU:\t// ?\n\tcase DBCS_KOR:\n\t    {\n\t\t// KS code classification\n\t\tunsigned char c1 = lead;\n\t\tunsigned char c2 = trail;\n\n\t\t/*\n\t\t * 20 : Hangul\n\t\t * 21 : Hanja\n\t\t * 22 : Symbols\n\t\t * 23 : Alphanumeric/Roman Letter (Full width)\n\t\t * 24 : Hangul Letter(Alphabet)\n\t\t * 25 : Roman Numeral/Greek Letter\n\t\t * 26 : Box Drawings\n\t\t * 27 : Unit Symbols\n\t\t * 28 : Circled/Parenthesized Letter\n\t\t * 29 : Hiragana/Katakana\n\t\t * 30 : Cyrillic Letter\n\t\t */\n\n\t\tif (c1 >= 0xB0 && c1 <= 0xC8)\n\t\t    // Hangul\n\t\t    return 20;\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t\telse if (c1 <= 0xA0 || c2 <= 0xA0)\n\t\t    // Extended Hangul Region : MS UHC(Unified Hangul Code)\n\t\t    // c1: 0x81-0xA0 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE\n\t\t    // c1: 0xA1-0xC6 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xA0\n\t\t    return 20;\n#endif\n\n\t\telse if (c1 >= 0xCA && c1 <= 0xFD)\n\t\t    // Hanja\n\t\t    return 21;\n\t\telse switch (c1)\n\t\t{\n\t\t    case 0xA1:\n\t\t    case 0xA2:\n\t\t\t// Symbols\n\t\t\treturn 22;\n\t\t    case 0xA3:\n\t\t\t// Alphanumeric\n\t\t\treturn 23;\n\t\t    case 0xA4:\n\t\t\t// Hangul Letter(Alphabet)\n\t\t\treturn 24;\n\t\t    case 0xA5:\n\t\t\t// Roman Numeral/Greek Letter\n\t\t\treturn 25;\n\t\t    case 0xA6:\n\t\t\t// Box Drawings\n\t\t\treturn 26;\n\t\t    case 0xA7:\n\t\t\t// Unit Symbols\n\t\t\treturn 27;\n\t\t    case 0xA8:\n\t\t    case 0xA9:\n\t\t\tif (c2 <= 0xAF)\n\t\t\t    return 25;  // Roman Letter\n\t\t\telse if (c2 >= 0xF6)\n\t\t\t    return 22;  // Symbols\n\t\t\telse\n\t\t\t    // Circled/Parenthesized Letter\n\t\t\t    return 28;\n\t\t    case 0xAA:\n\t\t    case 0xAB:\n\t\t\t// Hiragana/Katakana\n\t\t\treturn 29;\n\t\t    case 0xAC:\n\t\t\t// Cyrillic Letter\n\t\t\treturn 30;\n\t\t}\n\t    }\n\tdefault:\n\t    break;\n    }\n    return 3;\n}\n\n/*\n * mb_char2len() function pointer.\n * Return length in bytes of character \"c\".\n * Returns 1 for a single-byte character.\n */\n    int\nlatin_char2len(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2len(\n    int\t\tc)\n{\n    if (c >= 0x100)\n\treturn 2;\n    return 1;\n}\n\n/*\n * mb_char2bytes() function pointer.\n * Convert a character to its bytes.\n * Returns the length in bytes.\n */\n    int\nlatin_char2bytes(int c, char_u *buf)\n{\n    buf[0] = c;\n    return 1;\n}\n\n    static int\ndbcs_char2bytes(int c, char_u *buf)\n{\n    if (c >= 0x100)\n    {\n\tbuf[0] = (unsigned)c >> 8;\n\tbuf[1] = c;\n\t// Never use a NUL byte, it causes lots of trouble.  It's an invalid\n\t// character anyway.\n\tif (buf[1] == NUL)\n\t    buf[1] = '\\n';\n\treturn 2;\n    }\n    buf[0] = c;\n    return 1;\n}\n\n/*\n * mb_ptr2len() function pointer.\n * Get byte length of character at \"*p\" but stop at a NUL.\n * For UTF-8 this includes following composing characters.\n * Returns 0 when *p is NUL.\n */\n    int\nlatin_ptr2len(char_u *p)\n{\n return MB_BYTE2LEN(*p);\n}\n\n    static int\ndbcs_ptr2len(\n    char_u\t*p)\n{\n    int\t\tlen;\n\n    // Check if second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\n/*\n * mb_ptr2len_len() function pointer.\n * Like mb_ptr2len(), but limit to read \"size\" bytes.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nlatin_ptr2len_len(char_u *p, int size)\n{\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    return 1;\n}\n\n    static int\ndbcs_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (size == 1)\n\treturn 1;\n    // Check that second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\nstruct interval\n{\n    long first;\n    long last;\n};\n\n/*\n * Return TRUE if \"c\" is in \"table[size / sizeof(struct interval)]\".\n */\n    static int\nintable(struct interval *table, size_t size, int c)\n{\n    int mid, bot, top;\n\n    // first quick check for Latin1 etc. characters\n    if (c < table[0].first)\n\treturn FALSE;\n\n    // binary search in table\n    bot = 0;\n    top = (int)(size / sizeof(struct interval) - 1);\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Sorted list of non-overlapping intervals of East Asian Ambiguous\n// characters, generated with ../runtime/tools/unicode.vim.\nstatic struct interval ambiguous[] =\n{\n    {0x00a1, 0x00a1},\n    {0x00a4, 0x00a4},\n    {0x00a7, 0x00a8},\n    {0x00aa, 0x00aa},\n    {0x00ad, 0x00ae},\n    {0x00b0, 0x00b4},\n    {0x00b6, 0x00ba},\n    {0x00bc, 0x00bf},\n    {0x00c6, 0x00c6},\n    {0x00d0, 0x00d0},\n    {0x00d7, 0x00d8},\n    {0x00de, 0x00e1},\n    {0x00e6, 0x00e6},\n    {0x00e8, 0x00ea},\n    {0x00ec, 0x00ed},\n    {0x00f0, 0x00f0},\n    {0x00f2, 0x00f3},\n    {0x00f7, 0x00fa},\n    {0x00fc, 0x00fc},\n    {0x00fe, 0x00fe},\n    {0x0101, 0x0101},\n    {0x0111, 0x0111},\n    {0x0113, 0x0113},\n    {0x011b, 0x011b},\n    {0x0126, 0x0127},\n    {0x012b, 0x012b},\n    {0x0131, 0x0133},\n    {0x0138, 0x0138},\n    {0x013f, 0x0142},\n    {0x0144, 0x0144},\n    {0x0148, 0x014b},\n    {0x014d, 0x014d},\n    {0x0152, 0x0153},\n    {0x0166, 0x0167},\n    {0x016b, 0x016b},\n    {0x01ce, 0x01ce},\n    {0x01d0, 0x01d0},\n    {0x01d2, 0x01d2},\n    {0x01d4, 0x01d4},\n    {0x01d6, 0x01d6},\n    {0x01d8, 0x01d8},\n    {0x01da, 0x01da},\n    {0x01dc, 0x01dc},\n    {0x0251, 0x0251},\n    {0x0261, 0x0261},\n    {0x02c4, 0x02c4},\n    {0x02c7, 0x02c7},\n    {0x02c9, 0x02cb},\n    {0x02cd, 0x02cd},\n    {0x02d0, 0x02d0},\n    {0x02d8, 0x02db},\n    {0x02dd, 0x02dd},\n    {0x02df, 0x02df},\n    {0x0300, 0x036f},\n    {0x0391, 0x03a1},\n    {0x03a3, 0x03a9},\n    {0x03b1, 0x03c1},\n    {0x03c3, 0x03c9},\n    {0x0401, 0x0401},\n    {0x0410, 0x044f},\n    {0x0451, 0x0451},\n    {0x2010, 0x2010},\n    {0x2013, 0x2016},\n    {0x2018, 0x2019},\n    {0x201c, 0x201d},\n    {0x2020, 0x2022},\n    {0x2024, 0x2027},\n    {0x2030, 0x2030},\n    {0x2032, 0x2033},\n    {0x2035, 0x2035},\n    {0x203b, 0x203b},\n    {0x203e, 0x203e},\n    {0x2074, 0x2074},\n    {0x207f, 0x207f},\n    {0x2081, 0x2084},\n    {0x20ac, 0x20ac},\n    {0x2103, 0x2103},\n    {0x2105, 0x2105},\n    {0x2109, 0x2109},\n    {0x2113, 0x2113},\n    {0x2116, 0x2116},\n    {0x2121, 0x2122},\n    {0x2126, 0x2126},\n    {0x212b, 0x212b},\n    {0x2153, 0x2154},\n    {0x215b, 0x215e},\n    {0x2160, 0x216b},\n    {0x2170, 0x2179},\n    {0x2189, 0x2189},\n    {0x2190, 0x2199},\n    {0x21b8, 0x21b9},\n    {0x21d2, 0x21d2},\n    {0x21d4, 0x21d4},\n    {0x21e7, 0x21e7},\n    {0x2200, 0x2200},\n    {0x2202, 0x2203},\n    {0x2207, 0x2208},\n    {0x220b, 0x220b},\n    {0x220f, 0x220f},\n    {0x2211, 0x2211},\n    {0x2215, 0x2215},\n    {0x221a, 0x221a},\n    {0x221d, 0x2220},\n    {0x2223, 0x2223},\n    {0x2225, 0x2225},\n    {0x2227, 0x222c},\n    {0x222e, 0x222e},\n    {0x2234, 0x2237},\n    {0x223c, 0x223d},\n    {0x2248, 0x2248},\n    {0x224c, 0x224c},\n    {0x2252, 0x2252},\n    {0x2260, 0x2261},\n    {0x2264, 0x2267},\n    {0x226a, 0x226b},\n    {0x226e, 0x226f},\n    {0x2282, 0x2283},\n    {0x2286, 0x2287},\n    {0x2295, 0x2295},\n    {0x2299, 0x2299},\n    {0x22a5, 0x22a5},\n    {0x22bf, 0x22bf},\n    {0x2312, 0x2312},\n    {0x2460, 0x24e9},\n    {0x24eb, 0x254b},\n    {0x2550, 0x2573},\n    {0x2580, 0x258f},\n    {0x2592, 0x2595},\n    {0x25a0, 0x25a1},\n    {0x25a3, 0x25a9},\n    {0x25b2, 0x25b3},\n    {0x25b6, 0x25b7},\n    {0x25bc, 0x25bd},\n    {0x25c0, 0x25c1},\n    {0x25c6, 0x25c8},\n    {0x25cb, 0x25cb},\n    {0x25ce, 0x25d1},\n    {0x25e2, 0x25e5},\n    {0x25ef, 0x25ef},\n    {0x2605, 0x2606},\n    {0x2609, 0x2609},\n    {0x260e, 0x260f},\n    {0x261c, 0x261c},\n    {0x261e, 0x261e},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2660, 0x2661},\n    {0x2663, 0x2665},\n    {0x2667, 0x266a},\n    {0x266c, 0x266d},\n    {0x266f, 0x266f},\n    {0x269e, 0x269f},\n    {0x26bf, 0x26bf},\n    {0x26c6, 0x26cd},\n    {0x26cf, 0x26d3},\n    {0x26d5, 0x26e1},\n    {0x26e3, 0x26e3},\n    {0x26e8, 0x26e9},\n    {0x26eb, 0x26f1},\n    {0x26f4, 0x26f4},\n    {0x26f6, 0x26f9},\n    {0x26fb, 0x26fc},\n    {0x26fe, 0x26ff},\n    {0x273d, 0x273d},\n    {0x2776, 0x277f},\n    {0x2b56, 0x2b59},\n    {0x3248, 0x324f},\n    {0xe000, 0xf8ff},\n    {0xfe00, 0xfe0f},\n    {0xfffd, 0xfffd},\n    {0x1f100, 0x1f10a},\n    {0x1f110, 0x1f12d},\n    {0x1f130, 0x1f169},\n    {0x1f170, 0x1f18d},\n    {0x1f18f, 0x1f190},\n    {0x1f19b, 0x1f1ac},\n    {0xe0100, 0xe01ef},\n    {0xf0000, 0xffffd},\n    {0x100000, 0x10fffd}\n};\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_char2cells() with different argument type for libvterm.\n */\n    int\nutf_uint2cells(UINT32_T c)\n{\n    if (c >= 0x100 && utf_iscomposing((int)c))\n\treturn 0;\n    return utf_char2cells((int)c);\n}\n#endif\n\n/*\n * For UTF-8 character \"c\" return 2 for a double-width character, 1 for others.\n * Returns 4 or 6 for an unprintable character.\n * Is only correct for characters >= 0x80.\n * When p_ambw is \"double\", return 2 for a character with East Asian Width\n * class 'A'(mbiguous).\n */\n    int\nutf_char2cells(int c)\n{\n    // Sorted list of non-overlapping intervals of East Asian double width\n    // characters, generated with ../runtime/tools/unicode.vim.\n    static struct interval doublewidth[] =\n    {\n\t{0x1100, 0x115f},\n\t{0x231a, 0x231b},\n\t{0x2329, 0x232a},\n\t{0x23e9, 0x23ec},\n\t{0x23f0, 0x23f0},\n\t{0x23f3, 0x23f3},\n\t{0x25fd, 0x25fe},\n\t{0x2614, 0x2615},\n\t{0x2648, 0x2653},\n\t{0x267f, 0x267f},\n\t{0x2693, 0x2693},\n\t{0x26a1, 0x26a1},\n\t{0x26aa, 0x26ab},\n\t{0x26bd, 0x26be},\n\t{0x26c4, 0x26c5},\n\t{0x26ce, 0x26ce},\n\t{0x26d4, 0x26d4},\n\t{0x26ea, 0x26ea},\n\t{0x26f2, 0x26f3},\n\t{0x26f5, 0x26f5},\n\t{0x26fa, 0x26fa},\n\t{0x26fd, 0x26fd},\n\t{0x2705, 0x2705},\n\t{0x270a, 0x270b},\n\t{0x2728, 0x2728},\n\t{0x274c, 0x274c},\n\t{0x274e, 0x274e},\n\t{0x2753, 0x2755},\n\t{0x2757, 0x2757},\n\t{0x2795, 0x2797},\n\t{0x27b0, 0x27b0},\n\t{0x27bf, 0x27bf},\n\t{0x2b1b, 0x2b1c},\n\t{0x2b50, 0x2b50},\n\t{0x2b55, 0x2b55},\n\t{0x2e80, 0x2e99},\n\t{0x2e9b, 0x2ef3},\n\t{0x2f00, 0x2fd5},\n\t{0x2ff0, 0x2ffb},\n\t{0x3000, 0x303e},\n\t{0x3041, 0x3096},\n\t{0x3099, 0x30ff},\n\t{0x3105, 0x312f},\n\t{0x3131, 0x318e},\n\t{0x3190, 0x31e3},\n\t{0x31f0, 0x321e},\n\t{0x3220, 0x3247},\n\t{0x3250, 0x4dbf},\n\t{0x4e00, 0xa48c},\n\t{0xa490, 0xa4c6},\n\t{0xa960, 0xa97c},\n\t{0xac00, 0xd7a3},\n\t{0xf900, 0xfaff},\n\t{0xfe10, 0xfe19},\n\t{0xfe30, 0xfe52},\n\t{0xfe54, 0xfe66},\n\t{0xfe68, 0xfe6b},\n\t{0xff01, 0xff60},\n\t{0xffe0, 0xffe6},\n\t{0x16fe0, 0x16fe3},\n\t{0x16ff0, 0x16ff1},\n\t{0x17000, 0x187f7},\n\t{0x18800, 0x18cd5},\n\t{0x18d00, 0x18d08},\n\t{0x1b000, 0x1b11e},\n\t{0x1b150, 0x1b152},\n\t{0x1b164, 0x1b167},\n\t{0x1b170, 0x1b2fb},\n\t{0x1f004, 0x1f004},\n\t{0x1f0cf, 0x1f0cf},\n\t{0x1f18e, 0x1f18e},\n\t{0x1f191, 0x1f19a},\n\t{0x1f200, 0x1f202},\n\t{0x1f210, 0x1f23b},\n\t{0x1f240, 0x1f248},\n\t{0x1f250, 0x1f251},\n\t{0x1f260, 0x1f265},\n\t{0x1f300, 0x1f320},\n\t{0x1f32d, 0x1f335},\n\t{0x1f337, 0x1f37c},\n\t{0x1f37e, 0x1f393},\n\t{0x1f3a0, 0x1f3ca},\n\t{0x1f3cf, 0x1f3d3},\n\t{0x1f3e0, 0x1f3f0},\n\t{0x1f3f4, 0x1f3f4},\n\t{0x1f3f8, 0x1f43e},\n\t{0x1f440, 0x1f440},\n\t{0x1f442, 0x1f4fc},\n\t{0x1f4ff, 0x1f53d},\n\t{0x1f54b, 0x1f54e},\n\t{0x1f550, 0x1f567},\n\t{0x1f57a, 0x1f57a},\n\t{0x1f595, 0x1f596},\n\t{0x1f5a4, 0x1f5a4},\n\t{0x1f5fb, 0x1f64f},\n\t{0x1f680, 0x1f6c5},\n\t{0x1f6cc, 0x1f6cc},\n\t{0x1f6d0, 0x1f6d2},\n\t{0x1f6d5, 0x1f6d7},\n\t{0x1f6eb, 0x1f6ec},\n\t{0x1f6f4, 0x1f6fc},\n\t{0x1f7e0, 0x1f7eb},\n\t{0x1f90c, 0x1f93a},\n\t{0x1f93c, 0x1f945},\n\t{0x1f947, 0x1f978},\n\t{0x1f97a, 0x1f9cb},\n\t{0x1f9cd, 0x1f9ff},\n\t{0x1fa70, 0x1fa74},\n\t{0x1fa78, 0x1fa7a},\n\t{0x1fa80, 0x1fa86},\n\t{0x1fa90, 0x1faa8},\n\t{0x1fab0, 0x1fab6},\n\t{0x1fac0, 0x1fac2},\n\t{0x1fad0, 0x1fad6},\n\t{0x20000, 0x2fffd},\n\t{0x30000, 0x3fffd}\n    };\n\n    // Sorted list of non-overlapping intervals of Emoji characters that don't\n    // have ambiguous or double width,\n    // based on http://unicode.org/emoji/charts/emoji-list.html\n    static struct interval emoji_wide[] =\n    {\n\t{0x23ed, 0x23ef},\n\t{0x23f1, 0x23f2},\n\t{0x23f8, 0x23fa},\n\t{0x24c2, 0x24c2},\n\t{0x261d, 0x261d},\n\t{0x26c8, 0x26c8},\n\t{0x26cf, 0x26cf},\n\t{0x26d1, 0x26d1},\n\t{0x26d3, 0x26d3},\n\t{0x26e9, 0x26e9},\n\t{0x26f0, 0x26f1},\n\t{0x26f7, 0x26f9},\n\t{0x270c, 0x270d},\n\t{0x2934, 0x2935},\n\t{0x1f170, 0x1f189},\n\t{0x1f1e6, 0x1f1ff},\n\t{0x1f321, 0x1f321},\n\t{0x1f324, 0x1f32c},\n\t{0x1f336, 0x1f336},\n\t{0x1f37d, 0x1f37d},\n\t{0x1f396, 0x1f397},\n\t{0x1f399, 0x1f39b},\n\t{0x1f39e, 0x1f39f},\n\t{0x1f3cb, 0x1f3ce},\n\t{0x1f3d4, 0x1f3df},\n\t{0x1f3f3, 0x1f3f5},\n\t{0x1f3f7, 0x1f3f7},\n\t{0x1f43f, 0x1f43f},\n\t{0x1f441, 0x1f441},\n\t{0x1f4fd, 0x1f4fd},\n\t{0x1f549, 0x1f54a},\n\t{0x1f56f, 0x1f570},\n\t{0x1f573, 0x1f579},\n\t{0x1f587, 0x1f587},\n\t{0x1f58a, 0x1f58d},\n\t{0x1f590, 0x1f590},\n\t{0x1f5a5, 0x1f5a5},\n\t{0x1f5a8, 0x1f5a8},\n\t{0x1f5b1, 0x1f5b2},\n\t{0x1f5bc, 0x1f5bc},\n\t{0x1f5c2, 0x1f5c4},\n\t{0x1f5d1, 0x1f5d3},\n\t{0x1f5dc, 0x1f5de},\n\t{0x1f5e1, 0x1f5e1},\n\t{0x1f5e3, 0x1f5e3},\n\t{0x1f5e8, 0x1f5e8},\n\t{0x1f5ef, 0x1f5ef},\n\t{0x1f5f3, 0x1f5f3},\n\t{0x1f5fa, 0x1f5fa},\n\t{0x1f6cb, 0x1f6cf},\n\t{0x1f6e0, 0x1f6e5},\n\t{0x1f6e9, 0x1f6e9},\n\t{0x1f6f0, 0x1f6f0},\n\t{0x1f6f3, 0x1f6f3}\n\n#ifdef MACOS_X\n\t// Include SF Symbols characters, which should be rendered as\n\t// double-width. All of them are in the Supplementary Private Use\n\t// Area-B range. The exact range was determined by downloading the \"SF\n\t// Symbols\" app from Apple, and then selecting all symbols, copying\n\t// them out, and inspecting the unicode values of them.\n\t, {0x100000, 0x100d7f}\n#endif\n    };\n\n    if (c >= 0x100)\n    {\n#if defined(FEAT_EVAL) || defined(USE_WCHAR_FUNCTIONS)\n\tint\tn;\n#endif\n\n#ifdef FEAT_EVAL\n\tn = cw_value(c);\n\tif (n != 0)\n\t    return n;\n#endif\n\n#ifdef USE_WCHAR_FUNCTIONS\n\t/*\n\t * Assume the library function wcwidth() works better than our own\n\t * stuff.  It should return 1 for ambiguous width chars!\n\t */\n\tn = wcwidth(c);\n\n\tif (n < 0)\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (n > 1)\n\t    return n;\n#else\n\tif (!utf_printable(c))\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (intable(doublewidth, sizeof(doublewidth), c))\n\t    return 2;\n#endif\n\tif (p_emoji && intable(emoji_wide, sizeof(emoji_wide), c))\n\t    return 2;\n    }\n\n    // Characters below 0x100 are influenced by 'isprint' option\n    else if (c >= 0x80 && !vim_isprintc(c))\n\treturn 4;\t\t// unprintable, displays <xx>\n\n    if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, sizeof(ambiguous), c))\n\treturn 2;\n\n    return 1;\n}\n\n/*\n * mb_ptr2cells() function pointer.\n * Return the number of display cells character at \"*p\" occupies.\n * This doesn't take care of unprintable characters, use ptr2cells() for that.\n */\n    int\nlatin_ptr2cells(char_u *p UNUSED)\n{\n    return 1;\n}\n\n    int\nutf_ptr2cells(\n    char_u\t*p)\n{\n    int\t\tc;\n\n    // Need to convert to a character number.\n    if (*p >= 0x80)\n    {\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    int\ndbcs_ptr2cells(char_u *p)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_ptr2cells_len() function pointer.\n * Like mb_ptr2cells(), but limit string length to \"size\".\n * For an empty string or truncated character returns 1.\n */\n    int\nlatin_ptr2cells_len(char_u *p UNUSED, int size UNUSED)\n{\n    return 1;\n}\n\n    static int\nutf_ptr2cells_len(char_u *p, int size)\n{\n    int\t\tc;\n\n    // Need to convert to a wide character.\n    if (size > 0 && *p >= 0x80)\n    {\n\tif (utf_ptr2len_len(p, size) < utf8len_tab[*p])\n\t    return 1;  // truncated\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    static int\ndbcs_ptr2cells_len(char_u *p, int size)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_char2cells() function pointer.\n * Return the number of display cells character \"c\" occupies.\n * Only takes care of multi-byte chars, not \"^C\" and such.\n */\n    int\nlatin_char2cells(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2cells(int c)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\treturn 1;\n    // use the first byte\n    return MB_BYTE2LEN((unsigned)c >> 8);\n}\n\n/*\n * Return the number of cells occupied by string \"p\".\n * Stop at a NUL character.  When \"len\" >= 0 stop at character \"p[len]\".\n */\n    int\nmb_string2cells(char_u *p, int len)\n{\n    int i;\n    int clen = 0;\n\n    for (i = 0; (len < 0 || i < len) && p[i] != NUL; i += (*mb_ptr2len)(p + i))\n\tclen += (*mb_ptr2cells)(p + i);\n    return clen;\n}\n\n/*\n * mb_off2cells() function pointer.\n * Return number of display cells for char at ScreenLines[off].\n * We make sure that the offset used is less than \"max_off\".\n */\n    int\nlatin_off2cells(unsigned off UNUSED, unsigned max_off UNUSED)\n{\n    return 1;\n}\n\n    int\ndbcs_off2cells(unsigned off, unsigned max_off)\n{\n    // never check beyond end of the line\n    if (off >= max_off)\n\treturn 1;\n\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(ScreenLines[off]);\n}\n\n    int\nutf_off2cells(unsigned off, unsigned max_off)\n{\n    return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;\n}\n\n/*\n * mb_ptr2char() function pointer.\n * Convert a byte sequence into a character.\n */\n    int\nlatin_ptr2char(char_u *p)\n{\n    return *p;\n}\n\n    static int\ndbcs_ptr2char(char_u *p)\n{\n    if (MB_BYTE2LEN(*p) > 1 && p[1] != NUL)\n\treturn (p[0] << 8) + p[1];\n    return *p;\n}\n\n/*\n * Convert a UTF-8 byte sequence to a character number.\n * If the sequence is illegal or truncated by a NUL the first byte is\n * returned.\n * For an overlong sequence this may return zero.\n * Does not include composing characters, of course.\n */\n    int\nutf_ptr2char(char_u *p)\n{\n    int\t\tlen;\n\n    if (p[0] < 0x80)\t// be quick for ASCII\n\treturn p[0];\n\n    len = utf8len_tab_zero[p[0]];\n    if (len > 1 && (p[1] & 0xc0) == 0x80)\n    {\n\tif (len == 2)\n\t    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n\tif ((p[2] & 0xc0) == 0x80)\n\t{\n\t    if (len == 3)\n\t\treturn ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n\t\t    + (p[2] & 0x3f);\n\t    if ((p[3] & 0xc0) == 0x80)\n\t    {\n\t\tif (len == 4)\n\t\t    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n\t\t\t+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);\n\t\tif ((p[4] & 0xc0) == 0x80)\n\t\t{\n\t\t    if (len == 5)\n\t\t\treturn ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n\t\t\t    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n\t\t\t    + (p[4] & 0x3f);\n\t\t    if ((p[5] & 0xc0) == 0x80 && len == 6)\n\t\t\treturn ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n\t\t\t    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n\t\t\t    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);\n\t\t}\n\t    }\n\t}\n    }\n    // Illegal value, just return the first byte\n    return p[0];\n}\n\n/*\n * Convert a UTF-8 byte sequence to a wide character.\n * String is assumed to be terminated by NUL or after \"n\" bytes, whichever\n * comes first.\n * The function is safe in the sense that it never accesses memory beyond the\n * first \"n\" bytes of \"s\".\n *\n * On success, returns decoded codepoint, advances \"s\" to the beginning of\n * next character and decreases \"n\" accordingly.\n *\n * If end of string was reached, returns 0 and, if \"n\" > 0, advances \"s\" past\n * NUL byte.\n *\n * If byte sequence is illegal or incomplete, returns -1 and does not advance\n * \"s\".\n */\n    static int\nutf_safe_read_char_adv(char_u **s, size_t *n)\n{\n    int\t\tc, k;\n\n    if (*n == 0) // end of buffer\n\treturn 0;\n\n    k = utf8len_tab_zero[**s];\n\n    if (k == 1)\n    {\n\t// ASCII character or NUL\n\t(*n)--;\n\treturn *(*s)++;\n    }\n\n    if ((size_t)k <= *n)\n    {\n\t// We have a multibyte sequence and it isn't truncated by buffer\n\t// limits so utf_ptr2char() is safe to use. Or the first byte is\n\t// illegal (k=0), and it's also safe to use utf_ptr2char().\n\tc = utf_ptr2char(*s);\n\n\t// On failure, utf_ptr2char() returns the first byte, so here we\n\t// check equality with the first byte. The only non-ASCII character\n\t// which equals the first byte of its own UTF-8 representation is\n\t// U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.\n\t// It's safe even if n=1, else we would have k=2 > n.\n\tif (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83))\n\t{\n\t    // byte sequence was successfully decoded\n\t    *s += k;\n\t    *n -= k;\n\t    return c;\n\t}\n    }\n\n    // byte sequence is incomplete or illegal\n    return -1;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are skipped!\n */\n    int\nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are returned as separate characters.\n */\n    int\nmb_cptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    if (enc_utf8)\n\t*pp += utf_ptr2len(*pp);\n    else\n\t*pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\n/*\n * Check if the character pointed to by \"p2\" is a composing character when it\n * comes after \"p1\".  For Arabic sometimes \"ab\" is replaced with \"c\", which\n * behaves like a composing character.\n */\n    int\nutf_composinglike(char_u *p1, char_u *p2)\n{\n    int\t\tc2;\n\n    c2 = utf_ptr2char(p2);\n    if (utf_iscomposing(c2))\n\treturn TRUE;\n    if (!arabic_maycombine(c2))\n\treturn FALSE;\n    return arabic_combine(utf_ptr2char(p1), c2);\n}\n#endif\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.\n */\n    int\nutfc_ptr2char(\n    char_u\t*p,\n    int\t\t*pcc)\t// return: composing chars, last one is 0\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len(p);\n\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len(p + len);\n\t    if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.  Use no more than p[maxlen].\n */\n    int\nutfc_ptr2char_len(\n    char_u\t*p,\n    int\t\t*pcc,\t// return: composing chars, last one is 0\n    int\t\tmaxlen)\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len_len(p, maxlen);\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && len < maxlen\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len_len(p + len, maxlen - len);\n\t    if (len >= maxlen\n\t\t    || p[len] < 0x80\n\t\t    || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert the character at screen position \"off\" to a sequence of bytes.\n * Includes the composing characters.\n * \"buf\" must at least have the length MB_MAXBYTES + 1.\n * Only to be used when ScreenLinesUC[off] != 0.\n * Returns the produced number of bytes.\n */\n    int\nutfc_char2bytes(int off, char_u *buf)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    len = utf_char2bytes(ScreenLinesUC[off], buf);\n    for (i = 0; i < Screen_mco; ++i)\n    {\n\tif (ScreenLinesC[i][off] == 0)\n\t    break;\n\tlen += utf_char2bytes(ScreenLinesC[i][off], buf + len);\n    }\n    return len;\n}\n\n/*\n * Get the length of a UTF-8 byte sequence, not including any following\n * composing characters.\n * Returns 0 for \"\".\n * Returns 1 for an illegal byte sequence.\n */\n    int\nutf_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    if (*p == NUL)\n\treturn 0;\n    len = utf8len_tab[*p];\n    for (i = 1; i < len; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return length of UTF-8 character, obtained from the first byte.\n * \"b\" must be between 0 and 255!\n * Returns 1 for an invalid first byte value.\n */\n    int\nutf_byte2len(int b)\n{\n    return utf8len_tab[b];\n}\n\n/*\n * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any\n * following composing characters.\n * Returns 1 for \"\".\n * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).\n * Returns number > \"size\" for an incomplete byte sequence.\n * Never returns zero.\n */\n    int\nutf_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tm;\n\n    len = utf8len_tab[*p];\n    if (len == 1)\n\treturn 1;\t// NUL, ascii or illegal lead byte\n    if (len > size)\n\tm = size;\t// incomplete byte sequence.\n    else\n\tm = len;\n    for (i = 1; i < m; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p\" takes.\n * This includes following composing characters.\n */\n    int\nutfc_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\tb0 = *p;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (b0 == NUL)\n\treturn 0;\n    if (b0 < 0x80 && p[1] < 0x80)\t// be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len(p);\n\n    // Check for illegal byte.\n    if (len == 1 && b0 >= 0x80)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    for (;;)\n    {\n\tif (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    return len;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += utf_ptr2len(p + len);\n    }\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\"\n * takes.  This includes following composing characters.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nutfc_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) // be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len_len(p, size);\n\n    // Check for illegal byte and incomplete byte sequence.\n    if ((len == 1 && p[0] >= 0x80) || len > size)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    while (len < size)\n    {\n\tint\tlen_next_char;\n\n\tif (p[len] < 0x80)\n\t    break;\n\n\t/*\n\t * Next character length should not go beyond size to ensure that\n\t * UTF_COMPOSINGLIKE(...) does not read beyond size.\n\t */\n\tlen_next_char = utf_ptr2len_len(p + len, size - len);\n\tif (len_next_char > size - len)\n\t    break;\n\n\tif (!UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    break;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += len_next_char;\n    }\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of character \"c\" takes.\n * This does not include composing characters.\n */\n    int\nutf_char2len(int c)\n{\n    if (c < 0x80)\n\treturn 1;\n    if (c < 0x800)\n\treturn 2;\n    if (c < 0x10000)\n\treturn 3;\n    if (c < 0x200000)\n\treturn 4;\n    if (c < 0x4000000)\n\treturn 5;\n    return 6;\n}\n\n/*\n * Convert Unicode character \"c\" to UTF-8 string in \"buf[]\".\n * Returns the number of bytes.\n */\n    int\nutf_char2bytes(int c, char_u *buf)\n{\n    if (c < 0x80)\t\t// 7 bits\n    {\n\tbuf[0] = c;\n\treturn 1;\n    }\n    if (c < 0x800)\t\t// 11 bits\n    {\n\tbuf[0] = 0xc0 + ((unsigned)c >> 6);\n\tbuf[1] = 0x80 + (c & 0x3f);\n\treturn 2;\n    }\n    if (c < 0x10000)\t\t// 16 bits\n    {\n\tbuf[0] = 0xe0 + ((unsigned)c >> 12);\n\tbuf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[2] = 0x80 + (c & 0x3f);\n\treturn 3;\n    }\n    if (c < 0x200000)\t\t// 21 bits\n    {\n\tbuf[0] = 0xf0 + ((unsigned)c >> 18);\n\tbuf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[3] = 0x80 + (c & 0x3f);\n\treturn 4;\n    }\n    if (c < 0x4000000)\t\t// 26 bits\n    {\n\tbuf[0] = 0xf8 + ((unsigned)c >> 24);\n\tbuf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[4] = 0x80 + (c & 0x3f);\n\treturn 5;\n    }\n\t\t\t\t// 31 bits\n    buf[0] = 0xfc + ((unsigned)c >> 30);\n    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[5] = 0x80 + (c & 0x3f);\n    return 6;\n}\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_iscomposing() with different argument type for libvterm.\n */\n    int\nutf_iscomposing_uint(UINT32_T c)\n{\n    return utf_iscomposing((int)c);\n}\n#endif\n\n/*\n * Return TRUE if \"c\" is a composing UTF-8 character.  This means it will be\n * drawn on top of the preceding character.\n * Based on code from Markus Kuhn.\n */\n    int\nutf_iscomposing(int c)\n{\n    // Sorted list of non-overlapping intervals.\n    // Generated by ../runtime/tools/unicode.vim.\n    static struct interval combining[] =\n    {\n\t{0x0300, 0x036f},\n\t{0x0483, 0x0489},\n\t{0x0591, 0x05bd},\n\t{0x05bf, 0x05bf},\n\t{0x05c1, 0x05c2},\n\t{0x05c4, 0x05c5},\n\t{0x05c7, 0x05c7},\n\t{0x0610, 0x061a},\n\t{0x064b, 0x065f},\n\t{0x0670, 0x0670},\n\t{0x06d6, 0x06dc},\n\t{0x06df, 0x06e4},\n\t{0x06e7, 0x06e8},\n\t{0x06ea, 0x06ed},\n\t{0x0711, 0x0711},\n\t{0x0730, 0x074a},\n\t{0x07a6, 0x07b0},\n\t{0x07eb, 0x07f3},\n\t{0x07fd, 0x07fd},\n\t{0x0816, 0x0819},\n\t{0x081b, 0x0823},\n\t{0x0825, 0x0827},\n\t{0x0829, 0x082d},\n\t{0x0859, 0x085b},\n\t{0x08d3, 0x08e1},\n\t{0x08e3, 0x0903},\n\t{0x093a, 0x093c},\n\t{0x093e, 0x094f},\n\t{0x0951, 0x0957},\n\t{0x0962, 0x0963},\n\t{0x0981, 0x0983},\n\t{0x09bc, 0x09bc},\n\t{0x09be, 0x09c4},\n\t{0x09c7, 0x09c8},\n\t{0x09cb, 0x09cd},\n\t{0x09d7, 0x09d7},\n\t{0x09e2, 0x09e3},\n\t{0x09fe, 0x09fe},\n\t{0x0a01, 0x0a03},\n\t{0x0a3c, 0x0a3c},\n\t{0x0a3e, 0x0a42},\n\t{0x0a47, 0x0a48},\n\t{0x0a4b, 0x0a4d},\n\t{0x0a51, 0x0a51},\n\t{0x0a70, 0x0a71},\n\t{0x0a75, 0x0a75},\n\t{0x0a81, 0x0a83},\n\t{0x0abc, 0x0abc},\n\t{0x0abe, 0x0ac5},\n\t{0x0ac7, 0x0ac9},\n\t{0x0acb, 0x0acd},\n\t{0x0ae2, 0x0ae3},\n\t{0x0afa, 0x0aff},\n\t{0x0b01, 0x0b03},\n\t{0x0b3c, 0x0b3c},\n\t{0x0b3e, 0x0b44},\n\t{0x0b47, 0x0b48},\n\t{0x0b4b, 0x0b4d},\n\t{0x0b55, 0x0b57},\n\t{0x0b62, 0x0b63},\n\t{0x0b82, 0x0b82},\n\t{0x0bbe, 0x0bc2},\n\t{0x0bc6, 0x0bc8},\n\t{0x0bca, 0x0bcd},\n\t{0x0bd7, 0x0bd7},\n\t{0x0c00, 0x0c04},\n\t{0x0c3e, 0x0c44},\n\t{0x0c46, 0x0c48},\n\t{0x0c4a, 0x0c4d},\n\t{0x0c55, 0x0c56},\n\t{0x0c62, 0x0c63},\n\t{0x0c81, 0x0c83},\n\t{0x0cbc, 0x0cbc},\n\t{0x0cbe, 0x0cc4},\n\t{0x0cc6, 0x0cc8},\n\t{0x0cca, 0x0ccd},\n\t{0x0cd5, 0x0cd6},\n\t{0x0ce2, 0x0ce3},\n\t{0x0d00, 0x0d03},\n\t{0x0d3b, 0x0d3c},\n\t{0x0d3e, 0x0d44},\n\t{0x0d46, 0x0d48},\n\t{0x0d4a, 0x0d4d},\n\t{0x0d57, 0x0d57},\n\t{0x0d62, 0x0d63},\n\t{0x0d81, 0x0d83},\n\t{0x0dca, 0x0dca},\n\t{0x0dcf, 0x0dd4},\n\t{0x0dd6, 0x0dd6},\n\t{0x0dd8, 0x0ddf},\n\t{0x0df2, 0x0df3},\n\t{0x0e31, 0x0e31},\n\t{0x0e34, 0x0e3a},\n\t{0x0e47, 0x0e4e},\n\t{0x0eb1, 0x0eb1},\n\t{0x0eb4, 0x0ebc},\n\t{0x0ec8, 0x0ecd},\n\t{0x0f18, 0x0f19},\n\t{0x0f35, 0x0f35},\n\t{0x0f37, 0x0f37},\n\t{0x0f39, 0x0f39},\n\t{0x0f3e, 0x0f3f},\n\t{0x0f71, 0x0f84},\n\t{0x0f86, 0x0f87},\n\t{0x0f8d, 0x0f97},\n\t{0x0f99, 0x0fbc},\n\t{0x0fc6, 0x0fc6},\n\t{0x102b, 0x103e},\n\t{0x1056, 0x1059},\n\t{0x105e, 0x1060},\n\t{0x1062, 0x1064},\n\t{0x1067, 0x106d},\n\t{0x1071, 0x1074},\n\t{0x1082, 0x108d},\n\t{0x108f, 0x108f},\n\t{0x109a, 0x109d},\n\t{0x135d, 0x135f},\n\t{0x1712, 0x1714},\n\t{0x1732, 0x1734},\n\t{0x1752, 0x1753},\n\t{0x1772, 0x1773},\n\t{0x17b4, 0x17d3},\n\t{0x17dd, 0x17dd},\n\t{0x180b, 0x180d},\n\t{0x1885, 0x1886},\n\t{0x18a9, 0x18a9},\n\t{0x1920, 0x192b},\n\t{0x1930, 0x193b},\n\t{0x1a17, 0x1a1b},\n\t{0x1a55, 0x1a5e},\n\t{0x1a60, 0x1a7c},\n\t{0x1a7f, 0x1a7f},\n\t{0x1ab0, 0x1ac0},\n\t{0x1b00, 0x1b04},\n\t{0x1b34, 0x1b44},\n\t{0x1b6b, 0x1b73},\n\t{0x1b80, 0x1b82},\n\t{0x1ba1, 0x1bad},\n\t{0x1be6, 0x1bf3},\n\t{0x1c24, 0x1c37},\n\t{0x1cd0, 0x1cd2},\n\t{0x1cd4, 0x1ce8},\n\t{0x1ced, 0x1ced},\n\t{0x1cf4, 0x1cf4},\n\t{0x1cf7, 0x1cf9},\n\t{0x1dc0, 0x1df9},\n\t{0x1dfb, 0x1dff},\n\t{0x20d0, 0x20f0},\n\t{0x2cef, 0x2cf1},\n\t{0x2d7f, 0x2d7f},\n\t{0x2de0, 0x2dff},\n\t{0x302a, 0x302f},\n\t{0x3099, 0x309a},\n\t{0xa66f, 0xa672},\n\t{0xa674, 0xa67d},\n\t{0xa69e, 0xa69f},\n\t{0xa6f0, 0xa6f1},\n\t{0xa802, 0xa802},\n\t{0xa806, 0xa806},\n\t{0xa80b, 0xa80b},\n\t{0xa823, 0xa827},\n\t{0xa82c, 0xa82c},\n\t{0xa880, 0xa881},\n\t{0xa8b4, 0xa8c5},\n\t{0xa8e0, 0xa8f1},\n\t{0xa8ff, 0xa8ff},\n\t{0xa926, 0xa92d},\n\t{0xa947, 0xa953},\n\t{0xa980, 0xa983},\n\t{0xa9b3, 0xa9c0},\n\t{0xa9e5, 0xa9e5},\n\t{0xaa29, 0xaa36},\n\t{0xaa43, 0xaa43},\n\t{0xaa4c, 0xaa4d},\n\t{0xaa7b, 0xaa7d},\n\t{0xaab0, 0xaab0},\n\t{0xaab2, 0xaab4},\n\t{0xaab7, 0xaab8},\n\t{0xaabe, 0xaabf},\n\t{0xaac1, 0xaac1},\n\t{0xaaeb, 0xaaef},\n\t{0xaaf5, 0xaaf6},\n\t{0xabe3, 0xabea},\n\t{0xabec, 0xabed},\n\t{0xfb1e, 0xfb1e},\n\t{0xfe00, 0xfe0f},\n\t{0xfe20, 0xfe2f},\n\t{0x101fd, 0x101fd},\n\t{0x102e0, 0x102e0},\n\t{0x10376, 0x1037a},\n\t{0x10a01, 0x10a03},\n\t{0x10a05, 0x10a06},\n\t{0x10a0c, 0x10a0f},\n\t{0x10a38, 0x10a3a},\n\t{0x10a3f, 0x10a3f},\n\t{0x10ae5, 0x10ae6},\n\t{0x10d24, 0x10d27},\n\t{0x10eab, 0x10eac},\n\t{0x10f46, 0x10f50},\n\t{0x11000, 0x11002},\n\t{0x11038, 0x11046},\n\t{0x1107f, 0x11082},\n\t{0x110b0, 0x110ba},\n\t{0x11100, 0x11102},\n\t{0x11127, 0x11134},\n\t{0x11145, 0x11146},\n\t{0x11173, 0x11173},\n\t{0x11180, 0x11182},\n\t{0x111b3, 0x111c0},\n\t{0x111c9, 0x111cc},\n\t{0x111ce, 0x111cf},\n\t{0x1122c, 0x11237},\n\t{0x1123e, 0x1123e},\n\t{0x112df, 0x112ea},\n\t{0x11300, 0x11303},\n\t{0x1133b, 0x1133c},\n\t{0x1133e, 0x11344},\n\t{0x11347, 0x11348},\n\t{0x1134b, 0x1134d},\n\t{0x11357, 0x11357},\n\t{0x11362, 0x11363},\n\t{0x11366, 0x1136c},\n\t{0x11370, 0x11374},\n\t{0x11435, 0x11446},\n\t{0x1145e, 0x1145e},\n\t{0x114b0, 0x114c3},\n\t{0x115af, 0x115b5},\n\t{0x115b8, 0x115c0},\n\t{0x115dc, 0x115dd},\n\t{0x11630, 0x11640},\n\t{0x116ab, 0x116b7},\n\t{0x1171d, 0x1172b},\n\t{0x1182c, 0x1183a},\n\t{0x11930, 0x11935},\n\t{0x11937, 0x11938},\n\t{0x1193b, 0x1193e},\n\t{0x11940, 0x11940},\n\t{0x11942, 0x11943},\n\t{0x119d1, 0x119d7},\n\t{0x119da, 0x119e0},\n\t{0x119e4, 0x119e4},\n\t{0x11a01, 0x11a0a},\n\t{0x11a33, 0x11a39},\n\t{0x11a3b, 0x11a3e},\n\t{0x11a47, 0x11a47},\n\t{0x11a51, 0x11a5b},\n\t{0x11a8a, 0x11a99},\n\t{0x11c2f, 0x11c36},\n\t{0x11c38, 0x11c3f},\n\t{0x11c92, 0x11ca7},\n\t{0x11ca9, 0x11cb6},\n\t{0x11d31, 0x11d36},\n\t{0x11d3a, 0x11d3a},\n\t{0x11d3c, 0x11d3d},\n\t{0x11d3f, 0x11d45},\n\t{0x11d47, 0x11d47},\n\t{0x11d8a, 0x11d8e},\n\t{0x11d90, 0x11d91},\n\t{0x11d93, 0x11d97},\n\t{0x11ef3, 0x11ef6},\n\t{0x16af0, 0x16af4},\n\t{0x16b30, 0x16b36},\n\t{0x16f4f, 0x16f4f},\n\t{0x16f51, 0x16f87},\n\t{0x16f8f, 0x16f92},\n\t{0x16fe4, 0x16fe4},\n\t{0x16ff0, 0x16ff1},\n\t{0x1bc9d, 0x1bc9e},\n\t{0x1d165, 0x1d169},\n\t{0x1d16d, 0x1d172},\n\t{0x1d17b, 0x1d182},\n\t{0x1d185, 0x1d18b},\n\t{0x1d1aa, 0x1d1ad},\n\t{0x1d242, 0x1d244},\n\t{0x1da00, 0x1da36},\n\t{0x1da3b, 0x1da6c},\n\t{0x1da75, 0x1da75},\n\t{0x1da84, 0x1da84},\n\t{0x1da9b, 0x1da9f},\n\t{0x1daa1, 0x1daaf},\n\t{0x1e000, 0x1e006},\n\t{0x1e008, 0x1e018},\n\t{0x1e01b, 0x1e021},\n\t{0x1e023, 0x1e024},\n\t{0x1e026, 0x1e02a},\n\t{0x1e130, 0x1e136},\n\t{0x1e2ec, 0x1e2ef},\n\t{0x1e8d0, 0x1e8d6},\n\t{0x1e944, 0x1e94a},\n\t{0xe0100, 0xe01ef}\n    };\n\n    return intable(combining, sizeof(combining), c);\n}\n\n/*\n * Return TRUE for characters that can be displayed in a normal way.\n * Only for characters of 0x100 and above!\n */\n    int\nutf_printable(int c)\n{\n#ifdef USE_WCHAR_FUNCTIONS\n    /*\n     * Assume the iswprint() library function works better than our own stuff.\n     */\n    return iswprint(c);\n#else\n    // Sorted list of non-overlapping intervals.\n    // 0xd800-0xdfff is reserved for UTF-16, actually illegal.\n    static struct interval nonprint[] =\n    {\n\t{0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},\n\t{0x2060, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},\n\t{0xfffe, 0xffff}\n    };\n\n    return !intable(nonprint, sizeof(nonprint), c);\n#endif\n}\n\n// Sorted list of non-overlapping intervals of all Emoji characters,\n// based on http://unicode.org/emoji/charts/emoji-list.html\n// Generated by ../runtime/tools/unicode.vim.\n// Excludes 0x00a9 and 0x00ae because they are considered latin1.\nstatic struct interval emoji_all[] =\n{\n    {0x203c, 0x203c},\n    {0x2049, 0x2049},\n    {0x2122, 0x2122},\n    {0x2139, 0x2139},\n    {0x2194, 0x2199},\n    {0x21a9, 0x21aa},\n    {0x231a, 0x231b},\n    {0x2328, 0x2328},\n    {0x23cf, 0x23cf},\n    {0x23e9, 0x23f3},\n    {0x23f8, 0x23fa},\n    {0x24c2, 0x24c2},\n    {0x25aa, 0x25ab},\n    {0x25b6, 0x25b6},\n    {0x25c0, 0x25c0},\n    {0x25fb, 0x25fe},\n    {0x2600, 0x2604},\n    {0x260e, 0x260e},\n    {0x2611, 0x2611},\n    {0x2614, 0x2615},\n    {0x2618, 0x2618},\n    {0x261d, 0x261d},\n    {0x2620, 0x2620},\n    {0x2622, 0x2623},\n    {0x2626, 0x2626},\n    {0x262a, 0x262a},\n    {0x262e, 0x262f},\n    {0x2638, 0x263a},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2648, 0x2653},\n    {0x265f, 0x2660},\n    {0x2663, 0x2663},\n    {0x2665, 0x2666},\n    {0x2668, 0x2668},\n    {0x267b, 0x267b},\n    {0x267e, 0x267f},\n    {0x2692, 0x2697},\n    {0x2699, 0x2699},\n    {0x269b, 0x269c},\n    {0x26a0, 0x26a1},\n    {0x26a7, 0x26a7},\n    {0x26aa, 0x26ab},\n    {0x26b0, 0x26b1},\n    {0x26bd, 0x26be},\n    {0x26c4, 0x26c5},\n    {0x26c8, 0x26c8},\n    {0x26ce, 0x26cf},\n    {0x26d1, 0x26d1},\n    {0x26d3, 0x26d4},\n    {0x26e9, 0x26ea},\n    {0x26f0, 0x26f5},\n    {0x26f7, 0x26fa},\n    {0x26fd, 0x26fd},\n    {0x2702, 0x2702},\n    {0x2705, 0x2705},\n    {0x2708, 0x270d},\n    {0x270f, 0x270f},\n    {0x2712, 0x2712},\n    {0x2714, 0x2714},\n    {0x2716, 0x2716},\n    {0x271d, 0x271d},\n    {0x2721, 0x2721},\n    {0x2728, 0x2728},\n    {0x2733, 0x2734},\n    {0x2744, 0x2744},\n    {0x2747, 0x2747},\n    {0x274c, 0x274c},\n    {0x274e, 0x274e},\n    {0x2753, 0x2755},\n    {0x2757, 0x2757},\n    {0x2763, 0x2764},\n    {0x2795, 0x2797},\n    {0x27a1, 0x27a1},\n    {0x27b0, 0x27b0},\n    {0x27bf, 0x27bf},\n    {0x2934, 0x2935},\n    {0x2b05, 0x2b07},\n    {0x2b1b, 0x2b1c},\n    {0x2b50, 0x2b50},\n    {0x2b55, 0x2b55},\n    {0x3030, 0x3030},\n    {0x303d, 0x303d},\n    {0x3297, 0x3297},\n    {0x3299, 0x3299},\n    {0x1f004, 0x1f004},\n    {0x1f0cf, 0x1f0cf},\n    {0x1f170, 0x1f171},\n    {0x1f17e, 0x1f17f},\n    {0x1f18e, 0x1f18e},\n    {0x1f191, 0x1f19a},\n    {0x1f1e6, 0x1f1ff},\n    {0x1f201, 0x1f202},\n    {0x1f21a, 0x1f21a},\n    {0x1f22f, 0x1f22f},\n    {0x1f232, 0x1f23a},\n    {0x1f250, 0x1f251},\n    {0x1f300, 0x1f321},\n    {0x1f324, 0x1f393},\n    {0x1f396, 0x1f397},\n    {0x1f399, 0x1f39b},\n    {0x1f39e, 0x1f3f0},\n    {0x1f3f3, 0x1f3f5},\n    {0x1f3f7, 0x1f4fd},\n    {0x1f4ff, 0x1f53d},\n    {0x1f549, 0x1f54e},\n    {0x1f550, 0x1f567},\n    {0x1f56f, 0x1f570},\n    {0x1f573, 0x1f57a},\n    {0x1f587, 0x1f587},\n    {0x1f58a, 0x1f58d},\n    {0x1f590, 0x1f590},\n    {0x1f595, 0x1f596},\n    {0x1f5a4, 0x1f5a5},\n    {0x1f5a8, 0x1f5a8},\n    {0x1f5b1, 0x1f5b2},\n    {0x1f5bc, 0x1f5bc},\n    {0x1f5c2, 0x1f5c4},\n    {0x1f5d1, 0x1f5d3},\n    {0x1f5dc, 0x1f5de},\n    {0x1f5e1, 0x1f5e1},\n    {0x1f5e3, 0x1f5e3},\n    {0x1f5e8, 0x1f5e8},\n    {0x1f5ef, 0x1f5ef},\n    {0x1f5f3, 0x1f5f3},\n    {0x1f5fa, 0x1f64f},\n    {0x1f680, 0x1f6c5},\n    {0x1f6cb, 0x1f6d2},\n    {0x1f6d5, 0x1f6d7},\n    {0x1f6e0, 0x1f6e5},\n    {0x1f6e9, 0x1f6e9},\n    {0x1f6eb, 0x1f6ec},\n    {0x1f6f0, 0x1f6f0},\n    {0x1f6f3, 0x1f6fc},\n    {0x1f7e0, 0x1f7eb},\n    {0x1f90c, 0x1f93a},\n    {0x1f93c, 0x1f945},\n    {0x1f947, 0x1f978},\n    {0x1f97a, 0x1f9cb},\n    {0x1f9cd, 0x1f9ff},\n    {0x1fa70, 0x1fa74},\n    {0x1fa78, 0x1fa7a},\n    {0x1fa80, 0x1fa86},\n    {0x1fa90, 0x1faa8},\n    {0x1fab0, 0x1fab6},\n    {0x1fac0, 0x1fac2},\n    {0x1fad0, 0x1fad6}\n};\n\n/*\n * Get class of a Unicode character.\n * 0: white space\n * 1: punctuation\n * 2 or bigger: some class of word character.\n */\n    int\nutf_class(int c)\n{\n    return utf_class_buf(c, curbuf);\n}\n\n    int\nutf_class_buf(int c, buf_T *buf)\n{\n    // sorted list of non-overlapping intervals\n    static struct clinterval\n    {\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int class;\n    } classes[] =\n    {\n\t{0x037e, 0x037e, 1},\t\t// Greek question mark\n\t{0x0387, 0x0387, 1},\t\t// Greek ano teleia\n\t{0x055a, 0x055f, 1},\t\t// Armenian punctuation\n\t{0x0589, 0x0589, 1},\t\t// Armenian full stop\n\t{0x05be, 0x05be, 1},\n\t{0x05c0, 0x05c0, 1},\n\t{0x05c3, 0x05c3, 1},\n\t{0x05f3, 0x05f4, 1},\n\t{0x060c, 0x060c, 1},\n\t{0x061b, 0x061b, 1},\n\t{0x061f, 0x061f, 1},\n\t{0x066a, 0x066d, 1},\n\t{0x06d4, 0x06d4, 1},\n\t{0x0700, 0x070d, 1},\t\t// Syriac punctuation\n\t{0x0964, 0x0965, 1},\n\t{0x0970, 0x0970, 1},\n\t{0x0df4, 0x0df4, 1},\n\t{0x0e4f, 0x0e4f, 1},\n\t{0x0e5a, 0x0e5b, 1},\n\t{0x0f04, 0x0f12, 1},\n\t{0x0f3a, 0x0f3d, 1},\n\t{0x0f85, 0x0f85, 1},\n\t{0x104a, 0x104f, 1},\t\t// Myanmar punctuation\n\t{0x10fb, 0x10fb, 1},\t\t// Georgian punctuation\n\t{0x1361, 0x1368, 1},\t\t// Ethiopic punctuation\n\t{0x166d, 0x166e, 1},\t\t// Canadian Syl. punctuation\n\t{0x1680, 0x1680, 0},\n\t{0x169b, 0x169c, 1},\n\t{0x16eb, 0x16ed, 1},\n\t{0x1735, 0x1736, 1},\n\t{0x17d4, 0x17dc, 1},\t\t// Khmer punctuation\n\t{0x1800, 0x180a, 1},\t\t// Mongolian punctuation\n\t{0x2000, 0x200b, 0},\t\t// spaces\n\t{0x200c, 0x2027, 1},\t\t// punctuation and symbols\n\t{0x2028, 0x2029, 0},\n\t{0x202a, 0x202e, 1},\t\t// punctuation and symbols\n\t{0x202f, 0x202f, 0},\n\t{0x2030, 0x205e, 1},\t\t// punctuation and symbols\n\t{0x205f, 0x205f, 0},\n\t{0x2060, 0x27ff, 1},\t\t// punctuation and symbols\n\t{0x2070, 0x207f, 0x2070},\t// superscript\n\t{0x2080, 0x2094, 0x2080},\t// subscript\n\t{0x20a0, 0x27ff, 1},\t\t// all kinds of symbols\n\t{0x2800, 0x28ff, 0x2800},\t// braille\n\t{0x2900, 0x2998, 1},\t\t// arrows, brackets, etc.\n\t{0x29d8, 0x29db, 1},\n\t{0x29fc, 0x29fd, 1},\n\t{0x2e00, 0x2e7f, 1},\t\t// supplemental punctuation\n\t{0x3000, 0x3000, 0},\t\t// ideographic space\n\t{0x3001, 0x3020, 1},\t\t// ideographic punctuation\n\t{0x3030, 0x3030, 1},\n\t{0x303d, 0x303d, 1},\n\t{0x3040, 0x309f, 0x3040},\t// Hiragana\n\t{0x30a0, 0x30ff, 0x30a0},\t// Katakana\n\t{0x3300, 0x9fff, 0x4e00},\t// CJK Ideographs\n\t{0xac00, 0xd7a3, 0xac00},\t// Hangul Syllables\n\t{0xf900, 0xfaff, 0x4e00},\t// CJK Ideographs\n\t{0xfd3e, 0xfd3f, 1},\n\t{0xfe30, 0xfe6b, 1},\t\t// punctuation forms\n\t{0xff00, 0xff0f, 1},\t\t// half/fullwidth ASCII\n\t{0xff1a, 0xff20, 1},\t\t// half/fullwidth ASCII\n\t{0xff3b, 0xff40, 1},\t\t// half/fullwidth ASCII\n\t{0xff5b, 0xff65, 1},\t\t// half/fullwidth ASCII\n\t{0x1d000, 0x1d24f, 1},\t\t// Musical notation\n\t{0x1d400, 0x1d7ff, 1},\t\t// Mathematical Alphanumeric Symbols\n\t{0x1f000, 0x1f2ff, 1},\t\t// Game pieces; enclosed characters\n\t{0x1f300, 0x1f9ff, 1},\t\t// Many symbol blocks\n\t{0x20000, 0x2a6df, 0x4e00},\t// CJK Ideographs\n\t{0x2a700, 0x2b73f, 0x4e00},\t// CJK Ideographs\n\t{0x2b740, 0x2b81f, 0x4e00},\t// CJK Ideographs\n\t{0x2f800, 0x2fa1f, 0x4e00},\t// CJK Ideographs\n    };\n\n    int bot = 0;\n    int top = ARRAY_LENGTH(classes) - 1;\n    int mid;\n\n    // First quick check for Latin1 characters, use 'iskeyword'.\n    if (c < 0x100)\n    {\n\tif (c == ' ' || c == '\\t' || c == NUL || c == 0xa0)\n\t    return 0;\t    // blank\n\tif (vim_iswordc_buf(c, buf))\n\t    return 2;\t    // word character\n\treturn 1;\t    // punctuation\n    }\n\n    // emoji\n    if (intable(emoji_all, sizeof(emoji_all), c))\n\treturn 3;\n\n    // binary search in table\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (classes[mid].last < (unsigned int)c)\n\t    bot = mid + 1;\n\telse if (classes[mid].first > (unsigned int)c)\n\t    top = mid - 1;\n\telse\n\t    return (int)classes[mid].class;\n    }\n\n    // most other characters are \"word\" characters\n    return 2;\n}\n\n    int\nutf_ambiguous_width(int c)\n{\n    return c >= 0x80 && (intable(ambiguous, sizeof(ambiguous), c)\n\t    || intable(emoji_all, sizeof(emoji_all), c));\n}\n\n/*\n * Code for Unicode case-dependent operations.  Based on notes in\n * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt\n * This code uses simple case folding, not full case folding.\n * Last updated for Unicode 5.2.\n */\n\n/*\n * The following tables are built by ../runtime/tools/unicode.vim.\n * They must be in numeric order, because we use binary search.\n * An entry such as {0x41,0x5a,1,32} means that Unicode characters in the\n * range from 0x41 to 0x5a inclusive, stepping by 1, are changed to\n * folded/upper/lower by adding 32.\n */\ntypedef struct\n{\n    int rangeStart;\n    int rangeEnd;\n    int step;\n    int offset;\n} convertStruct;\n\nstatic convertStruct foldCase[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xb5,0xb5,-1,775},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x17f,0x17f,-1,-268},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x345,0x345,-1,116},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3c2,0x3c2,-1,1},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d0,0x3d0,-1,-30},\n\t{0x3d1,0x3d1,-1,-25},\n\t{0x3d5,0x3d5,-1,-15},\n\t{0x3d6,0x3d6,-1,-22},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f0,0x3f0,-1,-54},\n\t{0x3f1,0x3f1,-1,-48},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f5,0x3f5,-1,-64},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6222},\n\t{0x1c81,0x1c81,-1,-6221},\n\t{0x1c82,0x1c82,-1,-6212},\n\t{0x1c83,0x1c84,1,-6210},\n\t{0x1c85,0x1c85,-1,-6211},\n\t{0x1c86,0x1c86,-1,-6204},\n\t{0x1c87,0x1c87,-1,-6180},\n\t{0x1c88,0x1c88,-1,35267},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9b,0x1e9b,-1,-58},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fbe,0x1fbe,-1,-7173},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\n/*\n * Generic conversion function for case operations.\n * Return the converted equivalent of \"a\", which is a UCS-4 character.  Use\n * the given conversion \"table\".  Uses binary search on \"table\".\n */\n    static int\nutf_convert(\n    int\t\t\ta,\n    convertStruct\ttable[],\n    int\t\t\ttableSize)\n{\n    int start, mid, end; // indices into table\n    int entries = tableSize / sizeof(convertStruct);\n\n    start = 0;\n    end = entries;\n    while (start < end)\n    {\n\t// need to search further\n\tmid = (end + start) / 2;\n\tif (table[mid].rangeEnd < a)\n\t    start = mid + 1;\n\telse\n\t    end = mid;\n    }\n    if (start < entries\n\t    && table[start].rangeStart <= a\n\t    && a <= table[start].rangeEnd\n\t    && (a - table[start].rangeStart) % table[start].step == 0)\n\treturn (a + table[start].offset);\n    else\n\treturn a;\n}\n\n/*\n * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses\n * simple case folding.\n */\n    int\nutf_fold(int a)\n{\n    if (a < 0x80)\n\t// be fast for ASCII\n\treturn a >= 0x41 && a <= 0x5a ? a + 32 : a;\n    return utf_convert(a, foldCase, (int)sizeof(foldCase));\n}\n\nstatic convertStruct toLower[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x130,0x130,-1,-199},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13a0,0x13ef,1,38864},\n\t{0x13f0,0x13f5,1,8},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\nstatic convertStruct toUpper[] =\n{\n\t{0x61,0x7a,1,-32},\n\t{0xb5,0xb5,-1,743},\n\t{0xe0,0xf6,1,-32},\n\t{0xf8,0xfe,1,-32},\n\t{0xff,0xff,-1,121},\n\t{0x101,0x12f,2,-1},\n\t{0x131,0x131,-1,-232},\n\t{0x133,0x137,2,-1},\n\t{0x13a,0x148,2,-1},\n\t{0x14b,0x177,2,-1},\n\t{0x17a,0x17e,2,-1},\n\t{0x17f,0x17f,-1,-300},\n\t{0x180,0x180,-1,195},\n\t{0x183,0x185,2,-1},\n\t{0x188,0x18c,4,-1},\n\t{0x192,0x192,-1,-1},\n\t{0x195,0x195,-1,97},\n\t{0x199,0x199,-1,-1},\n\t{0x19a,0x19a,-1,163},\n\t{0x19e,0x19e,-1,130},\n\t{0x1a1,0x1a5,2,-1},\n\t{0x1a8,0x1ad,5,-1},\n\t{0x1b0,0x1b4,4,-1},\n\t{0x1b6,0x1b9,3,-1},\n\t{0x1bd,0x1bd,-1,-1},\n\t{0x1bf,0x1bf,-1,56},\n\t{0x1c5,0x1c5,-1,-1},\n\t{0x1c6,0x1c6,-1,-2},\n\t{0x1c8,0x1c8,-1,-1},\n\t{0x1c9,0x1c9,-1,-2},\n\t{0x1cb,0x1cb,-1,-1},\n\t{0x1cc,0x1cc,-1,-2},\n\t{0x1ce,0x1dc,2,-1},\n\t{0x1dd,0x1dd,-1,-79},\n\t{0x1df,0x1ef,2,-1},\n\t{0x1f2,0x1f2,-1,-1},\n\t{0x1f3,0x1f3,-1,-2},\n\t{0x1f5,0x1f9,4,-1},\n\t{0x1fb,0x21f,2,-1},\n\t{0x223,0x233,2,-1},\n\t{0x23c,0x23c,-1,-1},\n\t{0x23f,0x240,1,10815},\n\t{0x242,0x247,5,-1},\n\t{0x249,0x24f,2,-1},\n\t{0x250,0x250,-1,10783},\n\t{0x251,0x251,-1,10780},\n\t{0x252,0x252,-1,10782},\n\t{0x253,0x253,-1,-210},\n\t{0x254,0x254,-1,-206},\n\t{0x256,0x257,1,-205},\n\t{0x259,0x259,-1,-202},\n\t{0x25b,0x25b,-1,-203},\n\t{0x25c,0x25c,-1,42319},\n\t{0x260,0x260,-1,-205},\n\t{0x261,0x261,-1,42315},\n\t{0x263,0x263,-1,-207},\n\t{0x265,0x265,-1,42280},\n\t{0x266,0x266,-1,42308},\n\t{0x268,0x268,-1,-209},\n\t{0x269,0x269,-1,-211},\n\t{0x26a,0x26a,-1,42308},\n\t{0x26b,0x26b,-1,10743},\n\t{0x26c,0x26c,-1,42305},\n\t{0x26f,0x26f,-1,-211},\n\t{0x271,0x271,-1,10749},\n\t{0x272,0x272,-1,-213},\n\t{0x275,0x275,-1,-214},\n\t{0x27d,0x27d,-1,10727},\n\t{0x280,0x280,-1,-218},\n\t{0x282,0x282,-1,42307},\n\t{0x283,0x283,-1,-218},\n\t{0x287,0x287,-1,42282},\n\t{0x288,0x288,-1,-218},\n\t{0x289,0x289,-1,-69},\n\t{0x28a,0x28b,1,-217},\n\t{0x28c,0x28c,-1,-71},\n\t{0x292,0x292,-1,-219},\n\t{0x29d,0x29d,-1,42261},\n\t{0x29e,0x29e,-1,42258},\n\t{0x345,0x345,-1,84},\n\t{0x371,0x373,2,-1},\n\t{0x377,0x377,-1,-1},\n\t{0x37b,0x37d,1,130},\n\t{0x3ac,0x3ac,-1,-38},\n\t{0x3ad,0x3af,1,-37},\n\t{0x3b1,0x3c1,1,-32},\n\t{0x3c2,0x3c2,-1,-31},\n\t{0x3c3,0x3cb,1,-32},\n\t{0x3cc,0x3cc,-1,-64},\n\t{0x3cd,0x3ce,1,-63},\n\t{0x3d0,0x3d0,-1,-62},\n\t{0x3d1,0x3d1,-1,-57},\n\t{0x3d5,0x3d5,-1,-47},\n\t{0x3d6,0x3d6,-1,-54},\n\t{0x3d7,0x3d7,-1,-8},\n\t{0x3d9,0x3ef,2,-1},\n\t{0x3f0,0x3f0,-1,-86},\n\t{0x3f1,0x3f1,-1,-80},\n\t{0x3f2,0x3f2,-1,7},\n\t{0x3f3,0x3f3,-1,-116},\n\t{0x3f5,0x3f5,-1,-96},\n\t{0x3f8,0x3fb,3,-1},\n\t{0x430,0x44f,1,-32},\n\t{0x450,0x45f,1,-80},\n\t{0x461,0x481,2,-1},\n\t{0x48b,0x4bf,2,-1},\n\t{0x4c2,0x4ce,2,-1},\n\t{0x4cf,0x4cf,-1,-15},\n\t{0x4d1,0x52f,2,-1},\n\t{0x561,0x586,1,-48},\n\t{0x10d0,0x10fa,1,3008},\n\t{0x10fd,0x10ff,1,3008},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6254},\n\t{0x1c81,0x1c81,-1,-6253},\n\t{0x1c82,0x1c82,-1,-6244},\n\t{0x1c83,0x1c84,1,-6242},\n\t{0x1c85,0x1c85,-1,-6243},\n\t{0x1c86,0x1c86,-1,-6236},\n\t{0x1c87,0x1c87,-1,-6181},\n\t{0x1c88,0x1c88,-1,35266},\n\t{0x1d79,0x1d79,-1,35332},\n\t{0x1d7d,0x1d7d,-1,3814},\n\t{0x1d8e,0x1d8e,-1,35384},\n\t{0x1e01,0x1e95,2,-1},\n\t{0x1e9b,0x1e9b,-1,-59},\n\t{0x1ea1,0x1eff,2,-1},\n\t{0x1f00,0x1f07,1,8},\n\t{0x1f10,0x1f15,1,8},\n\t{0x1f20,0x1f27,1,8},\n\t{0x1f30,0x1f37,1,8},\n\t{0x1f40,0x1f45,1,8},\n\t{0x1f51,0x1f57,2,8},\n\t{0x1f60,0x1f67,1,8},\n\t{0x1f70,0x1f71,1,74},\n\t{0x1f72,0x1f75,1,86},\n\t{0x1f76,0x1f77,1,100},\n\t{0x1f78,0x1f79,1,128},\n\t{0x1f7a,0x1f7b,1,112},\n\t{0x1f7c,0x1f7d,1,126},\n\t{0x1f80,0x1f87,1,8},\n\t{0x1f90,0x1f97,1,8},\n\t{0x1fa0,0x1fa7,1,8},\n\t{0x1fb0,0x1fb1,1,8},\n\t{0x1fb3,0x1fb3,-1,9},\n\t{0x1fbe,0x1fbe,-1,-7205},\n\t{0x1fc3,0x1fc3,-1,9},\n\t{0x1fd0,0x1fd1,1,8},\n\t{0x1fe0,0x1fe1,1,8},\n\t{0x1fe5,0x1fe5,-1,7},\n\t{0x1ff3,0x1ff3,-1,9},\n\t{0x214e,0x214e,-1,-28},\n\t{0x2170,0x217f,1,-16},\n\t{0x2184,0x2184,-1,-1},\n\t{0x24d0,0x24e9,1,-26},\n\t{0x2c30,0x2c5e,1,-48},\n\t{0x2c61,0x2c61,-1,-1},\n\t{0x2c65,0x2c65,-1,-10795},\n\t{0x2c66,0x2c66,-1,-10792},\n\t{0x2c68,0x2c6c,2,-1},\n\t{0x2c73,0x2c76,3,-1},\n\t{0x2c81,0x2ce3,2,-1},\n\t{0x2cec,0x2cee,2,-1},\n\t{0x2cf3,0x2cf3,-1,-1},\n\t{0x2d00,0x2d25,1,-7264},\n\t{0x2d27,0x2d2d,6,-7264},\n\t{0xa641,0xa66d,2,-1},\n\t{0xa681,0xa69b,2,-1},\n\t{0xa723,0xa72f,2,-1},\n\t{0xa733,0xa76f,2,-1},\n\t{0xa77a,0xa77c,2,-1},\n\t{0xa77f,0xa787,2,-1},\n\t{0xa78c,0xa791,5,-1},\n\t{0xa793,0xa793,-1,-1},\n\t{0xa794,0xa794,-1,48},\n\t{0xa797,0xa7a9,2,-1},\n\t{0xa7b5,0xa7bf,2,-1},\n\t{0xa7c3,0xa7c8,5,-1},\n\t{0xa7ca,0xa7f6,44,-1},\n\t{0xab53,0xab53,-1,-928},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff41,0xff5a,1,-32},\n\t{0x10428,0x1044f,1,-40},\n\t{0x104d8,0x104fb,1,-40},\n\t{0x10cc0,0x10cf2,1,-64},\n\t{0x118c0,0x118df,1,-32},\n\t{0x16e60,0x16e7f,1,-32},\n\t{0x1e922,0x1e943,1,-34}\n};\n\n/*\n * Return the upper-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_toupper(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style toupper().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(a);\n\n#if defined(HAVE_TOWUPPER) && defined(__STDC_ISO_10646__)\n    // If towupper() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towupper(a);\n#endif\n\n    // For characters below 128 use locale sensitive toupper().\n    if (a < 128)\n\treturn TOUPPER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toUpper, (int)sizeof(toUpper));\n}\n\n    int\nutf_islower(int a)\n{\n    // German sharp s is lower case but has no upper case equivalent.\n    return (utf_toupper(a) != a) || a == 0xdf;\n}\n\n/*\n * Return the lower-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_tolower(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style tolower().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(a);\n\n#if defined(HAVE_TOWLOWER) && defined(__STDC_ISO_10646__)\n    // If towlower() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towlower(a);\n#endif\n\n    // For characters below 128 use locale sensitive tolower().\n    if (a < 128)\n\treturn TOLOWER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toLower, (int)sizeof(toLower));\n}\n\n    int\nutf_isupper(int a)\n{\n    return (utf_tolower(a) != a);\n}\n\n    static int\nutf_strnicmp(\n    char_u      *s1,\n    char_u      *s2,\n    size_t      n1,\n    size_t      n2)\n{\n    int\t\tc1, c2, cdiff;\n    char_u\tbuffer[6];\n\n    for (;;)\n    {\n\tc1 = utf_safe_read_char_adv(&s1, &n1);\n\tc2 = utf_safe_read_char_adv(&s2, &n2);\n\n\tif (c1 <= 0 || c2 <= 0)\n\t    break;\n\n\tif (c1 == c2)\n\t    continue;\n\n\tcdiff = utf_fold(c1) - utf_fold(c2);\n\tif (cdiff != 0)\n\t    return cdiff;\n    }\n\n    // some string ended or has an incomplete/illegal character sequence\n\n    if (c1 == 0 || c2 == 0)\n    {\n\t// some string ended. shorter string is smaller\n\tif (c1 == 0 && c2 == 0)\n\t    return 0;\n\treturn c1 == 0 ? -1 : 1;\n    }\n\n    // Continue with bytewise comparison to produce some result that\n    // would make comparison operations involving this function transitive.\n    //\n    // If only one string had an error, comparison should be made with\n    // folded version of the other string. In this case it is enough\n    // to fold just one character to determine the result of comparison.\n\n    if (c1 != -1 && c2 == -1)\n    {\n\tn1 = utf_char2bytes(utf_fold(c1), buffer);\n\ts1 = buffer;\n    }\n    else if (c2 != -1 && c1 == -1)\n    {\n\tn2 = utf_char2bytes(utf_fold(c2), buffer);\n\ts2 = buffer;\n    }\n\n    while (n1 > 0 && n2 > 0 && *s1 != NUL && *s2 != NUL)\n    {\n\tcdiff = (int)(*s1) - (int)(*s2);\n\tif (cdiff != 0)\n\t    return cdiff;\n\n\ts1++;\n\ts2++;\n\tn1--;\n\tn2--;\n    }\n\n    if (n1 > 0 && *s1 == NUL)\n\tn1 = 0;\n    if (n2 > 0 && *s2 == NUL)\n\tn2 = 0;\n\n    if (n1 == 0 && n2 == 0)\n\treturn 0;\n    return n1 == 0 ? -1 : 1;\n}\n\n/*\n * Version of strnicmp() that handles multi-byte characters.\n * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can\n * probably use strnicmp(), because there are no ASCII characters in the\n * second byte.\n * Returns zero if s1 and s2 are equal (ignoring case), the difference between\n * two characters otherwise.\n */\n    int\nmb_strnicmp(char_u *s1, char_u *s2, size_t nn)\n{\n    int\t\ti, l;\n    int\t\tcdiff;\n    int\t\tn = (int)nn;\n\n    if (enc_utf8)\n    {\n\treturn utf_strnicmp(s1, s2, nn, nn);\n    }\n    else\n    {\n\tfor (i = 0; i < n; i += l)\n\t{\n\t    if (s1[i] == NUL && s2[i] == NUL)\t// both strings end\n\t\treturn 0;\n\n\t    l = (*mb_ptr2len)(s1 + i);\n\t    if (l <= 1)\n\t    {\n\t\t// Single byte: first check normally, then with ignore case.\n\t\tif (s1[i] != s2[i])\n\t\t{\n\t\t    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);\n\t\t    if (cdiff != 0)\n\t\t\treturn cdiff;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// For non-Unicode multi-byte don't ignore case.\n\t\tif (l > n - i)\n\t\t    l = n - i;\n\t\tcdiff = STRNCMP(s1 + i, s2 + i, l);\n\t\tif (cdiff != 0)\n\t\t    return cdiff;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what\n * 'encoding' has been set to.\n */\n    void\nshow_utf8(void)\n{\n    int\t\tlen;\n    int\t\trlen = 0;\n    char_u\t*line;\n    int\t\tclen;\n    int\t\ti;\n\n    // Get the byte length of the char under the cursor, including composing\n    // characters.\n    line = ml_get_cursor();\n    len = utfc_ptr2len(line);\n    if (len == 0)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    clen = 0;\n    for (i = 0; i < len; ++i)\n    {\n\tif (clen == 0)\n\t{\n\t    // start of (composing) character, get its length\n\t    if (i > 0)\n\t    {\n\t\tSTRCPY(IObuff + rlen, \"+ \");\n\t\trlen += 2;\n\t    }\n\t    clen = utf_ptr2len(line + i);\n\t}\n\tsprintf((char *)IObuff + rlen, \"%02x \",\n\t\t(line[i] == NL) ? NUL : line[i]);  // NUL is stored as NL\n\t--clen;\n\trlen += (int)STRLEN(IObuff + rlen);\n\tif (rlen > IOSIZE - 20)\n\t    break;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * mb_head_off() function pointer.\n * Return offset from \"p\" to the first byte of the character it points into.\n * If \"p\" points to the NUL at the end of the string return 0.\n * Returns 0 when already at the first byte of a character.\n */\n    int\nlatin_head_off(char_u *base UNUSED, char_u *p UNUSED)\n{\n    return 0;\n}\n\n    static int\ndbcs_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    if (p <= base || MB_BYTE2LEN(p[-1]) == 1 || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    q = base;\n    while (q < p)\n\tq += dbcs_ptr2len(q);\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Special version of dbcs_head_off() that works for ScreenLines[], where\n * single-width DBCS_JPNU characters are stored separately.\n */\n    int\ndbcs_screen_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    // For euc-jp an 0x8e byte in the previous cell always means we have a\n    // lead byte in the current cell.\n    if (p <= base\n\t    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)\n\t    || MB_BYTE2LEN(p[-1]) == 1\n\t    || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    // For DBCS_JPNU look out for 0x8e, which means the second byte is not\n    // stored as the next byte.\n    q = base;\n    while (q < p)\n    {\n\tif (enc_dbcs == DBCS_JPNU && *q == 0x8e)\n\t    ++q;\n\telse\n\t    q += dbcs_ptr2len(q);\n    }\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Return offset from \"p\" to the start of a character, including composing\n * characters.  \"base\" must be the start of the string, which must be NUL\n * terminated.\n */\n    int\nutf_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    char_u\t*j;\n#endif\n\n    if (*p < 0x80)\t\t// be quick for ASCII\n\treturn 0;\n\n    // Skip backwards over trailing bytes: 10xx.xxxx\n    // Skip backwards again if on a composing char.\n    for (q = p; ; --q)\n    {\n\t// Move s to the last byte of this char.\n\tfor (s = q; (s[1] & 0xc0) == 0x80; ++s)\n\t    ;\n\t// Move q to the first byte of this char.\n\twhile (q > base && (*q & 0xc0) == 0x80)\n\t    --q;\n\t// Check for illegal sequence. Do allow an illegal byte after where we\n\t// started.\n\tlen = utf8len_tab[*q];\n\tif (len != (int)(s - q + 1) && len != (int)(p - q + 1))\n\t    return 0;\n\n\tif (q <= base)\n\t    break;\n\n\tc = utf_ptr2char(q);\n\tif (utf_iscomposing(c))\n\t    continue;\n\n#ifdef FEAT_ARABIC\n\tif (arabic_maycombine(c))\n\t{\n\t    // Advance to get a sneak-peak at the next char\n\t    j = q;\n\t    --j;\n\t    // Move j to the first byte of this char.\n\t    while (j > base && (*j & 0xc0) == 0x80)\n\t\t--j;\n\t    if (arabic_combine(utf_ptr2char(j), c))\n\t\tcontinue;\n\t}\n#endif\n\tbreak;\n    }\n\n    return (int)(p - q);\n}\n\n/*\n * Whether space is NOT allowed before/after 'c'.\n */\n    int\nutf_eat_space(int cc)\n{\n    return ((cc >= 0x2000 && cc <= 0x206F)\t// General punctuations\n\t || (cc >= 0x2e00 && cc <= 0x2e7f)\t// Supplemental punctuations\n\t || (cc >= 0x3000 && cc <= 0x303f)\t// CJK symbols and punctuations\n\t || (cc >= 0xff01 && cc <= 0xff0f)\t// Full width ASCII punctuations\n\t || (cc >= 0xff1a && cc <= 0xff20)\t// ..\n\t || (cc >= 0xff3b && cc <= 0xff40)\t// ..\n\t || (cc >= 0xff5b && cc <= 0xff65));\t// ..\n}\n\n/*\n * Whether line break is allowed before \"cc\".\n */\n    int\nutf_allow_break_before(int cc)\n{\n    static const int BOL_prohibition_punct[] =\n    {\n\t'!',\n\t'%',\n\t')',\n\t',',\n\t':',\n\t';',\n\t'>',\n\t'?',\n\t']',\n\t'}',\n\t0x2019, // \u2019 right single quotation mark\n\t0x201d, // \u201d right double quotation mark\n\t0x2020, // \u2020 dagger\n\t0x2021, // \u2021 double dagger\n\t0x2026, // \u2026 horizontal ellipsis\n\t0x2030, // \u2030 per mille sign\n\t0x2031, // \u2031 per then thousand sign\n\t0x203c, // \u203c double exclamation mark\n\t0x2047, // \u2047 double question mark\n\t0x2048, // \u2048 question exclamation mark\n\t0x2049, // \u2049 exclamation question mark\n\t0x2103, // \u2103 degree celsius\n\t0x2109, // \u2109 degree fahrenheit\n\t0x3001, // \u3001 ideographic comma\n\t0x3002, // \u3002 ideographic full stop\n\t0x3009, // \u3009 right angle bracket\n\t0x300b, // \u300b right double angle bracket\n\t0x300d, // \u300d right corner bracket\n\t0x300f, // \u300f right white corner bracket\n\t0x3011, // \u3011 right black lenticular bracket\n\t0x3015, // \u3015 right tortoise shell bracket\n\t0x3017, // \u3017 right white lenticular bracket\n\t0x3019, // \u3019 right white tortoise shell bracket\n\t0x301b, // \u301b right white square bracket\n\t0xff01, // \uff01 fullwidth exclamation mark\n\t0xff09, // \uff09 fullwidth right parenthesis\n\t0xff0c, // \uff0c fullwidth comma\n\t0xff0e, // \uff0e fullwidth full stop\n\t0xff1a, // \uff1a fullwidth colon\n\t0xff1b, // \uff1b fullwidth semicolon\n\t0xff1f, // \uff1f fullwidth question mark\n\t0xff3d, // \uff3d fullwidth right square bracket\n\t0xff5d, // \uff5d fullwidth right curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(BOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == BOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > BOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != BOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed after \"cc\".\n */\n    static int\nutf_allow_break_after(int cc)\n{\n    static const int EOL_prohibition_punct[] =\n    {\n\t'(',\n\t'<',\n\t'[',\n\t'`',\n\t'{',\n\t//0x2014, // \u2014 em dash\n\t0x2018, // \u2018 left single quotation mark\n\t0x201c, // \u201c left double quotation mark\n\t//0x2053, // \uff5e swung dash\n\t0x3008, // \u3008 left angle bracket\n\t0x300a, // \u300a left double angle bracket\n\t0x300c, // \u300c left corner bracket\n\t0x300e, // \u300e left white corner bracket\n\t0x3010, // \u3010 left black lenticular bracket\n\t0x3014, // \u3014 left tortoise shell bracket\n\t0x3016, // \u3016 left white lenticular bracket\n\t0x3018, // \u3018 left white tortoise shell bracket\n\t0x301a, // \u301a left white square bracket\n\t0xff08, // \uff08 fullwidth left parenthesis\n\t0xff3b, // \uff3b fullwidth left square bracket\n\t0xff5b, // \uff5b fullwidth left curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(EOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == EOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > EOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != EOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed between \"cc\" and \"ncc\".\n */\n    int\nutf_allow_break(int cc, int ncc)\n{\n    // don't break between two-letter punctuations\n    if (cc == ncc\n\t    && (cc == 0x2014 // em dash\n\t\t|| cc == 0x2026)) // horizontal ellipsis\n\treturn FALSE;\n\n    return utf_allow_break_after(cc) && utf_allow_break_before(ncc);\n}\n\n/*\n * Copy a character from \"*fp\" to \"*tp\" and advance the pointers.\n */\n    void\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n/*\n * Return the offset from \"p\" to the first byte of a character.  When \"p\" is\n * at the start of a character 0 is returned, otherwise the offset to the next\n * character.  Can start anywhere in a stream of bytes.\n */\n    int\nmb_off_next(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (enc_utf8)\n    {\n\tif (*p < 0x80)\t\t// be quick for ASCII\n\t    return 0;\n\n\t// Find the next character that isn't 10xx.xxxx\n\tfor (i = 0; (p[i] & 0xc0) == 0x80; ++i)\n\t    ;\n\tif (i > 0)\n\t{\n\t    // Check for illegal sequence.\n\t    for (j = 0; p - j > base; ++j)\n\t\tif ((p[-j] & 0xc0) != 0x80)\n\t\t    break;\n\t    if (utf8len_tab[p[-j]] != i + j)\n\t\treturn 0;\n\t}\n\treturn i;\n    }\n\n    // Only need to check if we're on a trail byte, it doesn't matter if we\n    // want the offset to the next or current character.\n    return (*mb_head_off)(base, p);\n}\n\n/*\n * Return the offset from \"p\" to the last byte of the character it points\n * into.  Can start anywhere in a stream of bytes.\n * Composing characters are not included.\n */\n    int\nmb_tail_off(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (*p == NUL)\n\treturn 0;\n\n    if (enc_utf8)\n    {\n\t// Find the last character that is 10xx.xxxx\n\tfor (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)\n\t    ;\n\t// Check for illegal sequence.\n\tfor (j = 0; p - j > base; ++j)\n\t    if ((p[-j] & 0xc0) != 0x80)\n\t\tbreak;\n\tif (utf8len_tab[p[-j]] != i + j + 1)\n\t    return 0;\n\treturn i;\n    }\n\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_head_off(base, p);\n}\n\n/*\n * Find the next illegal byte sequence.\n */\n    void\nutf_find_illegal(void)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*p;\n    int\t\tlen;\n    vimconv_T\tvimconv;\n    char_u\t*tofree = NULL;\n\n    vimconv.vc_type = CONV_NONE;\n    if (enc_utf8 && (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT))\n    {\n\t// 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n\t// possibly a utf-8 file with illegal bytes.  Setup for conversion\n\t// from utf-8 to 'fileencoding'.\n\tconvert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n    }\n\n    curwin->w_cursor.coladd = 0;\n    for (;;)\n    {\n\tp = ml_get_cursor();\n\tif (vimconv.vc_type != CONV_NONE)\n\t{\n\t    vim_free(tofree);\n\t    tofree = string_convert(&vimconv, p, NULL);\n\t    if (tofree == NULL)\n\t\tbreak;\n\t    p = tofree;\n\t}\n\n\twhile (*p != NUL)\n\t{\n\t    // Illegal means that there are not enough trail bytes (checked by\n\t    // utf_ptr2len()) or too many of them (overlong sequence).\n\t    len = utf_ptr2len(p);\n\t    if (*p >= 0x80 && (len == 1\n\t\t\t\t     || utf_char2len(utf_ptr2char(p)) != len))\n\t    {\n\t\tif (vimconv.vc_type == CONV_NONE)\n\t\t    curwin->w_cursor.col += (colnr_T)(p - ml_get_cursor());\n\t\telse\n\t\t{\n\t\t    int\t    l;\n\n\t\t    len = (int)(p - tofree);\n\t\t    for (p = ml_get_cursor(); *p != NUL && len-- > 0; p += l)\n\t\t    {\n\t\t\tl = utf_ptr2len(p);\n\t\t\tcurwin->w_cursor.col += l;\n\t\t    }\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    p += len;\n\t}\n\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t    break;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // didn't find it: don't move and beep\n    curwin->w_cursor = pos;\n    beep_flush();\n\ntheend:\n    vim_free(tofree);\n    convert_setup(&vimconv, NULL, NULL);\n}\n\n#if defined(FEAT_GUI_GTK) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" is a valid utf-8 string.\n * When \"end\" is NULL stop at the first NUL.\n * When \"end\" is positive stop there.\n */\n    int\nutf_valid_string(char_u *s, char_u *end)\n{\n    int\t\tl;\n    char_u\t*p = s;\n\n    while (end == NULL ? *p != NUL : p < end)\n    {\n\tl = utf8len_tab_zero[*p];\n\tif (l == 0)\n\t    return FALSE;\t// invalid lead byte\n\tif (end != NULL && p + l > end)\n\t    return FALSE;\t// incomplete byte sequence\n\t++p;\n\twhile (--l > 0)\n\t    if ((*p++ & 0xc0) != 0x80)\n\t\treturn FALSE;\t// invalid trail byte\n    }\n    return TRUE;\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Special version of mb_tail_off() for use in ScreenLines[].\n */\n    int\ndbcs_screen_tail_off(char_u *base, char_u *p)\n{\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    // For euc-jp an 0x8e byte always means we have a lead byte in the current\n    // cell.\n    if (*p == NUL || p[1] == NUL\n\t    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t    || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_screen_head_off(base, p);\n}\n#endif\n\n/*\n * If the cursor moves on an trail byte, set the cursor on the lead byte.\n * Thus it moves left if necessary.\n * Return TRUE when the cursor was adjusted.\n */\n    void\nmb_adjust_cursor(void)\n{\n    mb_adjustpos(curbuf, &curwin->w_cursor);\n}\n\n/*\n * Adjust position \"*lp\" to point to the first byte of a multi-byte character.\n * If it points to a tail byte it's moved backwards to the head byte.\n */\n    void\nmb_adjustpos(buf_T *buf, pos_T *lp)\n{\n    char_u\t*p;\n\n    if (lp->col > 0 || lp->coladd > 1)\n    {\n\tp = ml_get_buf(buf, lp->lnum, FALSE);\n\tif (*p == NUL || (int)STRLEN(p) < lp->col)\n\t    lp->col = 0;\n\telse\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t// Reset \"coladd\" when the cursor would be on the right half of a\n\t// double-wide character.\n\tif (lp->coladd == 1\n\t\t&& p[lp->col] != TAB\n\t\t&& vim_isprintc((*mb_ptr2char)(p + lp->col))\n\t\t&& ptr2cells(p + lp->col) > 1)\n\t    lp->coladd = 0;\n    }\n}\n\n/*\n * Return a pointer to the character before \"*p\", if there is one.\n */\n    char_u *\nmb_prevptr(\n    char_u *line,\t// start of the string\n    char_u *p)\n{\n    if (p > line)\n\tMB_PTR_BACK(line, p);\n    return p;\n}\n\n/*\n * Return the character length of \"str\".  Each multi-byte character (with\n * following composing characters) counts as one.\n */\n    int\nmb_charlen(char_u *str)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    if (p == NULL)\n\treturn 0;\n\n    for (count = 0; *p != NUL; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Like mb_charlen() but for a string with specified length.\n */\n    int\nmb_charlen_len(char_u *str, int len)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    for (count = 0; *p != NUL && p < str + len; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Try to un-escape a multi-byte character.\n * Used for the \"to\" and \"from\" part of a mapping.\n * Return the un-escaped string if it is a multi-byte character, and advance\n * \"pp\" to just after the bytes that formed it.\n * Return NULL if no multi-byte char was found.\n */\n    char_u *\nmb_unescape(char_u **pp)\n{\n    static char_u\tbuf[6];\n    int\t\t\tn;\n    int\t\t\tm = 0;\n    char_u\t\t*str = *pp;\n\n    // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI\n    // KS_EXTRA KE_CSI to CSI.\n    // Maximum length of a utf-8 character is 4 bytes.\n    for (n = 0; str[n] != NUL && m < 4; ++n)\n    {\n\tif (str[n] == K_SPECIAL\n\t\t&& str[n + 1] == KS_SPECIAL\n\t\t&& str[n + 2] == KE_FILLER)\n\t{\n\t    buf[m++] = K_SPECIAL;\n\t    n += 2;\n\t}\n\telse if ((str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t    || str[n] == CSI\n# endif\n\t\t )\n\t\t&& str[n + 1] == KS_EXTRA\n\t\t&& str[n + 2] == (int)KE_CSI)\n\t{\n\t    buf[m++] = CSI;\n\t    n += 2;\n\t}\n\telse if (str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t|| str[n] == CSI\n# endif\n\t\t)\n\t    break;\t\t// a special key can't be a multibyte char\n\telse\n\t    buf[m++] = str[n];\n\tbuf[m] = NUL;\n\n\t// Return a multi-byte character if it's found.  An illegal sequence\n\t// will result in a 1 here.\n\tif ((*mb_ptr2len)(buf) > 1)\n\t{\n\t    *pp = str + n + 1;\n\t    return buf;\n\t}\n\n\t// Bail out quickly for ASCII.\n\tif (buf[0] < 128)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if the character at \"row\"/\"col\" on the screen is the left side\n * of a double-width character.\n * Caller must make sure \"row\" and \"col\" are not invalid!\n */\n    int\nmb_lefthalve(int row, int col)\n{\n    return (*mb_off2cells)(LineOffset[row] + col,\n\t\t\t\t\tLineOffset[row] + screen_Columns) > 1;\n}\n\n/*\n * Correct a position on the screen, if it's the right half of a double-wide\n * char move it to the left half.  Returns the corrected column.\n */\n    int\nmb_fix_col(int col, int row)\n{\n    int off;\n\n    col = check_col(col);\n    row = check_row(row);\n    off = LineOffset[row] + col;\n    if (has_mbyte && ScreenLines != NULL && col > 0\n\t    && ((enc_dbcs\n\t\t    && ScreenLines[off] != NUL\n\t\t    && dbcs_screen_head_off(ScreenLines + LineOffset[row],\n\t\t\t\t\t ScreenLines + off))\n\t\t|| (enc_utf8 && ScreenLines[off] == 0\n\t\t\t\t\t\t  && ScreenLinesUC[off] == 0)))\n\treturn col - 1;\n    return col;\n}\n\nstatic int enc_alias_search(char_u *name);\n\n/*\n * Skip the Vim specific head of a 'encoding' name.\n */\n    char_u *\nenc_skip(char_u *p)\n{\n    if (STRNCMP(p, \"2byte-\", 6) == 0)\n\treturn p + 6;\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\treturn p + 5;\n    return p;\n}\n\n/*\n * Find the canonical name for encoding \"enc\".\n * When the name isn't recognized, returns \"enc\" itself, but with all lower\n * case characters and '_' replaced with '-'.\n * Returns an allocated string.  NULL for out-of-memory.\n */\n    char_u *\nenc_canonize(char_u *enc)\n{\n    char_u\t*r;\n    char_u\t*p, *s;\n    int\t\ti;\n\n    if (STRCMP(enc, \"default\") == 0)\n    {\n#ifdef MSWIN\n\t// Use the system encoding, the default is always utf-8.\n\tr = enc_locale();\n#else\n\t// Use the default encoding as it's found by set_init_1().\n\tr = get_encoding_default();\n#endif\n\tif (r == NULL)\n\t    r = (char_u *)ENC_DFLT;\n\treturn vim_strsave(r);\n    }\n\n    // copy \"enc\" to allocated memory, with room for two '-'\n    r = alloc(STRLEN(enc) + 3);\n    if (r != NULL)\n    {\n\t// Make it all lower case and replace '_' with '-'.\n\tp = r;\n\tfor (s = enc; *s != NUL; ++s)\n\t{\n\t    if (*s == '_')\n\t\t*p++ = '-';\n\t    else\n\t\t*p++ = TOLOWER_ASC(*s);\n\t}\n\t*p = NUL;\n\n\t// Skip \"2byte-\" and \"8bit-\".\n\tp = enc_skip(r);\n\n\t// Change \"microsoft-cp\" to \"cp\".  Used in some spell files.\n\tif (STRNCMP(p, \"microsoft-cp\", 12) == 0)\n\t    STRMOVE(p, p + 10);\n\n\t// \"iso8859\" -> \"iso-8859\"\n\tif (STRNCMP(p, \"iso8859\", 7) == 0)\n\t{\n\t    STRMOVE(p + 4, p + 3);\n\t    p[3] = '-';\n\t}\n\n\t// \"iso-8859n\" -> \"iso-8859-n\"\n\tif (STRNCMP(p, \"iso-8859\", 8) == 0 && isdigit(p[8]))\n\t{\n\t    STRMOVE(p + 9, p + 8);\n\t    p[8] = '-';\n\t}\n\n\t// \"latin-N\" -> \"latinN\"\n\tif (STRNCMP(p, \"latin-\", 6) == 0)\n\t    STRMOVE(p + 5, p + 6);\n\n\tif (enc_canon_search(p) >= 0)\n\t{\n\t    // canonical name can be used unmodified\n\t    if (p != r)\n\t\tSTRMOVE(r, p);\n\t}\n\telse if ((i = enc_alias_search(p)) >= 0)\n\t{\n\t    // alias recognized, get canonical name\n\t    vim_free(r);\n\t    r = vim_strsave((char_u *)enc_canon_table[i].name);\n\t}\n    }\n    return r;\n}\n\n/*\n * Search for an encoding alias of \"name\".\n * Returns -1 when not found.\n */\n    static int\nenc_alias_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; enc_alias_table[i].name != NULL; ++i)\n\tif (STRCMP(name, enc_alias_table[i].name) == 0)\n\t    return enc_alias_table[i].canon;\n    return -1;\n}\n\n\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n/*\n * Get the canonicalized encoding from the specified locale string \"locale\"\n * or from the environment variables LC_ALL, LC_CTYPE and LANG.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale_env(char *locale)\n{\n    char\t*s = locale;\n    char\t*p;\n    int\t\ti;\n    char\tbuf[50];\n\n    if (s == NULL || *s == NUL)\n\tif ((s = getenv(\"LC_ALL\")) == NULL || *s == NUL)\n\t    if ((s = getenv(\"LC_CTYPE\")) == NULL || *s == NUL)\n\t\ts = getenv(\"LANG\");\n\n    if (s == NULL || *s == NUL)\n\treturn NULL;\n\n    // The most generic locale format is:\n    // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]\n    // If there is a '.' remove the part before it.\n    // if there is something after the codeset, remove it.\n    // Make the name lowercase and replace '_' with '-'.\n    // Exception: \"ja_JP.EUC\" == \"euc-jp\", \"zh_CN.EUC\" = \"euc-cn\",\n    // \"ko_KR.EUC\" == \"euc-kr\"\n    if ((p = (char *)vim_strchr((char_u *)s, '.')) != NULL)\n    {\n\tif (p > s + 2 && STRNICMP(p + 1, \"EUC\", 3) == 0\n\t\t\t&& !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_')\n\t{\n\t    // copy \"XY.EUC\" to \"euc-XY\" to buf[10]\n\t    STRCPY(buf + 10, \"euc-\");\n\t    buf[14] = p[-2];\n\t    buf[15] = p[-1];\n\t    buf[16] = 0;\n\t    s = buf + 10;\n\t}\n\telse\n\t    s = p + 1;\n    }\n    for (i = 0; i < (int)sizeof(buf) - 1 && s[i] != NUL; ++i)\n    {\n\tif (s[i] == '_' || s[i] == '-')\n\t    buf[i] = '-';\n\telse if (isalnum((int)s[i]))\n\t    buf[i] = TOLOWER_ASC(s[i]);\n\telse\n\t    break;\n    }\n    buf[i] = NUL;\n\n    return enc_canonize((char_u *)buf);\n}\n#endif\n\n/*\n * Get the canonicalized encoding of the current locale.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale(void)\n{\n#ifdef MSWIN\n    char\tbuf[50];\n    long\tacp = GetACP();\n\n    if (acp == 1200)\n\tSTRCPY(buf, \"ucs-2le\");\n    else if (acp == 1252)\t    // cp1252 is used as latin1\n\tSTRCPY(buf, \"latin1\");\n    else if (acp == 65001)\n\tSTRCPY(buf, \"utf-8\");\n    else\n\tsprintf(buf, \"cp%ld\", acp);\n\n    return enc_canonize((char_u *)buf);\n#else\n    char\t*s;\n\n# ifdef HAVE_NL_LANGINFO_CODESET\n    if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)\n# endif\n# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n\tif ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)\n# endif\n\t    s = NULL;\n\n    return enc_locale_env(s);\n#endif\n}\n\n# if defined(MSWIN) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n/*\n * Convert an encoding name to an MS-Windows codepage.\n * Returns zero if no codepage can be figured out.\n */\n    int\nencname2codepage(char_u *name)\n{\n    int\t\tcp;\n    char_u\t*p = name;\n    int\t\tidx;\n\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\tp += 5;\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n\tp += 6;\n\n    if (p[0] == 'c' && p[1] == 'p')\n\tcp = atoi((char *)p + 2);\n    else if ((idx = enc_canon_search(p)) >= 0)\n\tcp = enc_canon_table[idx].codepage;\n    else\n\treturn 0;\n    if (IsValidCodePage(cp))\n\treturn cp;\n    return 0;\n}\n# endif\n\n# if defined(USE_ICONV) || defined(PROTO)\n\n/*\n * Call iconv_open() with a check if iconv() works properly (there are broken\n * versions).\n * Returns (void *)-1 if failed.\n * (should return iconv_t, but that causes problems with prototypes).\n */\n    void *\nmy_iconv_open(char_u *to, char_u *from)\n{\n    iconv_t\tfd;\n#define ICONV_TESTLEN 400\n    char_u\ttobuf[ICONV_TESTLEN];\n    char\t*p;\n    size_t\ttolen;\n    static int\ticonv_ok = -1;\n\n    if (iconv_ok == FALSE)\n\treturn (void *)-1;\t// detected a broken iconv() previously\n\n#ifdef DYNAMIC_ICONV\n    // Check if the iconv.dll can be found.\n    if (!iconv_enabled(TRUE))\n\treturn (void *)-1;\n#endif\n\n    fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));\n\n    if (fd != (iconv_t)-1 && iconv_ok == -1)\n    {\n\t/*\n\t * Do a dummy iconv() call to check if it actually works.  There is a\n\t * version of iconv() on Linux that is broken.  We can't ignore it,\n\t * because it's wide-spread.  The symptoms are that after outputting\n\t * the initial shift state the \"to\" pointer is NULL and conversion\n\t * stops for no apparent reason after about 8160 characters.\n\t */\n\tp = (char *)tobuf;\n\ttolen = ICONV_TESTLEN;\n\t(void)iconv(fd, NULL, NULL, &p, &tolen);\n\tif (p == NULL)\n\t{\n\t    iconv_ok = FALSE;\n\t    iconv_close(fd);\n\t    fd = (iconv_t)-1;\n\t}\n\telse\n\t    iconv_ok = TRUE;\n    }\n\n    return (void *)fd;\n}\n\n/*\n * Convert the string \"str[slen]\" with iconv().\n * If \"unconvlenp\" is not NULL handle the string ending in an incomplete\n * sequence and set \"*unconvlenp\" to the length of it.\n * Returns the converted string in allocated memory.  NULL for an error.\n * If resultlenp is not NULL, sets it to the result length in bytes.\n */\n    static char_u *\niconv_string(\n    vimconv_T\t*vcp,\n    char_u\t*str,\n    int\t\tslen,\n    int\t\t*unconvlenp,\n    int\t\t*resultlenp)\n{\n    const char\t*from;\n    size_t\tfromlen;\n    char\t*to;\n    size_t\ttolen;\n    size_t\tlen = 0;\n    size_t\tdone = 0;\n    char_u\t*result = NULL;\n    char_u\t*p;\n    int\t\tl;\n\n    from = (char *)str;\n    fromlen = slen;\n    for (;;)\n    {\n\tif (len == 0 || ICONV_ERRNO == ICONV_E2BIG)\n\t{\n\t    // Allocate enough room for most conversions.  When re-allocating\n\t    // increase the buffer size.\n\t    len = len + fromlen * 2 + 40;\n\t    p = alloc(len);\n\t    if (p != NULL && done > 0)\n\t\tmch_memmove(p, result, done);\n\t    vim_free(result);\n\t    result = p;\n\t    if (result == NULL)\t// out of memory\n\t\tbreak;\n\t}\n\n\tto = (char *)result + done;\n\ttolen = len - done - 2;\n\t// Avoid a warning for systems with a wrong iconv() prototype by\n\t// casting the second argument to void *.\n\tif (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t\t\t\t\t\t!= (size_t)-1)\n\t{\n\t    // Finished, append a NUL.\n\t    *to = NUL;\n\t    break;\n\t}\n\n\t// Check both ICONV_EINVAL and EINVAL, because the dynamically loaded\n\t// iconv library may use one of them.\n\tif (!vcp->vc_fail && unconvlenp != NULL\n\t\t&& (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Handle an incomplete sequence at the end.\n\t    *to = NUL;\n\t    *unconvlenp = (int)fromlen;\n\t    break;\n\t}\n\n\t// Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded\n\t// iconv library may use one of them.\n\telse if (!vcp->vc_fail\n\t\t&& (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ\n\t\t    || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Can't convert: insert a '?' and skip a character.  This assumes\n\t    // conversion from 'encoding' to something else.  In other\n\t    // situations we don't know what to skip anyway.\n\t    *to++ = '?';\n\t    if ((*mb_ptr2cells)((char_u *)from) > 1)\n\t\t*to++ = '?';\n\t    if (enc_utf8)\n\t\tl = utfc_ptr2len_len((char_u *)from, (int)fromlen);\n\t    else\n\t    {\n\t\tl = (*mb_ptr2len)((char_u *)from);\n\t\tif (l > (int)fromlen)\n\t\t    l = (int)fromlen;\n\t    }\n\t    from += l;\n\t    fromlen -= l;\n\t}\n\telse if (ICONV_ERRNO != ICONV_E2BIG)\n\t{\n\t    // conversion failed\n\t    VIM_CLEAR(result);\n\t    break;\n\t}\n\t// Not enough room or skipping illegal sequence.\n\tdone = to - (char *)result;\n    }\n\n    if (resultlenp != NULL && result != NULL)\n\t*resultlenp = (int)(to - (char *)result);\n    return result;\n}\n\n#  if defined(DYNAMIC_ICONV) || defined(PROTO)\n/*\n * Dynamically load the \"iconv.dll\" on Win32.\n */\n\n#   ifndef DYNAMIC_ICONV\t    // must be generating prototypes\n#    define HINSTANCE int\n#   endif\nstatic HINSTANCE hIconvDLL = 0;\nstatic HINSTANCE hMsvcrtDLL = 0;\n\n#   ifndef DYNAMIC_ICONV_DLL\n#    define DYNAMIC_ICONV_DLL \"iconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT1 \"libiconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT2 \"libiconv2.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT3 \"libiconv-2.dll\"\n#   endif\n#   ifndef DYNAMIC_MSVCRT_DLL\n#    define DYNAMIC_MSVCRT_DLL \"msvcrt.dll\"\n#   endif\n\n/*\n * Try opening the iconv.dll and return TRUE if iconv() can be used.\n */\n    int\niconv_enabled(int verbose)\n{\n    if (hIconvDLL != 0 && hMsvcrtDLL != 0)\n\treturn TRUE;\n\n    // The iconv DLL file goes under different names, try them all.\n    // Do the \"2\" version first, it's newer.\n#ifdef DYNAMIC_ICONV_DLL_ALT2\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT2);\n#endif\n#ifdef DYNAMIC_ICONV_DLL_ALT3\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT3);\n#endif\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);\n#ifdef DYNAMIC_ICONV_DLL_ALT1\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT1);\n#endif\n\n    if (hIconvDLL != 0)\n\thMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);\n    if (hIconvDLL == 0 || hMsvcrtDLL == 0)\n    {\n\t// Only give the message when 'verbose' is set, otherwise it might be\n\t// done whenever a conversion is attempted.\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_str_str),\n\t\t    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL,\n\t\t    GetWin32Error());\n\t    verbose_leave();\n\t}\n\ticonv_end();\n\treturn FALSE;\n    }\n\n    iconv\t= (void *)GetProcAddress(hIconvDLL, \"libiconv\");\n    iconv_open\t= (void *)GetProcAddress(hIconvDLL, \"libiconv_open\");\n    iconv_close\t= (void *)GetProcAddress(hIconvDLL, \"libiconv_close\");\n    iconvctl\t= (void *)GetProcAddress(hIconvDLL, \"libiconvctl\");\n    iconv_errno\t= get_dll_import_func(hIconvDLL, \"_errno\");\n    if (iconv_errno == NULL)\n\ticonv_errno = (void *)GetProcAddress(hMsvcrtDLL, \"_errno\");\n    if (iconv == NULL || iconv_open == NULL || iconv_close == NULL\n\t    || iconvctl == NULL || iconv_errno == NULL)\n    {\n\ticonv_end();\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_function_str), \"for libiconv\");\n\t    verbose_leave();\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n    void\niconv_end(void)\n{\n    // Don't use iconv() when inputting or outputting characters.\n    if (input_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&input_conv, NULL, NULL);\n    if (output_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&output_conv, NULL, NULL);\n\n    if (hIconvDLL != 0)\n\tFreeLibrary(hIconvDLL);\n    if (hMsvcrtDLL != 0)\n\tFreeLibrary(hMsvcrtDLL);\n    hIconvDLL = 0;\n    hMsvcrtDLL = 0;\n}\n#  endif // DYNAMIC_ICONV\n# endif // USE_ICONV\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getimstatus()\" function\n */\n    void\nf_getimstatus(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# if defined(HAVE_INPUT_METHOD)\n    rettv->vval.v_number = im_get_status();\n# endif\n}\n\n/*\n * iconv() function\n */\n    void\nf_iconv(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*from, *to, *str;\n    vimconv_T\tvimconv;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string(&argvars[0]);\n    from = enc_canonize(enc_skip(tv_get_string_buf(&argvars[1], buf1)));\n    to = enc_canonize(enc_skip(tv_get_string_buf(&argvars[2], buf2)));\n    vimconv.vc_type = CONV_NONE;\n    convert_setup(&vimconv, from, to);\n\n    // If the encodings are equal, no conversion needed.\n    if (vimconv.vc_type == CONV_NONE)\n\trettv->vval.v_string = vim_strsave(str);\n    else\n\trettv->vval.v_string = string_convert(&vimconv, str, NULL);\n\n    convert_setup(&vimconv, NULL, NULL);\n    vim_free(from);\n    vim_free(to);\n}\n#endif\n\n/*\n * Setup \"vcp\" for conversion from \"from\" to \"to\".\n * The names must have been made canonical with enc_canonize().\n * vcp->vc_type must have been initialized to CONV_NONE.\n * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8\n * instead).\n * Afterwards invoke with \"from\" and \"to\" equal to NULL to cleanup.\n * Return FAIL when conversion is not supported, OK otherwise.\n */\n    int\nconvert_setup(vimconv_T *vcp, char_u *from, char_u *to)\n{\n    return convert_setup_ext(vcp, from, TRUE, to, TRUE);\n}\n\n/*\n * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all\n * \"from\" unicode charsets be considered utf-8.  Same for \"to\".\n */\n    int\nconvert_setup_ext(\n    vimconv_T\t*vcp,\n    char_u\t*from,\n    int\t\tfrom_unicode_is_utf8,\n    char_u\t*to,\n    int\t\tto_unicode_is_utf8)\n{\n    int\t\tfrom_prop;\n    int\t\tto_prop;\n    int\t\tfrom_is_utf8;\n    int\t\tto_is_utf8;\n\n    // Reset to no conversion.\n#ifdef USE_ICONV\n    if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)\n\ticonv_close(vcp->vc_fd);\n#endif\n    vcp->vc_type = CONV_NONE;\n    vcp->vc_factor = 1;\n    vcp->vc_fail = FALSE;\n\n    // No conversion when one of the names is empty or they are equal.\n    if (from == NULL || *from == NUL || to == NULL || *to == NUL\n\t\t\t\t\t\t     || STRCMP(from, to) == 0)\n\treturn OK;\n\n    from_prop = enc_canon_props(from);\n    to_prop = enc_canon_props(to);\n    if (from_unicode_is_utf8)\n\tfrom_is_utf8 = from_prop & ENC_UNICODE;\n    else\n\tfrom_is_utf8 = from_prop == ENC_UNICODE;\n    if (to_unicode_is_utf8)\n\tto_is_utf8 = to_prop & ENC_UNICODE;\n    else\n\tto_is_utf8 = to_prop == ENC_UNICODE;\n\n    if ((from_prop & ENC_LATIN1) && to_is_utf8)\n    {\n\t// Internal latin1 -> utf-8 conversion.\n\tvcp->vc_type = CONV_TO_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN9) && to_is_utf8)\n    {\n\t// Internal latin9 -> utf-8 conversion.\n\tvcp->vc_type = CONV_9_TO_UTF8;\n\tvcp->vc_factor = 3;\t// up to three as long (euro sign)\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN1))\n    {\n\t// Internal utf-8 -> latin1 conversion.\n\tvcp->vc_type = CONV_TO_LATIN1;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN9))\n    {\n\t// Internal utf-8 -> latin9 conversion.\n\tvcp->vc_type = CONV_TO_LATIN9;\n    }\n#ifdef MSWIN\n    // Win32-specific codepage <-> codepage conversion without iconv.\n    else if ((from_is_utf8 || encname2codepage(from) > 0)\n\t    && (to_is_utf8 || encname2codepage(to) > 0))\n    {\n\tvcp->vc_type = CONV_CODEPAGE;\n\tvcp->vc_factor = 2;\t// up to twice as long\n\tvcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);\n\tvcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);\n    }\n#endif\n#ifdef MACOS_CONVERT\n    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))\n    {\n\tvcp->vc_type = CONV_MAC_LATIN1;\n    }\n    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)\n    {\n\tvcp->vc_type = CONV_MAC_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_LATIN1_MAC;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_UTF8_MAC;\n    }\n#endif\n#ifdef USE_ICONV\n    else\n    {\n\t// Use iconv() for conversion.\n\tvcp->vc_fd = (iconv_t)my_iconv_open(\n\t\tto_is_utf8 ? (char_u *)\"utf-8\" : to,\n\t\tfrom_is_utf8 ? (char_u *)\"utf-8\" : from);\n\tif (vcp->vc_fd != (iconv_t)-1)\n\t{\n\t    vcp->vc_type = CONV_ICONV;\n\t    vcp->vc_factor = 4;\t// could be longer too...\n\t}\n    }\n#endif\n    if (vcp->vc_type == CONV_NONE)\n\treturn FAIL;\n\n    return OK;\n}\n\n#if defined(FEAT_GUI) || defined(AMIGA) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Do conversion on typed input characters in-place.\n * The input and output are not NUL terminated!\n * Returns the length after conversion.\n */\n    int\nconvert_input(char_u *ptr, int len, int maxlen)\n{\n    return convert_input_safe(ptr, len, maxlen, NULL, NULL);\n}\n#endif\n\n/*\n * Like convert_input(), but when there is an incomplete byte sequence at the\n * end return that as an allocated string in \"restp\" and set \"*restlenp\" to\n * the length.  If \"restp\" is NULL it is not used.\n */\n    int\nconvert_input_safe(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tmaxlen,\n    char_u\t**restp,\n    int\t\t*restlenp)\n{\n    char_u\t*d;\n    int\t\tdlen = len;\n    int\t\tunconvertlen = 0;\n\n    d = string_convert_ext(&input_conv, ptr, &dlen,\n\t\t\t\t\trestp == NULL ? NULL : &unconvertlen);\n    if (d != NULL)\n    {\n\tif (dlen <= maxlen)\n\t{\n\t    if (unconvertlen > 0)\n\t    {\n\t\t// Move the unconverted characters to allocated memory.\n\t\t*restp = alloc(unconvertlen);\n\t\tif (*restp != NULL)\n\t\t    mch_memmove(*restp, ptr + len - unconvertlen, unconvertlen);\n\t\t*restlenp = unconvertlen;\n\t    }\n\t    mch_memmove(ptr, d, dlen);\n\t}\n\telse\n\t    // result is too long, keep the unconverted text (the caller must\n\t    // have done something wrong!)\n\t    dlen = len;\n\tvim_free(d);\n    }\n    return dlen;\n}\n\n/*\n * Convert text \"ptr[*lenp]\" according to \"vcp\".\n * Returns the result in allocated memory and sets \"*lenp\".\n * When \"lenp\" is NULL, use NUL terminated strings.\n * Illegal chars are often changed to \"?\", unless vcp->vc_fail is set.\n * When something goes wrong, NULL is returned and \"*lenp\" is unchanged.\n */\n    char_u *\nstring_convert(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp)\n{\n    return string_convert_ext(vcp, ptr, lenp, NULL);\n}\n\n/*\n * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is\n * an incomplete sequence at the end it is not converted and \"*unconvlenp\" is\n * set to the number of remaining bytes.\n */\n    char_u *\nstring_convert_ext(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp,\n    int\t\t*unconvlenp)\n{\n    char_u\t*retval = NULL;\n    char_u\t*d;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tl;\n    int\t\tc;\n\n    if (lenp == NULL)\n\tlen = (int)STRLEN(ptr);\n    else\n\tlen = *lenp;\n    if (len == 0)\n\treturn vim_strsave((char_u *)\"\");\n\n    switch (vcp->vc_type)\n    {\n\tcase CONV_TO_UTF8:\t// latin1 to utf-8 conversion\n\t    retval = alloc(len * 2 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tif (c < 0x80)\n\t\t    *d++ = c;\n\t\telse\n\t\t{\n\t\t    *d++ = 0xc0 + ((unsigned)c >> 6);\n\t\t    *d++ = 0x80 + (c & 0x3f);\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_9_TO_UTF8:\t// latin9 to utf-8 conversion\n\t    retval = alloc(len * 3 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tswitch (c)\n\t\t{\n\t\t    case 0xa4: c = 0x20ac; break;   // euro\n\t\t    case 0xa6: c = 0x0160; break;   // S hat\n\t\t    case 0xa8: c = 0x0161; break;   // S -hat\n\t\t    case 0xb4: c = 0x017d; break;   // Z hat\n\t\t    case 0xb8: c = 0x017e; break;   // Z -hat\n\t\t    case 0xbc: c = 0x0152; break;   // OE\n\t\t    case 0xbd: c = 0x0153; break;   // oe\n\t\t    case 0xbe: c = 0x0178; break;   // Y\n\t\t}\n\t\td += utf_char2bytes(c, d);\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_TO_LATIN1:\t// utf-8 to latin1 conversion\n\tcase CONV_TO_LATIN9:\t// utf-8 to latin9 conversion\n\t    retval = alloc(len + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tl = utf_ptr2len_len(ptr + i, len - i);\n\t\tif (l == 0)\n\t\t    *d++ = NUL;\n\t\telse if (l == 1)\n\t\t{\n\t\t    int l_w = utf8len_tab_zero[ptr[i]];\n\n\t\t    if (l_w == 0)\n\t\t    {\n\t\t\t// Illegal utf-8 byte cannot be converted\n\t\t\tvim_free(retval);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (unconvlenp != NULL && l_w > len - i)\n\t\t    {\n\t\t\t// Incomplete sequence at the end.\n\t\t\t*unconvlenp = len - i;\n\t\t\tbreak;\n\t\t    }\n\t\t    *d++ = ptr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = utf_ptr2char(ptr + i);\n\t\t    if (vcp->vc_type == CONV_TO_LATIN9)\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 0x20ac: c = 0xa4; break;   // euro\n\t\t\t    case 0x0160: c = 0xa6; break;   // S hat\n\t\t\t    case 0x0161: c = 0xa8; break;   // S -hat\n\t\t\t    case 0x017d: c = 0xb4; break;   // Z hat\n\t\t\t    case 0x017e: c = 0xb8; break;   // Z -hat\n\t\t\t    case 0x0152: c = 0xbc; break;   // OE\n\t\t\t    case 0x0153: c = 0xbd; break;   // oe\n\t\t\t    case 0x0178: c = 0xbe; break;   // Y\n\t\t\t    case 0xa4:\n\t\t\t    case 0xa6:\n\t\t\t    case 0xa8:\n\t\t\t    case 0xb4:\n\t\t\t    case 0xb8:\n\t\t\t    case 0xbc:\n\t\t\t    case 0xbd:\n\t\t\t    case 0xbe: c = 0x100; break; // not in latin9\n\t\t\t}\n\t\t    if (!utf_iscomposing(c))\t// skip composing chars\n\t\t    {\n\t\t\tif (c < 0x100)\n\t\t\t    *d++ = c;\n\t\t\telse if (vcp->vc_fail)\n\t\t\t{\n\t\t\t    vim_free(retval);\n\t\t\t    return NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    *d++ = 0xbf;\n\t\t\t    if (utf_char2cells(c) > 1)\n\t\t\t\t*d++ = '?';\n\t\t\t}\n\t\t    }\n\t\t    i += l - 1;\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n# ifdef MACOS_CONVERT\n\tcase CONV_MAC_LATIN1:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'l', unconvlenp);\n\t    break;\n\n\tcase CONV_LATIN1_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'l', 'm', unconvlenp);\n\t    break;\n\n\tcase CONV_MAC_UTF8:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'u', unconvlenp);\n\t    break;\n\n\tcase CONV_UTF8_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'u', 'm', unconvlenp);\n\t    break;\n# endif\n\n# ifdef USE_ICONV\n\tcase CONV_ICONV:\t// conversion with output_conv.vc_fd\n\t    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);\n\t    break;\n# endif\n# ifdef MSWIN\n\tcase CONV_CODEPAGE:\t\t// codepage -> codepage\n\t{\n\t    int\t\tretlen;\n\t    int\t\ttmp_len;\n\t    short_u\t*tmp;\n\n\t    // 1. codepage/UTF-8  ->  ucs-2.\n\t    if (vcp->vc_cpfrom == 0)\n\t\ttmp_len = utf8_to_utf16(ptr, len, NULL, NULL);\n\t    else\n\t    {\n\t\ttmp_len = MultiByteToWideChar(vcp->vc_cpfrom,\n\t\t\t\t\tunconvlenp ? MB_ERR_INVALID_CHARS : 0,\n\t\t\t\t\t(char *)ptr, len, 0, 0);\n\t\tif (tmp_len == 0\n\t\t\t&& GetLastError() == ERROR_NO_UNICODE_TRANSLATION)\n\t\t{\n\t\t    if (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\t    if (unconvlenp != NULL)\n\t\t\t*unconvlenp = len;\n\t\t    retval = alloc(1);\n\t\t    if (retval)\n\t\t\tretval[0] = NUL;\n\t\t    return retval;\n\t\t}\n\t    }\n\t    tmp = ALLOC_MULT(short_u, tmp_len);\n\t    if (tmp == NULL)\n\t\tbreak;\n\t    if (vcp->vc_cpfrom == 0)\n\t\tutf8_to_utf16(ptr, len, tmp, unconvlenp);\n\t    else\n\t\tMultiByteToWideChar(vcp->vc_cpfrom, 0,\n\t\t\t(char *)ptr, len, tmp, tmp_len);\n\n\t    // 2. ucs-2  ->  codepage/UTF-8.\n\t    if (vcp->vc_cpto == 0)\n\t\tretlen = utf16_to_utf8(tmp, tmp_len, NULL);\n\t    else\n\t\tretlen = WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t\t    tmp, tmp_len, 0, 0, 0, 0);\n\t    retval = alloc(retlen + 1);\n\t    if (retval != NULL)\n\t    {\n\t\tif (vcp->vc_cpto == 0)\n\t\t    utf16_to_utf8(tmp, tmp_len, retval);\n\t\telse\n\t\t    WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t  tmp, tmp_len,\n\t\t\t\t\t  (char *)retval, retlen, 0, 0);\n\t\tretval[retlen] = NUL;\n\t\tif (lenp != NULL)\n\t\t    *lenp = retlen;\n\t    }\n\t    vim_free(tmp);\n\t    break;\n\t}\n# endif\n    }\n\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Table set by setcellwidths().\n */\ntypedef struct\n{\n    long    first;\n    long    last;\n    char    width;\n} cw_interval_T;\n\nstatic cw_interval_T\t*cw_table = NULL;\nstatic size_t\t\tcw_table_size = 0;\n\n/*\n * Return 1 or 2 when \"c\" is in the cellwidth table.\n * Return 0 if not.\n */\n    static int\ncw_value(int c)\n{\n    int mid, bot, top;\n\n    if (cw_table == NULL)\n\treturn 0;\n\n    // first quick check for Latin1 etc. characters\n    if (c < cw_table[0].first)\n\treturn 0;\n\n    // binary search in table\n    bot = 0;\n    top = (int)cw_table_size - 1;\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (cw_table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (cw_table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return cw_table[mid].width;\n    }\n    return 0;\n}\n\n    static int\ntv_nr_compare(const void *a1, const void *a2)\n{\n    listitem_T *li1 = *(listitem_T **)a1;\n    listitem_T *li2 = *(listitem_T **)a2;\n\n    return li1->li_tv.vval.v_number - li2->li_tv.vval.v_number;\n}\n\n    void\nf_setcellwidths(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    list_T\t    *l;\n    listitem_T\t    *li;\n    int\t\t    item;\n    int\t\t    i;\n    listitem_T\t    **ptrs;\n    cw_interval_T   *table;\n    cw_interval_T   *cw_table_save;\n    size_t\t    cw_table_size_save;\n\n    if (in_vim9script() && check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn;\n    }\n    l = argvars[0].vval.v_list;\n    if (l->lv_len == 0)\n    {\n\t// Clearing the table.\n\tvim_free(cw_table);\n\tcw_table = NULL;\n\tcw_table_size = 0;\n\treturn;\n    }\n\n    ptrs = ALLOC_MULT(listitem_T *, l->lv_len);\n    if (ptrs == NULL)\n\treturn;\n\n    // Check that all entries are a list with three numbers, the range is\n    // valid and the cell width is valid.\n    item = 0;\n    for (li = l->lv_first; li != NULL; li = li->li_next)\n    {\n\tlistitem_T *lili;\n\tvarnumber_T n1;\n\n\tif (li->li_tv.v_type != VAR_LIST || li->li_tv.vval.v_list == NULL)\n\t{\n\t    semsg(_(e_list_item_nr_is_not_list), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\n\tlili = li->li_tv.vval.v_list->lv_first;\n\tptrs[item] = lili;\n\tfor (i = 0; lili != NULL; lili = lili->li_next, ++i)\n\t{\n\t    if (lili->li_tv.v_type != VAR_NUMBER)\n\t\tbreak;\n\t    if (i == 0)\n\t    {\n\t\tn1 = lili->li_tv.vval.v_number;\n\t\tif (n1 < 0x100)\n\t\t{\n\t\t    emsg(_(e_only_values_of_0x100_and_higher_supported));\n\t\t    vim_free(ptrs);\n\t\t    return;\n\t\t}\n\t    }\n\t    else if (i == 1 && lili->li_tv.vval.v_number < n1)\n\t    {\n\t\tsemsg(_(e_list_item_nr_range_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t    else if (i == 2 && (lili->li_tv.vval.v_number < 1\n\t\t\t\t\t     || lili->li_tv.vval.v_number > 2))\n\t    {\n\t\tsemsg(_(e_list_item_nr_cell_width_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t}\n\tif (i != 3)\n\t{\n\t    semsg(_(e_list_item_nr_does_not_contain_3_numbers), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\t++item;\n    }\n\n    // Sort the list on the first number.\n    qsort((void *)ptrs, (size_t)l->lv_len, sizeof(listitem_T *), tv_nr_compare);\n\n    table = ALLOC_MULT(cw_interval_T, l->lv_len);\n    if (table == NULL)\n    {\n\tvim_free(ptrs);\n\treturn;\n    }\n\n    // Store the items in the new table.\n    item = 0;\n    for (item = 0; item < l->lv_len; ++item)\n    {\n\tlistitem_T\t*lili = ptrs[item];\n\tvarnumber_T\tn1;\n\n\tn1 = lili->li_tv.vval.v_number;\n\tif (item > 0 && n1 <= table[item - 1].last)\n\t{\n\t    semsg(_(e_overlapping_ranges_for_nr), (long)n1);\n\t    vim_free(ptrs);\n\t    vim_free(table);\n\t    return;\n\t}\n\ttable[item].first = n1;\n\tlili = lili->li_next;\n\ttable[item].last = lili->li_tv.vval.v_number;\n\tlili = lili->li_next;\n\ttable[item].width = lili->li_tv.vval.v_number;\n    }\n\n    vim_free(ptrs);\n\n    cw_table_save = cw_table;\n    cw_table_size_save = cw_table_size;\n    cw_table = table;\n    cw_table_size = l->lv_len;\n\n    // Check that the new value does not conflict with 'fillchars' or\n    // 'listchars'.\n    if (set_chars_option(curwin, &p_fcs) != NULL)\n    {\n\temsg(_(e_conflicts_with_value_of_fillchars));\n\tcw_table = cw_table_save;\n\tcw_table_size = cw_table_size_save;\n\tvim_free(table);\n\treturn;\n    }\n    else\n    {\n\ttabpage_T\t*tp;\n\twin_T\t*wp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t{\n\t    if (set_chars_option(wp, &wp->w_p_lcs) != NULL)\n\t    {\n\t\temsg((e_conflicts_with_value_of_listchars));\n\t\tcw_table = cw_table_save;\n\t\tcw_table_size = cw_table_size_save;\n\t\tvim_free(table);\n\t\treturn;\n\t    }\n\t}\n    }\n\n    vim_free(cw_table_save);\n}\n\n    void\nf_charclass(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || argvars[0].vval.v_string == NULL)\n\treturn;\n    rettv->vval.v_number = mb_get_class(argvars[0].vval.v_string);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellfile.c: code for reading and writing spell files.\n *\n * See spell.c for information about spell checking.\n */\n\n/*\n * Vim spell file format: <HEADER>\n *\t\t\t  <SECTIONS>\n *\t\t\t  <LWORDTREE>\n *\t\t\t  <KWORDTREE>\n *\t\t\t  <PREFIXTREE>\n *\n * <HEADER>: <fileID> <versionnr>\n *\n * <fileID>     8 bytes    \"VIMspell\"\n * <versionnr>  1 byte\t    VIMSPELLVERSION\n *\n *\n * Sections make it possible to add information to the .spl file without\n * making it incompatible with previous versions.  There are two kinds of\n * sections:\n * 1. Not essential for correct spell checking.  E.g. for making suggestions.\n *    These are skipped when not supported.\n * 2. Optional information, but essential for spell checking when present.\n *    E.g. conditions for affixes.  When this section is present but not\n *    supported an error message is given.\n *\n * <SECTIONS>: <section> ... <sectionend>\n *\n * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n *\n * <sectionID>\t  1 byte    number from 0 to 254 identifying the section\n *\n * <sectionflags> 1 byte    SNF_REQUIRED: this section is required for correct\n *\t\t\t\t\t    spell checking\n *\n * <sectionlen>   4 bytes   length of section contents, MSB first\n *\n * <sectionend>\t  1 byte    SN_END\n *\n *\n * sectionID == SN_INFO: <infotext>\n * <infotext>\t N bytes    free format text with spell file info (version,\n *\t\t\t    website, etc)\n *\n * sectionID == SN_REGION: <regionname> ...\n * <regionname>\t 2 bytes    Up to MAXREGIONS region names: ca, au, etc.  Lower\n *\t\t\t    case.  First <regionname> is region 1.\n *\n * sectionID == SN_CHARFLAGS: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * <charflagslen> 1 byte    Number of bytes in <charflags> (should be 128).\n * <charflags>  N bytes     List of flags (first one is for character 128):\n *\t\t\t    0x01  word character\tCF_WORD\n *\t\t\t    0x02  upper-case character\tCF_UPPER\n * <folcharslen>  2 bytes   Number of bytes in <folchars>.\n * <folchars>     N bytes   Folded characters, first one is for character 128.\n *\n * sectionID == SN_MIDWORD: <midword>\n * <midword>     N bytes    Characters that are word characters only when used\n *\t\t\t    in the middle of a word.\n *\n * sectionID == SN_PREFCOND: <prefcondcnt> <prefcond> ...\n * <prefcondcnt> 2 bytes    Number of <prefcond> items following.\n * <prefcond> : <condlen> <condstr>\n * <condlen>\t1 byte\t    Length of <condstr>.\n * <condstr>\tN bytes\t    Condition for the prefix.\n *\n * sectionID == SN_REP: <repcount> <rep> ...\n * <repcount>\t 2 bytes    number of <rep> items, MSB first.\n * <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n * <repfromlen>\t 1 byte\t    length of <repfrom>\n * <repfrom>\t N bytes    \"from\" part of replacement\n * <reptolen>\t 1 byte\t    length of <repto>\n * <repto>\t N bytes    \"to\" part of replacement\n *\n * sectionID == SN_REPSAL: <repcount> <rep> ...\n *   just like SN_REP but for soundfolded words\n *\n * sectionID == SN_SAL: <salflags> <salcount> <sal> ...\n * <salflags>\t 1 byte\t    flags for soundsalike conversion:\n *\t\t\t    SAL_F0LLOWUP\n *\t\t\t    SAL_COLLAPSE\n *\t\t\t    SAL_REM_ACCENTS\n * <salcount>    2 bytes    number of <sal> items following\n * <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n * <salfromlen>\t 1 byte\t    length of <salfrom>\n * <salfrom>\t N bytes    \"from\" part of soundsalike\n * <saltolen>\t 1 byte\t    length of <salto>\n * <salto>\t N bytes    \"to\" part of soundsalike\n *\n * sectionID == SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * <sofofromlen> 2 bytes    length of <sofofrom>\n * <sofofrom>\t N bytes    \"from\" part of soundfold\n * <sofotolen>\t 2 bytes    length of <sofoto>\n * <sofoto>\t N bytes    \"to\" part of soundfold\n *\n * sectionID == SN_SUGFILE: <timestamp>\n * <timestamp>   8 bytes    time in seconds that must match with .sug file\n *\n * sectionID == SN_NOSPLITSUGS: nothing\n\t *\n * sectionID == SN_NOCOMPOUNDSUGS: nothing\n *\n * sectionID == SN_WORDS: <word> ...\n * <word>\t N bytes    NUL terminated common word\n *\n * sectionID == SN_MAP: <mapstr>\n * <mapstr>\t N bytes    String with sequences of similar characters,\n *\t\t\t    separated by slashes.\n *\n * sectionID == SN_COMPOUND: <compmax> <compminlen> <compsylmax> <compoptions>\n *\t\t\t\t<comppatcount> <comppattern> ... <compflags>\n * <compmax>     1 byte\t    Maximum nr of words in compound word.\n * <compminlen>  1 byte\t    Minimal word length for compounding.\n * <compsylmax>  1 byte\t    Maximum nr of syllables in compound word.\n * <compoptions> 2 bytes    COMP_ flags.\n * <comppatcount> 2 bytes   number of <comppattern> following\n * <compflags>   N bytes    Flags from COMPOUNDRULE items, separated by\n *\t\t\t    slashes.\n *\n * <comppattern>: <comppatlen> <comppattext>\n * <comppatlen>\t 1 byte\t    length of <comppattext>\n * <comppattext> N bytes    end or begin chars from CHECKCOMPOUNDPATTERN\n *\n * sectionID == SN_NOBREAK: (empty, its presence is what matters)\n *\n * sectionID == SN_SYLLABLE: <syllable>\n * <syllable>    N bytes    String from SYLLABLE item.\n *\n * <LWORDTREE>: <wordtree>\n *\n * <KWORDTREE>: <wordtree>\n *\n * <PREFIXTREE>: <wordtree>\n *\n *\n * <wordtree>: <nodecount> <nodedata> ...\n *\n * <nodecount>\t4 bytes\t    Number of nodes following.  MSB first.\n *\n * <nodedata>: <siblingcount> <sibling> ...\n *\n * <siblingcount> 1 byte    Number of siblings in this node.  The siblings\n *\t\t\t    follow in sorted order.\n *\n * <sibling>: <byte> [ <nodeidx> <xbyte>\n *\t\t      | <flags> [<flags2>] [<region>] [<affixID>]\n *\t\t      | [<pflags>] <affixID> <prefcondnr> ]\n *\n * <byte>\t1 byte\t    Byte value of the sibling.  Special cases:\n *\t\t\t    BY_NOFLAGS: End of word without flags and for all\n *\t\t\t\t\tregions.\n *\t\t\t\t\tFor PREFIXTREE <affixID> and\n *\t\t\t\t\t<prefcondnr> follow.\n *\t\t\t    BY_FLAGS:   End of word, <flags> follow.\n *\t\t\t\t\tFor PREFIXTREE <pflags>, <affixID>\n *\t\t\t\t\tand <prefcondnr> follow.\n *\t\t\t    BY_FLAGS2:  End of word, <flags> and <flags2>\n *\t\t\t\t\tfollow.  Not used in PREFIXTREE.\n *\t\t\t    BY_INDEX:   Child of sibling is shared, <nodeidx>\n *\t\t\t\t\tand <xbyte> follow.\n *\n * <nodeidx>\t3 bytes\t    Index of child for this sibling, MSB first.\n *\n * <xbyte>\t1 byte\t    byte value of the sibling.\n *\n * <flags>\t1 byte\t    bitmask of:\n *\t\t\t    WF_ALLCAP\tword must have only capitals\n *\t\t\t    WF_ONECAP   first char of word must be capital\n *\t\t\t    WF_KEEPCAP\tkeep-case word\n *\t\t\t    WF_FIXCAP   keep-case word, all caps not allowed\n *\t\t\t    WF_RARE\trare word\n *\t\t\t    WF_BANNED\tbad word\n *\t\t\t    WF_REGION\t<region> follows\n *\t\t\t    WF_AFX\t<affixID> follows\n *\n * <flags2>\t1 byte\t    Bitmask of:\n *\t\t\t    WF_HAS_AFF >> 8   word includes affix\n *\t\t\t    WF_NEEDCOMP >> 8  word only valid in compound\n *\t\t\t    WF_NOSUGGEST >> 8  word not used for suggestions\n *\t\t\t    WF_COMPROOT >> 8  word already a compound\n *\t\t\t    WF_NOCOMPBEF >> 8 no compounding before this word\n *\t\t\t    WF_NOCOMPAFT >> 8 no compounding after this word\n *\n * <pflags>\t1 byte\t    bitmask of:\n *\t\t\t    WFP_RARE\trare prefix\n *\t\t\t    WFP_NC\tnon-combining prefix\n *\t\t\t    WFP_UP\tletter after prefix made upper case\n *\n * <region>\t1 byte\t    Bitmask for regions in which word is valid.  When\n *\t\t\t    omitted it's valid in all regions.\n *\t\t\t    Lowest bit is for region 1.\n *\n * <affixID>\t1 byte\t    ID of affix that can be used with this word.  In\n *\t\t\t    PREFIXTREE used for the required prefix ID.\n *\n * <prefcondnr>\t2 bytes\t    Prefix condition number, index in <prefcond> list\n *\t\t\t    from HEADER.\n *\n * All text characters are in 'encoding', but stored as single bytes.\n */\n\n/*\n * Vim .sug file format:  <SUGHEADER>\n *\t\t\t  <SUGWORDTREE>\n *\t\t\t  <SUGTABLE>\n *\n * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n *\n * <fileID>     6 bytes     \"VIMsug\"\n * <versionnr>  1 byte      VIMSUGVERSION\n * <timestamp>  8 bytes     timestamp that must match with .spl file\n *\n *\n * <SUGWORDTREE>: <wordtree>  (see above, no flags or region used)\n *\n *\n * <SUGTABLE>: <sugwcount> <sugline> ...\n *\n * <sugwcount>\t4 bytes\t    number of <sugline> following\n *\n * <sugline>: <sugnr> ... NUL\n *\n * <sugnr>:     X bytes     word number that results in this soundfolded word,\n *\t\t\t    stored as an offset to the previous number in as\n *\t\t\t    few bytes as possible, see offset2bytes())\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n// Special byte values for <byte>.  Some are only used in the tree for\n// postponed prefixes, some only in the other trees.  This is a bit messy...\n#define BY_NOFLAGS\t0\t// end of word without flags or region; for\n\t\t\t\t// postponed prefix: no <pflags>\n#define BY_INDEX\t1\t// child is shared, index follows\n#define BY_FLAGS\t2\t// end of word, <flags> byte follows; for\n\t\t\t\t// postponed prefix: <pflags> follows\n#define BY_FLAGS2\t3\t// end of word, <flags> and <flags2> bytes\n\t\t\t\t// follow; never used in prefix tree\n#define BY_SPECIAL  BY_FLAGS2\t// highest special byte value\n\n#define ZERO_FLAG\t65009\t// used when flag is zero: \"0\"\n\n// Flags used in .spl file for soundsalike flags.\n#define SAL_F0LLOWUP\t\t1\n#define SAL_COLLAPSE\t\t2\n#define SAL_REM_ACCENTS\t\t4\n\n#define VIMSPELLMAGIC \"VIMspell\"  // string at start of Vim spell file\n#define VIMSPELLMAGICL 8\n#define VIMSPELLVERSION 50\n\n// Section IDs.  Only renumber them when VIMSPELLVERSION changes!\n#define SN_REGION\t0\t// <regionname> section\n#define SN_CHARFLAGS\t1\t// charflags section\n#define SN_MIDWORD\t2\t// <midword> section\n#define SN_PREFCOND\t3\t// <prefcond> section\n#define SN_REP\t\t4\t// REP items section\n#define SN_SAL\t\t5\t// SAL items section\n#define SN_SOFO\t\t6\t// soundfolding section\n#define SN_MAP\t\t7\t// MAP items section\n#define SN_COMPOUND\t8\t// compound words section\n#define SN_SYLLABLE\t9\t// syllable section\n#define SN_NOBREAK\t10\t// NOBREAK section\n#define SN_SUGFILE\t11\t// timestamp for .sug file\n#define SN_REPSAL\t12\t// REPSAL items section\n#define SN_WORDS\t13\t// common words\n#define SN_NOSPLITSUGS\t14\t// don't split word for suggestions\n#define SN_INFO\t\t15\t// info section\n#define SN_NOCOMPOUNDSUGS 16\t// don't compound for suggestions\n#define SN_END\t\t255\t// end of sections\n\n#define SNF_REQUIRED\t1\t// <sectionflags>: required section\n\n#define CF_WORD\t\t0x01\n#define CF_UPPER\t0x02\n\n/*\n * Loop through all the siblings of a node (including the node)\n */\n#define FOR_ALL_NODE_SIBLINGS(node, np) \\\n    for ((np) = (node); (np) != NULL; (np) = (np)->wn_sibling)\n\nstatic int set_spell_finish(spelltab_T\t*new_st);\nstatic int write_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv);\nstatic int read_region_section(FILE *fd, slang_T *slang, int len);\nstatic int read_charflags_section(FILE *fd);\nstatic int read_prefcond_section(FILE *fd, slang_T *lp);\nstatic int read_rep_section(FILE *fd, garray_T *gap, short *first);\nstatic int read_sal_section(FILE *fd, slang_T *slang);\nstatic int read_words_section(FILE *fd, slang_T *lp, int len);\nstatic int read_sofo_section(FILE *fd, slang_T *slang);\nstatic int read_compound(FILE *fd, slang_T *slang, int len);\nstatic int set_sofo(slang_T *lp, char_u *from, char_u *to);\nstatic void set_sal_first(slang_T *lp);\nstatic int *mb_str2wide(char_u *s);\nstatic int spell_read_tree(FILE *fd, char_u **bytsp, long *bytsp_len, idx_T **idxsp, int prefixtree, int prefixcnt);\nstatic idx_T read_tree_node(FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr);\nstatic void set_spell_charflags(char_u *flags, int cnt, char_u *upp);\nstatic int set_spell_chartab(char_u *fol, char_u *low, char_u *upp);\nstatic void set_map_str(slang_T *lp, char_u *map);\n\n\nstatic char *e_afftrailing = N_(\"Trailing text in %s line %d: %s\");\nstatic char *e_affname = N_(\"Affix name too long in %s line %d: %s\");\nstatic char *msg_compressing = N_(\"Compressing word tree...\");\n\n/*\n * Load one spell file and store the info into a slang_T.\n *\n * This is invoked in three ways:\n * - From spell_load_cb() to load a spell file for the first time.  \"lang\" is\n *   the language name, \"old_lp\" is NULL.  Will allocate an slang_T.\n * - To reload a spell file that was changed.  \"lang\" is NULL and \"old_lp\"\n *   points to the existing slang_T.\n * - Just after writing a .spl file; it's read back to produce the .sug file.\n *   \"old_lp\" is NULL and \"lang\" is NULL.  Will allocate an slang_T.\n *\n * Returns the slang_T the spell file was loaded into.  NULL for error.\n */\n    slang_T *\nspell_load_file(\n    char_u\t*fname,\n    char_u\t*lang,\n    slang_T\t*old_lp,\n    int\t\tsilent)\t\t// no error if file doesn't exist\n{\n    FILE\t*fd;\n    char_u\tbuf[VIMSPELLMAGICL];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tn;\n    int\t\tlen;\n    slang_T\t*lp = NULL;\n    int\t\tc = 0;\n    int\t\tres;\n    int\t\tdid_estack_push = FALSE;\n    ESTACK_CHECK_DECLARATION\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tif (!silent)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse if (p_verbose > 2)\n\t{\n\t    verbose_enter();\n\t    smsg((const char *)e_cant_open_file_str, fname);\n\t    verbose_leave();\n\t}\n\tgoto endFAIL;\n    }\n    if (p_verbose > 2)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading spell file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    if (old_lp == NULL)\n    {\n\tlp = slang_alloc(lang);\n\tif (lp == NULL)\n\t    goto endFAIL;\n\n\t// Remember the file name, used to reload the file when it's updated.\n\tlp->sl_fname = vim_strsave(fname);\n\tif (lp->sl_fname == NULL)\n\t    goto endFAIL;\n\n\t// Check for .add.spl (_add.spl for VMS).\n\tlp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;\n    }\n    else\n\tlp = old_lp;\n\n    // Set sourcing_name, so that error messages mention the file name.\n    estack_push(ETYPE_SPELL, fname, 0);\n    ESTACK_CHECK_SETUP\n    did_estack_push = TRUE;\n\n    /*\n     * <HEADER>: <fileID>\n     */\n    for (i = 0; i < VIMSPELLMAGICL; ++i)\n\tbuf[i] = getc(fd);\t\t\t\t// <fileID>\n    if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)\n    {\n\temsg(_(e_this_does_not_look_like_spell_file));\n\tgoto endFAIL;\n    }\n    c = getc(fd);\t\t\t\t\t// <versionnr>\n    if (c < VIMSPELLVERSION)\n    {\n\temsg(_(e_old_spell_file_needs_to_be_updated));\n\tgoto endFAIL;\n    }\n    else if (c > VIMSPELLVERSION)\n    {\n\temsg(_(e_spell_file_is_for_newer_version_of_vim));\n\tgoto endFAIL;\n    }\n\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n     */\n    for (;;)\n    {\n\tn = getc(fd);\t\t\t    // <sectionID> or <sectionend>\n\tif (n == SN_END)\n\t    break;\n\tc = getc(fd);\t\t\t\t\t// <sectionflags>\n\tlen = get4c(fd);\t\t\t\t// <sectionlen>\n\tif (len < 0)\n\t    goto truncerr;\n\n\tres = 0;\n\tswitch (n)\n\t{\n\t    case SN_INFO:\n\t\tlp->sl_info = read_string(fd, len);\t// <infotext>\n\t\tif (lp->sl_info == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_REGION:\n\t\tres = read_region_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_CHARFLAGS:\n\t\tres = read_charflags_section(fd);\n\t\tbreak;\n\n\t    case SN_MIDWORD:\n\t\tlp->sl_midword = read_string(fd, len);\t// <midword>\n\t\tif (lp->sl_midword == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_PREFCOND:\n\t\tres = read_prefcond_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_REP:\n\t\tres = read_rep_section(fd, &lp->sl_rep, lp->sl_rep_first);\n\t\tbreak;\n\n\t    case SN_REPSAL:\n\t\tres = read_rep_section(fd, &lp->sl_repsal, lp->sl_repsal_first);\n\t\tbreak;\n\n\t    case SN_SAL:\n\t\tres = read_sal_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_SOFO:\n\t\tres = read_sofo_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_MAP:\n\t\tp = read_string(fd, len);\t\t// <mapstr>\n\t\tif (p == NULL)\n\t\t    goto endFAIL;\n\t\tset_map_str(lp, p);\n\t\tvim_free(p);\n\t\tbreak;\n\n\t    case SN_WORDS:\n\t\tres = read_words_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_SUGFILE:\n\t\tlp->sl_sugtime = get8ctime(fd);\t\t// <timestamp>\n\t\tbreak;\n\n\t    case SN_NOSPLITSUGS:\n\t\tlp->sl_nosplitsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_NOCOMPOUNDSUGS:\n\t\tlp->sl_nocompoundsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_COMPOUND:\n\t\tres = read_compound(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_NOBREAK:\n\t\tlp->sl_nobreak = TRUE;\n\t\tbreak;\n\n\t    case SN_SYLLABLE:\n\t\tlp->sl_syllable = read_string(fd, len);\t// <syllable>\n\t\tif (lp->sl_syllable == NULL)\n\t\t    goto endFAIL;\n\t\tif (init_syl_tab(lp) != OK)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    default:\n\t\t// Unsupported section.  When it's required give an error\n\t\t// message.  When it's not required skip the contents.\n\t\tif (c & SNF_REQUIRED)\n\t\t{\n\t\t    emsg(_(e_unsupported_section_in_spell_file));\n\t\t    goto endFAIL;\n\t\t}\n\t\twhile (--len >= 0)\n\t\t    if (getc(fd) < 0)\n\t\t\tgoto truncerr;\n\t\tbreak;\n\t}\nsomeerror:\n\tif (res == SP_FORMERROR)\n\t{\n\t    emsg(_(e_format_error_in_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_TRUNCERROR)\n\t{\ntruncerr:\n\t    emsg(_(e_truncated_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_OTHERERROR)\n\t    goto endFAIL;\n    }\n\n    // <LWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_fbyts, &lp->sl_fbyts_len,\n\t\t\t\t\t\t      &lp->sl_fidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <KWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_kbyts, NULL, &lp->sl_kidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <PREFIXTREE>\n    res = spell_read_tree(fd, &lp->sl_pbyts, NULL, &lp->sl_pidxs, TRUE,\n\t\t\t\t\t\t\t    lp->sl_prefixcnt);\n    if (res != 0)\n\tgoto someerror;\n\n    // For a new file link it in the list of spell files.\n    if (old_lp == NULL && lang != NULL)\n    {\n\tlp->sl_next = first_lang;\n\tfirst_lang = lp;\n    }\n\n    goto endOK;\n\nendFAIL:\n    if (lang != NULL)\n\t// truncating the name signals the error to spell_load_lang()\n\t*lang = NUL;\n    if (lp != NULL && old_lp == NULL)\n\tslang_free(lp);\n    lp = NULL;\n\nendOK:\n    if (fd != NULL)\n\tfclose(fd);\n    if (did_estack_push)\n    {\n\tESTACK_CHECK_NOW\n\testack_pop();\n    }\n\n    return lp;\n}\n\n/*\n * Fill in the wordcount fields for a trie.\n * Returns the total number of words.\n */\n    static void\ntree_count_words(char_u *byts, idx_T *idxs)\n{\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    int\t\twordcount[MAXWLEN];\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    fast_breakcheck();\n\t}\n\telse\n\t{\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// End of word, count it.\n\t\t++wordcount[depth];\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).\n\t\twhile (byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper to count the words.\n\t\t++depth;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Load the .sug files for languages that have one and weren't loaded yet.\n */\n    void\nsuggest_load_files(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    char_u\t*dotp;\n    FILE\t*fd;\n    char_u\tbuf[MAXWLEN];\n    int\t\ti;\n    time_t\ttimestamp;\n    int\t\twcount;\n    int\t\twordnr;\n    garray_T\tga;\n    int\t\tc;\n\n    // Do this for all languages that support sound folding.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sugtime != 0 && !slang->sl_sugloaded)\n\t{\n\t    // Change \".spl\" to \".sug\" and open the file.  When the file isn't\n\t    // found silently skip it.  Do set \"sl_sugloaded\" so that we\n\t    // don't try again and again.\n\t    slang->sl_sugloaded = TRUE;\n\n\t    dotp = vim_strrchr(slang->sl_fname, '.');\n\t    if (dotp == NULL || fnamecmp(dotp, \".spl\") != 0)\n\t\tcontinue;\n\t    STRCPY(dotp, \".sug\");\n\t    fd = mch_fopen((char *)slang->sl_fname, \"r\");\n\t    if (fd == NULL)\n\t\tgoto nextone;\n\n\t    /*\n\t     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n\t     */\n\t    for (i = 0; i < VIMSUGMAGICL; ++i)\n\t\tbuf[i] = getc(fd);\t\t\t// <fileID>\n\t    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)\n\t    {\n\t\tsemsg(_(e_this_does_not_look_like_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    c = getc(fd);\t\t\t\t// <versionnr>\n\t    if (c < VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_old_sug_file_needs_to_be_updated_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    else if (c > VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_sug_file_is_for_newer_version_of_vim_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    // Check the timestamp, it must be exactly the same as the one in\n\t    // the .spl file.  Otherwise the word numbers won't match.\n\t    timestamp = get8ctime(fd);\t\t\t// <timestamp>\n\t    if (timestamp != slang->sl_sugtime)\n\t    {\n\t\tsemsg(_(e_sug_file_doesnt_match_spl_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGWORDTREE>: <wordtree>\n\t     * Read the trie with the soundfolded words.\n\t     */\n\t    if (spell_read_tree(fd, &slang->sl_sbyts, NULL, &slang->sl_sidxs,\n\t\t\t\t\t\t\t       FALSE, 0) != 0)\n\t    {\nsomeerror:\n\t\tsemsg(_(e_error_while_reading_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tslang_clear_sug(slang);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGTABLE>: <sugwcount> <sugline> ...\n\t     *\n\t     * Read the table with word numbers.  We use a file buffer for\n\t     * this, because it's so much like a file with lines.  Makes it\n\t     * possible to swap the info and save on memory use.\n\t     */\n\t    slang->sl_sugbuf = open_spellbuf();\n\t    if (slang->sl_sugbuf == NULL)\n\t\tgoto someerror;\n\t\t\t\t\t\t\t    // <sugwcount>\n\t    wcount = get4c(fd);\n\t    if (wcount < 0)\n\t\tgoto someerror;\n\n\t    // Read all the wordnr lists into the buffer, one NUL terminated\n\t    // list per line.\n\t    ga_init2(&ga, 1, 100);\n\t    for (wordnr = 0; wordnr < wcount; ++wordnr)\n\t    {\n\t\tga.ga_len = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    c = getc(fd);\t\t\t    // <sugline>\n\t\t    if (c < 0 || ga_grow(&ga, 1) == FAIL)\n\t\t\tgoto someerror;\n\t\t    ((char_u *)ga.ga_data)[ga.ga_len++] = c;\n\t\t    if (c == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,\n\t\t\t\t\t ga.ga_data, ga.ga_len, TRUE) == FAIL)\n\t\t    goto someerror;\n\t    }\n\t    ga_clear(&ga);\n\n\t    /*\n\t     * Need to put word counts in the word tries, so that we can find\n\t     * a word by its number.\n\t     */\n\t    tree_count_words(slang->sl_fbyts, slang->sl_fidxs);\n\t    tree_count_words(slang->sl_sbyts, slang->sl_sidxs);\n\nnextone:\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    STRCPY(dotp, \".spl\");\n\t}\n    }\n}\n\n\n/*\n * Read a length field from \"fd\" in \"cnt_bytes\" bytes.\n * Allocate memory, read the string into it and add a NUL at the end.\n * Returns NULL when the count is zero.\n * Sets \"*cntp\" to SP_*ERROR when there is an error, length of the result\n * otherwise.\n */\n    static char_u *\nread_cnt_string(FILE *fd, int cnt_bytes, int *cntp)\n{\n    int\t\tcnt = 0;\n    int\t\ti;\n    char_u\t*str;\n\n    // read the length bytes, MSB first\n    for (i = 0; i < cnt_bytes; ++i)\n    {\n\tint c = getc(fd);\n\n\tif (c == EOF)\n\t{\n\t    *cntp = SP_TRUNCERROR;\n\t    return NULL;\n\t}\n\tcnt = (cnt << 8) + (unsigned)c;\n    }\n    *cntp = cnt;\n    if (cnt == 0)\n\treturn NULL;\t    // nothing to read, return NULL\n\n    str = read_string(fd, cnt);\n    if (str == NULL)\n\t*cntp = SP_OTHERERROR;\n    return str;\n}\n\n/*\n * Read SN_REGION: <regionname> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_region_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\ti;\n\n    if (len > MAXREGIONS * 2)\n\treturn SP_FORMERROR;\n    for (i = 0; i < len; ++i)\n\tlp->sl_regions[i] = getc(fd);\t\t\t// <regionname>\n    lp->sl_regions[len] = NUL;\n    return 0;\n}\n\n/*\n * Read SN_CHARFLAGS section: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * Return SP_*ERROR flags.\n */\n    static int\nread_charflags_section(FILE *fd)\n{\n    char_u\t*flags;\n    char_u\t*fol;\n    int\t\tflagslen, follen;\n\n    // <charflagslen> <charflags>\n    flags = read_cnt_string(fd, 1, &flagslen);\n    if (flagslen < 0)\n\treturn flagslen;\n\n    // <folcharslen> <folchars>\n    fol = read_cnt_string(fd, 2, &follen);\n    if (follen < 0)\n    {\n\tvim_free(flags);\n\treturn follen;\n    }\n\n    // Set the word-char flags and fill SPELL_ISUPPER() table.\n    if (flags != NULL && fol != NULL)\n\tset_spell_charflags(flags, flagslen, fol);\n\n    vim_free(flags);\n    vim_free(fol);\n\n    // When <charflagslen> is zero then <fcharlen> must also be zero.\n    if ((flags == NULL) != (fol == NULL))\n\treturn SP_FORMERROR;\n    return 0;\n}\n\n/*\n * Read SN_PREFCOND section.\n * Return SP_*ERROR flags.\n */\n    static int\nread_prefcond_section(FILE *fd, slang_T *lp)\n{\n    int\t\tcnt;\n    int\t\ti;\n    int\t\tn;\n    char_u\t*p;\n    char_u\tbuf[MAXWLEN + 1];\n\n    // <prefcondcnt> <prefcond> ...\n    cnt = get2c(fd);\t\t\t\t\t// <prefcondcnt>\n    if (cnt <= 0)\n\treturn SP_FORMERROR;\n\n    lp->sl_prefprog = ALLOC_CLEAR_MULT(regprog_T *, cnt);\n    if (lp->sl_prefprog == NULL)\n\treturn SP_OTHERERROR;\n    lp->sl_prefixcnt = cnt;\n\n    for (i = 0; i < cnt; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tn = getc(fd);\t\t\t\t\t// <condlen>\n\tif (n < 0 || n >= MAXWLEN)\n\t    return SP_FORMERROR;\n\n\t// When <condlen> is zero we have an empty condition.  Otherwise\n\t// compile the regexp program used to check for the condition.\n\tif (n > 0)\n\t{\n\t    buf[0] = '^';\t    // always match at one position only\n\t    p = buf + 1;\n\t    while (n-- > 0)\n\t\t*p++ = getc(fd);\t\t\t// <condstr>\n\t    *p = NUL;\n\t    lp->sl_prefprog[i] = vim_regcomp(buf, RE_MAGIC + RE_STRING);\n\t}\n    }\n    return 0;\n}\n\n/*\n * Read REP or REPSAL items section from \"fd\": <repcount> <rep> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_rep_section(FILE *fd, garray_T *gap, short *first)\n{\n    int\t\tcnt;\n    fromto_T\t*ftp;\n    int\t\ti;\n\n    cnt = get2c(fd);\t\t\t\t\t// <repcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    if (ga_grow(gap, cnt) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[gap->ga_len];\n\tftp->ft_from = read_cnt_string(fd, 1, &i);\n\tif (i < 0)\n\t    return i;\n\tif (i == 0)\n\t    return SP_FORMERROR;\n\tftp->ft_to = read_cnt_string(fd, 1, &i);\n\tif (i <= 0)\n\t{\n\t    vim_free(ftp->ft_from);\n\t    if (i < 0)\n\t\treturn i;\n\t    return SP_FORMERROR;\n\t}\n    }\n\n    // Fill the first-index table.\n    for (i = 0; i < 256; ++i)\n\tfirst[i] = -1;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[i];\n\tif (first[*ftp->ft_from] == -1)\n\t    first[*ftp->ft_from] = i;\n    }\n    return 0;\n}\n\n/*\n * Read SN_SAL section: <salflags> <salcount> <sal> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_sal_section(FILE *fd, slang_T *slang)\n{\n    int\t\ti;\n    int\t\tcnt;\n    garray_T\t*gap;\n    salitem_T\t*smp;\n    int\t\tccnt;\n    char_u\t*p;\n\n    slang->sl_sofo = FALSE;\n\n    i = getc(fd);\t\t\t\t// <salflags>\n    if (i & SAL_F0LLOWUP)\n\tslang->sl_followup = TRUE;\n    if (i & SAL_COLLAPSE)\n\tslang->sl_collapse = TRUE;\n    if (i & SAL_REM_ACCENTS)\n\tslang->sl_rem_accents = TRUE;\n\n    cnt = get2c(fd);\t\t\t\t// <salcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    gap = &slang->sl_sal;\n    ga_init2(gap, sizeof(salitem_T), 10);\n    if (ga_grow(gap, cnt + 1) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tint\tc = NUL;\n\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tccnt = getc(fd);\t\t\t// <salfromlen>\n\tif (ccnt < 0)\n\t    return SP_TRUNCERROR;\n\tif ((p = alloc(ccnt + 2)) == NULL)\n\t    return SP_OTHERERROR;\n\tsmp->sm_lead = p;\n\n\t// Read up to the first special char into sm_lead.\n\tfor (i = 0; i < ccnt; ++i)\n\t{\n\t    c = getc(fd);\t\t\t// <salfrom>\n\t    if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)\n\t\tbreak;\n\t    *p++ = c;\n\t}\n\tsmp->sm_leadlen = (int)(p - smp->sm_lead);\n\t*p++ = NUL;\n\n\t// Put (abc) chars in sm_oneof, if any.\n\tif (c == '(')\n\t{\n\t    smp->sm_oneof = p;\n\t    for (++i; i < ccnt; ++i)\n\t    {\n\t\tc = getc(fd);\t\t\t// <salfrom>\n\t\tif (c == ')')\n\t\t    break;\n\t\t*p++ = c;\n\t    }\n\t    *p++ = NUL;\n\t    if (++i < ccnt)\n\t\tc = getc(fd);\n\t}\n\telse\n\t    smp->sm_oneof = NULL;\n\n\t// Any following chars go in sm_rules.\n\tsmp->sm_rules = p;\n\tif (i < ccnt)\n\t    // store the char we got while checking for end of sm_lead\n\t    *p++ = c;\n\tfor (++i; i < ccnt; ++i)\n\t    *p++ = getc(fd);\t\t\t// <salfrom>\n\t*p++ = NUL;\n\n\t// <saltolen> <salto>\n\tsmp->sm_to = read_cnt_string(fd, 1, &ccnt);\n\tif (ccnt < 0)\n\t{\n\t    vim_free(smp->sm_lead);\n\t    return ccnt;\n\t}\n\n\tif (has_mbyte)\n\t{\n\t    // convert the multi-byte strings to wide char strings\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = mb_charlen(smp->sm_lead);\n\t    if (smp->sm_oneof == NULL)\n\t\tsmp->sm_oneof_w = NULL;\n\t    else\n\t\tsmp->sm_oneof_w = mb_str2wide(smp->sm_oneof);\n\t    if (smp->sm_to == NULL)\n\t\tsmp->sm_to_w = NULL;\n\t    else\n\t\tsmp->sm_to_w = mb_str2wide(smp->sm_to);\n\t    if (smp->sm_lead_w == NULL\n\t\t    || (smp->sm_oneof_w == NULL && smp->sm_oneof != NULL)\n\t\t    || (smp->sm_to_w == NULL && smp->sm_to != NULL))\n\t    {\n\t\tvim_free(smp->sm_lead);\n\t\tvim_free(smp->sm_to);\n\t\tvim_free(smp->sm_lead_w);\n\t\tvim_free(smp->sm_oneof_w);\n\t\tvim_free(smp->sm_to_w);\n\t\treturn SP_OTHERERROR;\n\t    }\n\t}\n    }\n\n    if (gap->ga_len > 0)\n    {\n\t// Add one extra entry to mark the end with an empty sm_lead.  Avoids\n\t// that we need to check the index every time.\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tif ((p = alloc(1)) == NULL)\n\t    return SP_OTHERERROR;\n\tp[0] = NUL;\n\tsmp->sm_lead = p;\n\tsmp->sm_leadlen = 0;\n\tsmp->sm_oneof = NULL;\n\tsmp->sm_rules = p;\n\tsmp->sm_to = NULL;\n\tif (has_mbyte)\n\t{\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = 0;\n\t    smp->sm_oneof_w = NULL;\n\t    smp->sm_to_w = NULL;\n\t}\n\t++gap->ga_len;\n    }\n\n    // Fill the first-index table.\n    set_sal_first(slang);\n\n    return 0;\n}\n\n/*\n * Read SN_WORDS: <word> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_words_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\tdone = 0;\n    int\t\ti;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    while (done < len)\n    {\n\t// Read one word at a time.\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t\treturn SP_TRUNCERROR;\n\t    word[i] = c;\n\t    if (word[i] == NUL)\n\t\tbreak;\n\t    if (i == MAXWLEN - 1)\n\t\treturn SP_FORMERROR;\n\t}\n\n\t// Init the count to 10.\n\tcount_common_word(lp, word, -1, 10);\n\tdone += i + 1;\n    }\n    return 0;\n}\n\n/*\n * SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * Return SP_*ERROR flags.\n */\n    static int\nread_sofo_section(FILE *fd, slang_T *slang)\n{\n    int\t\tcnt;\n    char_u\t*from, *to;\n    int\t\tres;\n\n    slang->sl_sofo = TRUE;\n\n    // <sofofromlen> <sofofrom>\n    from = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n\treturn cnt;\n\n    // <sofotolen> <sofoto>\n    to = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n    {\n\tvim_free(from);\n\treturn cnt;\n    }\n\n    // Store the info in slang->sl_sal and/or slang->sl_sal_first.\n    if (from != NULL && to != NULL)\n\tres = set_sofo(slang, from, to);\n    else if (from != NULL || to != NULL)\n\tres = SP_FORMERROR;    // only one of two strings is an error\n    else\n\tres = 0;\n\n    vim_free(from);\n    vim_free(to);\n    return res;\n}\n\n/*\n * Read the compound section from the .spl file:\n *\t<compmax> <compminlen> <compsylmax> <compoptions> <compflags>\n * Returns SP_*ERROR flags.\n */\n    static int\nread_compound(FILE *fd, slang_T *slang, int len)\n{\n    int\t\ttodo = len;\n    int\t\tc;\n    int\t\tatstart;\n    char_u\t*pat;\n    char_u\t*pp;\n    char_u\t*cp;\n    char_u\t*ap;\n    char_u\t*crp;\n    int\t\tcnt;\n    garray_T\t*gap;\n\n    if (todo < 2)\n\treturn SP_FORMERROR;\t// need at least two bytes\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compmax>\n    if (c < 2)\n\tc = MAXWLEN;\n    slang->sl_compmax = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compminlen>\n    if (c < 1)\n\tc = 0;\n    slang->sl_compminlen = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compsylmax>\n    if (c < 1)\n\tc = MAXWLEN;\n    slang->sl_compsylmax = c;\n\n    c = getc(fd);\t\t\t\t\t// <compoptions>\n    if (c != 0)\n\tungetc(c, fd);\t    // be backwards compatible with Vim 7.0b\n    else\n    {\n\t--todo;\n\tc = getc(fd);\t    // only use the lower byte for now\n\t--todo;\n\tslang->sl_compoptions = c;\n\n\tgap = &slang->sl_comppat;\n\tc = get2c(fd);\t\t\t\t\t// <comppatcount>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\ttodo -= 2;\n\tga_init2(gap, sizeof(char_u *), c);\n\tif (ga_grow(gap, c) == OK)\n\t    while (--c >= 0)\n\t    {\n\t\t((char_u **)(gap->ga_data))[gap->ga_len++] =\n\t\t\t\t\t\t  read_cnt_string(fd, 1, &cnt);\n\t\t\t\t\t    // <comppatlen> <comppattext>\n\t\tif (cnt < 0)\n\t\t    return cnt;\n\t\ttodo -= cnt + 1;\n\t    }\n    }\n    if (todo < 0)\n\treturn SP_FORMERROR;\n\n    // Turn the COMPOUNDRULE items into a regexp pattern:\n    // \"a[bc]/a*b+\" -> \"^\\(a[bc]\\|a*b\\+\\)$\".\n    // Inserting backslashes may double the length, \"^\\(\\)$<Nul>\" is 7 bytes.\n    // Conversion to utf-8 may double the size.\n    c = todo * 2 + 7;\n    if (enc_utf8)\n\tc += todo * 2;\n    pat = alloc(c);\n    if (pat == NULL)\n\treturn SP_OTHERERROR;\n\n    // We also need a list of all flags that can appear at the start and one\n    // for all flags.\n    cp = alloc(todo + 1);\n    if (cp == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compstartflags = cp;\n    *cp = NUL;\n\n    ap = alloc(todo + 1);\n    if (ap == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compallflags = ap;\n    *ap = NUL;\n\n    // And a list of all patterns in their original form, for checking whether\n    // compounding may work in match_compoundrule().  This is freed when we\n    // encounter a wildcard, the check doesn't work then.\n    crp = alloc(todo + 1);\n    slang->sl_comprules = crp;\n\n    pp = pat;\n    *pp++ = '^';\n    *pp++ = '\\\\';\n    *pp++ = '(';\n\n    atstart = 1;\n    while (todo-- > 0)\n    {\n\tc = getc(fd);\t\t\t\t\t// <compflags>\n\tif (c == EOF)\n\t{\n\t    vim_free(pat);\n\t    return SP_TRUNCERROR;\n\t}\n\n\t// Add all flags to \"sl_compallflags\".\n\tif (vim_strchr((char_u *)\"?*+[]/\", c) == NULL\n\t\t&& !byte_in_str(slang->sl_compallflags, c))\n\t{\n\t    *ap++ = c;\n\t    *ap = NUL;\n\t}\n\n\tif (atstart != 0)\n\t{\n\t    // At start of item: copy flags to \"sl_compstartflags\".  For a\n\t    // [abc] item set \"atstart\" to 2 and copy up to the ']'.\n\t    if (c == '[')\n\t\tatstart = 2;\n\t    else if (c == ']')\n\t\tatstart = 0;\n\t    else\n\t    {\n\t\tif (!byte_in_str(slang->sl_compstartflags, c))\n\t\t{\n\t\t    *cp++ = c;\n\t\t    *cp = NUL;\n\t\t}\n\t\tif (atstart == 1)\n\t\t    atstart = 0;\n\t    }\n\t}\n\n\t// Copy flag to \"sl_comprules\", unless we run into a wildcard.\n\tif (crp != NULL)\n\t{\n\t    if (c == '?' || c == '+' || c == '*')\n\t    {\n\t\tVIM_CLEAR(slang->sl_comprules);\n\t\tcrp = NULL;\n\t    }\n\t    else\n\t\t*crp++ = c;\n\t}\n\n\tif (c == '/')\t    // slash separates two items\n\t{\n\t    *pp++ = '\\\\';\n\t    *pp++ = '|';\n\t    atstart = 1;\n\t}\n\telse\t\t    // normal char, \"[abc]\" and '*' are copied as-is\n\t{\n\t    if (c == '?' || c == '+' || c == '~')\n\t\t*pp++ = '\\\\';\t    // \"a?\" becomes \"a\\?\", \"a+\" becomes \"a\\+\"\n\t    if (enc_utf8)\n\t\tpp += mb_char2bytes(c, pp);\n\t    else\n\t\t*pp++ = c;\n\t}\n    }\n\n    *pp++ = '\\\\';\n    *pp++ = ')';\n    *pp++ = '$';\n    *pp = NUL;\n\n    if (crp != NULL)\n\t*crp = NUL;\n\n    slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);\n    vim_free(pat);\n    if (slang->sl_compprog == NULL)\n\treturn SP_FORMERROR;\n\n    return 0;\n}\n\n/*\n * Set the SOFOFROM and SOFOTO items in language \"lp\".\n * Returns SP_*ERROR flags when there is something wrong.\n */\n    static int\nset_sofo(slang_T *lp, char_u *from, char_u *to)\n{\n    int\t\ti;\n\n    garray_T\t*gap;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tc;\n    int\t\t*inp;\n\n    if (has_mbyte)\n    {\n\t// Use \"sl_sal\" as an array with 256 pointers to a list of wide\n\t// characters.  The index is the low byte of the character.\n\t// The list contains from-to pairs with a terminating NUL.\n\t// sl_sal_first[] is used for latin1 \"from\" characters.\n\tgap = &lp->sl_sal;\n\tga_init2(gap, sizeof(int *), 1);\n\tif (ga_grow(gap, 256) == FAIL)\n\t    return SP_OTHERERROR;\n\tvim_memset(gap->ga_data, 0, sizeof(int *) * 256);\n\tgap->ga_len = 256;\n\n\t// First count the number of items for each list.  Temporarily use\n\t// sl_sal_first[] for this.\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    MB_CPTR_ADV(s);\n\t    if (c >= 256)\n\t\t++lp->sl_sal_first[c & 0xff];\n\t}\n\tif (*p != NUL || *s != NUL)\t    // lengths differ\n\t    return SP_FORMERROR;\n\n\t// Allocate the lists.\n\tfor (i = 0; i < 256; ++i)\n\t    if (lp->sl_sal_first[i] > 0)\n\t    {\n\t\tp = alloc(sizeof(int) * (lp->sl_sal_first[i] * 2 + 1));\n\t\tif (p == NULL)\n\t\t    return SP_OTHERERROR;\n\t\t((int **)gap->ga_data)[i] = (int *)p;\n\t\t*(int *)p = 0;\n\t    }\n\n\t// Put the characters up to 255 in sl_sal_first[] the rest in a sl_sal\n\t// list.\n\tvim_memset(lp->sl_sal_first, 0, sizeof(salfirst_T) * 256);\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    i = mb_cptr2char_adv(&s);\n\t    if (c >= 256)\n\t    {\n\t\t// Append the from-to chars at the end of the list with\n\t\t// the low byte.\n\t\tinp = ((int **)gap->ga_data)[c & 0xff];\n\t\twhile (*inp != 0)\n\t\t    ++inp;\n\t\t*inp++ = c;\t\t// from char\n\t\t*inp++ = i;\t\t// to char\n\t\t*inp++ = NUL;\t\t// NUL at the end\n\t    }\n\t    else\n\t\t// mapping byte to char is done in sl_sal_first[]\n\t\tlp->sl_sal_first[c] = i;\n\t}\n    }\n    else\n    {\n\t// mapping bytes to bytes is done in sl_sal_first[]\n\tif (STRLEN(from) != STRLEN(to))\n\t    return SP_FORMERROR;\n\n\tfor (i = 0; to[i] != NUL; ++i)\n\t    lp->sl_sal_first[from[i]] = to[i];\n\tlp->sl_sal.ga_len = 1;\t\t// indicates we have soundfolding\n    }\n\n    return 0;\n}\n\n/*\n * Fill the first-index table for \"lp\".\n */\n    static void\nset_sal_first(slang_T *lp)\n{\n    salfirst_T\t*sfirst;\n    int\t\ti;\n    salitem_T\t*smp;\n    int\t\tc;\n    garray_T\t*gap = &lp->sl_sal;\n\n    sfirst = lp->sl_sal_first;\n    for (i = 0; i < 256; ++i)\n\tsfirst[i] = -1;\n    smp = (salitem_T *)gap->ga_data;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tif (has_mbyte)\n\t    // Use the lowest byte of the first character.  For latin1 it's\n\t    // the character, for other encodings it should differ for most\n\t    // characters.\n\t    c = *smp[i].sm_lead_w & 0xff;\n\telse\n\t    c = *smp[i].sm_lead;\n\tif (sfirst[c] == -1)\n\t{\n\t    sfirst[c] = i;\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\tn;\n\n\t\t// Make sure all entries with this byte are following each\n\t\t// other.  Move the ones that are in the wrong position.  Do\n\t\t// keep the same ordering!\n\t\twhile (i + 1 < gap->ga_len\n\t\t\t\t       && (*smp[i + 1].sm_lead_w & 0xff) == c)\n\t\t    // Skip over entry with same index byte.\n\t\t    ++i;\n\n\t\tfor (n = 1; i + n < gap->ga_len; ++n)\n\t\t    if ((*smp[i + n].sm_lead_w & 0xff) == c)\n\t\t    {\n\t\t\tsalitem_T  tsal;\n\n\t\t\t// Move entry with same index byte after the entries\n\t\t\t// we already found.\n\t\t\t++i;\n\t\t\t--n;\n\t\t\ttsal = smp[i + n];\n\t\t\tmch_memmove(smp + i + 1, smp + i,\n\t\t\t\t\t\t       sizeof(salitem_T) * n);\n\t\t\tsmp[i] = tsal;\n\t\t    }\n\t    }\n\t}\n    }\n}\n\n/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */\n    static int *\nmb_str2wide(char_u *s)\n{\n    int\t\t*res;\n    char_u\t*p;\n    int\t\ti = 0;\n\n    res = ALLOC_MULT(int, mb_charlen(s) + 1);\n    if (res != NULL)\n    {\n\tfor (p = s; *p != NUL; )\n\t    res[i++] = mb_ptr2char_adv(&p);\n\tres[i] = NUL;\n    }\n    return res;\n}\n\n/*\n * Read a tree from the .spl or .sug file.\n * Allocates the memory and stores pointers in \"bytsp\" and \"idxsp\".\n * This is skipped when the tree has zero length.\n * Returns zero when OK, SP_ value for an error.\n */\n    static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    long\t*bytsp_len,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t// TRUE for the prefix tree\n    int\t\tprefixcnt)\t// when \"prefixtree\" is TRUE: prefix count\n{\n    long\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    // The tree size was computed when writing the file, so that we can\n    // allocate it as one long block. <nodecount>\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= LONG_MAX / (long)sizeof(int))\n\t// Invalid length, multiply with sizeof(int) would overflow.\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t// Allocate the byte array.\n\tbp = alloc(len);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tif (bytsp_len != NULL)\n\t    *bytsp_len = len;\n\n\t// Allocate the index array.\n\tip = lalloc_clear(len * sizeof(int), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t// Recursively read the tree and store it in the array.\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}\n\n/*\n * Read one row of siblings from the spell file and store it in the byte array\n * \"byts\" and index array \"idxs\".  Recursively read the children.\n *\n * NOTE: The code here must match put_node()!\n *\n * Returns the index (>= 0) following the siblings.\n * Returns SP_TRUNCERROR if the file is shorter than expected.\n * Returns SP_FORMERROR if there is a format error.\n */\n    static idx_T\nread_tree_node(\n    FILE\t*fd,\n    char_u\t*byts,\n    idx_T\t*idxs,\n    int\t\tmaxidx,\t\t    // size of arrays\n    idx_T\tstartidx,\t    // current index in \"byts\" and \"idxs\"\n    int\t\tprefixtree,\t    // TRUE for reading PREFIXTREE\n    int\t\tmaxprefcondnr)\t    // maximum for <prefcondnr>\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tn;\n    idx_T\tidx = startidx;\n    int\t\tc;\n    int\t\tc2;\n#define SHARED_MASK\t0x8000000\n\n    len = getc(fd);\t\t\t\t\t// <siblingcount>\n    if (len <= 0)\n\treturn SP_TRUNCERROR;\n\n    if (startidx + len >= maxidx)\n\treturn SP_FORMERROR;\n    byts[idx++] = len;\n\n    // Read the byte values, flag/region bytes and shared indexes.\n    for (i = 1; i <= len; ++i)\n    {\n\tc = getc(fd);\t\t\t\t\t// <byte>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\tif (c <= BY_SPECIAL)\n\t{\n\t    if (c == BY_NOFLAGS && !prefixtree)\n\t    {\n\t\t// No flags, all regions.\n\t\tidxs[idx] = 0;\n\t\tc = 0;\n\t    }\n\t    else if (c != BY_INDEX)\n\t    {\n\t\tif (prefixtree)\n\t\t{\n\t\t    // Read the optional pflags byte, the prefix ID and the\n\t\t    // condition nr.  In idxs[] store the prefix ID in the low\n\t\t    // byte, the condition index shifted up 8 bits, the flags\n\t\t    // shifted up 24 bits.\n\t\t    if (c == BY_FLAGS)\n\t\t\tc = getc(fd) << 24;\t\t// <pflags>\n\t\t    else\n\t\t\tc = 0;\n\n\t\t    c |= getc(fd);\t\t\t// <affixID>\n\n\t\t    n = get2c(fd);\t\t\t// <prefcondnr>\n\t\t    if (n >= maxprefcondnr)\n\t\t\treturn SP_FORMERROR;\n\t\t    c |= (n << 8);\n\t\t}\n\t\telse // c must be BY_FLAGS or BY_FLAGS2\n\t\t{\n\t\t    // Read flags and optional region and prefix ID.  In\n\t\t    // idxs[] the flags go in the low two bytes, region above\n\t\t    // that and prefix ID above the region.\n\t\t    c2 = c;\n\t\t    c = getc(fd);\t\t\t// <flags>\n\t\t    if (c2 == BY_FLAGS2)\n\t\t\tc = (getc(fd) << 8) + c;\t// <flags2>\n\t\t    if (c & WF_REGION)\n\t\t\tc = (getc(fd) << 16) + c;\t// <region>\n\t\t    if (c & WF_AFX)\n\t\t\tc = (getc(fd) << 24) + c;\t// <affixID>\n\t\t}\n\n\t\tidxs[idx] = c;\n\t\tc = 0;\n\t    }\n\t    else // c == BY_INDEX\n\t    {\n\t\t\t\t\t\t\t// <nodeidx>\n\t\tn = get3c(fd);\n\t\tif (n < 0 || n >= maxidx)\n\t\t    return SP_FORMERROR;\n\t\tidxs[idx] = n + SHARED_MASK;\n\t\tc = getc(fd);\t\t\t\t// <xbyte>\n\t    }\n\t}\n\tbyts[idx++] = c;\n    }\n\n    // Recursively read the children for non-shared siblings.\n    // Skip the end-of-word ones (zero byte value) and the shared ones (and\n    // remove SHARED_MASK)\n    for (i = 1; i <= len; ++i)\n\tif (byts[startidx + i] != 0)\n\t{\n\t    if (idxs[startidx + i] & SHARED_MASK)\n\t\tidxs[startidx + i] &= ~SHARED_MASK;\n\t    else\n\t    {\n\t\tidxs[startidx + i] = idx;\n\t\tidx = read_tree_node(fd, byts, idxs, maxidx, idx,\n\t\t\t\t\t\t     prefixtree, maxprefcondnr);\n\t\tif (idx < 0)\n\t\t    break;\n\t    }\n\t}\n\n    return idx;\n}\n\n/*\n * Reload the spell file \"fname\" if it's loaded.\n */\n    static void\nspell_reload_one(\n    char_u\t*fname,\n    int\t\tadded_word)\t// invoked through \"zg\"\n{\n    slang_T\t*slang;\n    int\t\tdidit = FALSE;\n\n    FOR_ALL_SPELL_LANGS(slang)\n    {\n\tif (fullpathcmp(fname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t{\n\t    slang_clear(slang);\n\t    if (spell_load_file(fname, NULL, slang, FALSE) == NULL)\n\t\t// reloading failed, clear the language\n\t\tslang_clear(slang);\n\t    redraw_all_later(SOME_VALID);\n\t    didit = TRUE;\n\t}\n    }\n\n    // When \"zg\" was used and the file wasn't loaded yet, should redo\n    // 'spelllang' to load it now.\n    if (added_word && !didit)\n\tdid_set_spelllang(curwin);\n}\n\n\n/*\n * Functions for \":mkspell\".\n */\n\n#define MAXLINELEN  500\t\t// Maximum length in bytes of a line in a .aff\n\t\t\t\t// and .dic file.\n/*\n * Main structure to store the contents of a \".aff\" file.\n */\ntypedef struct afffile_S\n{\n    char_u\t*af_enc;\t// \"SET\", normalized, alloc'ed string or NULL\n    int\t\taf_flagtype;\t// AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG\n    unsigned\taf_rare;\t// RARE ID for rare word\n    unsigned\taf_keepcase;\t// KEEPCASE ID for keep-case word\n    unsigned\taf_bad;\t\t// BAD ID for banned word\n    unsigned\taf_needaffix;\t// NEEDAFFIX ID\n    unsigned\taf_circumfix;\t// CIRCUMFIX ID\n    unsigned\taf_needcomp;\t// NEEDCOMPOUND ID\n    unsigned\taf_comproot;\t// COMPOUNDROOT ID\n    unsigned\taf_compforbid;\t// COMPOUNDFORBIDFLAG ID\n    unsigned\taf_comppermit;\t// COMPOUNDPERMITFLAG ID\n    unsigned\taf_nosuggest;\t// NOSUGGEST ID\n    int\t\taf_pfxpostpone;\t// postpone prefixes without chop string and\n\t\t\t\t// without flags\n    int\t\taf_ignoreextra;\t// IGNOREEXTRA present\n    hashtab_T\taf_pref;\t// hashtable for prefixes, affheader_T\n    hashtab_T\taf_suff;\t// hashtable for suffixes, affheader_T\n    hashtab_T\taf_comp;\t// hashtable for compound flags, compitem_T\n} afffile_T;\n\n#define AFT_CHAR\t0\t// flags are one character\n#define AFT_LONG\t1\t// flags are two characters\n#define AFT_CAPLONG\t2\t// flags are one or two characters\n#define AFT_NUM\t\t3\t// flags are numbers, comma separated\n\ntypedef struct affentry_S affentry_T;\n// Affix entry from \".aff\" file.  Used for prefixes and suffixes.\nstruct affentry_S\n{\n    affentry_T\t*ae_next;\t// next affix with same name/number\n    char_u\t*ae_chop;\t// text to chop off basic word (can be NULL)\n    char_u\t*ae_add;\t// text to add to basic word (can be NULL)\n    char_u\t*ae_flags;\t// flags on the affix (can be NULL)\n    char_u\t*ae_cond;\t// condition (NULL for \".\")\n    regprog_T\t*ae_prog;\t// regexp program for ae_cond or NULL\n    char\tae_compforbid;\t// COMPOUNDFORBIDFLAG found\n    char\tae_comppermit;\t// COMPOUNDPERMITFLAG found\n};\n\n#define AH_KEY_LEN 17\t\t// 2 x 8 bytes + NUL\n\n// Affix header from \".aff\" file.  Used for af_pref and af_suff.\ntypedef struct affheader_S\n{\n    char_u\tah_key[AH_KEY_LEN]; // key for hashtab == name of affix\n    unsigned\tah_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tah_newID;\t// prefix ID after renumbering; 0 if not used\n    int\t\tah_combine;\t// suffix may combine with prefix\n    int\t\tah_follows;\t// another affix block should be following\n    affentry_T\t*ah_first;\t// first affix entry\n} affheader_T;\n\n#define HI2AH(hi)   ((affheader_T *)(hi)->hi_key)\n\n// Flag used in compound items.\ntypedef struct compitem_S\n{\n    char_u\tci_key[AH_KEY_LEN]; // key for hashtab == name of compound\n    unsigned\tci_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tci_newID;\t// affix ID after renumbering.\n} compitem_T;\n\n#define HI2CI(hi)   ((compitem_T *)(hi)->hi_key)\n\n/*\n * Structure that is used to store the items in the word tree.  This avoids\n * the need to keep track of each allocated thing, everything is freed all at\n * once after \":mkspell\" is done.\n * Note: \"sb_next\" must be just before \"sb_data\" to make sure the alignment of\n * \"sb_data\" is correct for systems where pointers must be aligned on\n * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).\n */\n#define  SBLOCKSIZE 16000\t// size of sb_data\ntypedef struct sblock_S sblock_T;\nstruct sblock_S\n{\n    int\t\tsb_used;\t// nr of bytes already in use\n    sblock_T\t*sb_next;\t// next block in list\n    char_u\tsb_data[1];\t// data, actually longer\n};\n\n/*\n * A node in the tree.\n */\ntypedef struct wordnode_S wordnode_T;\nstruct wordnode_S\n{\n    union   // shared to save space\n    {\n\tchar_u\thashkey[6];\t// the hash key, only used while compressing\n\tint\tindex;\t\t// index in written nodes (valid after first\n\t\t\t\t// round)\n    } wn_u1;\n    union   // shared to save space\n    {\n\twordnode_T *next;\t// next node with same hash key\n\twordnode_T *wnode;\t// parent node that will write this node\n    } wn_u2;\n    wordnode_T\t*wn_child;\t// child (next byte in word)\n    wordnode_T  *wn_sibling;\t// next sibling (alternate byte in word,\n\t\t\t\t// always sorted)\n    int\t\twn_refs;\t// Nr. of references to this node.  Only\n\t\t\t\t// relevant for first node in a list of\n\t\t\t\t// siblings, in following siblings it is\n\t\t\t\t// always one.\n    char_u\twn_byte;\t// Byte for this node. NUL for word end\n\n    // Info for when \"wn_byte\" is NUL.\n    // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n    // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n    // \"wn_region\" the LSW of the wordnr.\n    char_u\twn_affixID;\t// supported/required prefix ID or 0\n    short_u\twn_flags;\t// WF_ flags\n    short\twn_region;\t// region mask\n\n#ifdef SPELL_PRINTTREE\n    int\t\twn_nr;\t\t// sequence nr for printing\n#endif\n};\n\n#define WN_MASK\t 0xffff\t\t// mask relevant bits of \"wn_flags\"\n\n#define HI2WN(hi)    (wordnode_T *)((hi)->hi_key)\n\n/*\n * Info used while reading the spell files.\n */\ntypedef struct spellinfo_S\n{\n    wordnode_T\t*si_foldroot;\t// tree with case-folded words\n    long\tsi_foldwcount;\t// nr of words in si_foldroot\n\n    wordnode_T\t*si_keeproot;\t// tree with keep-case words\n    long\tsi_keepwcount;\t// nr of words in si_keeproot\n\n    wordnode_T\t*si_prefroot;\t// tree with postponed prefixes\n\n    long\tsi_sugtree;\t// creating the soundfolding trie\n\n    sblock_T\t*si_blocks;\t// memory blocks used\n    long\tsi_blocks_cnt;\t// memory blocks allocated\n    int\t\tsi_did_emsg;\t// TRUE when ran out of memory\n\n    long\tsi_compress_cnt;    // words to add before lowering\n\t\t\t\t    // compression limit\n    wordnode_T\t*si_first_free; // List of nodes that have been freed during\n\t\t\t\t// compression, linked by \"wn_child\" field.\n    long\tsi_free_count;\t// number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n    int\t\tsi_wordnode_nr;\t// sequence nr for nodes\n#endif\n    buf_T\t*si_spellbuf;\t// buffer used to store soundfold word table\n\n    int\t\tsi_ascii;\t// handling only ASCII words\n    int\t\tsi_add;\t\t// addition file\n    int\t\tsi_clear_chartab;   // when TRUE clear char tables\n    int\t\tsi_region;\t// region mask\n    vimconv_T\tsi_conv;\t// for conversion to 'encoding'\n    int\t\tsi_memtot;\t// runtime memory used\n    int\t\tsi_verbose;\t// verbose messages\n    int\t\tsi_msg_count;\t// number of words added since last message\n    char_u\t*si_info;\t// info text chars or NULL\n    int\t\tsi_region_count; // number of regions supported (1 when there\n\t\t\t\t // are no regions)\n    char_u\tsi_region_name[MAXREGIONS * 2 + 1];\n\t\t\t\t// region names; used only if\n\t\t\t\t// si_region_count > 1)\n\n    garray_T\tsi_rep;\t\t// list of fromto_T entries from REP lines\n    garray_T\tsi_repsal;\t// list of fromto_T entries from REPSAL lines\n    garray_T\tsi_sal;\t\t// list of fromto_T entries from SAL lines\n    char_u\t*si_sofofr;\t// SOFOFROM text\n    char_u\t*si_sofoto;\t// SOFOTO text\n    int\t\tsi_nosugfile;\t// NOSUGFILE item found\n    int\t\tsi_nosplitsugs;\t// NOSPLITSUGS item found\n    int\t\tsi_nocompoundsugs; // NOCOMPOUNDSUGS item found\n    int\t\tsi_followup;\t// soundsalike: ?\n    int\t\tsi_collapse;\t// soundsalike: ?\n    hashtab_T\tsi_commonwords;\t// hashtable for common words\n    time_t\tsi_sugtime;\t// timestamp for .sug file\n    int\t\tsi_rem_accents;\t// soundsalike: remove accents\n    garray_T\tsi_map;\t\t// MAP info concatenated\n    char_u\t*si_midword;\t// MIDWORD chars or NULL\n    int\t\tsi_compmax;\t// max nr of words for compounding\n    int\t\tsi_compminlen;\t// minimal length for compounding\n    int\t\tsi_compsylmax;\t// max nr of syllables for compounding\n    int\t\tsi_compoptions;\t// COMP_ flags\n    garray_T\tsi_comppat;\t// CHECKCOMPOUNDPATTERN items, each stored as\n\t\t\t\t// a string\n    char_u\t*si_compflags;\t// flags used for compounding\n    char_u\tsi_nobreak;\t// NOBREAK\n    char_u\t*si_syllable;\t// syllable string\n    garray_T\tsi_prefcond;\t// table with conditions for postponed\n\t\t\t\t// prefixes, each stored as a string\n    int\t\tsi_newprefID;\t// current value for ah_newID\n    int\t\tsi_newcompID;\t// current value for compound ID\n} spellinfo_T;\n\nstatic int is_aff_rule(char_u **items, int itemcnt, char *rulename, int\t mincount);\nstatic void aff_process_flags(afffile_T *affile, affentry_T *entry);\nstatic int spell_info_item(char_u *s);\nstatic unsigned affitem2flag(int flagtype, char_u *item, char_u\t*fname, int lnum);\nstatic unsigned get_affitem(int flagtype, char_u **pp);\nstatic void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags);\nstatic void check_renumber(spellinfo_T *spin);\nstatic void aff_check_number(int spinval, int affval, char *name);\nstatic void aff_check_string(char_u *spinval, char_u *affval, char *name);\nstatic int str_equal(char_u *s1, char_u\t*s2);\nstatic void add_fromto(spellinfo_T *spin, garray_T *gap, char_u\t*from, char_u *to);\nstatic int sal_to_bool(char_u *s);\nstatic int get_affix_flags(afffile_T *affile, char_u *afflist);\nstatic int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic int store_aff_word(spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen);\nstatic void *getroom(spellinfo_T *spin, size_t len, int align);\nstatic char_u *getroom_save(spellinfo_T *spin, char_u *s);\nstatic int store_word(spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix);\nstatic int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID);\nstatic wordnode_T *get_wordnode(spellinfo_T *spin);\nstatic void free_wordnode(spellinfo_T *spin, wordnode_T *n);\nstatic void wordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name);\nstatic long node_compress(spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, long *tot);\nstatic int node_equal(wordnode_T *n1, wordnode_T *n2);\nstatic void clear_node(wordnode_T *node);\nstatic int put_node(FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree);\nstatic int sug_filltree(spellinfo_T *spin, slang_T *slang);\nstatic int sug_maketable(spellinfo_T *spin);\nstatic int sug_filltable(spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap);\nstatic int offset2bytes(int nr, char_u *buf);\nstatic void sug_write(spellinfo_T *spin, char_u *fname);\nstatic void spell_message(spellinfo_T *spin, char_u *str);\nstatic void init_spellfile(void);\n\n// In the postponed prefixes tree wn_flags is used to store the WFP_ flags,\n// but it must be negative to indicate the prefix tree to tree_add_word().\n// Use a negative number with the lower 8 bits zero.\n#define PFX_FLAGS\t(-256)\n\n// flags for \"condit\" argument of store_aff_word()\n#define CONDIT_COMB\t1\t// affix must combine\n#define CONDIT_CFIX\t2\t// affix must have CIRCUMFIX flag\n#define CONDIT_SUF\t4\t// add a suffix for matching flags\n#define CONDIT_AFF\t8\t// word already has an affix\n\n/*\n * Tunable parameters for when the tree is compressed.  Filled from the\n * 'mkspellmem' option.\n */\nstatic long compress_start = 30000;\t// memory / SBLOCKSIZE\nstatic long compress_inc = 100;\t\t// memory / SBLOCKSIZE\nstatic long compress_added = 500000;\t// word count\n\n/*\n * Check the 'mkspellmem' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\".\n */\n    int\nspell_check_msm(void)\n{\n    char_u\t*p = p_msm;\n    long\tstart = 0;\n    long\tincr = 0;\n    long\tadded = 0;\n\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    // block count = (value * 1024) / SBLOCKSIZE (but avoid overflow)\n    start = (getdigits(&p) * 10) / (SBLOCKSIZE / 102);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    added = getdigits(&p) * 1024;\n    if (*p != NUL)\n\treturn FAIL;\n\n    if (start == 0 || incr == 0 || added == 0 || incr > start)\n\treturn FAIL;\n\n    compress_start = start;\n    compress_inc = incr;\n    compress_added = added;\n    return OK;\n}\n\n#ifdef SPELL_PRINTTREE\n/*\n * For debugging the tree code: print the current tree in a (more or less)\n * readable format, so that we can see what happens when adding a word and/or\n * compressing the tree.\n * Based on code from Olaf Seibert.\n */\n#define PRINTLINESIZE\t1000\n#define PRINTWIDTH\t6\n\n#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\\n\t    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)\n\nstatic char line1[PRINTLINESIZE];\nstatic char line2[PRINTLINESIZE];\nstatic char line3[PRINTLINESIZE];\n\n    static void\nspell_clear_flags(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tnp->wn_u1.index = FALSE;\n\tspell_clear_flags(np->wn_child);\n    }\n}\n\n    static void\nspell_print_node(wordnode_T *node, int depth)\n{\n    if (node->wn_u1.index)\n    {\n\t// Done this node before, print the reference.\n\tPRINTSOME(line1, depth, \"(%d)\", node->wn_nr, 0);\n\tPRINTSOME(line2, depth, \"    \", 0, 0);\n\tPRINTSOME(line3, depth, \"    \", 0, 0);\n\tmsg(line1);\n\tmsg(line2);\n\tmsg(line3);\n    }\n    else\n    {\n\tnode->wn_u1.index = TRUE;\n\n\tif (node->wn_byte != NUL)\n\t{\n\t    if (node->wn_child != NULL)\n\t\tPRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);\n\t    else\n\t\t// Cannot happen?\n\t\tPRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);\n\t}\n\telse\n\t    PRINTSOME(line1, depth, \" $    \", 0, 0);\n\n\tPRINTSOME(line2, depth, \"%d/%d    \", node->wn_nr, node->wn_refs);\n\n\tif (node->wn_sibling != NULL)\n\t    PRINTSOME(line3, depth, \" |    \", 0, 0);\n\telse\n\t    PRINTSOME(line3, depth, \"      \", 0, 0);\n\n\tif (node->wn_byte == NUL)\n\t{\n\t    msg(line1);\n\t    msg(line2);\n\t    msg(line3);\n\t}\n\n\t// do the children\n\tif (node->wn_byte != NUL && node->wn_child != NULL)\n\t    spell_print_node(node->wn_child, depth + 1);\n\n\t// do the siblings\n\tif (node->wn_sibling != NULL)\n\t{\n\t    // get rid of all parent details except |\n\t    STRCPY(line1, line3);\n\t    STRCPY(line2, line3);\n\t    spell_print_node(node->wn_sibling, depth);\n\t}\n    }\n}\n\n    static void\nspell_print_tree(wordnode_T *root)\n{\n    if (root != NULL)\n    {\n\t// Clear the \"wn_u1.index\" fields, used to remember what has been\n\t// done.\n\tspell_clear_flags(root);\n\n\t// Recursively print the tree.\n\tspell_print_node(root, 0);\n    }\n}\n#endif // SPELL_PRINTTREE\n\n/*\n * Read the affix file \"fname\".\n * Returns an afffile_T, NULL for complete failure.\n */\n    static afffile_T *\nspell_read_aff(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    afffile_T\t*aff;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n#define MAXITEMCNT  30\n    char_u\t*(items[MAXITEMCNT]);\n    int\t\titemcnt;\n    char_u\t*p;\n    int\t\tlnum = 0;\n    affheader_T\t*cur_aff = NULL;\n    int\t\tdid_postpone_prefix = FALSE;\n    int\t\taff_todo = 0;\n    hashtab_T\t*tp;\n    char_u\t*low = NULL;\n    char_u\t*fol = NULL;\n    char_u\t*upp = NULL;\n    int\t\tdo_rep;\n    int\t\tdo_repsal;\n    int\t\tdo_sal;\n    int\t\tdo_mapline;\n    int\t\tfound_map = FALSE;\n    hashitem_T\t*hi;\n    int\t\tl;\n    int\t\tcompminlen = 0;\t\t// COMPOUNDMIN value\n    int\t\tcompsylmax = 0;\t\t// COMPOUNDSYLMAX value\n    int\t\tcompoptions = 0;\t// COMP_ flags\n    int\t\tcompmax = 0;\t\t// COMPOUNDWORDMAX value\n    char_u\t*compflags = NULL;\t// COMPOUNDFLAG and COMPOUNDRULE\n\t\t\t\t\t// concatenated\n    char_u\t*midword = NULL;\t// MIDWORD value\n    char_u\t*syllable = NULL;\t// SYLLABLE value\n    char_u\t*sofofrom = NULL;\t// SOFOFROM value\n    char_u\t*sofoto = NULL;\t\t// SOFOTO value\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn NULL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading affix file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // Only do REP lines when not done in another .aff file already.\n    do_rep = spin->si_rep.ga_len == 0;\n\n    // Only do REPSAL lines when not done in another .aff file already.\n    do_repsal = spin->si_repsal.ga_len == 0;\n\n    // Only do SAL lines when not done in another .aff file already.\n    do_sal = spin->si_sal.ga_len == 0;\n\n    // Only do MAP lines when not done in another .aff file already.\n    do_mapline = spin->si_map.ga_len == 0;\n\n    /*\n     * Allocate and init the afffile_T structure.\n     */\n    aff = (afffile_T *)getroom(spin, sizeof(afffile_T), TRUE);\n    if (aff == NULL)\n    {\n\tfclose(fd);\n\treturn NULL;\n    }\n    hash_init(&aff->af_pref);\n    hash_init(&aff->af_suff);\n    hash_init(&aff->af_comp);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\t// Split the line up in white separated items.  Put a NUL after each\n\t// item.\n\titemcnt = 0;\n\tfor (p = line; ; )\n\t{\n\t    while (*p != NUL && *p <= ' ')  // skip white space and CR/NL\n\t\t++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    if (itemcnt == MAXITEMCNT)\t    // too many items\n\t\tbreak;\n\t    items[itemcnt++] = p;\n\t    // A few items have arbitrary text argument, don't split them.\n\t    if (itemcnt == 2 && spell_info_item(items[0]))\n\t\twhile (*p >= ' ' || *p == TAB)    // skip until CR/NL\n\t\t    ++p;\n\t    else\n\t\twhile (*p > ' ')    // skip until white space or CR/NL\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *p++ = NUL;\n\t}\n\n\t// Handle non-empty lines.\n\tif (itemcnt > 0)\n\t{\n\t    if (is_aff_rule(items, itemcnt, \"SET\", 2) && aff->af_enc == NULL)\n\t    {\n\t\t// Setup for conversion from \"ENC\" to 'encoding'.\n\t\taff->af_enc = enc_canonize(items[1]);\n\t\tif (aff->af_enc != NULL && !spin->si_ascii\n\t\t\t&& convert_setup(&spin->si_conv, aff->af_enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t    smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t       fname, aff->af_enc, p_enc);\n\t\tspin->si_conv.vc_fail = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FLAG\", 2)\n\t\t\t\t\t      && aff->af_flagtype == AFT_CHAR)\n\t    {\n\t\tif (STRCMP(items[1], \"long\") == 0)\n\t\t    aff->af_flagtype = AFT_LONG;\n\t\telse if (STRCMP(items[1], \"num\") == 0)\n\t\t    aff->af_flagtype = AFT_NUM;\n\t\telse if (STRCMP(items[1], \"caplong\") == 0)\n\t\t    aff->af_flagtype = AFT_CAPLONG;\n\t\telse\n\t\t    smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t\tif (aff->af_rare != 0\n\t\t\t|| aff->af_keepcase != 0\n\t\t\t|| aff->af_bad != 0\n\t\t\t|| aff->af_needaffix != 0\n\t\t\t|| aff->af_circumfix != 0\n\t\t\t|| aff->af_needcomp != 0\n\t\t\t|| aff->af_comproot != 0\n\t\t\t|| aff->af_nosuggest != 0\n\t\t\t|| compflags != NULL\n\t\t\t|| aff->af_suff.ht_used > 0\n\t\t\t|| aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"FLAG after using flags in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t    }\n\t    else if (spell_info_item(items[0]))\n\t    {\n\t\t    p = (char_u *)getroom(spin,\n\t\t\t    (spin->si_info == NULL ? 0 : STRLEN(spin->si_info))\n\t\t\t    + STRLEN(items[0])\n\t\t\t    + STRLEN(items[1]) + 3, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (spin->si_info != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, spin->si_info);\n\t\t\t    STRCAT(p, \"\\n\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[0]);\n\t\t\tSTRCAT(p, \" \");\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tspin->si_info = p;\n\t\t    }\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MIDWORD\", 2)\n\t\t\t\t\t\t\t   && midword == NULL)\n\t    {\n\t\tmidword = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"TRY\", 2))\n\t    {\n\t\t// ignored, we look in the tree for what chars may appear\n\t    }\n\t    // TODO: remove \"RAR\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"RARE\", 2))\n\t\t\t\t\t\t\t && aff->af_rare == 0)\n\t    {\n\t\taff->af_rare = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    // TODO: remove \"KEP\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))\n\t\t\t\t\t\t     && aff->af_keepcase == 0)\n\t    {\n\t\taff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"FORBIDDENWORD\", 2))\n\t\t\t\t\t\t\t  && aff->af_bad == 0)\n\t    {\n\t\taff->af_bad = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)\n\t\t\t\t\t\t    && aff->af_needaffix == 0)\n\t    {\n\t\taff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)\n\t\t\t\t\t\t    && aff->af_circumfix == 0)\n\t    {\n\t\taff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)\n\t\t\t\t\t\t    && aff->af_nosuggest == 0)\n\t    {\n\t\taff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"ONLYINCOMPOUND\", 2))\n\t\t\t\t\t\t     && aff->af_needcomp == 0)\n\t    {\n\t\taff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)\n\t\t\t\t\t\t     && aff->af_comproot == 0)\n\t    {\n\t\taff->af_comproot = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_compforbid == 0)\n\t    {\n\t\taff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDPERMITFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_comppermit == 0)\n\t    {\n\t\taff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFLAG\", 2)\n\t\t\t\t\t\t\t && compflags == NULL)\n\t    {\n\t\t// Turn flag \"c\" into COMPOUNDRULE compatible string \"c+\",\n\t\t// \"Na\" into \"Na+\", \"1234\" into \"1234+\".\n\t\tp = getroom(spin, STRLEN(items[1]) + 2, FALSE);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCPY(p, items[1]);\n\t\t    STRCAT(p, \"+\");\n\t\t    compflags = p;\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULES\", 2))\n\t    {\n\t\t// We don't use the count, but do check that it's a number and\n\t\t// not COMPOUNDRULE mistyped.\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULE\", 2))\n\t    {\n\t\t// Don't use the first rule if it is a number.\n\t\tif (compflags != NULL || *skipdigits(items[1]) != NUL)\n\t\t{\n\t\t    // Concatenate this string to previously defined ones,\n\t\t    // using a slash to separate them.\n\t\t    l = (int)STRLEN(items[1]) + 1;\n\t\t    if (compflags != NULL)\n\t\t\tl += (int)STRLEN(compflags) + 1;\n\t\t    p = getroom(spin, l, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (compflags != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, compflags);\n\t\t\t    STRCAT(p, \"/\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tcompflags = p;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDWORDMAX\", 2)\n\t\t\t\t\t\t\t      && compmax == 0)\n\t    {\n\t\tcompmax = atoi((char *)items[1]);\n\t\tif (compmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDMIN\", 2)\n\t\t\t\t\t\t\t   && compminlen == 0)\n\t    {\n\t\tcompminlen = atoi((char *)items[1]);\n\t\tif (compminlen == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDSYLMAX\", 2)\n\t\t\t\t\t\t\t   && compsylmax == 0)\n\t    {\n\t\tcompsylmax = atoi((char *)items[1]);\n\t\tif (compsylmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDDUP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKDUP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDREP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKREP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDCASE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKCASE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDTRIPLE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKTRIPLE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))\n\t    {\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 3))\n\t    {\n\t\tgarray_T    *gap = &spin->si_comppat;\n\t\tint\t    i;\n\n\t\t// Only add the couple if it isn't already there.\n\t\tfor (i = 0; i < gap->ga_len - 1; i += 2)\n\t\t    if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0\n\t\t\t    && STRCMP(((char_u **)(gap->ga_data))[i + 1],\n\t\t\t\t\t\t\t       items[2]) == 0)\n\t\t\tbreak;\n\t\tif (i >= gap->ga_len && ga_grow(gap, 2) == OK)\n\t\t{\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[1]);\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SYLLABLE\", 2)\n\t\t\t\t\t\t\t  && syllable == NULL)\n\t    {\n\t\tsyllable = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOBREAK\", 1))\n\t    {\n\t\tspin->si_nobreak = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSPLITSUGS\", 1))\n\t    {\n\t\tspin->si_nosplitsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOCOMPOUNDSUGS\", 1))\n\t    {\n\t\tspin->si_nocompoundsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGFILE\", 1))\n\t    {\n\t\tspin->si_nosugfile = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"PFXPOSTPONE\", 1))\n\t    {\n\t\taff->af_pfxpostpone = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"IGNOREEXTRA\", 1))\n\t    {\n\t\taff->af_ignoreextra = TRUE;\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo == 0\n\t\t    && itemcnt >= 4)\n\t    {\n\t\tint\tlasti = 4;\n\t\tchar_u\tkey[AH_KEY_LEN];\n\n\t\tif (*items[0] == 'P')\n\t\t    tp = &aff->af_pref;\n\t\telse\n\t\t    tp = &aff->af_suff;\n\n\t\t// Myspell allows the same affix name to be used multiple\n\t\t// times.  The affix files that do this have an undocumented\n\t\t// \"S\" flag on all but the last block, thus we check for that\n\t\t// and store it in ah_follows.\n\t\tvim_strncpy(key, items[1], AH_KEY_LEN - 1);\n\t\thi = hash_find(tp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    cur_aff = HI2AH(hi);\n\t\t    if (cur_aff->ah_combine != (*items[2] == 'Y'))\n\t\t\tsmsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),\n\t\t\t\t\t\t   fname, lnum, items[1]);\n\t\t    if (!cur_aff->ah_follows)\n\t\t\tsmsg(_(\"Duplicate affix in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // New affix letter.\n\t\t    cur_aff = (affheader_T *)getroom(spin,\n\t\t\t\t\t\t   sizeof(affheader_T), TRUE);\n\t\t    if (cur_aff == NULL)\n\t\t\tbreak;\n\t\t    cur_aff->ah_flag = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    if (cur_aff->ah_flag == 0 || STRLEN(items[1]) >= AH_KEY_LEN)\n\t\t\tbreak;\n\t\t    if (cur_aff->ah_flag == aff->af_bad\n\t\t\t    || cur_aff->ah_flag == aff->af_rare\n\t\t\t    || cur_aff->ah_flag == aff->af_keepcase\n\t\t\t    || cur_aff->ah_flag == aff->af_needaffix\n\t\t\t    || cur_aff->ah_flag == aff->af_circumfix\n\t\t\t    || cur_aff->ah_flag == aff->af_nosuggest\n\t\t\t    || cur_aff->ah_flag == aff->af_needcomp\n\t\t\t    || cur_aff->ah_flag == aff->af_comproot)\n\t\t\tsmsg(_(\"Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t    STRCPY(cur_aff->ah_key, items[1]);\n\t\t    hash_add(tp, cur_aff->ah_key);\n\n\t\t    cur_aff->ah_combine = (*items[2] == 'Y');\n\t\t}\n\n\t\t// Check for the \"S\" flag, which apparently means that another\n\t\t// block with the same affix name is following.\n\t\tif (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0)\n\t\t{\n\t\t    ++lasti;\n\t\t    cur_aff->ah_follows = TRUE;\n\t\t}\n\t\telse\n\t\t    cur_aff->ah_follows = FALSE;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter.\n\t\tif (itemcnt > lasti && *items[lasti] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\tif (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)\n\t\t    smsg(_(\"Expected Y or N in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[2]);\n\n\t\tif (*items[0] == 'P' && aff->af_pfxpostpone)\n\t\t{\n\t\t    if (cur_aff->ah_newID == 0)\n\t\t    {\n\t\t\t// Use a new number in the .spl file later, to be able\n\t\t\t// to handle multiple .aff files.\n\t\t\tcheck_renumber(spin);\n\t\t\tcur_aff->ah_newID = ++spin->si_newprefID;\n\n\t\t\t// We only really use ah_newID if the prefix is\n\t\t\t// postponed.  We know that only after handling all\n\t\t\t// the items.\n\t\t\tdid_postpone_prefix = FALSE;\n\t\t    }\n\t\t    else\n\t\t\t// Did use the ID in a previous block.\n\t\t\tdid_postpone_prefix = TRUE;\n\t\t}\n\n\t\taff_todo = atoi((char *)items[3]);\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo > 0\n\t\t    && STRCMP(cur_aff->ah_key, items[1]) == 0\n\t\t    && itemcnt >= 5)\n\t    {\n\t\taffentry_T\t*aff_entry;\n\t\tint\t\tupper = FALSE;\n\t\tint\t\tlasti = 5;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter,\n\t\t// unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.\n\t\tif (itemcnt > lasti\n\t\t\t&& !aff->af_ignoreextra\n\t\t\t&& *items[lasti] != '#'\n\t\t\t&& (STRCMP(items[lasti], \"-\") != 0\n\t\t\t\t\t\t     || itemcnt != lasti + 1))\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\t// New item for an affix letter.\n\t\t--aff_todo;\n\t\taff_entry = (affentry_T *)getroom(spin,\n\t\t\t\t\t\t    sizeof(affentry_T), TRUE);\n\t\tif (aff_entry == NULL)\n\t\t    break;\n\n\t\tif (STRCMP(items[2], \"0\") != 0)\n\t\t    aff_entry->ae_chop = getroom_save(spin, items[2]);\n\t\tif (STRCMP(items[3], \"0\") != 0)\n\t\t{\n\t\t    aff_entry->ae_add = getroom_save(spin, items[3]);\n\n\t\t    // Recognize flags on the affix: abcd/XYZ\n\t\t    aff_entry->ae_flags = vim_strchr(aff_entry->ae_add, '/');\n\t\t    if (aff_entry->ae_flags != NULL)\n\t\t    {\n\t\t\t*aff_entry->ae_flags++ = NUL;\n\t\t\taff_process_flags(aff, aff_entry);\n\t\t    }\n\t\t}\n\n\t\t// Don't use an affix entry with non-ASCII characters when\n\t\t// \"spin->si_ascii\" is TRUE.\n\t\tif (!spin->si_ascii || !(has_non_ascii(aff_entry->ae_chop)\n\t\t\t\t\t  || has_non_ascii(aff_entry->ae_add)))\n\t\t{\n\t\t    aff_entry->ae_next = cur_aff->ah_first;\n\t\t    cur_aff->ah_first = aff_entry;\n\n\t\t    if (STRCMP(items[4], \".\") != 0)\n\t\t    {\n\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\taff_entry->ae_cond = getroom_save(spin, items[4]);\n\t\t\tif (*items[0] == 'P')\n\t\t\t    sprintf((char *)buf, \"^%s\", items[4]);\n\t\t\telse\n\t\t\t    sprintf((char *)buf, \"%s$\", items[4]);\n\t\t\taff_entry->ae_prog = vim_regcomp(buf,\n\t\t\t\t\t    RE_MAGIC + RE_STRING + RE_STRICT);\n\t\t\tif (aff_entry->ae_prog == NULL)\n\t\t\t    smsg(_(\"Broken condition in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[4]);\n\t\t    }\n\n\t\t    // For postponed prefixes we need an entry in si_prefcond\n\t\t    // for the condition.  Use an existing one if possible.\n\t\t    // Can't be done for an affix with flags, ignoring\n\t\t    // COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG.\n\t\t    if (*items[0] == 'P' && aff->af_pfxpostpone\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t    {\n\t\t\t// When the chop string is one lower-case letter and\n\t\t\t// the add string ends in the upper-case letter we set\n\t\t\t// the \"upper\" flag, clear \"ae_chop\" and remove the\n\t\t\t// letters from \"ae_add\".  The condition must either\n\t\t\t// be empty or start with the same letter.\n\t\t\tif (aff_entry->ae_chop != NULL\n\t\t\t\t&& aff_entry->ae_add != NULL\n\t\t\t\t&& aff_entry->ae_chop[(*mb_ptr2len)(\n\t\t\t\t\t\t   aff_entry->ae_chop)] == NUL)\n\t\t\t{\n\t\t\t    int\t\tc, c_up;\n\n\t\t\t    c = PTR2CHAR(aff_entry->ae_chop);\n\t\t\t    c_up = SPELL_TOUPPER(c);\n\t\t\t    if (c_up != c\n\t\t\t\t    && (aff_entry->ae_cond == NULL\n\t\t\t\t\t|| PTR2CHAR(aff_entry->ae_cond) == c))\n\t\t\t    {\n\t\t\t\tp = aff_entry->ae_add\n\t\t\t\t\t\t  + STRLEN(aff_entry->ae_add);\n\t\t\t\tMB_PTR_BACK(aff_entry->ae_add, p);\n\t\t\t\tif (PTR2CHAR(p) == c_up)\n\t\t\t\t{\n\t\t\t\t    upper = TRUE;\n\t\t\t\t    aff_entry->ae_chop = NULL;\n\t\t\t\t    *p = NUL;\n\n\t\t\t\t    // The condition is matched with the\n\t\t\t\t    // actual word, thus must check for the\n\t\t\t\t    // upper-case letter.\n\t\t\t\t    if (aff_entry->ae_cond != NULL)\n\t\t\t\t    {\n\t\t\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\t\t\tif (has_mbyte)\n\t\t\t\t\t{\n\t\t\t\t\t    onecap_copy(items[4], buf, TRUE);\n\t\t\t\t\t    aff_entry->ae_cond = getroom_save(\n\t\t\t\t\t\t\t\t   spin, buf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t    *aff_entry->ae_cond = c_up;\n\t\t\t\t\tif (aff_entry->ae_cond != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    sprintf((char *)buf, \"^%s\",\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t\t\t    vim_regfree(aff_entry->ae_prog);\n\t\t\t\t\t    aff_entry->ae_prog = vim_regcomp(\n\t\t\t\t\t\t    buf, RE_MAGIC + RE_STRING);\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (aff_entry->ae_chop == NULL\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t\t{\n\t\t\t    int\t\tidx;\n\t\t\t    char_u\t**pp;\n\t\t\t    int\t\tn;\n\n\t\t\t    // Find a previously used condition.\n\t\t\t    for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;\n\t\t\t\t\t\t\t\t\t--idx)\n\t\t\t    {\n\t\t\t\tp = ((char_u **)spin->si_prefcond.ga_data)[idx];\n\t\t\t\tif (str_equal(p, aff_entry->ae_cond))\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (idx < 0 && ga_grow(&spin->si_prefcond, 1) == OK)\n\t\t\t    {\n\t\t\t\t// Not found, add a new condition.\n\t\t\t\tidx = spin->si_prefcond.ga_len++;\n\t\t\t\tpp = ((char_u **)spin->si_prefcond.ga_data)\n\t\t\t\t\t\t\t\t\t+ idx;\n\t\t\t\tif (aff_entry->ae_cond == NULL)\n\t\t\t\t    *pp = NULL;\n\t\t\t\telse\n\t\t\t\t    *pp = getroom_save(spin,\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t    }\n\n\t\t\t    // Add the prefix to the prefix tree.\n\t\t\t    if (aff_entry->ae_add == NULL)\n\t\t\t\tp = (char_u *)\"\";\n\t\t\t    else\n\t\t\t\tp = aff_entry->ae_add;\n\n\t\t\t    // PFX_FLAGS is a negative number, so that\n\t\t\t    // tree_add_word() knows this is the prefix tree.\n\t\t\t    n = PFX_FLAGS;\n\t\t\t    if (!cur_aff->ah_combine)\n\t\t\t\tn |= WFP_NC;\n\t\t\t    if (upper)\n\t\t\t\tn |= WFP_UP;\n\t\t\t    if (aff_entry->ae_comppermit)\n\t\t\t\tn |= WFP_COMPPERMIT;\n\t\t\t    if (aff_entry->ae_compforbid)\n\t\t\t\tn |= WFP_COMPFORBID;\n\t\t\t    tree_add_word(spin, p, spin->si_prefroot, n,\n\t\t\t\t\t\t      idx, cur_aff->ah_newID);\n\t\t\t    did_postpone_prefix = TRUE;\n\t\t\t}\n\n\t\t\t// Didn't actually use ah_newID, backup si_newprefID.\n\t\t\tif (aff_todo == 0 && !did_postpone_prefix)\n\t\t\t{\n\t\t\t    --spin->si_newprefID;\n\t\t\t    cur_aff->ah_newID = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FOL\", 2) && fol == NULL)\n\t    {\n\t\tfol = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"LOW\", 2) && low == NULL)\n\t    {\n\t\tlow = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"UPP\", 2) && upp == NULL)\n\t    {\n\t\tupp = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"REP\", 2)\n\t\t     || is_aff_rule(items, itemcnt, \"REPSAL\", 2))\n\t    {\n\t\t// Ignore REP/REPSAL count\n\t\tif (!isdigit(*items[1]))\n\t\t    smsg(_(\"Expected REP(SAL) count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((STRCMP(items[0], \"REP\") == 0\n\t\t\t|| STRCMP(items[0], \"REPSAL\") == 0)\n\t\t    && itemcnt >= 3)\n\t    {\n\t\t// REP/REPSAL item\n\t\t// Myspell ignores extra arguments, we require it starts with\n\t\t// # to detect mistakes.\n\t\tif (itemcnt > 3 && items[3][0] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[3]);\n\t\tif (items[0][3] == 'S' ? do_repsal : do_rep)\n\t\t{\n\t\t    // Replace underscore with space (can't include a space\n\t\t    // directly).\n\t\t    for (p = items[1]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    for (p = items[2]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    add_fromto(spin, items[0][3] == 'S'\n\t\t\t\t\t ? &spin->si_repsal\n\t\t\t\t\t : &spin->si_rep, items[1], items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MAP\", 2))\n\t    {\n\t\t// MAP item or count\n\t\tif (!found_map)\n\t\t{\n\t\t    // First line contains the count.\n\t\t    found_map = TRUE;\n\t\t    if (!isdigit(*items[1]))\n\t\t\tsmsg(_(\"Expected MAP count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t}\n\t\telse if (do_mapline)\n\t\t{\n\t\t    int\t\tc;\n\n\t\t    // Check that every character appears only once.\n\t\t    for (p = items[1]; *p != NUL; )\n\t\t    {\n\t\t\tc = mb_ptr2char_adv(&p);\n\t\t\tif ((spin->si_map.ga_len > 0\n\t\t\t\t    && vim_strchr(spin->si_map.ga_data, c)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t\t|| vim_strchr(p, c) != NULL)\n\t\t\t    smsg(_(\"Duplicate character in MAP in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    }\n\n\t\t    // We simply concatenate all the MAP strings, separated by\n\t\t    // slashes.\n\t\t    ga_concat(&spin->si_map, items[1]);\n\t\t    ga_append(&spin->si_map, '/');\n\t\t}\n\t    }\n\t    // Accept \"SAL from to\" and \"SAL from to  #comment\".\n\t    else if (is_aff_rule(items, itemcnt, \"SAL\", 3))\n\t    {\n\t\tif (do_sal)\n\t\t{\n\t\t    // SAL item (sounds-a-like)\n\t\t    // Either one of the known keys or a from-to pair.\n\t\t    if (STRCMP(items[1], \"followup\") == 0)\n\t\t\tspin->si_followup = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"collapse_result\") == 0)\n\t\t\tspin->si_collapse = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"remove_accents\") == 0)\n\t\t\tspin->si_rem_accents = sal_to_bool(items[2]);\n\t\t    else\n\t\t\t// when \"to\" is \"_\" it means empty\n\t\t\tadd_fromto(spin, &spin->si_sal, items[1],\n\t\t\t\t     STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"\n\t\t\t\t\t\t\t\t: items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOFROM\", 2)\n\t\t\t\t\t\t\t  && sofofrom == NULL)\n\t    {\n\t\tsofofrom = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOTO\", 2)\n\t\t\t\t\t\t\t    && sofoto == NULL)\n\t    {\n\t\tsofoto = getroom_save(spin, items[1]);\n\t    }\n\t    else if (STRCMP(items[0], \"COMMON\") == 0)\n\t    {\n\t\tint\ti;\n\n\t\tfor (i = 1; i < itemcnt; ++i)\n\t\t{\n\t\t    if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,\n\t\t\t\t\t\t\t\t   items[i])))\n\t\t    {\n\t\t\tp = vim_strsave(items[i]);\n\t\t\tif (p == NULL)\n\t\t\t    break;\n\t\t\thash_add(&spin->si_commonwords, p);\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tsmsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[0]);\n\t}\n    }\n\n    if (fol != NULL || low != NULL || upp != NULL)\n    {\n\tif (spin->si_clear_chartab)\n\t{\n\t    // Clear the char type tables, don't want to use any of the\n\t    // currently used spell properties.\n\t    init_spell_chartab();\n\t    spin->si_clear_chartab = FALSE;\n\t}\n\n\t/*\n\t * Don't write a word table for an ASCII file, so that we don't check\n\t * for conflicts with a word table that matches 'encoding'.\n\t * Don't write one for utf-8 either, we use utf_*() and\n\t * mb_get_class(), the list of chars in the file will be incomplete.\n\t */\n\tif (!spin->si_ascii && !enc_utf8)\n\t{\n\t    if (fol == NULL || low == NULL || upp == NULL)\n\t\tsmsg(_(\"Missing FOL/LOW/UPP line in %s\"), fname);\n\t    else\n\t\t(void)set_spell_chartab(fol, low, upp);\n\t}\n\n\tvim_free(fol);\n\tvim_free(low);\n\tvim_free(upp);\n    }\n\n    // Use compound specifications of the .aff file for the spell info.\n    if (compmax != 0)\n    {\n\taff_check_number(spin->si_compmax, compmax, \"COMPOUNDWORDMAX\");\n\tspin->si_compmax = compmax;\n    }\n\n    if (compminlen != 0)\n    {\n\taff_check_number(spin->si_compminlen, compminlen, \"COMPOUNDMIN\");\n\tspin->si_compminlen = compminlen;\n    }\n\n    if (compsylmax != 0)\n    {\n\tif (syllable == NULL)\n\t    smsg(_(\"COMPOUNDSYLMAX used without SYLLABLE\"));\n\taff_check_number(spin->si_compsylmax, compsylmax, \"COMPOUNDSYLMAX\");\n\tspin->si_compsylmax = compsylmax;\n    }\n\n    if (compoptions != 0)\n    {\n\taff_check_number(spin->si_compoptions, compoptions, \"COMPOUND options\");\n\tspin->si_compoptions |= compoptions;\n    }\n\n    if (compflags != NULL)\n\tprocess_compflags(spin, aff, compflags);\n\n    // Check that we didn't use too many renumbered flags.\n    if (spin->si_newcompID < spin->si_newprefID)\n    {\n\tif (spin->si_newcompID == 127 || spin->si_newcompID == 255)\n\t    msg(_(\"Too many postponed prefixes\"));\n\telse if (spin->si_newprefID == 0 || spin->si_newprefID == 127)\n\t    msg(_(\"Too many compound flags\"));\n\telse\n\t    msg(_(\"Too many postponed prefixes and/or compound flags\"));\n    }\n\n    if (syllable != NULL)\n    {\n\taff_check_string(spin->si_syllable, syllable, \"SYLLABLE\");\n\tspin->si_syllable = syllable;\n    }\n\n    if (sofofrom != NULL || sofoto != NULL)\n    {\n\tif (sofofrom == NULL || sofoto == NULL)\n\t    smsg(_(\"Missing SOFO%s line in %s\"),\n\t\t\t\t     sofofrom == NULL ? \"FROM\" : \"TO\", fname);\n\telse if (spin->si_sal.ga_len > 0)\n\t    smsg(_(\"Both SAL and SOFO lines in %s\"), fname);\n\telse\n\t{\n\t    aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");\n\t    aff_check_string(spin->si_sofoto, sofoto, \"SOFOTO\");\n\t    spin->si_sofofr = sofofrom;\n\t    spin->si_sofoto = sofoto;\n\t}\n    }\n\n    if (midword != NULL)\n    {\n\taff_check_string(spin->si_midword, midword, \"MIDWORD\");\n\tspin->si_midword = midword;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n    return aff;\n}\n\n/*\n * Return TRUE when items[0] equals \"rulename\", there are \"mincount\" items or\n * a comment is following after item \"mincount\".\n */\n    static int\nis_aff_rule(\n    char_u\t**items,\n    int\t\titemcnt,\n    char\t*rulename,\n    int\t\tmincount)\n{\n    return (STRCMP(items[0], rulename) == 0\n\t    && (itemcnt == mincount\n\t\t|| (itemcnt > mincount && items[mincount][0] == '#')));\n}\n\n/*\n * For affix \"entry\" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from\n * ae_flags to ae_comppermit and ae_compforbid.\n */\n    static void\naff_process_flags(afffile_T *affile, affentry_T *entry)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n\n    if (entry->ae_flags != NULL\n\t\t&& (affile->af_compforbid != 0 || affile->af_comppermit != 0))\n    {\n\tfor (p = entry->ae_flags; *p != NUL; )\n\t{\n\t    prevp = p;\n\t    flag = get_affitem(affile->af_flagtype, &p);\n\t    if (flag == affile->af_comppermit || flag == affile->af_compforbid)\n\t    {\n\t\tSTRMOVE(prevp, p);\n\t\tp = prevp;\n\t\tif (flag == affile->af_comppermit)\n\t\t    entry->ae_comppermit = TRUE;\n\t\telse\n\t\t    entry->ae_compforbid = TRUE;\n\t    }\n\t    if (affile->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n\tif (*entry->ae_flags == NUL)\n\t    entry->ae_flags = NULL;\t// nothing left\n    }\n}\n\n/*\n * Return TRUE if \"s\" is the name of an info item in the affix file.\n */\n    static int\nspell_info_item(char_u *s)\n{\n    return STRCMP(s, \"NAME\") == 0\n\t|| STRCMP(s, \"HOME\") == 0\n\t|| STRCMP(s, \"VERSION\") == 0\n\t|| STRCMP(s, \"AUTHOR\") == 0\n\t|| STRCMP(s, \"EMAIL\") == 0\n\t|| STRCMP(s, \"COPYRIGHT\") == 0;\n}\n\n/*\n * Turn an affix flag name into a number, according to the FLAG type.\n * returns zero for failure.\n */\n    static unsigned\naffitem2flag(\n    int\t\tflagtype,\n    char_u\t*item,\n    char_u\t*fname,\n    int\t\tlnum)\n{\n    unsigned\tres;\n    char_u\t*p = item;\n\n    res = get_affitem(flagtype, &p);\n    if (res == 0)\n    {\n\tif (flagtype == AFT_NUM)\n\t    smsg(_(\"Flag is not a number in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n\telse\n\t    smsg(_(\"Illegal flag in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n    }\n    if (*p != NUL)\n    {\n\tsmsg(_(e_affname), fname, lnum, item);\n\treturn 0;\n    }\n\n    return res;\n}\n\n/*\n * Get one affix name from \"*pp\" and advance the pointer.\n * Returns ZERO_FLAG for \"0\".\n * Returns zero for an error, still advances the pointer then.\n */\n    static unsigned\nget_affitem(int flagtype, char_u **pp)\n{\n    int\t\tres;\n\n    if (flagtype == AFT_NUM)\n    {\n\tif (!VIM_ISDIGIT(**pp))\n\t{\n\t    ++*pp;\t// always advance, avoid getting stuck\n\t    return 0;\n\t}\n\tres = getdigits(pp);\n\tif (res == 0)\n\t    res = ZERO_FLAG;\n    }\n    else\n    {\n\tres = mb_ptr2char_adv(pp);\n\tif (flagtype == AFT_LONG || (flagtype == AFT_CAPLONG\n\t\t\t\t\t\t && res >= 'A' && res <= 'Z'))\n\t{\n\t    if (**pp == NUL)\n\t\treturn 0;\n\t    res = mb_ptr2char_adv(pp) + (res << 16);\n\t}\n    }\n    return res;\n}\n\n/*\n * Process the \"compflags\" string used in an affix file and append it to\n * spin->si_compflags.\n * The processing involves changing the affix names to ID numbers, so that\n * they fit in one byte.\n */\n    static void\nprocess_compflags(\n    spellinfo_T\t*spin,\n    afffile_T\t*aff,\n    char_u\t*compflags)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n    compitem_T\t*ci;\n    int\t\tid;\n    int\t\tlen;\n    char_u\t*tp;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    // Make room for the old and the new compflags, concatenated with a / in\n    // between.  Processing it makes it shorter, but we don't know by how\n    // much, thus allocate the maximum.\n    len = (int)STRLEN(compflags) + 1;\n    if (spin->si_compflags != NULL)\n\tlen += (int)STRLEN(spin->si_compflags) + 1;\n    p = getroom(spin, len, FALSE);\n    if (p == NULL)\n\treturn;\n    if (spin->si_compflags != NULL)\n    {\n\tSTRCPY(p, spin->si_compflags);\n\tSTRCAT(p, \"/\");\n    }\n    spin->si_compflags = p;\n    tp = p + STRLEN(p);\n\n    for (p = compflags; *p != NUL; )\n    {\n\tif (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)\n\t    // Copy non-flag characters directly.\n\t    *tp++ = *p++;\n\telse\n\t{\n\t    // First get the flag number, also checks validity.\n\t    prevp = p;\n\t    flag = get_affitem(aff->af_flagtype, &p);\n\t    if (flag != 0)\n\t    {\n\t\t// Find the flag in the hashtable.  If it was used before, use\n\t\t// the existing ID.  Otherwise add a new entry.\n\t\tvim_strncpy(key, prevp, p - prevp);\n\t\thi = hash_find(&aff->af_comp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    id = HI2CI(hi)->ci_newID;\n\t\telse\n\t\t{\n\t\t    ci = (compitem_T *)getroom(spin, sizeof(compitem_T), TRUE);\n\t\t    if (ci == NULL)\n\t\t\tbreak;\n\t\t    STRCPY(ci->ci_key, key);\n\t\t    ci->ci_flag = flag;\n\t\t    // Avoid using a flag ID that has a special meaning in a\n\t\t    // regexp (also inside []).\n\t\t    do\n\t\t    {\n\t\t\tcheck_renumber(spin);\n\t\t\tid = spin->si_newcompID--;\n\t\t    } while (vim_strchr((char_u *)\"/?*+[]\\\\-^\", id) != NULL);\n\t\t    ci->ci_newID = id;\n\t\t    hash_add(&aff->af_comp, ci->ci_key);\n\t\t}\n\t\t*tp++ = id;\n\t    }\n\t    if (aff->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n    }\n\n    *tp = NUL;\n}\n\n/*\n * Check that the new IDs for postponed affixes and compounding don't overrun\n * each other.  We have almost 255 available, but start at 0-127 to avoid\n * using two bytes for utf-8.  When the 0-127 range is used up go to 128-255.\n * When that is used up an error message is given.\n */\n    static void\ncheck_renumber(spellinfo_T *spin)\n{\n    if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)\n    {\n\tspin->si_newprefID = 127;\n\tspin->si_newcompID = 255;\n    }\n}\n\n/*\n * Return TRUE if flag \"flag\" appears in affix list \"afflist\".\n */\n    static int\nflag_in_afflist(int flagtype, char_u *afflist, unsigned flag)\n{\n    char_u\t*p;\n    unsigned\tn;\n\n    switch (flagtype)\n    {\n\tcase AFT_CHAR:\n\t    return vim_strchr(afflist, flag) != NULL;\n\n\tcase AFT_CAPLONG:\n\tcase AFT_LONG:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = mb_ptr2char_adv(&p);\n\t\tif ((flagtype == AFT_LONG || (n >= 'A' && n <= 'Z'))\n\t\t\t\t\t\t\t\t && *p != NUL)\n\t\t    n = mb_ptr2char_adv(&p) + (n << 16);\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t    }\n\t    break;\n\n\tcase AFT_NUM:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = getdigits(&p);\n\t\tif (n == 0)\n\t\t    n = ZERO_FLAG;\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t\tif (*p != NUL)\t// skip over comma\n\t\t    ++p;\n\t    }\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" numbers are set and not the same.\n */\n    static void\naff_check_number(int spinval, int affval, char *name)\n{\n    if (spinval != 0 && spinval != affval)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" strings are set and not the same.\n */\n    static void\naff_check_string(char_u *spinval, char_u *affval, char *name)\n{\n    if (spinval != NULL && STRCMP(spinval, affval) != 0)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Return TRUE if strings \"s1\" and \"s2\" are equal.  Also consider both being\n * NULL as equal.\n */\n    static int\nstr_equal(char_u *s1, char_u *s2)\n{\n    if (s1 == NULL || s2 == NULL)\n\treturn s1 == s2;\n    return STRCMP(s1, s2) == 0;\n}\n\n/*\n * Add a from-to item to \"gap\".  Used for REP and SAL items.\n * They are stored case-folded.\n */\n    static void\nadd_fromto(\n    spellinfo_T\t*spin,\n    garray_T\t*gap,\n    char_u\t*from,\n    char_u\t*to)\n{\n    fromto_T\t*ftp;\n    char_u\tword[MAXWLEN];\n\n    if (ga_grow(gap, 1) == OK)\n    {\n\tftp = ((fromto_T *)gap->ga_data) + gap->ga_len;\n\t(void)spell_casefold(curwin, from, (int)STRLEN(from), word, MAXWLEN);\n\tftp->ft_from = getroom_save(spin, word);\n\t(void)spell_casefold(curwin, to, (int)STRLEN(to), word, MAXWLEN);\n\tftp->ft_to = getroom_save(spin, word);\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Convert a boolean argument in a SAL line to TRUE or FALSE;\n */\n    static int\nsal_to_bool(char_u *s)\n{\n    return STRCMP(s, \"1\") == 0 || STRCMP(s, \"true\") == 0;\n}\n\n/*\n * Free the structure filled by spell_read_aff().\n */\n    static void\nspell_free_aff(afffile_T *aff)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n\n    vim_free(aff->af_enc);\n\n    // All this trouble to free the \"ae_prog\" items...\n    for (ht = &aff->af_pref; ; ht = &aff->af_suff)\n    {\n\ttodo = (int)ht->ht_used;\n\tfor (hi = ht->ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tah = HI2AH(hi);\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t    vim_regfree(ae->ae_prog);\n\t    }\n\t}\n\tif (ht == &aff->af_suff)\n\t    break;\n    }\n\n    hash_clear(&aff->af_pref);\n    hash_clear(&aff->af_suff);\n    hash_clear(&aff->af_comp);\n}\n\n/*\n * Read dictionary file \"fname\".\n * Returns OK or FAIL;\n */\n    static int\nspell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)\n{\n    hashtab_T\tht;\n    char_u\tline[MAXLINELEN];\n    char_u\t*p;\n    char_u\t*afflist;\n    char_u\tstore_afflist[MAXWLEN];\n    int\t\tpfxlen;\n    int\t\tneed_affix;\n    char_u\t*dw;\n    char_u\t*pc;\n    char_u\t*w;\n    int\t\tl;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    FILE\t*fd;\n    int\t\tlnum = 1;\n    int\t\tnon_ascii = 0;\n    int\t\tretval = OK;\n    char_u\tmessage[MAXLINELEN + MAXWLEN];\n    int\t\tflags;\n    int\t\tduplicate = 0;\n    time_T\tlast_msg_time = 0;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // The hashtable is only used to detect duplicated words.\n    hash_init(&ht);\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Reading dictionary file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // start with a message for the first line\n    spin->si_msg_count = 999999;\n\n    // Read and ignore the first line: word count.\n    if (vim_fgets(line, MAXLINELEN, fd) || !vim_isdigit(*skipwhite(line)))\n\tsemsg(_(e_no_word_count_in_str), fname);\n\n    /*\n     * Read all the lines in the file one by one.\n     * The words are converted to 'encoding' here, before being added to\n     * the hashtable.\n     */\n    while (!vim_fgets(line, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\tif (line[0] == '#' || line[0] == '/')\n\t    continue;\t// comment line\n\n\t// Remove CR, LF and white space from the end.  White space halfway\n\t// the word is kept to allow e.g., \"et al.\".\n\tl = (int)STRLEN(line);\n\twhile (l > 0 && line[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty line\n\tline[l] = NUL;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, line, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\tcontinue;\n\t    }\n\t    w = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    w = line;\n\t}\n\n\t// Truncate the word at the \"/\", set \"afflist\" to what follows.\n\t// Replace \"\\/\" by \"/\" and \"\\\\\" by \"\\\".\n\tafflist = NULL;\n\tfor (p = w; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (*p == '\\\\' && (p[1] == '\\\\' || p[1] == '/'))\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '/')\n\t    {\n\t\t*p = NUL;\n\t\tafflist = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(w))\n\t{\n\t    ++non_ascii;\n\t    vim_free(pc);\n\t    continue;\n\t}\n\n\t// This takes time, print a message every 10000 words, but not more\n\t// often than once per second.\n\tif (spin->si_verbose && spin->si_msg_count > 10000)\n\t{\n\t    spin->si_msg_count = 0;\n\t    if (vim_time() > last_msg_time)\n\t    {\n\t\tlast_msg_time = vim_time();\n\t\tvim_snprintf((char *)message, sizeof(message),\n\t\t\t_(\"line %6d, word %6ld - %s\"),\n\t\t\t   lnum, spin->si_foldwcount + spin->si_keepwcount, w);\n\t\tmsg_start();\n\t\tmsg_outtrans_long_attr(message, 0);\n\t\tmsg_clr_eos();\n\t\tmsg_didout = FALSE;\n\t\tmsg_col = 0;\n\t\tout_flush();\n\t    }\n\t}\n\n\t// Store the word in the hashtable to be able to find duplicates.\n\tdw = getroom_save(spin, w);\n\tif (dw == NULL)\n\t{\n\t    retval = FAIL;\n\t    vim_free(pc);\n\t    break;\n\t}\n\n\thash = hash_hash(dw);\n\thi = hash_lookup(&ht, dw, hash);\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    if (p_verbose > 0)\n\t\tsmsg(_(\"Duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    else if (duplicate == 0)\n\t\tsmsg(_(\"First duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    ++duplicate;\n\t}\n\telse\n\t    hash_add_item(&ht, hi, dw, hash);\n\n\tflags = 0;\n\tstore_afflist[0] = NUL;\n\tpfxlen = 0;\n\tneed_affix = FALSE;\n\tif (afflist != NULL)\n\t{\n\t    // Extract flags from the affix list.\n\t    flags |= get_affix_flags(affile, afflist);\n\n\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_needaffix))\n\t\tneed_affix = TRUE;\n\n\t    if (affile->af_pfxpostpone)\n\t\t// Need to store the list of prefix IDs with the word.\n\t\tpfxlen = get_pfxlist(affile, afflist, store_afflist);\n\n\t    if (spin->si_compflags != NULL)\n\t\t// Need to store the list of compound flags with the word.\n\t\t// Concatenate them to the list of prefix IDs.\n\t\tget_compflags(affile, afflist, store_afflist + pfxlen);\n\t}\n\n\t// Add the word to the word tree(s).\n\tif (store_word(spin, dw, flags, spin->si_region,\n\t\t\t\t\t   store_afflist, need_affix) == FAIL)\n\t    retval = FAIL;\n\n\tif (afflist != NULL)\n\t{\n\t    // Find all matching suffixes and add the resulting words.\n\t    // Additionally do matching prefixes that combine.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t   &affile->af_suff, &affile->af_pref,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\n\t    // Find all matching prefixes and add the resulting words.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t  &affile->af_pref, NULL,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\t}\n\n\tvim_free(pc);\n    }\n\n    if (duplicate > 0)\n\tsmsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);\n    if (spin->si_ascii && non_ascii > 0)\n\tsmsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),\n\t\t\t\t\t\t\t    non_ascii, fname);\n    hash_clear(&ht);\n\n    fclose(fd);\n    return retval;\n}\n\n/*\n * Check for affix flags in \"afflist\" that are turned into word flags.\n * Return WF_ flags.\n */\n    static int\nget_affix_flags(afffile_T *affile, char_u *afflist)\n{\n    int\t\tflags = 0;\n\n    if (affile->af_keepcase != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_keepcase))\n\tflags |= WF_KEEPCAP | WF_FIXCAP;\n    if (affile->af_rare != 0 && flag_in_afflist(\n\t\t\t       affile->af_flagtype, afflist, affile->af_rare))\n\tflags |= WF_RARE;\n    if (affile->af_bad != 0 && flag_in_afflist(\n\t\t\t\taffile->af_flagtype, afflist, affile->af_bad))\n\tflags |= WF_BANNED;\n    if (affile->af_needcomp != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_needcomp))\n\tflags |= WF_NEEDCOMP;\n    if (affile->af_comproot != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_comproot))\n\tflags |= WF_COMPROOT;\n    if (affile->af_nosuggest != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_nosuggest))\n\tflags |= WF_NOSUGGEST;\n    return flags;\n}\n\n/*\n * Get the list of prefix IDs from the affix list \"afflist\".\n * Used for PFXPOSTPONE.\n * Put the resulting flags in \"store_afflist[MAXWLEN]\" with a terminating NUL\n * and return the number of affixes.\n */\n    static int\nget_pfxlist(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    int\t\tid;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a postponed prefix flag if it appears in \"af_pref\"\n\t    // and its ID is not zero.\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_pref, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tid = HI2AH(hi)->ah_newID;\n\t\tif (id != 0)\n\t\t    store_afflist[cnt++] = id;\n\t    }\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n    return cnt;\n}\n\n/*\n * Get the list of compound IDs from the affix list \"afflist\" that are used\n * for compound words.\n * Puts the flags in \"store_afflist[]\".\n */\n    static void\nget_compflags(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a compound flag if it appears in \"af_comp\".\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_comp, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\tstore_afflist[cnt++] = HI2CI(hi)->ci_newID;\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n}\n\n/*\n * Apply affixes to a word and store the resulting words.\n * \"ht\" is the hashtable with affentry_T that need to be applied, either\n * prefixes or suffixes.\n * \"xht\", when not NULL, is the prefix hashtable, to be used additionally on\n * the resulting words for combining affixes.\n *\n * Returns FAIL when out of memory.\n */\n    static int\nstore_aff_word(\n    spellinfo_T\t*spin,\t\t// spell info\n    char_u\t*word,\t\t// basic word start\n    char_u\t*afflist,\t// list of names of supported affixes\n    afffile_T\t*affile,\n    hashtab_T\t*ht,\n    hashtab_T\t*xht,\n    int\t\tcondit,\t\t// CONDIT_SUF et al.\n    int\t\tflags,\t\t// flags for the word\n    char_u\t*pfxlist,\t// list of prefix IDs\n    int\t\tpfxlen)\t\t// nr of flags in \"pfxlist\" for prefixes, rest\n\t\t\t\t// is compound flags\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n    char_u\tnewword[MAXWLEN];\n    int\t\tretval = OK;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tuse_flags;\n    char_u\t*use_pfxlist;\n    int\t\tuse_pfxlen;\n    int\t\tneed_affix;\n    char_u\tstore_afflist[MAXWLEN];\n    char_u\tpfx_pfxlist[MAXWLEN];\n    size_t\twordlen = STRLEN(word);\n    int\t\tuse_condit;\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ah = HI2AH(hi);\n\n\t    // Check that the affix combines, if required, and that the word\n\t    // supports this affix.\n\t    if (((condit & CONDIT_COMB) == 0 || ah->ah_combine)\n\t\t    && flag_in_afflist(affile->af_flagtype, afflist,\n\t\t\t\t\t\t\t\t ah->ah_flag))\n\t    {\n\t\t// Loop over all affix entries with this name.\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t{\n\t\t    // Check the condition.  It's not logical to match case\n\t\t    // here, but it is required for compatibility with\n\t\t    // Myspell.\n\t\t    // Another requirement from Myspell is that the chop\n\t\t    // string is shorter than the word itself.\n\t\t    // For prefixes, when \"PFXPOSTPONE\" was used, only do\n\t\t    // prefixes with a chop string and/or flags.\n\t\t    // When a previously added affix had CIRCUMFIX this one\n\t\t    // must have it too, if it had not then this one must not\n\t\t    // have one either.\n\t\t    if ((xht != NULL || !affile->af_pfxpostpone\n\t\t\t\t|| ae->ae_chop != NULL\n\t\t\t\t|| ae->ae_flags != NULL)\n\t\t\t    && (ae->ae_chop == NULL\n\t\t\t\t|| STRLEN(ae->ae_chop) < wordlen)\n\t\t\t    && (ae->ae_prog == NULL\n\t\t\t\t|| vim_regexec_prog(&ae->ae_prog, FALSE,\n\t\t\t\t\t\t\t    word, (colnr_T)0))\n\t\t\t    && (((condit & CONDIT_CFIX) == 0)\n\t\t\t\t== ((condit & CONDIT_AFF) == 0\n\t\t\t\t    || ae->ae_flags == NULL\n\t\t\t\t    || !flag_in_afflist(affile->af_flagtype,\n\t\t\t\t\tae->ae_flags, affile->af_circumfix))))\n\t\t    {\n\t\t\t// Match.  Remove the chop and add the affix.\n\t\t\tif (xht == NULL)\n\t\t\t{\n\t\t\t    // prefix: chop/add at the start of the word\n\t\t\t    if (ae->ae_add == NULL)\n\t\t\t\t*newword = NUL;\n\t\t\t    else\n\t\t\t\tvim_strncpy(newword, ae->ae_add, MAXWLEN - 1);\n\t\t\t    p = word;\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Skip chop string.\n\t\t\t\tif (has_mbyte)\n\t\t\t\t{\n\t\t\t\t    i = mb_charlen(ae->ae_chop);\n\t\t\t\t    for ( ; i > 0; --i)\n\t\t\t\t\tMB_PTR_ADV(p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    p += STRLEN(ae->ae_chop);\n\t\t\t    }\n\t\t\t    STRCAT(newword, p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // suffix: chop/add at the end of the word\n\t\t\t    vim_strncpy(newword, word, MAXWLEN - 1);\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Remove chop string.\n\t\t\t\tp = newword + STRLEN(newword);\n\t\t\t\ti = (int)MB_CHARLEN(ae->ae_chop);\n\t\t\t\tfor ( ; i > 0; --i)\n\t\t\t\t    MB_PTR_BACK(newword, p);\n\t\t\t\t*p = NUL;\n\t\t\t    }\n\t\t\t    if (ae->ae_add != NULL)\n\t\t\t\tSTRCAT(newword, ae->ae_add);\n\t\t\t}\n\n\t\t\tuse_flags = flags;\n\t\t\tuse_pfxlist = pfxlist;\n\t\t\tuse_pfxlen = pfxlen;\n\t\t\tneed_affix = FALSE;\n\t\t\tuse_condit = condit | CONDIT_COMB | CONDIT_AFF;\n\t\t\tif (ae->ae_flags != NULL)\n\t\t\t{\n\t\t\t    // Extract flags from the affix list.\n\t\t\t    use_flags |= get_affix_flags(affile, ae->ae_flags);\n\n\t\t\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_needaffix))\n\t\t\t\tneed_affix = TRUE;\n\n\t\t\t    // When there is a CIRCUMFIX flag the other affix\n\t\t\t    // must also have it and we don't add the word\n\t\t\t    // with one affix.\n\t\t\t    if (affile->af_circumfix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_circumfix))\n\t\t\t    {\n\t\t\t\tuse_condit |= CONDIT_CFIX;\n\t\t\t\tif ((condit & CONDIT_CFIX) == 0)\n\t\t\t\t    need_affix = TRUE;\n\t\t\t    }\n\n\t\t\t    if (affile->af_pfxpostpone\n\t\t\t\t\t\t|| spin->si_compflags != NULL)\n\t\t\t    {\n\t\t\t\tif (affile->af_pfxpostpone)\n\t\t\t\t    // Get prefix IDS from the affix list.\n\t\t\t\t    use_pfxlen = get_pfxlist(affile,\n\t\t\t\t\t\t ae->ae_flags, store_afflist);\n\t\t\t\telse\n\t\t\t\t    use_pfxlen = 0;\n\t\t\t\tuse_pfxlist = store_afflist;\n\n\t\t\t\t// Combine the prefix IDs. Avoid adding the\n\t\t\t\t// same ID twice.\n\t\t\t\tfor (i = 0; i < pfxlen; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = 0; j < use_pfxlen; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j == use_pfxlen)\n\t\t\t\t\tuse_pfxlist[use_pfxlen++] = pfxlist[i];\n\t\t\t\t}\n\n\t\t\t\tif (spin->si_compflags != NULL)\n\t\t\t\t    // Get compound IDS from the affix list.\n\t\t\t\t    get_compflags(affile, ae->ae_flags,\n\t\t\t\t\t\t  use_pfxlist + use_pfxlen);\n\n\t\t\t\t// Combine the list of compound flags.\n\t\t\t\t// Concatenate them to the prefix IDs list.\n\t\t\t\t// Avoid adding the same ID twice.\n\t\t\t\tfor (i = pfxlen; pfxlist[i] != NUL; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = use_pfxlen;\n\t\t\t\t\t\t   use_pfxlist[j] != NUL; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (use_pfxlist[j] == NUL)\n\t\t\t\t    {\n\t\t\t\t\tuse_pfxlist[j++] = pfxlist[i];\n\t\t\t\t\tuse_pfxlist[j] = NUL;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// Obey a \"COMPOUNDFORBIDFLAG\" of the affix: don't\n\t\t\t// use the compound flags.\n\t\t\tif (use_pfxlist != NULL && ae->ae_compforbid)\n\t\t\t{\n\t\t\t    vim_strncpy(pfx_pfxlist, use_pfxlist, use_pfxlen);\n\t\t\t    use_pfxlist = pfx_pfxlist;\n\t\t\t}\n\n\t\t\t// When there are postponed prefixes...\n\t\t\tif (spin->si_prefroot != NULL\n\t\t\t\t&& spin->si_prefroot->wn_sibling != NULL)\n\t\t\t{\n\t\t\t    // ... add a flag to indicate an affix was used.\n\t\t\t    use_flags |= WF_HAS_AFF;\n\n\t\t\t    // ... don't use a prefix list if combining\n\t\t\t    // affixes is not allowed.  But do use the\n\t\t\t    // compound flags after them.\n\t\t\t    if (!ah->ah_combine && use_pfxlist != NULL)\n\t\t\t\tuse_pfxlist += use_pfxlen;\n\t\t\t}\n\n\t\t\t// When compounding is supported and there is no\n\t\t\t// \"COMPOUNDPERMITFLAG\" then forbid compounding on the\n\t\t\t// side where the affix is applied.\n\t\t\tif (spin->si_compflags != NULL && !ae->ae_comppermit)\n\t\t\t{\n\t\t\t    if (xht != NULL)\n\t\t\t\tuse_flags |= WF_NOCOMPAFT;\n\t\t\t    else\n\t\t\t\tuse_flags |= WF_NOCOMPBEF;\n\t\t\t}\n\n\t\t\t// Store the modified word.\n\t\t\tif (store_word(spin, newword, use_flags,\n\t\t\t\t\t\t spin->si_region, use_pfxlist,\n\t\t\t\t\t\t\t  need_affix) == FAIL)\n\t\t\t    retval = FAIL;\n\n\t\t\t// When added a prefix or a first suffix and the affix\n\t\t\t// has flags may add a(nother) suffix.  RECURSIVE!\n\t\t\tif ((condit & CONDIT_SUF) && ae->ae_flags != NULL)\n\t\t\t    if (store_aff_word(spin, newword, ae->ae_flags,\n\t\t\t\t\taffile, &affile->af_suff, xht,\n\t\t\t\t\t   use_condit & (xht == NULL\n\t\t\t\t\t\t\t? ~0 :  ~CONDIT_SUF),\n\t\t\t\t      use_flags, use_pfxlist, pfxlen) == FAIL)\n\t\t\t\tretval = FAIL;\n\n\t\t\t// When added a suffix and combining is allowed also\n\t\t\t// try adding a prefix additionally.  Both for the\n\t\t\t// word flags and for the affix flags.  RECURSIVE!\n\t\t\tif (xht != NULL && ah->ah_combine)\n\t\t\t{\n\t\t\t    if (store_aff_word(spin, newword,\n\t\t\t\t\tafflist, affile,\n\t\t\t\t\txht, NULL, use_condit,\n\t\t\t\t\tuse_flags, use_pfxlist,\n\t\t\t\t\tpfxlen) == FAIL\n\t\t\t\t    || (ae->ae_flags != NULL\n\t\t\t\t\t&& store_aff_word(spin, newword,\n\t\t\t\t\t    ae->ae_flags, affile,\n\t\t\t\t\t    xht, NULL, use_condit,\n\t\t\t\t\t    use_flags, use_pfxlist,\n\t\t\t\t\t    pfxlen) == FAIL))\n\t\t\t\tretval = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a file with a list of words.\n */\n    static int\nspell_read_wordfile(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    long\tlnum = 0;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tretval = OK;\n    int\t\tdid_word = FALSE;\n    int\t\tnon_ascii = 0;\n    int\t\tflags;\n    int\t\tregionmask;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading word file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Remove CR, LF and white space from the end.\n\tl = (int)STRLEN(rline);\n\twhile (l > 0 && rline[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty or blank line\n\trline[l] = NUL;\n\n\t// Convert from \"/encoding={encoding}\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %ld: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\tif (*line == '/')\n\t{\n\t    ++line;\n\t    if (STRNCMP(line, \"encoding=\", 9) == 0)\n\t    {\n\t\tif (spin->si_conv.vc_type != CONV_NONE)\n\t\t    smsg(_(\"Duplicate /encoding= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse if (did_word)\n\t\t    smsg(_(\"/encoding= line after word ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse\n\t\t{\n\t\t    char_u\t*enc;\n\n\t\t    // Setup for conversion to 'encoding'.\n\t\t    line += 9;\n\t\t    enc = enc_canonize(line);\n\t\t    if (enc != NULL && !spin->si_ascii\n\t\t\t    && convert_setup(&spin->si_conv, enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t\tsmsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t\t\t  fname, line, p_enc);\n\t\t    vim_free(enc);\n\t\t    spin->si_conv.vc_fail = TRUE;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (STRNCMP(line, \"regions=\", 8) == 0)\n\t    {\n\t\tif (spin->si_region_count > 1)\n\t\t    smsg(_(\"Duplicate /regions= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\telse\n\t\t{\n\t\t    line += 8;\n\t\t    if (STRLEN(line) > MAXREGIONS * 2)\n\t\t\tsmsg(_(\"Too many regions in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\t    else\n\t\t    {\n\t\t\tspin->si_region_count = (int)STRLEN(line) / 2;\n\t\t\tSTRCPY(spin->si_region_name, line);\n\n\t\t\t// Adjust the mask for a word valid in all regions.\n\t\t\tspin->si_region = (1 << spin->si_region_count) - 1;\n\t\t    }\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    smsg(_(\"/ line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t    continue;\n\t}\n\n\tflags = 0;\n\tregionmask = spin->si_region;\n\n\t// Check for flags and region after a slash.\n\tp = vim_strchr(line, '/');\n\tif (p != NULL)\n\t{\n\t    *p++ = NUL;\n\t    while (*p != NUL)\n\t    {\n\t\tif (*p == '=')\t\t// keep-case word\n\t\t    flags |= WF_KEEPCAP | WF_FIXCAP;\n\t\telse if (*p == '!')\t// Bad, bad, wicked word.\n\t\t    flags |= WF_BANNED;\n\t\telse if (*p == '?')\t// Rare word.\n\t\t    flags |= WF_RARE;\n\t\telse if (VIM_ISDIGIT(*p)) // region number(s)\n\t\t{\n\t\t    if ((flags & WF_REGION) == 0)   // first one\n\t\t\tregionmask = 0;\n\t\t    flags |= WF_REGION;\n\n\t\t    l = *p - '0';\n\t\t    if (l == 0 || l > spin->si_region_count)\n\t\t    {\n\t\t\tsmsg(_(\"Invalid region nr in %s line %ld: %s\"),\n\t\t\t\t\t\t\t  fname, lnum, p);\n\t\t\tbreak;\n\t\t    }\n\t\t    regionmask |= 1 << (l - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    smsg(_(\"Unrecognized flags in %s line %ld: %s\"),\n\t\t\t\t\t\t\t      fname, lnum, p);\n\t\t    break;\n\t\t}\n\t\t++p;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(line))\n\t{\n\t    ++non_ascii;\n\t    continue;\n\t}\n\n\t// Normal word: store it.\n\tif (store_word(spin, line, flags, regionmask, NULL, FALSE) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    break;\n\t}\n\tdid_word = TRUE;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n\n    if (spin->si_ascii && non_ascii > 0)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t  _(\"Ignored %d words with non-ASCII characters\"), non_ascii);\n\tspell_message(spin, IObuff);\n    }\n\n    return retval;\n}\n\n/*\n * Get part of an sblock_T, \"len\" bytes long.\n * This avoids calling free() for every little struct we use (and keeping\n * track of them).\n * The memory is cleared to all zeros.\n * Returns NULL when out of memory.\n */\n    static void *\ngetroom(\n    spellinfo_T *spin,\n    size_t\tlen,\t\t// length needed\n    int\t\talign)\t\t// align for pointer\n{\n    char_u\t*p;\n    sblock_T\t*bl = spin->si_blocks;\n\n    if (align && bl != NULL)\n\t// Round size up for alignment.  On some systems structures need to be\n\t// aligned to the size of a pointer (e.g., SPARC).\n\tbl->sb_used = (bl->sb_used + sizeof(char *) - 1)\n\t\t\t\t\t\t      & ~(sizeof(char *) - 1);\n\n    if (bl == NULL || bl->sb_used + len > SBLOCKSIZE)\n    {\n\tif (len >= SBLOCKSIZE)\n\t    bl = NULL;\n\telse\n\t    // Allocate a block of memory. It is not freed until much later.\n\t    bl = alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);\n\tif (bl == NULL)\n\t{\n\t    if (!spin->si_did_emsg)\n\t    {\n\t\temsg(_(e_insufficient_memory_word_list_will_be_incomplete));\n\t\tspin->si_did_emsg = TRUE;\n\t    }\n\t    return NULL;\n\t}\n\tbl->sb_next = spin->si_blocks;\n\tspin->si_blocks = bl;\n\tbl->sb_used = 0;\n\t++spin->si_blocks_cnt;\n    }\n\n    p = bl->sb_data + bl->sb_used;\n    bl->sb_used += (int)len;\n\n    return p;\n}\n\n/*\n * Make a copy of a string into memory allocated with getroom().\n * Returns NULL when out of memory.\n */\n    static char_u *\ngetroom_save(spellinfo_T *spin, char_u *s)\n{\n    char_u\t*sc;\n\n    sc = (char_u *)getroom(spin, STRLEN(s) + 1, FALSE);\n    if (sc != NULL)\n\tSTRCPY(sc, s);\n    return sc;\n}\n\n\n/*\n * Free the list of allocated sblock_T.\n */\n    static void\nfree_blocks(sblock_T *bl)\n{\n    sblock_T\t*next;\n\n    while (bl != NULL)\n    {\n\tnext = bl->sb_next;\n\tvim_free(bl);\n\tbl = next;\n    }\n}\n\n/*\n * Allocate the root of a word tree.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nwordtree_alloc(spellinfo_T *spin)\n{\n    return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n}\n\n/*\n * Store a word in the tree(s).\n * Always store it in the case-folded tree.  For a keep-case word this is\n * useful when the word can also be used with all caps (no WF_FIXCAP flag) and\n * used to find suggestions.\n * For a keep-case word also store it in the keep-case tree.\n * When \"pfxlist\" is not NULL store the word for each postponed prefix ID and\n * compound flag.\n */\n    static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    // Avoid adding illegal bytes to the word tree.\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n\treturn FAIL;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}\n\n/*\n * Add word \"word\" to a word tree at \"root\".\n * When \"flags\" < 0 we are adding to the prefix tree where \"flags\" is used for\n * \"rare\" and \"region\" is the condition nr.\n * Returns FAIL when out of memory.\n */\n    static int\ntree_add_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    wordnode_T\t*root,\n    int\t\tflags,\n    int\t\tregion,\n    int\t\taffixID)\n{\n    wordnode_T\t*node = root;\n    wordnode_T\t*np;\n    wordnode_T\t*copyp, **copyprev;\n    wordnode_T\t**prev = NULL;\n    int\t\ti;\n\n    // Add each byte of the word to the tree, including the NUL at the end.\n    for (i = 0; ; ++i)\n    {\n\t// When there is more than one reference to this node we need to make\n\t// a copy, so that we can modify it.  Copy the whole list of siblings\n\t// (we don't optimize for a partly shared list of siblings).\n\tif (node != NULL && node->wn_refs > 1)\n\t{\n\t    --node->wn_refs;\n\t    copyprev = prev;\n\t    FOR_ALL_NODE_SIBLINGS(node, copyp)\n\t    {\n\t\t// Allocate a new node and copy the info.\n\t\tnp = get_wordnode(spin);\n\t\tif (np == NULL)\n\t\t    return FAIL;\n\t\tnp->wn_child = copyp->wn_child;\n\t\tif (np->wn_child != NULL)\n\t\t    ++np->wn_child->wn_refs;\t// child gets extra ref\n\t\tnp->wn_byte = copyp->wn_byte;\n\t\tif (np->wn_byte == NUL)\n\t\t{\n\t\t    np->wn_flags = copyp->wn_flags;\n\t\t    np->wn_region = copyp->wn_region;\n\t\t    np->wn_affixID = copyp->wn_affixID;\n\t\t}\n\n\t\t// Link the new node in the list, there will be one ref.\n\t\tnp->wn_refs = 1;\n\t\tif (copyprev != NULL)\n\t\t    *copyprev = np;\n\t\tcopyprev = &np->wn_sibling;\n\n\t\t// Let \"node\" point to the head of the copied list.\n\t\tif (copyp == node)\n\t\t    node = np;\n\t    }\n\t}\n\n\t// Look for the sibling that has the same character.  They are sorted\n\t// on byte value, thus stop searching when a sibling is found with a\n\t// higher byte value.  For zero bytes (end of word) the sorting is\n\t// done on flags and then on affixID.\n\twhile (node != NULL\n\t\t&& (node->wn_byte < word[i]\n\t\t    || (node->wn_byte == NUL\n\t\t\t&& (flags < 0\n\t\t\t    ? node->wn_affixID < (unsigned)affixID\n\t\t\t    : (node->wn_flags < (unsigned)(flags & WN_MASK)\n\t\t\t\t|| (node->wn_flags == (flags & WN_MASK)\n\t\t\t\t    && (spin->si_sugtree\n\t\t\t\t\t? (node->wn_region & 0xffff) < region\n\t\t\t\t\t: node->wn_affixID\n\t\t\t\t\t\t    < (unsigned)affixID)))))))\n\t{\n\t    prev = &node->wn_sibling;\n\t    node = *prev;\n\t}\n\tif (node == NULL\n\t\t|| node->wn_byte != word[i]\n\t\t|| (word[i] == NUL\n\t\t    && (flags < 0\n\t\t\t|| spin->si_sugtree\n\t\t\t|| node->wn_flags != (flags & WN_MASK)\n\t\t\t|| node->wn_affixID != affixID)))\n\t{\n\t    // Allocate a new node.\n\t    np = get_wordnode(spin);\n\t    if (np == NULL)\n\t\treturn FAIL;\n\t    np->wn_byte = word[i];\n\n\t    // If \"node\" is NULL this is a new child or the end of the sibling\n\t    // list: ref count is one.  Otherwise use ref count of sibling and\n\t    // make ref count of sibling one (matters when inserting in front\n\t    // of the list of siblings).\n\t    if (node == NULL)\n\t\tnp->wn_refs = 1;\n\t    else\n\t    {\n\t\tnp->wn_refs = node->wn_refs;\n\t\tnode->wn_refs = 1;\n\t    }\n\t    if (prev != NULL)\n\t\t*prev = np;\n\t    np->wn_sibling = node;\n\t    node = np;\n\t}\n\n\tif (word[i] == NUL)\n\t{\n\t    node->wn_flags = flags;\n\t    node->wn_region |= region;\n\t    node->wn_affixID = affixID;\n\t    break;\n\t}\n\tprev = &node->wn_child;\n\tnode = *prev;\n    }\n#ifdef SPELL_PRINTTREE\n    smsg(\"Added \\\"%s\\\"\", word);\n    spell_print_tree(root->wn_sibling);\n#endif\n\n    // count nr of words added since last message\n    ++spin->si_msg_count;\n\n    if (spin->si_compress_cnt > 1)\n    {\n\tif (--spin->si_compress_cnt == 1)\n\t    // Did enough words to lower the block count limit.\n\t    spin->si_blocks_cnt += compress_inc;\n    }\n\n    /*\n     * When we have allocated lots of memory we need to compress the word tree\n     * to free up some room.  But compression is slow, and we might actually\n     * need that room, thus only compress in the following situations:\n     * 1. When not compressed before (si_compress_cnt == 0): when using\n     *    \"compress_start\" blocks.\n     * 2. When compressed before and used \"compress_inc\" blocks before\n     *    adding \"compress_added\" words (si_compress_cnt > 1).\n     * 3. When compressed before, added \"compress_added\" words\n     *    (si_compress_cnt == 1) and the number of free nodes drops below the\n     *    maximum word length.\n     */\n#ifndef SPELL_COMPRESS_ALLWAYS\n    if (spin->si_compress_cnt == 1\n\t    ? spin->si_free_count < MAXWLEN\n\t    : spin->si_blocks_cnt >= compress_start)\n#endif\n    {\n\t// Decrement the block counter.  The effect is that we compress again\n\t// when the freed up room has been used and another \"compress_inc\"\n\t// blocks have been allocated.  Unless \"compress_added\" words have\n\t// been added, then the limit is put back again.\n\tspin->si_blocks_cnt -= compress_inc;\n\tspin->si_compress_cnt = compress_added;\n\n\tif (spin->si_verbose)\n\t{\n\t    msg_start();\n\t    msg_puts(_(msg_compressing));\n\t    msg_clr_eos();\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    out_flush();\n\t}\n\n\t// Compress both trees.  Either they both have many nodes, which makes\n\t// compression useful, or one of them is small, which means\n\t// compression goes fast.  But when filling the soundfold word tree\n\t// there is no keep-case tree.\n\twordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\tif (affixID >= 0)\n\t    wordtree_compress(spin, spin->si_keeproot, \"keep-case\");\n    }\n\n    return OK;\n}\n\n/*\n * Get a wordnode_T, either from the list of previously freed nodes or\n * allocate a new one.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nget_wordnode(spellinfo_T *spin)\n{\n    wordnode_T *n;\n\n    if (spin->si_first_free == NULL)\n\tn = (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n    else\n    {\n\tn = spin->si_first_free;\n\tspin->si_first_free = n->wn_child;\n\tCLEAR_POINTER(n);\n\t--spin->si_free_count;\n    }\n#ifdef SPELL_PRINTTREE\n    if (n != NULL)\n\tn->wn_nr = ++spin->si_wordnode_nr;\n#endif\n    return n;\n}\n\n/*\n * Decrement the reference count on a node (which is the head of a list of\n * siblings).  If the reference count becomes zero free the node and its\n * siblings.\n * Returns the number of nodes actually freed.\n */\n    static int\nderef_wordnode(spellinfo_T *spin, wordnode_T *node)\n{\n    wordnode_T\t*np;\n    int\t\tcnt = 0;\n\n    if (--node->wn_refs == 0)\n    {\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    if (np->wn_child != NULL)\n\t\tcnt += deref_wordnode(spin, np->wn_child);\n\t    free_wordnode(spin, np);\n\t    ++cnt;\n\t}\n\t++cnt;\t    // length field\n    }\n    return cnt;\n}\n\n/*\n * Free a wordnode_T for re-use later.\n * Only the \"wn_child\" field becomes invalid.\n */\n    static void\nfree_wordnode(spellinfo_T *spin, wordnode_T *n)\n{\n    n->wn_child = spin->si_first_free;\n    spin->si_first_free = n;\n    ++spin->si_free_count;\n}\n\n/*\n * Compress a tree: find tails that are identical and can be shared.\n */\n    static void\nwordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name)\n{\n    hashtab_T\t    ht;\n    long\t    n;\n    long\t    tot = 0;\n    long\t    perc;\n\n    // Skip the root itself, it's not actually used.  The first sibling is the\n    // start of the tree.\n    if (root->wn_sibling != NULL)\n    {\n\thash_init(&ht);\n\tn = node_compress(spin, root->wn_sibling, &ht, &tot);\n\n#ifndef SPELL_PRINTTREE\n\tif (spin->si_verbose || p_verbose > 2)\n#endif\n\t{\n\t    if (tot > 1000000)\n\t\tperc = (tot - n) / (tot / 100);\n\t    else if (tot == 0)\n\t\tperc = 0;\n\t    else\n\t\tperc = (tot - n) * 100 / tot;\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t       _(\"Compressed %s: %ld of %ld nodes; %ld (%ld%%) remaining\"),\n\t\t\t\t\t\t       name, n, tot, tot - n, perc);\n\t    spell_message(spin, IObuff);\n\t}\n#ifdef SPELL_PRINTTREE\n\tspell_print_tree(root->wn_sibling);\n#endif\n\thash_clear(&ht);\n    }\n}\n\n/*\n * Compress a node, its siblings and its children, depth first.\n * Returns the number of compressed nodes.\n */\n    static long\nnode_compress(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    hashtab_T\t*ht,\n    long\t*tot)\t    // total count of nodes before compressing,\n\t\t\t    // incremented while going through the tree\n{\n    wordnode_T\t*np;\n    wordnode_T\t*tp;\n    wordnode_T\t*child;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    long\tlen = 0;\n    unsigned\tnr, n;\n    long\tcompressed = 0;\n\n    /*\n     * Go through the list of siblings.  Compress each child and then try\n     * finding an identical child to replace it.\n     * Note that with \"child\" we mean not just the node that is pointed to,\n     * but the whole list of siblings of which the child node is the first.\n     */\n    for (np = node; np != NULL && !got_int; np = np->wn_sibling)\n    {\n\t++len;\n\tif ((child = np->wn_child) != NULL)\n\t{\n\t    // Compress the child first.  This fills hashkey.\n\t    compressed += node_compress(spin, child, ht, tot);\n\n\t    // Try to find an identical child.\n\t    hash = hash_hash(child->wn_u1.hashkey);\n\t    hi = hash_lookup(ht, child->wn_u1.hashkey, hash);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// There are children we encountered before with a hash value\n\t\t// identical to the current child.  Now check if there is one\n\t\t// that is really identical.\n\t\tfor (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)\n\t\t    if (node_equal(child, tp))\n\t\t    {\n\t\t\t// Found one!  Now use that child in place of the\n\t\t\t// current one.  This means the current child and all\n\t\t\t// its siblings is unlinked from the tree.\n\t\t\t++tp->wn_refs;\n\t\t\tcompressed += deref_wordnode(spin, child);\n\t\t\tnp->wn_child = tp;\n\t\t\tbreak;\n\t\t    }\n\t\tif (tp == NULL)\n\t\t{\n\t\t    // No other child with this hash value equals the child of\n\t\t    // the node, add it to the linked list after the first\n\t\t    // item.\n\t\t    tp = HI2WN(hi);\n\t\t    child->wn_u2.next = tp->wn_u2.next;\n\t\t    tp->wn_u2.next = child;\n\t\t}\n\t    }\n\t    else\n\t\t// No other child has this hash value, add it to the\n\t\t// hashtable.\n\t\thash_add_item(ht, hi, child->wn_u1.hashkey, hash);\n\t}\n    }\n    *tot += len + 1;\t// add one for the node that stores the length\n\n    /*\n     * Make a hash key for the node and its siblings, so that we can quickly\n     * find a lookalike node.  This must be done after compressing the sibling\n     * list, otherwise the hash key would become invalid by the compression.\n     */\n    node->wn_u1.hashkey[0] = len;\n    nr = 0;\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == NUL)\n\t    // end node: use wn_flags, wn_region and wn_affixID\n\t    n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);\n\telse\n\t    // byte node: use the byte value and the child pointer\n\t    n = (unsigned)(np->wn_byte + ((long_u)np->wn_child << 8));\n\tnr = nr * 101 + n;\n    }\n\n    // Avoid NUL bytes, it terminates the hash key.\n    n = nr & 0xff;\n    node->wn_u1.hashkey[1] = n == 0 ? 1 : n;\n    n = (nr >> 8) & 0xff;\n    node->wn_u1.hashkey[2] = n == 0 ? 1 : n;\n    n = (nr >> 16) & 0xff;\n    node->wn_u1.hashkey[3] = n == 0 ? 1 : n;\n    n = (nr >> 24) & 0xff;\n    node->wn_u1.hashkey[4] = n == 0 ? 1 : n;\n    node->wn_u1.hashkey[5] = NUL;\n\n    // Check for CTRL-C pressed now and then.\n    veryfast_breakcheck();\n\n    return compressed;\n}\n\n/*\n * Return TRUE when two nodes have identical siblings and children.\n */\n    static int\nnode_equal(wordnode_T *n1, wordnode_T *n2)\n{\n    wordnode_T\t*p1;\n    wordnode_T\t*p2;\n\n    for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;\n\t\t\t\t     p1 = p1->wn_sibling, p2 = p2->wn_sibling)\n\tif (p1->wn_byte != p2->wn_byte\n\t\t|| (p1->wn_byte == NUL\n\t\t    ? (p1->wn_flags != p2->wn_flags\n\t\t\t|| p1->wn_region != p2->wn_region\n\t\t\t|| p1->wn_affixID != p2->wn_affixID)\n\t\t    : (p1->wn_child != p2->wn_child)))\n\t    break;\n\n    return p1 == NULL && p2 == NULL;\n}\n\nstatic int rep_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the REP items on \"from\" string.\n */\n    static int\nrep_compare(const void *s1, const void *s2)\n{\n    fromto_T\t*p1 = (fromto_T *)s1;\n    fromto_T\t*p2 = (fromto_T *)s2;\n\n    return STRCMP(p1->ft_from, p2->ft_from);\n}\n\n/*\n * Write the Vim .spl file \"fname\".\n * Return FAIL or OK;\n */\n    static int\nwrite_vim_spell(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    int\t\tregionmask;\n    int\t\tround;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\ti;\n    int\t\tl;\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    char_u\t*p;\n    int\t\trr;\n    int\t\tretval = OK;\n    size_t\tfwv = 1;  // collect return value of fwrite() to avoid\n\t\t\t  // warnings from picky compiler\n\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // <HEADER>: <fileID> <versionnr>\n\t\t\t\t\t\t\t    // <fileID>\n    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);\n    if (fwv != (size_t)1)\n\t// Catch first write error, don't try writing more.\n\tgoto theend;\n\n    putc(VIMSPELLVERSION, fd);\t\t\t\t    // <versionnr>\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     */\n\n    // SN_INFO: <infotext>\n    if (spin->si_info != NULL)\n    {\n\tputc(SN_INFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_info);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); // <infotext>\n    }\n\n    // SN_REGION: <regionname> ...\n    // Write the region names only if there is more than one.\n    if (spin->si_region_count > 1)\n    {\n\tputc(SN_REGION, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\tl = spin->si_region_count * 2;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <regionname> ...\n\tregionmask = (1 << spin->si_region_count) - 1;\n    }\n    else\n\tregionmask = 0;\n\n    // SN_CHARFLAGS: <charflagslen> <charflags> <folcharslen> <folchars>\n    //\n    // The table with character flags and the table for case folding.\n    // This makes sure the same characters are recognized as word characters\n    // when generating and when using a spell file.\n    // Skip this for ASCII, the table may conflict with the one used for\n    // 'encoding'.\n    // Also skip this for an .add.spl file, the main spell file must contain\n    // the table (avoids that it conflicts).  File is shorter too.\n    if (!spin->si_ascii && !spin->si_add)\n    {\n\tchar_u\tfolchars[128 * 8];\n\tint\tflags;\n\n\tputc(SN_CHARFLAGS, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\t// Form the <folchars> string first, we need to know its length.\n\tl = 0;\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tl += mb_char2bytes(spelltab.st_fold[i], folchars + l);\n\t    else\n\t\tfolchars[l++] = spelltab.st_fold[i];\n\t}\n\tput_bytes(fd, (long_u)(1 + 128 + 2 + l), 4);\t// <sectionlen>\n\n\tfputc(128, fd);\t\t\t\t\t// <charflagslen>\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    flags = 0;\n\t    if (spelltab.st_isw[i])\n\t\tflags |= CF_WORD;\n\t    if (spelltab.st_isu[i])\n\t\tflags |= CF_UPPER;\n\t    fputc(flags, fd);\t\t\t\t// <charflags>\n\t}\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <folcharslen>\n\tfwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); // <folchars>\n    }\n\n    // SN_MIDWORD: <midword>\n    if (spin->si_midword != NULL)\n    {\n\tputc(SN_MIDWORD, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_midword);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);\n\t\t\t\t\t\t\t// <midword>\n    }\n\n    // SN_PREFCOND: <prefcondcnt> <prefcond> ...\n    if (spin->si_prefcond.ga_len > 0)\n    {\n\tputc(SN_PREFCOND, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\tl = write_spell_prefcond(NULL, &spin->si_prefcond, &fwv);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\twrite_spell_prefcond(fd, &spin->si_prefcond, &fwv);\n    }\n\n    // SN_REP: <repcount> <rep> ...\n    // SN_SAL: <salflags> <salcount> <sal> ...\n    // SN_REPSAL: <repcount> <rep> ...\n\n    // round 1: SN_REP section\n    // round 2: SN_SAL section (unless SN_SOFO is used)\n    // round 3: SN_REPSAL section\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    gap = &spin->si_rep;\n\telse if (round == 2)\n\t{\n\t    // Don't write SN_SAL when using a SN_SOFO section\n\t    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n\t\tcontinue;\n\t    gap = &spin->si_sal;\n\t}\n\telse\n\t    gap = &spin->si_repsal;\n\n\t// Don't write the section if there are no items.\n\tif (gap->ga_len == 0)\n\t    continue;\n\n\t// Sort the REP/REPSAL items.\n\tif (round != 2)\n\t    qsort(gap->ga_data, (size_t)gap->ga_len,\n\t\t\t\t\t       sizeof(fromto_T), rep_compare);\n\n\ti = round == 1 ? SN_REP : (round == 2 ? SN_SAL : SN_REPSAL);\n\tputc(i, fd);\t\t\t\t\t// <sectionID>\n\n\t// This is for making suggestions, section is not required.\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// Compute the length of what follows.\n\tl = 2;\t    // count <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    l += 1 + (int)STRLEN(ftp->ft_from);  // count <*fromlen> and <*from>\n\t    l += 1 + (int)STRLEN(ftp->ft_to);    // count <*tolen> and <*to>\n\t}\n\tif (round == 2)\n\t    ++l;\t// count <salflags>\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\tif (round == 2)\n\t{\n\t    i = 0;\n\t    if (spin->si_followup)\n\t\ti |= SAL_F0LLOWUP;\n\t    if (spin->si_collapse)\n\t\ti |= SAL_COLLAPSE;\n\t    if (spin->si_rem_accents)\n\t\ti |= SAL_REM_ACCENTS;\n\t    putc(i, fd);\t\t\t// <salflags>\n\t}\n\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t// <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n\t    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    for (rr = 1; rr <= 2; ++rr)\n\t    {\n\t\tp = rr == 1 ? ftp->ft_from : ftp->ft_to;\n\t\tl = (int)STRLEN(p);\n\t\tputc(l, fd);\n\t\tif (l > 0)\n\t\t    fwv &= fwrite(p, l, (size_t)1, fd);\n\t    }\n\t}\n\n    }\n\n    // SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n    // This is for making suggestions, section is not required.\n    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n    {\n\tputc(SN_SOFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_sofofr);\n\tput_bytes(fd, (long_u)(l + STRLEN(spin->si_sofoto) + 4), 4);\n\t\t\t\t\t\t\t// <sectionlen>\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofofromlen>\n\tfwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); // <sofofrom>\n\n\tl = (int)STRLEN(spin->si_sofoto);\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofotolen>\n\tfwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); // <sofoto>\n    }\n\n    // SN_WORDS: <word> ...\n    // This is for making suggestions, section is not required.\n    if (spin->si_commonwords.ht_used > 0)\n    {\n\tputc(SN_WORDS, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// round 1: count the bytes\n\t// round 2: write the bytes\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    int\t\ttodo;\n\t    int\t\tlen = 0;\n\t    hashitem_T\t*hi;\n\n\t    todo = (int)spin->si_commonwords.ht_used;\n\t    for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    l = (int)STRLEN(hi->hi_key) + 1;\n\t\t    len += l;\n\t\t    if (round == 2)\t\t\t// <word>\n\t\t\tfwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);\n\t\t    --todo;\n\t\t}\n\t    if (round == 1)\n\t\tput_bytes(fd, (long_u)len, 4);\t\t// <sectionlen>\n\t}\n    }\n\n    // SN_MAP: <mapstr>\n    // This is for making suggestions, section is not required.\n    if (spin->si_map.ga_len > 0)\n    {\n\tputc(SN_MAP, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tl = spin->si_map.ga_len;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <mapstr>\n    }\n\n    // SN_SUGFILE: <timestamp>\n    // This is used to notify that a .sug file may be available and at the\n    // same time allows for checking that a .sug file that is found matches\n    // with this .spl file.  That's because the word numbers must be exactly\n    // right.\n    if (!spin->si_nosugfile\n\t    && (spin->si_sal.ga_len > 0\n\t\t     || (spin->si_sofofr != NULL && spin->si_sofoto != NULL)))\n    {\n\tputc(SN_SUGFILE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)8, 4);\t\t\t// <sectionlen>\n\n\t// Set si_sugtime and write it to the file.\n\tspin->si_sugtime = time(NULL);\n\tput_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n    }\n\n    // SN_NOSPLITSUGS: nothing\n    // This is used to notify that no suggestions with word splits are to be\n    // made.\n    if (spin->si_nosplitsugs)\n    {\n\tputc(SN_NOSPLITSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_NOCOMPUNDSUGS: nothing\n    // This is used to notify that no suggestions with compounds are to be\n    // made.\n    if (spin->si_nocompoundsugs)\n    {\n\tputc(SN_NOCOMPOUNDSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_COMPOUND: compound info.\n    // We don't mark it required, when not supported all compound words will\n    // be bad words.\n    if (spin->si_compflags != NULL)\n    {\n\tputc(SN_COMPOUND, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_compflags);\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t    l += (int)STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;\n\tput_bytes(fd, (long_u)(l + 7), 4);\t\t// <sectionlen>\n\n\tputc(spin->si_compmax, fd);\t\t\t// <compmax>\n\tputc(spin->si_compminlen, fd);\t\t\t// <compminlen>\n\tputc(spin->si_compsylmax, fd);\t\t\t// <compsylmax>\n\tputc(0, fd);\t\t// for Vim 7.0b compatibility\n\tputc(spin->si_compoptions, fd);\t\t\t// <compoptions>\n\tput_bytes(fd, (long_u)spin->si_comppat.ga_len, 2);\n\t\t\t\t\t\t\t// <comppatcount>\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t{\n\t    p = ((char_u **)(spin->si_comppat.ga_data))[i];\n\t    putc((int)STRLEN(p), fd);\t\t\t// <comppatlen>\n\t    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);\n\t\t\t\t\t\t\t// <comppattext>\n\t}\n\t\t\t\t\t\t\t// <compflags>\n\tfwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),\n\t\t\t\t\t\t\t       (size_t)1, fd);\n    }\n\n    // SN_NOBREAK: NOBREAK flag\n    if (spin->si_nobreak)\n    {\n\tputc(SN_NOBREAK, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// It's empty, the presence of the section flags the feature.\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_SYLLABLE: syllable info.\n    // We don't mark it required, when not supported syllables will not be\n    // counted.\n    if (spin->si_syllable != NULL)\n    {\n\tputc(SN_SYLLABLE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_syllable);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <syllable>\n    }\n\n    // end of <SECTIONS>\n    putc(SN_END, fd);\t\t\t\t\t// <sectionend>\n\n\n    /*\n     * <LWORDTREE>  <KWORDTREE>  <PREFIXTREE>\n     */\n    spin->si_memtot = 0;\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    tree = spin->si_foldroot->wn_sibling;\n\telse if (round == 2)\n\t    tree = spin->si_keeproot->wn_sibling;\n\telse\n\t    tree = spin->si_prefroot->wn_sibling;\n\n\t// Clear the index and wnode fields in the tree.\n\tclear_node(tree);\n\n\t// Count the number of nodes.  Needed to be able to allocate the\n\t// memory when reading the nodes.  Also fills in index for shared\n\t// nodes.\n\tnodecount = put_node(NULL, tree, 0, regionmask, round == 3);\n\n\t// number of nodes in 4 bytes\n\tput_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n\tspin->si_memtot += nodecount + nodecount * sizeof(int);\n\n\t// Write the nodes.\n\t(void)put_node(fd, tree, 0, regionmask, round == 3);\n    }\n\n    // Write another byte to check for errors (file system full).\n    if (putc(0, fd) == EOF)\n\tretval = FAIL;\ntheend:\n    if (fclose(fd) == EOF)\n\tretval = FAIL;\n\n    if (fwv != (size_t)1)\n\tretval = FAIL;\n    if (retval == FAIL)\n\temsg(_(e_error_while_writing));\n\n    return retval;\n}\n\n/*\n * Clear the index and wnode fields of \"node\", it siblings and its\n * children.  This is needed because they are a union with other items to save\n * space.\n */\n    static void\nclear_node(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    if (node != NULL)\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    np->wn_u1.index = 0;\n\t    np->wn_u2.wnode = NULL;\n\n\t    if (np->wn_byte != NUL)\n\t\tclear_node(np->wn_child);\n\t}\n}\n\n\n/*\n * Dump a word tree at node \"node\".\n *\n * This first writes the list of possible bytes (siblings).  Then for each\n * byte recursively write the children.\n *\n * NOTE: The code here must match the code in read_tree_node(), since\n * assumptions are made about the indexes (so that we don't have to write them\n * in the file).\n *\n * Returns the number of nodes used.\n */\n    static int\nput_node(\n    FILE\t*fd,\t\t// NULL when only counting\n    wordnode_T\t*node,\n    int\t\tidx,\n    int\t\tregionmask,\n    int\t\tprefixtree)\t// TRUE for PREFIXTREE\n{\n    int\t\tnewindex = idx;\n    int\t\tsiblingcount = 0;\n    wordnode_T\t*np;\n    int\t\tflags;\n\n    // If \"node\" is zero the tree is empty.\n    if (node == NULL)\n\treturn 0;\n\n    // Store the index where this node is written.\n    node->wn_u1.index = idx;\n\n    // Count the number of siblings.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\t++siblingcount;\n\n    // Write the sibling count.\n    if (fd != NULL)\n\tputc(siblingcount, fd);\t\t\t\t// <siblingcount>\n\n    // Write each sibling byte and optionally extra info.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == 0)\n\t{\n\t    if (fd != NULL)\n\t    {\n\t\t// For a NUL byte (end of word) write the flags etc.\n\t\tif (prefixtree)\n\t\t{\n\t\t    // In PREFIXTREE write the required affixID and the\n\t\t    // associated condition nr (stored in wn_region).  The\n\t\t    // byte value is misused to store the \"rare\" and \"not\n\t\t    // combining\" flags\n\t\t    if (np->wn_flags == (short_u)PFX_FLAGS)\n\t\t\tputc(BY_NOFLAGS, fd);\t\t// <byte>\n\t\t    else\n\t\t    {\n\t\t\tputc(BY_FLAGS, fd);\t\t// <byte>\n\t\t\tputc(np->wn_flags, fd);\t\t// <pflags>\n\t\t    }\n\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    put_bytes(fd, (long_u)np->wn_region, 2); // <prefcondnr>\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For word trees we write the flag/region items.\n\t\t    flags = np->wn_flags;\n\t\t    if (regionmask != 0 && np->wn_region != regionmask)\n\t\t\tflags |= WF_REGION;\n\t\t    if (np->wn_affixID != 0)\n\t\t\tflags |= WF_AFX;\n\t\t    if (flags == 0)\n\t\t    {\n\t\t\t// word without flags or region\n\t\t\tputc(BY_NOFLAGS, fd);\t\t\t// <byte>\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (np->wn_flags >= 0x100)\n\t\t\t{\n\t\t\t    putc(BY_FLAGS2, fd);\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t    putc((unsigned)flags >> 8, fd);\t// <flags2>\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    putc(BY_FLAGS, fd);\t\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t}\n\t\t\tif (flags & WF_REGION)\n\t\t\t    putc(np->wn_region, fd);\t\t// <region>\n\t\t\tif (flags & WF_AFX)\n\t\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if (np->wn_child->wn_u1.index != 0\n\t\t\t\t\t && np->wn_child->wn_u2.wnode != node)\n\t    {\n\t\t// The child is written elsewhere, write the reference.\n\t\tif (fd != NULL)\n\t\t{\n\t\t    putc(BY_INDEX, fd);\t\t\t// <byte>\n\t\t\t\t\t\t\t// <nodeidx>\n\t\t    put_bytes(fd, (long_u)np->wn_child->wn_u1.index, 3);\n\t\t}\n\t    }\n\t    else if (np->wn_child->wn_u2.wnode == NULL)\n\t\t// We will write the child below and give it an index.\n\t\tnp->wn_child->wn_u2.wnode = node;\n\n\t    if (fd != NULL)\n\t\tif (putc(np->wn_byte, fd) == EOF) // <byte> or <xbyte>\n\t\t{\n\t\t    emsg(_(e_error_while_writing));\n\t\t    return 0;\n\t\t}\n\t}\n    }\n\n    // Space used in the array when reading: one for each sibling and one for\n    // the count.\n    newindex += siblingcount + 1;\n\n    // Recursively dump the children of each sibling.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\tif (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)\n\t    newindex = put_node(fd, np->wn_child, newindex, regionmask,\n\t\t\t\t\t\t\t\t  prefixtree);\n\n    return newindex;\n}\n\n\n/*\n * \":mkspell [-ascii] outfile  infile ...\"\n * \":mkspell [-ascii] addfile\"\n */\n    void\nex_mkspell(exarg_T *eap)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    char_u\t*arg = eap->arg;\n    int\t\tascii = FALSE;\n\n    if (STRNCMP(arg, \"-ascii\", 6) == 0)\n    {\n\tascii = TRUE;\n\targ = skipwhite(arg + 6);\n    }\n\n    // Expand all the remaining arguments (e.g., $VIMRUNTIME).\n    if (get_arglist_exp(arg, &fcount, &fnames, FALSE) == OK)\n    {\n\tmkspell(fcount, fnames, ascii, eap->forceit, FALSE);\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Create the .sug file.\n * Uses the soundfold info in \"spin\".\n * Writes the file with the name \"wfname\", with \".spl\" changed to \".sug\".\n */\n    static void\nspell_make_sugfile(spellinfo_T *spin, char_u *wfname)\n{\n    char_u\t*fname = NULL;\n    int\t\tlen;\n    slang_T\t*slang;\n    int\t\tfree_slang = FALSE;\n\n    /*\n     * Read back the .spl file that was written.  This fills the required\n     * info for soundfolding.  This also uses less memory than the\n     * pointer-linked version of the trie.  And it avoids having two versions\n     * of the code for the soundfolding stuff.\n     * It might have been done already by spell_reload_one().\n     */\n    FOR_ALL_SPELL_LANGS(slang)\n\tif (fullpathcmp(wfname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t    break;\n    if (slang == NULL)\n    {\n\tspell_message(spin, (char_u *)_(\"Reading back spell file...\"));\n\tslang = spell_load_file(wfname, NULL, NULL, FALSE);\n\tif (slang == NULL)\n\t    return;\n\tfree_slang = TRUE;\n    }\n\n    /*\n     * Clear the info in \"spin\" that is used.\n     */\n    spin->si_blocks = NULL;\n    spin->si_blocks_cnt = 0;\n    spin->si_compress_cnt = 0;\t    // will stay at 0 all the time\n    spin->si_free_count = 0;\n    spin->si_first_free = NULL;\n    spin->si_foldwcount = 0;\n\n    /*\n     * Go through the trie of good words, soundfold each word and add it to\n     * the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));\n    if (sug_filltree(spin, slang) == FAIL)\n\tgoto theend;\n\n    /*\n     * Create the table which links each soundfold word with a list of the\n     * good words it may come from.  Creates buffer \"spin->si_spellbuf\".\n     * This also removes the wordnr from the NUL byte entries to make\n     * compression possible.\n     */\n    if (sug_maketable(spin) == FAIL)\n\tgoto theend;\n\n    smsg(_(\"Number of words after soundfolding: %ld\"),\n\t\t\t\t (long)spin->si_spellbuf->b_ml.ml_line_count);\n\n    /*\n     * Compress the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(msg_compressing));\n    wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\n    /*\n     * Write the .sug file.\n     * Make the file name by changing \".spl\" to \".sug\".\n     */\n    fname = alloc(MAXPATHL);\n    if (fname == NULL)\n\tgoto theend;\n    vim_strncpy(fname, wfname, MAXPATHL - 1);\n    len = (int)STRLEN(fname);\n    fname[len - 2] = 'u';\n    fname[len - 1] = 'g';\n    sug_write(spin, fname);\n\ntheend:\n    vim_free(fname);\n    if (free_slang)\n\tslang_free(slang);\n    free_blocks(spin->si_blocks);\n    close_spellbuf(spin->si_spellbuf);\n}\n\n/*\n * Build the soundfold trie for language \"slang\".\n */\n    static int\nsug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}\n\n/*\n * Make the table that links each word in the soundfold trie to the words it\n * can be produced from.\n * This is not unlike lines in a file, thus use a memfile to be able to access\n * the table efficiently.\n * Returns FAIL when out of memory.\n */\n    static int\nsug_maketable(spellinfo_T *spin)\n{\n    garray_T\tga;\n    int\t\tres = OK;\n\n    // Allocate a buffer, open a memline for it and create the swap file\n    // (uses a temp file, not a .swp file).\n    spin->si_spellbuf = open_spellbuf();\n    if (spin->si_spellbuf == NULL)\n\treturn FAIL;\n\n    // Use a buffer to store the line info, avoids allocating many small\n    // pieces of memory.\n    ga_init2(&ga, 1, 100);\n\n    // recursively go through the tree\n    if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)\n\tres = FAIL;\n\n    ga_clear(&ga);\n    return res;\n}\n\n/*\n * Fill the table for one node and its children.\n * Returns the wordnr at the start of the node.\n * Returns -1 when out of memory.\n */\n    static int\nsug_filltable(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    int\t\tstartwordnr,\n    garray_T\t*gap)\t    // place to store line of numbers\n{\n    wordnode_T\t*p, *np;\n    int\t\twordnr = startwordnr;\n    int\t\tnr;\n    int\t\tprev_nr;\n\n    FOR_ALL_NODE_SIBLINGS(node, p)\n    {\n\tif (p->wn_byte == NUL)\n\t{\n\t    gap->ga_len = 0;\n\t    prev_nr = 0;\n\t    for (np = p; np != NULL && np->wn_byte == NUL; np = np->wn_sibling)\n\t    {\n\t\tif (ga_grow(gap, 10) == FAIL)\n\t\t    return -1;\n\n\t\tnr = (np->wn_flags << 16) + (np->wn_region & 0xffff);\n\t\t// Compute the offset from the previous nr and store the\n\t\t// offset in a way that it takes a minimum number of bytes.\n\t\t// It's a bit like utf-8, but without the need to mark\n\t\t// following bytes.\n\t\tnr -= prev_nr;\n\t\tprev_nr += nr;\n\t\tgap->ga_len += offset2bytes(nr,\n\t\t\t\t\t (char_u *)gap->ga_data + gap->ga_len);\n\t    }\n\n\t    // add the NUL byte\n\t    ((char_u *)gap->ga_data)[gap->ga_len++] = NUL;\n\n\t    if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,\n\t\t\t\t     gap->ga_data, gap->ga_len, TRUE) == FAIL)\n\t\treturn -1;\n\t    ++wordnr;\n\n\t    // Remove extra NUL entries, we no longer need them. We don't\n\t    // bother freeing the nodes, they won't be reused anyway.\n\t    while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)\n\t\tp->wn_sibling = p->wn_sibling->wn_sibling;\n\n\t    // Clear the flags on the remaining NUL node, so that compression\n\t    // works a lot better.\n\t    p->wn_flags = 0;\n\t    p->wn_region = 0;\n\t}\n\telse\n\t{\n\t    wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);\n\t    if (wordnr == -1)\n\t\treturn -1;\n\t}\n    }\n    return wordnr;\n}\n\n/*\n * Convert an offset into a minimal number of bytes.\n * Similar to utf_char2byters, but use 8 bits in followup bytes and avoid NUL\n * bytes.\n */\n    static int\noffset2bytes(int nr, char_u *buf)\n{\n    int\t    rem;\n    int\t    b1, b2, b3, b4;\n\n    // Split the number in parts of base 255.  We need to avoid NUL bytes.\n    b1 = nr % 255 + 1;\n    rem = nr / 255;\n    b2 = rem % 255 + 1;\n    rem = rem / 255;\n    b3 = rem % 255 + 1;\n    b4 = rem / 255 + 1;\n\n    if (b4 > 1 || b3 > 0x1f)\t// 4 bytes\n    {\n\tbuf[0] = 0xe0 + b4;\n\tbuf[1] = b3;\n\tbuf[2] = b2;\n\tbuf[3] = b1;\n\treturn 4;\n    }\n    if (b3 > 1 || b2 > 0x3f )\t// 3 bytes\n    {\n\tbuf[0] = 0xc0 + b3;\n\tbuf[1] = b2;\n\tbuf[2] = b1;\n\treturn 3;\n    }\n    if (b2 > 1 || b1 > 0x7f )\t// 2 bytes\n    {\n\tbuf[0] = 0x80 + b2;\n\tbuf[1] = b1;\n\treturn 2;\n    }\n\t\t\t\t// 1 byte\n    buf[0] = b1;\n    return 1;\n}\n\n/*\n * Write the .sug file in \"fname\".\n */\n    static void\nsug_write(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\twcount;\n    char_u\t*line;\n    linenr_T\tlnum;\n    int\t\tlen;\n\n    // Create the file.  Note that an existing file is silently overwritten!\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Writing suggestion file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n     */\n    if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) // <fileID>\n    {\n\temsg(_(e_error_while_writing));\n\tgoto theend;\n    }\n    putc(VIMSUGVERSION, fd);\t\t\t\t// <versionnr>\n\n    // Write si_sugtime to the file.\n    put_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n\n    /*\n     * <SUGWORDTREE>\n     */\n    spin->si_memtot = 0;\n    tree = spin->si_foldroot->wn_sibling;\n\n    // Clear the index and wnode fields in the tree.\n    clear_node(tree);\n\n    // Count the number of nodes.  Needed to be able to allocate the\n    // memory when reading the nodes.  Also fills in index for shared\n    // nodes.\n    nodecount = put_node(NULL, tree, 0, 0, FALSE);\n\n    // number of nodes in 4 bytes\n    put_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n    spin->si_memtot += nodecount + nodecount * sizeof(int);\n\n    // Write the nodes.\n    (void)put_node(fd, tree, 0, 0, FALSE);\n\n    /*\n     * <SUGTABLE>: <sugwcount> <sugline> ...\n     */\n    wcount = spin->si_spellbuf->b_ml.ml_line_count;\n    put_bytes(fd, (long_u)wcount, 4);\t// <sugwcount>\n\n    for (lnum = 1; lnum <= (linenr_T)wcount; ++lnum)\n    {\n\t// <sugline>: <sugnr> ... NUL\n\tline = ml_get_buf(spin->si_spellbuf, lnum, FALSE);\n\tlen = (int)STRLEN(line) + 1;\n\tif (fwrite(line, (size_t)len, (size_t)1, fd) == 0)\n\t{\n\t    emsg(_(e_error_while_writing));\n\t    goto theend;\n\t}\n\tspin->si_memtot += len;\n    }\n\n    // Write another byte to check for errors.\n    if (putc(0, fd) == EOF)\n\temsg(_(e_error_while_writing));\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);\n    spell_message(spin, IObuff);\n\ntheend:\n    // close the file\n    fclose(fd);\n}\n\n\n/*\n * Create a Vim spell file from one or more word lists.\n * \"fnames[0]\" is the output file name.\n * \"fnames[fcount - 1]\" is the last input file name.\n * Exception: when \"fnames[0]\" ends in \".add\" it's used as the input file name\n * and \".spl\" is appended to make the output file name.\n */\n    void\nmkspell(\n    int\t\tfcount,\n    char_u\t**fnames,\n    int\t\tascii,\t\t    // -ascii argument given\n    int\t\tover_write,\t    // overwrite existing output file\n    int\t\tadded_word)\t    // invoked through \"zg\"\n{\n    char_u\t*fname = NULL;\n    char_u\t*wfname;\n    char_u\t**innames;\n    int\t\tincount;\n    afffile_T\t*(afile[MAXREGIONS]);\n    int\t\ti;\n    int\t\tlen;\n    stat_T\tst;\n    int\t\terror = FALSE;\n    spellinfo_T spin;\n\n    CLEAR_FIELD(spin);\n    spin.si_verbose = !added_word;\n    spin.si_ascii = ascii;\n    spin.si_followup = TRUE;\n    spin.si_rem_accents = TRUE;\n    ga_init2(&spin.si_rep, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_repsal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_sal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_map, sizeof(char_u), 100);\n    ga_init2(&spin.si_comppat, sizeof(char_u *), 20);\n    ga_init2(&spin.si_prefcond, sizeof(char_u *), 50);\n    hash_init(&spin.si_commonwords);\n    spin.si_newcompID = 127;\t// start compound ID at first maximum\n\n    // default: fnames[0] is output file, following are input files\n    // When \"fcount\" is 1 there is only one file.\n    innames = &fnames[fcount == 1 ? 0 : 1];\n    incount = fcount - 1;\n\n    wfname = alloc(MAXPATHL);\n    if (wfname == NULL)\n\treturn;\n\n    if (fcount >= 1)\n    {\n\tlen = (int)STRLEN(fnames[0]);\n\tif (fcount == 1 && len > 4 && STRCMP(fnames[0] + len - 4, \".add\") == 0)\n\t{\n\t    // For \":mkspell path/en.latin1.add\" output file is\n\t    // \"path/en.latin1.add.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, \"%s.spl\", fnames[0]);\n\t}\n\telse if (fcount == 1)\n\t{\n\t    // For \":mkspell path/vim\" output file is \"path/vim.latin1.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\t}\n\telse if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)\n\t{\n\t    // Name ends in \".spl\", use as the file name.\n\t    vim_strncpy(wfname, fnames[0], MAXPATHL - 1);\n\t}\n\telse\n\t    // Name should be language, make the file name from it.\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\n\t// Check for .ascii.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)\n\t    spin.si_ascii = TRUE;\n\n\t// Check for .add.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)\n\t    spin.si_add = TRUE;\n    }\n\n    if (incount <= 0)\n\temsg(_(e_invalid_argument));\t// need at least output and input names\n    else if (vim_strchr(gettail(wfname), '_') != NULL)\n\temsg(_(e_output_file_name_must_not_have_region_name));\n    else if (incount > MAXREGIONS)\n\tsemsg(_(e_only_up_to_nr_regions_supported), MAXREGIONS);\n    else\n    {\n\t// Check for overwriting before doing things that may take a lot of\n\t// time.\n\tif (!over_write && mch_stat((char *)wfname, &st) >= 0)\n\t{\n\t    emsg(_(e_file_exists));\n\t    goto theend;\n\t}\n\tif (mch_isdir(wfname))\n\t{\n\t    semsg(_(e_str_is_directory), wfname);\n\t    goto theend;\n\t}\n\n\tfname = alloc(MAXPATHL);\n\tif (fname == NULL)\n\t    goto theend;\n\n\t/*\n\t * Init the aff and dic pointers.\n\t * Get the region names if there are more than 2 arguments.\n\t */\n\tfor (i = 0; i < incount; ++i)\n\t{\n\t    afile[i] = NULL;\n\n\t    if (incount > 1)\n\t    {\n\t\tlen = (int)STRLEN(innames[i]);\n\t\tif (STRLEN(gettail(innames[i])) < 5\n\t\t\t\t\t\t|| innames[i][len - 3] != '_')\n\t\t{\n\t\t    semsg(_(e_invalid_region_in_str), innames[i]);\n\t\t    goto theend;\n\t\t}\n\t\tspin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);\n\t\tspin.si_region_name[i * 2 + 1] =\n\t\t\t\t\t     TOLOWER_ASC(innames[i][len - 1]);\n\t    }\n\t}\n\tspin.si_region_count = incount;\n\n\tspin.si_foldroot = wordtree_alloc(&spin);\n\tspin.si_keeproot = wordtree_alloc(&spin);\n\tspin.si_prefroot = wordtree_alloc(&spin);\n\tif (spin.si_foldroot == NULL\n\t\t|| spin.si_keeproot == NULL\n\t\t|| spin.si_prefroot == NULL)\n\t{\n\t    free_blocks(spin.si_blocks);\n\t    goto theend;\n\t}\n\n\t// When not producing a .add.spl file clear the character table when\n\t// we encounter one in the .aff file.  This means we dump the current\n\t// one in the .spl file if the .aff file doesn't define one.  That's\n\t// better than guessing the contents, the table will match a\n\t// previously loaded spell file.\n\tif (!spin.si_add)\n\t    spin.si_clear_chartab = TRUE;\n\n\t/*\n\t * Read all the .aff and .dic files.\n\t * Text is converted to 'encoding'.\n\t * Words are stored in the case-folded and keep-case trees.\n\t */\n\tfor (i = 0; i < incount && !error; ++i)\n\t{\n\t    spin.si_conv.vc_type = CONV_NONE;\n\t    spin.si_region = 1 << i;\n\n\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.aff\", innames[i]);\n\t    if (mch_stat((char *)fname, &st) >= 0)\n\t    {\n\t\t// Read the .aff file.  Will init \"spin->si_conv\" based on the\n\t\t// \"SET\" line.\n\t\tafile[i] = spell_read_aff(&spin, fname);\n\t\tif (afile[i] == NULL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // Read the .dic file and store the words in the trees.\n\t\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",\n\t\t\t\t\t\t\t\t  innames[i]);\n\t\t    if (spell_read_dic(&spin, fname, afile[i]) == FAIL)\n\t\t\terror = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// No .aff file, try reading the file as a word list.  Store\n\t\t// the words in the trees.\n\t\tif (spell_read_wordfile(&spin, innames[i]) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\n\t    // Free any conversion stuff.\n\t    convert_setup(&spin.si_conv, NULL, NULL);\n\t}\n\n\tif (spin.si_compflags != NULL && spin.si_nobreak)\n\t    msg(_(\"Warning: both compounding and NOBREAK specified\"));\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Combine tails in the tree.\n\t     */\n\t    spell_message(&spin, (char_u *)_(msg_compressing));\n\t    wordtree_compress(&spin, spin.si_foldroot, \"case-folded\");\n\t    wordtree_compress(&spin, spin.si_keeproot, \"keep-case\");\n\t    wordtree_compress(&spin, spin.si_prefroot, \"prefixes\");\n\t}\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Write the info in the spell file.\n\t     */\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t      _(\"Writing spell file %s...\"), wfname);\n\t    spell_message(&spin, IObuff);\n\n\t    error = write_vim_spell(&spin, wfname) == FAIL;\n\n\t    spell_message(&spin, (char_u *)_(\"Done!\"));\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);\n\t    spell_message(&spin, IObuff);\n\n\t    /*\n\t     * If the file is loaded need to reload it.\n\t     */\n\t    if (!error)\n\t\tspell_reload_one(wfname, added_word);\n\t}\n\n\t// Free the allocated memory.\n\tga_clear(&spin.si_rep);\n\tga_clear(&spin.si_repsal);\n\tga_clear(&spin.si_sal);\n\tga_clear(&spin.si_map);\n\tga_clear(&spin.si_comppat);\n\tga_clear(&spin.si_prefcond);\n\thash_clear_all(&spin.si_commonwords, 0);\n\n\t// Free the .aff file structures.\n\tfor (i = 0; i < incount; ++i)\n\t    if (afile[i] != NULL)\n\t\tspell_free_aff(afile[i]);\n\n\t// Free all the bits and pieces at once.\n\tfree_blocks(spin.si_blocks);\n\n\t/*\n\t * If there is soundfolding info and no NOSUGFILE item create the\n\t * .sug file with the soundfolded word trie.\n\t */\n\tif (spin.si_sugtime != 0 && !error && !got_int)\n\t    spell_make_sugfile(&spin, wfname);\n\n    }\n\ntheend:\n    vim_free(fname);\n    vim_free(wfname);\n}\n\n/*\n * Display a message for spell file processing when 'verbose' is set or using\n * \":mkspell\".  \"str\" can be IObuff.\n */\n    static void\nspell_message(spellinfo_T *spin, char_u *str)\n{\n    if (spin->si_verbose || p_verbose > 2)\n    {\n\tif (!spin->si_verbose)\n\t    verbose_enter();\n\tmsg((char *)str);\n\tout_flush();\n\tif (!spin->si_verbose)\n\t    verbose_leave();\n    }\n}\n\n/*\n * \":[count]spellgood  {word}\"\n * \":[count]spellwrong {word}\"\n * \":[count]spellundo  {word}\"\n * \":[count]spellrare  {word}\"\n */\n    void\nex_spell(exarg_T *eap)\n{\n    spell_add_word(eap->arg, (int)STRLEN(eap->arg),\n\t\teap->cmdidx == CMD_spellwrong ? SPELL_ADD_BAD :\n\t\teap->cmdidx == CMD_spellrare ? SPELL_ADD_RARE : SPELL_ADD_GOOD,\n\t\t\t\t   eap->forceit ? 0 : (int)eap->line2,\n\t\t\t\t   eap->cmdidx == CMD_spellundo);\n}\n\n/*\n * Add \"word[len]\" to 'spellfile' as a good, rare or bad word.\n */\n    void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n    {\n\temsg(_(e_illegal_character_in_word));\n\treturn;\n    }\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}\n\n/*\n * Initialize 'spellfile' for the current buffer.\n */\n    static void\ninit_spellfile(void)\n{\n    char_u\t*buf;\n    int\t\tl;\n    char_u\t*fname;\n    char_u\t*rtp;\n    char_u\t*lend;\n    int\t\taspath = FALSE;\n    char_u\t*lstart = curbuf->b_s.b_p_spl;\n\n    if (*curwin->w_s->b_p_spl != NUL && curwin->w_s->b_langp.ga_len > 0)\n    {\n\tbuf = alloc(MAXPATHL);\n\tif (buf == NULL)\n\t    return;\n\n\t// Find the end of the language name.  Exclude the region.  If there\n\t// is a path separator remember the start of the tail.\n\tfor (lend = curwin->w_s->b_p_spl; *lend != NUL\n\t\t\t&& vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)\n\t    if (vim_ispathsep(*lend))\n\t    {\n\t\taspath = TRUE;\n\t\tlstart = lend + 1;\n\t    }\n\n\t// Loop over all entries in 'runtimepath'.  Use the first one where we\n\t// are allowed to write.\n\trtp = p_rtp;\n\twhile (*rtp != NUL)\n\t{\n\t    if (aspath)\n\t\t// Use directory of an entry with path, e.g., for\n\t\t// \"/dir/lg.utf-8.spl\" use \"/dir\".\n\t\tvim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t    lstart - curbuf->b_s.b_p_spl - 1);\n\t    else\n\t\t// Copy the path from 'runtimepath' to buf[].\n\t\tcopy_option_part(&rtp, buf, MAXPATHL, \",\");\n\t    if (filewritable(buf) == 2)\n\t    {\n\t\t// Use the first language name from 'spelllang' and the\n\t\t// encoding used in the first loaded .spl file.\n\t\tif (aspath)\n\t\t    vim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t\t  lend - curbuf->b_s.b_p_spl);\n\t\telse\n\t\t{\n\t\t    // Create the \"spell\" directory if it doesn't exist yet.\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l, \"/spell\");\n\t\t    if (filewritable(buf) != 2)\n\t\t\tvim_mkdir(buf, 0755);\n\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l,\n\t\t\t\t \"/%.*s\", (int)(lend - lstart), lstart);\n\t\t}\n\t\tl = (int)STRLEN(buf);\n\t\tfname = LANGP_ENTRY(curwin->w_s->b_langp, 0)\n\t\t\t\t\t\t\t ->lp_slang->sl_fname;\n\t\tvim_snprintf((char *)buf + l, MAXPATHL - l, \".%s.add\",\n\t\t\tfname != NULL\n\t\t\t  && strstr((char *)gettail(fname), \".ascii.\") != NULL\n\t\t\t\t       ? (char_u *)\"ascii\" : spell_enc());\n\t\tset_option_value_give_err((char_u *)\"spellfile\",\n\t\t\t\t\t\t\t   0L, buf, OPT_LOCAL);\n\t\tbreak;\n\t    }\n\t    aspath = FALSE;\n\t}\n\n\tvim_free(buf);\n    }\n}\n\n\n\n/*\n * Set the spell character tables from strings in the affix file.\n */\n    static int\nset_spell_chartab(char_u *fol, char_u *low, char_u *upp)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    char_u\t*pf = fol, *pl = low, *pu = upp;\n    int\t\tf, l, u;\n\n    clear_spell_chartab(&new_st);\n\n    while (*pf != NUL)\n    {\n\tif (*pl == NUL || *pu == NUL)\n\t{\n\t    emsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\t    return FAIL;\n\t}\n\tf = mb_ptr2char_adv(&pf);\n\tl = mb_ptr2char_adv(&pl);\n\tu = mb_ptr2char_adv(&pu);\n\n\t// Every character that appears is a word character.\n\tif (f < 256)\n\t    new_st.st_isw[f] = TRUE;\n\tif (l < 256)\n\t    new_st.st_isw[l] = TRUE;\n\tif (u < 256)\n\t    new_st.st_isw[u] = TRUE;\n\n\t// if \"LOW\" and \"FOL\" are not the same the \"LOW\" char needs\n\t// case-folding\n\tif (l < 256 && l != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[l] = f;\n\t}\n\n\t// if \"UPP\" and \"FOL\" are not the same the \"UPP\" char needs\n\t// case-folding, it's upper case and the \"UPP\" is the upper case of\n\t// \"FOL\" .\n\tif (u < 256 && u != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[u] = f;\n\t    new_st.st_isu[u] = TRUE;\n\t    new_st.st_upper[f] = u;\n\t}\n    }\n\n    if (*pl != NUL || *pu != NUL)\n    {\n\temsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\treturn FAIL;\n    }\n\n    return set_spell_finish(&new_st);\n}\n\n/*\n * Set the spell character tables from strings in the .spl file.\n */\n    static void\nset_spell_charflags(\n    char_u\t*flags,\n    int\t\tcnt,\t    // length of \"flags\"\n    char_u\t*fol)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    int\t\ti;\n    char_u\t*p = fol;\n    int\t\tc;\n\n    clear_spell_chartab(&new_st);\n\n    for (i = 0; i < 128; ++i)\n    {\n\tif (i < cnt)\n\t{\n\t    new_st.st_isw[i + 128] = (flags[i] & CF_WORD) != 0;\n\t    new_st.st_isu[i + 128] = (flags[i] & CF_UPPER) != 0;\n\t}\n\n\tif (*p != NUL)\n\t{\n\t    c = mb_ptr2char_adv(&p);\n\t    new_st.st_fold[i + 128] = c;\n\t    if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)\n\t\tnew_st.st_upper[c] = i + 128;\n\t}\n    }\n\n    (void)set_spell_finish(&new_st);\n}\n\n    static int\nset_spell_finish(spelltab_T *new_st)\n{\n    int\t\ti;\n\n    if (did_set_spelltab)\n    {\n\t// check that it's the same table\n\tfor (i = 0; i < 256; ++i)\n\t{\n\t    if (spelltab.st_isw[i] != new_st->st_isw[i]\n\t\t    || spelltab.st_isu[i] != new_st->st_isu[i]\n\t\t    || spelltab.st_fold[i] != new_st->st_fold[i]\n\t\t    || spelltab.st_upper[i] != new_st->st_upper[i])\n\t    {\n\t\temsg(_(e_word_characters_differ_between_spell_files));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// copy the new spelltab into the one being used\n\tspelltab = *new_st;\n\tdid_set_spelltab = TRUE;\n    }\n\n    return OK;\n}\n\n/*\n * Write the table with prefix conditions to the .spl file.\n * When \"fd\" is NULL only count the length of what is written and return it.\n */\n    static int\nwrite_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv)\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ttotlen;\n\n    if (fd != NULL)\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t    // <prefcondcnt>\n\n    totlen = 2 + gap->ga_len; // length of <prefcondcnt> and <condlen> bytes\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tp = ((char_u **)gap->ga_data)[i];\n\tif (p != NULL)\n\t{\n\t    len = (int)STRLEN(p);\n\t    if (fd != NULL)\n\t    {\n\t\tfputc(len, fd);\n\t\t*fwv &= fwrite(p, (size_t)len, (size_t)1, fd);\n\t    }\n\t    totlen += len;\n\t}\n\telse if (fd != NULL)\n\t    fputc(0, fd);\n    }\n\n    return totlen;\n}\n\n/*\n * Use map string \"map\" for languages \"lp\".\n */\n    static void\nset_map_str(slang_T *lp, char_u *map)\n{\n    char_u\t*p;\n    int\t\theadc = 0;\n    int\t\tc;\n    int\t\ti;\n\n    if (*map == NUL)\n    {\n\tlp->sl_has_map = FALSE;\n\treturn;\n    }\n    lp->sl_has_map = TRUE;\n\n    // Init the array and hash tables empty.\n    for (i = 0; i < 256; ++i)\n\tlp->sl_map_array[i] = 0;\n    hash_init(&lp->sl_map_hash);\n\n    /*\n     * The similar characters are stored separated with slashes:\n     * \"aaa/bbb/ccc/\".  Fill sl_map_array[c] with the character before c and\n     * before the same slash.  For characters above 255 sl_map_hash is used.\n     */\n    for (p = map; *p != NUL; )\n    {\n\tc = mb_cptr2char_adv(&p);\n\tif (c == '/')\n\t    headc = 0;\n\telse\n\t{\n\t    if (headc == 0)\n\t\t headc = c;\n\n\t    // Characters above 255 don't fit in sl_map_array[], put them in\n\t    // the hash table.  Each entry is the char, a NUL the headchar and\n\t    // a NUL.\n\t    if (c >= 256)\n\t    {\n\t\tint\t    cl = mb_char2len(c);\n\t\tint\t    headcl = mb_char2len(headc);\n\t\tchar_u\t    *b;\n\t\thash_T\t    hash;\n\t\thashitem_T  *hi;\n\n\t\tb = alloc(cl + headcl + 2);\n\t\tif (b == NULL)\n\t\t    return;\n\t\tmb_char2bytes(c, b);\n\t\tb[cl] = NUL;\n\t\tmb_char2bytes(headc, b + cl + 1);\n\t\tb[cl + 1 + headcl] = NUL;\n\t\thash = hash_hash(b);\n\t\thi = hash_lookup(&lp->sl_map_hash, b, hash);\n\t\tif (HASHITEM_EMPTY(hi))\n\t\t    hash_add_item(&lp->sl_map_hash, hi, b, hash);\n\t\telse\n\t\t{\n\t\t    // This should have been checked when generating the .spl\n\t\t    // file.\n\t\t    emsg(_(e_duplicate_char_in_map_entry));\n\t\t    vim_free(b);\n\t\t}\n\t    }\n\t    else\n\t\tlp->sl_map_array[c] = headc;\n\t}\n    }\n}\n\n#endif  // FEAT_SPELL\n", "\" Test for spell checking with 'encoding' set to utf-8\n\nsource check.vim\nCheckFeature spell\n\nscriptencoding utf-8\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.utf-8.add')\n  call delete('Xtest.utf-8.add.spl')\n  call delete('Xtest.utf-8.spl')\n  call delete('Xtest.utf-8.sug')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\u00eb\u00e9\u00e8\u00ea\u00ef\u00ee\u00e4\u00e0\u00e2\u00f6\u00fc\u00fb'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"LOW  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"UPP  \u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00ff\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\"\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=utf-8\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.utf-8.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  %bwipe!\n  call setline(1, ['', \"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  %bwipe!\nendfunc\n\nfunc Test_spell_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\u00E9\\u00F4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u00ffn\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_spell_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\u00E9\\u00F4l\",\n        \\ [\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_spell_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\u00EF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\u00EF barm\\u00EF m\\u00EFfoo m\\u00EFbar m\\u00EFm\\u00EF lala m\\u00EFla lam\\u00EF foola labar\",\n        \\ [\"foo\", \"m\\u00EF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\u00EF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\u00EF\", \"foo\"]],\n        \\   [\"foom\\u00EF\", [\"foo m\\u00EF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\u00EF\", [\"barfoo\", \"m\\u00EF\", \"barbar\"]],\n        \\   [\"m\\u00EFfoo\", [\"m\\u00EF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\u00EFbar\", [\"foobar\", \"barbar\", \"m\\u00EF\"]],\n        \\   [\"m\\u00EFm\\u00EF\", [\"m\\u00EF m\\u00EF\", \"m\\u00EF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\u00EFla\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"lam\\u00EF\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\" Test affix flags with two characters\nfunc Test_spell_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\u00E9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\u00E9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\u00E9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\u00E9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\u00E9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\u00E9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\u00E9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\u00E9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_spell_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_spell_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_spell_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\" Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_spell_sal_and_addition()\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.utf-8.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u00ffn\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.utf-8.add\")\n  mkspell! Xtest.utf-8.add.spl Xtest.utf-8.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.utf-8.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.utf-8.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.utf-8.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_no_crash_with_weird_text()\n  new\n  let lines =<< trim END\n      r<sfile>\n      \u0080\n\n\n      \u0080\n  END\n  call setline(1, lines)\n  exe \"%norm \\<C-v>ez=>\\<C-v>wzG\"\n\n  bwipe!\nendfunc\n\n\" Invalid bytes may cause trouble when creating the word list.\nfunc Test_check_for_valid_word()\n  call assert_fails(\"spellgood! 0\u0002\\xac\", 'E1280:')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/errors.h", "src/mbyte.c", "src/spellfile.c", "src/testdir/test_spell_utf8.vim", "src/version.c"], "buggy_code_start_loc": [3275, 4229, 4392, 782, 748], "buggy_code_end_loc": [3275, 4230, 6192, 782, 748], "fixing_code_start_loc": [3276, 4229, 4393, 783, 749], "fixing_code_end_loc": [3280, 4230, 6203, 788, 751], "type": "CWE-122", "message": "Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution", "other": {"cve": {"id": "CVE-2022-1621", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-10T14:15:08.460", "lastModified": "2023-05-03T12:15:21.913", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution"}, {"lang": "es", "value": "Un Desbordamiento del b\u00fafer de pila en vim_strncpy find_word en el repositorio de GitHub vim/vim versiones anteriores a 8.2.4919. Esta vulnerabilidad es capaz de bloquear el software, Omitir el Mecanismo de Protecci\u00f3n, Modificar la Memoria y una posible ejecuci\u00f3n remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4919", "matchCriteriaId": "CF072C31-D320-47CE-B39B-F45447D70BD9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/7c824682d2028432ee082703ef0ab399867a089b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/520ce714-bfd2-4646-9458-f52cd22bb2fb", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/7c824682d2028432ee082703ef0ab399867a089b"}}