{"buggy_code": ["2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_ojpeg.c: make OJPEGDecode() early exit in case of failure in\n\tOJPEGPreDecode(). This will avoid a divide by zero, and potential other issues.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2611\n\n2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to\n\tinstanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),\n\tinstead of a logic based on the total size of data. Which is faulty is\n\tthe total size of data is not sufficient to fill the whole image, and thus\n\tresults in reading outside of the StripByCounts/StripOffsets arrays when\n\tusing TIFFReadScanline().\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2608.\n\n\t* libtiff/tif_strip.c: revert the change in TIFFNumberOfStrips() done\n\tfor http://bugzilla.maptools.org/show_bug.cgi?id=2587 / CVE-2016-9273 since\n\tthe above change is a better fix that makes it unnecessary.\n\n2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c, libtiff/tif_luv.c: fix heap-based buffer\n\toverflow on generation of PixarLog / LUV compressed files, with\n\tColorMap, TransferFunction attached and nasty plays with bitspersample.\n\tThe fix for LUV has not been tested, but suffers from the same kind\n\tof issue of PixarLog.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2604\n\n2016-12-02 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that \n\tcan cause various issues, such as buffer overflows in the library.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2598\n\n2016-12-02 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c, libtiff/tiffiop.h: fix uint32 overflow in\n\tTIFFReadEncodedStrip() that caused an integer division by zero.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2596\n\n2016-11-20 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_getimage.c, libtiff/tif_open.c: add parenthesis to\n\tfix cppcheck clarifyCalculation warnings\n\t* libtiff/tif_predict.c, libtiff/tif_print.c: fix printf unsigned\n\tvs signed formatting (cppcheck invalidPrintfArgType_uint warnings)\n\n2016-11-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/fax2tiff.c (main): Applied patch by J\u00f6rg Ahrens to fix\n\tpassing client data for Win32 builds using tif_win32.c\n\t(USE_WIN32_FILEIO defined) for file I/O.  Patch was provided via\n\temail on November 20, 2016.\n\n2016-11-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.7 released.\n\n\t* configure.ac: Update for 4.0.7 release.\n\n\t* tools/tiffdump.c (ReadDirectory): Remove uint32 cast to\n\t_TIFFmalloc() argument which resulted in Coverity report.  Added\n\tmore mutiplication overflow checks.\n\n2016-11-18 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Fix memory leak in (recent) error code path.\n\tFixes Coverity 1394415.\n\n2016-11-17  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c: Fix some benign warnings which appear in\n\t64-bit compilation under Microsoft Visual Studio of the form\n\t\"Arithmetic overflow: 32-bit value is shifted, then cast to 64-bit\n\tvalue.  Results might not be an expected value.\".  Problem was\n\treported on November 16, 2016 on the tiff mailing list.\n\n2016-11-16 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), do not dereference\n\tNULL pointer when values of tags with TIFF_SETGET_C16_ASCII / TIFF_SETGET_C32_ASCII\n\taccess are 0-byte arrays.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2593 (regression introduced\n\tby previous fix done on 2016-11-11 for CVE-2016-9297).\n\tReported by Henri Salo. Assigned as CVE-2016-9448\n\n2016-11-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffinfo.c (TIFFReadContigTileData): Fix signed/unsigned\n\tcomparison warning.\n\t(TIFFReadSeparateTileData): Fix signed/unsigned comparison\n\twarning.\n\n\t* tools/tiffcrop.c (readContigTilesIntoBuffer): Fix\n\tsigned/unsigned comparison warning.\n\n\t* html/v4.0.7.html: Add a file to document the pending 4.0.7\n\trelease.\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: avoid undefined behaviour related to overlapping\n\tof source and destination buffer in memcpy() call in\n\tt2p_sample_rgbaa_to_rgb()\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2577\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix potential integer overflows on 32 bit builds\n\tin t2p_read_tiff_size()\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2576\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_aux.c: fix crash in TIFFVGetFieldDefaulted()\n\twhen requesting Predictor tag and that the zip/lzw codec is not\n\tconfigured.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2591\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make sure that\n\tvalues of tags with TIFF_SETGET_C16_ASCII / TIFF_SETGET_C32_ASCII\n\taccess are null terminated, to avoid potential read outside buffer\n\tin _TIFFPrintField().\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2590 (CVE-2016-9297)\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: reject images with OJPEG compression that\n\thave no TileOffsets/StripOffsets tag, when OJPEG compression is\n\tdisabled. Prevent null pointer dereference in TIFFReadRawStrip1()\n\tand other functions that expect td_stripbytecount to be non NULL.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2585\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix multiple uint32 overflows in\n\twriteBufferToSeparateStrips(), writeBufferToContigTiles() and\n\twriteBufferToSeparateTiles() that could cause heap buffer overflows.\n\tReported by Henri Salo from Nixu Corporation.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2592 (CVE-2016-9532)\n\n2016-11-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_strip.c: make TIFFNumberOfStrips() return the td->td_nstrips\n\tvalue when it is non-zero, instead of recomputing it. This is needed in\n\tTIFF_STRIPCHOP mode where td_nstrips is modified. Fixes a read outsize of\n\tarray in tiffsplit (or other utilities using TIFFNumberOfStrips()).\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2587 (CVE-2016-9273)\n\n2016-11-04 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predic.c: fix memory leaks in error code paths added in\n\tprevious commit (fix for MSVR 35105)\n\n2016-10-31 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.h, libtiff/tif_predict.c:\n\tReplace assertions by runtime checks to avoid assertions in debug mode,\n\tor buffer overflows in release mode. Can happen when dealing with\n\tunusual tile size like YCbCr with subsampling. Reported as MSVR 35105\n\tby Axel Souchet\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations\n\tteam.\n\n2016-10-26 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/fax2tiff.c: fix segfault when specifying -r without\n\targument. Patch by Yuriy M. Kaminskiy.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2572\n\n2016-10-25 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c: discard values of SMinSampleValue and\n\tSMaxSampleValue when they have been read and the value of\n\tSamplesPerPixel is changed afterwards (like when reading a\n\tOJPEG compressed image with a missing SamplesPerPixel tag,\n\tand whose photometric is RGB or YCbCr, forcing SamplesPerPixel\n\tbeing 3). Otherwise when rewriting the directory (for example\n\twith tiffset, we will expect 3 values whereas the array had been\n\tallocated with just one), thus causing a out of bound read access.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2500\n\t(CVE-2014-8127, duplicate: CVE-2016-3658)\n\t\n\t* libtiff/tif_dirwrite.c: avoid null pointer dereference on td_stripoffset\n\twhen writing directory, if FIELD_STRIPOFFSETS was artificially set\n\tfor a hack case\tin OJPEG case.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2500\n\t(CVE-2014-8127, duplicate: CVE-2016-3658)\n\n2016-10-25 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffinfo.c: fix out-of-bound read on some tiled images.\n\t(http://bugzilla.maptools.org/show_bug.cgi?id=2517)\n\n\t* libtiff/tif_compress.c: make TIFFNoDecode() return 0 to indicate an\n\terror and make upper level read routines treat it accordingly.\n\t(linked to the test case of http://bugzilla.maptools.org/show_bug.cgi?id=2517)\n\n2016-10-14 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix out-of-bound read of up to 3 bytes in\n\treadContigTilesIntoBuffer(). Reported as MSVR 35092 by Axel Souchet\n\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations team.\n\n2016-10-09 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix write buffer overflow of 2 bytes on JPEG\n\tcompressed images. Reported by Tyler Bohan of Cisco Talos as\n\tTALOS-CAN-0187 / CVE-2016-5652.\n\tAlso prevents writing 2 extra uninitialized bytes to the file stream.\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: fix out-of-bounds write on tiled images with odd\n\ttile width vs image width. Reported as MSVR 35103\n\tby Axel Souchet and Vishal Chauhan from the MSRC Vulnerabilities &\n\tMitigations team.\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix read -largely- outsize of buffer in\n\tt2p_readwrite_pdf_image_tile(), causing crash, when reading a\n\tJPEG compressed image with TIFFTAG_JPEGTABLES length being one.\n\tReported as MSVR 35101 by Axel Souchet and Vishal Chauhan from\n\tthe MSRC Vulnerabilities & Mitigations team. CVE-2016-9453\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: fix read of undefined variable in case of missing\n\trequired tags. Found on test case of MSVR 35100.\n\t* tools/tiffcrop.c: fix read of undefined buffer in\n\treadContigStripsIntoBuffer() due to uint16 overflow. Probably not a\n\tsecurity issue but I can be wrong. Reported as MSVR 35100 by Axel\n\tSouchet from the MSRC Vulnerabilities & Mitigations team.\n\n2016-09-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html: Change as many remotesensing.org broken links to a working\n\tURL as possible.\n\n2016-09-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c (TIFFRGBAImageOK): Reject attempts to\n\tread floating point images.\n\n\t* libtiff/tif_predict.c (PredictorSetup): Enforce bits-per-sample\n\trequirements of floating point predictor (3).  Fixes CVE-2016-3622\n\t\"Divide By Zero in the tiff2rgba tool.\"\n\n2016-09-23 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix various out-of-bounds write vulnerabilities\n\tin heap or stack allocated buffers. Reported as MSVR 35093,\n\tMSVR 35096 and MSVR 35097. Discovered by Axel Souchet and Vishal\n\tChauhan from the MSRC Vulnerabilities & Mitigations team.\n\t* tools/tiff2pdf.c: fix out-of-bounds write vulnerabilities in\n\theap allocate buffer in t2p_process_jpeg_strip(). Reported as MSVR\n\t35098. Discovered by Axel Souchet and Vishal Chauhan from the MSRC\n\tVulnerabilities & Mitigations team.\n\t* libtiff/tif_pixarlog.c: fix out-of-bounds write vulnerabilities\n\tin heap allocated buffers. Reported as MSVR 35094. Discovered by\n\tAxel Souchet and Vishal Chauhan from the MSRC Vulnerabilities &\n\tMitigations team.\n\t* libtiff/tif_write.c: fix issue in error code path of TIFFFlushData1()\n\tthat didn't reset the tif_rawcc and tif_rawcp members. I'm not\n\tcompletely sure if that could happen in practice outside of the odd\n\tbehaviour of t2p_seekproc() of tiff2pdf). The report points that a\n\tbetter fix could be to check the return value of TIFFFlushData1() in\n\tplaces where it isn't done currently, but it seems this patch is enough.\n\tReported as MSVR 35095. Discovered by Axel Souchet & Vishal Chauhan &\n\tSuha Can from the MSRC Vulnerabilities & Mitigations team.\n\n2016-09-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/man/index.html: Comment out links to documentation for\n\tabandoned utilities.\n\n2016-09-17 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_lzma.c: typo fix in comment\n\n2016-09-04 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix warnings raised by clang 3.9 -Wcomma\n\n2016-09-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirwrite.c, libtiff/tif_color.c: fix warnings raised\n\tby GCC 5 / clang -Wfloat-conversion\n\n2016-08-16 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix C99'ism.\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2bw.c: fix weight computation that could result of color\n\tvalue overflow (no security implication). Fix bugzilla #2550.\n\tPatch by Frank Freudenberg.\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/rgb2ycbcr.c: validate values of -v and -h parameters to\n\tavoid potential divide by zero. Fixes CVE-2016-3623 (bugzilla #2569)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Fix out-of-bounds write in loadImage().\n\tFrom patch libtiff-CVE-2016-3991.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro (bugzilla #2543)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: Fix write buffer overflow in PixarLogEncode\n\tif more input samples are provided than expected by PixarLogSetupEncode.\n\tIdea based on libtiff-CVE-2016-3990.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro, but with different and\n\tsimpler check. (bugzilla #2544)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2rgba.c: Fix integer overflow in size of allocated\n\tbuffer, when -b mode is enabled, that could result in out-of-bounds\n\twrite. Based initially on patch tiff-CVE-2016-3945.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro, with correction for\n\tinvalid tests that rejected valid files. (bugzilla #2545)\n\n2016-07-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Avoid access outside of stack allocated array\n\ton a tiled separate TIFF with more than 8 samples per pixel.\n\tReported by Kaixiang Zhang of the Cloud Security Team, Qihoo 360\n\t(CVE-2016-5321 / CVE-2016-5323 , bugzilla #2558 / #2559)\n\n2016-07-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c: Fix out-of-bounds read on\n\tmemory-mapped files in TIFFReadRawStrip1() and TIFFReadRawTile1()\n\twhen stripoffset is beyond tmsize_t max value (reported by\n\tMathias Svensson)\n\n2016-07-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffdump.c: fix a few misaligned 64-bit reads warned\n\tby -fsanitize\n\n2016-07-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c: make TIFFReadEncodedStrip() and\n\tTIFFReadEncodedTile() directly use user provided buffer when\n\tno compression (and other conditions) to save a memcpy().\n\n\t* libtiff/tif_write.c: make TIFFWriteEncodedStrip() and\n\tTIFFWriteEncodedTile() directly use user provided buffer when\n\tno compression to save a memcpy().\n\n2016-07-01  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_luv.c: validate that for COMPRESSION_SGILOG and\n\tPHOTOMETRIC_LOGL, there is only one sample per pixel. Avoid\n\tpotential invalid memory write on corrupted/unexpected images when\n\tusing the TIFFRGBAImageBegin() interface (reported by\n\tClay Wood)\n\n2016-06-28  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: fix potential buffer write overrun in\n\tPixarLogDecode() on corrupted/unexpected images (reported by Mathias Svensson)\n\t(CVE-2016-5875)\n\n2016-06-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/libtiff.def: Added _TIFFMultiply32 and _TIFFMultiply64\n\tto libtiff.def\n\n2016-06-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/Makefile.am: The libtiff tools bmp2tiff, gif2tiff,\n\tras2tiff, sgi2tiff, sgisv, and ycbcr are completely removed from\n\tthe distribution.  The libtiff tools rgb2ycbcr and thumbnail are\n\tonly built in the build tree for testing.  Old files are put in\n\tnew 'archive' subdirectory of the source repository, but not in\n\tdistribution archives.  These changes are made in order to lessen\n\tthe maintenance burden.\n\n2016-05-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h (HAVE_SNPRINTF): Add a '1' to the\n\tHAVE_SNPRINTF definition.'\n\n2016-05-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h (HAVE_SNPRINTF): Applied patch by Edward\n\tLam to define HAVE_SNPRINTF for Visual Studio 2015.\n\n2016-04-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: when compiled with DEFER_STRILE_LOAD,\n\tfix regression, introduced on 2014-12-23, when reading a one-strip\n\tfile without a StripByteCounts tag. GDAL #6490\n\n2016-04-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/bugs.html: Replace Andrey Kiselev with Bob Friesenhahn for\n\tpurposes of security issue reporting.\n\n2016-01-23  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*: upstream typo fixes (mostly contributed by Kurt Schwehr)\n\tcoming from GDAL internal libtiff\n\n2016-01-09  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.h: make Param member of TIFFFaxTabEnt structure\n\ta uint16 to reduce size of the binary.\n\n2016-01-03  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c, tif_dirread.c: fix indentation issues raised\n\tby GCC 6 -Wmisleading-indentation\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: avoid zlib error messages to pass a NULL\n\tstring to %s formatter, which is undefined behaviour in sprintf().\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_next.c: fix potential out-of-bound write in NeXTDecode()\n\ttriggered by http://lcamtuf.coredump.cx/afl/vulns/libtiff5.tif\n\t(bugzilla #2508)\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_luv.c: fix potential out-of-bound writes in decode\n\tfunctions in non debug builds by replacing assert()s by regular if\n\tchecks (bugzilla #2522).\n\tFix potential out-of-bound reads in case of short input data.\n\n2015-12-26  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_getimage.c: fix out-of-bound reads in TIFFRGBAImage\n\tinterface in case of unsupported values of SamplesPerPixel/ExtraSamples\n\tfor LogLUV / CIELab. Add explicit call to TIFFRGBAImageOK() in\n\tTIFFRGBAImageBegin(). Fix CVE-2015-8665 reported by limingxing and\n\tCVE-2015-8683 reported by zzf of Alibaba.\n\n2015-12-21  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: workaround false positive warning of Clang Static\n\tAnalyzer about null pointer dereference in TIFFCheckDirOffset().\n\n2015-12-19  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.c: remove dead assignment in Fax3PutEOLgdal(). Found\n\tby Clang Static Analyzer\n\n2015-12-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirwrite.c: fix truncation to 32 bit of file offsets in\n\tTIFFLinkDirectory() and TIFFWriteDirectorySec() when aligning directory\n\toffsets on a even offset (affects BigTIFF). This was a regression of the\n\tchangeset of 2015-10-19.\n\n2015-12-12  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_write.c: TIFFWriteEncodedStrip() and TIFFWriteEncodedTile()\n\tshould return -1 in case of failure of tif_encodestrip() as documented\n\t* libtiff/tif_dumpmode.c: DumpModeEncode() should return 0 in case of\n\tfailure so that the above mentionned functions detect the error.\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/uvcode.h: const'ify uv_code array\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirinfo.c: const'ify tiffFields, exifFields,\n\ttiffFieldArray and exifFieldArray arrays\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_print.c: constify photoNames and orientNames arrays\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_close.c, libtiff/tif_extension.c : rename link\n\tvariable to avoid -Wshadow warnings\n\n2015-11-22  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix typos in comments (patch by Kurt Schwehr)\n \n2015-11-22  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix MSVC warnings related to cast shortening and\n\tassignment within conditional expression\n\n2015-11-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix clang -Wshorten-64-to-32 warnings\n\n2015-11-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: initialize double* data at line 3693 to NULL\n\tto please MSVC 2013\n\n2015-11-17  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: prevent reading ColorMap or TransferFunction\n\tif BitsPerPixel > 24, so as to avoid huge memory allocation and file\n\tread attempts\n\n2015-11-02  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: remove duplicated assignment (reported by\n\tClang static analyzer)\n\n2015-10-28  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirinfo.c, libtiff/tif_compress.c,\n\tlibtiff/tif_jpeg_12.c: suppress warnings about 'no previous\n\tdeclaration/prototype'\n\n2015-10-19  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tiffiop.h, libtiff/tif_dirwrite.c: suffix constants by U to fix \n\t'warning: negative integer implicitly converted to unsigned type' warning\n\t(part of -Wconversion)\n\n2015-10-17  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirread.c, libtiff/tif_getimage.c,\n\t  libtiff/tif_print.c: fix -Wshadow warnings (only in libtiff/)\n\n2015-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.6 released.\n\n\t* html/v4.0.6.html: Added release notes for 4.0.6.\n\n2015-09-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Silence glut API deprecation warnings on MacOS\n\tX.  Patch by Roger Leigh.\n\n\t* Makefile.am: Added a 'coverity' rule to assist with Coverity\n\tsubmissions.\n\n\t* tools/tiff2pdf.c: Fix compiler warning about unused function\n\twhen JPEG is not available.\n\n\t* tools/fax2ps.c (main): Detect failure to write to temporary\n\tfile.\n\n2015-09-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryCheckRangeSlongSlong8):\n\tChange implementation so that it does not sometimes overflow the\n\trange of a 32-bit int and to avoid a signed vs unsigned compare\n\tcompiler warning.\n\t(TIFF_INT64_MAX): Avoid use of platform-specific large constants.\n\t(TIFF_UINT32_MAX): Avoid use of platform-specific large constants.\n\n2015-09-01  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am (distcheck-hook), configure.ac: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-09-01) to fix issue\n\twith BSD make and to make use of cmake in 'distcheck' target\n\tconditional on if cmake is available.\n\n\t* CMakeLists.txt, Makefile.am, configure.ac: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-09-01).\n\n\tCMake build is now included in 'distcheck' target.\n\n\tBuilds with CMake 2.8.9 and newer.\n\n\tTar is now resquested to use POSIX PAX format.\n\n2015-08-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt, libtiff/test/Makefile.am: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-08-31.\n\n\tCMake reads all version information directly from configure.ac to\n\tavoid duplication of values.  This basically greps over the file\n\tfor the LIBTIFF_* variables, then translates them to the form\n\tneeded for cmake. This includes the release version and libtool\n\tshared library version information.\n\n\tMake shared/static library building configurable.  Currently it\n\talways builds shared libraries, with static libs having a _static\n\tsuffix (copying zlib, but it means it's got a non-standard name).\n\tCMake has a -DBUILD_SHARED_LIBS=ON|OFF option to select one or the\n\tother, which is now used instead.  There's now a single \"tiff\"\n\ttarget to build either shared or static as required, and all the\n\ttests and tools are linked with this. Note: the Windows tests fail\n\twhen linked with a static libtiff (says: libtiff.dll not found).\n\tNot really a regression since this was not tested up to this\n\tpoint, and it's likely the unit tests haven't (ever?) been run on\n\tWindows with a static libtiff, so there's some additional\n\tportability issue here to address.  Works fine on UNIX systems,\n\tand fine on Windows with the default to build a DLL.\n\n\tAdd a missing file which wasn't being distributed, causing unit\n\ttests to fail.  Note that \"find . -name '*.cmake'\" lists all the\n\tCMake files which need distributing in addition to all the\n\tCMakeLists.txt files (which now are distributed).\n\n2015-08-31  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.c: pedantic change to add explicit masking\n\twith 0xff before casting to uchar in floating-point horizontal\n\tdifferencing and accumulation routines.\n\n2015-08-31  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.c: fix generation of output with 16 bit\n\tor 32 bit integer, when byte swapping is needed, in\n\thorizontal predictor (#2521). Also fixes decoding when there is\n\ta single pixel to code (unlikely case...) and byte swapping is\n\tinvolved.\n\n2015-08-30  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_lzw.c: make nextdata a unsigned type to avoid\n\tundefined behaviour with shifts (gcc -fsanitize=shift)\n\n2015-08-30  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.c, libtiff/tif_lzw.c, libtiff/tif_predict.c:\n\tadd explicit masking with 0xff before casting\n\tto unsigned char (make icc -check=conversions happy)\n\n\t* libtiff/tif_predict.c: operate on unsigned datatypes when\n\tcomputing/applying differences to avoid undefined behaviour of\n\tsigned types (C standard compliance)\n\n2015-08-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: libtiff 4.0.5 released.\n\n2015-08-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Applied patch by Roger Leigh (via tiff mailing\n\tlist on 2015-08-29) to add ld-version-script option to cmake build\n\tto match autoconf.  Note: defaults to 'on' to be ABI-compatible by\n\tdefault with common Linux distribution builds.  Note that the\n\tautoconf configure script defaults to 'off'.\n\n\t* html/build.html: Applied patch by Roger Leigh (via tiff mailing\n\tlist on 2015-08-29) to describe how to use CMake to build libtiff.\n\n2015-08-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/v4.0.5.html: Added HTML file describing the changes which\n\twill appear in the 4.0.5 release.\n\n2015-08-23  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h: For MinGW comiles, make sure that build\n\tsupports necessary __MSVCRT_VERSION__ (at least at least 0x800).\n\tOtherwise large files can not be supported for POSIX-style I/O.\n\n\t* tools/fax2tiff.c (main): Eliminate a compiler warning in 64-bit\n\tbuilds about cast to thandle_t.\n\n\t* test/rewrite_tag.c (main): Does not require any arguments.\n\n2015-08-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/CMakeLists.txt, port/snprintf.c: Patch by Roger Leigh to\n\tfix build issues when using Cmake due to Windows large file\n\tchanges.\n\n2015-08-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h: First cut at supporting large files under\n\tMicrosoft Windows using tif_unix.c and the libtiff tools.  This\n\tonly works if the Windows CDK is new enough to support the APIs\n\tused (Visual C++ 2005 or later).  Support for large files is not\n\tactually tested yet.\n\n2015-08-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Applied patch by R\u00e4is\u00e4 Olli to assure that\n\tclient_data is initialized to a known value, and to report an\n\terror on two memory allocation failures.\n\n2015-08-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Applied patch by Roger Leigh to fix libtiffxx\n\tsymbol versioning.  Patch was mailed to libtiff list on Thu, 13\n\tAug 2015.\n\n2015-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* cmake: Add d suffix to debug libraries with MSVC.  Patch #3 of 3\n\tby Roger Leigh posted to tiff list on Wed, 1 Jul 2015 15:58:20\n\t+0100.\n\n\t* cmake: Add extra warning flags.  Patch #2 of 3 by Roger Leigh\n\tposted to tiff list on Wed, 1 Jul 2015 15:58:20 +0100.\n\n\t* cmake: Correct snprintf fallback for VS2015.  Patch #1 of 3 by\n\tRoger Leigh posted to tiff list on Wed, 1 Jul 2015 15:58:20 +0100.\n\n2015-06-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Add CMake patchset by Roger Leigh as posted to\n\tlibtiff mailing list on Mon, 22 Jun 2015 21:21:01 +0100. Several\n\tcorrections to ensure that the autotools build still works were\n\tadded by me.  I have not yet tested the build using 'cmake' or\n\tMSVC with 'nmake'.\n\n2015-06-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am: tiff2rgba-quad-tile.jpg.sh depends on the JPEG\n\tlibrary so only execute if JPEG is available.\n\n\t* libtiff 4.0.4 released.\n\n\t* configure.ac: Add a HAVE_FOO Automake conditional for each\n\tadd-on library.\n\n\t* test/Makefile.am (JPEG_DEPENDENT_CHECK_PROG): raw_decode\n\trequires JPEG support to compile.  Use Automake conditional to\n\tonly include it when JPEG support is available.\n\n\t* html/build.html: Try to improve the nmake-based VC++ build\n\tdescription.\n\n\t* libtiff/tiffconf.vc.h: Build fixes based on testing.\n\n\t* libtiff/tif_config.vc.h: Build fixes based on testing.\n\n\t* libtiff/libtiff.def: TIFFRasterScanline does not exist so remove\n\texport for it.\n\n2015-06-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h: Make adjustments to match the new\n\tdefinitions that configure produces, including for WIN64.  Still\n\tneeds to be tested.\n\n\t* configure.ac: For 64-bit MinGW, fix SSIZE_FORMAT formatting\n\tspecifier.  64-bit MinGW supports 'long long' but support for\n\t'lld' is not assured by the run-time DLLs and so GCC warns.\n\tAdd TIFF_SIZE_T and TIFF_SIZE_FORMAT to provide a type definition\n\tand printf format specifier to deal with printing values of\n\t'size_t' type.  In particular, this was necessary for WIN64.\n\tAdded a configure test for if the system headers provide 'optarg'\n\t(normal case) and block out the many explicit 'extern' statements\n\tin the utilities.  This was found to be necessary under Windows\n\twhen getopt is in a DLL and the symbols are already imported with\n\tdllimport via standard header files.\n\n\t* test/raw_decode.c (XMD_H): Avoid conflicting typedefs for INT32\n\tand boolean in MinGW build due to including jpeglib.h.\n\n\t* test/rewrite_tag.c (main): Fix problem with location of variable\n\tdeclaration.\n\n\t* libtiff/libtiff.def: Added exports for TIFFGetConfiguredCODECs,\n\tTIFFReadRGBAImageOriented, TIFFSetCompressionScheme,\n\tTIFFSwabArrayOfTriples, TIFFVGetFieldDefaulted, _TIFFCheckRealloc,\n\tTIFFRasterScanline, TIFFSetErrorHandlerExt,\n\tTIFFSetWarningHandlerExt, TIFFNumberOfDirectories,\n\tTIFFCreateCustomDirectory, TIFFCreateEXIFDirectory,\n\tTIFFWriteCustomDirectory, _TIFFRewriteField as recommended by\n\tRoger Leigh and justified by use in libtiff tests, documentation,\n\tand changelog notes.  Also sorted symbol list and removed\n\tduplicate entries.\n\n2015-06-16  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c: Fix four Coverity issues related to\n\tunintended sign extension.\n\n2015-06-16  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_unix.c: fix compilation with MSVC (fix by Jeff McKenna)\n\n2015-06-14  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_unix.c: contribution from Vadim Zeitlin on\n\tBugzilla Bug #2510 fixes several harmless but still annoying\n\twarnings\n\n\t* configure: contribution from Ludolf Holzheid on Bugzilla\n\tBug #2498.  Adds an option to select the file I/O style on\n\tWindows hosts.\n\n\t* libtiff/tif_getimage.c: contribution from Gary Cramblitt\n\ton Bugzilla Bug #2409.  Correct reading of certain tiled TIFFs.\n\n\t* configure, configure.ac: contribution from Marcos H. Woehrmann\n\ton Bugzilla Bug #2405.  Correct shell equality operator.\n\n\t* tools/tiffgt.c (raster_draw): contribution from Jay Berkenbilt\n\ton Bugzilla Bug #2401.  Appropriately call glFlush().\n\n\t* tools/tiff2pdf.c: change ColorTransform from \"0\" to \"1\"\n\tfollowing Bugzilla Bug #2150.\n\n2015-06-13  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_lzw.c: contribution from Andy Cave - decode\n\tfiles that contain consecutive CODE_CLEAR codes.\n\n\t* tools/tiff2pdf.c: contribution from Antti S. Lankila on\n\tBugzilla Bug #2078. Suppress initial output of the header.\n\n\t* tools/tiff2pdf.c: contribution from Yuriy M. Kaminskiy -\n\tTake care in using the return value from snprintf().\n\n\t* tools/tiffcrop.c: contribution from Eduardo Robles Elvira -\n\tcorrectly copy the compression tag from the source TIFF.\n\n\t* tools/tiff2ps.c: contribution from Eduardo Robles Elvira -\n\tcorrect sizing and scaling problems with output document.\n\n2015-06-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c (JPEGDecode): Split JPEGDecode() into two\n\tclean implementations in order to avoid pre-processor hell.  Only\n\tone of the implementations is used in a given build.\n\n2015-06-08  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_jpeg.c: Fix compilation in BITS_IN_JSAMPLE == 12\n\tcase\n\n2015-06-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_write.c (TIFFWriteEncodedStrip): Fix Coverity 715975\n\t\"Division or modulo by zero\".\n\t(TIFFWriteEncodedTile): Fix Coverity 715976 and 715977 \"Division\n\tor modulo by zero\".\n\t(TIFFWriteRawStrip): Fix Coverity 715978 \"Division or modulo by\n\tzero\".\n\t(TIFFWriteScanline): Fix Coverity 715979 \"Division or modulo by\n\tzero\".\n\n\t* libtiff/tif_read.c (TIFFStartTile): Fix Coverity 715973 and\n\t715974 \"Division or modulo by zero\".\n\n2015-05-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (TIFFNumberOfDirectories): Quiet Coverity\n\t1134470 \"Logically dead code\" by making the roll-over check\n\texplicit.\n\n\t* libtiff/tif_luv.c (LogLuvDecodeTile): Fix Coverity 991227\n\t\"Division or modulo by zero\".\n\t(LogLuvDecodeStrip): Fix Coverity 991239 \"Division or modulo by\n\tzero\".\n\t(LogLuvEncodeStrip): Fix Coverity 991240 \"Division or modulo by\n\tzero\".\n\t(LogLuvEncodeTile): Fix Coverity 991241 \"Division or modulo by\n\tzero\".\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryDoubleArray): Fix\n\tCoverity 298626 \"Logically dead code\".\n\t(TIFFReadDirEntryFloatArray): Fix Coverity 298627 \"Logically dead\n\tcode\".\n\t(TIFFReadDirEntryIfd8Array): Fix Coverity 298628 \"Logically dead\n\tcode\".\n\t(TIFFReadDirEntrySlong8Array): Fix Coverity 298629 \"Logically dead\n\tcode\"\n\n\t* libtiff/tif_dir.c (TIFFNumberOfDirectories): Don't depend on ++\n\toperator precedenc in evaluation.  Might quench Coverity 1134470\n\t\"Logically dead code\".\n\n\t* libtiff/tif_jpeg.c (JPEGDecode): Fix Coverity 602597 \"Operands\n\tdon't affect result\".  This change uses ifdefs to include\n\tapplicable code based on properties of libjpeg.  Still needs to be\n\tre-tested with 12-bit \"6b\" and \"MK1\".\n\n2015-05-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirwrite.c (_TIFFRewriteField): Fix Coverity 1024310\n\t\"Resource leak\".\n\n\t* libtiff/tif_ojpeg.c (OJPEGReadHeaderInfoSecStreamDht): Fix\n\tCoverity 601720 \"Resource leak\".\n\n\t* libtiff/tif_jpeg.c (JPEGCleanup): Fix Coverity 298624\n\t\"Dereference before null check\".\n\n\t* libtiff/tif_ojpeg.c (OJPEGReadBufferFill): Fix Coverity 603400\n\t\"Missing break in switch\".\n\n\t* contrib/addtiffo/tif_overview.c (TIFF_DownSample): Check buffer\n\tsize calculation for overflow.\n\n\t* contrib/addtiffo/addtiffo.c (main): Possibly address Coverity\n\t1024226 \"Untrusted value as argument\".\n\n\t* tools/gif2tiff.c (readgifimage): Fix Coverity 1024222 \"Untrusted\n\tvalue as argument\".\n\t(checksignature): Fix Coverity 1024894 \"Ignoring number of bytes\n\tread\".\n\t(readextension): Fix Coverity 1024893 \"Ignoring number of bytes\n\tread\".\n\t(readgifimage): Fix Coverity 1024890 \"Ignoring number of bytes\n\tread\".\n\t(readraster): Fix Coverity 1024891 \"Ignoring number of bytes\n\tread\".\n\t(readgifimage): Fix Coverity 1024892 \"Ignoring number of bytes\n\tread\".\n\n\t* tools/tiff2pdf.c (t2p_readwrite_pdf_image): Fix Coverity 1024181\n\t\"Structurally dead code\".\n\n\t* tools/raw2tiff.c (main): Fix Coverity 1024887 \"Unchecked return\n\tvalue from library\".\n\t(guessSize): Fix Coverity 1024888 \"Unchecked return value from\n\tlibrary\".\n\t(guessSize): Fix Coverity 1214162 \"Ignoring number of bytes read\".\n\t(guessSize): Fix Coverity 1024889 \"Unchecked return value from\n\tlibrary\".\n\n\t* tools/tiff2pdf.c (t2p_readwrite_pdf_image): Fix Coverity 298621\n\t\"Resource leak\".\n\t(t2p_readwrite_pdf_image): Fix Coverity 1024181 \"Structurally dead\n\tcode\".\n\t(t2p_write_pdf): Fix Coverity 1227690 \"Unused value\".\n\n2015-05-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/iptcutil/iptcutil.c (formatIPTC): Fix Coverity 1024468\n\t\"Infinite loop\".\n\t(formatIPTC): Fix Coverity 1024727 \"Truncated stdio return value\".\n\t(formatIPTC): Fix Coverity 1214240 \"Untrusted loop bound\".\n\n2015-05-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/addtiffo/tif_ovrcache.c (TIFFCreateOvrCache): Fix\n\tCoverity 298615 \"Resource leak\".\n\t(TIFFGetOvrBlock): Fix Coverity 1024649 \"Unintended sign\n\textension\".\n\n\t* tools/bmp2tiff.c (main): Fix Coverity 1024225 \"Untrusted value\n\tas argument\".\n\t(main): Fix Coverity 1024678 \"Unchecked return value from\n\tlibrary\".\n\t(main): Fix Coverity 1024679 \"Unchecked return value from\n\tlibrary\".\n\t(main): Fix Coverity 1214160 \"Ignoring number of bytes read\".\n\n\t* contrib/addtiffo/tif_ovrcache.c (TIFFCreateOvrCache): Fix\n\tCoverity 298615 \"Resource leak\".\n\n\t* tools/tiffcp.c: Fix Coverity 1024306, 1024307, 1024308, 1024309\n\t\"Resource leak\".\n\n\t* tools/tiffsplit.c (cpTiles): Fix Coverity 1024304 \"Resource\n\tleak\".\n\t(cpStrips): Fix Coverity 1024305 \"Resource leak\".\n\n2015-05-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/ras2tiff.c: Fix Sun Raster header definition to be safe\n\tfor 64-bit systems.  Add some header validations.  Should fix many\n\tCoverity issues.\n\t(main): Fix Coverity 1301206: \"Integer handling issues  (BAD_SHIFT)\".\n\t(main): Quiet Coverity 1024223 \"Untrusted value as argument\".\n\n\t* tools/tiffmedian.c (GetInputLine): Fix Coverity 1024795 \"Nesting\n\tlevel does not match indentation\".\n\t(get_histogram): Quiet Coverity 1024386 \"Out-of-bounds read\".\n\tThis was a benign mis-diagnosis but added code to enforce against\n\tbuffer overflow.\n\n\t* tools/tiffcrop.c (ROTATE_ANY): Fix Coverity 1294542 \"Logical\n\tvs. bitwise operator\".\n\t(readContigStripsIntoBuffer): Fix Coverity 1024545 \"Division or\n\tmodulo by zero\".\n\t(readContigTilesIntoBuffer): Fix Coverity 1024586 \"Logically dead\n\tcode\".\n\t(writeSingleSection): Fix Coverity 1024796 \"Nesting level does not\n\tmatch indentation\".\n\t(writeCroppedImage): Fix Coverity 1024797 \"Nesting level does not\n\tmatch indentation\".\n\t(loadImage): Fix Coverity 1299741 \"Dereference before null check\".\n\t(loadImage): Fix Coverity 1299740 \"Out-of-bounds write\".\n\n2015-03-02  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiffdither.c: check memory allocations to avoid writing to\n\tNULL pointer. Also check multiplication overflow. Fixes #2501,\n\tCVE-2014-8128. Derived from patch by Petr Gajdos.\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* add html/v4.0.4beta.html under version control\n\t* HOWTO-RELEASE: write that cvs add html/vX.X.html must be used\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff 4.0.4beta released\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* automake: updated to 1.15\n\t* libtool: updated to 2.4.5\n\n2015-01-22  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: Fix two crashes (oCERT-2014-013)\n\n2015-01-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/bugs.html: remove note about needing to email the tiff mailing\n\tlist administrator about being approved for membership, this appears\n\tnot to be true.\n\n2015-01-05  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* tools/tiff2pdf.c: Fixed unsigned integer addition overflow detection.\n\n2015-01-03  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFCheckDirOffset(), avoid uint16 overflow\n\twhen reading more than 65535 directories, and effectively error out when\n\treaching that limit.\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_jpeg.c: in JPEGFixupTags(), recognize SOF2, SOF9 and SOF10\n\tmarkers to avoid emitting a warning (even if, according to the TechNote,\n\tthere are admitedly unusual/not recommended or even forbidden variants, but\n\tthey do work well with libjpeg for SOF2, and with libjpeg-turbo for SOF2,\n\tSOF9 and SOF10).\n\tDefine in_color_space and input_components to the right values in\n\tJPEGSetupEncode(), before calling jpeg_set_defaults(), as specified by\n\tlibjpeg API documentation, so as to be compatible with mozjpeg library.\n\tNote: the default settings of mozjpeg will produce progressive scans, which\n\tis forbidden by the TechNote.\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c: move test on vertical value of YCbCr subsampling.\n\tto avoid buffer leak (fix previous fix, found by Coverity scan)\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_next.c: add new tests to check that we don't read outside of\n\tthe compressed input stream buffer.\n\n\t* libtiff/tif_getimage.c: in OJPEG case, fix checks on strile width/height\n    in the putcontig8bitYCbCr42tile, putcontig8bitYCbCr41tile and\n    putcontig8bitYCbCr21tile cases.\n\n2014-12-27  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dir.c: in TIFFDefaultDirectory(), reset any already existing\n\textented tags installed by user code through the extender mechaninm before\n\tcalling the extender callback (GDAL #5054)\n\n2014-12-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Fix warnings about variables set but not used.\n\n\t* contrib/iptcutil/iptcutil.c: Fix warnings about variables set\n\tbut not used.\n\n\t* tools/tiffgt.c: Fix warnings about unused parameters.\n\n\t* libtiff/tif_stream.cxx: Fix warnings about unused parameters.\n\n2014-12-25  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c, libtiff/tif_ojpeg.c, libtiff/tif_zip.c: fix\n\tvarious typos found by Debian lintian tool (GDAL #5756)\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c: avoid divide by zero on invalid YCbCr subsampling.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2235\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: fix buffer overflow on some YCbCr JPEG compressed images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2445\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: fix buffer overflow on YCbCr JPEG compressed image.\n\tDerived from patch by Petr Gajdos,\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2443\n\n2014-12-23  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dirread.c: In EstimateStripByteCounts(), check return code\n\tof _TIFFFillStriles(). This solves crashing bug on corrupted\n\timages generated by afl.\n\n2014-12-23  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_read.c: fix several invalid comparisons of a uint64 value with\n\t<= 0 by casting it to int64 first. This solves crashing bug on corrupted\n\timages generated by afl.\n\n2014-12-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffdump.c: Guard against arithmetic overflow when\n\tcalculating allocation buffer sizes.\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2bw.c: when Photometric=RGB, the utility only works if\n\tSamplesPerPixel = 3. Enforce that\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2485 (CVE-2014-8127)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/pal2rgb.c, tools/thumbnail.c: fix crash by disabling TIFFTAG_INKNAMES\n\tcopying. The right fix would be to properly copy it, but not worth the burden\n\tfor those esoteric utilities.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2484 (CVE-2014-8127)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c: fix out-of-buffer write\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2489 (CVE-2014-8128)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c, tools/tiffcmp.c: only read/write TIFFTAG_GROUP3OPTIONS\n\tor TIFFTAG_GROUP4OPTIONS if compression is COMPRESSION_CCITTFAX3 or\n\tCOMPRESSION_CCITTFAX4\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2493 (CVE-2014-8128)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_next.c: check that BitsPerSample = 2. Fixes\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2487 (CVE-2014-8129)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: check return code of TIFFGetField() when reading\n\tTIFFTAG_SAMPLESPERPIXEL\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiffcp.c: fix crash when converting YCbCr JPEG-compressed to none.\n\tBased on patch by Tomasz Buchert (http://bugzilla.maptools.org/show_bug.cgi?id=2480)\n\tDescription: fix for Debian bug #741451\n\ttiffcp crashes when converting JPEG-encoded TIFF to a different\n\tencoding (like none or lzw). For example this will probably fail:\n\ttiffcp -c none jpeg_encoded_file.tif output.tif\n\tThe reason is that when the input file contains JPEG data,\n\tthe tiffcp code forces conversion to RGB space. However,\n\tthe output normally inherits YCbCr subsampling parameters\n\tfrom the input, which leads to a smaller working buffer\n\tthan necessary. The buffer is subsequently overrun inside\n\tcpStripToTile() (called from writeBufferToContigTiles).\n\tNote that the resulting TIFF file would be scrambled even\n\tif tiffcp wouldn't crash, since the output file would contain\n\tRGB data intepreted as subsampled YCbCr values.\n\tThis patch fixes the problem by forcing RGB space on the output\n\tTIF if the input is JPEG-encoded and output is *not* JPEG-encoded.\n\tAuthor: Tomasz Buchert <tomasz.buchert@inria.fr>\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\tFix various crasher bugs on fuzzed images.\n\t* libtiff/tif_dir.c: TIFFSetField(): refuse to set negative values for\n\tTIFFTAG_XRESOLUTION and TIFFTAG_YRESOLUTION that cause asserts when writing\n\tthe directory\n\t* libtiff/tif_dirread.c: TIFFReadDirectory(): refuse to read ColorMap or\n\tTransferFunction if BitsPerSample has not yet been read, otherwise reading\n\tit later will cause user code to crash if BitsPerSample > 1\n\t* libtiff/tif_getimage.c: TIFFRGBAImageOK(): return FALSE if LOGLUV with\n\tSamplesPerPixel != 3, or if CIELAB with SamplesPerPixel != 3 or BitsPerSample != 8\n\t* libtiff/tif_next.c: in the \"run mode\", use tilewidth for tiled images\n\tinstead of imagewidth to avoid crash\n\t* tools/bmp2tiff.c: fix crash due to int overflow related to input BMP dimensions\n\t* tools/tiff2pdf.c: fix crash due to invalid tile count (should likely be checked by\n\tlibtiff too). Detect invalid settings of BitsPerSample/SamplesPerPixel for CIELAB / ITULAB\n\t* tools/tiffcrop.c: fix crash due to invalid TileWidth/TileHeight\n\t* tools/tiffdump.c: fix crash due to overflow of entry count.\n\n2014-12-15  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_jpeg.c: Fix regression introduced on 2010-05-07 that caused\n\tall tiles/strips to include quantization tables even when the jpegtablesmode\n\thad the JPEGTABLESMODE_QUANT bit set.\n\tAlso add explicit removal of Huffman tables when jpegtablesmode has the\n\tJPEGTABLESMODE_HUFF bit set, which avoids Huffman tables to be emitted in the\n\tfirst tile/strip (only useful in update scenarios. create-only was\n\tfine)\n\n2014-12-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c: Assure that memory size calculations for\n\t_TIFFmalloc() do not overflow the range of tmsize_t.\n\n2014-12-07  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c, tools/tiffcrop.c: \"fix\" heap read over-run found with\n\tValgrind and Address Sanitizer on test suite\n\n2014-12-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c (t2p_read_tiff_init): TIFFTAG_TRANSFERFUNCTION\n\ttag can return one channel, with the other two channels set to\n\tNULL.  The tiff2pdf code was expecting that other two channels\n\twere duplicate pointers in the case where there is only one\n\tchannel.  Detect this condition in order to avoid a crash, and\n\tpresumably perform correctly with just one channel.\n\n2014-12-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffdump.c: Fix double-free bug.\n\n2014-11-27  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_config.vc.h: no longer use \"#define snprintf _snprintf\" with\n\tVisual Studio 2015 aka VC 14 aka MSVC 1900\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_lzw.c: prevent potential null dereference of\n\tsp->dec_codetab in LZWPreDecode (bug #2459)\n\n\t* libtiff/tif_read.c: in TIFFReadBufferSetup(), avoid passing -1 size\n\tto TIFFmalloc() if passed user buffer size is 0 (bug #2459)\n\n\t* libtiff/tif_ojpeg.c: make Coverity happier (not a bug, #2459)\n\n\t* libtiff/tif_dir.c: in _TIFFVGetField() and _TIFFVSetField(), make\n\tCoverity happier (not a bug, #2459)\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make Coverity happier\n\t(not a bug, #2459)\n\n\t* tools/tiff2pdf.c: close PDF file (bug #2479)\n\n\t* tools/fax2ps.c: check malloc()/realloc() result (bug #2470)\n\n\t* tools/tiffdump.c: detect cycle in TIFF directory chaining (bug #2463)\n\tand avoid passing a NULL pointer to read() if seek() failed before (bug #2459)\n\n\t* tools/tiffcrop.c: fix segfault if bad value passed to -Z option\n\t(bug #2459) and add missing va_end in dump_info (#2459)\n\n\t* tools/gif2tif.c: apply patch for CVE-2013-4243 (#2451)\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\t* libtiff/tif_jpeg.c: fix segfault in JPEGFixupTagsSubsampling() on\n\tcorrupted image where tif->tif_dir.td_stripoffset == NULL (bug #2471)\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\t* automake: updated to 1.14.1\n\t* libtool: updated to 2.4.3\n\t* HOWTO-RELEASE: small update about autotools building order\n\n2014-10-20  Olivier Paquet  <olivier.paquet@gmail.com>\n\t* tools/tiff2pdf.c: Preserve input file directory order when pages\n\tare tagged with the same page number.\n\n2014-08-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryOutputErr): Incorrect\n\tcount for tag should be a warning rather than an error since\n\terrors terminate processing.\n\n2014-06-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2rgba.c (]): Fixed tiff2rgba usage message in that zip\n\twas wrongly described.  Fix suggested by Miguel Medalha.\n\n2014-05-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirinfo.c (TIFFField) : Fix data type for\n\tTIFFTAG_GLOBALPARAMETERSIFD tag.  Patch by Steve Underwood.\n\tReviewed and forwarded by Lee Howard.\n\n2013-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fix last fix for TIFFNumberOfDirectories()\n\n2013-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: generate error in case of directory count\n\toverflow.\n\n2013-10-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h, libtiff/tif_dirinfo.c: add definitions for\n\tTIFF/EP CFARepeatPatternDim and CFAPattern tags (bug #2457)\n\n2013-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (TIFFAdvanceDirectory): If nextdir is found to\n\tbe defective, then set it to zero before returning error in order\n\tto terminate processing of truncated TIFF.  Issue found and fix\n\tsuggested by Richard Nolde.\n\n2013-08-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/gif2tiff.c: fix possible OOB write (#2452, CVE-2013-4244)\n\n2013-08-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/gif2tiff.c: Be more careful about corrupt or\n\thostile input files (#2450, CVE-2013-4231)\n\n\t* tools/tiff2pdf.c: terminate after failure of allocating\n\tycbcr buffer (bug #2449, CVE-2013-4232)\n\n2013-07-09  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tools/tiffinfo.c: Default various values fetched with\n\tTIFFGetField() to avoid being uninitialized.\n\n2013-05-02  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Rewrite JPEG marker parsing in\n\tt2p_process_jpeg_strip to be at least marginally competent.  The\n\tapproach is still fundamentally flawed, but at least now it won't\n\tstomp all over memory when given bogus input.  Fixes CVE-2013-1960.\n\n2013-05-02  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* contrib/dbs/xtiff/xtiff.c, libtiff/tif_codec.c,\n \tlibtiff/tif_dirinfo.c, tools/rgb2ycbcr.c, tools/tiff2bw.c,\n \ttools/tiff2pdf.c, tools/tiff2ps.c, tools/tiffcrop.c,\n \ttools/tiffdither.c: Enlarge some fixed-size buffers that weren't\n \tlarge enough, and eliminate substantially all uses of sprintf(buf,\n \t...)  in favor of using snprintf(buf, sizeof(buf), ...), so as to\n \tprotect against overflow of fixed-size buffers.  This responds in\n \tparticular to CVE-2013-1961 concerning overflow in tiff2pdf.c's\n \tt2p_write_pdf_page(), but in general it seems like a good idea to\n \tdeprecate use of sprintf().\n\n2013-03-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Applied patch by Brad Smith to improve pkg-config\n\tstatic linking by adding -lm to Libs.private when needed.\n\n2013-03-05  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* html/man/tiff2ps.1.html, html/man/tiffcp.1.html,\n \thtml/man/tiffdither.1.html, man/tiff2ps.1, man/tiffcp.1,\n \tman/tiffdither.1, tools/tiff2ps.c, tools/tiffcp.c,\n \ttools/tiffdither.c: Sync tool usage printouts and man pages with\n \treality (quite a few options had escaped being documented in one\n \tor both places).  Per an old report from Miroslav Vadkerti.\n\n2013-01-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2ps.c:Fix bug in auto rotate option code. Once a\n\trotation angle was set by the auto rotate check, it was retained\n\tfor all pages that followed instead ofa being retested for each\n\tpage.  Patch by Richard Nolde.\n\n2013-01-18  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_write.c: tmsize_t related casting warning fixed for\n\t64bit linux.\n\n\t* libtiff/tif_read.c: uint64/tmsize_t change for MSVC warnings.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2427\n\n2012-12-20  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* test/raw_decode.c: Relax raw_decode's pixel-value checks so that\n\tit will pass with more versions of libjpeg.  (There are at least\n\tthree in active use now, and JPEG_LIB_VERSION doesn't tell us\n\tenough to uniquely identify expected results.)\n\n2012-12-12  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/tif_print.c: Fix TIFFPrintDirectory's handling of\n\tfield_passcount fields: it had the TIFF_VARIABLE and\n\tTIFF_VARIABLE2 cases backwards.\n\n2012-12-10  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/ppm2tiff.c: Improve previous patch for CVE-2012-4564:\n \tcheck the linebytes calculation too, get the max() calculation\n \tstraight, avoid redundant error messages, check for malloc\n \tfailure.\n\n2012-12-10  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/tif_pixarlog.c: Improve previous patch for CVE-2012-4447\n \t(to enlarge tbuf for possible partial stride at end) so that\n \toverflow in the integer addition is detected.  Per gripe from\n \tHuzaifa Sidhpurwala.\n\n2012-12-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffset.c: tiffset now supports a -u option to unset a\n\ttag.  Patch by Zach Baker. See\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2419\n\n2012-11-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* automake: Update Automake to 1.12.5 release.\n\n\t* libtiff/tif_{unix,vms,win32}.c (_TIFFmalloc): ANSI C does not\n\trequire malloc() to return NULL pointer if requested allocation\n\tsize is zero.  Assure that _TIFFmalloc does.\n\n2012-11-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/ppm2tiff.c: avoid zero size buffer vulnerability.\n\tCVE-2012-4564 - Thanks to Huzaifa Sidhpurwala of the\n\tRed Hat Security Response team for the fix.\n\n2012-10-18  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tif_zip.c: Avoid crash on NULL error messages.\n\n2012-09-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.3 released.\n\n2012-09-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am: Update to Automake 1.12.4\n\n2012-08-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.in: Update to Automake 1.12.3\n\n\t* libtiff{tiff.h, tif_print.c, tif_dirinfo.c, tif_dirread.c}: Add\n\tsome TIFF/FX support in libtiff.  Add the tag definitions to\n\ttiff.h.  Add the related TIFF field definitions to tif_dirinfo.c,\n\tand also fixes an error in a comment.  Adds the photometric values\n\tto tif_print.c, and fixes a bug.  These changes are by Steve\n\tUnderwood.\n\n2012-08-13  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_write.c: Fix bug rewriting image tiles in a\n\tcompressed file: http://trac.osgeo.org/gdal/ticket/4771\n\n2012-08-02  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_dirread.c: report error in case of mismatch value\n\tcounts for tags (ie. DotRange).\n\n2012-07-26  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/{tiffio.h, tif_dirinfo.c, libtiff.def}: Add six new\n \tfunctions TIFFFieldTag(), TIFFFieldName(), TIFFFieldDataType(),\n\tTIFFFieldPassCount(), TIFFFieldReadCount(), TIFFFieldWriteCount()\n\tas external accessors for the opaque type TIFFField.\n\n\t* tools/tiffset.c: Make tiffset use the above functions instead of\n\trelying on library private headers.\n\n2012-07-19  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Fix two places where t2p_error didn't get set\n\tafter a malloc failure.  No crash risk AFAICS, but the program\n\tmight not report exit code 1 as desired.  h/t mancha@mac.hush.com\n\n2012-07-18  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Fail when TIFFSetDirectory() fails.  This\n\tprevents core dumps or perhaps even arbitrary code execution when\n\tprocessing a corrupt input file (CVE-2012-3401).\n\n2012-07-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/raw_decode.c (main): Test fixes to work with IJG JPEG 7+.\n\tIJG JPEG 7+ uses a different upsampling algorithm which produces\n\tdifferent numeric results.\n\n\t* libtiff/tif_jpeg.c (JPEGPreDecode): Patch from Even Rouault to\n\twork with IJG JPEG 7+.\n\n2012-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/raw_decode.c: Add changes so that test can run with build\n\tdirectory outside of source directory.\n\n2012-07-02  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: Fix handling when writing RGBA jpeg compressed\n\timagery (http://trac.osgeo.org/gdal/ticket/4732)\n\n2012-06-20  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_fax3.c: fix memory initialization of runs, only\n\tpartly done.\n\n\t* libtiff/tif_pixarlog.c: Make sure tbuf is large enough for one\n\tfull \"stride\" past the end.\n\n2012-06-19  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_packbits.c: fix read past end of data buffer.\n\n2012-06-15  Frank Warmerdam  <warmerdam@google.com>\n\n\t*  libtiff 4.0.2 released.\n\n\t* tools/tif2pdf.c, tools/tifdump.c: avoid unitialized variable\n\twarnings with clang.\n\n2012-06-15  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Defend against integer overflows while\n\tcalculating required buffer sizes (CVE-2012-2113).\n\n2012-06-12  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_print.c: Be careful about printing corrupt inknames.\n\n\t* libtiff/tif_fax3.c: Ensure runs array is initialized to zeros.\n\n2012-06-07  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_print.c: avoid pretty printing other fields when\n\twe don't have the proper amount and type of data or if the field\n\tis actually autodefined.\n\n2012-06-05  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_tile.c, libtiff/tif_strip.c: Ensure that illegal\n\tycbcrsubsampling values result in a runtime error, not just an\n\tassertion.\n\n\t* tests/custom_dir.c: Add testing of EXIF and custom directory\n\treading and writing.\n\n\t* libtiff/tif_dir.c, libtiff/tiffio.h: Add TIFFCreateCustomDirectory()\n\tand TIFFCreateEXIFDirectory() functions.\n\n\t* libtiff/tif_dir.c, tif_print.c : Remove FIELD_CUSTOM handling for\n\tPAGENUMBER, HALFTONEHINTS, and YCBCRSUBSAMPLING.  Implement DOTRANGE\n\tdifferently.  This is to avoid using special TIFFGetField/TIFFSetField\n\trules for these fields in non-image directories (like EXIF).\n\n2012-06-04  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: Remove code for fixing up h_sampling and v_sampling\n\tin JPEGPreDecode().  If a fixup will be done it needs to be done sooner\n\tin JPEGFixupTagsSubsampling() or else buffer sized may be wrong.\n\n2012-06-01  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tools/tiffinfo.c: Do not try to read image data in EXIF directories.\n\n\t* libtiff/tif_getimage.c: added support for _SEPARATED CMYK images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2379\n\n\t* libtiff/tif_unix.c: use strerror() to return a more specific error message\n\ton failed open.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2341\n\n\t* libtiff/tif_jpeg.c: Fix JPEGDecodeRaw() bugs.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2386\n\n\t* tests/decode_raw.c, tests/images/quad-tile.jpg.tiff: add limited support\n\tfor testing jpeg in tiff image decoding including the \"raw\" decode interface.\n\n2012-05-31  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: avoid overrunning the end of the output buffer in\n\tJPEGDecodeRaw() - mostly likely to occur when there is confusion about\n\tsampling values.\n\n\t* libtiff/tif_read.c: Make sure tif_rawdatasize is cleared when tif_rawdata is freed.\n\n\t* libtiff/tif_getimage.c: Add support for greyscale+alpha c/o J\u00e9r\u00e9mie Laval.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2398\n\n2012-05-29  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_dir.c: avoid using specific set/get logic to process fields in custom directories,\n\tlike EXIF directories.  This fixes problems like a tag \"320\" existing in a custom directory getting\n\tprocessed as if it were a colormap when it isn't really.  Damn the wide variety of argument formulations\n\tto get/set functions for different tags!\n\n\t* libtiff/tif_dir.c: Ensure that we keep track of when tif_rawdata\n\tis a pointer into an mmap()ed file via TIFF_BUFFERMMAP flag.\n\n2012-05-24  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_pixarlog.c: Allocate working buffer one word larger since we \"forward\n\taccumulate\" and overwrite the end by one word in at least some cases.\n\n2012-05-23  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_pixarlog.c: avoid accessing out of the lookup arrays for out of range inputs.\n\n\t* tools/tiffinfo.c: initialize h=0 to avoid undefined variable for degenerate files.\n\n\t* libtiff/tif_ojpeg.c: if OJPEGWriteHeader() fails once do not bother trying again on\n\tthe same image.\n\n\t* libtiff/tif_ojpeg.c: make things more resilient in the face of files without\n\tstripbytecounts or stripoffsets or where loading these fails.\n\n\t* libtiff/tif_print.c: be careful about whether min/max values are singular\n\tor one per sample.\n\n\t* libtiff/tif_print.c: Avoid confusion about count size when printing custom fields.\n\tMay affect things like ISOSpeedRatings.\n\n\t* libtiff/tif_dir.c: avoid one byte past end of ink names reading\n\tin some cases.\n\n2012-05-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* man/TIFFGetField.3tiff: Correct the 'count' field type in the\n\texample for how to retreive the value of unsupported tags.\n\n2012-03-30  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tif_getimage.c: Fix size overflow (zdi-can-1221,CVE-2012-1173)\n\tcare of Tom Lane @ Red Hat.\n\n2012-02-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.1 released.\n\n\t* Update automake used to 1.11.3.\n\n\t* libtiff/tiffio.h: Use double-underbar syntax in GCC printf\n\tattribute specification to lessen the risk of accidental macro\n\tsubstitution.  Patch from Vincent Torri.\n\n2012-01-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirread.c: Extra caution around\n\tassumption tag fetching is always successful.\n\n\t* libtiff/tif_jpeg.c: Extra caution for case where sp is NULL.\n\n2012-01-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Add support for using library symbol versioning on\n\tELF systems with the GNU linker.  Support is enabled via\n\t--enable-ld-version-script.  Disabled by default for now until\n\tthere is a decision for how to deploy a libtiff with versioned\n\tsymbols after libtiff 4.0.0 was already released.\n\n2011-12-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_win32.c: Eliminate some minor 64-bit warnings in\n\n\ttif_win32.c.  Patch by Edward Lam.\n\n\t* configure.ac: Add libtiff private dependency on -llzma for\n\tpkg-config.  Patch by Mark Brand.\n\tUpdated Automake to 1.11.2.\n\n2011-12-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0 released.\n\n2011-12-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c, libtiff/tif_read.c: more cautious checking\n\tof _TIFFFillStriles() results (#gdal 4372)\n\n2011-12-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: fixes to deal with invalid files where\n\t_TIFFFillStriles() fails, and we try to chop up strips (gdal #4372)\n\n\t* libtiff/tif_dirread.c: fix error reporting when there is no\n\ttag information struct and name (gdal #4373)\n\n2011-10-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Update GNU libtool to 2.4.2.\n\n\t* tools/tiffsplit.c (tiffcp): TIFFGetField count field should be\n\tuint32 type for TIFFTAG_JPEGTABLES.  Patch by Christophe\n\tDeroulers.\n\n2011-06-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Restore TIFFMergeFieldInfo.\n\n2011-05-31  Jim Meyering  <meyering@redhat.com>\n\n\t* libtiff/tif_dirread.c (TIFFFetchStripThing): Free \"data\" also\n\tupon failure to allocate \"resizeddata\".\n\t* tools/tiff2ps.c (PSDataBW): Zero buffer *after* checking for\n\tallocation failure, not before.\n\t* libtiff/tif_ojpeg.c: plug leaks on OJPEG read failure path\n\t* tools/rgb2ycbcr.c (cvtRaster): unchecked malloc\n\t* libtiff/tif_jpeg.c, tools/tiff2pdf.c, tools/tiff2ps.c: mark\n\tNULL-deref and possible overflow\n\t* tools/tiff2pdf.c: remove decl+set of set-but-not-used local, \"written\"\n\t* libtiff/tif_jpeg.c (JPEGInitializeLibJPEG): Remove declaration\n\tand set of otherwise unused local, data_is_empty.\n\t* libtiff/tif_jpeg.c (JPEGDecodeRaw) [JPEG_LIB_MK1_OR_12BIT]:\n\tDiagnose out-of-memory failure and return 0 rather than\n\tdereferencing NULL.\n\n2011-05-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: produce special error message for zero tag\n\tdirectories instead of error out on the malloc(0) failure.\n\n2011-05-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Restore TIFFMergeFieldInfo() and\n\trelated declarations as they are in active use by libraries\n\tsuch as libgeotiff, and work just fine.  (#2315)\n\n2011-04-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c,tiffio.h: Remove the obsolete\n\tTIFFMergeFieldInfo/TIFFFindFieldInfo/TIFFFindFieldInfoByName API.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2315\n\n\t* libtiff/libtiff.def: add some missing (64bit) APIs.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2316\n\n2011-04-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0beta7 released.\n\n2011-04-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Should use AC_CANONICAL_HOST since host specifies\n\tthe run-time target whereas target is used to specify the final\n\toutput target if the package is a build tool (like a compiler),\n\twhich libtiff is not.  Resolves libtiff bug 2307 \"Use\n\tAC_CANONICAL_HOST macro\".\n\n2011-04-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Support configuring TIFF_INT64_FORMAT and\n\tTIFF_UINT64_FORMAT appropriately for MinGW32.\n\n\t* tools/tiffdump.c (ReadDirectory): MinGW32 needs to use WIN32\n\tprintf conventions for 64-bit types because it uses the WIN32 CRT.\n\n\t* libtiff/{tif_dumpmode.c,tif_luv.c,tif_lzw.c,tif_print.c,\n\ttif_read.c,tif_strip.c,tif_thunder.c}: MinGW32 needs to use WIN32\n\tprintf conventions for 64-bit types because it uses the WIN32 CRT.\n\n\t* tools/tiff2pdf.c (t2p_write_pdf_string): Fix printf syntax not\n\tunderstood by WIN32 CRT.\n\n\t* libtiff/tif_ojpeg.c: Fixes to compile with MinGW32 GCC.\n\n\t* tools/fax2ps.c (main): Use tmpfile() rather than mkstemp() since\n\tit is much more portable.  Tmpfile is included in ISO/IEC\n\t9899:1990 and the WIN32 CRT.\n\n2011-03-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffset.c: add -d and -sd switches to allow operation on\n\ta particular directory, not just the first (jef).\n\n2011-03-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_thunder.c: Correct potential buffer overflow with\n\tthunder encoded files with wrong bitspersample set.  The libtiff\n\tdevelopment team would like to thank Marin Barbella and TippingPoint's\n\tZero Day Initiative for reporting this vulnerability (ZDI-CAN-1004,\n\tCVE-2011-1167).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2300\n\n2011-03-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.h: Fix to last change allowing zero length\n\truns at the start of a scanline - needed for legal cases.\n\n2011-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.h: Protect against a fax VL(n) codeword commanding\n\ta move left.  Without this, a malicious input file can generate an\n\tindefinitely large series of runs without a0 ever reaching the right\n\tmargin, thus overrunning our buffer of run lengths.  Per CVE-2011-0192.\n\tThis is a modified version of a patch proposed by Drew Yao of Apple\n\tProduct Security.  It adds an unexpected() report, and disallows the\n\tequality case, since emitting a run without increasing a0 still allows\n\tbuffer overrun.\n\n2011-02-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: avoid divide by zero in degenerate case (#2296)\n\n\t* tools/tiff2rgba.c: close source file on error to make leak\n\tdetection easier.\n\n\t* libtiff/tif_getimage.c: avoid leaks if TIFFRGBAImageBegin() fails.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2295\n\n2011-02-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzma.c: Maintain tif_rawcc/tif_rawcp (CHUNKY_STRING_READ\n\t_SUPPORT)\n\n2011-02-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure.ac, configure: Added support for --enable-chunky-strip-read\n\tconfigure option to enable the experimental feature from a couple\n\tmonths ago for reading big strips in chunks.\n\n\t* configure.ac, tif_read.c, tif_readdir.c, tif_dir.h, tiffiop.h,\n\ttif_write.c, tif_print.c, tif_jpeg.c, tif_dirwrite.c, tif_write.c:\n\tImplement optional support for deferring the load of strip/tile\n\toffset and size tags for optimized scanning of directories.  Enabled\n\twith the --enable-defer-strile-load configure option (DEFER_STRILE_LOAD\n\t#define in tif_config.h).\n\n2011-02-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: remove unused variable.\n\n2011-02-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_win32.c: avoid error/warning buffer overrun problem\n\twith non-console (popup message) builds on win32.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2293\n\n2011-01-24  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/{tif_dir.{h,c}, tif_dirinfo.c, tif_dirread.c, tif_dirwrite.c,\n\ttif_print.c, tiff.h, tiffiop.h} : Added support for\n\tTIFFTAG_SMINSAMPLEVALUE and TIFFTAG_SMAXSAMPLEVALUE to have different\n\tvalues for each sample. Presents the min/max of all samples by default for\n\tcompatibility. TIFFSetField/TIFFGetField can be made to handle those tags\n\tas arrays by changing the new TIFFTAG_PERSAMPLE pseudo tag.\n\thttp://www.asmail.be/msg0055458208.html\n\n2011-01-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_pixarlog.c: Note that tif_rawcc/tif_rawcp are not\n\tmaintained.\n\n\t* libtiff/tif_zip.c: Maintain tif_rawcc/tif_rawcp when decoding\n\tfor CHUNKY_STRIP_READ_SUPPORT.\n\n\t* libtiff/tif_jpeg.c: ensure that rawcc and rawcp are maintained\n\tduring JPEGPreDecode and JPEGDecode calls.\n\t* libtiff/tif_read.c: larger read ahead for CHUNKY_STRIP_READ_SUPPORT,\n\tas compression formats like JPEG keep 16 lines interleaved in a sense\n\tand might need to touch\tquite a bit of data.\n\n\thttp://trac.osgeo.org/gdal/ticket/3894\n\n2011-01-03  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: Fix regressions with 2 and 3 band images\n\tcaused by commit on 2010-12-14.  Submitted by e-mail from\n\tEven Rouault <even.rouault@mines-paris.org>\n\n2010-12-31  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirwrite.c: Fixed writing of TIFFTAG_REFERENCEBLACKWHITE.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2266\n\n2010-12-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c, man/tiffcp.1: Added support for specifying the\n\tcompression level parameter (preset) for Deflate and LZMA encoders,\n\te.g \"-c lzma:p1\" or \"-c zip:p9\".\n\n\t* libtiff/tif_lzma.c: Properly set the LZMA2 compression level\n\t(preset) in LZMAVSetField().\n\n2010-12-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/Makefile.am (libtiff_la_SOURCES): Added tif_lzma.c to\n\tMakefile.\n\n2010-12-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/{tif_codec.c, tif_config.h.in, tiff.h,\n\ttiffiop.h, tif_lzma.c}, tools/tiffcp.c, man/tiffcp.1: Implement a new\n\tTIFF compression scheme LZMA reserving a new value 34925 for\n\tCompression tag. As per\n\tbug http://bugzilla.maptools.org/show_bug.cgi?id=2221\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: tolerate some cases where\n\tFIELD_COLORMAP is missing\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2189\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_read.c: change read_ahead to tmsize_t\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2222\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* configure.ac, libtiff/Makefile.am: Build tif_win32.c on\n\tWindows except on Cygwin\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2224\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/gif2tiff.c: fix buffer overrun\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2270\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: reduce usage of JCS_UNKNOWN in order\n\tto improve compatibility with various viewers\n\tsubmitted by e-mail from Dwight Kelly <dkelly@apago.com>\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/fax2ps.c: be consistent with page-numbering\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2225\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_color.c: prevent crash in handling bad TIFFs\n\tresolves CVE-2010-2595\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2208\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiffcrop.c: new release by Richard Nolde\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2004\n\n2010-12-12  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: fix colors for images with RGBA\n\tinterleaved data\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2250\n\n2010-12-12  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: fix for Zeiss LSM and Canon CR2 files\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2164\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: remove invalid duplication for Lab\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2162\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: fix use of clumplines calculation\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2149\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/fax2ps.c: replace unsafe tmpfile() with mkstemp()\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2118\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_ojpeg.c, libtiff/tif_pixarlog.c,\n\t  libtiff/tif_zip.c: fix build errors for VC6\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2105\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_stream.cxx: warnings cleanup\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2091\n\t* libtiff/tif_dirread.c: warnings cleanup\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2092\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: add fill-page option\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2051\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: modify warnings\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2016\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_ojpeg.c: fix buffer overflow on problem data\n        http://bugzilla.maptools.org/show_bug.cgi?id=1999\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiffinfoce.c: strip byte counts are uint64* now\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_ojpeg.c: fix crash when reading a TIFF with a zero\n        or missing byte-count tag\n        * tools/tiffsplit.c: abort when reading a TIFF without a byte-count\n        per http://bugzilla.maptools.org/show_bug.cgi?id=1996\n\n2010-12-08  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_dirread.c: fix crash when reading a badly-constructed\n        TIFF per http://bugzilla.maptools.org/show_bug.cgi?id=1994\n\n2010-12-06  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_open.c: Fix mode check before opening a file.\n        http://bugzilla.maptools.org/show_bug.cgi?id=1906\n\n2010-11-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff-4.pc.in: Added libtiff pkg-config .pc file support.\n\tPatch by Vincent Torri.\n\n2010-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffinfo.c: avoid direct reference to _TIFFerrorHandler.\n\n\t* libtiff/tif_config.vc.h: define snprintf to _snprintf for tiff2pdf.\n\n\t* libtiff/libtiff.def: export _TIFFCheckMalloc for tools.\n\n2010-09-25  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2ps.c: improvements and enhancements from Richard Nolde\n\twith additional command line options for Document Title,\n\tDocument Creator, and Page Orientation\n\n2010-07-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Patch from Richard Nolde to avoid a\n\tpotentially unterminated buffer due to using an exceptionally long\n\tfile name.\n\n2010-07-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Fixed ID buffer filling in\n\tt2p_write_pdf_trailer(), thanks to Dmitry V. Levin.\n\n2010-07-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Really reset the tag count in CheckDirCount()\n\tto expected value as the warning message suggests. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1963\n\n2010-07-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Properly handle TIFFTAG_PAGENUMBER,\n\tTIFFTAG_HALFTONEHINTS, TIFFTAG_YCBCRSUBSAMPLING, TIFFTAG_DOTRANGE\n\twhich should be set by value.\n\n\t* libtiff/tif_dirinfo.c: Don't use assertions in _TIFFFieldWithTag()\n\tand _TIFFFieldWithName() if the tag is not found in the tag table.\n\tThis should be normal situation and returned NULL value should be\n\tproperly handled by the caller.\n\n2010-07-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Avoid wrong math du to the signed/unsigned\n\tinteger type conversions. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2207\n\n\t* tools/{tiff2bw.c, thumbnail.c, pal2rgb.c}: Fix the count for\n\tWhitePoint tag as per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2042\n\n\t* libtiff/tif_getimage.c: Check the number of samples per pixel when\n\tworking with YCbCr image in PickContigCase(). As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2216\n\n\t* libtiff/tif_dir.c: Set the bogus post-decoding hook when processing\n\tTIFFTAG_BITSPERSAMPLE in _TIFFVSetField() for the case of 8 bit when\n\twe don't need any post-processing. That helps to reset the hook if we\n\tpreviously set this field to some other value and the hook was\n\tinitialized accordingly. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2035\n\n2010-07-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffgt.c: Properly check the raster buffer allocations for\n\tinteger overflows. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2108\n\n\t* m4/acinclude.m4: Update GL/GLU/GLUt/Pthread macros from the\n\tupstream.\n\n\t* libtiff/{tif_aux.c, tif_strip.c, tif_tile.c, tiffiop.h}: Move\n\tmultiply_32() and multiply_64() functions into tif_aux.c file and\n\trename them into _TIFFMultiply32() and _TIFFMultiply64() respectively.\n\n2010-06-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Better generation of ID field in\n\tt2p_write_pdf_trailer(). Get rid of GCC aliasing warnings.\n\n\t* tools/tiff2pdf.c: Fixed computation of the tile buffer size when\n\tconverting JPEG encoded tiles.\n\n\t* tools/tiff2pdf.c: Better handling of string fields, use static\n\tstring buffers instead of dynamically allocated, use strncpy() instead\n\tof strcpy(), control the string lengths.\n\n2010-06-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Initialize buffer arrays with zero to avoid\n\treferencing to uninitialized memory in some cases (e.g. when tile size\n\tset bigger than the image size).\n\n2010-06-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Patch from Richard Nolde. Reject YCbCr\n\tsubsampled data since tiffcrop currently doesn't support it.  Fix\n\tJPEG support.\n\n2010-06-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Fix invocation of tag compare function (#2201)\n\n\t* tools/tiff2pdf.c: Fix assorted bugs in tiff2pdf: missing \"return\"\n\tin t2p_read_tiff_size() causes t2p->tiff_datasize to be set entirely\n\twrong for COMPRESSION_JPEG case, resulting in memory stomp if actual\n\tsize is larger.  Also, there are a bunch of places that try to\n\tmemset() a malloc'd buffer before checking for malloc failure, which\n\twould result in core dump if there actually were a failure. (#2211)\n\n2010-06-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): Need more castings to\n\tavoid compiler warnings if parameter types are not sign\n\tconsistent.\n\n\t* libtiff 4.0.0alpha6 released.\n\n\t* tools/tiffcrop.c: Applied patch from Richard Nolde: Corrected\n\tEuropean page size dimensions.  Added an option to allow the user\n\tto specify a custom page size on the command line.  Fix the case\n\twhere a page size specified with a fractional part was being\n\tcoerced to an integer by retyping the variables that define the\n\tpaper size.\n\n\t* html/index.html: Update for the 3.9.3 release.\n\n\t* tools/tiffcp.c (tiffcp): Applied Tom Lane's patch to reject\n\tYCbCr subsampled data since tiffcp currently doesn't support it.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2097\n\n\t* Update libtool to version 2.2.10.\n\n2010-06-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): Work properly if\n\tmultiplier is zero.\n\n2010-06-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_fax3.c (Fax3SetupState): Yesterday's fix for\n\tCVE-2010-1411 was not complete.\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): New macro to safely\n\tmultiply two integers.  Returns zero if there is an integer\n\toverflow.\n\n\t* tools/tiffcp.c (main): tiffcp should not leak memory if an error\n\tis reported when reading the input file.\n\n2010-06-08  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Update libtool to version 2.2.8.\n\n\t* libtiff/tif_fax3.c (Fax3SetupState): Avoid under-allocation of\n\tbuffer due to integer overflow in TIFFroundup() and several other\n\tpotential overflows.  In conjunction with the fix to TIFFhowmany(),\n\tfixes CVE-2010-1411.\n\n\t* libtiff/tiffiop.h (TIFFhowmany): Return zero if parameters would\n\tresult in an integer overflow. This causes TIFFroundup() to also\n\treturn zero if there would be an integer overflow.\n\n\t* contrib: Add an emacs formatting mode footer to all source files\n\tso that emacs can be effectively used.\n\n2010-06-03  Oliver Chen Feng <scip8183@gmail.com>\n\n\t* libtiff/tools/tiffcp.c: add a new option -x to force merged tiff\n\tfile PAGENUMBER value in sequence for users who care the page\n\tsequence, this will also prevent tiff2pdf from creating pdf file from\n\tthe merged tiff file with wrong page sequence.\n\n2010-05-08  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirread.c: Restored TIFFReadDirEntryFloat function in order\n\tto add missing TIFF_SETGET_FLOAT case to TIFFFetchNormalTag.\n\t* libtiff/tif_dirinfo.c: Use correct set_field_type for\n\tTIFFTAG_PIXAR_FOVCOT so it is readable again (regression from 3.9.2).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2192\n\n2010-05-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Ensure that quality is always set in\n\tJPEGPreEncode(), not just when we want to output local tables.\n\tOtherwise the quality used during compression may not be right and\n\tmight not match the tables in the tables tag.   This bug only occurs\n\twhen seeking between directories in the midst of writing blocks.\n\thttp://trac.osgeo.org/gdal/ticket/3539\n\n2010-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* html/man/TIFFGetField.3tiff.html, html/man/TIFFSetField.3tiff.html:\n\tRegenerated from the source.\n\n2010-05-05  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_print.c: Fixed printing of TIFFTAG_REFERENCEBLACKWHITE which\n\thad stopped working. Also made it always print 6 floats instead of\n\t2*SamplesPerPixel.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2191\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2186\n\t* man/TIFFGetField.3tiff, man/TIFFSetField.3tiff: Fixed doc to reflect the\n\tfact that libtiff considers TIFFTAG_REFERENCEBLACKWHITE to be 6 floats.\n\n2010-05-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Fix to use memcmp(), not memcpy() when checking\n\tif the jpeg table was written.  This is a fix for the last fix on 04-21.\n\n2010-04-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: avoid preparing jpeg tables everytime\n\tJPEGSetupEncode() is called if the tables already seem to be\n\testablished.  This prevents spurious updates and rewriting of\n\tdirectories with jpegtables when doing updates to existing images.\n\thttp://trac.osgeo.org/gdal/ticket/3539\n\n2010-04-20  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirinfo.c: Use correct set_field_type for\n\tTIFFTAG_PIXAR_IMAGEFULLWIDTH, TIFFTAG_PIXAR_IMAGEFULLLENGTH,\n\tTIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN and TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA.\n\tThey were unreadable with TIFF_SETGET_UNDEFINED, a regression from 3.9.2.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2139\n\n2010-04-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (_TIFFVSetField): Add a special error case for\n\twhen the tag count value is zero.  Error handling is still a\n\tregression since in 3.9.2, empty tags are skipped (with a warning)\n\trather than returning a hard error and refusing to read the file.\n\n\t* tools/ppm2tiff.c (main): While case for parsing comment line\n\trequires extra parenthesis to work as expected.  Reported by\n\tThomas Sinclair.\n\n2010-04-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_read.c (primarily): Add support for\n\tCHUNKY_STRIP_READ_SUPPORT where large strips are\n\tread in chunks for applications using TIFFReadScanline().\n\tThis is intended to make it more practical work with very\n\tlarge compressed one-strip files.   Feature is off by default.\n\tEnable by defining CHUNK_STRIP_READ_SUPPORT as a macro.\n\thttp://trac.osgeo.org/gdal/ticket/3514\n\n2010-03-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_flush.c: Use TIFFRewriteDirectory() when flushing\n\tdirectories so previously placed directories will be migrated to\n\tthe end of file if needed.\n\n2010-03-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: change type of dec_bitsleft field to uint64\n\tto support operating on strips/tiles of more than 256MB.\n\thttp://trac.osgeo.org/gdal/ticket/3512\n\n2010-03-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_aux.c (_TIFFCheckRealloc): Improve error message so\n\tthat it is clearly a memory allocation error message, and also\n\tincludes the size of the allocation request.\n\n2010-02-22  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: Do not generate a JPEGTables tag when creating\n\tthe JPEG TIFF as is is not required in order to prevent it from\n\tbeing unused and filled with invalid data.  (Leave it to be\n\tgenerated by later activity.)\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2135\n\t* tools/tiff2pdf.c: Write the JPEG SOI headers into the TIFF strip\n\tdata rather than skipping them.  This fixes the ability to view in\n\tAcrobat Reader, Evince, and Ghostscript.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2135\n\t* libtiff/tif_fax3.c: Don't return error on badly-terminated MMR\n\tstrips.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2029\n\n2009-12-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Made JPEGDecodeRaw() check for buffer overruns.\n\tMade so that when working with downsampled images a stub function\n\treporting an error is used for tif_decoderow.  We cannot meaningfully\n\tsupport reading scanlines in this situation.  (#1936)\n\n\t* libtiff/tif_jpeg.c: Ensure that tif_scanlinesize is computed after\n\tresetting of the upsampling values (gdal:#3259).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1936\n\n2009-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/dbs/tiff-grayscale.c, contrib/tif-palette.c,\n\ttools/ras2tiff.c: Fix resource leaks on error.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2121\n\n\t* libtiff/tif_{aux.c,dir.c,dir.h,dirinfo.c}: Return to handling\n\tTIFFTAG_REFERENCEBLACKWHITE as a field in the TIFF directory instead\n\tof as a custom(generic) field to avoid a potential reentrancy problem.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2125\n\n\t* libtiff/tif_color.c, libtiff/tif_getimage.c, libtiff/tiffio.h,\n\tman/TIFFcolor.3tiff: Make TIFFDisplay argument in TIFFCIELabToRGBInit\n\tconst, and display_sRGB static and const.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2124\n\n2009-11-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0alpha5 released.\n\n2009-11-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Updated tiffcrop from Richard Nolde.  This\n\tversion has undergone substantial testing with arbitrary sample\n\tbit depths.  Also eliminates GCC compilation warnings.\n\n2009-11-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* port/libport.h: Add extern declarations for getopt standard\n\tglobals.\n\n2009-10-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_lzw.c (LZWDecode, LZWDecodeCompat): Fix warnings\n\tnoticed in 64-bit build of libtiff with Visual Studio 2005.\n\tResolves \"Bug 2067 - Visual Studio 2005 64-bit warnings in\n\ttif_lzw.c\", http://bugzilla.maptools.org/show_bug.cgi?id=2067\n\n\t* libtiff/tif_pixarlog.c (PixarLogEncode): Fix non-important\n\twarning noticed in Visual Studio 2005 build. Resolves \"Bug 2068 -\n\tVisual Studio 2005 64-bit warning in tif_pixarlog.c\",\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2068\n\n2009-10-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c: Eliminate GCC \"dereferencing type-punned\n\tpointer\" warnings.\n\n2009-10-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/tools.html: Add manual page links, and a summary\n\tdescription of tiffcrop.\n\n2009-10-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: x86_64 should use the same fill order as i386.\n\n2009-09-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: New tiffcrop from Richard\n\tNolde.  Major updates to add significant functionality for reading\n\tand writing tile based images with bit depths not a multiple of 8\n\twhich cannot be handled by tiffcp.\n\n2009-09-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_ojpeg.c (OJPEGWriteHeaderInfo): IJG JPEG 7 needs\n\tdo_fancy_upsampling=FALSE in order to read raw data.  Resolves\n\t\"Bug 2090 - OJPEG crash with libjpeg v7\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2090\n\n2009-09-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Fixed error recognition handling in RGBA\n\tinterface when stoponerror is set.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2071\n\n2009-08-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/{tiffcrop.c,tiffgt.c}: Applied patch from Oden Eriksson to\n\tfix build with gcc when using the \"-Wformat\n\t-Werror=format-security\" flags.\n\n2009-08-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/{bmp2tiff_palette.sh, bmp2tiff_rgb.sh, gif2tiff.sh,\n\tppm2tiff_pbm.sh, ppm2tiff_pgm.sh, ppm2tiff_ppm.sh}: Additional\n\tutilities tests.\n\n2009-08-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffinfo.c: tiffinfo should return error status to the\n\tcaller.  Register a private error callback to accomplish that.\n\n\t* test/Makefile.am (TIFFIMAGES): Add test images in BMP, GIF, and\n\tPNM formats so that we will be able to test more of the tools.\n\tWhile adding these test images I notice that bmp2tiff and gif2tiff\n\tonly support ancient versions of their respective formats.\n\n2009-08-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0alpha4 released.\n\n\t* HOWTO-RELEASE: Improved release instructions.\n\n2009-08-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* man/{TIFFClose.3tiff,raw2tiff.1,tiffcmp.1,tiffsplit.1}: Applied\n\tfixes for \"Bug 2023 - nroff errors in manual pages\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2023\n\n\t* tools/{rgb2ycbcr.c, tiff2rgba.c}: Applied fixes for \"Bug 2079 -\n\tCVE-2009-2347 libtiff: integer overflows in various inter-color\n\tspace conversion tools\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2079\n\n\t* libtiff/tif_print.c (TIFFPrintDirectory): Apply fix from Jay\n\tBerkenbilt for \"Bug 2024 - possible null pointer dereference with\n\tone-line fix\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2024\n\n\t* libtiff/tif_dirread.c (TIFFReadCustomDirectory): Apply patch\n\tfrom Jay Berkenbilt for \"Bug 1895 - logic error in tif_dirread.c:\n\tsegfault after setting tdir_tag = IGNORE\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1895\n\n2009-08-23  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am, test/tiffcrop*.sh: Split previously existing\n\ttiffcrop.sh into a collection of many specific tests.  Re-wrote\n\tall of the existing tests to be based on some simple shell\n\tfunctions.  Make distcheck works again.\n\n\tExport certain variables (MAKE, MAKEFLAGS, MEMCHECK) to tests and\n\tadded 'memcheck' and 'ptrcheck' targets to make it easy to run the\n\ttests under valgrind.\n\n2009-08-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/tiffcp-logluv.sh: Fix test so that it works with a VPATH\n\tbuild.\n\n\t* test/Makefile.am (AUTOMAKE_OPTIONS): Colorized tests was not\n\tactually activated since it needed to be enabled in this\n\tMakefile.am.  Also activated parallel-tests mode since it offers\n\tuseful features such as per-test .log files and a summary test\n\treport .log file.\n\n2009-08-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Updated autotools.  Autoconf 2.64, Automake 1.11,\n\tlibtool 2.2.6.  Enabled support for silent build rules\n\t(--enable-silent-rules or 'make V=0') and colorized tests.\n\n\t* html/{index.html, v3.9.0.html}: Update for 3.9.0 release.\n\n2009-06-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tests/tiffcp-logluv.sh: minimal testing of sgilog compression.\n\n\t* tools/tiffcp.c: add -c sgilog support.\n\n\t* libtiff/tif_luv.c: correct return codes from encoderow to be\n\t1 on success instead of zero.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2069\n\n\t* libtiff/tif_lzw.c: back out patch from #2065 and apply patch from\n\t#1085 for a better underflow fix that errors properly.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2065\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1985\n\n2009-06-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_strip.c: Remove an inappropriate assertion that often\n\tfails on oddly sized 12bit jpeg compressed ycbcr images.\n\n2009-06-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: Fix buffer underflow bug.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2065\n\n2009-06-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure.ac, libtiff/tif_jpeg.c, libtiff/tif_jpeg_12.c: add support\n\tfor dual mode 8/12 bit jpeg support.\n\n2009-06-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: do not override the planar configuration to be\n\tcontig for one sample files if planar configuration is already set.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2057\n\n2009-06-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Add TIFFUnsetField.\n\n2009-05-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tif_jpeg.c,tif_ojpeg.c,tif_getimage.c}: Fixed various\n\terror reports to use \"%s\" as format string.\n\thttp://trac.osgeo.org/gdal/ticket/2976\n\n2009-03-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tif_fax3.c,tif_jpeg.c,tif_ojpeg.c}: Fix printdir chaining\n\tfor some codecs (#2020).\n\n2009-02-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_luv.c: Fix handling of tiled logluv images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2005\n\n2009-02-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Improve allocation safety when allocated\n\tbuffer for large tags.  (#1998)  Related to (#1993)\n\n2009-02-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffcrop.c: Don't default image->res_unit to INCH.  Now the\n\ttest suite should pass.\n\n2009-02-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Re-incorporated a sanity check on tag size,\n\tbut at the 2GB boundary to avoid overflow on 32bit systems.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1993\n\n\t* libtiff/tif_dirread.c: Remove some assertions that blow due to\n\tcorrupt files rather than in response to library internal\n\tinconsistencies.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1995\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1991\n\n\t* libtiff/tif_dirread.c: Fixed testing for failed result from\n\tTIFFReadDirectoryFindFieldInfo().\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1992\n\n2009-01-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_predict.c: Add support for 32bit integer horz. predictors.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1911\n\n\t* libtiff/tif_dirwrite.c: Fix byte swapping of next directory offset.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1924\n\n\t* tools/tiffcrop.c: initialize xres/yres values.\n\n\t* test/*.sh - default ${srcdir} to local directory.\n\n\t* test/common.sh - start verbose mode after common settings.\n\n\t* libtiff/tif_dirinfo.c: Replace lfind() with local equivelent to\n\tavoid type mismatches on different platforms.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1889\n\n2009-01-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/{fax2tiff.c,thumbnail.c,tiff2pdf.c,tiff2ps.c,tiffdump.c,\n\ttiffsplit.c}: avoid warnings, mostly 32bit/64bit casting issues.\n\n\t* port,tools: Introduce libport.h, and include in tools if NEED_LIBPORT\n\tdefined, primarily to reduce prototype warnings on windows.\n\n\t* libtiff/tif_dirinfo.c,tif_dirread.c: Avoid warnings\n\tabout unused parameters, and uninitialized variables.\n\n2009-01-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/common.sh: Execute tests like 'make VERBOSE=TRUE check' in\n\torder to trace full execution detail while executing the test suite.\n\n2009-01-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffsplit.c: fix sampleformat to be shortv instead of longv.\n\n2009-01-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am (CLEANFILES): Make sure that test output files\n\tare removed by 'make clean'\n\n\t* Update autotools for 4.0.0 beta3\n\n\t* 4.0.0 beta3 produced.\n\n2009-01-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/tiffcrop.sh: New test script for tiffcrop from Richard\n\tNolde.\n\n\t* tools/tiff2ps.c: Remove spurious message to stderr.\n\n2009-01-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2ps.c: Incorporated significant functionality update\n\tfrom Richard Nolde.  In particular, support for rotating the image\n\tby 90, 180, 270, and 'auto' has been added.\n\n\t* man/tiffcrop.1: Incorporated documentation updates from Richard\n\tNolde.\n\n\t* tools/tiffcrop.c: Incorporated significant functionality update\n\tfrom Richard Nolde.\n\n2008-12-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffio.h: GCC will now validate format specifications\n\tfor TIFFError(), TIFFErrorExt(), TIFFWarning(), and\n\tTIFFWarningExt() in order to reveal bugs.\n\n\t* Many fixes throughout to work better as a 64-bit build.\n\n2008-12-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/{tiff2pdf.c, tiff2ps.c, tiffinfo.c}: Offset and length\n\ttags now require 64-bit parameter rather than 32-bit.\n\n\t* libtiff/tif_dirread.c: Fixed issues with unaligned access to\n\t64-bit values.\n\n\t* tools/thumbnail.c: Eliminate crash noticed while running test\n\tsuite.\n\n2008-12-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_ojpeg.c (OJPEGLibjpegJpegSourceMgrFillInputBuffer):\n\tInitialize stack variables to avoid compiler warning.\n\n\t* tools/tiffinfoce.c (main): Use toff_t for offset type when\n\tretrieving offset of EXIF IFD.\n\n\t* libtiff/tiffio.h: Undeprecate toff_t and restore its use in the\n\tTIFFClientOpen() callback and other external function definitions.\n\n\t* tools/tiffinfo.c (main): Offset to EXIF IFD requires a 64-bit\n\ttype now.  Fixes crash when dumping files containing an EXIF IFD.\n\n\t* m4/libtool.m4: Update to libtool 2.2.6.\n\n2008-12-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c, tiffio.h: Introduce TIFFUnsetField() function.\n\n\t* libtiff/tif_jpeg.c: Avoid errors if the application writes a full\n\tstrip for the last partial strip in a jpeg compressed file.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1981\n\n2008-10-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_flush.c: Make sure that BEENWRITING is cleared when\n\twe take the shortcut to only update the strip/tile offsets in place.\n\thttp://trac.osgeo.org/gdal/ticket/2621\n\n2008-10-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jbig.c: Support the JBIG-KIT 2.0 (compatibility with\n\tthe older versions retained).\n\n2008-10-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Add #ifdefs for changes needed if using\n\tIPP enabled version of libjpeg from Intel.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1951\n\n2008-09-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Use byte counts of proper size (uint64).\n\tRequired for libtiff 4.0.\n\n\t* tools/tiffsplit.c: Use dynamically allocated array instead of static\n\twhen constructing output file names.\n\n2008-09-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Get rid of unsafe strcpy()/strcat() calls when\n\tdoing the filename/path construction.\n\n\t* tools/tiff2pdf.c: More appropriate format string in\n\tt2p_write_pdf_string(); avoid signed/unsigned mismatch.\n\n\t* libtiff/tif_lzw.c: Properly zero out the codetable. As per bug\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1929\n\n\t* libtiff/tif_lzw.c: Properly zero out the string table. Fixes\n\tCVE-2008-2327 security issue.\n\n2008-09-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Avoid unused TIFFReadDirEntryFloat() function.\n\n\t* libtiff/tif_dirwrite.c: modified to write IFDs as either IFD8 or IFD\n\tdepending on whether the file is bigtiff or classic tiff.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1917\n\n2008-08-12  Edward Lam  <edward@sidefx.com>\n\n\t* tools/tiffdump.c: When compiling for Microsoft Windows, apply\n\tconsistent (__int64) casting when testing if _lseeki64 has\n\tsuccessfully seeked as requested.  This is necessary for large\n\tfile support to work since off_t is only 32-bit.\n\n2008-07-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_strip.c: Replace assertions related to samplesperpixel != 3 or\n\tthe subsampling values not being 1, 2 or 4 (for jpeg compressed images)\n\twith control logic to return runtime errors (c/o Even Rouault) (#1927).\n\n2008-06-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffcrop.c: Fix some portability problems.\n\n\t* libtiff/tif_ojpeg.c: Use same jpeg/win32 boolean/FAR hacks as are\n\tused in tif_jpeg.c.\n\n\t* libtiff/tif_win32.c: Ensure TIFFOpenW() uses same FILE_SHARE flags\n\tas TIFFOpen().\n\n2008-06-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Fix alignment problems affecting architectures\n\tlike Sparc/Solaris.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1892\n\n2008-05-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff.def: Add TIFFFindField\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1891\n\n2008-05-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_config.*.h, tiffconf.*.h: Remove SIZEOF_LONG definition, unused.\n\n\t* li2008-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\nbtiff/tif_win32.c: Replace custom Win32 memory api with generic\n\tPOSIX one.  No apparent value to use of GlobalAlloc() in the modern\n\tage.  http://bugzilla.maptools.org/show_bug.cgi?id=1885\n\n\t* libtiff/tiffconf.vc.h: Added JBIG_SUPPORT and MDI_SUPPORT items\n\tin windows version (care of Edward Lam).\n\n2008-05-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_codec.c: Avoid NULL pointer dereferencing for exotic\n\tcompression codec codes.\n\n\t* tif_dirwrite.c: fix potential memory leak.\n\n\t* tif_dirread.c: Fix unchecked malloc result.\n\n2008-05-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test {tiff2pdf.sh tiff2ps-EPS1.sh tiff2ps-PS1.sh tiff2ps-PS2.sh\n\ttiff2ps-PS3.sh tiffcp-g3-1d-fill.sh tiffcp-g3-1d.sh\n\ttiffcp-g3-2d-fill.sh tiffcp-g3-2d.sh tiffcp-g3.sh tiffcp-g4.sh\n\ttiffcp-split-join.sh tiffcp-split.sh tiffcp-thumbnail.sh\n\ttiffdump.sh tiffinfo.sh}: Added more test scripts based on\n\tsuggestions from Lee Howard posted to the tiff list on 13 Sep\n\t2007.\n\n2008-05-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.c: Add an assert in an effort to detect a\n\tpossible runtime problem reported by coverity.\n\n\t* contrib/iptcutil/iptcutil.c: Fixed memory leak of str.\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: Major update from Richard Nolde.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1888\n\n\t* tools/tiffdither.c: remove dead onestrip code.  avoid memory leak.\n\n\t* tools/rgb2ycbcr.c: fix memory leak of raster buffer.\n\n\t* tools/tiffcp.c: Simplify inknames code to avoid pointless test.\n\tCleanup scanline allocation to avoid coverity warning.\n\n\t* tools/thumbnail.c: Check for TIFFOpen() failure.\n\n2008-05-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Use TIFF_SETGET_ASCII for PIXAR_TEXTUREFORMAT\n\tand PIXAR_WRAPMODES instead of TIFF_SETGET_UNDEFINED.  Not exactly clear\n\twhy this is needed.\n\n2008-05-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am (ACLOCAL_AMFLAGS): Libtool 2.2.4 does not like\n\t\"ACLOCAL_AMFLAGS=-I ./m4\".  It wants \"ACLOCAL_AMFLAGS=-I m4\".\n\n2008-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* test/: Test suite updated. Everything is passed now.\n\n\t* libtiff/tif_dirinfo.c: Fixed description of the\n\tTIFFTAG_NUMBEROFINKS tag.\n\n2008-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_dirwrite.c, tiffiop.h}:\n\tGet rid of some of \"dereferencing type-punned\" warnings by converting\n\ttdir_offset field of TIFFDirEntry structure into union.\n\n2008-04-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_flush.c, tif_dirwrite.c, tiffio.h, tiffiop.h}:\n\tTIFFRewriteField() renamed into _TIFFRewriteField() and moved out\n\tfrom the public interface. Type of its 'count' parameter changed\n\tfrom uint32 to tmsize_t.\n\n\t* /libtiff/tiffiop.h: Make tif_nfields and tif_nfieldscompat fields\n\tof the tiff structure have the size_t type instead of uint32.\n\n2008-04-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Added support for MSVS 6.0.\n\n\t* libtiff/tif_dirread.c: Use custom functions _TIFFUInt64ToFloat()\n\tand _TIFFUInt64ToDouble() to convert 64-bit integers into floating\n\tpoint values on MSVS 6.0 platform.\n\n2008-03-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: Removed sanity checks on tags larger than 4MB in\n\tTIFFReadDirEntryArray() since they are interfering with seemingly\n\tlegitimate files.  http://trac.osgeo.org/gdal/ticket/2005\n\n2008-02-09  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Added handling for the case of number of values for\n\tPageNumber tag different from 2 (previously resulted in an assert\n\tindicating lack of handling and was forgotten about)\n\n2008-02-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Do not try to fixup subsampling tags based on\n\tthe actual jpeg data stream if the first strip/tile has zero size.\n\tThis is the case when GDAL creates a new file with zero sizes, closes\n\tand reopens it.\n\n2008-01-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c: fix up 64bit issues (from Edward Lam).\n\n2008-01-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: #ifdef out lots of unused functions.\n\n\t* Makefile.vc, libtiff/Makefile.vc, tools/Makefile.vc: Improve clean\n\ttargets.\n\n\t* tools/tiffinfo.c, tools/tiffcmp.c, tools/gif2tiff.c, tools/bmp2tiff.c\n\ttools/tiff2pdf.c: Fix 64-bit warnings when compiling under MSVC 2005\n\t(x64).\n\n\t* tools/tiffset.c: Changes to reflect the fact that TIFFFieldWithTag()\n\tand TIFFFieldWithName() now return TIFFField pointers instead of\n\tTIFFFieldInfo pointers.\n\n\t* tools/tiffdump.c: Added ssize_t typedef on Windows since it doesn't\n\texist. This makes it compile again on Windows\n\n\t* tif_aux.c, tif_getimage.c, tif_next.c, tif_predict.c, tif_win32.c,\n\ttiffconf.vc.h: Various 64bit fixes from Edward Lam identified on win64.\n\n\t* test/rewrite_tag.c: New test for TIFFRewriteField().\n\n2007-12-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Added TIFFRewriteField().  This new function\n\trewrites one field \"on disk\" updating an existing directory\n\tentry.  Lots of limitations still...\n\n\t* tiffiop.h, tif_write.c, tif_dirread.c, tif_flush.c: Keep track of\n\tTIFF_DIRTYSTRIP separately from TIFF_DIRTYDIRECT to indicate that\n\tthe strip offset/size values are dirty but nothing else about the\n\tdirectory is dirty.  In flush handle \"just stripmaps dirty\" as a\n\tspecial case that just rewrites these values without otherwise\n\tmodifying the directory on disk using TIFFRewriteField().\n\n\tWe also modify logic so that in update mode the directory is not\n\tmarked dirty on read, but only when something is changed.  This\n\tmeans we need to keep track of updates to the stripmap stuff in\n\tTIFFAppendToStrip().\n\n2007-12-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_jpeg.c: Improve ability to switch between encoding and decoding\n\tin the jpeg code (gdal bug #2033).\n\n2007-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dir.c, tif_dirread.c, tif_dirwrite.c, tif_read.c, tif_write.c,\n\ttiffiop.h: Added TIFF_BUF4WRITE flag to indicate if contents of the\n\trawcp/rawcc buffer are for writing and thus may require flushing.\n\tNecessary to distinguish whether they need to be written to disk when\n\tin mixed read/write mode and doing a mixture of writing followed by\n\treading.  http://trac.osgeo.org/gdal/ticket/1758\n\n2007-11-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.com, libtiff/tif_vms.c: Better OpenVMS support. Patches\n\tfrom Alexey Chupahin.\n\n2007-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_write.c: Rip out the fancy logic in TIFFAppendToStrip() for\n\testablishing if an existing tile can be rewritten to the same location\n\tby comparing the current size to all the other blocks in the same\n\tdirectory.  This is dangerous in many situations and can easily\n\tcorrupt a file.  (observed in esoteric GDAL situation that's hard to\n\tdocument).  This change involves leaving the stripbytecount[] values\n\tunaltered till TIFFAppendToStrip().  Now we only write a block back\n\tto the same location it used to be at if the new data is the same\n\tsize or smaller - otherwise we move it to the end of file.\n\n\t* tif_dirwrite.c: Try to avoid writing out a full readbuffer of tile\n\tdata when writing the directory just because we have BEENWRITING at\n\tsome point in the past.  This was causing odd junk to be written out\n\tin a tile of data when a single tile had an interleaving of reading\n\tand writing with reading last.  (highlighted by gdal\n\tautotest/gcore/tif_write.py test 7.\n\n\t* tif_predict.c: use working buffer in PredictorEncodeTile to avoid\n\tmodifying callers buffer.\n\thttp://trac.osgeo.org/gdal/ticket/1965\n\n\t* tif_predict.c/h: more fixes related to last item, keeping a\n\tdistinct pfunc for encode and decode cases as these were getting\n\tmixed up sometimes.\n\thttp://trac.osgeo.org/gdal/ticket/1948\n\n2007-11-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_predict.c/h, tif_lzw.c, tif_zip.c: Improvements so that\n\tpredictor based encoding and decoding works in read-write update\n\tmode properly.\n\thttp://trac.osgeo.org/gdal/ticket/1948\n\n2007-10-24  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Fixed problem with bogus file triggering\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG) in\n\tChopUpSingleUncompressedStrip\n\n2007-10-22  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_jpeg.c: Resolved buffer incrementation bug that lead to faulty images\n\tat best, access violation at worst, when subsampled JPEG compressed imagery\n\tis decoded without the JPEG_COLORMODE feature\n\n2007-10-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/index.html: Update \"people responsible\" section.\n\n2007-10-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fix problem with alpha setting in some cases\n\tas reported on the mailing list.\n\n2007-10-01  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* changed some more incorrect %lud printf flags to %lu\n\n2007-09-29  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Strip chopping interfered badly with uncompressed\n\tsubsampled images because it tried to divide subsampled rowblocks,\n\tleading to all sorts of errors throughout the library for these\n\timages. Fixed by making strip chopping divide in row counts that\n\tare a multiple of vertical subsampling value.\n\n2007-09-28  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Logical cast working around compiler warning\n\n\t* tif_read.c: Correction of some error flags and parameter lists\n\n2007-09-27  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Made calculation of td_maxsamplevalue more robust\n\twhen dealing with large bitspersample values, shutting up purification\n\ttools that warn about truncation, though it remains incorrect and\n\tindicates a conceptual problem there.\n\n\t* tif_open.c: Moved early exit in case of 'h' flag (to disable reading\n\tof first IFD) to proper place because it badly interfered with memory\n\tmapping, resulting in mapping flag even with dummy mapping functions\n\tthat returned 0 whilst at the same time the mapping tif_size wasn't\n\tset, thus resulting in continuous incorrect beyond-eof errors.\n\n2007-09-24  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirinfo.c: Fixed (MSVC) compiler reports about\n\tinconsistent use of const in tiffFields and exifFields definition\n\n2007-09-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Always write tile/strip offsets and sizes\n\tusing LONG8 type when output format is BigTIFF.  The\n\tTIFFWriteDirectoryTagLongLong8Array() function was restructured\n\taccordingly.\n\n\t* tif_dirread.c: Improvements to error reporting text in\n\tTIFFFetchDirectory().\n\n2007-09-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/images: Added a small collection of test images for use by\n\ttest programs and scripts.\n\t* test/tiffinfo.sh: A trivial example test script.\n\t* test/common.sh: Added small script for setting the environment\n\tused by script-based tests.\n\n2007-08-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Write the tif_nextdiroff value instead of a fixed\n\tzero when writing directory contents to preserve the ability to\n\trewrite directories in place, even in the middle of a directory\n\tchain.\n\n\t* tif_dirinfo.c:  _TIFFMergeFields() now only merges in field\n\tdefinitions that are missing.  Existing definitions are silently\n\tignored.\n\n\t* tif_dirread.c: Add runtime error for fields for which no definition\n\tis found (in addition to an assert for developers) in\n\tTIFFFetchNormalTag().  Not sure if this is needed, but it seems\n\tprudent.\n\n2007-08-10  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: removed SubsamplingHor and SubsamplingVer\n\tfrom _TIFFRGBAImage structure to revert unwanted ABI change.\n\n2007-08-10  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_win32.c: use SetFilePointer instead of\n\tSetFilePointerEx, as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1580\n\n2007-07-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_stream.cxx: Put all callback functions declarations\n\tinside extern \"C\" block.\n\n\t* libtiff/{tif_lzw.c, tif_luv.c, tif_dumpmode.c, tif_print.c,\n\ttif_read.c, tif_strip.c, tif_thunder.c}: Use \"%I64d\" printf()\n\tformatter instead of \"%lld\" with MSVC compiler.\n\n\t* libtiff/{tiffiop.h, tif_aux.c}:  Added _TIFFUInt64ToFloat() and\n\t_TIFFUInt64ToDouble() functions.\n\n2007-07-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Handle the case of MSVC 6 when using 64-bit\n\tinteger constants.\n\n\t* libtiff/{Makefile.am, Makefile.v}: Do not distribute tiffconf.h,\n\tremove tif_config.h/tiffconf.h during cleaning. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1573\n\n\t* libtiff/tif_unix.c: Do not use O_LARGEFILE. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1577\n\n2007-07-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 4.0.0alpha released.\n\n2007-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Added missed extern optind as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1567\n\n\t* libtiff/{tif_close.c, tif_dirinfo.c, tiffiop.c, tif_dirread.c,\n\ttif_dir.h, tif_dir.c, tiffio.h}: Transition to the new-style tag\n\textending scheme completed.\n\n2007-07-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_stream.cxx: Adapt to use toff_t again.  Update to\n\tuse standard C++ library size types and attempt to detect overflow\n\tcases.\n\n2007-07-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_jpeg.c, tif_dir.h, tif_dir.c, tif_dirinfo.c, tiffio.h,\n\ttif_ojpeg.c, tif_print.c, tif_fax3.c, tif_dirread.c}: More work on new\n\ttag extending scheme. Use the new scheme everywhere.\n\n\t* libtiff/{tif_zip.c, tif_predict.c, tif_pixarlog.c, tif_luv.c,\n\ttif_fax3.c, tif_dirread.c, tif_dirwrite.c, tif_close.c, tif_ojpeg.c,\n\ttif_jpeg.c, tif_dirinfo.c, tif_dir.h, tiffio.h, tiffiop.h}:\n\tTIFFFIeldInfo structure replaced with TIFFField structure.\n\tTIFFFieldInfo retained for the backward compatibility.\n\n2007-07-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c: Fix a compile problem when JPEG_SUPPORT is not\n\tdefined.\n\n2007-07-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tiff.h, tiffio.h, libtiff.def}: Unused\n\tTIFFReassignTagToIgnore() function and TIFFIgnoreSense enumeration\n\tremoved.\n\n\t* libtiff/{tif_dirinfo.c, tif_fax3.c, tif_jbig.c, tif_jpeg.c}: Move\n\ttags TIFFTAG_FAXRECVPARAMS, TIFFTAG_FAXSUBADDRESS,\n\tTIFFTAG_FAXRECVTIME and TIFFTAG_FAXDCS to the common tag directory.\n\tThese tags are not codec-specific and relate to image content, so\n\tprocess them as other normal tags.\n\n\t* libtiff/{tiffio.h, tif_dir.h}: TIFFTagValue structure moved from the\n\tpublic tiffio.h to private tif_dir.h.\n\n\t* contrib/{acorn, mac-cw, mac-mpw}: Removed as unmaintained and\n\toutdated.\n\n2007-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff{tif_acorn.c, tif_apple.c, tif_atari.c, tif_msdos.c,\n\ttif_win3.c}: Obsoleted portability stuff removed.\n\n\t* tools/tiff2ps.c:  Added support 16-bit images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1566\n\n\tPatch from William Bader.\n\n\t* tools/tiff2pdf.c: Fix for TIFFTAG_JPEGTABLES tag fetching and\n\tsignificant upgrade of the whole utility as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1560\n\n\tNow we don't need tiffiop.h in tiff2pdf anymore and will open output\n\tPDF file using TIFFClientOpen() machinery as it is implemented\n\tby Leon Bottou.\n\n2007-06-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Fix typo when substituting value for unsigned 8 bit type.\n\tAdded support for a TIFF_PTRDIFF_T type to use when doing pointer arithmetic.\n\tAdded support for a TIFF_SSIZE_T in order to return memory sizes but still\n\tallow returning -1 for errors.\n\t* libtiff/tiffconf.vc.h: Add porting type defintions for WIN32.\n\n2007-06-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* port/strtoull.c: New porting function in case strtoull() is not\n\tavailable on the target system.\n\t* configure.ac: Add configure support for determining sized types\n\tin a portable way and performing necessary substitutions in\n\ttif_config.h and tiffconf.h.  Updated tiff.h to use the new\n\tdefinitions.\n\n2007-04-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Check the tmpfile() return status as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=154\n\n2007-04-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tif_dirread.c, tif_dirinfo.c, tif_jpeg.c,\n\ttif_fax3.c, tif_jbig.c, tif_luv.c, tif_ojpeg.c, tif_pixarlog.c,\n\ttif_predict.c, tif_zip.c}: Finally fix bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1274\n\n\tby introducing _TIFFMergeFieldInfo() returning integer error status\n\tinstead of void in case of problems with field merging (e.g., if the\n\tfield with such a tag already registered). TIFFMergeFieldInfo() in\n\tpublic API remains void. Use _TIFFMergeFieldInfo() everywhere and\n\tcheck returned value.\n\n2007-04-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/addtiffo/tif_overview.c: Fix problems with odd sized output\n\tblocks in TIFF_DownSample_Subsampled() (bug 1542).\n\n2007-04-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Changed JPEGInitializeLibJPEG() so that it\n\twill convert from decompressor to compressor or compress to decompress\n\tif required by the force arguments.  This works around a problem in\n\twhere the JPEGFixupTestSubsampling() may cause a decompressor to\n\tbe setup on a directory when later a compressor is required with the\n\tforce flag set.  Occurs with the addtiffo program for instance.\n\n2007-04-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: Significant update in\n\tfunctionality from Richard Nolde. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1525\n\n2007-03-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.c: \"inline static\" -> \"static inline\" for IRIC CC.\n\n2007-03-17  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* start of BigTIFF upgrade - CVS HEAD unstable until further notice\n\n2007-03-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: workaround for 'Fractional scanline' error reading\n\tOJPEG images with rowsperstrip that is not a multiple of vertical subsampling\n\tfactor. This bug is mentioned in:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1390\n\thttp://www.asmail.be/msg0054766825.html\n\n2007-03-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_win32.c: made inclusion of windows.h unconditional\n\n\t* libtiff/tif_win32.c: replaced preprocessor indication for consiously\n\tunused arguments by standard C indication for the same\n\n2007-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Use uint32 type instead of tsize_t in byte\n\tcounters in TIFFFetchData(). Should finally fix the issue\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=890\n\n2007-02-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Properly handle tags with TIFF_VARIABLE writecount.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1350\n\n\t* libtiff/tif_dirread.c: Added special function to handle\n\tSubjectDistance EXIF tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1362\n\n\t* tools/tiff2pdf.c: Do not assume inches when the resolution units\n\tdo not specified. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1366\n\n\t* tools/{tiffcp.c, tiffcrop.c}: Do not change RowsPerStrip value if\n\tit was set as infinite. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1368\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: New tiffcrop utility contributed\n\tby Richard Nolde. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1383\n\n2007-02-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Workaround for incorrect TIFFs with\n\tExtraSamples == 999 produced by Corel Draw. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1490\n\n\t* libtiff/{tif_dirread.c, tif_read.c}: Type of the byte counters\n\tchanged from tsize_t to uint32 to be able to work with data arrays\n\tlarger than 2GB. Fixes bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=890\n\n\tIdea submitted by Matt Hancher.\n\n2007-01-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tif2rgba.c: This utility does not work properly on big-endian\n\tarchitectures. It was fixed including the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1149\n\n2007-01-15  Mateusz Loskot <mateusz@loskot.net>\n\n\t* Submitted libtiff port for Windows CE platform\n\t* libtiff/tif_config.wince.h: Added configuration header for WinCE.\n\t* libtiff/tiffconf.wince.h: Ported old configuration header for WinCE.\n\t* libtiff/tif_wince.c: Added WinCE-specific implementation of some\n\tfunctons from tif_win32.c.\n\t* libtiff/tif_win32.c: Disabled some functions already reimplemented in tif_wince.c.\n\t* libtiff/tiffiop.h, port/lfind.c: Added conditional include of some\n\tstandard header files for Windows CE build.\n\t* tools/tiffinfoce.c: Ported tiffinfo utility for Windows CE.\n\n2006-11-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: TIFFAppendToStrip() - clear sorted flag if\n\twe move a strip.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1359\n\n2006-10-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: More fixes for vulnerabilities, reported\n\tin Gentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n\t* libtiff/contrib/dbs/xtiff/xtiff.c: Make xtiff utility compilable.\n\tThough it is still far from the state of being working and useful.\n\n2006-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Save the state of printdir codec dependent\n\tmethod.\n\n\t* libtiff/tif_jpeg.c: Save the state of printdir codec dependent method\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1273\n\n\t* libtiff/tif_win32.c: Fixed problem with offset value manipulation\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1322\n\n\t* libtiff/{tif_read.c, tif_jpeg.c, tif_dir.c}: More fixes for\n\tvulnerabilities, reported in Gentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n2006-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_fax3.c, tif_next.c, tif_pixarlog.c}: Fixed multiple\n\tvulnerabilities, as per\tGentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n2006-09-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c, libtiff/tif_zip.c: Fixed problems with mixing\n\tencoding and decoding on the same read-write TIFF handle.  The LZW\n\tcode can now maintain encode and decode state at the same time. The\n\tZIP code will switch back and forth as needed.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=757\n\n2006-09-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff: Rename config.h.vc and tif_config.h.vc to config.vc.h and\n\ttif_config.vc.h for easier identification by folks using an IDE.\n\n2006-07-25  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_msdos.c: Avoid handle leak for failed opens.  c/o Thierry Pierron\n\n2006-07-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: take care not to flush out buffer of strip/tile\n\tdata in _TIFFWriteDirectory if TIFF_BEENWRITING not set.  Relates\n\tto bug report by Peng Gao with black strip at bottom of images.\n\n2006-07-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: make sure to use uint32 for wordcount in\n\tTIFFWriteNormanTag if writecount is VARIABLE2 for ASCII fields.\n\tIt already seems to have been done for other field types.  Needed\n\tfor \"tiffset\" on files with geotiff ascii text.\n\n2006-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* {configure.ac, libtiff/tif_config.h.vc, libtiff/tif_jbig.c}\n\t(JBIGDecode): jbg_newlen is not available in older JBIG-KIT and\n\tits use does not appear to be required, so use it only when it is\n\tavailable.\n\n2006-06-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Added missed EXIF tag ColorSpace (40961).\n\n\t* libtiff/tif_dirread.c: Move IFD fetching code in the separate\n\tfunction TIFFFetchDirectory() avoiding code duplication in\n\tTIFFReadDirectory() and TIFFReadCustomDirectory().\n\n2006-06-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fix handling of -q values.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=587\n\n2006-06-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_readdir.c: Added case in EstimateStripByteCounts() for tiled\n\tfiles.  Modified TIFFReadDirectory() to not invoke\n\tEstimateStripByteCounts() for case where entry 0 and 1 are unequal\n\tbut one of them is zero.\n\t  http://bugzilla.remotesensing.org/show_bug.cgi?id=1204\n\n2006-06-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_open.c, tif_dirread.c, tiffiop.h}: Move IFD looping\n\tchecking code in the separate function TIFFCheckDirOffset().\n\n\t* libtiff/tif_aux.c: Added _TIFFCheckRealloc() function.\n\n\t* tools/tiffcmp.c: Fixed floating point comparison logic as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1191\n\n\t* libtiff/tif_fax3.c: Fixed problems in fax decoder as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1194\n\n\t* tools/tiff2pdf.c: Fixed buffer overflow condition in\n\tt2p_write_pdf_string() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1196\n\n2006-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* {configure, configure.ac, libtiff/tif_jbig.c, tools/tiffcp.c}: Added\n\tsupport for JBIG compression scheme (34661 code) contributed by Lee\n\tHoward. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=896\n\n\t* configure, configure.ac: OJPEG support enabled by default.\n\n\t* contrib/ojpeg/: Removed. New OJPEG support does not need this patch.\n\n2006-06-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/{tif_dirinfo.c, tif_print.c} : Fix crash in\n\tTIFFPrintDirectory().  Joris Van Damme authored the fix.\n\n2006-04-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Unified line ending characters (always use '\\n')\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1163\n\n\t* README.vms, Makefile.am, configure.com, libtiff/{Makefile.am,\n\ttif_config.h-vms, tif_stream.cxx, tif_vms.c, tiffconf.h-vms}:\n\tAdded support for OpenVMS by Alexey Chupahin, elvis_75@mail.ru.\n\n2006-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{fax2ps.c, fax2tiff.c, ppm2tiff.c, ras2tiff.c, tiff2pdf.c}:\n\tProperly set the binary mode for stdin stream as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1141\n\n\t* man/{bmp2tiff.1, fax2ps.1, fax2tiff.1, gif2tiff.1, ras2tiff.1,\n\traw2tiff.1, rgb2ycbcr.1, sgi2tiff.1, tiff2bw.1, tiff2pdf.1, tiff2ps.1,\n\ttiff2rgba.1, tiffcmp.1, tiffcp.1, tiffdither.1,\ttiffdump.1, tiffgt.1,\n\ttiffset.1}: Improvements in page formatting as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1140\n\n\t* html/tools.html, html/man/Makefile.am, tools/tiff2pdf.c: Fixed\n\ttypos as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1139\n\n2006-04-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* nmake.opt: use /EHsc for VS2005 compatibility.  Also define\n\t_CRT_SECURE_NO_DEPRECATE to avoid noise on VS2005.\n\n2006-04-12  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: Added support for planarconfig separate\n\tnon-subsampled YCbCr (i.e. separate YCbCr with subsampling [1,1])\n\n2006-04-11  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: Revision of all RGB(A) put routines\n\t- Conversion of unassociated alpha to associated alpha now done with\n\t  more performant LUT, and calculation more correct\n\t- Conversion of 16bit data to 8bit data now done with\n\t  more performant LUT, and calculation more correct\n\t- Bugfix of handling of 16bit RGB with unassociated alpha\n\n2006-04-11  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c:\n\t- When there is no alpha, gtTileSeparate and gtStripSeparate allocated\n\t  buffer for alpha strile and filled it, only to never read it back.\n\t  Removed allocation and fill.\n\t- Minor rename of vars in gtTileSeparate and gtStripSeparate\n\t  anticipating planned functionality extension\n\n2006-04-08  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: renamed pickTileContigCase to PickContigCase\n\tand pickTileSeparateCase to PickSeparateCase as both work on strips as\n\twell\n\n\t* libtiff/tif_getimage.c: moved img->get selection from\n\tTIFFRGBAImageBegin into PickContigCase and PickSeparateCase to create\n\tlogical hook for planned functionality extension\n\n2006-04-08  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_ojpeg.c: resolved memory leak that was a consequence\n\tof inappropriate use of jpeg_abort instead of jpeg_destroy\n\n2006-04-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: replaced usage of TIFFScanlineSize in\n\tgtStripContig with TIFFNewScanlineSize so as to fix buggy behaviour\n\ton subsampled images - this ought to get sorted when we feel brave\n\tenough to replace TIFFScanlineSize alltogether\n\n\t* libtiff/tif_ojpeg.c: fixed bug in OJPEGReadSkip\n\n2006-04-04  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tiffio.h: added new type tstrile_t\n\n\t* libtiff/tif_dir.h: changed types of td_stripsperimage and td_nstrips\n\tto new tstrile_t, types of td_stripoffset and td_stripbytecount to\n\ttoff_t*\n\n\t* libtiff/tif_ojpeg.c: totally new implementation\n\n\t* libtiff/tif_dirread.c: added several hacks to suit new support of\n\tOJPEG\n\n\t* libtiff/tif_getimage.c: removed TIFFTAG_JPEGCOLORMODE handling\n\tof OJPEG images in favor of tif_getimage.c native handling of\n\tYCbCr and desubsampling\n\n2006-03-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: JPEGVSetField() so that altering the photometric\n\tinterpretation causes the \"upsampled\" flag to be recomputed.  Fixes\n\tpeculiar bug where photometric flag had to be set before jpegcolormode\n\tflag.\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_jpeg.c: strip size related bugfix in encode raw\n\n\t* libtiff/tif_strip.c: temporarilly added two new versions of\n\tTIFFScanlineSize\n\t  - TIFFNewScanlineSize: proposed new version, after all related\n\t    issues and side-effects are sorted out\n\t  - TIFFOldScanlineSize: old version, from prior to 2006-03-21 change\n\tThis needs further sorting out.\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* contrib/addtiffo/tif_ovrcache.c: bugfix to correctly pass size\n\tof last truncated strip data to TIFFWriteEncodedStrip\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/{tif_jpeg.c, tif_strip.c}: bugfix of tif_jpeg decode raw\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: bugfix/rewrite of putcontig8bitYCbCr22tile\n\n\t* libtiff/tif_getimage.c: added putcontig8bitYCbCr12tile\n\n\t* libtiff/tif_read.c: added support for new TIFF_NOREADRAW flag to\n\tprepare\tthe path for new tif_ojpeg.c\n\n2006-03-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.2 released.\n\n\t* tools/Makefile.am: Use runtime paths linker flags when rpath\n\toption enabled.\n\n2006-03-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed exports as per bug\n\thttp://bugzilla.remotesensing.org/attachment.cgi?id=337\n\n\t* contrib/addtiffo/Makefile.vc, libtiff/Makefile.vc, port/Makefile.vc,\n\ttools/Makefile.vc: Makefiles improvements as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1128\n\n\t* nmake.opt libtiff/{tif_config.h.vc, tif_unix.c, tiffio.h},\n\ttools/{fax2ps.c, fax2tiff.c, tiff2pdf.c}: Fixed win32 I/O functions\n\tusage as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1127\n\n\t* libtiff/tif_strip.c: Take subsampling in account when calculating\n\tTIFFScanlineSize().\n\n\t* tools/tiffcp.c: Do not set RowsPerStrip bigger than image length.\n\n2006-03-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Fixed wrong TIFFerror() invocations as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1125\n\n\t* tools/fax2ps.c: Fixed reading the input stream from stdin as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1124\n\n2006-03-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffiop.h: Added decalration for\n\t_TIFFSetDefaultCompressionState().\n\n\t* libtiff/{tif_jpeg.c, tif_fax3.c, tif_zip.c, tif_pixarlog.c,\n\ttif_lzw.c, tif_luv.c}: Use _TIFFSetDefaultCompressionState() in all\n\tcodec cleanup methods. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1120\n\n2006-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Do not cleanup codec state in TIFFInitJPEG(). As\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1119\n\n\t* tools/raw2tiff.c: Do not set RowsPerStrip larger than ImageLength.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1110\n\n\t* libtiff/tiffiop.h: dblparam_t typedef removed; GLOBALDATA macro\n\tremoved; move here the STRIP_SIZE_DEFAULT macro definition.\n\n\t* libtiff/{tif_dirread.c, tif_strip.c}: Removed STRIP_SIZE_DEFAULT\n\tmacro definition.\n\n\t* libtiff/tif_dir.c: Use double type instead of dblparam_t.\n\n2006-03-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Do not check the PlanarConfig tag presence\n\tin TIFFReadDirectory, because it is always set at the start of\n\tfunction and we allow TIFFs without that tag set.\n\n2005-03-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.1 released.\n\n2006-03-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Fixed error reporting in TIFFFetchAnyArray()\n\tfunction as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/tif_dirread.c: More wise check for integer overflow\n\tcondition as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/{tif_jpeg.c, tif_pixarlog.c, tif_fax3.c, tif_zip.c}:\n\tProperly restore setfield/getfield methods in cleanup functions. As\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n2006-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_predict.c, tif_predict.h}: Added new function\n\tTIFFPredictorCleanup() to restore parent decode/encode/field methods.\n\n\t* libtiff/{tif_lzw.c, tif_pixarlog.c, tif_zip.c}: Use\n\tTIFFPredictorCleanup() in codec cleanup methods. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/tif_dirread.c: Fixed integer overflow condition in\n\tTIFFFetchData() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n2006-03-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_ojpeg.c: Set the ReferenceBlackWhite with the\n\tTIFFSetField() method, not directly. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1043\n\n\t* tools/ppm2tiff.c: Added support for PBM files as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1044\n\n2006-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Small code rearrangement in TIFFWriteScanline()\n\tto avoid crash as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1081.\n\n2006-02-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Functions t2p_sample_rgbaa_to_rgb() and\n\tt2p_sample_rgba_to_rgb() was used in place of each other, that was\n\tresulted in problems with RGBA images with associated alpha.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1097\n\n2006-02-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Properly write TIFFTAG_DOTRANGE tag as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1088.\n\n\t* libtiff/tif_print.c: Properly read TIFFTAG_PAGENUMBER,\n\tTIFFTAG_HALFTONEHINTS, TIFFTAG_YCBCRSUBSAMPLING and TIFFTAG_DOTRANGE\n\ttags as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1088.\n\n\t* tools/tiff2ps.c: Properly scale all the pages when converting\n\tmultipage TIFF with /width/height/center options set. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1080\n\n2006-02-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Do not create output file until all option checks\n\twill be done. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1072\n\n\t* tools/bmp2tiff.c: Added ability to create multipage TIFFs from the\n\tlist of input files as per bug:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1077\n\n2006-02-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_tile.c: Fix error reporting in TIFFCheckTile() as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1063.\n\n\t* tools/tiffgt.c: Avoid crashing in case of image unsupported by\n\tTIFFRGBAImage interface.\n\n\t* libtiff/tif_color.c: Avoid overflow in case of wrong input as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1065.\n\n2006-02-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fixed support for non-YCbCr encoded JPEG\n\tcompressed TIFF files, per submission from Dan Cobra.\n\n2006-02-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_packbits.c, tif_win32.c}: Properly\n\tcast values to avoid warnings. As per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n\t* libtiff/tif_dirinfo.c: Use TIFF_NOTYPE instead of 0 when\n\tappropriate. As per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n\t* libtiff/tif_aux.c: Fixed type of temporary variable in\n\t_TIFFCheckMalloc() as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n2006-02-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_aux.c: Return static array when fetching default\n\tYCbCrCoefficients (another problem, reported a the\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1029 entry).\n\n2006-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Special handling for PageNumber, HalftoneHints,\n\tYCbCrSubsampling and DotRange tags as per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1029\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1034\n\n\t* libtiff/tif_dirread.c: Use _TIFFGetExifFieldInfo() instead of\n\t_TIFFGetFieldInfo() in TIFFReadEXIFDirectory() call as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1026.\n\n2006-01-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtool related stuff updated from the 2.1a branch.\n\n2006-01-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/bmp2tiff,pal2rgb,ppm2tiff,ras2tiff,raw2tiff,sgi2tiff,\n\ttiff2bw,tiffcp: Fixed jpeg option processing so -c jpeg:r:50 works\n\tproperly as per bug:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1025\n\n2006-01-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Fix with_default_strip_size comparison as reported\n\tby Norihiko Murase.\n\n2006-01-08  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am (LIBTIFF): Due to linking against libtiff\n\tincorrectly, tests were not actually testing the uninstalled\n\tlibtiff.  Now they are.\n\n2006-01-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Change definitions for TIFFTAG_ICCPROFILE,\n\tTIFFTAG_PHOTOSHOP, TIFFTAG_RICHTIFFIPTC, TIFFTAG_XMLPACKET: readcount\n\tshould be uint32 value.\n\n2006-01-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/man/Makefile.am (htmldoc): Fix htmldoc rule so that it can\n\tbe used if build directory is not the same as source directory.\n\t* man/{TIFFGetField.3tiff, TIFFSetField.3tiff}: Documented\n\tTIFFTAG_PHOTOSHOP, TIFFTAG_RICHTIFFIPTC, and TIFFTAG_XMLPACKET,\n\tand re-sorted tag names in alphabetical order.\n\n2005-12-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.0 released.\n\n2005-12-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/bmp2tiff.c (main): Fixed warning regarding returning\n\tinconsistent types from a condition.\n\t* tools/tiffcmp.c (CheckLongTag): Eliminate warning due to printf\n\tformat.\n\t* tools/bmp2tiff.c: Reduce compilation warnings on big-endian CPUs.\n\n2005-12-28  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* html/{index.html, support.hml, libtiff.html}: Cleaned up HTML\n\n2005-12-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Added VC_EXTRALEAN definition before including\n\twindows.h, to reduce the compile time.\n\n2005-12-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Improve compilation under MinGW.\n\n2005-12-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_dirread.c, tif_dirinfo.c}:\n\ttiffFieldInfo and exifFieldInfo arrays definitions moved back to\n\ttif_dirinfo.c; added _TIFFGetFieldInfo() and _TIFFGetExifFieldInfo()\n\tprivate functions to retrieve FieldInfo arrays.\n\n2005-12-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/build.html: Added some additional instructions for when\n\tbuilding using MSVC under Windows.  Also fixed two HTML syntax\n\terrors and used HTML Tidy to tidy up the HTML syntax and\n\tformatting.\n\n2005-12-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dir.c, tif_dir.h, tif_dirwrite.c,\n\ttif_print.c, tif_getimage.c}: Make InkSet, NumberOfInks, DotRange and\n\tStoNits tags custom.\n\n2005-12-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dir.c, tif_dir.h, tif_print.c}: Make\n\tWhitePoint tag custom.\n\n\t* libtiff/{tif_dir.h, tiff.h}: More EXIF tags added.\n\n2005-12-23  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tiffio.h: fixed typo that potentially resulted in\n\tredefininition of USE_WIN32_FILEIO\n\n\t* libtiff/*: Added more 'dual-mode' error handling: Done TIFFWarning\n\tcalls in core LibTiff.\n\n2005-12-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_print.c}: Make RichTIFFIPTC,\n\tPhotoshop and ICCProfile tags custom.\n\n2005-12-21  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/*, contrib/*: Added 'dual-mode' error handling, enabling\n\tnewer code to get context indicator in error handler and still\n\tremain compatible with older code: Done TIFFError calls everywhere\n\texcept in tools\n\n2005-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Added many error reporting messages; fixed integer\n\toverflow as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=789\n\n2005-12-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/addtiffo/*: Major upgrade by Joris to support subsampled\n\tYCbCr images in jpeg compressed TIFF files.\n\n2005-12-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Return non-zero status when reading fails (again).\n\n2005-12-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Return non-zero status when reading fails.\n\n2005-12-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tiff.h}: Added more EXIF tags.\n\n2005-12-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_print.c}: Make XMLPacket tag\n\tcustom.\n\n\t* tools/tiffinfo.c: Print EXIF directory contents if exist.\n\n\t* libtiff/tiff.h: Few EXIF tag numbers added.\n\n\t* libtiff/{tif_dirinfo.c, tif_dirread.c, tif_dir.h, tif_dir.c,\n\ttiffio.h}: Preliminary support to read custom directories. New\n\tfunctions: TIFFReadCustomDirectory() and TIFFReadEXIFDirectory().\n\n2005-12-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirinfo.c, tif_dirread.c, tif_dir.h, tif_dir.c}:\n\tMore work to implement custom directory read support.\n\n\t* libtiff/{tif_aux.c, tif_dirinfo.c, tif_dirread.c, tif_dir.h,\n\ttif_dir.c, tif_print.c}: Make YCbCrCoefficients and ReferenceBlackWhite\n\ttags custom.\n\n2005-12-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: One more workaround for broken\n\tStripByteCounts tag. Handle the case when StripByteCounts array filled\n\twith completely wrong values.\n\n2005-11-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Release file descriptor in case of failure\n\tin the TIFFOpenW() function as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1003\n\n\t* libtiff/tif_dirinfo.c: Correctly yse bsearch() and lfind()\n\tfunctions as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1008\n\n2005-11-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_open.c, tiff.h, tiffdump.c: Incorporate preliminary support\n\tfor MS MDI format.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1002\n\n\t* .cvsignore: many files added, and a few update according\n\tto suggestion of Brad HArds on tiff mailing list.\n\n2005-11-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def, tiffiop.h, tiffio.h: Made TIFFFreeDirectory\n\tpublic.\n\n2005-10-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Properly calculate sizes of temporary arrays\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=943\n\n\t* tools/fax2tiff.c: Added option '-r' to set RowsPerStrip parameter\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=944\n\n\t* tools/tiffdump.c: Fixed typeshift and typemask arrays initialization\n\tproblem as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=946\n\n\t* tools/bmp2tiff.c: Fixed possible integer overflow error as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=965\n\n\t* libtiff/tif_dirinfo.c: Make XResolution, YResolution and\n\tResolutionUnit tags modifiable during write process. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=977\n\n\t* tools/tiffsplit.c: Copy fax related fields over splitted parts\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=983\n\n2005-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: Don't try and split single strips into \"0\" strips\n\tin ChopUpSingleUncompressedStrip.  This happens in some degenerate\n\tcases (like 1x1 files with stripbytecounts==0 (gtsmall.jp2 embed tiff)\n\n2005-10-20  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_fax3.c: changed 'at scanline ...' style warning/errors\n\twith incorrect use of tif_row, to 'at line ... of\n\tstrip/tile ...' style\n\n2005-10-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_write.c: fixed setting of planarconfig as per bug report\n\ton the mailing list from Joris.\n\n2005-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, configure, nmake.opt, libtiff/{tif_config.h,\n\ttif_dirread.c}: Make the default strip size configurable via the\n\t--with-default-strip-size and STRIP_SIZE_DEFAULT options.\n\n2005-09-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/support.html: Fixed link to documentation on Greg Ward's\n\tLogLuv TIFF format.\n\n2005-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Fixed crash when reading malformed tags.\n\n2005-09-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Added missed 'break' statement as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=932\n\n2005-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.4 released.\n\n\t* {configure, configure.ac, Makefile.am, autogen.sh}: Applied patch\n\tfrom Patrick Welche (all scripts moved in the 'config' and 'm4'\n\tdirectories).\n\n2005-09-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: reintroduce seek to avoid problem on solaris.\n\n2005-09-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: When prefreeing tv->value in TIFFSetFieldV\n\talso set it to NULL to avoid double free when re-setting custom\n\tstring fields as per:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=922\n\n2005-08-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: avoid signed/unsigned warning.\n\n\t* libtiff/tif_dirread.c: removed unused variable.\n\n2005-07-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: Fixed up support for swapping \"double complex\"\n\tvalues (128 bits as 2 64 bits doubles).  GDAL gcore tests now\n\tpass on bigendian (macosx) system.\n\n2005-07-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dirread.c, tif_fax3.c, tiffiop.h}: Rename\n\tCheckMalloc() function to _TIFFCheckMalloc() and make it available\n\tglobally as an internal helper routine.\n\n2005-07-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: More improvements in the \"pass by value\" part of\n\tthe custom tags handling code.\n\n2005-07-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_dirinfo.c}: Do not upcast BYTEs to\n\tSHORTs in the TIFFFetchByteArray(). Remove TIFFFetchExtraSamples()\n\tfunction, use TIFFFetchNormalTag() instead as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=831\n\n\tRemove TIFFFetchExtraSamples() function, use TIFFFetchNormalTag()\n\tinstead.\n\n\t* libtiff/tiffconf.h.in: One more attempt to fix the AIX bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2005-07-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_print.c: Fixed printing of the BYTE and SBYTE arrays.\n\n\t* tools/tiffdump.c: Added support for TIFF_IFD datatype.\n\n2005-07-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Do not check the PlanarConfiguration field in\n\tthe TIFFWriteCheck() function in case of single band images (as per\n\tTIFF spec).\n\n2005-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* SConstruct, libtiff/SConstruct: Added the first very preliminary\n\tsupport for SCons software building tool (http://www.scons.org/).\n\tThis is experimental infrastructure and it will exist along with the\n\tautotools mechanics.\n\n2005-07-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* port/{getopt.c, strcasecmp.c, strtoul.c}: Update modules from\n\tthe NetBSD source tree (the old\t4-clause BSD license changed to\n\tthe new 3-clause one).\n\n\t* configure.ac, port/lfind.c, libtiff/tiffiop.h: Added lfind()\n\treplacement module.\n\n\t* port/dummy.c: Make the dummy function static.\n\n2005-07-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed WhitePoint tag copying.\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_print.c}:\n\tMake FieldOfViewCotangent, MatrixWorldToScreen, MatrixWorldToCamera,\n\tImageFullWidth, ImageFullLength and PrimaryChromaticities tags custom.\n\n2005-07-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.3 released.\n\n\t* configure, configure.ac: Do not use empty -R option when linking\n\twith --enable-rpath.\n\n2005-07-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_open.c}: Added open option 'h' to avoid\n\treading the first IFD when needed. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=875\n\n\t* libtiff/tif_color.c: Better use of TIFFmin() macro to avoid side\n\teffects.\n\n2005-06-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Print two characters per loop in the\n\tt2p_write_pdf_trailer(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=594\n\n\t* tools/tiffgt.c: Use MacOS X OpenGL framework when appropriate. As\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=844\n\n\t* acinclude.m4: Updated to latest OpenGL test macros versions.\n\n\t* libtiff/tiff.h: Use correct int size on Sparc 64bit/Sun compiler\n\tplatform. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=855\n\n2005-06-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Added support for ClipPath, XClipPathUnits\n\tand YClipPathUnits tags.\n\n2005-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/addtiffo/tif_ovrcache.c: Properly extract tile/strip size;\n\tuse pixel sized shift in contigous case.\n\n2005-06-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/addtiffo/{tif_overview.c, tif_ovrcache.c, tif_ovrcache.h}:\n\tMake overviews working for contiguos images.\n\n2005-06-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Replace runtime endianess check with the compile\n\ttime one.\n\n\t* libtiff/tif_predict.c: Floating point predictor now works on\n\tbig-endian hosts.\n\n2005-06-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Use _TIFFsetString() function when read custom\n\tASCII values.\n\n\t* libtiff/{tif_dirinfo.c, tif_dir.h, tif_dir.c, tif_print.c}: Make\n\tDocumentName, Artist, HostComputer, ImageDescription, Make, Model,\n\tCopyright, DateTime, PageName, TextureFormat, TextureWrapModes and\n\tTargetPrinter tags custom.\n\n\t* libtiff/tif_jpeg.c: Cleanup the codec state depending on\n\tTIFF_CODERSETUP flag (to fix memry leaks).\n\n\t* libtiff/tif_jpeg.c: Initialize JPEGTables array with zero after\n\tallocating.\n\n2005-05-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/Makefile.am: Added workaround for\n\tOpenBSD/MirOS soname problem as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=838\n\n\t* libtiff/tif_dirwrite.c: Use tdir_count when calling\n\tTIFFCvtNativeToIEEEDouble() in the TIFFWriteDoubleArray() function as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=845\n\n2005-05-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: Fixed format string when read PPM file header with\n\tthe fscanf() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=861\n\n\t* libtiff/{tif_dirinfo.c, tif_print.c}: TIFFFetchByteArray() returns\n\tuint16 array when fetching the BYTE and SBYTE filds, so we should\n\tconsider result as pointer to uint16 array and not as array of chars.\n\tAs per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=831\n\n\t* libtiff/tif_dir.c: More efficient custom tags retrieval as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=830\n\n\t* libtiff/tif_win32.c: Use FILE_SHARE_READ | FILE_SHARE_WRITE share\n\tmode in CreateFile() call as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=829\n\n\t* libtiff/Makefile.am: Fixed parallel compilation of the libtiff and\n\tlibtiffxx libraries as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=826\n\n\t* contrib/addtiffo/{tif_overview.c, tif_ovrcache.h}: Sinchronized with\n\tGDAL.\n\n2005-05-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Substantial fix for addtiffo problems with\n\tJPEG encoded TIFF files.  Pre-allocate lots of space for jpegtables\n\tin directory.\n\n2005-05-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Changed the code that computes\n\tstripbytecount[0] if it appears bogus to ignore if stripoffset[0] is\n\tzero. This is a common case with GDAL indicating a \"null\" tile/strip.\n\n2005-05-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Check for JPEGTables tag presence before copying.\n\n2005-05-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Applied similar change to\n\tTIFFFetchPerSampleLongs and TIFFFetchPerSampleAnys.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=843\n\n\t* libtiff/tif_jpeg.c: added LIB_JPEG_MK1 support in JPEGDecodeRaw().\n\n2005-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\t* tools/tiff2pdfr.c, man/tiff2pdf.1: Calculate the tile width properly;\n\tadded new option '-b' to use interpolation in output PDF files (Bruno\n\tLedoux).\n\n2005-05-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Ensure that broken files with too many\n\tvalues in PerSampleShorts work ok instead of crashing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=843\n\n2005-04-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdither.c: Copy the PhotometricInterpretation tag from the\n\tinput file.\n\n2005-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_predict.c: Added ability to encode floating point\n\tpredictor, as per TIFF Technical Note 3.\n\n2005-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_predict.h, tif_predict.c}: Added ability to decode\n\tfloating point predictor, as per TIFF Technical Note 3.\n\n2005-04-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tiffiop.h, tif_dir.c, tif_read.c, tif_swab.c}:\n\tAdded _TIFFSwab24BitData() and TIFFSwabArrayOfLong() functions used to\n\tswap 24-bit floating point values.\n\n\t* libtiff/tiff.h: Added predictor constants.\n\n2005-04-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dir.c}: Use uint32 type for appropriate\n\tvalues in _TIFFVSetField() function. Inspired by the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=816\n\n\t* man/TIFFSetField.3tiff: Fixed definition of the TIFFTAG_INKNAMES tag\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=816\n\n2005-03-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Do not read header in case the output file\n\tshould be truncated (Ron).\n\n\t* libtiff/{tif_dirinfo.c, tif_config.h.vc}: Use lfind() instead\n\tof bsearch() in _TIFFFindFieldInfoByName() function (Ron).\n\n\t* libtiff/{tiff.h, tif_dirinfo.c}: Fixes in EXIF tag ordering (Ron).\n\n2005-03-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/Makefile.am: Use libtool machinery to pass\n\trpath option.\n\n2005-03-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_print.c}: Handle all data types in custom\n\ttags.\n\n2005-03-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/dirinfo.c: Added DNG tags.\n\n\t* libtiff/{tif_dir.c, tif_print.c}: More improvements in custom tag\n\thandling code.\n\n\t* libtiff/tiff.h: More comments; added missed DNG tag (LensInfo);\n\tadded DNG 1.1.0.0 tags.\n\n\t* tools/tif2pdf.c: Fixed problem with alpha channel handling as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=794\n\n\t* man/TIFFGetField.3tiff: Add a note about autoregistered tags.\n\n2005-03-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* nmake.opt: Build with Win32 CRT library by default.\n\n\t* tools/tiff2ps.c: Fixed typo in page size handling code.\n\n\t* libtiff/{tif_dir.c, tif_print.c}: Support for custom tags, passed\n\tby value.\n\n\t* libtiff/{tiff.h, tif_dirinfo.c, tiffiop.h}: Added EXIF related tags.\n\n2005-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.2 released.\n\n2005-03-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcmp.c: Added ability to compare the 32-bit integer and\n\tfloating point data; complain on unsupported bit depths.\n\n2005-03-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tif_stream.cxx: Use ios namespace instead of ios_base to support\n\tGCC 2.95.\n\n\t* libtiff/{tiff.h, tif_fax3.tif, tif_jpeg.c}: Applied correct patch from\n\tLee Howard for HylaFax DCS tag\n\t(see http://bugzilla.remotesensing.org/show_bug.cgi?id=771)\n\n2005-03-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, configure.ac: Use -rpath option instead of -R as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=732\n\n\t* libtiff/{tiff.h, tif_fax3.tif, tif_jpeg.c}: Applied patch from Lee\n\tHoward to support a new tag TIFFTAG_FAXDCS (34911) used in HylaFax\n\tsoftware. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=771\n\n\t* nmake.opt, html/build.html: Add more comments, change the config\n\tfile organization a bit as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=764\n\n\t* tools/tiffcmp.c: Use properly sized buffer in short arrays comparison\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=785\n\n2005-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: More logic to guess missed strip size as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=705\n\n\t* tools/fax2ps.c: Replace insecure mktemp() function with the\n\ttmpfile() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=786\n\n2005-02-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Changed the int8 definition to be always signed char\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=727\n\n\t* libtiff/tiffio.h: Move TIFFOpenW() function into the extern \"C\"{}\n\tblock as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=763\n\n2005-02-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Fix problem on big-endian CPUs so that images\n\tdisplay more correctly.  Images display brighter than they should\n\ton a Sun workstation.\n\n2005-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Estimate strip size in case of wrong or\n\tsuspicious values in the tags. As per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=705\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=320\n\n\t* tools/tiff2ps.c: Fixed problem with page sizes as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=742\n\n2005-01-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiff.h (TIFFTAG_TILEWIDTH): Corrected description.\n\t(TIFFTAG_TILELENGTH): Corrected description.\n\n2005-01-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac: Fixes for --with-docdir option as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=759\n\n\t* libtiff/tif_open.c: Remove unnesessary TIFFSeekFile() call as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=756\n\n\t* libtiff/tif_stream.cxx: Fixes for C++ stream interface from\n\tMichael Rinne and Edward Lam.\n\n2005-01-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac: Make the documentation directory location configurable\n\tvia the --with-docdir option (as suggested by Jeremy C. Reed).\n\n\t* libtiff/tif_color.c: Use double as the second argument of pow()\n\tfunction in TIFFCIELabToRGBInit(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=741\n\n\t* libtiff/tif_pixarlog.c: Avoid warnings when converting float to\n\tinteger as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=740\n\n\t* libtiff/tif_getimage.c: Always fill the error message buffer in\n\tTIFFRGBAImageBegin() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=739\n\n2005-01-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Added ability to read/write the fax specific\n\tTIFFTAG_FAXRECVPARAMS, TIFFTAG_FAXSUBADDRESS and TIFFTAG_FAXRECVTIME\n\ttags as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=736\n\n\t* libtiff/tif_win32.c: Fixed message formatting in functions\n\tWin32WarningHandler() and Win32ErrorHandler() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=735\n\n\t* tools/tiff2ps.c: Interpret the -w and -h options independently. As\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=689\n\n2005-01-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Move the color conversion routines in the 'extern\n\t\"C\"' section as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=727\n\n\t* libtiff/tiff.h: Restore back the workaround for AIX Visual Age C\n\tcompiler to avoid double definition of BSD types as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n\t* libtiff/Makefile.am: Place the C++ stream API in the separate\n\tlibrary called libtiffxx to avoid unneeded dependencies. Probably\n\tthere will be more C++ API in the future. As per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=733\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=730\n\n2005-01-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Fixed problem when read broken TIFFs with the\n\twrong tag counts (Dmitry V. Levin, Martin Pitt).\n\n\t* configure.ac: Replace --disable-c++ with the --disable-cxx option as\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=730\n\n2004-12-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: More fixes for multiple-alpha-channelled\n\tRGB-images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=713\n\n\n\t* tools/tiffset.c: Convert character option to integer value as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=725\n\n2004-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.1 released.\n\n\t* html/tiffset.1.html: Add missed manual page as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=678\n\n\t* libtiff/tiff.h: Revert back libtiff data type definitions as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=687\n\n2004-12-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Do not forget about TIFF_VARIABLE2 when\n\tchecking for tag count in TIFFReadDirectory() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=713\n\n\t* libtiff/{tif_dirread.c, tif_fax3.c}: More argument checking in\n\tCheckMallock() function.\n\n\t* libtiff/tif_getimage.c: Support for multiple-alpha-channelled\n\tRGB-images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=718\n\n2004-12-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: #define A1 bracketing for clean build on\n\tSunPro compiler.\n\n2004-12-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* autogen.sh: aclocal and autoheader should be executed after\n\tlibtoolize.  Also add '-I .' to aclocal invocation to check\n\tcurrent directory for macros.\n\n2004-12-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Always write TIFFTAG_SUBIFD using LONG type\n\tas per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=703\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=704\n\n2004-12-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* nmake.opt: Link with the user32.lib in windowed mode. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=697\n\n\t* libtiff/tif_win32.c: Use char* strings instead of TCHAR in windowed\n\tmode as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=697\n\n\t* libtiff/tif_config.in.vc: Removed unneded definitions for\n\tread/open/close/lseek functions to fix the\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=680\n\n2004-12-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dirread.c}: Remove TIFFReassignTagToIgnore()\n\tcall from the TIFFReadDirectory() function. TIFFReassignTagToIgnore\n\tmust be removed in the future, as it was never used properly. As per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=692\n\n2004-11-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Added a work-around in order to allow\n\tcompilation with the heavily modified version of libjpeg delivered\n\twith Cygwin.\n\n2004-11-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Properly handle tags, which have the uint32\n\tcounts. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=693\n\n\t* tools/fax2ps.c: Be able to extract the first page (#0). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=690\n\n2004-11-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_unix.c: Make UNIX module compilable (and usable)\n\ton Windows.\n\n\t* nmake.opt: Add missed DLLNAME variable.\n\n2004-11-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/makefile.vc: make it easier to rename the libtiff DLL.\n\n2004-11-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* man/libtiff.3tiff: Improvements in the \"LIST OF ROUTINES\" table as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=545\n\n\t* man/tiffset.1: Added manual page for tiffset tool written by Jay\n\tBerkenbilt. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=678\n\n2004-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_error.c: fixed TIFFerror call to be TIFFError.\n\n2004-11-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/document.html: Updated Adobe web links as per email from Joris.\n\n2004-11-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.hxx, tiffio.h}: C++ stream interface moved to new\n\tfile tiffio.hxx. We don't have any C++ in tiffio.h, those who want to\n\tuse C++ streams should #include <tiffio.hxx>.\n\n2004-11-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Added Adobe DNG tags.\n\n\t* libtiff/tif_win32.c: Typo fixed.\n\n\t* libtiff/{tif_stream.cxx, tiffio.h}: C++ stream interface updated to\n\tbe compliant with the latest standard. Appropriate additions in\n\tmakefiles now completed.\n\n2004-11-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c, libtiff/tif_dirinfo.c: Properly handle the\n\tdifferent tag types. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=600\n\n2004-11-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_aux.c: Set the appropriate ReferenceBlackWhite array for\n\tYCbCr image which lacks that tag (noted by Hans Petter Selasky).\n\n2004-11-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_color.c: Division by zero fixed (Hans Petter Selasky).\n\n2004-11-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_stream.cxx, tiffio.h}: Added C++ stream interface\n\tcontributed by Edward Lam (see\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=654 for details).\n\tThough no changes in any makefiles yet.\n\n2004-11-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: Removed close() in TIFFClientOpen() if file\n\tis bad. This is the callers responsibility.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=651\n\n2004-11-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_win32.c, libtiff.def}: Added TIFFOpenW()\n\tfunction to work with the double byte strings (used to represent\n\tfilenames in some locales). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=625\n\n\t* libtiff/tif_dirread.c: Fixed problem when fetching BitsPerSample and\n\tCompression tags of type LONG from broken TIFFS as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=662\n\n\t* libtiff/tif_dirinfo.c: Fixed definition for TIFFTAG_RICHTIFFIPTC,\n\tthe writecount should have uint32 type. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=662\n\n\t* libtiff/tif_write.c: Fixed wrong if() statement in\n\tTIFFAppendToStrip() function as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=660\n\n2004-11-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Change definition for TIFFTAG_EXTRASAMPLES\n\tfield. The caller should supply a count when setting this field. As\n\tper bug\n\n\t http://bugzilla.remotesensing.org/show_bug.cgi?id=648\n\n\t* libtiff/{tif_jpeg.c, tif_ojpeg.c}: TIFFTAG_JPEGTABLES should have\n\tuint32 count. Use this type everywhere.\n\n2004-11-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_next.c: avoid use of u_long and u_char types.  Bug 653.\n\n2004-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2rgba.c: removed extra newlines in usage message.\n\n2004-10-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Improvements in tag writing code.\n\n\t* tools/tiff2ps.c: Fixed wrong variable data type when read Position\n\ttags (Tristan Hill).\n\n2004-10-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiffiop.h: added fallback definition of assert() if we\n\tdon't have assert.h.\n\n2004-10-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Fixed case with the wrong decode routines\n\tchoosing when the incorrect Group4Options tag set. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=323\n\n\t* libtiff/tif_dirwrite.c: Fixed problem with passing count variable of\n\twrong type when writing the TIFF_BYTE/TIFF_SBYTE tags in\n\tTIFFWriteNormalTag().\n\n2004-10-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed wrong variable data type when read Resolution\n\ttags (Peter Fales).\n\n\t* tools/{bmp2tiff.c, raw2tiff.c}: Get rid of stream I/O functions.\n\n2004-10-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: added casts to avoid warnings.\n\n\t* libtiff/libtiff.def: Added several more entry points required\n\tto link fax2tiff.c against the DLL on windows.\n\n2004-10-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, configure.ac: Added --enable-rpath option to embed linker\n\tpaths into library binary.\n\n2004-10-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Check the malloc return value (Dmitry V. Levin).\n\n\t* libtiff/{tif_strip.c, tif_tile.c}: Zero division problem fixed\n\t(Vladimir Nadvornik, Dmitry V. Levin).\n\n2004-10-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0 released.\n\n2004-10-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: There seems to be no need to include stdio.h\n\tin this file so its inclusion is removed.  Including stdio.h\n\tsometimes incurs an INT32 typedef conflict between MinGW's\n\tbasetsd.h and libjpeg's jmorecfg.h.\n\n2004-10-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* man/bmp2tiff.1: Added manual page for bmp2tiff utility.\n\n2004-10-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcmp.c (leof): Renamed from 'eof' in order to avoid\n\tconflict noticed under MinGW.\n\t* ltmain.sh: Fix for MinGW compilation.\n\n2004-10-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/tiffsplit.1: Fixed to indicate using aaa-zzz, not aa-zz.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=635\n\n2004-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_jpeg.c, tif_luv.c, tif_ojpeg.c,\n\ttif_pixarlog.c, tif_write.c}: Handle the zero strip/tile sizes\n\tproperly (Dmitry V. Levin, Marcus Meissner).\n\n2004-10-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Type of the TIFFTAG_SUBIFD field changed\n\tto TIFF_IFD.\n\n2004-10-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tif.c: Check the space allocation results.\n\n2004-10-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Initialize td_tilewidth and td_tilelength fields\n\tof the TIFFDirectory structure with the 0 instead of -1 to avoid\n\tconfusing integer overflows in TIFFTileRowSize() for striped images.\n\n\t* tools/tiff2pdf.c: Fixed TransferFunction tag handling reported\n\tby Ross A. Finlayson.\n\n\t* libtiff/tif_dir.c: Fixed custom tags handling as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=629\n\n2004-10-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Fix bug with tif_foundfield and reallocation\n\tof tif_fieldinfo.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=630\n\n2004-10-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/iptcutil/README: Added the missing README which goes\n\talong with iptcutil.\n\n2004-10-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_compress.c: Improved error reporting in\n\tTIFFGetConfiguredCODECs() (Dmitry V. Levin).\n\n2004-10-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0beta2 released.\n\n\t* libtiff/{tif_aux.c, tif_compress.c, tif_dirinfo.c, tif_dirwrite.c,\n\ttif_extension.c, tif_fax3.c, tif_luv.c, tif_packbits.c,\n\ttif_pixarlog.c, tif_write.c}: Added checks for failed memory\n\tallocations and\tinteger overflows (Dmitry V. Levin).\n\n\t* libtiff/tiff.h: Missed TIFF_BIGTIFF_VERSION constant added.\n\n2004-10-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: added a more informative message if a BigTIFF\n\tfile is opened.\n\n2004-09-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: changed type of XMLPacket (tag 700) to\n\tTIFFTAG_BYTE instead of TIFFTAG_UNDEFINED to comply with the info\n\tin the Adobe XMP Specification.\n\n2004-09-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_jpeg.c, tif_pixarlog.c}: Use _TIFFmemset() instead of\n\tmemset().\n\n\t* libtiff/{tif_dirread.c, tif_strip.c, tif_tile.c}: Applied patches\n\tfrom Dmitry V. Levin to fix possible integer overflow problems.\n\n2004-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Check for allocated buffers before clearing\n\t(Dmitry V. Levin).\n\n2004-09-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tif_dir.c, tif_dirread.c, tif_write.c}:\n\tOptimize checking for the strip bounds.\n\n\t* libtiff/{tif_dirread.c, tif_strip.c}: TIFFScanlineSize() and\n\tTIFFRasterScanlineSize() functions report zero in the case of integer\n\toverflow now. Properly handle this case in TIFFReadDirectory()\n\t(patches from Dmitry V. Levin).\n\n2004-09-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirinfo.c, tif_strip.c, tif_tile.c}: Use TIFFhowmany8()\n\tmacro where appropriate.\n\n\t* tools/tiff2bw.c: Write ImageWidth/Height tags to output file, as\n\tnoted by Gennady Khokhorin.\n\n\t* libtiff/tif_dirread.c: Always check the return values, returned\n\tby the _TIFFmalloc() (Dmitry V. Levin).\n\n\t* libtiff/tif_dir.c: Fixed possible integer overflow _TIFFset*Array()\n\tfunctions (Dmitry V. Levin).\n\n\t* libtiff/{tif_dirread.c, tif_dir.c, tif_write.c}:\n\tPotential memory leak fixed in TIFFReadDirectory(), _TIFFVSetField(),\n\tTIFFGrowStrips() (found by Dmitry V. Levin).\n\n2004-09-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_compress.c}: Added TIFFGetConfiguredCODECs()\n\tto get the list of configured codecs.\n\n\t* libtiff/{tiffiop.h, tif_dirread.c}: More overflow fixes from\n\tDmitry V. Levin.\n\n2004-09-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Applied patch from Dmitry V. Levin to fix\n\tpossible integer overflow in CheckMalloc() function.\n\n2004-09-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_strip.c}: Use TIFFhowmany8() macro instead\n\tof plain TIFFhowmany() where appropriate.\n\n2004-09-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Initialize arrays after space allocation.\n\n2004-09-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0beta released.\n\n\t* libtiff/{tif_luv.c, tif_next.c, tif_thunder.c}: Several buffer\n\toverruns fixed, as noted by Chris Evans.\n\n2004-09-14  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* commit: Added a script to make it more convenient to commit\n\tupdates.  The CVS commit message is extracted from this ChangeLog\n\tfile.\n\n2004-09-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, configure, aclocal.m4, libtiff/{mkspans.c, tif_fax3.c,\n\ttif_getimage.c, tif_luv.c, tif_lzw.c, tif_ojpeg.c, tif_packbits.c,\n\ttif_predict.c, tif_read.c, tif_swab.c, tif_thunder.c, tif_write.c,\n\ttif_dir.c, tif_dirread.c, tif_dirwrite.c, tif_jpeg.c, tif_dirinfo.c,\n\ttif_vms.c, tif_print.c, tif_strip.c, tif_tile.c, tif_dir.h,\n\ttif_config.h.in, tiffiop.h}:\n\tGet rid of BSD data types (u_char, u_short, u_int, u_long).\n\n2004-09-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiff.h: Fix column tagging. Reference current Adobe XMP\n\tspecification. Reference libtiff bug tracking system to submit\n\tprivate tag additions.\n\n2004-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Include \"tif_config.h\".\n\n\t* configure.ac: Use AM_PROG_CC_C_O since it is now needed to build\n\ttiffgt.  This results in the 'compile' script being added to the\n\tproject.\n\n\t* tools/Makefile.am (tiffgt_CFLAGS): Add extra build options\n\trequired to find OpenGL headers necessary to build tiffgt.  Also\n\tensure that the libtiff that we built is used rather than some other\n\tlibtiff installed on the system.\n\n2004-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, acinclude.m4, aclocal.m4: New macros to detect GLUT\n\tlibraries.\n\n2004-09-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Pass library configuration defines via\n\ttif_config.h rather than extending CPPFLAGS. Configure a\n\tlibtiff/tiffconf.h in order to satisfy application requirements\n\t(not used by library build). Do not define _POSIX_C_SOURCE=2 since\n\tthis causes failure to build on systems which properly respect\n\tthis request.\n\n\t* libtiff/tiffconf.h.in: New file to act as the template for the\n\tconfigured tiffconf.h\n\n\t* libtiff/files.lst (HDRS): Install the configured tiffconf.h.\n\n2004-09-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/internals.html: Split off a discussion of adding new tags\n\tinto addingtags.html.\n\n2004-09-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* test/{ascii_tag.c, long_tag.c}: Preliminary test suite added.\n\n\t* tools/tiff2pdf.c: Fixed reading TransferFunction tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n\t* libtiff/tif_print.c: Fixes in InkNames and NumberOfInks reporting.\n\n\t* libtiff/tif_dirread.c: Don't reject to read tags of the\n\tSamplesPerPixel size when the tag count is greater than number of\n\tsamples as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=576\n\n\t* libtiff/tiff.h: Use _TIFF_DATA_TYPEDEFS_ guardian to switch off\n\tdefining int8/uint8/... etc. types. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=607\n\n2004-09-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c, tools/tiffmedian.c: fiddle with include files\n\tto avoid compile warnings about getopt() and a few other things.\n\n2004-09-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Use memcpy() function instead of pointer\n\tassigning magic in TIFFFetchFloat().\n\n2004-09-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_open.c}: Applied patches from Joris Van Damme\n\tto avoid requirement for tiffiop.h inclusion in some applications. See\n\there\n\n\thttp://www.asmail.be/msg0054799560.html\n\n\tfor details.\n\n\t* tools/fax2tiff.c: Use the new functions in the code.\n\n2004-08-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Initialize arrays properly.\n\n\t* tools/tiff2ps.c: Avoid zero division in setupPageState() function;\n\tproperly initialize array in PSDataBW().\n\n2004-08-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: More fixes for bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n\tfrom Ross Finlayson.\n\n2004-08-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed problem with uninitialized values.\n\n\t* libtiff/tif_dir.c: Initialize tif_foundfield data member in the\n\tTIFFDefaultDirectory() (in addition to 2004-08-19 fix).\n\n\t* tools/tiff2pdf.c: Fixed a bunch of problems as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n2004-08-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Applied patch from Ross Finlayson that checks\n\tthat the input file has compression, photometric interpretation,\n\tetcetra, tags or if not than a more descriptive error is returned.\n\n\t* libtiff/tif_dirread.c: Fixed problem in TIFFReadDirectory() in the\n\tcode, responsible for tag data type checking.\n\n2004-08-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dirinfo.c}: Fixed problem with the static\n\tvariable as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=593\n\n2004-08-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ras2tiff.c: Fixed issue with missed big-endian checks as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=586\n\n2004-08-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_config.h.in, tif_config.h.vc}: config.h.in and\n\tconfig.h.vc files renamed in the tif_config.h.in and tif_config.h.vc.\n\n2004-07-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: LZW compression code is merged back from the\n\tseparate package. All libtiff tools are updated to not advertise an\n\tabcence of LZW support.\n\n2004-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Revert thandle_t back to void* type.\n\n2004-07-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_read.c, tif_tile.c, tif_strip.c}: Fixes in error\n\tmessages, as suggested by Bernd Herd.\n\n2004-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Call TIFFError() instead of producing warnings\n\twhen setting custom tags by value. Reported by Eric Fieleke.\n\n2004-06-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tiff.c: Add missed RawsPerStrip setting.\n\n2004-06-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tiff.c: Added new utility to convert Windows BMP files\n\tinto TIFFs.\n\n2004-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0alpha released.\n\n2004-06-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiff.h, tif_dirwrite.c, tif_fax3.c, tif_packbits.c,}: Get rid\n\tof ugly 64-bit hacks, replace them with the clever (autoconf based )\n\tones :-).\n\n\t* libtiff/tiffio.h: Define thandle_t as int, not void* (may cause\n\tproblems in 64-bit environment).\n\n2004-06-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: tiffset now can set any libtiff supported tags.\n\tTags can be supplied by the mnemonic name or number.\n\n\t* libtiff/{tiffio.h, tif_dir.h, tif_dirinfo.c,}: Added two new\n\tfunctions TIFFFindFieldInfoByName() and TIFFFieldWithName().\n\n2004-05-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_ojpeg.c: Fixed problem with duplicated SOI and SOF\n\tmarkers as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=581\n\n2004-05-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Don't forget to copy Photometric\n\tInterpretation tag.\n\n2004-05-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_open.c, tiffio.h}: New function added:\n\tTIFFIsBigEndian(). Function returns nonzero if given was file written\n\tin big-endian order.\n\n\t* tools/tiffsplit.c: Fixed problem with unproperly written multibyte\n\tfiles. Now output files will be written using the same byte order\n\tflag as\tin the input image. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=574\n\n\tfor details.\n\n2004-05-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: added (untested) support for printing\n\tSSHORT, SLONG and SRATIONAL fields.\n\n\t* tools/tiffcp.c: close output file on normal exit.\n\n2004-05-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Avoid reading CCITT compression options\n\tif compression type mismatches. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=565\n\n2004-04-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_strip.c: Never return 0 from the\n\tTIFFNumberOfStrips().\n\n2004-04-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Workaround for broken TIFF writers which\n\tstore single SampleFormat value for multisampled images. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=562\n\n2004-04-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/{tiff.h, config.h.in}: Added tests for int8,\n\tint16 and int32 types to avoid complains on some compilers. Details at\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2004-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Fixed problem with unaligned access as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=555\n\n2004-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Allow in-place updating of the compressed\n\timages (don't work properly with all codecs). For details see GDAL bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=534\n\n2004-04-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Workaround for wrong sampling factors used\n\tin the Intergarph JPEG compressed TIFF images as per bug:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=532\n\n2004-04-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: close clientdata if TIFFClientOpen() fails\n\tvia bad2.\n\n2004-03-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Properly set Photometric Interpretation in case of\n\tJPEG compression of grayscale images.\n\n\t* tools/tiffcp.c: Don't emit warnings when Orientation tag does not\n\tpresent in the input image.\n\n2004-03-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* {many}: The first attempt to switch to autotools.\n\n2004-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Use dummy mmap/munmap functions in\n\tTIFFClientOpen() when the appropriate client functions was not\n\tsupplied by user.\n\n2004-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/ycbcr.c: fixed main() declaration as per:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=513\n\n2004-02-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Copy JPEGTables tag contents for JPEG compressed\n\timages. Reported by Artem Mirolubov.\n\n\t* libtiff/tif_dirread.c: Fixed problem with handling TIFF_UNDEFINED\n\ttag type in TIFFFetchNormalTag() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=508\n\n2004-02-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_codec.c: Fixed typo in TIFFInitPackBits name as per:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=494\n\n2004-02-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Fixed problem with CCITT encoding modes as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=483\n\n\tBut we need more work on fax codec to support update mode.\n\n2004-01-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Added TIFFCurrentDirOffset, TIFFWriteCheck,\n\tTIFFRGBAImageOK, and TIFFNumberOfDirectories as suggested by\n\tScott Reynolds.\n\n2004-01-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Fixed tag definitions for TIFFTAG_YCLIPPATHUNITS\n\tand TIFFTAG_INDEXED as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=475\n\n\t* libtiff/{tif_win32.c, tif_unix.c}: Check whether the pointer is\n\tNULL before proceeding further as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=474\n\n\tCheck results, returned by the TIFFFdOpen() before returning and close\n\tfile if TIFFFdOpen() failed as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n\t* libtiff/tif_open.c: More fixes for\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n2004-01-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{libtiff.def, tif_close.c, tiffio.h, tif_open.c}: Separate\n\tTIFFCleanup() from the TIFFClose() in order to fix the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n\t* tools/tiffcp.c: Fixed problem with wrong interpretation of the\n\tInkNames tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=466\n\n\tMemory leak fixed.\n\n2004-01-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Fixed handling of writable ASCII tags that\n\tare field_passcount=TRUE properly.  Arguably anonymous custom tags\n\tshould be declared as passcount=FALSE, but I don't want to change\n\tthat without a careful review.\n\n2004-01-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Fixed reporting size of the buffer in case of\n\tstripped image in TIFFWriteBufferSetup(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=460\n\n2004-01-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Incomplete cleanup in TIFFFreeDirectory(),\n\tpatch from Gerben Koopmans.\n\n\t* libtiff/tif_dirread.c: Check field_passcount value before setting\n\tthe value of undefined type, patch from Gerben Koopmans.\n\n2004-01-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed problem with wrong Photometric setting for\n\tnon-RGB images.\n\n2003-12-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_win32.c: Fixed problem with _TIFFrealloc() when the NULL\n\tpointer passed. Patch supplied by Larry Grill.\n\n\t* libtiff/{tiff.h, tif_fax3.c}:Fixes for AMD 64 platform as\n\tsuggested by Jeremy C. Reed.\n\n2003-12-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.6.1 released.\n\n2003-12-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* config.guess, config.sub: Updated from the recent upstream.\n\n2003-12-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_color, tif_getimage.c, tiffio.h}, man/TIFFcolor.3t:\n\tMore cleanups in color conversion interface, added appropriate manual\n\tpage.\n\n2003-12-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_extension.c, tif_dirinfo.c, tiff.h}: Warnings fixed as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=357\n\n\t* tools/tiff2ps.c: Added support for alpha channel. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=428\n\n\t* libtiff/{libtiff.def, tif_color.c, tif_getimage.c, tiffio.h}:\n\tInterface for Lab->RGB color conversion is finally cleaned up.\n\tAdded support for ReferenceBlackWhite tag handling when converted from\n\tYCbCr color space. The latter closes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=120\n\n2003-12-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tiffio.h}: Avoid warnings.\n\n\t* libtiff/makefile.vc, tools/makefile.vc: Support for IJG JPEG\n\tlibrary.\n\n2003-12-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_aux.c}: Read WhitePoint tag from the\n\tfile and properly use it for CIE Lab->RGB transform.\n\n2003-12-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_color.c, tiffio.h}: YCbCr->RGB\n\tconversion routines now in the tif_color.c module. New function\n\tTIFFYCbCrtoRGB() available in TIFF API.\n\n\t* libtiff/tif_dirwrite.c: Handle TIFF_IFD tag type correctly.\n\n2003-12-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_color.c, tiffio.h}: Improvements in\n\tCIE Lab conversion code. Start moving YCbCr stuff to the tif_color.c\n\tmodule.\n\n\t* libtiff/{tif_getimage.c, tiffio.h}, man{TIFFReadRGBAImage.3t,\n\tTIFFReadRGBAStrip.3t, TIFFReadRGBATile.3t, TIFFRGBAImage.3t}:\n\tFinally resolved problems with orientation handling. TIFFRGBAImage\n\tinterface now properly supports all possible orientations, i.e. images\n\twill be flipped both in horizontal and vertical directions if\n\trequired. 'Known bugs' section now removed from the appropriate manual\n\tpages. Closed bug entry:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=322\n\n2003-12-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Fixed order of the parameters in TIFFError()\n\tfunction calls as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=440\n\n2003-11-28 Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* tools/tiff2pdf.c:  Some bugs fixed.\n\n2003-11-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_luv.c: Fixed bug in 48-bit to 24-bit conversion routine,\n\treported by Antonio Scuri.\n\n\t* man/tiff2pdf.1: Few improvements in page layout.\n\n\t* Makefile.in, /man/Makefile.in, /html/man/tiff2pdf.1.html:\n\t Added support fpr tiff2pdf manual page.\n\n2003-11-26 Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* /man/tiff2pdf.1:  File added to repository.\n\n2003-11-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in, /tools/{Makefile.in, makefile.vc}:\n\t Added support fpr tiff2pdf utility.\n\n2003-11-25  Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* /tools/tiff2pdf.c:  File added to repository.\n\n2003-11-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/raw2tiff.c: sqrtf() replaced with sqrt().\n\n2003-11-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/raw2tiff.c: #include <getopt.h> removed.\n\n\t* tools/{Makefile.in, tiffgt.c}: Unmaintained and platform dependent\n\tsgigt utility removed and replaced with the completely rewritten\n\tportable tiffgt tool (depend on OpenGL and GLUT). Initial revision,\n\tthere is a lot of things to improve.\n\n\t* libtiff/tif_ojpeg.c: TIFFVGetField() function now can properly\n\textract the fields from the OJPEG files. Patch supplied by Ross\n\tFinlayson.\n\n\t* libtiff/{tiffio.h, tif_codec.c}, man/{libtiff.3t, TIFFcodec.3t}:\n\tAdded new function TIFFIsCODECConfigured(), suggested by Ross\n\tFinlayson.\n\n2003-11-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Implemented binary search in\n\t_TIFFMergeFieldInfo(). Patch supplied by Ross Finlayson.\n\n\t* libtiff/tif_dir.h: _TIFFFindOrRegisterdInfo declaration replaced\n\twith _TIFFFindOrRegisterFieldInfo as reported by Ross Finlayson.\n\n2003-11-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: do not mark all anonymously defined tags to be\n\tIGNOREd.\n\n2003-11-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/pds/{tif_pdsdirread.c, tif_pdsdirwrite.c}: Use\n\tTIFFDataWidth() function insted of tiffDataWidth array.\n\n2003-11-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiff.h, tif_dirinfo.c}: Added support for IFD (13)\n\tdatatype, intruduced in \"Adobe PageMaker TIFF Tech. Notes\".\n\n2003-11-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Makefile.in: fixed missing backslash for tif_color.c in list.\n\n2003-11-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_color.c, tif_getimage.c, tiffio.h, Makefile.in}:\n\tNew color space conversion code: CIE L*a*b* 1976 images now supported\n\tby the TIFFRGBAImage interface. All introduced routines go to new\n\tmodule tif_color.c. Eventually all color conversion functions should\n\tbe moved there.\n\n2003-11-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{ras2tiff.c, rasterfile.h}: Properly determine SUN Rasterfiles\n\twith the reverse byte order (it is reported by the magic header\n\tfield). Problem reported by Andreas Wiesmann.\n\n\t* tools/raw2tiff.c, man/raw2tiff.1: Few improvements in correlation\n\tcalculation function. Guessing mechanics now documented in manual page.\n\n2003-11-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Implemented image size guessing using\n\tcorrelation coefficient calculation between two neighbour lines.\n\n2003-11-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_tile.c: remove spurious use of \"s\" (sample) in the\n\tplanarconfig_contig case in TIFFComputeTile().\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=387\n\n2003-11-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffiop.h: New macros: TIFFmax, TIFFmin and TIFFrint.\n\n2003-11-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_strip.c}, man/{TIFFstrip.3t, libtiff.3t}:\n\tAdded TIFFRawStripSize() function as suggested by Chris Hanson.\n\n2003-11-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_lzw.c, tif_fax3.c}: Proper support for update mode as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=424\n\n2003-10-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added TIFFReadRGBAImageOriented.\n\n\t* html/build.html: Added note about GNU make requirement.\n\n2003-10-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Fixes in using MAKEFLAGS as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=418\n\n\t* port/install.sh.in: Option -p added to the mkdir command to create\n\tall directory tree structure before installing.\n\n2003-10-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/tiff2ps.c: #include <strings.h> replaced with the\n\t#include <string.h>.\n\n2003-10-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Add an absolute path to the test_pics.sh call.\n\n2003-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffcomp.h: #define _BSDTYPES_DEFINED when defining BSD\n\ttypedefs.\n\n2003-10-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, libtiff/{Makefile.in, mkversion.c}:\n\tRelative buildings fixed.\n\n\t* tools/Makefile.in: Added \"-I../libtiff\" to the tiffset building\n\trule.\n\n2003-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Added missed v3.6.0.html.\n\n\t* libtiff/tiffio.h: Typo fixed: ORIENTATION_BOTTOMLEFT replaced with\n\tORIENTATION_BOTLEFT.\n\n2003-10-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* 3.6.0 final release.\n\n2003-10-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tiffio.h}, man/TIFFReadRGBAImage.3t: New\n\tfunction TIFFReadRGBAImageOriented() implemented to retrieve raster\n\tarray with user-specified origin position as suggested by Jason Frank.\n\tSee\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=322\n\n\tfor details.\n\n\t* tools/tiff2rgba.c: Switched to use TIFFReadRGBAImageOriented()\n\tinstead of TIFFReadRGBAImage().\n\n\t* tools/tiff2ps.c: Fixed possible endless loop as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=404\n\n2003-09-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Check field counter against number of fields\n\tin order to fix\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=366\n\n\t* libtiff/tif_fax3.c: Fix wrong line numbering as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=342\n\n2003-09-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dirread.c, tif_dir.c, tif_open.c,\n\ttif_close.c}: Store a list of opened IFD to prevent looping as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=383\n\n2003-09-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: More fixes for\tEstimateStripByteCounts(). See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=358\n\n2003-08-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffmedian.c: int declaration replaced with the uint32 to\n\tsupport large images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=382\n\n2003-08-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n \t* libtiff/Makefile.in: Fixed problem with building in different\n\tdirectory.\n\n\t* tools/tiff2ps.c: Added missing #include <strings.h>.\n\n\t* libtiff/tif_dirwrite.c: More fixes for custom tags code\n\tfrom Ashley Dreier.\n\n2003-08-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Added page size setting when creating PS Level 2.\n\tPatch submitted by Balatoni Denes (with corrections from Tom\n\tKacvinsky).\n\n\t* tools/tiff2ps.c: Fixed PS comment emitted when FlateDecode is\n\tbeing used. Reported by Tom Kacvinsky.\n\n\t* libtiff/tif_dirwrite.c: Fixed problem with custom tags writing,\n\treported by Ashley Dreier.\n\n\t* libtiff/tif_print.c: Fixed problem with float tags reading, support\n\tfor printing RATIONAL and BYTE tags added.\n\n2003-08-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: Move LZW codec state block allocation back to\n\tTIFFInitLZW(), because its initialization in LZWSetupDecode() cause\n\tproblems with predictor initialization. Remove O_RDONLY check during\n\tstate block allocation to be able open LZW compressed files in update\n\tmode.\n\n\tProblem exist for libtiff version of the tif_lzw.c module. One from\n\tlzw-compression-kit hasn't such troubles.\n\n2003-08-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: modified tif_write.c so that the various\n\tencoded write functions use tif_postdecode() to apply byte order\n\tswapping (swab) to the application passed data buffer if the same\n\twould be done when reading.  This allows us to write pixel data with\n\tmore than 8 bits per sample to existing files of a non-native byte\n\torder.  One side effect of this change is the applications buffer\n\titself is altered in this case by the act of writing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=171\n\n2003-07-25  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: avoid signed/unsigned casting warning\n\tinitializing typemask as per patch from J.A. Strother.\n\n\t* tools/tiffcp.c: fixed signed/unsigned casting warning.\n\n\t* libtiff/tif_print.c: dos2unix conversion.\n\n\t* tools/tiffsplit.c: increased the maximum number of pages that\n\tcan be split.  Patch provided by Andrew J. Montalenti.\n\n2003-07-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Added option `-p' to explicitly select color\n\tspace of input image data. Closes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=364\n\n2003-07-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_aux.c, tif_codec.c, tif_dir.c, tif_dirread.c, tif_extension.c,\n\ttif_fax3.c, tif_getimage.c, tif_luv.c, tif_lzw.c, tif_next.c,\n\ttif_packbits.c, tif_predict.c, tif_print.c, tif_swab.c, tif_thunder.c:\n\tavoid casting warning at /W4.\n\n2003-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/thumbnail.c: Memory leak fixed as reported by Robert S. Kissel.\n\n2003-06-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_pixarlog.c: Unused variables removed.\n\n\t* libtiff/{tif_dirread.c, tif_dir.c}: Fixed problem with\n\tEstimateStripByteCounts() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=358\n\n\t* libtiff/{tif_dirwrite.c, tif_packbits.c}: Fixed compilation on\n\t64-bit architectures as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=357\n\n\t* libtiff/tif_dirinfo.c: TIFFDataWidth() returns 0 in case of\n\tunknown data type.\n\n2003-06-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: fixed some serious bugs when printing\n\tcustom tags ... almost certain to crash.\n\n\t* libtiff/tif_dirread.c: Don't ignore custom fields that are\n\tautodefined.  Not sure how this got to be like this.\n\n2003-06-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* 3.6.0 Beta2 released.\n\n\t* tools/tiffcmp.c, man/tiffcmp.1: Fixed problem with unused data\n\tcomparing as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=349\n\n\t`-z' option now can be used to set the number of reported different\n\tbytes.\n\n2003-06-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c, man/tiffcp.1: Added possibility to specify value -1\n\tto -r option to get the entire image as one strip. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=343\n\n\tfor details.\n\n2003-06-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Set the correct RowsPerStrip and PageNumber\n\tvalues as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=343\n\n2003-05-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: modified segment_height calculation to always\n\tbe a full height tile for tiled images.  Also changed error to just\n\tbe a warning.\n\n2003-05-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Page numbering fixed, as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=341\n\n2003-05-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/ojpeg/{Makefile.in, jdhuff.h, jinclude.h, ojpeg.c, README},\n\tconfigure, Makefile.in:\tSwitched back to the old behaviour. Likely\n\tbetter solution should be found for OJPEG support.\n\n2003-05-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/mkversion.c: Fixed problem with wrong string size when\n\treading RELEASE-DATE file.\n\n2003-05-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed bug in Ascii85EncodeBlock() function: array\n\tindex was out of range.\n\n2003-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/ojpeg/{Makefile.in, jdhuff.h, jinclude.h, ojpeg.c, README},\n\tconfigure, Makefile.in:\tImproved libtiff compilation with OJPEG\n\tsupport. Now no need for patching IJG JPEG library, hack requred by\n\tlibtiff will be compiled and used in-place. Implemented with\n\tsuggestion and help from Bill Allombert, Debian's libjpeg maintainer.\n\n\t* libtiff/tif_aux.c: Properly handle TIFFTAG_PREDICTOR in\n\tTIFFVGetFieldDefaulted() function.\n\n2003-05-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: PPM header parser improved: now able to skip\n\tcomments.\n\n\t* tools/tiffdither.c: Fixed problem with bit fill order tag setting:\n\twas not copied from source image.\n\n\t* libtiff/getimage.c: Workaround for some images without correct\n\tinfo about alpha channel as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=331\n\n2003-04-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c, man/tiff2ps.1: Add ability to generate PS Level 3.\n\tIt basically allows one to use the /flateDecode filter for ZIP\n\tcompressed TIFF images. Patch supplied by Tom Kacvinsky. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=328\n\n\t* tools/tiff2ps.c: Force deadzone printing when EPS output specified\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=325\n\n2003-04-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Removed additional check for StripByteCounts\n\tdue to problems with multidirectory images. Quality of error messages\n\timproved.\n\n2003-04-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed problem with colorspace conversion for JPEG\n\tencoded images. See bug entries\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=275\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=23\n\n\t* libtiff/tif_dirread.c: Additional check for StripByteCounts\n\tcorrectness. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=320\n\n2003-03-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{fax2ps.c, fax2tiff.c, gif2tiff.c, pal2rgb.c, ppm2tiff.c,\n\tras2tiff.c, raw2tiff.c, rgb2ycbcr.c, thumbnail.c, tiff2bw.c,\n\ttiff2ps.c, tiff2rgba.c, tiffcp.c, tiffdither.c, tiffinfo.c,\n\ttiffmedian.c}: Added library version reporting facility to all tools.\n\n2003-03-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* port/install.sh.in: Fixed problems with install producing paths\n\tlike ///usr/local/lib on cygwin.\n\n2003-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c, man/fax2tiff.1: New switch (-X) to set width of\n\traw input page. Patch supplied by Julien Gaulmin. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=293\n\n\tfor details.\n\n2003-02-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fixed up the tif_postdecode settings\n\tresponsible for byte swapping complex image data.\n\n\t* libtiff/tif_lzw.c: fixed so that decoder state isn't allocated till\n\tLZWSetupDecode().  Needed to read LZW files in \"r+\" mode.\n\n2003-02-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: Fixed problem with too many arguments.\n\n2003-02-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Memory leak fixed.\n\n2003-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c, man/fax2tiff.1: Applied patch from Julien Gaulmin\n\t(thanks, Julien!). More switches for fax2tiff tool for better control\n\tof input and output. Details at\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=272\n\n2003-02-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Modified to defer initialization of jpeg\n\tlibrary so that we can check if there is already any tile/strip data\n\tbefore deciding between creating a compressor or a decompressor.\n\n2003-01-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: TIFFWriteCheck() now fails if the image is\n\ta pre-existing compressed image.  That is, image writing to\n\tpre-existing compressed images is not allowed.\n\n\t* libtiff/tif_open.c: Removed error if opening a compressed file\n\tin update mode.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=198\n\n2003-01-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* config.guess, config.sub: Updated to recent upstream versions.\n\n2003-01-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* cut 3.6.0 Beta release.\n\n2002-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2ps.c, man/fax2ps.1: Page size was determined\n\tin wrong way as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=239\n\n2002-12-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Allow wrong sized arrays in\n\tTIFFFetchStripThing().\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=49\n\n2002-12-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fix problem with test on td_customValueCount.\n\tWas using realloc even first time.  Fix by Igor Venevtsev.\n\n2002-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fixed bug with resetting an existing custom\n\tfield value.\n\n\t* libtiff/tif_dir.c: Fixed potential problem with ascii \"custom\"\n\ttags in TIFFVGetField() ... added missing break.\n\n2002-10-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c: fixes a problem where \"tiff2ps -1e\" did not make\n\tthe scanline buffer long enough when writing rgb triplets.\n\tThe scanline needs to be 3 X the number of dots or else it will\n\tcontain\tan incomplete triplet and programs that try to separate\n\tthe eps by redefining the colorimage operator will get messed up.\n\tPatch supplied by William Bader.\n\n\t* Makefile.in: added tif_extension.c to file list as per\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=218.\n\n2002-10-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, config.site, libtiff/{tif_unix.c, Makefile.in}: Fix for\n\tlarge files (>2GiB) supporting. New option in the config.site:\n\tLARGEFILE=\"yes\". Should be enough for I/O of the large files.\n\n2002-10-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/html/v3.6.0.html: new release notes.\n\n\t* libtiff/index.html: removed faq, cvs snapshot cruft.  Added email\n\tlink for Andrey.  Pointer to v3.6.0.html.\n\n\t* libtiff/Makefile.in: added direct rule for tiffvers.h for release.\n\n2002-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\t* tools/tiff2ps.c, man/tiff2ps.1: Applied patch form Sebastian Eken\n\t(thanks, Sebastian!). New switches:\n\t-b # for a bottom margin of # inches\n\t-c   center image\n\t-l # for a left margin of # inches\n\t-r   rotate the image by 180 degrees\n\tNew features merged with code for shrinking/overlapping.\n\tPreviously added -c and -n switches (for overriding PS units) renamed\n\tin -x and -y respectively.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=200\n\n\t* html/man/*.html: Updated from actual manual pages.\n\n2002-10-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: fixed problem with boolean defined with wrong\n\tsize on windows.  Use #define boolean hack.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=188\n\n\t* libtiff/tiff.h: Don't do special type handling in tiff.h unless\n\tUSING_VISUALAGE is defined.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2002-10-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: added COMPRESSION_JP2000.\n\n2002-10-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Another fix for the fetching SBYTE arrays\n\tby the TIFFFetchByteArray() function. Should finally resolve\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=52\n\n\t* configure: Set -DPIXARLOG_SUPPORT option along with -DZIP_SUPPORT\n\n\t* html/Makefile.in: New targets added: html and groffhtml for\n\tproducing HTML representations of the manual pages automatically.\n\thtml target uses man2html tool, groffhtml uses groff tool.\n\n2002-09-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: Added SCO OpenServer 5.0.6 support\n\tfrom John H. DuBois III.\n\n2002-09-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in, /man/{raw2tiff.1, Makefile.in, libtiff.3}: Added\n\tmanual page for raw2tiff(1) tool.\n\n2002-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/{tiffio.h, tif_dir.h}: TIFFDataWidth() declaration moved to\n\tthe tiffio.h header file.\n\n\t* Makefile.in, /man/{TIFFDataWidth.3t, Makefile.in, libtiff.3}: Added\n\tmanual page for TIFFDataWidth() function\n\n2002-09-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Expand v[2] to v[4] in TIFFFetchShortPair()\n\tas per http://bugzilla.remotesensing.org/show_bug.cgi?id=196.\n\n\t* tools/tiff2ps.c: Don't emit BeginData/EndData DSC comments\n\tsince we are unable to properly include the amount to skip.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=80\n\n2002-09-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/tif_dirread.c: Fixed problem with SBYTE type data fetching\n\tin TIFFFetchByteArray(). Problem described at\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=52\n\n2002-08-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/tif_dirinfo.c: Further additions to free custom fields\n\tin _TIFFSetupFieldInfo() function.\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=169 for details.\n\n\t* /libtiff/tif_lzw.c: Additional consistency checking added in\n\tLZWDecode() and LZWDecodeCompat().\n\tFixes http://bugzilla.remotesensing.org/show_bug.cgi?id=190\n\tand http://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n\t* /libtiff/tif_lzw.c:\n\tAdded check for valid code lengths in LZWDecode() and\n\tLZWDecodeCompat(). Fixes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=115\n\n2002-08-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/{Makefile.vc, libtiff.def}:\n\tMissed declarations added.\n\n2002-08-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_getimage.c: Ensure that TIFFRGBAImageBegin() returns the\n\treturn code from the underlying pick function.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=177\n\n\t* tif_dir.h: changed FIELD_CODEC to 66 from 64 to avoid overlap\n\twith FIELD_CUSTOM as mentioned in bug 169.\n\n\t* tif_close.c: added logic to free dynamically created anonymous\n\tfield definitions to correct a small memory leak.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=169\n\n2002-08-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/{raw2tiff.c, Makefile.in, Makefile.lcc, Makefile.vc}:\n\tNew tool: raw2tiff --- raw images to TIFF converter. No manual page yet.\n\n2002-07-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Fixed problem with setting of nrows in\n\tJPEGDecode() as per bugzilla bug (issue 1):\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=129\n\n\t* libtiff/{tif_jpeg.c,tif_strip.c,tif_print.c}: Hacked tif_jpeg.c to\n\tfetch TIFFTAG_YCBCRSUBSAMPLING from the jpeg data stream if it isn't\n\tpresent in the tiff tags.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\n\t* libtiff/tif_read.c, libtiff/tif_write.c: TIFFReadScanline() and\n\tTIFFWriteScanline() now set tif_row explicitly in case the codec has\n\tfooled with the value.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=129\n\n2002-06-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/tiff2ps.c: Added workaround for some software that may crash\n\twhen last strip of image contains fewer number of scanlines than\n\tspecified by the `/Height' variable. See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=164\n\tfor explanation.\n\n2002-06-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps, man/tiff2ps.1: New functionality for tiff2ps utility:\n\tsplitting long images in several pages. See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=142 for explanation.\n\tPatch granted by John Williams <williams@morinda.com>.\n\n2002-06-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/contrib/win95: renamed to contrib/win_dib.  Added new\n\tTiffile.cpp example of converting TIFF files into a DIB on Win32.\n\tThis one is described in:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=143\n\n\t* libtiff/tif_ojpeg.c: Major upgrade from Scott.  See details at:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=156\n\n2002-05-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps: New commandline switches to override resolution\n\tunits obtained from the input file. Closes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=131\n\n2002-04-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed declaration.\n\n2002-04-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Updated to reflect latest changes in libtiff.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=125\n\n2002-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Pointers to custom procedures\n\tin TIFFClientOpen() are checked to be not NULL-pointers.\n\n2002-04-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed declarations.\n\n\t* libtiff/tif_pixarlog.c: Updated for using tif_tagmethods structure.\n\n2002-04-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: Additional checks for data integrity introduced.\n\tShould finally close\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n2002-04-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps: Division by zero fixed.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=88\n\n2002-04-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dirwrite.c, tif_write.c, tiffio.h:\n\tTIFFCheckpointDirectory() routine added.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=124\n\n\t* man/: TIFFWriteDirectory.3t,  Makefile.in: Added description\n\tfor the new function.\n\n2002-04-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_codec.c, tif_compress.c, tiffiop.h: Introduced\n\tadditional members tif->tif_decodestatus and tif->tif_encodestatus\n\tfor correct handling of unconfigured codecs (we should not try to read\n\tdata or to define data size without correct codecs).\n\n\t* libtiff/tif_getimage.c: The way of codecs checking in TIFFRGBAImageOK\n\tchanged. Now it has used tif->tif_decodestatus and\n\ttif->tif_encodestatus.\n\tShould fix http://bugzilla.remotesensing.org/show_bug.cgi?id=119 (in\n\tcase of __cvs_8.tif test image).\n\n\t* libtiff/: tif_dirinfo.c, tif_dirread.c: Somebody makes a bug in\n\ttif_dirread.c when TIFFCreateAnonFieldInfo was introduced.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=119 in case\n\tof _cvs_00000-00.tif, _cvs_00000-01.tif and _cvs_00000-02.tif.\n\n2002-04-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_lzw.c: Assertions in LZWDecode and LZWDecodeCompat\n\treplaced by warnings. Now libtiff should read corrupted LZW-compressed\n\tfiles by skipping bad strips.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n2002-04-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Removed some dead code.\n\n\t* libtiff/*: Cleanup some warnings.\n\n\t* libtiff/tif_dir.c: Fixed bug with count returned by TIFFGetField()\n\tfor variable length FIELD_CUSTOM values.  Was int * but should be\n\tu_short *.\n\n2002-04-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/: tifcp.c: Added support for 'Orientation' tag in tiffcp\n\tutility (at cpStripToTile routine).\n\n2002-03-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: avoid div-by-zero if rowbytes is zero in chop func.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=111\n\n\t* tif_print.c: Fixed so that ASCII FIELD_CUSTOM values with\n\tpasscount set FALSE can be printed (such as TIFFTAG_SOFTWARE).\n\n\t* libtiff/tif_dir.c,tif_dirinfo.c,tif_dir.h,tif_ojpeg.c: modified so\n\tthat TIFFTAG_SOFTWARE uses FIELD_CUSTOM as an example.\n\n2002-03-26  Dwight Kelly  <dbmalloc@remotesensing.org>\n\n\t* libtiff/: tiff.h, tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_dirread.c,\n\ttif_dirwrite.c: Added get/put code for new tag XMLPACKET as defined\n\tin Adobe XMP Technote. Added missing INKSET tag value from TIFF 6.0 spec\n\tINKSET_MULTIINK (=2). Added missing tags from Adobe TIFF technotes:\n\tCLIPPATH, XCLIPPATHUNITS, YCLIPPATHUNITS, OPIIMAGEID, OPIPROXY and\n\tINDEXED. Added PHOTOMETRIC tag value from TIFF technote 4 ICCLAB (=9).\n\n2002-03-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_getimage.c: TIFFReadRGBAStrip and TIFFReadRGBATile\n\tnow also uses TIFFRGBAImageOK before reading. This is additional fix\n\tfor http://bugzilla.remotesensing.org/show_bug.cgi?id=110\n\n2002-03-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_getimage.c: Additional check for supported\n\tcodecs added in TIFFRGBAImageOK and TIFFReadRGBAImage now uses\n\tTIFFRGBAImageOK before reading.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=110\n\n2002-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_dirread.c,\n\ttif_dirwrite.c: Added routine TIFFDataWidth for detrmining\n\tTIFFDataType sizes instead of working with tiffDataWidth array\n\tdirectly. Should prevent out-of-borders bugs in case of unknown or\n\tbroken data types.  EstimateStripByteCounts routine modified, so it\n\twon't work when tags with uknown sizes founded.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=109\n\n2002-03-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Added support for correct handling\n\t`Orientation' tag in gtTileContig. Should be added in other gt*\n\tfunctions as well, but I have not images for testing yet. Partially\n\tresolves http://bugzilla.remotesensing.org/show_bug.cgi?id=23\n\n2002-03-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dirinfo.c, tif_dirwrite.c: Added possibility to\n\tread broken TIFFs with LONG type used for TIFFTAG_COMPRESSION,\n\tTIFFTAG_BITSPERSAMPLE, TIFFTAG_PHOTOMETRIC.  Closes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=99\n\n2002-03-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/Makefile.in, tools/Makefile.in: Shared library will not\n\tbe stripped when installing, utility binaries will do.\tCloses\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=93\n\n2002-02-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/TIFFGetField: fixed type of TIFFTAG_COPYRIGHT.\n\n\t* man/libtiff.3t: added copyright tag info.\n\n2002-02-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tiff.h,tif_fax3.c}: Add support for __arch64__.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=94\n\n\t* man/Makefile.in: Patch DESTDIR handling\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=95\n\n\t* configure: OpenBSD changes for Sparc64 and DSO version.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=96\n\n2002-02-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* config.site/configure: added support for OJPEG=yes option to enable\n\tOJPEG support from config.site.\n\n2002-01-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/document.html: fixed links for TIFf 6 docs.\n\n2002-01-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* config.guess, config.sub: Updated from ftp.gnu.org/pub/config.\n\n\t* libtiff/tif_read.c: Fixed TIFFReadEncodedStrip() to fail if the\n\tdecodestrip function returns anything not greater than zero as per\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=97\n\n\t* configure: Modify CheckForBigEndian so it can work in a cross\n\tcompiled situation.\n\n2002-01-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffdump.c: include TIFFTAG_JPEGTABLES in tag list.\n\n\t* tools/tiffset.c: fix bug in error reporting.\n\n\t* tools/tiffcp.c: fix several warnings that show up with -Wall.\n\n2002-01-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: fixed computation of segment_width for\n\ttiles files to avoid error about it not matching the\n\tcinfo.d.image_width values (\"JPEGPreDecode: Improper JPEG strip/tile\n\tsize.\") for ITIFF files.  Apparently the problem was incorporated since\n\t3.5.5, presumably during the OJPEG/JPEG work recently.\n\n2001-12-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: Changes for building on MacOS 10.1.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=94\n\n\t* libtiff/tif_getimage.c: If DEFAULT_EXTRASAMPLE_AS_ALPHA is 1\n\t(defined in tiffconf.h - 1 by default) then the RGBA interface\n\twill assume that a fourth extra sample is ASSOCALPHA if the\n\tEXTRASAMPLE value isn't set for it.  This changes the behaviour of\n\tthe library, but makes it work better with RGBA files produced by\n\tlots of applications that don't mark the alpha values properly.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=93\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=65\n\n2001-12-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: allow jpeg data stream sampling values to\n\toverride those from tiff directory.  This makes this work with\n\tImageGear generated files.\n\n2001-12-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/Makefile.in: added missing images per bug 92.\n\n\t* port/Makefile.in: fixed clean target per bug 92.\n\n2001-11-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Reissue 3.5.7 release.\n\n\t* libtiff/mkversion.c: Fix output of TIFF_VERSION to be\n\tYYYYMMDD so that it is increasing over time.\n\n\t* Makefile.in: Ensure that tiffvers.h is regenerated in the\n\tmake release target.\n\n\t* Makefile.in: added libtiff/tiffvers.h to the release file list.\n\n2001-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* added html/v3.5.7.html, updated html/index.html.\n\n\t* Makefile.in: added contrib/addtiffo/tif_ovrcache.{c,h}.\n\n2001-11-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure: fixed test for -lm.\n\n2001-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added PHOTOMETRIC_ITULAB as per bug 90.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=90\n\n2001-10-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: I have created COMPRESSION_CCITT_T4,\n\tCOMPRESSION_CCITT_T6, TIFFTAG_T4OPTIONS and TIFFTAG_T6OPTIONS aliases\n\tin keeping with TIFF 6.0 standard in tiff.h\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=83\n\n2001-09-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: added TIFFRewriteDirectory() function.\n\tUpdated TIFFWriteDirectory man page to include TIFFRewriteDirectory.\n\n2001-09-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: Avoid MS VC++ 5.0 optimization bug.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=78\n\n\t* libtiff/tif_lzw.c: added dummy LZWSetupEncode() to report an\n\terror about LZW not being available.\n\n\t* libtiff/tif_dir.c: propagate failure to initialize compression\n\tback from TIFFSetField() as an error status, so applications can\n\tdetect failure.\n\n\t* libtiff/tif_dir.c: removed the auto replacement of\n\tCOMPRESSION_LZW with COMPRESSION_NONE in _TIFFVSetField().\n\n\t* Removed Makefile, tools/Makefile, port/install.sh, man/Makefile\n\tfrom CVS as they are all supposed to be auto-generated by configure.\n\n2001-09-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: new update from Scott.\n\n2001-09-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtif/tif_fax3.c: Removed #ifdef PURIFY logic, and modified to\n\talways use the \"safe\" version, even if there is a very slight\n\tcost in performance.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=54\n\n\t* libtiff/Makefile.in: Fixed @DSOSUB_VERSION to be @DSOSUF_VERSION@\n\tin two places.\n\n\t* libtiff/tif_getimage.c: Fixed problem with reading strips or\n\ttiles that don't start on a tile boundary.  Fix contributed by\n\tJosep Vallverdu (from HP), and further described in bug 47.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=47\n\n\t* tools/tiff2ps.c: added OJPEG YCbCr to RGB support.\n\n\t* libtiff/tif_ojpeg.c: Applied substantial patch from Scott.\n\n2001-09-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_packbits.c: fixed memory overrun error.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=77\n\n2001-08-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: relax handling of contig case where\n\tthere are extra samples that are supposed to be ignored.  This\n\tshould now work for 8bit greyscale or palletted images.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=75\n\n2001-08-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Don't complain for CMYK (separated)\n\timages with more than four samples per pixel.  See:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=73\n\n2001-08-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Use memmove() instead of TIFFmemcpy()\n\tin TIFFReadRGBATile() to avoid issues in cases of overlapping\n\tbuffers.  See Bug 69 in Bugzilla.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=69\n\n\t* tools/tiff2rgba.c: fixed getopt() call so that -b works again.\n\n2001-08-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h, libtiff/tif_fax3.c: added check for __LP64__\n\twhen checking for 64 bit architectures as per bugzilla bug 67.\n\n2001-07-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/Makefile.in: add TIFFClientOpen link as per debian submitted\n\tbug 66.\n\n2001-07-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Define HAVE_BOOLEAN on windows if RPCNDR.H\n\thas been included.\n\n2001-07-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: Seek back to zero after failed read,\n\tbefore writing header.\n\n2001-07-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: updates from Scott.  Handles colors\n\tmuch better.  Now depends on having patched libjpeg as per\n\tpatch in contrib/ojpeg/*.\n\n2001-07-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* */Makefile.in: added DESTDIR support.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=60\n\n2001-07-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: applied OpenBSD patches\n\tas per:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=61\n\n2001-06-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Fixed so that failure is properly\n\treported by gtTileContig, gtStripContig, gtTileSeparate and\n\tgtStripSeparate.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=51\n\n\t* tiffcmp.c: Fixed multi samples per pixel support for ContigCompare.\n\tUpdated bug section of tiffcmp.1 to note tiled file issues.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=53\n\n2001-06-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure: Changes for DSO generation on AIX provided by\n\tJohn Marquart <jomarqua@indiana.edu>.\n\n\t* configure, libtiff/Makeifle.in: Modified to build DSOs properly\n\ton Darwin thanks to Robert Krajewski (rpk@alum.mit.edu) and\n\tKeisuke Fujii (fujiik@jlcuxf.kek.jp).\n\n2001-06-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2rgba.c: added -n flag to avoid emitting alpha component.\n\n\t* man/tiff2rgba.1: new\n\n2001-05-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added tiffset and tif_ojpeg to the dist lists in Makefile.in.\n\n2001-05-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tools/thumbnail.c: changed default output compression\n\tto packbits from LZW since LZW isn't generally available.\n\n2001-05-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: New.\n\tlibtiff/tif_jpeg.c, tiffconf.h, tif_getimage.c: changes related\n\tto OJPEG support.\n\n\tScott Marovich <marovich@hpl.hp.com> supplied OJPEG support.\n\n2001-05-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tiff.h: removed, it duplicates libtiff/tiff.h.\n\n2001-05-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: moved pixar and copyright flags to\n\tensure everything is in order.\n\n\t* libtiff/libtiff.def: added TIFFCreateDirectory and\n\tTIFFDefaultStripSize as per:\n\n\t  http://bugzilla.remotesensing.org/show_bug.cgi?id=46\n\n2001-05-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Modified the TIFF_BYTE definition for\n\tTIFFTAG_PHOTOSHOP to use a writecount of TIFF_VARIABLE2 (-3) to\n\tforce use of uint32 counts instead of short counts.\n\n\t* libtiff/tif_dirwrite.c: Added support for TIFF_VARIABLE2 in the\n\tcase of writing TIFF_BYTE/TIFF_SBYTE fields.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=43\n\n2001-05-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: removed duplicate TIFFTAG_PHOTOSHOP as per\n\tbug report http://bugzilla.remotesensing.org/show_bug.cgi?id=44\n\n2001-04-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tiffio.h: removed C++ style comment.\n\n\t* configure: fixed up SCRIPT_SH/SHELL handling.\n\n\t* Makefile.in: Fixed SCRIPT_SH/SHELL handling.\n\n\t* config.guess: documented more variables as per bug 40.\n\n2001-04-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, *Makefile.in: Various changes to improve configuration\n\tfor HP/UX specifically, and also in general.  They include:\n\t - Try to handle /usr/bin/sh instead of /bin/sh where necessary.\n\t - Upgrade to HP/UX 10.x+ compiler, linker and dso options.\n\t - Fixed mmap() test to avoid MMAP_FIXED ... it isn't available on HP\n\t - Use -${MAKEFLAGS} in sub makes from makefiles.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=40\n\n2001-04-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: Applied hac to try and resolve the problem\n\twith the inttypes.h include file on AIX.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n\t* VERSION: update to 3.5.7 beta in preparation for release.\n\n\t* configure/config.site: modified to check if -lm is needed for\n\tMACHDEPLIBS if not supplied by config.site.  Needed for Darwin.\n\n\t* config.guess: updated wholesale to an FSF version apparently\n\tfrom 1998 (as opposed to 1994).  This is mainly inspired by\n\tproviding for MacOS X support.\n\n2001-03-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, Makefile.in, etc: added support for OPTIMIZER being\n\tset from config.site.\n\n2001-03-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* fax2ps.c: Helge (libtiff at oldach.net) submitted fix:\n\n\tHere's a fix for fax2ps that corrects behaviour for non-Letter paper\n\tsizes. It fixes two problems:\n\n\tWithout\tscaling (-S) the fax is now centered on the page size specified\n\twith -H\tand/or -W. Before, fax2ps was using an obscure and practially\n\tuseless algorithm to allocate the image relative to Letter sized paper\n\twhich sometime sled to useless whitespace on the paper, while at the\n\tsame time cutting of the faxes printable area at the opposite border.\n\n\tSecond, scaling now preserves aspect ratio, which makes unusual faxes\n\t(in particular short ones) print properly.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=35\n\n\t* tiff2ps.c/tiff2ps.1: Substantial changes to tiff2ps by\n\tBruce A. Mallett.  See check message for detailed information\n\ton all the changes, including a faster encoder, fixes for level\n\t2 PostScript, and support for the imagemask operator.\n\n2001-03-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiffio.h: Changed \"#if LOGLUV_PUBLIC\" to\n\t\"#ifdef LOGLUV_PUBLIC\" so it will work with VisualAge on AIX.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2001-03-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirinfo.c: moved definition of copyright tag in field list.\n\tApparently they have to be in sorted order by tag id.\n\n2001-03-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_getimage.c: Added support for 16bit minisblack/miniswhite\n\timages in RGBA interface.\n\n2001-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added TIFFTAG_COPYRIGHT support.\n\n2001-02-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Brent Roman contributed updated tiffcp utility (and tiffcp.1)\n\twith support for extracting subimages with the ,n syntax, and also\n\tadding the -b bias removal flag.\n\n2001-02-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Brent Roman submitted new version adding\n\tserveral missing entry points.\n\n\t* libtiff/tif_dirinfo.c: don't declare tiffFieldInfo static on VMS.\n\tSome sort of weird VMS thing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=31\n\n\t* tif_luv.c/tiff.h/tiffio.h:\n\tNew version of TIFF LogLuv (SGILOG) modules contributed by Greg Ward\n\t(greg@shutterfly.com).  He writes:\n\n\t1) I improved the gamut-mapping function in tif_luv.c for imaginary\n\tcolors, because some images were being super-saturated on the input\n\tside and this resulted in some strange color shifts in the output.\n\n\t2) I added a psuedotag in tiff.h to control random dithering during\n\tLogLuv encoding.  This is turned off by default for 32-bit LogLuv and\n\ton for 24-bit LogLuv output.  Dithering improves the average color\n\taccuracy over the image.\n\n\t3) I added a #define for LOG_LUV_PUBLIC, which is enabled by default in\n\ttiffio.h, to expose internal routines for converting between LogLuv and\n\tXYZ coordinates.  This is helpful for writing more efficient,\n\tspecialized conversion routines, especially for reading LogLuv files.\n\n\tChanges applied with minor edits.\n\n2001-01-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_fax3.c: keep rw_mode flag internal to fax3 state to remember\n\twhether we are encoding or decoding.  This is to ensure graceful\n\trecovery if TIFFClientOpen() discovers an attempt to open a compressed\n\tfile for \"r+\" access, and subsequently close it, as it resets the\n\ttif_mode flag to O_RDONLY in this case to avoid writes, confusing the\n\tcompressor's concept of whether it is in encode or decode mode.\n\n2001-01-08  Mike Welles <mike@bangstate.com>\n\n\t* Makefile.in:  Now cleaning up after itself after creating the .tar.gz and .zip\n\n2001-01-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/libtiff.html: Fixed arguments in example for TIFFRGBAImageGet()\n\tas per bug report by Patrick Connor.\n\n2000-12-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added RELEASE-DATE file to release file list.\n\n\t* Fixed libtiff/makefile.vc to make tiffvers.h not version.h.\n\n2000-12-22  Mike Welles <mike@bangstate.com>\n        * added link to CVS mirror from index.html\n\n\t* updated html/internals.html to note that LZW compression is\n\t  not supported by default.\n\n2000-12-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* updated html/libtiff.html to not point at Niles' old JPL web site\n\tfor the man pages, point at www.libtiff.org.\n\n2000-12-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_apple.c: Applied \"Carbon\" support patches supplied by\n\tLeonard Rosenthol <leonardr@lazerware.com>.  May interfere\n\twith correct building on older systems.  If so, please let me know.\n\n2000-12-19 Mike Welles <mike@bangsate.com>\n\n\t* Took out LZW Encoding from tif_lzw.c\n\n\t* Created HOWTO-RELEASE\n\n\t* Created html/v3.5.6.html\n\n\t* updated index.html\n\n2000-12-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added patches for EOFB support in tif_fax3.c and tif_fax3.h.\n\tPatches supplied by Frank Cringle <fdc@cliwe.ping.de>\n\tExample file at: ftp://ftp.remotesensing.org/pub/libtiff/eofb_396.tif\n\n2000-11-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/Makefile.in: Added an installPrivateHdrs and install-private\n\ttarget so that the private headers required by libgeotiff can be\n\tinstalled with the others.  They are not installed by default.\n\n\t* libtiff/Makefile.in: Added @MACHLIBDEPS@ to LINUXdso and GNULDdso\n\ttargets so libtiff.so will be built with an explicit dependency\n\ton libm.so.\n\n\t* libtiff/Makefile.in: Use softlinks to link libtiff.so.3 to\n\tlibtiff.so.3.5.5.\n\n\t* libtiff/Makefile.in & configure: Remove all references to the ALPHA\n\tfile, or ALPHA version logic.  Added stuff about DIST_POINT in\n\tplace of DIST_TYPE and the alpha release number stuff.\n\n2000-11-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* I have applied a patch from Steffen Moeller <moeller@ebi.ac.uk> to\n\tthe configure script so that it now accepts the --prefix, and\n\t--exec-prefix directives.\n\n2000-11-13  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* I have made a variety of modifications in an effort to ensure the\n\tTIFFLIB_VERSION macro is automatically generated from the RELEASE-DATE\n\tfile which seems to be updated regularly.\n\n\t o mkversion.c now reads RELEASE-DATE and emits TIFFLIB_VERSION in\n\t   version include file.\n\t o renamed version.h to tiffvers.h because we now have to install it\n\t   with the public libtiff include files.\n\t o include tiffvers.h in tiffio.h.\n\t o updated tif_version.c to use tiffvers.h.\n\t o Updated Makefile.in accordingly.\n\n\t* As per http://bugzilla.remotesensing.org/show_bug.cgi?id=25\n\tI have updated the win32 detection rules in tiffcomp.h.\n\n2000-10-20  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_getimage.c: Fixed RGBA translation for YCbCr images for which\n\tthe strip/tile width and height aren't multiples of the sampling size.\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=20\n\tSome patches from Rick LaMont of Dot C Software.\n\n\t* Modified tif_packbits.c encoder to avoid compressing more\n\tdata than provided if rowsize doesn't factor into provided data\n\t(such as occurs for YCbCr).\n\n2000-10-19  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tools/rgb2ycbcr.c: fixed output strip size to account for vertical\n\troundup if rows_per_strip not a multiple of vertical sample size.\n\n2000-10-16  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_dir.c: Clear TIFF_ISTILED flag in TIFFDefaultDirectory\n\tas per http://bugzilla.remotesensing.org/show_bug.cgi?id=18\n\tfrom vandrove@vc.cvut.cz.\n\n\t* Modified tif_packbits.c decoding to avoid overrunning the\n\toutput buffer, and to issue a warning if data needs to be\n\tdiscarded.  See http://bugzilla.remotesensing.org/show_bug.cgi?id=18\n\n2000-10-12  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Modified tiff2bw to ensure portions add to 100%, and that\n\twhite is properly recovered.\n\n\tSee bug http://bugzilla.remotesensing.org/show_bug.cgi?id=15\n\tPatch c/o Stanislav Brabec <utx@penguin.cz>\n\n2000-09-30  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Modified TIFFClientOpen() to emit an error on an attempt to\n\topen a comperessed file for update (O_RDWR/r+) access.  This is\n\tbecause the compressor/decompressor code gets very confused when\n\tthe mode is O_RDWR, assuming this means writing only.  See\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=13\n\n2000-09-27  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Added GNULDdso target an`d switched linux and freebsd to use it.\n\n2000-09-26  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Applied patch for 0x0000 sequences in tif_fax3.h's definition\n\tof EXPAND1D() as per bug 11 (from Roman).\n\n2000-09-25  Frank Warmerdam  <warmerda@cs46980-c>\n\t* Fixed tiffcomp.h to avoid win32 stuff if unix #defined, to improve\n\tcygwin compatibility.\n\n\t* Applied patch from Roman Shpount to tif_fax3.c.  This seems to\n\tbe a proper fix to the buffer sizing problem.  See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=11\n\n\t* Fixed tif_getimage.c to fix overrun bug with YCbCr images without\n\tdownsampling.  http://bugzilla.remotesensing.org/show_bug.cgi?id=10\n\tThanks to Nick Lamb <njl98r@ecs.soton.ac.uk> for reporting the\n\tbug and proving the patch.\n\n2000-09-18  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Fixed tif_jpeg.c so avoid destroying the decompressor before\n\twe are done access data thanks to bug report from:\n\tMichael Eckstein <eckstein@gepro.cz>.\n\n\t* Reverted tif_flush change.\n\n2000-09-14  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_flush.c: Changed so that TIFFFlushData() doesn't return an\n\terror when TIFF_BEENWRITING is not set.  This ensures that the\n\tdirectory contents can still be flushed by TIFFFlush().\n\n2000-08-14  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* tif_open.c: Don't set MMAP for O_RDWR files.\n\n\t* tif_open.c: Set STRIPCHOP_DEFAULT for O_RDWR as well as O_RDONLY\n\tso that files opened for update can be strip chopped too.\n\n\t* tif_read.c: fixed up bug with files missing rowsperstrip and\n\tthe strips per separation fix done a few weeks ago.\n\n2000-07-17  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Tentatively added support for SAMPLEFORMAT_COMPLEXIEEEFP, and\n\tSAMPLEFORMAT_COMPLEXINT.\n\n2000-07-13  Mike Welles <mike@onshore.com>\n\n\t* index.html, bugs.html: added bugzilla info.\n\n2000-07-12  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* tif_read.c: fix subtle bug with determining the number of\n\trows for strips that are the last strip in a separation but\n\tnot the last strip of all in TIFFReadEncodedStrip().\n\n\t* Applied 16/32 bit fix to tif_fax3.c.  Fix supplied by\n\tPeter Skarpetis <peters@serendipity-software.com.au>\n\n2000-06-15  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* Modified tiffio.h logic with regard to including windows.h.  It\n\twon't include it when building with __CYGWIN__.\n\n2000-05-11  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* README: update to mention www.libtiff.org, don't list Sam's old\n\temail address.\n\n\t* configure: Fixed DSO test for Linux as per patch from\n\t  Jan Van Buggenhout <chipzz@Ace.ULYSSIS.Student.KULeuven.Ac.Be>.\n\n2000-04-21  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* libtiff/tif_dirread.c: Don't use estimate strip byte count for\n\tone tile/strip images with an offset, and byte count of zero. These\n\tcould be \"unpopulated\" images.\n\n2000-04-18  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* contrib/addtiffo: Added \"averaging\" resampling option.\n\n\t* tools/tiffsplit.c: Copy TIFFTAG_SAMPLEFORMAT.\n\nTue Apr 18 16:18:08 2000  Frank Warmerdam  <warmerda@esabot.atlsci.com>\n\n\t* tools/Makefile.in: Modified to install properly on SGI.\n\n2000-04-12  Mike Welles\t     <mike@onshore.com>\n\t* configure:  Fixed stupid mistake in libc6 test on Linux\n\n2000-04-04  Mike Welles\t     <mike@onshore.com>\n\t* tif_win32.c:  Applied patch to fix overreads and ovverwrites\n\t  caught by BoundsChecker.  From Arvan Pritchard\n\t  <arvan.pritchard@infomatix.co.uk>  (untested).\n\n\t* tif_getimage.c:  Applied patch to silence VC6 warnings.  From\n\t  Arvan Pritchard <arvan.pritchard@informatix.co.uk>\n\n\t* tif_lzw.c:  Applied patch to silence VC6 warnings.  From\n\t  Arvan Pritchard <arvan.pritchard@informatix.co.uk>\n\n2000-03-28  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Added contrib/stream (stream io) code submitted by Avi Bleiweiss.\n\n2000-03-28  Frank Warmerdam  <warmerda@cs46980-c>    *** 3.5.5 release ***\n\n\t* fax2ps: Fixed mixup of width and height in bounding box statement\n\tas per submission by Nalin Dahyabhai <nalin@redhat.com>.\n\n2000-03-27  Mike Welles\t     <mike@onshore.com>\n\n\t* fax2ps:  Modified printruns to take uint32 instead of uint16.\n\tPatch courtesy of Bernt Herd <herd@herdsoft.com>\n\n2000-03-20  Mike Welles\t     <mike@onshore.com>\n\n\t* configure: added test for libc6 for linux targets.  Bug reported by\n        Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* Added 3.5 docs to html/Makefile.in.\n\tThanks to  Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* configure: fixed bugs in sed scripts\n\t(applied sed script s:/@:s;@:;s:/s;;:;: to configure).\n\tfix submitted to Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* tools/iptcutil was not in files list, and wasn't being\n\tadded to tar archive.  Updated Makefile.in.\n\n2000-03-17  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_fax3.c: Fixed serious bug introduced during the uint16->uint32\n\tconversion for the run arrays.\n\n2000-03-03  Frank Warmerdam  <warmerda@cs46980-c.mtnk1.on.wave.home.com>\n\n\t* Set td_sampleformat default to SAMPLEFORMAT_UINT instead of\n\tSAMPLEFORMAT_VOID in TIFFDefaultDirectory() in tif_dir.c.\n\n2000-03-02  Frank Warmerdam  <warmerda@cs46980-c.mtnk1.on.wave.home.com>\n\n\t* Added \"GetDefaulted\" support for TIFFTAG_SAMPLEFORMAT in tif_aux.c.\n\n\t* Patched tif_fax3.c so that dsp->runs is allocated a bit bigger\n\tto avoid overruns encountered with frle_bug.tif.\n\nTue Feb 15 22:01:05 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Fixed tools/tiffcmp so that stopondiff testing works.\n\t  Patch care of Joseph Orost <joe@sanskrit.lz.att.com>.\n\n2000-01-28    <warmerda@CS46980-B>\n\n\t* Modified tif_unix.c to support 2-4GB seeks if USE_64BIT_API is\n\t  set to 1, and added default (off) setting in tiffconf.h.  This\n\t  should eventually be set by the configure script somehow.\n\n\t  The original work on all these 2-4GB changes was done by\n\t  Peter Smith (psmith@creo.com).\n\n\t* Modified tif_win32.c to support 2-4GB seeks.\n\n\t* tentatively changed toff_t to be unsigned instead of signed to\n\t  facilitate support for 2-4GB files.\n\n\t* Updated a variety of files to use toff_t.  Fixed some mixups\n\t  between toff_t and tsize_t.\n\nFri Jan 28 10:13:49 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Largely reimplemented contrib/addtiffo to avoid temp files,\n\tupdating the TIFF file in place.  Fixed a few other bugs to.\n\n\t* Set tif_rawdatasize to zero when freeing raw data buffer in\n\tTIFFWriteDirectory().\n\n\t* Enabled \"REWRITE_HACK\" in tif_write.c by default.\n\n\t* Fix bug in tif_write.c when switching between reading one directory\n\tand writing to another.\n\n\t* Made TIFFWriteCheck() public, and added TIFFCreateDirectory()\n\nWed Jan  5 12:37:48 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added TIFFmemory(3t) functions to libtiff.def.\n\nTue Jan  4 13:39:00 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added libtiff/libtiff.def to TIFFILES distribution list.\n\nMon Dec 27 12:13:39 EST 1999  Mike Welles <mike@onshore.com>\n\n\t* Created lzw compression kit, as a new module (libtiff-lzw-compression-kit).\n\n\t* Altered descriptions in tools to reflect \"by default\" lzw not supported\n\n\t* Updated index.html to note lzw compression kit.\n\nTue Dec 21 14:01:51 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added fax3sm_winnt.c to distribution list in Makefile.in.\n\nTue Dec 21 11:04:45 EST 1999  Mike Welles <mike@onshore.com> *** 3.5.4 release ***\n\n\t* Aadded Pixar tag support.  Contributed by Phil Beffery <phil@pixar.com>\n\n\t* Made one more change to tif_dir.c for removal of LZW compression. Also added notice\n\t  when LZW compression invoked.\n\n\t* Changed default compression in tools to TIFF_PACKBITS, and changed usage descriptions\n\t  in tools to reflect removal of LZW compression\n\nMon Dec 20 18:39:02 EST 1999  Mike Welles  <mike@onshore.com>\n\n        * Fixed bug that caused LZW (non) compression to segfault. Added\n\t  warning about LZW compression removed being removed, and why.\n\n\t* Added nostrip to install in tools/Makefile.in so that debugging\n\t  symbols are kept.\n\nTue Dec  7 12:04:47 EST 1999  Mike Welles  <mike@onshore.com>\n\n\t* Added patch from Ivo Penzar <ivo.penzar@infolink-software.com>,\n\t  supporting Adobe ZIP deflate.  Untested.\n\nSat Dec  4 15:47:11 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Made Packbits the default compression in tools/tiff2rgba.c instead\n\tof LZW.\n\nTue Nov 30 14:41:43 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>    *** 3.5.3. release ***\n\n\t* Added tif_luv to contrib/djgpp/Makefile.lib.\n\nTue Nov 30 14:15:32 EST 1999   Mike Welles <mike@onshore.com>\n\n        * Added zip creation to relase makefile target\n\n\t* Added html for TIFFWriteTile.3t man page.\n\nTue Nov 30 09:20:16 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added some changes to tif_write.c to support rewriting existing\n\tfixed sized tiles and strips.  Code mods disabled by default, only\n\tenabled if REWRITE_HACK is defined for now.\n\nMon Nov 29 11:43:42 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added TIFFWriteTile.3t man page.\n\nSun Nov 28 20:36:18 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added notes on use of makefile.vc in build.html, and fixed\n\temail subscription address.\n\n199-11-28  Mike Welles <mike@onshore.com>\n\n\t*  Fixed apocalypse-inducing y2k bug in contrib/ras/ras2tiff.c\n\n\t*  Did some casts cleaning up to reduce compiler warnings in tif_fax3.c,\n\t   from Bruce Carmeron <cameron@petris.com> -- modifications of\n\t   changes made by Frank (sun cc still complained on cast).\n\n\t*  Added tiffconf.h to install target per request from Bill\n\t   Radcliffe <billr@corbis.com>: \"We need a way for ImageMagick to\n \t   know features have been compiled into the TIFF library in order to\n\t   handle things properly\".\n\nSat Nov 27 16:49:21 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* fixed various VC++ warnings as suggested by Gilles Vollant\n\t<info@winimage.com>.\n\nWed Nov 24 12:08:16 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Modified TIFFquery.3t man pages info on TIFFIsByteSwapped() to\n\tnot imply applications are responsible for image data swapping.\n\n1999-11-22  Mike Welles <mike@onshore.com>\n\t*  HTML-ized the man pages, added to html/man\n\n\t*  Removed LZW Compression to comply with Unisys patent extortion.\n\n1999-09-29  Mike Welles\t\t<mike@onshore.com>\n\t*  Corrected one remaining 16 -> 32 bit value in tif_fax3.c,\n\t   From Ivo Penzar <ivo.penzar@infolink-software.com.\n\n\t*  Added patch from Ivo Penzar to have TiffAdvanceDirectory handle\n\t   memory mapped files. <ivo.penzar@infolink-software.com>\n\n1999-09-26  Mike Welles \t<mike@onshore.com>  *** 3.5.2 release ***\n\t* Corrected alpha versioning.\n\n\t* Removed distinction between  alpha and release targets in Makefile.in.\n\n\t* added release.stamp target, which tags cvs tree, and updates\n\t  \"RELEASE-DATE\"\n\n\t* added releasediff target, which diffs tree with source as of\n\t  date in \"RELEASE-DATE\"\n\n\t* Ticked up version to 3.5.2 (alpha 01 -- but I think we'll moving\n\t  away from alpha/non-alpha distinctions).\n\n\t* updated html to reflect release\n\n1999-09-23    <warmerda@CS46980-B>\n\n\t* Set O_BINARY for tif_unix.c open() ... used on cygwin for instance.\n\n\t* Added CYGWIN case in configure.\n\nFri Sep 17 00:13:51 CEST 1999  Mike Welles <mike@onshore.com>\n\n\t* Applied Francois Dagand's patch to handle fax decompression bug.\n\t  (sizes >= 65536 were failing)\n\nTue Sep 14 21:31:43 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Applied \"a\" mode fix to tif_win32.c/TIFFOpen() as suggested\n\t  by Christopher Lawton <clawton@mathworks.com>\n\nWed Sep  8 08:19:18 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added IRIX/gcc, and OSF/1 4.x support on behalf of\n\t  Albert Chin-A-Young <china@thewrittenword.com>\n\n\t* Added TIFFReassignTagToIgnore() API on behalf of\n\t  Bruce Cameron <cameron@petris.com>.  Man page still pending.\n\nWed Aug 25 11:39:07 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added test target in Makefile, test_pics.sh script and pics/*.rpt\n\tfiles to provide for a rudimentary testsuite.\n\n\t* Added contrib/tags back from old distribution ... fixed up a bit.\n\n1999-08-16    <warmerda@CS46980-B>\n\n\t* Added simple makefile.vc makefiles for building with MS VC++\n\ton Windows NT/98/95 in console mode.  Stuff in contrib/win* make give\n\tbetter solutions for some users.\n\nMon Aug 16 21:52:11 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added addtiffo (add overviews to a TIFF file) in contrib.  Didn't\n\tput it in tools since part of it is in C++.\n\n1999-08-16  Michael L. Welles  <mike@kurtz.fake>\n\n\t* Updated html/index.html with anon CVS instructions.\n\nMon Aug 16 13:18:41 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* pre-remove so link before softlink in LINUXdso action in\n\tlibtiff/Makefile.in to avoid failure on LINUXdso builds other than\n\tthe first.\n\n\t* Fixed problem with cvtcmap() in tif_getimage.c modifying the\n\tcolormaps owned by the TIFF handle itself when trying to fixup wrong\n\t(eight bit) colormaps.  Corrected by maintaining a private copy of\n\tthe colormap.\n\n\t* Added TIFFReadRGBATile()/TIFFReadRGBAStrip() support in\n\ttif_getimage.c.\n\n\t* CVS Repository placed at remotesensing.org.  ChangeLog added.\n", "/* $Id$ */\n\n/* tiffcrop.c -- a port of tiffcp.c extended to include manipulations of\n * the image data through additional options listed below\n *\n * Original code:\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n * Additions (c) Richard Nolde 2006-2010 \n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS OR ANY OTHER COPYRIGHT  \n * HOLDERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL \n * DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, \n * DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND \n * ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE\n * OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Some portions of the current code are derived from tiffcp, primarly in \n * the areas of lowlevel reading and writing of TAGS, scanlines and tiles though\n * some of the original functions have been extended to support arbitrary bit\n * depths. These functions are presented at the top of this file.\n *\n * Add support for the options below to extract sections of image(s) \n * and to modify the whole image or selected portions of each image by\n * rotations, mirroring, and colorscale/colormap inversion of selected\n * types of TIFF images when appropriate. Some color model dependent \n * functions are restricted to bilevel or 8 bit per sample data.\n * See the man page for the full explanations.\n *\n * New Options: \n * -h             Display the syntax guide.\n * -v             Report the version and last build date for tiffcrop and libtiff.\n * -z x1,y1,x2,y2:x3,y3,x4,y4:..xN,yN,xN + 1, yN + 1 \n *                Specify a series of coordinates to define rectangular\n *                regions by the top left and lower right corners.\n * -e c|d|i|m|s   export mode for images and selections from input images\n *   combined     All images and selections are written to a single file (default)\n *                with multiple selections from one image combined into a single image\n *   divided      All images and selections are written to a single file\n *                with each selection from one image written to a new image\n *   image        Each input image is written to a new file (numeric filename sequence)\n *                with multiple selections from the image combined into one image\n *   multiple     Each input image is written to a new file (numeric filename sequence)\n *                with each selection from the image written to a new image\n *   separated    Individual selections from each image are written to separate files\n * -U units       [in, cm, px ] inches, centimeters or pixels\n * -H #           Set horizontal resolution of output images to #\n * -V #           Set vertical resolution of output images to #\n * -J #           Horizontal margin of output page to # expressed in current\n *                units when sectioning image into columns x rows \n *                using the -S cols:rows option.\n * -K #           Vertical margin of output page to # expressed in current\n *                units when sectioning image into columns x rows\n *                using the -S cols:rows option.\n * -X #           Horizontal dimension of region to extract expressed in current\n *                units\n * -Y #           Vertical dimension of region to extract expressed in current\n *                units\n * -O orient      Orientation for output image, portrait, landscape, auto\n * -P page        Page size for output image segments, eg letter, legal, tabloid,\n *                etc.\n * -S cols:rows   Divide the image into equal sized segments using cols across\n *                and rows down\n * -E t|l|r|b     Edge to use as origin\n * -m #,#,#,#     Margins from edges for selection: top, left, bottom, right\n *                (commas separated)\n * -Z #:#,#:#     Zones of the image designated as zone X of Y, \n *                eg 1:3 would be first of three equal portions measured\n *                from reference edge\n * -N odd|even|#,#-#,#|last \n *                Select sequences and/or ranges of images within file\n *                to process. The words odd or even may be used to specify\n *                all odd or even numbered images the word last may be used\n *                in place of a number in the sequence to indicate the final\n *                image in the file without knowing how many images there are.\n * -R #           Rotate image or crop selection by 90,180,or 270 degrees\n *                clockwise  \n * -F h|v         Flip (mirror) image or crop selection horizontally\n *                or vertically \n * -I [black|white|data|both]\n *                Invert color space, eg dark to light for bilevel and grayscale images\n *                If argument is white or black, set the PHOTOMETRIC_INTERPRETATION \n *                tag to MinIsBlack or MinIsWhite without altering the image data\n *                If the argument is data or both, the image data are modified:\n *                both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,\n *                data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag\n * -D input:<filename1>,output:<filename2>,format:<raw|txt>,level:N,debug:N\n *                Dump raw data for input and/or output images to individual files\n *                in raw (binary) format or text (ASCII) representing binary data\n *                as strings of 1s and 0s. The filename arguments are used as stems\n *                from which individual files are created for each image. Text format\n *                includes annotations for image parameters and scanline info. Level\n *                selects which functions dump data, with higher numbers selecting\n *                lower level, scanline level routines. Debug reports a limited set\n *                of messages to monitor progess without enabling dump logs.\n */\n\nstatic   char tiffcrop_version_id[] = \"2.4\";\nstatic   char tiffcrop_rev_date[] = \"12-13-2010\";\n\n#include \"tif_config.h\"\n#include \"tiffiop.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n\n#ifndef HAVE_GETOPT\nextern int getopt(int argc, char * const argv[], const char *optstring);\n#endif\n\n#ifdef NEED_LIBPORT\n# include \"libport.h\"\n#endif\n\n#include \"tiffio.h\"\n\n#if defined(VMS)\n# define unlink delete\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#define TIFF_UINT32_MAX     0xFFFFFFFFU\n\n#ifndef streq\n#define\tstreq(a,b)\t(strcmp((a),(b)) == 0)\n#endif\n#define\tstrneq(a,b,n)\t(strncmp((a),(b),(n)) == 0)\n\n#define\tTRUE\t1\n#define\tFALSE\t0\n\n#ifndef TIFFhowmany\n#define TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))\n#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)\n#endif\n\n/*\n * Definitions and data structures required to support cropping and image\n * manipulations.\n */\n\n#define EDGE_TOP      1\n#define EDGE_LEFT     2\n#define EDGE_BOTTOM   3\n#define EDGE_RIGHT    4\n#define EDGE_CENTER   5\n\n#define MIRROR_HORIZ  1\n#define MIRROR_VERT   2\n#define MIRROR_BOTH   3\n#define ROTATECW_90   8\n#define ROTATECW_180 16\n#define ROTATECW_270 32\n#define ROTATE_ANY (ROTATECW_90 | ROTATECW_180 | ROTATECW_270)\n\n#define CROP_NONE     0\n#define CROP_MARGINS  1\n#define CROP_WIDTH    2\n#define CROP_LENGTH   4\n#define CROP_ZONES    8\n#define CROP_REGIONS 16\n#define CROP_ROTATE  32\n#define CROP_MIRROR  64\n#define CROP_INVERT 128\n\n/* Modes for writing out images and selections */\n#define ONE_FILE_COMPOSITE       0 /* One file, sections combined sections */\n#define ONE_FILE_SEPARATED       1 /* One file, sections to new IFDs */\n#define FILE_PER_IMAGE_COMPOSITE 2 /* One file per image, combined sections */\n#define FILE_PER_IMAGE_SEPARATED 3 /* One file per input image */\n#define FILE_PER_SELECTION       4 /* One file per selection */\n\n#define COMPOSITE_IMAGES         0 /* Selections combined into one image */  \n#define SEPARATED_IMAGES         1 /* Selections saved to separate images */\n\n#define STRIP    1\n#define TILE     2\n\n#define MAX_REGIONS   8  /* number of regions to extract from a single page */\n#define MAX_OUTBUFFS  8  /* must match larger of zones or regions */\n#define MAX_SECTIONS 32  /* number of sections per page to write to output */\n#define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */\n#define MAX_SAMPLES   8  /* maximum number of samples per pixel supported */\n#define MAX_BITS_PER_SAMPLE 64 /* maximum bit depth supported */\n#define MAX_EXPORT_PAGES 999999  /* maximum number of export pages per file */\n\n#define DUMP_NONE   0\n#define DUMP_TEXT   1\n#define DUMP_RAW    2\n\n/* Offsets into buffer for margins and fixed width and length segments */\nstruct offset {\n  uint32  tmargin;\n  uint32  lmargin;\n  uint32  bmargin;\n  uint32  rmargin;\n  uint32  crop_width;\n  uint32  crop_length;\n  uint32  startx;\n  uint32  endx;\n  uint32  starty;\n  uint32  endy;\n};\n\n/* Description of a zone within the image. Position 1 of 3 zones would be \n * the first third of the image. These are computed after margins and \n * width/length requests are applied so that you can extract multiple \n * zones from within a larger region for OCR or barcode recognition.\n */\n\nstruct  buffinfo {\n  uint32 size;           /* size of this buffer */\n  unsigned char *buffer; /* address of the allocated buffer */\n};\n\nstruct  zone {\n  int   position;  /* ordinal of segment to be extracted */\n  int   total;     /* total equal sized divisions of crop area */\n  };\n\nstruct  pageseg {\n  uint32 x1;        /* index of left edge */\n  uint32 x2;        /* index of right edge */\n  uint32 y1;        /* index of top edge */\n  uint32 y2;        /* index of bottom edge */\n  int    position;  /* ordinal of segment to be extracted */\n  int    total;     /* total equal sized divisions of crop area */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped zone */\n};\n\nstruct  coordpairs {\n  double X1;        /* index of left edge in current units */\n  double X2;        /* index of right edge in current units */\n  double Y1;        /* index of top edge in current units */\n  double Y2;        /* index of bottom edge in current units */\n};\n\nstruct  region {\n  uint32 x1;        /* pixel offset of left edge */\n  uint32 x2;        /* pixel offset of right edge */\n  uint32 y1;        /* pixel offset of top edge */\n  uint32 y2;        /* picel offset of bottom edge */\n  uint32 width;     /* width in pixels */\n  uint32 length;    /* length in pixels */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped region */\n  unsigned char *buffptr; /* address of start of the region */\n};\n\n/* Cropping parameters from command line and image data \n * Note: This should be renamed to proc_opts and expanded to include all current globals\n * if possible, but each function that accesses global variables will have to be redone.\n */\nstruct crop_mask {\n  double width;           /* Selection width for master crop region in requested units */\n  double length;          /* Selection length for master crop region in requesed units */\n  double margins[4];      /* Top, left, bottom, right margins */\n  float  xres;            /* Horizontal resolution read from image*/\n  float  yres;            /* Vertical resolution read from image */\n  uint32 combined_width;  /* Width of combined cropped zones */\n  uint32 combined_length; /* Length of combined cropped zones */\n  uint32 bufftotal;       /* Size of buffer needed to hold all the cropped region */\n  uint16 img_mode;        /* Composite or separate images created from zones or regions */\n  uint16 exp_mode;        /* Export input images or selections to one or more files */\n  uint16 crop_mode;       /* Crop options to be applied */\n  uint16 res_unit;        /* Resolution unit for margins and selections */\n  uint16 edge_ref;        /* Reference edge for sections extraction and combination */\n  uint16 rotation;        /* Clockwise rotation of the extracted region or image */\n  uint16 mirror;          /* Mirror extracted region or image horizontally or vertically */\n  uint16 invert;          /* Invert the color map of image or region */\n  uint16 photometric;     /* Status of photometric interpretation for inverted image */\n  uint16 selections;      /* Number of regions or zones selected */\n  uint16 regions;         /* Number of regions delimited by corner coordinates */\n  struct region regionlist[MAX_REGIONS]; /* Regions within page or master crop region */\n  uint16 zones;           /* Number of zones delimited by Ordinal:Total requested */\n  struct zone zonelist[MAX_REGIONS]; /* Zones indices to define a region */\n  struct coordpairs corners[MAX_REGIONS]; /* Coordinates of upper left and lower right corner */\n};\n\n#define MAX_PAPERNAMES 49\n#define MAX_PAPERNAME_LENGTH 15\n#define DEFAULT_RESUNIT      RESUNIT_INCH\n#define DEFAULT_PAGE_HEIGHT   14.0\n#define DEFAULT_PAGE_WIDTH     8.5\n#define DEFAULT_RESOLUTION   300\n#define DEFAULT_PAPER_SIZE  \"legal\"\n\n#define ORIENTATION_NONE       0\n#define ORIENTATION_PORTRAIT   1\n#define ORIENTATION_LANDSCAPE  2\n#define ORIENTATION_SEASCAPE   4\n#define ORIENTATION_AUTO      16\n\n#define PAGE_MODE_NONE         0\n#define PAGE_MODE_RESOLUTION   1\n#define PAGE_MODE_PAPERSIZE    2\n#define PAGE_MODE_MARGINS      4\n#define PAGE_MODE_ROWSCOLS     8\n\n#define INVERT_DATA_ONLY      10\n#define INVERT_DATA_AND_TAG   11\n\nstruct paperdef {\n  char   name[MAX_PAPERNAME_LENGTH];\n  double width;\n  double length;\n  double asratio;\n  };\n\n/* European page sizes corrected from update sent by \n * thomas . jarosch @ intra2net . com on 5/7/2010\n * Paper Size       Width   Length  Aspect Ratio */\nstruct paperdef PaperTable[MAX_PAPERNAMES] = {\n  {\"default\",         8.500,  14.000,  0.607},\n  {\"pa4\",             8.264,  11.000,  0.751},\n  {\"letter\",          8.500,  11.000,  0.773},\n  {\"legal\",           8.500,  14.000,  0.607},\n  {\"half-letter\",     8.500,   5.514,  1.542},\n  {\"executive\",       7.264,  10.528,  0.690},\n  {\"tabloid\",        11.000,  17.000,  0.647},\n  {\"11x17\",          11.000,  17.000,  0.647},\n  {\"ledger\",         17.000,  11.000,  1.545},\n  {\"archa\",           9.000,  12.000,  0.750},\n  {\"archb\",          12.000,  18.000,  0.667},\n  {\"archc\",          18.000,  24.000,  0.750},\n  {\"archd\",          24.000,  36.000,  0.667},\n  {\"arche\",          36.000,  48.000,  0.750},\n  {\"csheet\",         17.000,  22.000,  0.773},\n  {\"dsheet\",         22.000,  34.000,  0.647},\n  {\"esheet\",         34.000,  44.000,  0.773},\n  {\"superb\",         11.708,  17.042,  0.687},\n  {\"commercial\",      4.139,   9.528,  0.434},\n  {\"monarch\",         3.889,   7.528,  0.517},\n  {\"envelope-dl\",     4.333,   8.681,  0.499},\n  {\"envelope-c5\",     6.389,   9.028,  0.708},\n  {\"europostcard\",    4.139,   5.833,  0.710},\n  {\"a0\",             33.110,  46.811,  0.707},\n  {\"a1\",             23.386,  33.110,  0.706},\n  {\"a2\",             16.535,  23.386,  0.707},\n  {\"a3\",             11.693,  16.535,  0.707},\n  {\"a4\",              8.268,  11.693,  0.707},\n  {\"a5\",              5.827,   8.268,  0.705},\n  {\"a6\",              4.134,   5.827,  0.709},\n  {\"a7\",              2.913,   4.134,  0.705},\n  {\"a8\",              2.047,   2.913,  0.703},\n  {\"a9\",              1.457,   2.047,  0.712},\n  {\"a10\",             1.024,   1.457,  0.703},\n  {\"b0\",             39.370,  55.669,  0.707},\n  {\"b1\",             27.835,  39.370,  0.707},\n  {\"b2\",             19.685,  27.835,  0.707},\n  {\"b3\",             13.898,  19.685,  0.706},\n  {\"b4\",              9.843,  13.898,  0.708},\n  {\"b5\",              6.929,   9.843,  0.704},\n  {\"b6\",              4.921,   6.929,  0.710},\n  {\"c0\",             36.102,  51.063,  0.707},\n  {\"c1\",             25.512,  36.102,  0.707},\n  {\"c2\",             18.031,  25.512,  0.707},\n  {\"c3\",             12.756,  18.031,  0.707},\n  {\"c4\",              9.016,  12.756,  0.707},\n  {\"c5\",              6.378,   9.016,  0.707},\n  {\"c6\",              4.488,   6.378,  0.704},\n  {\"\",                0.000,   0.000,  1.000}\n};\n\n/* Structure to define input image parameters */\nstruct image_data {\n  float  xres;\n  float  yres;\n  uint32 width;\n  uint32 length;\n  uint16 res_unit;\n  uint16 bps;\n  uint16 spp;\n  uint16 planar;\n  uint16 photometric;\n  uint16 orientation;\n  uint16 compression;\n  uint16 adjustments;\n};\n\n/* Structure to define the output image modifiers */\nstruct pagedef {\n  char          name[16];\n  double        width;    /* width in pixels */\n  double        length;   /* length in pixels */\n  double        hmargin;  /* margins to subtract from width of sections */\n  double        vmargin;  /* margins to subtract from height of sections */\n  double        hres;     /* horizontal resolution for output */\n  double        vres;     /* vertical resolution for output */\n  uint32        mode;     /* bitmask of modifiers to page format */\n  uint16        res_unit; /* resolution unit for output image */\n  unsigned int  rows;     /* number of section rows */\n  unsigned int  cols;     /* number of section cols */\n  unsigned int  orient;   /* portrait, landscape, seascape, auto */\n};\n\nstruct dump_opts {\n  int  debug;\n  int  format;\n  int  level;\n  char mode[4];\n  char infilename[PATH_MAX + 1];\n  char outfilename[PATH_MAX + 1];\n  FILE *infile;\n  FILE *outfile;\n  };\n\n/* globals */\nstatic int    outtiled = -1;\nstatic uint32 tilewidth = 0;\nstatic uint32 tilelength = 0;\n\nstatic uint16 config = 0;\nstatic uint16 compression = 0;\nstatic uint16 predictor = 0;\nstatic uint16 fillorder = 0;\nstatic uint32 rowsperstrip = 0;\nstatic uint32 g3opts = 0;\nstatic int    ignore = FALSE;\t\t/* if true, ignore read errors */\nstatic uint32 defg3opts = (uint32) -1;\nstatic int    quality = 100;\t\t/* JPEG quality */\n/* static int    jpegcolormode = -1;        was JPEGCOLORMODE_RGB;  */\nstatic int    jpegcolormode = JPEGCOLORMODE_RGB;\nstatic uint16 defcompression = (uint16) -1;\nstatic uint16 defpredictor = (uint16) -1;\nstatic int    pageNum = 0;\nstatic int    little_endian = 1;\n\n/* Functions adapted from tiffcp with additions or significant modifications */\nstatic int  readContigStripsIntoBuffer   (TIFF*, uint8*);\nstatic int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\nstatic int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\nstatic int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);\nstatic int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t, \n                                         uint16, uint16, struct dump_opts *);\nstatic int processCompressOptions(char*);\nstatic void usage(void);\n\n/* All other functions by Richard Nolde,  not found in tiffcp */\nstatic void initImageData (struct image_data *);\nstatic void initCropMasks (struct crop_mask *);\nstatic void initPageSetup (struct pagedef *, struct pageseg *, struct buffinfo []);\nstatic void initDumpOptions(struct dump_opts *);\n\n/* Command line and file naming functions */\nvoid  process_command_opts (int, char *[], char *, char *, uint32 *,\n\t                    uint16 *, uint16 *, uint32 *, uint32 *, uint32 *,\n\t\t            struct crop_mask *, struct pagedef *, \n                            struct dump_opts *, \n                            unsigned int *, unsigned int *);\nstatic  int update_output_file (TIFF **, char *, int, char *, unsigned int *);\n\n\n/*  * High level functions for whole image manipulation */\nstatic int  get_page_geometry (char *, struct pagedef*);\nstatic int  computeInputPixelOffsets(struct crop_mask *, struct image_data *, \n                                     struct offset *);\nstatic int  computeOutputPixelOffsets (struct crop_mask *, struct image_data *,\n\t\t\t\t       struct pagedef *, struct pageseg *,\n                                       struct dump_opts *);\nstatic int  loadImage(TIFF *, struct image_data *, struct dump_opts *, unsigned char **);\nstatic int  correct_orientation(struct image_data *, unsigned char **);\nstatic int  getCropOffsets(struct image_data *, struct crop_mask *, struct dump_opts *);\nstatic int  processCropSelections(struct image_data *, struct crop_mask *, \n                                  unsigned char **, struct buffinfo []);\nstatic int  writeSelections(TIFF *, TIFF **, struct crop_mask *, struct image_data *,\n                            struct dump_opts *, struct buffinfo [],\n                            char *, char *, unsigned int*, unsigned int);\n\n/* Section functions */\nstatic int  createImageSection(uint32, unsigned char **);\nstatic int  extractImageSection(struct image_data *, struct pageseg *, \n                                unsigned char *, unsigned char *);\nstatic int  writeSingleSection(TIFF *, TIFF *, struct image_data *,\n                               struct dump_opts *, uint32, uint32,\n\t\t\t       double, double, unsigned char *);\nstatic int  writeImageSections(TIFF *, TIFF *, struct image_data *,\n                               struct pagedef *, struct pageseg *, \n                               struct dump_opts *, unsigned char *, \n                               unsigned char **);\n/* Whole image functions */\nstatic int  createCroppedImage(struct image_data *, struct crop_mask *, \n                               unsigned char **, unsigned char **);\nstatic int  writeCroppedImage(TIFF *, TIFF *, struct image_data *image,\n                              struct dump_opts * dump,\n                              uint32, uint32, unsigned char *, int, int);\n\n/* Image manipulation functions */\nstatic int rotateContigSamples8bits(uint16, uint16, uint16, uint32, \n                                    uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples16bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples24bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples32bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateImage(uint16, struct image_data *, uint32 *, uint32 *,\n \t\t       unsigned char **);\nstatic int mirrorImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\nstatic int invertImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\n\n/* Functions to reverse the sequence of samples in a scanline */\nstatic int reverseSamples8bits  (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples16bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples24bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples32bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamplesBytes  (uint16, uint16, uint32, uint8 *, uint8 *);\n\n/* Functions for manipulating individual samples in an image */\nstatic int extractSeparateRegion(struct image_data *, struct crop_mask *,\n\t\t \t\t unsigned char *, unsigned char *, int);\nstatic int extractCompositeRegions(struct image_data *,  struct crop_mask *,\n\t\t\t\t   unsigned char *, unsigned char *);\nstatic int extractContigSamples8bits (uint8 *, uint8 *, uint32,\n \t                             tsample_t, uint16, uint16, \n                                     tsample_t, uint32, uint32);\nstatic int extractContigSamples16bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples24bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples32bits (uint8 *, uint8 *, uint32,\n\t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamplesBytes (uint8 *, uint8 *, uint32, \n                                      tsample_t, uint16, uint16, \n\t\t\t\t      tsample_t, uint32, uint32);\nstatic int extractContigSamplesShifted8bits (uint8 *, uint8 *, uint32,\n \t                                     tsample_t, uint16, uint16,\n                                             tsample_t, uint32, uint32,\n                                             int);\nstatic int extractContigSamplesShifted16bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted24bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted32bits (uint8 *, uint8 *, uint32,\n\t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,\n  \t                                    uint32, uint32, tsample_t, uint16,\n\t\t\t\t\t    uint16, uint16, struct dump_opts *);\n\n/* Functions to combine separate planes into interleaved planes */\nstatic int combineSeparateSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                        uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t\t\tuint32, uint32, tsample_t, uint16,\n                                        FILE *, int, int);\n\nstatic int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                            uint32, uint32, uint16, uint16, \n                                            FILE *, int, int);\nstatic int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t  \t\t    uint32, uint32, uint32, uint32, \n                                            tsample_t, uint16, FILE *, int, int);\n\n/* Dump functions for debugging */\nstatic void dump_info  (FILE *, int, char *, char *, ...);\nstatic int  dump_data  (FILE *, int, char *, unsigned char *, uint32);\nstatic int  dump_byte  (FILE *, int, char *, unsigned char);\nstatic int  dump_short (FILE *, int, char *, uint16);\nstatic int  dump_long  (FILE *, int, char *, uint32);\nstatic int  dump_wide  (FILE *, int, char *, uint64);\nstatic int  dump_buffer (FILE *, int, uint32, uint32, uint32, unsigned char *);\n\n/* End function declarations */\n/* Functions derived in whole or in part from tiffcp */\n/* The following functions are taken largely intact from tiffcp */\n\nstatic   char* usage_info[] = {\n\"usage: tiffcrop [options] source1 ... sourceN  destination\",\n\"where options are:\",\n\" -h\t\tPrint this syntax listing\",\n\" -v\t\tPrint tiffcrop version identifier and last revision date\",\n\" \",\n\" -a\t\tAppend to output instead of overwriting\",\n\" -d offset\tSet initial directory offset, counting first image as one, not zero\",\n\" -p contig\tPack samples contiguously (e.g. RGBRGB...)\",\n\" -p separate\tStore samples separately (e.g. RRR...GGG...BBB...)\",\n\" -s\t\tWrite output in strips\",\n\" -t\t\tWrite output in tiles\",\n\" -i\t\tIgnore read errors\",\n\" \",\n\" -r #\t\tMake each strip have no more than # rows\",\n\" -w #\t\tSet output tile width (pixels)\",\n\" -l #\t\tSet output tile length (pixels)\",\n\" \",\n\" -f lsb2msb\tForce lsb-to-msb FillOrder for output\",\n\" -f msb2lsb\tForce msb-to-lsb FillOrder for output\",\n\"\",\n\" -c lzw[:opts]\t Compress output with Lempel-Ziv & Welch encoding\",\n\" -c zip[:opts]\t Compress output with deflate encoding\",\n\" -c jpeg[:opts] Compress output with JPEG encoding\",\n\" -c packbits\t Compress output with packbits encoding\",\n\" -c g3[:opts]\t Compress output with CCITT Group 3 encoding\",\n\" -c g4\t\t Compress output with CCITT Group 4 encoding\",\n\" -c none\t Use no compression algorithm on output\",\n\" \",\n\"Group 3 options:\",\n\" 1d\t\tUse default CCITT Group 3 1D-encoding\",\n\" 2d\t\tUse optional CCITT Group 3 2D-encoding\",\n\" fill\t\tByte-align EOL codes\",\n\"For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs\",\n\" \",\n\"JPEG options:\",\n\" #\t\tSet compression quality level (0-100, default 100)\",\n\" raw\t\tOutput color image as raw YCbCr\",\n\" rgb\t\tOutput color image as RGB\",\n\"For example, -c jpeg:rgb:50 to get JPEG-encoded RGB data with 50% comp. quality\",\n\" \",\n\"LZW and deflate options:\",\n\" #\t\tSet predictor value\",\n\"For example, -c lzw:2 to get LZW-encoded data with horizontal differencing\",\n\" \",\n\"Page and selection options:\",\n\" -N odd|even|#,#-#,#|last         sequences and ranges of images within file to process\",\n\"             The words odd or even may be used to specify all odd or even numbered images.\",\n\"             The word last may be used in place of a number in the sequence to indicate.\",\n\"             The final image in the file without knowing how many images there are.\",\n\"             Numbers are counted from one even though TIFF IFDs are counted from zero.\",\n\" \",\n\" -E t|l|r|b  edge to use as origin for width and length of crop region\",\n\" -U units    [in, cm, px ] inches, centimeters or pixels\",\n\" \",\n\" -m #,#,#,#  margins from edges for selection: top, left, bottom, right separated by commas\",\n\" -X #        horizontal dimension of region to extract expressed in current units\",\n\" -Y #        vertical dimension of region to extract expressed in current units\",\n\" -Z #:#,#:#  zones of the image designated as position X of Y,\",\n\"             eg 1:3 would be first of three equal portions measured from reference edge\",\n\" -z x1,y1,x2,y2:...:xN,yN,xN+1,yN+1\",\n\"             regions of the image designated by upper left and lower right coordinates\",\n\"\",\n\"Export grouping options:\",\n\" -e c|d|i|m|s    export mode for images and selections from input images.\",\n\"                 When exporting a composite image from multiple zones or regions\",\n\"                 (combined and image modes), the selections must have equal sizes\",\n\"                 for the axis perpendicular to the edge specified with -E.\",\n\"    c|combined   All images and selections are written to a single file (default).\",\n\"                 with multiple selections from one image combined into a single image.\",\n\"    d|divided    All images and selections are written to a single file\",\n\"                 with each selection from one image written to a new image.\",\n\"    i|image      Each input image is written to a new file (numeric filename sequence)\",\n\"                 with multiple selections from the image combined into one image.\",\n\"    m|multiple   Each input image is written to a new file (numeric filename sequence)\",\n\"                 with each selection from the image written to a new image.\",\n\"    s|separated  Individual selections from each image are written to separate files.\",\n\"\",\n\"Output options:\",\n\" -H #        Set horizontal resolution of output images to #\",\n\" -V #        Set vertical resolution of output images to #\",\n\" -J #        Set horizontal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" -K #        Set verticalal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" \",\n\" -O orient    orientation for output image, portrait, landscape, auto\",\n\" -P page      page size for output image segments, eg letter, legal, tabloid, etc\",\n\"              use #.#x#.# to specify a custom page size in the currently defined units\",\n\"              where #.# represents the width and length\",        \n\" -S cols:rows Divide the image into equal sized segments using cols across and rows down.\",\n\" \",\n\" -F hor|vert|both\",\n\"             flip (mirror) image or region horizontally, vertically, or both\",\n\" -R #        [90,180,or 270] degrees clockwise rotation of image or extracted region\",\n\" -I [black|white|data|both]\",\n\"             invert color space, eg dark to light for bilevel and grayscale images\",\n\"             If argument is white or black, set the PHOTOMETRIC_INTERPRETATION \",\n\"             tag to MinIsBlack or MinIsWhite without altering the image data\",\n\"             If the argument is data or both, the image data are modified:\",\n\"             both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,\",\n\"             data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag\",\n\" \",\n\"-D opt1:value1,opt2:value2,opt3:value3:opt4:value4\",\n\"             Debug/dump program progress and/or data to non-TIFF files.\",\n\"             Options include the following and must be joined as a comma\",\n\"             separate list. The use of this option is generally limited to\",\n\"             program debugging and development of future options.\",\n\" \",\n\"   debug:N   Display limited program progress indicators where larger N\",\n\"             increase the level of detail. Note: Tiffcrop may be compiled with\",\n\"             -DDEVELMODE to enable additional very low level debug reporting.\",\n\"\",\n\"   Format:txt|raw  Format any logged data as ASCII text or raw binary \",\n\"             values. ASCII text dumps include strings of ones and zeroes\",\n\"             representing the binary values in the image data plus identifying headers.\",\n\" \",\n\"   level:N   Specify the level of detail presented in the dump files.\",\n\"             This can vary from dumps of the entire input or output image data to dumps\",\n\"             of data processed by specific functions. Current range of levels is 1 to 3.\",\n\" \",\n\"   input:full-path-to-directory/input-dumpname\",\n\" \",\n\"   output:full-path-to-directory/output-dumpnaem\",\n\" \",\n\"             When dump files are being written, each image will be written to a separate\",\n\"             file with the name built by adding a numeric sequence value to the dumpname\",\n\"             and an extension of .txt for ASCII dumps or .bin for binary dumps.\",\n\" \",\n\"             The four debug/dump options are independent, though it makes little sense to\",\n\"             specify a dump file without specifying a detail level.\",\n\" \",\nNULL\n};\n\n/* This function could be modified to pass starting sample offset \n * and number of samples as args to select fewer than spp\n * from input image. These would then be passed to individual \n * extractContigSampleXX routines.\n */\nstatic int readContigTilesIntoBuffer (TIFF* in, uint8* buf, \n                                      uint32 imagelength, \n                                      uint32 imagewidth, \n                                      uint32 tw, uint32 tl,\n                                      tsample_t spp, uint16 bps)\n  {\n  int status = 1;\n  tsample_t sample = 0;\n  tsample_t count = spp; \n  uint32 row, col, trow;\n  uint32 nrow, ncol;\n  uint32 dst_rowsize, shift_width;\n  uint32 bytes_per_sample, bytes_per_pixel;\n  uint32 trailing_bits, prev_trailing_bits;\n  uint32 tile_rowsize  = TIFFTileRowSize(in);\n  uint32 src_offset, dst_offset;\n  uint32 row_offset, col_offset;\n  uint8 *bufp = (uint8*) buf;\n  unsigned char *src = NULL;\n  unsigned char *dst = NULL;\n  tsize_t tbytes = 0, tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(in);\n  unsigned char *tilebuf = NULL;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  tile_buffsize = tilesize;\n  if (tilesize == 0 || tile_rowsize == 0)\n  {\n     TIFFError(\"readContigTilesIntoBuffer\", \"Tile size or tile rowsize is zero\");\n     exit(-1);\n  }\n\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"readContigTilesIntoBuffer\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != (tile_buffsize / tile_rowsize))\n    {\n    \tTIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n        exit(-1);\n    }\n    }\n\n  /* Add 3 padding bytes for extractContigSamplesShifted32bits */\n  if( (size_t) tile_buffsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n  tilebuf = _TIFFmalloc(tile_buffsize + 3);\n  if (tilebuf == 0)\n    return 0;\n  tilebuf[tile_buffsize] = 0;\n  tilebuf[tile_buffsize+1] = 0;\n  tilebuf[tile_buffsize+2] = 0;\n\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n      if (tbytes < tilesize  && !ignore)\n        {\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\n\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n                  (unsigned long)tilesize);\n\t\t  status = 0;\n                  _TIFFfree(tilebuf);\n\t\t  return status;\n\t}\n      \n      row_offset = row * dst_rowsize;\n      col_offset = ((col * bps * spp) + 7)/ 8;\n      bufp = buf + row_offset + col_offset;\n\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      /* Each tile scanline will start on a byte boundary but it\n       * has to be merged into the scanline for the entire\n       * image buffer and the previous segment may not have\n       * ended on a byte boundary\n       */\n      /* Optimization for common bit depths, all samples */\n      if (((bps % 8) == 0) && (count == spp))\n        {\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n          bufp += (imagewidth * bps * spp) / 8;\n\t  }\n        }\n      else\n        {\n\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n        prev_trailing_bits = trailing_bits = 0;\n        trailing_bits = (ncol * bps * spp) % 8;\n\n\t/*\tfor (trow = 0; tl < nrow; trow++) */\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n          src = tilebuf + src_offset;\n\t  dst_offset = (row + trow) * dst_rowsize;\n          dst = buf + dst_offset + col_offset;\n          switch (shift_width)\n            {\n            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n                                                   spp, bps, count, 0, ncol))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 1: if (bps == 1)\n                      { \n                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n                                                            sample, spp,\n                                                            bps, count,\n                                                            0, ncol,\n                                                            prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t\t      break;\n\t\t      }\n                    else\n                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n                                                             sample, spp,\n                                                             bps, count,\n                                                             0, ncol,\n                                                             prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t            break;\n            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 3:\n            case 4:\n            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\n\t\t     return 1;\n\t    }\n          }\n        prev_trailing_bits += trailing_bits;\n        /* if (prev_trailing_bits > 7) */\n\t/*   prev_trailing_bits-= 8; */\n\t}\n      }\n    }\n\n  _TIFFfree(tilebuf);\n  return status;\n  }\n\nstatic int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp && s < MAX_SAMPLES; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }\n\nstatic int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)\n  {\n  uint32 row, nrows, rowsperstrip;\n  tstrip_t strip = 0;\n  tsize_t stripsize;\n\n  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  for (row = 0; row < imagelength; row += rowsperstrip)\n    {\n    nrows = (row + rowsperstrip > imagelength) ?\n\t     imagelength - row : rowsperstrip;\n    stripsize = TIFFVStripSize(out, nrows);\n    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)\n      {\n      TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n      return 1;\n      }\n    buf += stripsize;\n    }\n\n  return 0;\n  }\n\n/* Abandon plans to modify code so that plannar orientation separate images\n * do not have all samples for each channel written before all samples\n * for the next channel have been abandoned.\n * Libtiff internals seem to depend on all data for a given sample\n * being contiguous within a strip or tile when PLANAR_CONFIG is \n * separate. All strips or tiles of a given plane are written\n * before any strips or tiles of a different plane are stored.\n */\nstatic int \nwriteBufferToSeparateStrips (TIFF* out, uint8* buf, \n\t\t\t     uint32 length, uint32 width, uint16 spp,\n\t\t\t     struct dump_opts *dump)\n  {\n  uint8   *src;\n  uint16   bps;\n  uint32   row, nrows, rowsize, rowsperstrip;\n  uint32   bytes_per_sample;\n  tsample_t s;\n  tstrip_t strip = 0;\n  tsize_t  stripsize = TIFFStripSize(out);\n  tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);\n  tsize_t  total_bytes = 0;\n  tdata_t  obuf;\n\n  (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n  bytes_per_sample = (bps + 7) / 8;\n  if( width == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / width ||\n      bps * spp * width > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (bps * spp * width) + 7\");\n      return 1;\n  }\n  rowsize = ((bps * spp * width) + 7U) / 8; /* source has interleaved samples */\n  if( bytes_per_sample == 0 ||\n      rowsperstrip > TIFF_UINT32_MAX / bytes_per_sample ||\n      rowsperstrip * bytes_per_sample > TIFF_UINT32_MAX / (width + 1) )\n  {\n      TIFFError(TIFFFileName(out),\n                \"Error, uint32 overflow when computing rowsperstrip * \"\n                \"bytes_per_sample * (width + 1)\");\n      return 1;\n  }\n  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); \n\n  obuf = _TIFFmalloc (rowstripsize);\n  if (obuf == NULL)\n    return 1;\n  \n  for (s = 0; s < spp; s++)\n    {\n    for (row = 0; row < length; row += rowsperstrip)\n      {\n      nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;\n\n      stripsize = TIFFVStripSize(out, nrows);\n      src = buf + (row * rowsize);\n      total_bytes += stripsize;\n      memset (obuf, '\\0', rowstripsize);\n      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n        {\n        _TIFFfree(obuf);\n        return 1;\n\t}\n      if ((dump->outfile != NULL) && (dump->level == 1))\n        {\n        dump_info(dump->outfile, dump->format,\"\", \n                  \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\", \n                  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);\n        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\n\t}\n\n      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n        {\n\tTIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n\t_TIFFfree(obuf);\n\treturn 1;\n\t}\n      }\n    }      \n\n  _TIFFfree(obuf);\n  return 0;\n}\n\n/* Extract all planes from contiguous buffer into a single tile buffer \n * to be written out as a tile.\n */\nstatic int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts* dump)\n  {\n  uint16 bps;\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint32 tile_rowsize  = TIFFTileRowSize(out);\n  uint8* bufp = (uint8*) buf;\n  tsize_t tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(out);\n  unsigned char *tilebuf = NULL;\n\n  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||\n      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||\n      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )\n      return 1;\n\n  if (tilesize == 0 || tile_rowsize == 0 || tl == 0 || tw == 0)\n  {\n    TIFFError(\"writeBufferToContigTiles\", \"Tile size, tile row size, tile width, or tile length is zero\");\n    exit(-1);\n  }\n  \n  tile_buffsize = tilesize;\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"writeBufferToContigTiles\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != tile_buffsize / tile_rowsize)\n    {\n\tTIFFError(\"writeBufferToContigTiles\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    }\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n\n  tilebuf = _TIFFmalloc(tile_buffsize);\n  if (tilebuf == 0)\n    return 1;\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\", \n                  \"Unable to extract data to tile for row %lu, col %lu\",\n                  (unsigned long) row, (unsigned long)col);\n\t_TIFFfree(tilebuf);\n\treturn 1;\n        }\n\n      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\",\n\t          \"Cannot write tile at %lu %lu\",\n\t          (unsigned long) col, (unsigned long) row);\n\t _TIFFfree(tilebuf);\n\treturn 1;\n\t}\n      }\n    }\n  _TIFFfree(tilebuf);\n\n  return 0;\n  } /* end writeBufferToContigTiles */\n\n/* Extract each plane from contiguous buffer into a single tile buffer \n * to be written out as a tile.\n */\nstatic int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts * dump)\n  {\n  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint16 bps;\n  tsample_t s;\n  uint8* bufp = (uint8*) buf;\n\n  if (obuf == NULL)\n    return 1;\n\n  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7 )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      _TIFFfree(obuf);\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n         \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n\n      for (s = 0; s < spp; s++)\n        {\n\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)\n          {\n\t  TIFFError(\"writeBufferToSeparateTiles\", \n                    \"Unable to extract data to tile for row %lu, col %lu sample %d\",\n                    (unsigned long) row, (unsigned long)col, (int)s);\n\t  _TIFFfree(obuf);\n\t  return 1;\n          }\n\n\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)\n          {\n\t   TIFFError(\"writeBufferToseparateTiles\",\n\t             \"Cannot write tile at %lu %lu sample %lu\",\n\t             (unsigned long) col, (unsigned long) row,\n\t             (unsigned long) s);\n\t   _TIFFfree(obuf);\n\t   return 1;\n\t  }\n\t}\n      }\n    }\n  _TIFFfree(obuf);\n\n  return 0;\n  } /* end writeBufferToSeparateTiles */\n\nstatic void\nprocessG3Options(char* cp)\n{\n\tif( (cp = strchr(cp, ':')) ) {\n\t\tif (defg3opts == (uint32) -1)\n\t\t\tdefg3opts = 0;\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while( (cp = strchr(cp, ':')) );\n\t}\n}\n\nstatic int\nprocessCompressOptions(char* opt)\n  {\n  char* cp = NULL;\n\n  if (strneq(opt, \"none\",4))\n    {\n    defcompression = COMPRESSION_NONE;\n    }\n  else if (streq(opt, \"packbits\"))\n    {\n    defcompression = COMPRESSION_PACKBITS;\n    }\n  else if (strneq(opt, \"jpeg\", 4))\n    {\n    cp = strchr(opt, ':');\n    defcompression = COMPRESSION_JPEG;\n\n    while (cp)\n      {\n      if (isdigit((int)cp[1]))\n\tquality = atoi(cp + 1);\n      else if (strneq(cp + 1, \"raw\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RAW;\n      else if (strneq(cp + 1, \"rgb\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RGB;\n      else\n\tusage();\n      cp = strchr(cp + 1, ':');\n      }\n    }\n  else if (strneq(opt, \"g3\", 2))\n    {\n    processG3Options(opt);\n    defcompression = COMPRESSION_CCITTFAX3;\n    }\n  else if (streq(opt, \"g4\"))\n    {\n    defcompression = COMPRESSION_CCITTFAX4;\n    }\n  else if (strneq(opt, \"lzw\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_LZW;\n    }\n  else if (strneq(opt, \"zip\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_ADOBE_DEFLATE;\n   }\n  else\n    return (0);\n\n  return (1);\n  }\n\nstatic void\nusage(void)\n  {\n  int i;\n\n  fprintf(stderr, \"\\n%s\\n\", TIFFGetVersion());\n  for (i = 0; usage_info[i] != NULL; i++)\n    fprintf(stderr, \"%s\\n\", usage_info[i]);\n  exit(-1);\n  }\n\n#define\tCopyField(tag, v) \\\n    if (TIFFGetField(in, tag, &v)) TIFFSetField(out, tag, v)\n#define\tCopyField2(tag, v1, v2) \\\n    if (TIFFGetField(in, tag, &v1, &v2)) TIFFSetField(out, tag, v1, v2)\n#define\tCopyField3(tag, v1, v2, v3) \\\n    if (TIFFGetField(in, tag, &v1, &v2, &v3)) TIFFSetField(out, tag, v1, v2, v3)\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n    if (TIFFGetField(in, tag, &v1, &v2, &v3, &v4)) TIFFSetField(out, tag, v1, v2, v3, v4)\n\nstatic void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped\",\n                          tag, type);\n\t}\n}\n\nstatic struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n} tags[] = {\n\t{ TIFFTAG_SUBFILETYPE,\t\t1, TIFF_LONG },\n\t{ TIFFTAG_THRESHHOLDING,\t1, TIFF_SHORT },\n\t{ TIFFTAG_DOCUMENTNAME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_IMAGEDESCRIPTION,\t1, TIFF_ASCII },\n\t{ TIFFTAG_MAKE,\t\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_MODEL,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_MINSAMPLEVALUE,\t1, TIFF_SHORT },\n\t{ TIFFTAG_MAXSAMPLEVALUE,\t1, TIFF_SHORT },\n\t{ TIFFTAG_XRESOLUTION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_YRESOLUTION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_PAGENAME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_XPOSITION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_YPOSITION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_RESOLUTIONUNIT,\t1, TIFF_SHORT },\n\t{ TIFFTAG_SOFTWARE,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_DATETIME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_ARTIST,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_HOSTCOMPUTER,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_WHITEPOINT,\t\t(uint16) -1, TIFF_RATIONAL },\n\t{ TIFFTAG_PRIMARYCHROMATICITIES,(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_HALFTONEHINTS,\t2, TIFF_SHORT },\n\t{ TIFFTAG_INKSET,\t\t1, TIFF_SHORT },\n\t{ TIFFTAG_DOTRANGE,\t\t2, TIFF_SHORT },\n\t{ TIFFTAG_TARGETPRINTER,\t1, TIFF_ASCII },\n\t{ TIFFTAG_SAMPLEFORMAT,\t\t1, TIFF_SHORT },\n\t{ TIFFTAG_YCBCRCOEFFICIENTS,\t(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_YCBCRSUBSAMPLING,\t2, TIFF_SHORT },\n\t{ TIFFTAG_YCBCRPOSITIONING,\t1, TIFF_SHORT },\n\t{ TIFFTAG_REFERENCEBLACKWHITE,\t(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_EXTRASAMPLES,\t\t(uint16) -1, TIFF_SHORT },\n\t{ TIFFTAG_SMINSAMPLEVALUE,\t1, TIFF_DOUBLE },\n\t{ TIFFTAG_SMAXSAMPLEVALUE,\t1, TIFF_DOUBLE },\n\t{ TIFFTAG_STONITS,\t\t1, TIFF_DOUBLE },\n};\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n\n#define\tCopyTag(tag, count, type)\tcpTag(in, out, tag, count, type)\n\n/* Functions written by Richard Nolde, with exceptions noted. */\nvoid  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32 *dirnum,\n\t                    uint16 *defconfig, uint16 *deffillorder, uint32 *deftilewidth,\n                            uint32 *deftilelength, uint32 *defrowsperstrip,\n\t\t            struct crop_mask *crop_data, struct pagedef *page, \n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hil:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'h':\tusage();\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unkown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': TIFFError(\"Library Release\", \"%s\", TIFFGetVersion());\n                TIFFError (\"Tiffcrop version\", \"%s, last updated: %s\", \n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n \t        TIFFError (\"Tiffcp code\", \"Copyright (c) 1988-1997 Sam Leffler\");\n\t\tTIFFError (\"           \", \"Copyright (c) 1991-1997 Silicon Graphics, Inc\");\n                TIFFError (\"Tiffcrop additions\", \"Copyright (c) 2007-2010 Richard Nolde\");\n\t        exit (0);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%d %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (-1);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (-1);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned ouput pages */ \n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned ouput pages*/ \n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (-1);                   \n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (-1);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (-1);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(-1);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (-1);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\t/*NOTREACHED*/\n      }\n    }\n  }  /* end process_command_opts */\n\n/* Start a new output file if one has not been previously opened or\n * autoindex is set to non-zero. Update page and file counters\n * so TIFFTAG PAGENUM will be correct in image.\n */\nstatic int \nupdate_output_file (TIFF **tiffout, char *mode, int autoindex,\n                    char *outname, unsigned int *page)\n  {\n  static int findex = 0;    /* file sequence indicator */\n  char  *sep;\n  char   filenum[16];\n  char   export_ext[16];\n  char   exportname[PATH_MAX];\n\n  if (autoindex && (*tiffout != NULL))\n    {   \n    /* Close any export file that was previously opened */\n    TIFFClose (*tiffout);\n    *tiffout = NULL;\n    }\n\n  strcpy (export_ext, \".tiff\");\n  memset (exportname, '\\0', PATH_MAX);\n\n  /* Leave room for page number portion of the new filename */\n  strncpy (exportname, outname, PATH_MAX - 16);\n  if (*tiffout == NULL)   /* This is a new export file */\n    {\n    if (autoindex)\n      { /* create a new filename for each export */\n      findex++;\n      if ((sep = strstr(exportname, \".tif\")) || (sep = strstr(exportname, \".TIF\")))\n        {\n        strncpy (export_ext, sep, 5);\n        *sep = '\\0';\n        }\n      else\n        strncpy (export_ext, \".tiff\", 5);\n      export_ext[5] = '\\0';\n\n      /* MAX_EXPORT_PAGES limited to 6 digits to prevent string overflow of pathname */\n      if (findex > MAX_EXPORT_PAGES)\n\t{\n\tTIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES);\n        return 1;\n        }\n\n      snprintf(filenum, sizeof(filenum), \"-%03d%s\", findex, export_ext);\n      filenum[14] = '\\0';\n      strncat (exportname, filenum, 15);\n      }\n    exportname[PATH_MAX - 1] = '\\0';\n\n    *tiffout = TIFFOpen(exportname, mode);\n    if (*tiffout == NULL)\n      {\n      TIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname);\n      return 1;\n      }\n    *page = 0; \n\n    return 0;\n    }\n  else \n    (*page)++;\n\n  return 0;\n  } /* end update_output_file */\n\n\nint\nmain(int argc, char* argv[])\n  {\n\n#if !HAVE_DECL_OPTARG\n  extern int optind;\n#endif\n  uint16 defconfig = (uint16) -1;\n  uint16 deffillorder = 0;\n  uint32 deftilewidth = (uint32) 0;\n  uint32 deftilelength = (uint32) 0;\n  uint32 defrowsperstrip = (uint32) 0;\n  uint32 dirnum = 0;\n\n  TIFF *in = NULL;\n  TIFF *out = NULL;\n  char  mode[10];\n  char *mp = mode;\n\n  /** RJN additions **/\n  struct image_data image;     /* Image parameters for one image */\n  struct crop_mask  crop;      /* Cropping parameters for all images */\n  struct pagedef    page;      /* Page definition for output pages */\n  struct pageseg    sections[MAX_SECTIONS];  /* Sections of one output page */\n  struct buffinfo   seg_buffs[MAX_SECTIONS]; /* Segment buffer sizes and pointers */\n  struct dump_opts  dump;                  /* Data dump options */\n  unsigned char *read_buff    = NULL;      /* Input image data buffer */\n  unsigned char *crop_buff    = NULL;      /* Crop area buffer */\n  unsigned char *sect_buff    = NULL;      /* Image section buffer */\n  unsigned char *sect_src     = NULL;      /* Image section buffer pointer */\n  unsigned int  imagelist[MAX_IMAGES + 1]; /* individually specified images */\n  unsigned int  image_count  = 0;\n  unsigned int  dump_images  = 0;\n  unsigned int  next_image   = 0;\n  unsigned int  next_page    = 0;\n  unsigned int  total_pages  = 0;\n  unsigned int  total_images = 0;\n  unsigned int  end_of_input = FALSE;\n  int    seg, length;\n  char   temp_filename[PATH_MAX + 1];\n\n  little_endian = *((unsigned char *)&little_endian) & '1';\n\n  initImageData(&image);\n  initCropMasks(&crop);\n  initPageSetup(&page, sections, seg_buffs);\n  initDumpOptions(&dump);\n\n  process_command_opts (argc, argv, mp, mode, &dirnum, &defconfig, \n                        &deffillorder, &deftilewidth, &deftilelength, &defrowsperstrip,\n\t                &crop, &page, &dump, imagelist, &image_count);\n\n  if (argc - optind < 2)\n    usage();\n\n  if ((argc - optind) == 2)\n    pageNum = -1;\n  else\n    total_images = 0;\n  /* read multiple input files and write to output file(s) */\n  while (optind < argc - 1)\n    {\n    in = TIFFOpen (argv[optind], \"r\");\n    if (in == NULL)\n      return (-3);\n\n    /* If only one input file is specified, we can use directory count */\n    total_images = TIFFNumberOfDirectories(in); \n    if (image_count == 0)\n      {\n      dirnum = 0;\n      total_pages = total_images; /* Only valid with single input file */\n      }\n    else\n      {\n      dirnum = (tdir_t)(imagelist[next_image] - 1);\n      next_image++;\n\n      /* Total pages only valid for enumerated list of pages not derived\n       * using odd, even, or last keywords.\n       */\n      if (image_count >  total_images)\n\timage_count = total_images;\n      \n      total_pages = image_count;\n      }\n\n    /* MAX_IMAGES is used for special case \"last\" in selection list */\n    if (dirnum == (MAX_IMAGES - 1))\n      dirnum = total_images - 1;\n\n    if (dirnum > (total_images))\n      {\n      TIFFError (TIFFFileName(in), \n      \"Invalid image number %d, File contains only %d images\", \n\t\t (int)dirnum + 1, total_images);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    if (dirnum != 0 && !TIFFSetDirectory(in, (tdir_t)dirnum))\n      {\n      TIFFError(TIFFFileName(in),\"Error, setting subdirectory at %d\", dirnum);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    end_of_input = FALSE;\n    while (end_of_input == FALSE)\n      {\n      config = defconfig;\n      compression = defcompression;\n      predictor = defpredictor;\n      fillorder = deffillorder;\n      rowsperstrip = defrowsperstrip;\n      tilewidth = deftilewidth;\n      tilelength = deftilelength;\n      g3opts = defg3opts;\n\n      if (dump.format != DUMP_NONE)\n        {\n        /* manage input and/or output dump files here */\n\tdump_images++;\n        length = strlen(dump.infilename);\n        if (length > 0)\n          {\n          if (dump.infile != NULL)\n            fclose (dump.infile);\n\n          /* dump.infilename is guaranteed to be NUL termimated and have 20 bytes \n             fewer than PATH_MAX */ \n          snprintf(temp_filename, sizeof(temp_filename), \"%s-read-%03d.%s\",\n\t\t   dump.infilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t    TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.infile, dump.format, \"Reading image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        length = strlen(dump.outfilename);\n        if (length > 0)\n          {\n          if (dump.outfile != NULL)\n            fclose (dump.outfile);\n\n          /* dump.outfilename is guaranteed to be NUL termimated and have 20 bytes \n             fewer than PATH_MAX */ \n          snprintf(temp_filename, sizeof(temp_filename), \"%s-write-%03d.%s\",\n\t\t   dump.outfilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t      TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.outfile, dump.format, \"Writing image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        }\n\n      if (dump.debug)\n         TIFFError(\"main\", \"Reading image %4d of %4d total pages.\", dirnum + 1, total_pages);\n\n      if (loadImage(in, &image, &dump, &read_buff))\n        {\n        TIFFError(\"main\", \"Unable to load source image\");\n        exit (-1);\n        }\n\n      /* Correct the image orientation if it was not ORIENTATION_TOPLEFT.\n       */\n      if (image.adjustments != 0)\n        {\n\tif (correct_orientation(&image, &read_buff))\n\t    TIFFError(\"main\", \"Unable to correct image orientation\");\n        }\n\n      if (getCropOffsets(&image, &crop, &dump))\n        {\n        TIFFError(\"main\", \"Unable to define crop regions\");\n        exit (-1);\n\t}\n\n      if (crop.selections > 0)\n        {\n        if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n          {\n          TIFFError(\"main\", \"Unable to process image selections\");\n          exit (-1);\n\t  }\n\t}\n      else  /* Single image segment without zones or regions */\n        {\n        if (createCroppedImage(&image, &crop, &read_buff, &crop_buff))\n          {\n          TIFFError(\"main\", \"Unable to create output image\");\n          exit (-1);\n\t  }\n\t}\n      if (page.mode == PAGE_MODE_NONE)\n        {  /* Whole image or sections not based on output page size */\n        if (crop.selections > 0)\n          {\n\t  writeSelections(in, &out, &crop, &image, &dump, seg_buffs,\n                          mp, argv[argc - 1], &next_page, total_pages);\n          }\n\telse  /* One file all images and sections */\n          {\n\t  if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1],\n                                  &next_page))\n             exit (1);\n          if (writeCroppedImage(in, out, &image, &dump,crop.combined_width, \n                                crop.combined_length, crop_buff, next_page, total_pages))\n            {\n             TIFFError(\"main\", \"Unable to write new image\");\n             exit (-1);\n\t    }\n          }\n\t}\n      else\n        {\n\t/* If we used a crop buffer, our data is there, otherwise it is\n         * in the read_buffer\n         */\n\tif (crop_buff != NULL)  \n\t  sect_src = crop_buff;\n        else\n          sect_src = read_buff;\n        /* Break input image into pages or rows and columns */\n        if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump))\n          {\n          TIFFError(\"main\", \"Unable to compute output section data\");\n          exit (-1);\n\t  }\n        /* If there are multiple files on the command line, the final one is assumed \n         * to be the output filename into which the images are written.\n         */\n\tif (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page))\n          exit (1);\n\n\tif (writeImageSections(in, out, &image, &page, sections, &dump, sect_src, &sect_buff))\n          {\n          TIFFError(\"main\", \"Unable to write image sections\");\n          exit (-1);\n\t  }\n        }\n\n      /* No image list specified, just read the next image */\n      if (image_count == 0)\n        dirnum++;\n      else\n        {\n\tdirnum = (tdir_t)(imagelist[next_image] - 1);\n        next_image++;\n        }\n\n      if (dirnum == MAX_IMAGES - 1)\n        dirnum = TIFFNumberOfDirectories(in) - 1;\n\n      if (!TIFFSetDirectory(in, (tdir_t)dirnum))\n        end_of_input = TRUE;\n      }\n    TIFFClose(in);\n    optind++;\n    }\n\n  /* If we did not use the read buffer as the crop buffer */\n  if (read_buff)\n    _TIFFfree(read_buff);\n\n  if (crop_buff)\n    _TIFFfree(crop_buff);\n\n  if (sect_buff)\n    _TIFFfree(sect_buff);\n\n   /* Clean up any segment buffers used for zones or regions */\n  for (seg = 0; seg < crop.selections; seg++)\n    _TIFFfree (seg_buffs[seg].buffer);\n\n  if (dump.format != DUMP_NONE)\n    {\n    if (dump.infile != NULL)\n     fclose (dump.infile);\n\n    if (dump.outfile != NULL)\n      {\n      dump_info (dump.outfile, dump.format, \"\", \"Completed run for %s\", TIFFFileName(out));\n      fclose (dump.outfile);\n      }\n    }\n\n  TIFFClose(out);\n\n  return (0);\n  } /* end main */\n\n\n/* Debugging functions */\nstatic int dump_data (FILE *dumpfile, int format, char *dump_tag, unsigned char *data, uint32 count)\n  {\n  int j, k;\n  uint32 i;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (i = 0; i < count; i++)\n      {\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n\tbitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n        }\n      dump_array[8] = '\\0';\n      fprintf (dumpfile,\" %s\", dump_array);\n      }\n    fprintf (dumpfile,\"\\n\");\n    }\n  else\n    {\n    if ((fwrite (data, 1, count, dumpfile)) != count)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_byte (FILE *dumpfile, int format, char *dump_tag, unsigned char data)\n  {\n  int j, k;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 7; j < 8; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      }\n    dump_array[8] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 1, 1, dumpfile)) != 1)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_short (FILE *dumpfile, int format, char *dump_tag, uint16 data)\n  {\n  int j, k;\n  char  dump_array[20];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 15; k >= 0; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[17] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 2, 1, dumpfile)) != 2)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_long (FILE *dumpfile, int format, char *dump_tag, uint32 data)\n  {\n  int j, k;\n  char  dump_array[40];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 31; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint32)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[35] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 4, 1, dumpfile)) != 4)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n  return (0);\n  }\n\nstatic int dump_wide (FILE *dumpfile, int format, char *dump_tag, uint64 data)\n  {\n  int j, k;\n  char  dump_array[80];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 63; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint64)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[71] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 8, 1, dumpfile)) != 8)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...)\n  {\n  if (format == DUMP_TEXT)\n    {\n    va_list ap;\n    va_start(ap, msg);\n    fprintf(dumpfile, \"%s \", prefix);\n    vfprintf(dumpfile, msg, ap);\n    fprintf(dumpfile, \"\\n\");\n    va_end(ap);\n    }\n  }\n\nstatic int dump_buffer (FILE* dumpfile, int format, uint32 rows, uint32 width, \n                 uint32 row, unsigned char *buff)\n  {\n  int j, k;\n  uint32 i;\n  unsigned char * dump_ptr;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  for (i = 0; i < rows; i++)\n    {\n    dump_ptr = buff + (i * width);\n    if (format == DUMP_TEXT)\n      dump_info (dumpfile, format, \"\", \n                 \"Row %4d, %d bytes at offset %d\",\n\t         row + i + 1, width, row * width);\n     \n    for (j = 0, k = width; k >= 10; j += 10, k -= 10, dump_ptr += 10)\n      dump_data (dumpfile, format, \"\", dump_ptr, 10);\n    if (k > 0)\n      dump_data (dumpfile, format, \"\", dump_ptr, k);\n    }\n  return (0);\n  }\n\n/* Extract one or more samples from an interleaved buffer. If count == 1,\n * only the sample plane indicated by sample will be extracted.  If count > 1, \n * count samples beginning at sample will be extracted. Portions of a \n * scanline can be extracted by specifying a start and end value.\n */\n\nstatic int \nextractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols, \n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int i, bytes_per_sample, sindex;\n  uint32 col, dst_rowsize, bit_offset;\n  uint32 src_byte /*, src_bit */;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  dst_rowsize = (bps * (end - start) * count) / 8;\n\n  bytes_per_sample = (bps + 7) / 8; \n  /* Optimize case for copying all samples */\n  if (count == spp)\n    {\n    src = in + (start * spp * bytes_per_sample);\n    _TIFFmemcpy (dst, src, dst_rowsize);\n    }\n  else\n    {\n    for (col = start; col < end; col++)\n      {\n      for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n        {\n        bit_offset = col * bps * spp;\n        if (sindex == 0)\n          {\n          src_byte = bit_offset / 8;\n          /* src_bit  = bit_offset % 8; */\n          }\n        else\n          {\n          src_byte = (bit_offset + (sindex * bps)) / 8;\n          /* src_bit  = (bit_offset + (sindex * bps)) % 8; */\n          }\n        src = in + src_byte;\n        for (i = 0; i < bytes_per_sample; i++)\n            *dst++ = *src++;\n        }\n      }\n    }\n\n  return (0);\n  } /* end extractContigSamplesBytes */\n\nstatic int\nextractContigSamples8bits (uint8 *in, uint8 *out, uint32 cols,\n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n  \n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end extractContigSamples8bits */\n\nstatic int\nextractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols, \n                            tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n\n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        { \n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamples16bits */\n\n\nstatic int\nextractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                    tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16) /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    } \n  \n  return (0);\n  } /* end extractContigSamples24bits */\n\nstatic int\nextractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,\n                            tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t    tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16)  | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 32)\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamples32bits */\n\nstatic int\nextractContigSamplesShifted8bits (uint8 *in, uint8 *out, uint32 cols,\n                                  tsample_t sample, uint16 spp, uint16 bps, \n\t\t\t          tsample_t count, uint32 start, uint32 end,\n \t                          int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n      if ((col == start) && (sindex == sample))\n        buff2 = *src & ((uint8)-1) << (shift);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ |= buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n\tbuff2 = buff2 | (buff1 >> ready_bits);\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end extractContigSamplesShifted8bits */\n\nstatic int\nextractContigSamplesShifted16bits (uint8 *in, uint8 *out, uint32 cols, \n                                   tsample_t sample, uint16 spp, uint16 bps, \n  \t\t\t           tsample_t count, uint32 start, uint32 end,\n \t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits = (uint16)-1 >> (16 - bps);\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint16)-1) << (8 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        buff2 = buff2 | (buff1 >> ready_bits);\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamplesShifted16bits */\n\n\nstatic int\nextractContigSamplesShifted24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                           tsample_t sample, uint16 spp, uint16 bps, \n                                   tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint32)-1) << (16 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16)  /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n   \n  return (0);\n  } /* end extractContigSamplesShifted24bits */\n\nstatic int\nextractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,\n                                   tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t           tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = shift;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      if ((col == start) && (sindex == sample))\n        buff2 = buff3 & ((uint64)-1) << (32 - shift);\n\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamplesShifted32bits */\n\nstatic int\nextractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                     tsample_t sample, uint16 spp, uint16 bps, \n                             struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row, first_col = 0;\n  uint32 dst_rowsize, dst_offset;\n  tsample_t count = 1;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src_rowsize = ((bps * spp * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols) + 7) / 8;\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, first_col, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, first_col, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  } /* end extractContigSamplesToBuffer */\n\nstatic int\nextractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,\n\t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row;\n  uint32 dst_rowsize, dst_offset;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToTileBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n\n  src_rowsize = ((bps * spp * imagewidth) + 7) / 8;\n  dst_rowsize = ((bps * tilewidth * count) + 7) / 8;\n\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, 0, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, 0, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, 0, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToTileBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  } /* end extractContigSamplesToTileBuffer */\n\nstatic int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} /* end readContigStripsIntoBuffer */\n\nstatic int \ncombineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,\n                             FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n\n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * spp * cols) + 7) / 8;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    row_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = row_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        src += bytes_per_sample;\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamplesBytes */\n\nstatic int\ncombineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                            uint32 rows, uint16 spp, uint16 bps, \n \t                    FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  /* int    bytes_per_sample = 0; */\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamples8bits */\n\nstatic int\ncombineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n \t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamples16bits */\n\nstatic int\ncombineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateSamples24bits */\n\nstatic int\ncombineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n          longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateSamples32bits */\n\nstatic int \ncombineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                                 uint32 cols, uint32 rows, uint32 imagewidth,\n                                 uint32 tw, uint16 spp, uint16 bps,\n                                 FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = imagewidth * bytes_per_sample * spp;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n#ifdef DEVELMODE\n    TIFFError(\"\",\"Tile row %4d, Src offset %6d   Dst offset %6d\", \n              row, src_offset, dst - out);\n#endif\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = src_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamplesBytes */\n\nstatic int\ncombineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                                 uint32 rows, uint32 imagewidth, \n                                 uint32 tw, uint16 spp, uint16 bps, \n \t                         FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamples8bits */\n\nstatic int\ncombineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamples16bits */\n\nstatic int\ncombineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateTileSamples24bits */\n\nstatic int\ncombineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\t  longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateTileSamples32bits */\n\n\nstatic int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  } /* end readSeparateStripsIntoBuffer */\n\nstatic int\nget_page_geometry (char *name, struct pagedef *page)\n    {\n    char *ptr;\n    int n; \n\n    for (ptr = name; *ptr; ptr++)\n      *ptr = (char)tolower((int)*ptr);\n\n    for (n = 0; n < MAX_PAPERNAMES; n++)\n      {\n      if (strcmp(name, PaperTable[n].name) == 0)\n        {\n\tpage->width = PaperTable[n].width;\n\tpage->length = PaperTable[n].length;\n        strncpy (page->name, PaperTable[n].name, 15);\n        page->name[15] = '\\0';\n        return (0);\n        }\n      }\n\n  return (1);\n  }\n\n\nstatic void\ninitPageSetup (struct pagedef *page, struct pageseg *pagelist, \n               struct buffinfo seg_buffs[])\n   {\n   int i; \n\n   strcpy (page->name, \"\");\n   page->mode = PAGE_MODE_NONE;\n   page->res_unit = RESUNIT_NONE;\n   page->hres = 0.0;\n   page->vres = 0.0;\n   page->width = 0.0;\n   page->length = 0.0;\n   page->hmargin = 0.0;\n   page->vmargin = 0.0;\n   page->rows = 0;\n   page->cols = 0;\n   page->orient = ORIENTATION_NONE;\n\n   for (i = 0; i < MAX_SECTIONS; i++)\n     {\n     pagelist[i].x1 = (uint32)0;\n     pagelist[i].x2 = (uint32)0;\n     pagelist[i].y1 = (uint32)0;\n     pagelist[i].y2 = (uint32)0;\n     pagelist[i].buffsize = (uint32)0;\n     pagelist[i].position = 0;\n     pagelist[i].total = 0;\n     }\n\n   for (i = 0; i < MAX_OUTBUFFS; i++)\n     {\n     seg_buffs[i].size = 0;\n     seg_buffs[i].buffer = NULL;\n     }\n   }\n\nstatic void\ninitImageData (struct image_data *image)\n  {\n  image->xres = 0.0;\n  image->yres = 0.0;\n  image->width = 0;\n  image->length = 0;\n  image->res_unit = RESUNIT_NONE;\n  image->bps = 0;\n  image->spp = 0;\n  image->planar = 0;\n  image->photometric = 0;\n  image->orientation = 0;\n  image->compression = COMPRESSION_NONE;\n  image->adjustments = 0;\n  }\n\nstatic void\ninitCropMasks (struct crop_mask *cps)\n   {\n   int i;\n\n   cps->crop_mode = CROP_NONE;\n   cps->res_unit  = RESUNIT_NONE;\n   cps->edge_ref  = EDGE_TOP;\n   cps->width = 0;\n   cps->length = 0;\n   for (i = 0; i < 4; i++)\n     cps->margins[i] = 0.0;\n   cps->bufftotal = (uint32)0;\n   cps->combined_width = (uint32)0;\n   cps->combined_length = (uint32)0;\n   cps->rotation = (uint16)0;\n   cps->photometric = INVERT_DATA_AND_TAG;\n   cps->mirror   = (uint16)0;\n   cps->invert   = (uint16)0;\n   cps->zones    = (uint32)0;\n   cps->regions  = (uint32)0;\n   for (i = 0; i < MAX_REGIONS; i++)\n     {\n     cps->corners[i].X1 = 0.0;\n     cps->corners[i].X2 = 0.0;\n     cps->corners[i].Y1 = 0.0;\n     cps->corners[i].Y2 = 0.0;\n     cps->regionlist[i].x1 = 0;\n     cps->regionlist[i].x2 = 0;\n     cps->regionlist[i].y1 = 0;\n     cps->regionlist[i].y2 = 0;\n     cps->regionlist[i].width = 0;\n     cps->regionlist[i].length = 0;\n     cps->regionlist[i].buffsize = 0;\n     cps->regionlist[i].buffptr = NULL;\n     cps->zonelist[i].position = 0;\n     cps->zonelist[i].total = 0;\n     }\n   cps->exp_mode = ONE_FILE_COMPOSITE;\n   cps->img_mode = COMPOSITE_IMAGES;\n   }\n\nstatic void initDumpOptions(struct dump_opts *dump)\n  {\n  dump->debug  = 0;\n  dump->format = DUMP_NONE;\n  dump->level  = 1;\n  sprintf (dump->mode, \"w\");\n  memset (dump->infilename, '\\0', PATH_MAX + 1);\n  memset (dump->outfilename, '\\0',PATH_MAX + 1);\n  dump->infile = NULL;\n  dump->outfile = NULL;\n  }\n\n/* Compute pixel offsets into the image for margins and fixed regions */\nstatic int\ncomputeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,\n                         struct offset *off)\n  {\n  double scale;\n  float xres, yres;\n  /* Values for these offsets are in pixels from start of image, not bytes,\n   * and are indexed from zero to width - 1 or length - 1 */\n  uint32 tmargin, bmargin, lmargin, rmargin;\n  uint32 startx, endx;   /* offsets of first and last columns to extract */\n  uint32 starty, endy;   /* offsets of first and last row to extract */\n  uint32 width, length, crop_width, crop_length; \n  uint32 i, max_width, max_length, zwidth, zlength, buffsize;\n  uint32 x1, x2, y1, y2;\n\n  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER)\n    {\n    xres = 1.0;\n    yres = 1.0;\n    }\n  else\n    {\n    if (((image->xres == 0) || (image->yres == 0)) && \n         (crop->res_unit != RESUNIT_NONE) &&\n\t((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||\n \t (crop->crop_mode & CROP_LENGTH)  || (crop->crop_mode & CROP_WIDTH)))\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Cannot compute margins or fixed size sections without image resolution\");\n      TIFFError(\"computeInputPixelOffsets\", \"Specify units in pixels and try again\");\n      return (-1);\n      }\n    xres = image->xres;\n    yres = image->yres;\n    }\n\n  /* Translate user units to image units */\n  scale = 1.0;\n  switch (crop->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (image->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (image->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  if (crop->crop_mode & CROP_REGIONS)\n    {\n    max_width = max_length = 0;\n    for (i = 0; i < crop->regions; i++)\n      {\n      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))\n        {\n\tx1 = (uint32) (crop->corners[i].X1 * scale * xres);\n\tx2 = (uint32) (crop->corners[i].X2 * scale * xres);\n\ty1 = (uint32) (crop->corners[i].Y1 * scale * yres);\n\ty2 = (uint32) (crop->corners[i].Y2 * scale * yres);\n        }\n      else\n        {\n\tx1 = (uint32) (crop->corners[i].X1);\n\tx2 = (uint32) (crop->corners[i].X2);\n\ty1 = (uint32) (crop->corners[i].Y1);\n\ty2 = (uint32) (crop->corners[i].Y2);       \n\t}\n      if (x1 < 1)\n        crop->regionlist[i].x1 = 0;\n      else\n        crop->regionlist[i].x1 = (uint32) (x1 - 1);\n\n      if (x2 > image->width - 1)\n        crop->regionlist[i].x2 = image->width - 1;\n      else\n        crop->regionlist[i].x2 = (uint32) (x2 - 1);\n      zwidth  = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1; \n\n      if (y1 < 1)\n        crop->regionlist[i].y1 = 0;\n      else\n        crop->regionlist[i].y1 = (uint32) (y1 - 1);\n\n      if (y2 > image->length - 1)\n        crop->regionlist[i].y2 = image->length - 1;\n      else\n        crop->regionlist[i].y2 = (uint32) (y2 - 1);\n\n      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1; \n\n      if (zwidth > max_width)\n        max_width = zwidth;\n      if (zlength > max_length)\n        max_length = zlength;\n\n      buffsize = (uint32)\n          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));\n\n      crop->regionlist[i].buffsize = buffsize;\n      crop->bufftotal += buffsize;\n      if (crop->img_mode == COMPOSITE_IMAGES)\n        {\n        switch (crop->edge_ref)\n          {\n          case EDGE_LEFT:\n          case EDGE_RIGHT:\n               crop->combined_length = zlength;\n               crop->combined_width += zwidth;\n               break;\n          case EDGE_BOTTOM:\n          case EDGE_TOP:  /* width from left, length from top */\n          default:\n               crop->combined_width = zwidth;\n               crop->combined_length += zlength;\n\t       break;\n          }\n\t}\n      }\n    return (0);\n    }\n  \n  /* Convert crop margins into offsets into image\n   * Margins are expressed as pixel rows and columns, not bytes\n   */\n  if (crop->crop_mode & CROP_MARGINS)\n    {\n    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n      { /* User has specified pixels as reference unit */\n      tmargin = (uint32)(crop->margins[0]);\n      lmargin = (uint32)(crop->margins[1]);\n      bmargin = (uint32)(crop->margins[2]);\n      rmargin = (uint32)(crop->margins[3]);\n      }\n    else\n      { /* inches or centimeters specified */\n      tmargin = (uint32)(crop->margins[0] * scale * yres);\n      lmargin = (uint32)(crop->margins[1] * scale * xres);\n      bmargin = (uint32)(crop->margins[2] * scale * yres);\n      rmargin = (uint32)(crop->margins[3] * scale * xres);\n      }\n\n    if ((lmargin + rmargin) > image->width)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined left and right margins exceed image width\");\n      lmargin = (uint32) 0;\n      rmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((tmargin + bmargin) > image->length)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined top and bottom margins exceed image length\"); \n      tmargin = (uint32) 0; \n      bmargin = (uint32) 0;\n      return (-1);\n      }\n    }\n  else\n    { /* no margins requested */\n    tmargin = (uint32) 0;\n    lmargin = (uint32) 0;\n    bmargin = (uint32) 0;\n    rmargin = (uint32) 0;\n    }\n\n  /* Width, height, and margins are expressed as pixel offsets into image */\n  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)crop->width;\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)crop->length;\n    else\n      length = image->length - tmargin - bmargin;\n    }\n  else\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)(crop->width * scale * image->xres);\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)(crop->length * scale * image->yres);\n    else\n      length = image->length - tmargin - bmargin;\n    }\n\n  off->tmargin = tmargin;\n  off->bmargin = bmargin;\n  off->lmargin = lmargin;\n  off->rmargin = rmargin;\n\n  /* Calculate regions defined by margins, width, and length. \n   * Coordinates expressed as 0 to imagewidth - 1, imagelength - 1,\n   * since they are used to compute offsets into buffers */\n  switch (crop->edge_ref) {\n    case EDGE_BOTTOM:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         endy = image->length - bmargin - 1;\n         if ((endy - length) <= tmargin)\n           starty = tmargin;\n         else\n           starty = endy - length + 1;\n         break;\n    case EDGE_RIGHT:\n         endx = image->width - rmargin - 1;\n         if ((endx - width) <= lmargin)\n           startx = lmargin;\n         else\n           startx = endx - width + 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    case EDGE_TOP:  /* width from left, length from top */\n    case EDGE_LEFT:\n    default:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    }\n  off->startx = startx;\n  off->starty = starty;\n  off->endx   = endx;\n  off->endy   = endy;\n\n  crop_width  = endx - startx + 1;\n  crop_length = endy - starty + 1;\n\n  if (crop_width <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n               \"Invalid left/right margins and /or image crop width requested\");\n    return (-1);\n    }\n  if (crop_width > image->width)\n    crop_width = image->width;\n\n  if (crop_length <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n              \"Invalid top/bottom margins and /or image crop length requested\");\n    return (-1);\n    }\n  if (crop_length > image->length)\n    crop_length = image->length;\n\n  off->crop_width = crop_width;\n  off->crop_length = crop_length;\n\n  return (0);\n  } /* end computeInputPixelOffsets */\n\n/* \n * Translate crop options into pixel offsets for one or more regions of the image.\n * Options are applied in this order: margins, specific width and length, zones,\n * but all are optional. Margins are relative to each edge. Width, length and\n * zones are relative to the specified reference edge. Zones are expressed as\n * X:Y where X is the ordinal value in a set of Y equal sized portions. eg.\n * 2:3 would indicate the middle third of the region qualified by margins and\n * any explicit width and length specified. Regions are specified by coordinates\n * of the top left and lower right corners with range 1 to width or height.\n */\n\nstatic int\ngetCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump)\n  {\n  struct offset offsets;\n  int    i;\n  int32  test;\n  uint32 seg, total, need_buff = 0;\n  uint32 buffsize;\n  uint32 zwidth, zlength;\n\n  memset(&offsets, '\\0', sizeof(struct offset));\n  crop->bufftotal = 0;\n  crop->combined_width  = (uint32)0;\n  crop->combined_length = (uint32)0;\n  crop->selections = 0;\n\n  /* Compute pixel offsets if margins or fixed width or length specified */\n  if ((crop->crop_mode & CROP_MARGINS) ||\n      (crop->crop_mode & CROP_REGIONS) ||\n      (crop->crop_mode & CROP_LENGTH)  || \n      (crop->crop_mode & CROP_WIDTH))\n    {\n    if (computeInputPixelOffsets(crop, image, &offsets))\n      {\n      TIFFError (\"getCropOffsets\", \"Unable to compute crop margins\");\n      return (-1);\n      }\n    need_buff = TRUE;\n    crop->selections = crop->regions;\n    /* Regions are only calculated from top and left edges with no margins */\n    if (crop->crop_mode & CROP_REGIONS)\n      return (0);\n    }\n  else\n    { /* cropped area is the full image */\n    offsets.tmargin = 0;\n    offsets.lmargin = 0;\n    offsets.bmargin = 0;\n    offsets.rmargin = 0;\n    offsets.crop_width = image->width;\n    offsets.crop_length = image->length;\n    offsets.startx = 0;\n    offsets.endx = image->width - 1;\n    offsets.starty = 0;\n    offsets.endy = image->length - 1;\n    need_buff = FALSE;\n    }\n\n  if (dump->outfile != NULL)\n    {\n    dump_info (dump->outfile, dump->format, \"\", \"Margins: Top: %d  Left: %d  Bottom: %d  Right: %d\", \n           offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin); \n    dump_info (dump->outfile, dump->format, \"\", \"Crop region within margins: Adjusted Width:  %6d  Length: %6d\", \n           offsets.crop_width, offsets.crop_length);\n    }\n\n  if (!(crop->crop_mode & CROP_ZONES)) /* no crop zones requested */\n    {\n    if (need_buff == FALSE)  /* No margins or fixed width or length areas */\n      {\n      crop->selections = 0;\n      crop->combined_width  = image->width;\n      crop->combined_length = image->length;\n      return (0);\n      }\n    else \n      {\n      /* Use one region for margins and fixed width or length areas\n       * even though it was not formally declared as a region.\n       */\n      crop->selections = 1;\n      crop->zones = 1;\n      crop->zonelist[0].total = 1;\n      crop->zonelist[0].position = 1;\n      }\n    }     \n  else\n    crop->selections = crop->zones;\n\n  for (i = 0; i < crop->zones; i++)\n    {\n    seg = crop->zonelist[i].position;\n    total = crop->zonelist[i].total;\n\n    switch (crop->edge_ref) \n      {\n      case EDGE_LEFT: /* zones from left to right, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx + \n                                  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);\n           test = (int32)offsets.startx + \n                  (int32)(offsets.crop_width * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n\t       crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_BOTTOM: /* width from left, zones from bottom to top */\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n\t     crop->regionlist[i].y1 = 0;\n           else\n\t     crop->regionlist[i].y1 = test + 1;\n\n           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n             if (test > (int32)(image->length - 1))\n               crop->regionlist[i].y2 = image->length - 1;\n             else \n               crop->regionlist[i].y2 = test;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_RIGHT: /* zones from right to left, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx +\n                                  (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);\n           test = offsets.startx + \n\t          (offsets.crop_width * (total - seg + 1) * 1.0 / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n               crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_TOP: /* width from left, zones from top to bottom */\n      default:\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\n           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->length - 1))\n\t       crop->regionlist[i].y2 = image->length - 1;\n             else\n\t       crop->regionlist[i].y2 = test - 1;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      } /* end switch statement */\n\n    buffsize = (uint32)\n          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));\n    crop->regionlist[i].width = (uint32) zwidth;\n    crop->regionlist[i].length = (uint32) zlength;\n    crop->regionlist[i].buffsize = buffsize;\n    crop->bufftotal += buffsize;\n\n\n  if (dump->outfile != NULL)\n    dump_info (dump->outfile, dump->format, \"\",  \"Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\",\n                    i + 1, (uint32)zwidth, (uint32)zlength,\n\t\t    crop->regionlist[i].x1, crop->regionlist[i].x2, \n                    crop->regionlist[i].y1, crop->regionlist[i].y2);\n    }\n\n  return (0);\n  } /* end getCropOffsets */\n\n\nstatic int\ncomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n                           struct pagedef *page, struct pageseg *sections,\n                           struct dump_opts* dump)\n  {\n  double scale;\n  double pwidth, plength;          /* Output page width and length in user units*/\n  uint32 iwidth, ilength;          /* Input image width and length in pixels*/\n  uint32 owidth, olength;          /* Output image width and length in pixels*/\n  uint32 orows, ocols;             /* rows and cols for output */\n  uint32 hmargin, vmargin;         /* Horizontal and vertical margins */\n  uint32 x1, x2, y1, y2, line_bytes;\n  /* unsigned int orientation; */\n  uint32 i, j, k;\n \n  scale = 1.0;\n  if (page->res_unit == RESUNIT_NONE)\n    page->res_unit = image->res_unit;\n\n  switch (image->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (page->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (page->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  /* get width, height, resolutions of input image selection */\n  if (crop->combined_width > 0)\n    iwidth = crop->combined_width;\n  else\n    iwidth = image->width;\n  if (crop->combined_length > 0)\n    ilength = crop->combined_length;\n  else\n    ilength = image->length;\n\n  if (page->hres <= 1.0)\n    page->hres = image->xres;\n  if (page->vres <= 1.0)\n    page->vres = image->yres;\n\n  if ((page->hres < 1.0) || (page->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* If no page sizes are being specified, we just use the input image size to\n   * calculate maximum margins that can be taken from image.\n   */\n  if (page->width <= 0)\n    pwidth = iwidth;\n  else\n    pwidth = page->width;\n\n  if (page->length <= 0)\n    plength = ilength;\n  else\n    plength = page->length;\n\n  if (dump->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     page->name, page->vres, page->hres,\n             page->hmargin, page->vmargin);\n    TIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\", \n           page->res_unit, scale, pwidth, plength);\n    }\n\n  /* compute margins at specified unit and resolution */\n  if (page->mode & PAGE_MODE_MARGINS)\n    {\n    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n      { /* inches or centimeters specified */\n      hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));\n      }\n    else\n      { /* Otherwise user has specified pixels as reference unit */\n      hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));\n      }\n\n    if ((hmargin * 2.0) > (pwidth * page->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      hmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((vmargin * 2.0) > (plength * page->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      vmargin = (uint32) 0; \n      return (-1);\n      }\n    }\n  else\n    {\n    hmargin = 0;\n    vmargin = 0;\n    }\n\n  if (page->mode & PAGE_MODE_ROWSCOLS )\n    {\n    /* Maybe someday but not for now */\n    if (page->mode & PAGE_MODE_MARGINS)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    owidth  = TIFFhowmany(iwidth, page->cols);\n    olength = TIFFhowmany(ilength, page->rows);\n    }\n  else\n    {\n    if (page->mode & PAGE_MODE_PAPERSIZE )\n      {\n      owidth  = (uint32)((pwidth * page->hres) - (hmargin * 2));\n      olength = (uint32)((plength * page->vres) - (vmargin * 2));\n      }\n    else\n      {\n      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));\n      olength = (uint32)(ilength - (vmargin * 2 * page->vres));\n      }\n    }\n\n  if (owidth > iwidth)\n    owidth = iwidth;\n  if (olength > ilength)\n    olength = ilength;\n\n  /* Compute the number of pages required for Portrait or Landscape */\n  switch (page->orient)\n    {\n    case ORIENTATION_NONE:\n    case ORIENTATION_PORTRAIT:\n         ocols = TIFFhowmany(iwidth, owidth);\n         orows = TIFFhowmany(ilength, olength);\n         /* orientation = ORIENTATION_PORTRAIT; */\n         break;\n\n    case ORIENTATION_LANDSCAPE:\n         ocols = TIFFhowmany(iwidth, olength);\n         orows = TIFFhowmany(ilength, owidth);\n         x1 = olength;\n         olength = owidth;\n         owidth = x1;\n         /* orientation = ORIENTATION_LANDSCAPE; */\n         break;\n\n    case ORIENTATION_AUTO:\n    default:\n         x1 = TIFFhowmany(iwidth, owidth);\n         x2 = TIFFhowmany(ilength, olength); \n         y1 = TIFFhowmany(iwidth, olength);\n         y2 = TIFFhowmany(ilength, owidth); \n\n         if ( (x1 * x2) < (y1 * y2))\n           { /* Portrait */\n           ocols = x1;\n           orows = x2;\n           /* orientation = ORIENTATION_PORTRAIT; */\n\t   }\n         else\n           { /* Landscape */\n           ocols = y1;\n           orows = y2;\n           x1 = olength;\n           olength = owidth;\n           owidth = x1;\n           /* orientation = ORIENTATION_LANDSCAPE; */\n           }\n    }\n\n  if (ocols < 1)\n    ocols = 1;\n  if (orows < 1)\n    orows = 1;\n\n  /* If user did not specify rows and cols, set them from calcuation */\n  if (page->rows < 1)\n    page->rows = orows;\n  if (page->cols < 1)\n    page->cols = ocols;\n\n  line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp;\n\n  if ((page->rows * page->cols) > MAX_SECTIONS)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* build the list of offsets for each output section */\n  for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++)\n    {\n    y1 = (uint32)(olength * i);\n    y2 = (uint32)(olength * (i +  1) - 1);\n    if (y2 >= ilength)\n      y2 = ilength - 1;\n    for (j = 0; j < ocols; j++, k++)\n      {\n      x1 = (uint32)(owidth * j); \n      x2 = (uint32)(owidth * (j + 1) - 1);\n      if (x2 >= iwidth)\n        x2 = iwidth - 1;\n      sections[k].x1 = x1;\n      sections[k].x2 = x2;\n      sections[k].y1 = y1;\n      sections[k].y2 = y2;\n      sections[k].buffsize = line_bytes * olength;\n      sections[k].position = k + 1;\n      sections[k].total = orows * ocols;\n      } \n    } \n  return (0);\n  } /* end computeOutputPixelOffsets */\n\nstatic int\nloadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n\nstatic int  correct_orientation(struct image_data *image, unsigned char **work_buff_ptr)\n  {\n  uint16 mirror, rotation;\n  unsigned char *work_buff;\n\n  work_buff = *work_buff_ptr;\n  if ((image == NULL) || (work_buff == NULL))\n    {\n    TIFFError (\"correct_orientatin\", \"Invalid image or buffer pointer\");\n    return (-1);\n    }\n\n  if ((image->adjustments & MIRROR_HORIZ) || (image->adjustments & MIRROR_VERT))\n    {\n    mirror = (uint16)(image->adjustments & MIRROR_BOTH);\n    if (mirrorImage(image->spp, image->bps, mirror, \n        image->width, image->length, work_buff))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to mirror image\");\n      return (-1);\n      }\n    }\n\n  if (image->adjustments & ROTATE_ANY)\n    {\n    if (image->adjustments & ROTATECW_90)\n      rotation = (uint16) 90;\n    else\n    if (image->adjustments & ROTATECW_180)\n      rotation = (uint16) 180;\n    else\n    if (image->adjustments & ROTATECW_270)\n      rotation = (uint16) 270;\n    else\n      {\n      TIFFError (\"correct_orientation\", \"Invalid rotation value: %d\", \n                  image->adjustments & ROTATE_ANY);\n      return (-1);\n      }\n \n    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to rotate image\");\n      return (-1);\n      }\n    image->orientation = ORIENTATION_TOPLEFT;\n    }\n\n  return (0);\n  } /* end correct_orientation */\n\n\n/* Extract multiple zones from an image and combine into a single composite image */\nstatic int\nextractCompositeRegions(struct image_data *image,  struct crop_mask *crop, \n                        unsigned char *read_buff, unsigned char *crop_buff)\n  {\n  int       shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32    i, trailing_bits, prev_trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_rowsize, dst_rowsize, src_offset, dst_offset;\n  uint32    crop_width, crop_length, img_width /*, img_length */;\n  uint32    prev_length, prev_width, composite_width;\n  uint16    bps, spp;\n  uint8    *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract one or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src = read_buff;\n  dst = crop_buff;\n\n  /* These are setup for adding additional sections */\n  prev_width = prev_length = 0;\n  prev_trailing_bits = trailing_bits = 0;\n  composite_width = crop->combined_width;\n  crop->combined_width = 0;\n  crop->combined_length = 0;\n\n  for (i = 0; i < crop->selections; i++)\n    {\n    /* rows, columns, width, length are expressed in pixels */\n    first_row = crop->regionlist[i].y1;\n    last_row  = crop->regionlist[i].y2;\n    first_col = crop->regionlist[i].x1;\n    last_col  = crop->regionlist[i].x2;\n\n    crop_width = last_col - first_col + 1;\n    crop_length = last_row - first_row + 1;\n\n    /* These should not be needed for composite images */\n    crop->regionlist[i].width = crop_width;\n    crop->regionlist[i].length = crop_length;\n    crop->regionlist[i].buffptr = crop_buff;\n\n    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n    dst_rowsize = (((crop_width * bps * count) + 7) / 8);\n\n    switch (crop->edge_ref)\n      {\n      default:\n      case EDGE_TOP:\n      case EDGE_BOTTOM:\n\t   if ((i > 0) && (crop_width != crop->regionlist[i - 1].width))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal width regions can be combined for -E top or bottom\");\n\t     return (1);\n             }\n\n           crop->combined_width = crop_width;\n           crop->combined_length += crop_length;\n\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + (prev_length * dst_rowsize);\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                                      spp, bps, count, first_col,\n                                                      last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n             }\n           prev_length += crop_length;\n\t   break;\n      case EDGE_LEFT:  /* splice the pieces of each row together, side by side */\n      case EDGE_RIGHT:\n\t   if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal length regions can be combined for -E left or right\");\n\t     return (1);\n             }\n           crop->combined_width += crop_width;\n           crop->combined_length = crop_length;\n           dst_rowsize = (((composite_width * bps * count) + 7) / 8);\n           trailing_bits = (crop_width * bps * count) % 8;\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + prev_width;\n\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width,\n                                                      sample, spp, bps, count,\n                                                      first_col, last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n              case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n\t     }\n\t   prev_width += (crop_width * bps * count) / 8;\n           prev_trailing_bits += trailing_bits;\n           if (prev_trailing_bits > 7)\n\t     prev_trailing_bits-= 8;\n\t   break;\n      }\n    }\n  if (crop->combined_width != composite_width)\n    TIFFError(\"combineSeparateRegions\",\"Combined width does not match composite width\");\n      \n  return (0);\n  }  /* end extractCompositeRegions */\n\n/* Copy a single region of input buffer to an output buffer. \n * The read functions used copy separate plane data into a buffer \n * as interleaved samples rather than separate planes so the same\n * logic works to extract regions regardless of the way the data \n * are organized in the input file. This function can be used to\n * extract one or more samples from the input image by updating the \n * parameters for starting sample and number of samples to copy in the\n * fifth and eighth arguments of the call to extractContigSamples.\n * They would be passed as new elements of the crop_mask struct.\n */\n\nstatic int\nextractSeparateRegion(struct image_data *image,  struct crop_mask *crop,\n                      unsigned char *read_buff, unsigned char *crop_buff,\n                      int region)\n  {\n  int     shift_width, prev_trailing_bits = 0;\n  uint32  bytes_per_sample, bytes_per_pixel;\n  uint32  src_rowsize, dst_rowsize;\n  uint32  row, first_row, last_row, first_col, last_col;\n  uint32  src_offset, dst_offset;\n  uint32  crop_width, crop_length, img_width /*, img_length */;\n  uint16  bps, spp;\n  uint8  *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract more or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0; /* Byte aligned data only */\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = crop->regionlist[region].y1;\n  last_row  = crop->regionlist[region].y2;\n  first_col = crop->regionlist[region].x1;\n  last_col  = crop->regionlist[region].x2;\n\n  crop_width = last_col - first_col + 1;\n  crop_length = last_row - first_row + 1;\n\n  crop->regionlist[region].width = crop_width;\n  crop->regionlist[region].length = crop_length;\n  crop->regionlist[region].buffptr = crop_buff;\n\n  src = read_buff;\n  dst = crop_buff;\n  src_rowsize = ((img_width * bps * spp) + 7) / 8;\n  dst_rowsize = (((crop_width * bps * spp) + 7) / 8);\n\n  for (row = first_row; row <= last_row; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = (row  - first_row) * dst_rowsize;\n    src = read_buff + src_offset;\n    dst = crop_buff + dst_offset;\n\n    switch (shift_width)\n      {\n      case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                             spp, bps, count, first_col,\n                                             last_col + 1))\n                {\n\t        TIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t        return (1);\n\t        }\n\t      break;\n      case 1: if (bps == 1)\n                { \n                if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                      sample, spp, bps, count, \n                                                      first_col, last_col + 1,\n                                                      prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t\t  break;\n\t\t}\n              else\n                if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                       sample, spp, bps, count, \n                                                       first_col, last_col + 1,\n                                                       prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t      break;\n      case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      case 3:\n      case 4:\n      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      default: TIFFError(\"extractSeparateRegion\", \"Unsupported bit depth %d\", bps);\n\t       return (1);\n      }\n    }\n          \n  return (0);\n  }  /* end extractSeparateRegion */\n\nstatic int\nextractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n  /* unsigned  char *src, *dst; */\n#endif\n\n  uint32    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32    img_length;\n#endif\n  uint32    j, shift1, shift2, trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_offset, dst_offset, row_offset, col_offset;\n  uint32    offset1, offset2, full_bytes;\n  uint32    sect_width;\n#ifdef DEVELMODE\n  uint32    sect_length;\n#endif\n  uint16    bps, spp;\n\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n  static char *bitarray = NULL;\n#endif\n\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n\n#ifdef DEVELMODE\n  /* src = src_buff; */\n  /* dst = sect_buff; */\n#endif\n  src_offset = 0;\n  dst_offset = 0;\n\n#ifdef DEVELMODE\n  if (bitarray == NULL)\n    {\n    if ((bitarray = (char *)malloc(img_width)) == NULL)\n      {\n      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n      return (-1);\n      }\n    }\n#endif\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n  img_rowsize = ((img_width * bps + 7) / 8) * spp;\n  full_bytes = (sect_width * spp * bps) / 8;   /* number of COMPLETE bytes per row in section */\n  trailing_bits = (sect_width * bps) % 8;\n\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\n\t   img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n\n  if ((bps % 8) == 0)\n    {\n    col_offset = first_col * spp * bps / 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* row_offset = row * img_width * spp * bps / 8; */\n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { /* bps != 8 */\n    shift1  = spp * ((first_col * bps) % 8);\n    shift2  = spp * ((last_col * bps) % 8);\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* pull out the first byte */\n      row_offset = row * img_rowsize;\n      offset1 = row_offset + (first_col * bps / 8);\n      offset2 = row_offset + (last_col * bps / 8);\n\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\", \n                 row, offset1, shift1, offset2, shift2); \n#endif\n\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) /* the region is byte and sample alligned */\n        {\n\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n\n#ifdef DEVELMODE\n\tTIFFError (\"\", \"        Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n\t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\", \n                              offset2, dst_offset); \n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   /* each destination byte will have to be built from two source bytes*/\n        {\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); \n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n\t  bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n\t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); \n#endif\n\t  if (shift2 > shift1)\n            {\n\t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n            sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Shift2 > Shift1\\n\"); \n#endif\n            }\n          else\n            {\n\t    if (shift2 < shift1)\n              {\n              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n\t      sect_buff[dst_offset] &= bytebuff2;\n#ifdef DEVELMODE\n\t      TIFFError (\"\", \"        Shift2 < Shift1\\n\"); \n#endif\n              }\n#ifdef DEVELMODE\n            else\n\t      TIFFError (\"\", \"        Shift2 == Shift1\\n\"); \n#endif\n            }\n\t  }\n#ifdef DEVELMODE\n\t  sprintf(&bitarray[28], \" \");\n\t  sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n\n  return (0);\n  } /* end extractImageSection */\n\nstatic int \nwriteSelections(TIFF *in, TIFF **out, struct crop_mask *crop, \n                struct image_data *image, struct dump_opts *dump,\n                struct buffinfo seg_buffs[], char *mp, char *filename, \n                unsigned int *page, unsigned int total_pages)\n  {\n  int i, page_count;\n  int autoindex = 0;\n  unsigned char *crop_buff = NULL;\n\n  /* Where we open a new file depends on the export mode */  \n  switch (crop->exp_mode)\n    {\n    case ONE_FILE_COMPOSITE: /* Regions combined into single image */\n         autoindex = 0;\n         crop_buff = seg_buffs[0].buffer;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = total_pages;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length,\n                               crop_buff, *page, total_pages))\n            {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t break;\n    case ONE_FILE_SEPARATED: /* Regions as separated images */\n         autoindex = 0;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = crop->selections * total_pages;\n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t   }\n         break;\n    case FILE_PER_IMAGE_COMPOSITE: /* Regions as composite image */\n         autoindex = 1;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n\n         crop_buff = seg_buffs[0].buffer;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length, \n                               crop_buff, *page, total_pages))\n           {\n           TIFFError(\"writeRegions\", \"Unable to write new image\");\n           return (-1);\n           }\n         break;\n    case FILE_PER_IMAGE_SEPARATED: /* Regions as separated images */\n         autoindex = 1;\n         page_count = crop->selections;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n                \n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n         break;\n    case FILE_PER_SELECTION:\n         autoindex = 1;\n\t page_count = 1;\n         for (i = 0; i < crop->selections; i++)\n           {\n           if (update_output_file (out, mp, autoindex, filename, page))\n             return (1);\n\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n\t break;\n    default: return (1);\n    }\n\n  return (0);\n  } /* end writeRegions */\n\nstatic int\nwriteImageSections(TIFF *in, TIFF *out, struct image_data *image,\n\t\t   struct pagedef *page, struct pageseg *sections,\n\t\t   struct dump_opts * dump, unsigned char *src_buff,\n                   unsigned char **sect_buff_ptr)\n  {\n  double  hres, vres;\n  uint32  i, k, width, length, sectsize;\n  unsigned char *sect_buff = *sect_buff_ptr;\n\n  hres = page->hres;\n  vres = page->vres;\n\n  k = page->cols * page->rows;\n  if ((k < 1) || (k > MAX_SECTIONS))\n   {\n   TIFFError(\"writeImageSections\",\n\t     \"%d Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);\n   return (-1);\n   }\n\n  for (i = 0; i < k; i++)\n    {\n    width  = sections[i].x2 - sections[i].x1 + 1;\n    length = sections[i].y2 - sections[i].y1 + 1;\n    sectsize = (uint32)\n\t    ceil((width * image->bps + 7) / (double)8) * image->spp * length;\n    /* allocate a buffer if we don't have one already */\n    if (createImageSection(sectsize, sect_buff_ptr))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\");\n      exit (-1);\n      }\n    sect_buff = *sect_buff_ptr;\n\n    if (extractImageSection (image, &sections[i], src_buff, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to extract image sections\");\n      exit (-1);\n      }\n\n  /* call the write routine here instead of outside the loop */\n    if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to write image section\");\n      exit (-1);\n      }\n    }\n\n  return (0);\n  } /* end writeImageSections */\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n */\nstatic int  \nwriteSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n                   struct dump_opts *dump, uint32 width, uint32 length,\n                   double hres, double vres,\n                   unsigned char *sect_buff)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  /*  Calling this seems to reset the compression mode on the TIFF *in file.\n  TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);\n  */\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n\n  spp = image->spp;\n  bps = image->bps;\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n  /* This is the global variable compression which is set \n   * if the user has specified a command line option for \n   * a compression option.  Should be passed around in one\n   * of the parameters instead of as a global. If no user\n   * option specified it will still be (uint16) -1. */\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    { /* OJPEG is no longer supported for writing so upgrade to JPEG */\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else /* Use the compression from the input file */\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* holdout mask */\n      {\n      TIFFError (\"writeSingleSection\",\n                 \"JPEG compression cannot be used with %s image data\",\n\t\t (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n    else\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n    }\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input photometric: %s\",\n\t    (input_photometric == PHOTOMETRIC_RGB) ? \"RGB\" :\n\t    ((input_photometric == PHOTOMETRIC_YCBCR) ?  \"YCbCr\" : \"Not RGB or YCbCr\"));\n#endif\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeSingleSection\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard.\n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    /* These are references to GLOBAL variables set by defaults\n     * and /or the compression flag\n     */\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeSingleSection\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\tbreak;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     if (pageNum < 0) /* only one input file */\n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n     else \n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Update these since they are overwritten from input res by loop above */\n  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);\n  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);\n    else\n      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigStrips (out, sect_buff, length);\n    else\n      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeSingleSection */\n\n\n/* Create a buffer to write one section at a time */\nstatic int\ncreateImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n    *sect_buff_ptr = sect_buff;\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n\tfree (sect_buff);\n        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  if (!sect_buff)\n    {\n    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n    return (-1);\n    }\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }  /* end createImageSection */\n\n\n/* Process selections defined by regions, zones, margins, or fixed sized areas */\nstatic int\nprocessCropSelections(struct image_data *image, struct crop_mask *crop, \n                      unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n  {\n  int       i;\n  uint32    width, length, total_width, total_length;\n  tsize_t   cropsize;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *next_buff = NULL;\n  tsize_t   prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  if (crop->img_mode == COMPOSITE_IMAGES)\n    {\n    cropsize = crop->bufftotal;\n    crop_buff = seg_buffs[0].buffer; \n    if (!crop_buff)\n      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    else\n      {\n      prev_cropsize = seg_buffs[0].size;\n      if (prev_cropsize < cropsize)\n        {\n        next_buff = _TIFFrealloc(crop_buff, cropsize);\n        if (! next_buff)\n          {\n          _TIFFfree (crop_buff);\n          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n          }\n        else\n          crop_buff = next_buff;\n        }\n      }\n\n    if (!crop_buff)\n      {\n      TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n      return (-1);\n      }\n \n    _TIFFmemset(crop_buff, 0, cropsize);\n    seg_buffs[0].buffer = crop_buff;\n    seg_buffs[0].size = cropsize;\n\n    /* Checks for matching width or length as required */\n    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n      return (1);\n\n    if (crop->crop_mode & CROP_INVERT)\n      {\n      switch (crop->photometric)\n        {\n        /* Just change the interpretation */\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n\t     image->photometric = crop->photometric;\n\t     break;\n        case INVERT_DATA_ONLY:\n        case INVERT_DATA_AND_TAG:\n             if (invertImage(image->photometric, image->spp, image->bps, \n                             crop->combined_width, crop->combined_length, crop_buff))\n               {\n               TIFFError(\"processCropSelections\", \n                         \"Failed to invert colorspace for composite regions\");\n               return (-1);\n               }\n             if (crop->photometric == INVERT_DATA_AND_TAG)\n               {\n               switch (image->photometric)\n                 {\n                 case PHOTOMETRIC_MINISWHITE:\n \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n\t              break;\n                 case PHOTOMETRIC_MINISBLACK:\n \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n\t              break;\n                 default:\n\t              break;\n\t         }\n\t       }\n             break;\n        default: break;\n        }\n      }\n\n    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n    if (crop->crop_mode & CROP_MIRROR)\n      {\n      if (mirrorImage(image->spp, image->bps, crop->mirror, \n                      crop->combined_width, crop->combined_length, crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\", \n\t         (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n        return (-1);\n        }\n      }\n\n    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n      {\n      if (rotateImage(crop->rotation, image, &crop->combined_width, \n                      &crop->combined_length, &crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \n                  \"Failed to rotate composite regions by %d degrees\", crop->rotation);\n        return (-1);\n        }\n      seg_buffs[0].buffer = crop_buff;\n      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n                            * image->spp) * crop->combined_length; \n      }\n    }\n  else  /* Separated Images */\n    {\n    total_width = total_length = 0;\n    for (i = 0; i < crop->selections; i++)\n      {\n      cropsize = crop->bufftotal;\n      crop_buff = seg_buffs[i].buffer; \n      if (!crop_buff)\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n      else\n        {\n        prev_cropsize = seg_buffs[0].size;\n        if (prev_cropsize < cropsize)\n          {\n          next_buff = _TIFFrealloc(crop_buff, cropsize);\n          if (! next_buff)\n            {\n            _TIFFfree (crop_buff);\n            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n            }\n          else\n            crop_buff = next_buff;\n          }\n        }\n\n      if (!crop_buff)\n        {\n        TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n        }\n \n      _TIFFmemset(crop_buff, 0, cropsize);\n      seg_buffs[i].buffer = crop_buff;\n      seg_buffs[i].size = cropsize;\n\n      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n        {\n\tTIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i);\n        return (-1);\n        }\n    \n      width  = crop->regionlist[i].width;\n      length = crop->regionlist[i].length;\n\n      if (crop->crop_mode & CROP_INVERT)\n        {\n        switch (crop->photometric)\n          {\n          /* Just change the interpretation */\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n\t       image->photometric = crop->photometric;\n\t       break;\n          case INVERT_DATA_ONLY:\n          case INVERT_DATA_AND_TAG:\n               if (invertImage(image->photometric, image->spp, image->bps, \n                               width, length, crop_buff))\n                 {\n                 TIFFError(\"processCropSelections\", \n                           \"Failed to invert colorspace for region\");\n                 return (-1);\n                 }\n               if (crop->photometric == INVERT_DATA_AND_TAG)\n                 {\n                 switch (image->photometric)\n                   {\n                   case PHOTOMETRIC_MINISWHITE:\n \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n\t                break;\n                   case PHOTOMETRIC_MINISBLACK:\n \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n\t                break;\n                   default:\n\t                break;\n\t           }\n\t         }\n               break;\n          default: break;\n          }\n        }\n\n      if (crop->crop_mode & CROP_MIRROR)\n        {\n        if (mirrorImage(image->spp, image->bps, crop->mirror, \n                        width, length, crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\", \n\t           (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n          return (-1);\n          }\n        }\n\n      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n        {\n\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n\t\t\t&crop->regionlist[i].length, &crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \n                    \"Failed to rotate crop region by %d degrees\", crop->rotation);\n          return (-1);\n          }\n        total_width  += crop->regionlist[i].width;\n        total_length += crop->regionlist[i].length;\n        crop->combined_width = total_width;\n        crop->combined_length = total_length;\n        seg_buffs[i].buffer = crop_buff;\n        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n                               * image->spp) * crop->regionlist[i].length; \n        }\n      }\n    }\n  return (0);\n  } /* end processCropSelections */\n\n/* Copy the crop section of the data from the current image into a buffer\n * and adjust the IFD values to reflect the new size. If no cropping is\n * required, use the origial read buffer as the crop buffer.\n *\n * There is quite a bit of redundancy between this routine and the more\n * specialized processCropSelections, but this provides\n * the most optimized path when no Zones or Regions are required.\n */\nstatic int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %d degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  } /* end createCroppedImage */\n\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n * Use of global variables for config, compression and others\n * should be replaced by addition to the crop_mask struct (which\n * will be renamed to proc_opts indicating that is controlls\n * user supplied processing options, not just cropping) and \n * then passed in as an argument.\n */\nstatic int  \nwriteCroppedImage(TIFF *in, TIFF *out, struct image_data *image, \n                  struct dump_opts *dump, uint32 width, uint32 length, \n                  unsigned char *crop_buff, int pagenum, int total_pages)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n  spp = image->spp;\n  bps = image->bps;\n\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeCroppedImage\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    {\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */\n      {\n      TIFFError (\"writeCroppedImage\",\n                 \"JPEG compression cannot be used with %s image data\",\n      \t        (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      {\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n      }\n    else\n      {\n      if (input_compression == COMPRESSION_SGILOG ||\n          input_compression == COMPRESSION_SGILOG24)\n        {\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\t  PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n        }\n      else\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n      }\n    }\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeCroppedImage\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard. \n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\t\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeCroppedImage\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n        if (bps != 1)\n          {\n\t  TIFFError(\"writeCroppedImage\",\n            \"Group 3/4 compression is not usable with bps > 1\");\n          return (-1);\n\t  }\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n        break;\n    case COMPRESSION_NONE:\n         break;\n    default: break;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write contiguous tile data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate tile data for page %d\", pagenum);\n      }\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigStrips (out, crop_buff, length))\n        TIFFError(\"\",\"Unable to write contiguous strip data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate strip data for page %d\", pagenum);\n      }\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFError(\"\",\"Failed to write IFD for page number %d\", pagenum);\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeCroppedImage */\n\nstatic int\nrotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   row, rowsize = 0, bit_offset = 0;\n  uint8    matchbits = 0, maskbits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n\n  for (row = 0; row < length ; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*next) & matchbits) << (src_bit);\n\n       /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        {\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples8bits */\n\n\nstatic int\nrotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint16   matchbits = 0, maskbits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint16)-1 >> (16 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (next[0] << 8) | next[1];\n      else\n        buff1 = (next[1] << 8) | next[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples16bits */\n\nstatic int\nrotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   matchbits = 0, maskbits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> (32 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n      else\n\tbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 16)\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  }  /* end rotateContigSamples24bits */\n\nstatic int\nrotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 row, rowsize, bit_offset;\n  uint32 src_byte, src_bit;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> (64 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n        longbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end rotateContigSamples32bits */\n\n\n/* Rotate an image by a multiple of 90 degrees clockwise */\nstatic int\nrotateImage(uint16 rotation, struct image_data *image, uint32 *img_width, \n            uint32 *img_length, unsigned char **ibuff_ptr)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, src_offset, dst_offset;\n  uint32   i, col, width, length;\n  uint32   colsize, buffsize, col_offset, pix_offset;\n  unsigned char *ibuff;\n  unsigned char *src;\n  unsigned char *dst;\n  uint16   spp, bps;\n  float    res_temp;\n  unsigned char *rbuff = NULL;\n\n  width  = *img_width;\n  length = *img_length;\n  spp = image->spp;\n  bps = image->bps;\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  colsize = ((bps * spp * length) + 7) / 8;\n  if ((colsize * width) > (rowsize * length))\n    buffsize = (colsize + 1) * width;\n  else\n    buffsize = (rowsize + 1) * length;\n\n  bytes_per_sample = (bps + 7) / 8;\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  switch (rotation)\n    {\n    case 0:\n    case 360: return (0);\n    case 90:\n    case 180:\n    case 270: break;\n    default:  TIFFError(\"rotateImage\", \"Invalid rotation angle %d\", rotation);\n              return (-1);\n    }\n\n  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize)))\n    {\n    TIFFError(\"rotateImage\", \"Unable to allocate rotation buffer of %1u bytes\", buffsize);\n    return (-1);\n    }\n  _TIFFmemset(rbuff, '\\0', buffsize);\n\n  ibuff = *ibuff_ptr;\n  switch (rotation)\n    {\n    case 180: if ((bps % 8) == 0) /* byte alligned data */\n                { \n                src = ibuff;\n                pix_offset = (spp * bps) / 8;\n                for (row = 0; row < length; row++)\n                   {\n\t\t   dst_offset = (length - row - 1) * rowsize;\n                   for (col = 0; col < width; col++)\n                     { \n\t\t     col_offset = (width - col - 1) * pix_offset;\n                     dst = rbuff + dst_offset + col_offset;\n\n\t\t     for (i = 0; i  < bytes_per_pixel; i++)\n\t\t       *dst++ = *src++;\n                     }\n                   }\n                }\n\t      else\n                { /* non 8 bit per sample data */ \n                for (row = 0; row < length; row++)\n                  {\n\t\t  src_offset = row * rowsize;\n\t\t  dst_offset = (length - row - 1) * rowsize;\n\t\t  src = ibuff + src_offset;\n                  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (reverseSamples8bits(spp, bps, width, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (reverseSamples16bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n                    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n              break;\n\n    case 90:  if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel);\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src -= rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = (length - 1) * rowsize;\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n\t      break;\n\n    case 270: if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = col * bytes_per_pixel;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src += rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = 0;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n              break;\n    default:\n              break;\n    }\n\n  return (0);\n  } /* end rotateImage */\n\nstatic int\nreverseSamples8bits (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte, src_bit;\n  uint32   bit_offset = 0;\n  uint8    match_bits = 0, mask_bits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples8bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint8)-1 >> ( 8 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (8 - src_bit - bps); \n      buff1 = ((*src) & match_bits) << (src_bit);\n\n      if (ready_bits < 8)\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      ready_bits += bps;\n      }\n    }\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  } /* end reverseSamples8bits */\n\n\nstatic int\nreverseSamples16bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint16   match_bits = 0, mask_bits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint16)-1 >> (16 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (16 - high_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n      \n      if (ready_bits < 8)\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  } /* end reverseSamples16bits */\n\nstatic int\nreverseSamples24bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint32   match_bits = 0, mask_bits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples24bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint32)-1 >> (32 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (32 - high_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n\n      if (ready_bits < 16)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  } /* end reverseSamples24bits */\n\n\nstatic int\nreverseSamples32bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 bit_offset;\n  uint32 src_byte = 0, high_bit = 0;\n  uint32 col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 mask_bits = 0, match_bits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples32bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint64)-1 >> (64 - bps);\n  dst = obuff;\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (64 - high_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n        longbuff2 = longbuff1;\n\t}\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & match_bits) << (high_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end reverseSamples32bits */\n\nstatic int\nreverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  /* Use memcpy for multiple bytes per sample data */\n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: /* Use byte copy only for single byte per sample data */\n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } /* end reverseSamplesBytes */\n\n\n/* Mirror an image horizontally or vertically */\nstatic int\nmirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, row_offset;\n  unsigned char *line_buff = NULL;\n  unsigned char *src;\n  unsigned char *dst;\n\n  src = ibuff;\n  rowsize = ((width * bps * spp) + 7) / 8;\n  switch (mirror)\n    {\n    case MIRROR_BOTH:\n    case MIRROR_VERT: \n             line_buff = (unsigned char *)_TIFFmalloc(rowsize);\n             if (line_buff == NULL)\n               {\n\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);\n               return (-1);\n               }\n\n             dst = ibuff + (rowsize * (length - 1));\n             for (row = 0; row < length / 2; row++)\n               {\n\t      _TIFFmemcpy(line_buff, src, rowsize);\n\t      _TIFFmemcpy(src, dst,  rowsize);\n\t      _TIFFmemcpy(dst, line_buff, rowsize);\n               src += (rowsize);\n               dst -= (rowsize);                                 \n               }\n             if (line_buff)\n               _TIFFfree(line_buff);\n             if (mirror == MIRROR_VERT)\n               break;\n    case MIRROR_HORIZ :\n              if ((bps % 8) == 0) /* byte alligned data */\n                { \n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  dst = ibuff + row_offset + rowsize;\n                  if (reverseSamplesBytes(spp, bps, width, src, dst))\n                    {\n\t\t    return (-1);\n                    }\n\t\t  }\n\t\t}\n\t      else\n                { /* non 8 bit per sample  data */\n                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1)))\n                  {\n                  TIFFError(\"mirrorImage\", \"Unable to allocate mirror line buffer\");\n                  return (-1);\n                  }\n                bytes_per_sample = (bps + 7) / 8;\n                bytes_per_pixel  = ((bps * spp) + 7) / 8;\n                if (bytes_per_pixel < (bytes_per_sample + 1))\n                  shift_width = bytes_per_pixel;\n                else\n                  shift_width = bytes_per_sample + 1;\n\n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  _TIFFmemset (line_buff, '\\0', rowsize);\n                  switch (shift_width)\n                    {\n                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    default: TIFFError(\"mirrorImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(line_buff);\n                             return (-1);      \n                    }\n\t\t  }\n                if (line_buff)\n                  _TIFFfree(line_buff);\n\t\t}\n             break;\n\n    default: TIFFError (\"mirrorImage\", \"Invalid mirror axis %d\", mirror);\n             return (-1);\n             break;\n    }\n\n  return (0);\n  }\n\n/* Invert the light and dark values for a bilevel or grayscale image */\nstatic int\ninvertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff)\n  {\n  uint32   row, col;\n  unsigned char  bytebuff1, bytebuff2, bytebuff3, bytebuff4;\n  unsigned char *src;\n  uint16        *src_uint16;\n  uint32        *src_uint32;\n\n  if (spp != 1)\n    {\n    TIFFError(\"invertImage\", \"Image inversion not supported for more than one sample per pixel\");\n    return (-1);\n    }\n\n  if (photometric !=  PHOTOMETRIC_MINISWHITE && photometric !=  PHOTOMETRIC_MINISBLACK)\n    {\n    TIFFError(\"invertImage\", \"Only black and white and grayscale images can be inverted\");\n    return (-1);\n    }\n\n  src = work_buff;\n  if (src == NULL)\n    {\n    TIFFError (\"invertImage\", \"Invalid crop buffer passed to invertImage\");\n    return (-1);\n    }\n\n  switch (bps)\n    {\n    case 32: src_uint32 = (uint32 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32;\n                  src_uint32++;\n                 }\n            break;\n    case 16: src_uint16 = (uint16 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint16 = (uint16)0xFFFF - *src_uint16;\n                  src_uint16++;\n                 }\n            break;\n    case 8: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\t*src = (uint8)255 - *src;\n                 src++;\n                }\n            break;\n    case 4: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\tbytebuff1 = 16 - (uint8)(*src & 240 >> 4);\n\t\tbytebuff2 = 16 - (*src & 15);\n\t\t*src = bytebuff1 << 4 & bytebuff2;\n                src++;\n                }\n            break;\n    case 2: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\tbytebuff1 = 4 - (uint8)(*src & 192 >> 6);\n\t\tbytebuff2 = 4 - (uint8)(*src & 48  >> 4);\n\t\tbytebuff3 = 4 - (uint8)(*src & 12  >> 2);\n\t\tbytebuff4 = 4 - (uint8)(*src & 3);\n\t\t*src = (bytebuff1 << 6) || (bytebuff2 << 4) || (bytebuff3 << 2) || bytebuff4;\n                src++;\n                }\n            break;\n    case 1: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col += 8 /(spp * bps))\n                {\n                *src = ~(*src);\n                src++;\n                }\n            break;\n    default: TIFFError(\"invertImage\", \"Unsupported bit depth %d\", bps);\n      return (-1);\n    }\n\n  return (0);\n  }\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n"], "fixing_code": ["2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix readContigStripsIntoBuffer() in -i (ignore) mode so\n\tthat the output buffer is correctly incremented to avoid write outside bounds.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2620\n\n2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_ojpeg.c: make OJPEGDecode() early exit in case of failure in\n\tOJPEGPreDecode(). This will avoid a divide by zero, and potential other issues.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2611\n\n2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to\n\tinstanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),\n\tinstead of a logic based on the total size of data. Which is faulty is\n\tthe total size of data is not sufficient to fill the whole image, and thus\n\tresults in reading outside of the StripByCounts/StripOffsets arrays when\n\tusing TIFFReadScanline().\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2608.\n\n\t* libtiff/tif_strip.c: revert the change in TIFFNumberOfStrips() done\n\tfor http://bugzilla.maptools.org/show_bug.cgi?id=2587 / CVE-2016-9273 since\n\tthe above change is a better fix that makes it unnecessary.\n\n2016-12-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c, libtiff/tif_luv.c: fix heap-based buffer\n\toverflow on generation of PixarLog / LUV compressed files, with\n\tColorMap, TransferFunction attached and nasty plays with bitspersample.\n\tThe fix for LUV has not been tested, but suffers from the same kind\n\tof issue of PixarLog.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2604\n\n2016-12-02 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that \n\tcan cause various issues, such as buffer overflows in the library.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2598\n\n2016-12-02 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c, libtiff/tiffiop.h: fix uint32 overflow in\n\tTIFFReadEncodedStrip() that caused an integer division by zero.\n\tReported by Agostino Sarubbo.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2596\n\n2016-11-20 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_getimage.c, libtiff/tif_open.c: add parenthesis to\n\tfix cppcheck clarifyCalculation warnings\n\t* libtiff/tif_predict.c, libtiff/tif_print.c: fix printf unsigned\n\tvs signed formatting (cppcheck invalidPrintfArgType_uint warnings)\n\n2016-11-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/fax2tiff.c (main): Applied patch by J\u00f6rg Ahrens to fix\n\tpassing client data for Win32 builds using tif_win32.c\n\t(USE_WIN32_FILEIO defined) for file I/O.  Patch was provided via\n\temail on November 20, 2016.\n\n2016-11-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.7 released.\n\n\t* configure.ac: Update for 4.0.7 release.\n\n\t* tools/tiffdump.c (ReadDirectory): Remove uint32 cast to\n\t_TIFFmalloc() argument which resulted in Coverity report.  Added\n\tmore mutiplication overflow checks.\n\n2016-11-18 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Fix memory leak in (recent) error code path.\n\tFixes Coverity 1394415.\n\n2016-11-17  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c: Fix some benign warnings which appear in\n\t64-bit compilation under Microsoft Visual Studio of the form\n\t\"Arithmetic overflow: 32-bit value is shifted, then cast to 64-bit\n\tvalue.  Results might not be an expected value.\".  Problem was\n\treported on November 16, 2016 on the tiff mailing list.\n\n2016-11-16 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), do not dereference\n\tNULL pointer when values of tags with TIFF_SETGET_C16_ASCII / TIFF_SETGET_C32_ASCII\n\taccess are 0-byte arrays.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2593 (regression introduced\n\tby previous fix done on 2016-11-11 for CVE-2016-9297).\n\tReported by Henri Salo. Assigned as CVE-2016-9448\n\n2016-11-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffinfo.c (TIFFReadContigTileData): Fix signed/unsigned\n\tcomparison warning.\n\t(TIFFReadSeparateTileData): Fix signed/unsigned comparison\n\twarning.\n\n\t* tools/tiffcrop.c (readContigTilesIntoBuffer): Fix\n\tsigned/unsigned comparison warning.\n\n\t* html/v4.0.7.html: Add a file to document the pending 4.0.7\n\trelease.\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: avoid undefined behaviour related to overlapping\n\tof source and destination buffer in memcpy() call in\n\tt2p_sample_rgbaa_to_rgb()\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2577\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix potential integer overflows on 32 bit builds\n\tin t2p_read_tiff_size()\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2576\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_aux.c: fix crash in TIFFVGetFieldDefaulted()\n\twhen requesting Predictor tag and that the zip/lzw codec is not\n\tconfigured.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2591\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make sure that\n\tvalues of tags with TIFF_SETGET_C16_ASCII / TIFF_SETGET_C32_ASCII\n\taccess are null terminated, to avoid potential read outside buffer\n\tin _TIFFPrintField().\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2590 (CVE-2016-9297)\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: reject images with OJPEG compression that\n\thave no TileOffsets/StripOffsets tag, when OJPEG compression is\n\tdisabled. Prevent null pointer dereference in TIFFReadRawStrip1()\n\tand other functions that expect td_stripbytecount to be non NULL.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2585\n\n2016-11-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix multiple uint32 overflows in\n\twriteBufferToSeparateStrips(), writeBufferToContigTiles() and\n\twriteBufferToSeparateTiles() that could cause heap buffer overflows.\n\tReported by Henri Salo from Nixu Corporation.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2592 (CVE-2016-9532)\n\n2016-11-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_strip.c: make TIFFNumberOfStrips() return the td->td_nstrips\n\tvalue when it is non-zero, instead of recomputing it. This is needed in\n\tTIFF_STRIPCHOP mode where td_nstrips is modified. Fixes a read outsize of\n\tarray in tiffsplit (or other utilities using TIFFNumberOfStrips()).\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2587 (CVE-2016-9273)\n\n2016-11-04 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predic.c: fix memory leaks in error code paths added in\n\tprevious commit (fix for MSVR 35105)\n\n2016-10-31 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.h, libtiff/tif_predict.c:\n\tReplace assertions by runtime checks to avoid assertions in debug mode,\n\tor buffer overflows in release mode. Can happen when dealing with\n\tunusual tile size like YCbCr with subsampling. Reported as MSVR 35105\n\tby Axel Souchet\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations\n\tteam.\n\n2016-10-26 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/fax2tiff.c: fix segfault when specifying -r without\n\targument. Patch by Yuriy M. Kaminskiy.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2572\n\n2016-10-25 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c: discard values of SMinSampleValue and\n\tSMaxSampleValue when they have been read and the value of\n\tSamplesPerPixel is changed afterwards (like when reading a\n\tOJPEG compressed image with a missing SamplesPerPixel tag,\n\tand whose photometric is RGB or YCbCr, forcing SamplesPerPixel\n\tbeing 3). Otherwise when rewriting the directory (for example\n\twith tiffset, we will expect 3 values whereas the array had been\n\tallocated with just one), thus causing a out of bound read access.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2500\n\t(CVE-2014-8127, duplicate: CVE-2016-3658)\n\t\n\t* libtiff/tif_dirwrite.c: avoid null pointer dereference on td_stripoffset\n\twhen writing directory, if FIELD_STRIPOFFSETS was artificially set\n\tfor a hack case\tin OJPEG case.\n\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2500\n\t(CVE-2014-8127, duplicate: CVE-2016-3658)\n\n2016-10-25 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffinfo.c: fix out-of-bound read on some tiled images.\n\t(http://bugzilla.maptools.org/show_bug.cgi?id=2517)\n\n\t* libtiff/tif_compress.c: make TIFFNoDecode() return 0 to indicate an\n\terror and make upper level read routines treat it accordingly.\n\t(linked to the test case of http://bugzilla.maptools.org/show_bug.cgi?id=2517)\n\n2016-10-14 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix out-of-bound read of up to 3 bytes in\n\treadContigTilesIntoBuffer(). Reported as MSVR 35092 by Axel Souchet\n\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations team.\n\n2016-10-09 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix write buffer overflow of 2 bytes on JPEG\n\tcompressed images. Reported by Tyler Bohan of Cisco Talos as\n\tTALOS-CAN-0187 / CVE-2016-5652.\n\tAlso prevents writing 2 extra uninitialized bytes to the file stream.\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: fix out-of-bounds write on tiled images with odd\n\ttile width vs image width. Reported as MSVR 35103\n\tby Axel Souchet and Vishal Chauhan from the MSRC Vulnerabilities &\n\tMitigations team.\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2pdf.c: fix read -largely- outsize of buffer in\n\tt2p_readwrite_pdf_image_tile(), causing crash, when reading a\n\tJPEG compressed image with TIFFTAG_JPEGTABLES length being one.\n\tReported as MSVR 35101 by Axel Souchet and Vishal Chauhan from\n\tthe MSRC Vulnerabilities & Mitigations team. CVE-2016-9453\n\n2016-10-08 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcp.c: fix read of undefined variable in case of missing\n\trequired tags. Found on test case of MSVR 35100.\n\t* tools/tiffcrop.c: fix read of undefined buffer in\n\treadContigStripsIntoBuffer() due to uint16 overflow. Probably not a\n\tsecurity issue but I can be wrong. Reported as MSVR 35100 by Axel\n\tSouchet from the MSRC Vulnerabilities & Mitigations team.\n\n2016-09-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html: Change as many remotesensing.org broken links to a working\n\tURL as possible.\n\n2016-09-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c (TIFFRGBAImageOK): Reject attempts to\n\tread floating point images.\n\n\t* libtiff/tif_predict.c (PredictorSetup): Enforce bits-per-sample\n\trequirements of floating point predictor (3).  Fixes CVE-2016-3622\n\t\"Divide By Zero in the tiff2rgba tool.\"\n\n2016-09-23 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix various out-of-bounds write vulnerabilities\n\tin heap or stack allocated buffers. Reported as MSVR 35093,\n\tMSVR 35096 and MSVR 35097. Discovered by Axel Souchet and Vishal\n\tChauhan from the MSRC Vulnerabilities & Mitigations team.\n\t* tools/tiff2pdf.c: fix out-of-bounds write vulnerabilities in\n\theap allocate buffer in t2p_process_jpeg_strip(). Reported as MSVR\n\t35098. Discovered by Axel Souchet and Vishal Chauhan from the MSRC\n\tVulnerabilities & Mitigations team.\n\t* libtiff/tif_pixarlog.c: fix out-of-bounds write vulnerabilities\n\tin heap allocated buffers. Reported as MSVR 35094. Discovered by\n\tAxel Souchet and Vishal Chauhan from the MSRC Vulnerabilities &\n\tMitigations team.\n\t* libtiff/tif_write.c: fix issue in error code path of TIFFFlushData1()\n\tthat didn't reset the tif_rawcc and tif_rawcp members. I'm not\n\tcompletely sure if that could happen in practice outside of the odd\n\tbehaviour of t2p_seekproc() of tiff2pdf). The report points that a\n\tbetter fix could be to check the return value of TIFFFlushData1() in\n\tplaces where it isn't done currently, but it seems this patch is enough.\n\tReported as MSVR 35095. Discovered by Axel Souchet & Vishal Chauhan &\n\tSuha Can from the MSRC Vulnerabilities & Mitigations team.\n\n2016-09-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/man/index.html: Comment out links to documentation for\n\tabandoned utilities.\n\n2016-09-17 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_lzma.c: typo fix in comment\n\n2016-09-04 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix warnings raised by clang 3.9 -Wcomma\n\n2016-09-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirwrite.c, libtiff/tif_color.c: fix warnings raised\n\tby GCC 5 / clang -Wfloat-conversion\n\n2016-08-16 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: fix C99'ism.\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2bw.c: fix weight computation that could result of color\n\tvalue overflow (no security implication). Fix bugzilla #2550.\n\tPatch by Frank Freudenberg.\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/rgb2ycbcr.c: validate values of -v and -h parameters to\n\tavoid potential divide by zero. Fixes CVE-2016-3623 (bugzilla #2569)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Fix out-of-bounds write in loadImage().\n\tFrom patch libtiff-CVE-2016-3991.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro (bugzilla #2543)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: Fix write buffer overflow in PixarLogEncode\n\tif more input samples are provided than expected by PixarLogSetupEncode.\n\tIdea based on libtiff-CVE-2016-3990.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro, but with different and\n\tsimpler check. (bugzilla #2544)\n\n2016-08-15 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiff2rgba.c: Fix integer overflow in size of allocated\n\tbuffer, when -b mode is enabled, that could result in out-of-bounds\n\twrite. Based initially on patch tiff-CVE-2016-3945.patch from\n\tlibtiff-4.0.3-25.el7_2.src.rpm by Nikola Forro, with correction for\n\tinvalid tests that rejected valid files. (bugzilla #2545)\n\n2016-07-11 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffcrop.c: Avoid access outside of stack allocated array\n\ton a tiled separate TIFF with more than 8 samples per pixel.\n\tReported by Kaixiang Zhang of the Cloud Security Team, Qihoo 360\n\t(CVE-2016-5321 / CVE-2016-5323 , bugzilla #2558 / #2559)\n\n2016-07-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c: Fix out-of-bounds read on\n\tmemory-mapped files in TIFFReadRawStrip1() and TIFFReadRawTile1()\n\twhen stripoffset is beyond tmsize_t max value (reported by\n\tMathias Svensson)\n\n2016-07-10 Even Rouault <even.rouault at spatialys.com>\n\n\t* tools/tiffdump.c: fix a few misaligned 64-bit reads warned\n\tby -fsanitize\n\n2016-07-03 Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c: make TIFFReadEncodedStrip() and\n\tTIFFReadEncodedTile() directly use user provided buffer when\n\tno compression (and other conditions) to save a memcpy().\n\n\t* libtiff/tif_write.c: make TIFFWriteEncodedStrip() and\n\tTIFFWriteEncodedTile() directly use user provided buffer when\n\tno compression to save a memcpy().\n\n2016-07-01  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_luv.c: validate that for COMPRESSION_SGILOG and\n\tPHOTOMETRIC_LOGL, there is only one sample per pixel. Avoid\n\tpotential invalid memory write on corrupted/unexpected images when\n\tusing the TIFFRGBAImageBegin() interface (reported by\n\tClay Wood)\n\n2016-06-28  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: fix potential buffer write overrun in\n\tPixarLogDecode() on corrupted/unexpected images (reported by Mathias Svensson)\n\t(CVE-2016-5875)\n\n2016-06-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/libtiff.def: Added _TIFFMultiply32 and _TIFFMultiply64\n\tto libtiff.def\n\n2016-06-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/Makefile.am: The libtiff tools bmp2tiff, gif2tiff,\n\tras2tiff, sgi2tiff, sgisv, and ycbcr are completely removed from\n\tthe distribution.  The libtiff tools rgb2ycbcr and thumbnail are\n\tonly built in the build tree for testing.  Old files are put in\n\tnew 'archive' subdirectory of the source repository, but not in\n\tdistribution archives.  These changes are made in order to lessen\n\tthe maintenance burden.\n\n2016-05-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h (HAVE_SNPRINTF): Add a '1' to the\n\tHAVE_SNPRINTF definition.'\n\n2016-05-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h (HAVE_SNPRINTF): Applied patch by Edward\n\tLam to define HAVE_SNPRINTF for Visual Studio 2015.\n\n2016-04-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: when compiled with DEFER_STRILE_LOAD,\n\tfix regression, introduced on 2014-12-23, when reading a one-strip\n\tfile without a StripByteCounts tag. GDAL #6490\n\n2016-04-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/bugs.html: Replace Andrey Kiselev with Bob Friesenhahn for\n\tpurposes of security issue reporting.\n\n2016-01-23  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*: upstream typo fixes (mostly contributed by Kurt Schwehr)\n\tcoming from GDAL internal libtiff\n\n2016-01-09  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.h: make Param member of TIFFFaxTabEnt structure\n\ta uint16 to reduce size of the binary.\n\n2016-01-03  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_read.c, tif_dirread.c: fix indentation issues raised\n\tby GCC 6 -Wmisleading-indentation\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_pixarlog.c: avoid zlib error messages to pass a NULL\n\tstring to %s formatter, which is undefined behaviour in sprintf().\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_next.c: fix potential out-of-bound write in NeXTDecode()\n\ttriggered by http://lcamtuf.coredump.cx/afl/vulns/libtiff5.tif\n\t(bugzilla #2508)\n\n2015-12-27  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_luv.c: fix potential out-of-bound writes in decode\n\tfunctions in non debug builds by replacing assert()s by regular if\n\tchecks (bugzilla #2522).\n\tFix potential out-of-bound reads in case of short input data.\n\n2015-12-26  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_getimage.c: fix out-of-bound reads in TIFFRGBAImage\n\tinterface in case of unsupported values of SamplesPerPixel/ExtraSamples\n\tfor LogLUV / CIELab. Add explicit call to TIFFRGBAImageOK() in\n\tTIFFRGBAImageBegin(). Fix CVE-2015-8665 reported by limingxing and\n\tCVE-2015-8683 reported by zzf of Alibaba.\n\n2015-12-21  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: workaround false positive warning of Clang Static\n\tAnalyzer about null pointer dereference in TIFFCheckDirOffset().\n\n2015-12-19  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.c: remove dead assignment in Fax3PutEOLgdal(). Found\n\tby Clang Static Analyzer\n\n2015-12-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirwrite.c: fix truncation to 32 bit of file offsets in\n\tTIFFLinkDirectory() and TIFFWriteDirectorySec() when aligning directory\n\toffsets on a even offset (affects BigTIFF). This was a regression of the\n\tchangeset of 2015-10-19.\n\n2015-12-12  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_write.c: TIFFWriteEncodedStrip() and TIFFWriteEncodedTile()\n\tshould return -1 in case of failure of tif_encodestrip() as documented\n\t* libtiff/tif_dumpmode.c: DumpModeEncode() should return 0 in case of\n\tfailure so that the above mentionned functions detect the error.\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/uvcode.h: const'ify uv_code array\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirinfo.c: const'ify tiffFields, exifFields,\n\ttiffFieldArray and exifFieldArray arrays\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_print.c: constify photoNames and orientNames arrays\n\n2015-12-06  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_close.c, libtiff/tif_extension.c : rename link\n\tvariable to avoid -Wshadow warnings\n\n2015-11-22  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix typos in comments (patch by Kurt Schwehr)\n \n2015-11-22  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix MSVC warnings related to cast shortening and\n\tassignment within conditional expression\n\n2015-11-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/*.c: fix clang -Wshorten-64-to-32 warnings\n\n2015-11-18  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: initialize double* data at line 3693 to NULL\n\tto please MSVC 2013\n\n2015-11-17  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: prevent reading ColorMap or TransferFunction\n\tif BitsPerPixel > 24, so as to avoid huge memory allocation and file\n\tread attempts\n\n2015-11-02  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dirread.c: remove duplicated assignment (reported by\n\tClang static analyzer)\n\n2015-10-28  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirinfo.c, libtiff/tif_compress.c,\n\tlibtiff/tif_jpeg_12.c: suppress warnings about 'no previous\n\tdeclaration/prototype'\n\n2015-10-19  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tiffiop.h, libtiff/tif_dirwrite.c: suffix constants by U to fix \n\t'warning: negative integer implicitly converted to unsigned type' warning\n\t(part of -Wconversion)\n\n2015-10-17  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirread.c, libtiff/tif_getimage.c,\n\t  libtiff/tif_print.c: fix -Wshadow warnings (only in libtiff/)\n\n2015-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.6 released.\n\n\t* html/v4.0.6.html: Added release notes for 4.0.6.\n\n2015-09-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Silence glut API deprecation warnings on MacOS\n\tX.  Patch by Roger Leigh.\n\n\t* Makefile.am: Added a 'coverity' rule to assist with Coverity\n\tsubmissions.\n\n\t* tools/tiff2pdf.c: Fix compiler warning about unused function\n\twhen JPEG is not available.\n\n\t* tools/fax2ps.c (main): Detect failure to write to temporary\n\tfile.\n\n2015-09-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryCheckRangeSlongSlong8):\n\tChange implementation so that it does not sometimes overflow the\n\trange of a 32-bit int and to avoid a signed vs unsigned compare\n\tcompiler warning.\n\t(TIFF_INT64_MAX): Avoid use of platform-specific large constants.\n\t(TIFF_UINT32_MAX): Avoid use of platform-specific large constants.\n\n2015-09-01  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am (distcheck-hook), configure.ac: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-09-01) to fix issue\n\twith BSD make and to make use of cmake in 'distcheck' target\n\tconditional on if cmake is available.\n\n\t* CMakeLists.txt, Makefile.am, configure.ac: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-09-01).\n\n\tCMake build is now included in 'distcheck' target.\n\n\tBuilds with CMake 2.8.9 and newer.\n\n\tTar is now resquested to use POSIX PAX format.\n\n2015-08-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt, libtiff/test/Makefile.am: Applied patches by\n\tRoger Leigh (via tiff mailing list on 2015-08-31.\n\n\tCMake reads all version information directly from configure.ac to\n\tavoid duplication of values.  This basically greps over the file\n\tfor the LIBTIFF_* variables, then translates them to the form\n\tneeded for cmake. This includes the release version and libtool\n\tshared library version information.\n\n\tMake shared/static library building configurable.  Currently it\n\talways builds shared libraries, with static libs having a _static\n\tsuffix (copying zlib, but it means it's got a non-standard name).\n\tCMake has a -DBUILD_SHARED_LIBS=ON|OFF option to select one or the\n\tother, which is now used instead.  There's now a single \"tiff\"\n\ttarget to build either shared or static as required, and all the\n\ttests and tools are linked with this. Note: the Windows tests fail\n\twhen linked with a static libtiff (says: libtiff.dll not found).\n\tNot really a regression since this was not tested up to this\n\tpoint, and it's likely the unit tests haven't (ever?) been run on\n\tWindows with a static libtiff, so there's some additional\n\tportability issue here to address.  Works fine on UNIX systems,\n\tand fine on Windows with the default to build a DLL.\n\n\tAdd a missing file which wasn't being distributed, causing unit\n\ttests to fail.  Note that \"find . -name '*.cmake'\" lists all the\n\tCMake files which need distributing in addition to all the\n\tCMakeLists.txt files (which now are distributed).\n\n2015-08-31  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.c: pedantic change to add explicit masking\n\twith 0xff before casting to uchar in floating-point horizontal\n\tdifferencing and accumulation routines.\n\n2015-08-31  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_predict.c: fix generation of output with 16 bit\n\tor 32 bit integer, when byte swapping is needed, in\n\thorizontal predictor (#2521). Also fixes decoding when there is\n\ta single pixel to code (unlikely case...) and byte swapping is\n\tinvolved.\n\n2015-08-30  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_lzw.c: make nextdata a unsigned type to avoid\n\tundefined behaviour with shifts (gcc -fsanitize=shift)\n\n2015-08-30  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_fax3.c, libtiff/tif_lzw.c, libtiff/tif_predict.c:\n\tadd explicit masking with 0xff before casting\n\tto unsigned char (make icc -check=conversions happy)\n\n\t* libtiff/tif_predict.c: operate on unsigned datatypes when\n\tcomputing/applying differences to avoid undefined behaviour of\n\tsigned types (C standard compliance)\n\n2015-08-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: libtiff 4.0.5 released.\n\n2015-08-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Applied patch by Roger Leigh (via tiff mailing\n\tlist on 2015-08-29) to add ld-version-script option to cmake build\n\tto match autoconf.  Note: defaults to 'on' to be ABI-compatible by\n\tdefault with common Linux distribution builds.  Note that the\n\tautoconf configure script defaults to 'off'.\n\n\t* html/build.html: Applied patch by Roger Leigh (via tiff mailing\n\tlist on 2015-08-29) to describe how to use CMake to build libtiff.\n\n2015-08-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/v4.0.5.html: Added HTML file describing the changes which\n\twill appear in the 4.0.5 release.\n\n2015-08-23  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h: For MinGW comiles, make sure that build\n\tsupports necessary __MSVCRT_VERSION__ (at least at least 0x800).\n\tOtherwise large files can not be supported for POSIX-style I/O.\n\n\t* tools/fax2tiff.c (main): Eliminate a compiler warning in 64-bit\n\tbuilds about cast to thandle_t.\n\n\t* test/rewrite_tag.c (main): Does not require any arguments.\n\n2015-08-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/CMakeLists.txt, port/snprintf.c: Patch by Roger Leigh to\n\tfix build issues when using Cmake due to Windows large file\n\tchanges.\n\n2015-08-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h: First cut at supporting large files under\n\tMicrosoft Windows using tif_unix.c and the libtiff tools.  This\n\tonly works if the Windows CDK is new enough to support the APIs\n\tused (Visual C++ 2005 or later).  Support for large files is not\n\tactually tested yet.\n\n2015-08-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Applied patch by R\u00e4is\u00e4 Olli to assure that\n\tclient_data is initialized to a known value, and to report an\n\terror on two memory allocation failures.\n\n2015-08-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Applied patch by Roger Leigh to fix libtiffxx\n\tsymbol versioning.  Patch was mailed to libtiff list on Thu, 13\n\tAug 2015.\n\n2015-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* cmake: Add d suffix to debug libraries with MSVC.  Patch #3 of 3\n\tby Roger Leigh posted to tiff list on Wed, 1 Jul 2015 15:58:20\n\t+0100.\n\n\t* cmake: Add extra warning flags.  Patch #2 of 3 by Roger Leigh\n\tposted to tiff list on Wed, 1 Jul 2015 15:58:20 +0100.\n\n\t* cmake: Correct snprintf fallback for VS2015.  Patch #1 of 3 by\n\tRoger Leigh posted to tiff list on Wed, 1 Jul 2015 15:58:20 +0100.\n\n2015-06-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* CMakeLists.txt: Add CMake patchset by Roger Leigh as posted to\n\tlibtiff mailing list on Mon, 22 Jun 2015 21:21:01 +0100. Several\n\tcorrections to ensure that the autotools build still works were\n\tadded by me.  I have not yet tested the build using 'cmake' or\n\tMSVC with 'nmake'.\n\n2015-06-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am: tiff2rgba-quad-tile.jpg.sh depends on the JPEG\n\tlibrary so only execute if JPEG is available.\n\n\t* libtiff 4.0.4 released.\n\n\t* configure.ac: Add a HAVE_FOO Automake conditional for each\n\tadd-on library.\n\n\t* test/Makefile.am (JPEG_DEPENDENT_CHECK_PROG): raw_decode\n\trequires JPEG support to compile.  Use Automake conditional to\n\tonly include it when JPEG support is available.\n\n\t* html/build.html: Try to improve the nmake-based VC++ build\n\tdescription.\n\n\t* libtiff/tiffconf.vc.h: Build fixes based on testing.\n\n\t* libtiff/tif_config.vc.h: Build fixes based on testing.\n\n\t* libtiff/libtiff.def: TIFFRasterScanline does not exist so remove\n\texport for it.\n\n2015-06-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_config.vc.h: Make adjustments to match the new\n\tdefinitions that configure produces, including for WIN64.  Still\n\tneeds to be tested.\n\n\t* configure.ac: For 64-bit MinGW, fix SSIZE_FORMAT formatting\n\tspecifier.  64-bit MinGW supports 'long long' but support for\n\t'lld' is not assured by the run-time DLLs and so GCC warns.\n\tAdd TIFF_SIZE_T and TIFF_SIZE_FORMAT to provide a type definition\n\tand printf format specifier to deal with printing values of\n\t'size_t' type.  In particular, this was necessary for WIN64.\n\tAdded a configure test for if the system headers provide 'optarg'\n\t(normal case) and block out the many explicit 'extern' statements\n\tin the utilities.  This was found to be necessary under Windows\n\twhen getopt is in a DLL and the symbols are already imported with\n\tdllimport via standard header files.\n\n\t* test/raw_decode.c (XMD_H): Avoid conflicting typedefs for INT32\n\tand boolean in MinGW build due to including jpeglib.h.\n\n\t* test/rewrite_tag.c (main): Fix problem with location of variable\n\tdeclaration.\n\n\t* libtiff/libtiff.def: Added exports for TIFFGetConfiguredCODECs,\n\tTIFFReadRGBAImageOriented, TIFFSetCompressionScheme,\n\tTIFFSwabArrayOfTriples, TIFFVGetFieldDefaulted, _TIFFCheckRealloc,\n\tTIFFRasterScanline, TIFFSetErrorHandlerExt,\n\tTIFFSetWarningHandlerExt, TIFFNumberOfDirectories,\n\tTIFFCreateCustomDirectory, TIFFCreateEXIFDirectory,\n\tTIFFWriteCustomDirectory, _TIFFRewriteField as recommended by\n\tRoger Leigh and justified by use in libtiff tests, documentation,\n\tand changelog notes.  Also sorted symbol list and removed\n\tduplicate entries.\n\n2015-06-16  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_getimage.c: Fix four Coverity issues related to\n\tunintended sign extension.\n\n2015-06-16  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_unix.c: fix compilation with MSVC (fix by Jeff McKenna)\n\n2015-06-14  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_unix.c: contribution from Vadim Zeitlin on\n\tBugzilla Bug #2510 fixes several harmless but still annoying\n\twarnings\n\n\t* configure: contribution from Ludolf Holzheid on Bugzilla\n\tBug #2498.  Adds an option to select the file I/O style on\n\tWindows hosts.\n\n\t* libtiff/tif_getimage.c: contribution from Gary Cramblitt\n\ton Bugzilla Bug #2409.  Correct reading of certain tiled TIFFs.\n\n\t* configure, configure.ac: contribution from Marcos H. Woehrmann\n\ton Bugzilla Bug #2405.  Correct shell equality operator.\n\n\t* tools/tiffgt.c (raster_draw): contribution from Jay Berkenbilt\n\ton Bugzilla Bug #2401.  Appropriately call glFlush().\n\n\t* tools/tiff2pdf.c: change ColorTransform from \"0\" to \"1\"\n\tfollowing Bugzilla Bug #2150.\n\n2015-06-13  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_lzw.c: contribution from Andy Cave - decode\n\tfiles that contain consecutive CODE_CLEAR codes.\n\n\t* tools/tiff2pdf.c: contribution from Antti S. Lankila on\n\tBugzilla Bug #2078. Suppress initial output of the header.\n\n\t* tools/tiff2pdf.c: contribution from Yuriy M. Kaminskiy -\n\tTake care in using the return value from snprintf().\n\n\t* tools/tiffcrop.c: contribution from Eduardo Robles Elvira -\n\tcorrectly copy the compression tag from the source TIFF.\n\n\t* tools/tiff2ps.c: contribution from Eduardo Robles Elvira -\n\tcorrect sizing and scaling problems with output document.\n\n2015-06-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c (JPEGDecode): Split JPEGDecode() into two\n\tclean implementations in order to avoid pre-processor hell.  Only\n\tone of the implementations is used in a given build.\n\n2015-06-08  Even Rouault <even.rouault at spatialys.com>\n\n\t* libtiff/tif_jpeg.c: Fix compilation in BITS_IN_JSAMPLE == 12\n\tcase\n\n2015-06-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_write.c (TIFFWriteEncodedStrip): Fix Coverity 715975\n\t\"Division or modulo by zero\".\n\t(TIFFWriteEncodedTile): Fix Coverity 715976 and 715977 \"Division\n\tor modulo by zero\".\n\t(TIFFWriteRawStrip): Fix Coverity 715978 \"Division or modulo by\n\tzero\".\n\t(TIFFWriteScanline): Fix Coverity 715979 \"Division or modulo by\n\tzero\".\n\n\t* libtiff/tif_read.c (TIFFStartTile): Fix Coverity 715973 and\n\t715974 \"Division or modulo by zero\".\n\n2015-05-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (TIFFNumberOfDirectories): Quiet Coverity\n\t1134470 \"Logically dead code\" by making the roll-over check\n\texplicit.\n\n\t* libtiff/tif_luv.c (LogLuvDecodeTile): Fix Coverity 991227\n\t\"Division or modulo by zero\".\n\t(LogLuvDecodeStrip): Fix Coverity 991239 \"Division or modulo by\n\tzero\".\n\t(LogLuvEncodeStrip): Fix Coverity 991240 \"Division or modulo by\n\tzero\".\n\t(LogLuvEncodeTile): Fix Coverity 991241 \"Division or modulo by\n\tzero\".\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryDoubleArray): Fix\n\tCoverity 298626 \"Logically dead code\".\n\t(TIFFReadDirEntryFloatArray): Fix Coverity 298627 \"Logically dead\n\tcode\".\n\t(TIFFReadDirEntryIfd8Array): Fix Coverity 298628 \"Logically dead\n\tcode\".\n\t(TIFFReadDirEntrySlong8Array): Fix Coverity 298629 \"Logically dead\n\tcode\"\n\n\t* libtiff/tif_dir.c (TIFFNumberOfDirectories): Don't depend on ++\n\toperator precedenc in evaluation.  Might quench Coverity 1134470\n\t\"Logically dead code\".\n\n\t* libtiff/tif_jpeg.c (JPEGDecode): Fix Coverity 602597 \"Operands\n\tdon't affect result\".  This change uses ifdefs to include\n\tapplicable code based on properties of libjpeg.  Still needs to be\n\tre-tested with 12-bit \"6b\" and \"MK1\".\n\n2015-05-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirwrite.c (_TIFFRewriteField): Fix Coverity 1024310\n\t\"Resource leak\".\n\n\t* libtiff/tif_ojpeg.c (OJPEGReadHeaderInfoSecStreamDht): Fix\n\tCoverity 601720 \"Resource leak\".\n\n\t* libtiff/tif_jpeg.c (JPEGCleanup): Fix Coverity 298624\n\t\"Dereference before null check\".\n\n\t* libtiff/tif_ojpeg.c (OJPEGReadBufferFill): Fix Coverity 603400\n\t\"Missing break in switch\".\n\n\t* contrib/addtiffo/tif_overview.c (TIFF_DownSample): Check buffer\n\tsize calculation for overflow.\n\n\t* contrib/addtiffo/addtiffo.c (main): Possibly address Coverity\n\t1024226 \"Untrusted value as argument\".\n\n\t* tools/gif2tiff.c (readgifimage): Fix Coverity 1024222 \"Untrusted\n\tvalue as argument\".\n\t(checksignature): Fix Coverity 1024894 \"Ignoring number of bytes\n\tread\".\n\t(readextension): Fix Coverity 1024893 \"Ignoring number of bytes\n\tread\".\n\t(readgifimage): Fix Coverity 1024890 \"Ignoring number of bytes\n\tread\".\n\t(readraster): Fix Coverity 1024891 \"Ignoring number of bytes\n\tread\".\n\t(readgifimage): Fix Coverity 1024892 \"Ignoring number of bytes\n\tread\".\n\n\t* tools/tiff2pdf.c (t2p_readwrite_pdf_image): Fix Coverity 1024181\n\t\"Structurally dead code\".\n\n\t* tools/raw2tiff.c (main): Fix Coverity 1024887 \"Unchecked return\n\tvalue from library\".\n\t(guessSize): Fix Coverity 1024888 \"Unchecked return value from\n\tlibrary\".\n\t(guessSize): Fix Coverity 1214162 \"Ignoring number of bytes read\".\n\t(guessSize): Fix Coverity 1024889 \"Unchecked return value from\n\tlibrary\".\n\n\t* tools/tiff2pdf.c (t2p_readwrite_pdf_image): Fix Coverity 298621\n\t\"Resource leak\".\n\t(t2p_readwrite_pdf_image): Fix Coverity 1024181 \"Structurally dead\n\tcode\".\n\t(t2p_write_pdf): Fix Coverity 1227690 \"Unused value\".\n\n2015-05-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/iptcutil/iptcutil.c (formatIPTC): Fix Coverity 1024468\n\t\"Infinite loop\".\n\t(formatIPTC): Fix Coverity 1024727 \"Truncated stdio return value\".\n\t(formatIPTC): Fix Coverity 1214240 \"Untrusted loop bound\".\n\n2015-05-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/addtiffo/tif_ovrcache.c (TIFFCreateOvrCache): Fix\n\tCoverity 298615 \"Resource leak\".\n\t(TIFFGetOvrBlock): Fix Coverity 1024649 \"Unintended sign\n\textension\".\n\n\t* tools/bmp2tiff.c (main): Fix Coverity 1024225 \"Untrusted value\n\tas argument\".\n\t(main): Fix Coverity 1024678 \"Unchecked return value from\n\tlibrary\".\n\t(main): Fix Coverity 1024679 \"Unchecked return value from\n\tlibrary\".\n\t(main): Fix Coverity 1214160 \"Ignoring number of bytes read\".\n\n\t* contrib/addtiffo/tif_ovrcache.c (TIFFCreateOvrCache): Fix\n\tCoverity 298615 \"Resource leak\".\n\n\t* tools/tiffcp.c: Fix Coverity 1024306, 1024307, 1024308, 1024309\n\t\"Resource leak\".\n\n\t* tools/tiffsplit.c (cpTiles): Fix Coverity 1024304 \"Resource\n\tleak\".\n\t(cpStrips): Fix Coverity 1024305 \"Resource leak\".\n\n2015-05-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/ras2tiff.c: Fix Sun Raster header definition to be safe\n\tfor 64-bit systems.  Add some header validations.  Should fix many\n\tCoverity issues.\n\t(main): Fix Coverity 1301206: \"Integer handling issues  (BAD_SHIFT)\".\n\t(main): Quiet Coverity 1024223 \"Untrusted value as argument\".\n\n\t* tools/tiffmedian.c (GetInputLine): Fix Coverity 1024795 \"Nesting\n\tlevel does not match indentation\".\n\t(get_histogram): Quiet Coverity 1024386 \"Out-of-bounds read\".\n\tThis was a benign mis-diagnosis but added code to enforce against\n\tbuffer overflow.\n\n\t* tools/tiffcrop.c (ROTATE_ANY): Fix Coverity 1294542 \"Logical\n\tvs. bitwise operator\".\n\t(readContigStripsIntoBuffer): Fix Coverity 1024545 \"Division or\n\tmodulo by zero\".\n\t(readContigTilesIntoBuffer): Fix Coverity 1024586 \"Logically dead\n\tcode\".\n\t(writeSingleSection): Fix Coverity 1024796 \"Nesting level does not\n\tmatch indentation\".\n\t(writeCroppedImage): Fix Coverity 1024797 \"Nesting level does not\n\tmatch indentation\".\n\t(loadImage): Fix Coverity 1299741 \"Dereference before null check\".\n\t(loadImage): Fix Coverity 1299740 \"Out-of-bounds write\".\n\n2015-03-02  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiffdither.c: check memory allocations to avoid writing to\n\tNULL pointer. Also check multiplication overflow. Fixes #2501,\n\tCVE-2014-8128. Derived from patch by Petr Gajdos.\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* add html/v4.0.4beta.html under version control\n\t* HOWTO-RELEASE: write that cvs add html/vX.X.html must be used\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff 4.0.4beta released\n\n2015-01-26  Even Rouault  <even.rouault@spatialys.com>\n\n\t* automake: updated to 1.15\n\t* libtool: updated to 2.4.5\n\n2015-01-22  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: Fix two crashes (oCERT-2014-013)\n\n2015-01-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/bugs.html: remove note about needing to email the tiff mailing\n\tlist administrator about being approved for membership, this appears\n\tnot to be true.\n\n2015-01-05  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* tools/tiff2pdf.c: Fixed unsigned integer addition overflow detection.\n\n2015-01-03  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dirread.c: in TIFFCheckDirOffset(), avoid uint16 overflow\n\twhen reading more than 65535 directories, and effectively error out when\n\treaching that limit.\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_jpeg.c: in JPEGFixupTags(), recognize SOF2, SOF9 and SOF10\n\tmarkers to avoid emitting a warning (even if, according to the TechNote,\n\tthere are admitedly unusual/not recommended or even forbidden variants, but\n\tthey do work well with libjpeg for SOF2, and with libjpeg-turbo for SOF2,\n\tSOF9 and SOF10).\n\tDefine in_color_space and input_components to the right values in\n\tJPEGSetupEncode(), before calling jpeg_set_defaults(), as specified by\n\tlibjpeg API documentation, so as to be compatible with mozjpeg library.\n\tNote: the default settings of mozjpeg will produce progressive scans, which\n\tis forbidden by the TechNote.\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c: move test on vertical value of YCbCr subsampling.\n\tto avoid buffer leak (fix previous fix, found by Coverity scan)\n\n2014-12-29  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_next.c: add new tests to check that we don't read outside of\n\tthe compressed input stream buffer.\n\n\t* libtiff/tif_getimage.c: in OJPEG case, fix checks on strile width/height\n    in the putcontig8bitYCbCr42tile, putcontig8bitYCbCr41tile and\n    putcontig8bitYCbCr21tile cases.\n\n2014-12-27  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dir.c: in TIFFDefaultDirectory(), reset any already existing\n\textented tags installed by user code through the extender mechaninm before\n\tcalling the extender callback (GDAL #5054)\n\n2014-12-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Fix warnings about variables set but not used.\n\n\t* contrib/iptcutil/iptcutil.c: Fix warnings about variables set\n\tbut not used.\n\n\t* tools/tiffgt.c: Fix warnings about unused parameters.\n\n\t* libtiff/tif_stream.cxx: Fix warnings about unused parameters.\n\n2014-12-25  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c, libtiff/tif_ojpeg.c, libtiff/tif_zip.c: fix\n\tvarious typos found by Debian lintian tool (GDAL #5756)\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_getimage.c: avoid divide by zero on invalid YCbCr subsampling.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2235\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: fix buffer overflow on some YCbCr JPEG compressed images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2445\n\n2014-12-24  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: fix buffer overflow on YCbCr JPEG compressed image.\n\tDerived from patch by Petr Gajdos,\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2443\n\n2014-12-23  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_dirread.c: In EstimateStripByteCounts(), check return code\n\tof _TIFFFillStriles(). This solves crashing bug on corrupted\n\timages generated by afl.\n\n2014-12-23  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_read.c: fix several invalid comparisons of a uint64 value with\n\t<= 0 by casting it to int64 first. This solves crashing bug on corrupted\n\timages generated by afl.\n\n2014-12-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffdump.c: Guard against arithmetic overflow when\n\tcalculating allocation buffer sizes.\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2bw.c: when Photometric=RGB, the utility only works if\n\tSamplesPerPixel = 3. Enforce that\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2485 (CVE-2014-8127)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/pal2rgb.c, tools/thumbnail.c: fix crash by disabling TIFFTAG_INKNAMES\n\tcopying. The right fix would be to properly copy it, but not worth the burden\n\tfor those esoteric utilities.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2484 (CVE-2014-8127)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c: fix out-of-buffer write\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2489 (CVE-2014-8128)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c, tools/tiffcmp.c: only read/write TIFFTAG_GROUP3OPTIONS\n\tor TIFFTAG_GROUP4OPTIONS if compression is COMPRESSION_CCITTFAX3 or\n\tCOMPRESSION_CCITTFAX4\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2493 (CVE-2014-8128)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_next.c: check that BitsPerSample = 2. Fixes\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2487 (CVE-2014-8129)\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiff2pdf.c: check return code of TIFFGetField() when reading\n\tTIFFTAG_SAMPLESPERPIXEL\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/tiffcp.c: fix crash when converting YCbCr JPEG-compressed to none.\n\tBased on patch by Tomasz Buchert (http://bugzilla.maptools.org/show_bug.cgi?id=2480)\n\tDescription: fix for Debian bug #741451\n\ttiffcp crashes when converting JPEG-encoded TIFF to a different\n\tencoding (like none or lzw). For example this will probably fail:\n\ttiffcp -c none jpeg_encoded_file.tif output.tif\n\tThe reason is that when the input file contains JPEG data,\n\tthe tiffcp code forces conversion to RGB space. However,\n\tthe output normally inherits YCbCr subsampling parameters\n\tfrom the input, which leads to a smaller working buffer\n\tthan necessary. The buffer is subsequently overrun inside\n\tcpStripToTile() (called from writeBufferToContigTiles).\n\tNote that the resulting TIFF file would be scrambled even\n\tif tiffcp wouldn't crash, since the output file would contain\n\tRGB data intepreted as subsampled YCbCr values.\n\tThis patch fixes the problem by forcing RGB space on the output\n\tTIF if the input is JPEG-encoded and output is *not* JPEG-encoded.\n\tAuthor: Tomasz Buchert <tomasz.buchert@inria.fr>\n\n2014-12-21  Even Rouault  <even.rouault@spatialys.com>\n\n\tFix various crasher bugs on fuzzed images.\n\t* libtiff/tif_dir.c: TIFFSetField(): refuse to set negative values for\n\tTIFFTAG_XRESOLUTION and TIFFTAG_YRESOLUTION that cause asserts when writing\n\tthe directory\n\t* libtiff/tif_dirread.c: TIFFReadDirectory(): refuse to read ColorMap or\n\tTransferFunction if BitsPerSample has not yet been read, otherwise reading\n\tit later will cause user code to crash if BitsPerSample > 1\n\t* libtiff/tif_getimage.c: TIFFRGBAImageOK(): return FALSE if LOGLUV with\n\tSamplesPerPixel != 3, or if CIELAB with SamplesPerPixel != 3 or BitsPerSample != 8\n\t* libtiff/tif_next.c: in the \"run mode\", use tilewidth for tiled images\n\tinstead of imagewidth to avoid crash\n\t* tools/bmp2tiff.c: fix crash due to int overflow related to input BMP dimensions\n\t* tools/tiff2pdf.c: fix crash due to invalid tile count (should likely be checked by\n\tlibtiff too). Detect invalid settings of BitsPerSample/SamplesPerPixel for CIELAB / ITULAB\n\t* tools/tiffcrop.c: fix crash due to invalid TileWidth/TileHeight\n\t* tools/tiffdump.c: fix crash due to overflow of entry count.\n\n2014-12-15  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_jpeg.c: Fix regression introduced on 2010-05-07 that caused\n\tall tiles/strips to include quantization tables even when the jpegtablesmode\n\thad the JPEGTABLESMODE_QUANT bit set.\n\tAlso add explicit removal of Huffman tables when jpegtablesmode has the\n\tJPEGTABLESMODE_HUFF bit set, which avoids Huffman tables to be emitted in the\n\tfirst tile/strip (only useful in update scenarios. create-only was\n\tfine)\n\n2014-12-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c: Assure that memory size calculations for\n\t_TIFFmalloc() do not overflow the range of tmsize_t.\n\n2014-12-07  Even Rouault  <even.rouault@spatialys.com>\n\n\t* tools/thumbnail.c, tools/tiffcrop.c: \"fix\" heap read over-run found with\n\tValgrind and Address Sanitizer on test suite\n\n2014-12-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c (t2p_read_tiff_init): TIFFTAG_TRANSFERFUNCTION\n\ttag can return one channel, with the other two channels set to\n\tNULL.  The tiff2pdf code was expecting that other two channels\n\twere duplicate pointers in the case where there is only one\n\tchannel.  Detect this condition in order to avoid a crash, and\n\tpresumably perform correctly with just one channel.\n\n2014-12-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffdump.c: Fix double-free bug.\n\n2014-11-27  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_config.vc.h: no longer use \"#define snprintf _snprintf\" with\n\tVisual Studio 2015 aka VC 14 aka MSVC 1900\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\n\t* libtiff/tif_lzw.c: prevent potential null dereference of\n\tsp->dec_codetab in LZWPreDecode (bug #2459)\n\n\t* libtiff/tif_read.c: in TIFFReadBufferSetup(), avoid passing -1 size\n\tto TIFFmalloc() if passed user buffer size is 0 (bug #2459)\n\n\t* libtiff/tif_ojpeg.c: make Coverity happier (not a bug, #2459)\n\n\t* libtiff/tif_dir.c: in _TIFFVGetField() and _TIFFVSetField(), make\n\tCoverity happier (not a bug, #2459)\n\n\t* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make Coverity happier\n\t(not a bug, #2459)\n\n\t* tools/tiff2pdf.c: close PDF file (bug #2479)\n\n\t* tools/fax2ps.c: check malloc()/realloc() result (bug #2470)\n\n\t* tools/tiffdump.c: detect cycle in TIFF directory chaining (bug #2463)\n\tand avoid passing a NULL pointer to read() if seek() failed before (bug #2459)\n\n\t* tools/tiffcrop.c: fix segfault if bad value passed to -Z option\n\t(bug #2459) and add missing va_end in dump_info (#2459)\n\n\t* tools/gif2tif.c: apply patch for CVE-2013-4243 (#2451)\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\t* libtiff/tif_jpeg.c: fix segfault in JPEGFixupTagsSubsampling() on\n\tcorrupted image where tif->tif_dir.td_stripoffset == NULL (bug #2471)\n\n2014-11-20  Even Rouault  <even.rouault@spatialys.com>\n\t* automake: updated to 1.14.1\n\t* libtool: updated to 2.4.3\n\t* HOWTO-RELEASE: small update about autotools building order\n\n2014-10-20  Olivier Paquet  <olivier.paquet@gmail.com>\n\t* tools/tiff2pdf.c: Preserve input file directory order when pages\n\tare tagged with the same page number.\n\n2014-08-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c (TIFFReadDirEntryOutputErr): Incorrect\n\tcount for tag should be a warning rather than an error since\n\terrors terminate processing.\n\n2014-06-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2rgba.c (]): Fixed tiff2rgba usage message in that zip\n\twas wrongly described.  Fix suggested by Miguel Medalha.\n\n2014-05-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirinfo.c (TIFFField) : Fix data type for\n\tTIFFTAG_GLOBALPARAMETERSIFD tag.  Patch by Steve Underwood.\n\tReviewed and forwarded by Lee Howard.\n\n2013-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fix last fix for TIFFNumberOfDirectories()\n\n2013-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: generate error in case of directory count\n\toverflow.\n\n2013-10-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h, libtiff/tif_dirinfo.c: add definitions for\n\tTIFF/EP CFARepeatPatternDim and CFAPattern tags (bug #2457)\n\n2013-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (TIFFAdvanceDirectory): If nextdir is found to\n\tbe defective, then set it to zero before returning error in order\n\tto terminate processing of truncated TIFF.  Issue found and fix\n\tsuggested by Richard Nolde.\n\n2013-08-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/gif2tiff.c: fix possible OOB write (#2452, CVE-2013-4244)\n\n2013-08-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/gif2tiff.c: Be more careful about corrupt or\n\thostile input files (#2450, CVE-2013-4231)\n\n\t* tools/tiff2pdf.c: terminate after failure of allocating\n\tycbcr buffer (bug #2449, CVE-2013-4232)\n\n2013-07-09  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tools/tiffinfo.c: Default various values fetched with\n\tTIFFGetField() to avoid being uninitialized.\n\n2013-05-02  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Rewrite JPEG marker parsing in\n\tt2p_process_jpeg_strip to be at least marginally competent.  The\n\tapproach is still fundamentally flawed, but at least now it won't\n\tstomp all over memory when given bogus input.  Fixes CVE-2013-1960.\n\n2013-05-02  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* contrib/dbs/xtiff/xtiff.c, libtiff/tif_codec.c,\n \tlibtiff/tif_dirinfo.c, tools/rgb2ycbcr.c, tools/tiff2bw.c,\n \ttools/tiff2pdf.c, tools/tiff2ps.c, tools/tiffcrop.c,\n \ttools/tiffdither.c: Enlarge some fixed-size buffers that weren't\n \tlarge enough, and eliminate substantially all uses of sprintf(buf,\n \t...)  in favor of using snprintf(buf, sizeof(buf), ...), so as to\n \tprotect against overflow of fixed-size buffers.  This responds in\n \tparticular to CVE-2013-1961 concerning overflow in tiff2pdf.c's\n \tt2p_write_pdf_page(), but in general it seems like a good idea to\n \tdeprecate use of sprintf().\n\n2013-03-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Applied patch by Brad Smith to improve pkg-config\n\tstatic linking by adding -lm to Libs.private when needed.\n\n2013-03-05  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* html/man/tiff2ps.1.html, html/man/tiffcp.1.html,\n \thtml/man/tiffdither.1.html, man/tiff2ps.1, man/tiffcp.1,\n \tman/tiffdither.1, tools/tiff2ps.c, tools/tiffcp.c,\n \ttools/tiffdither.c: Sync tool usage printouts and man pages with\n \treality (quite a few options had escaped being documented in one\n \tor both places).  Per an old report from Miroslav Vadkerti.\n\n2013-01-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2ps.c:Fix bug in auto rotate option code. Once a\n\trotation angle was set by the auto rotate check, it was retained\n\tfor all pages that followed instead ofa being retested for each\n\tpage.  Patch by Richard Nolde.\n\n2013-01-18  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_write.c: tmsize_t related casting warning fixed for\n\t64bit linux.\n\n\t* libtiff/tif_read.c: uint64/tmsize_t change for MSVC warnings.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2427\n\n2012-12-20  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* test/raw_decode.c: Relax raw_decode's pixel-value checks so that\n\tit will pass with more versions of libjpeg.  (There are at least\n\tthree in active use now, and JPEG_LIB_VERSION doesn't tell us\n\tenough to uniquely identify expected results.)\n\n2012-12-12  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/tif_print.c: Fix TIFFPrintDirectory's handling of\n\tfield_passcount fields: it had the TIFF_VARIABLE and\n\tTIFF_VARIABLE2 cases backwards.\n\n2012-12-10  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/ppm2tiff.c: Improve previous patch for CVE-2012-4564:\n \tcheck the linebytes calculation too, get the max() calculation\n \tstraight, avoid redundant error messages, check for malloc\n \tfailure.\n\n2012-12-10  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/tif_pixarlog.c: Improve previous patch for CVE-2012-4447\n \t(to enlarge tbuf for possible partial stride at end) so that\n \toverflow in the integer addition is detected.  Per gripe from\n \tHuzaifa Sidhpurwala.\n\n2012-12-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffset.c: tiffset now supports a -u option to unset a\n\ttag.  Patch by Zach Baker. See\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2419\n\n2012-11-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* automake: Update Automake to 1.12.5 release.\n\n\t* libtiff/tif_{unix,vms,win32}.c (_TIFFmalloc): ANSI C does not\n\trequire malloc() to return NULL pointer if requested allocation\n\tsize is zero.  Assure that _TIFFmalloc does.\n\n2012-11-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/ppm2tiff.c: avoid zero size buffer vulnerability.\n\tCVE-2012-4564 - Thanks to Huzaifa Sidhpurwala of the\n\tRed Hat Security Response team for the fix.\n\n2012-10-18  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tif_zip.c: Avoid crash on NULL error messages.\n\n2012-09-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.3 released.\n\n2012-09-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am: Update to Automake 1.12.4\n\n2012-08-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.in: Update to Automake 1.12.3\n\n\t* libtiff{tiff.h, tif_print.c, tif_dirinfo.c, tif_dirread.c}: Add\n\tsome TIFF/FX support in libtiff.  Add the tag definitions to\n\ttiff.h.  Add the related TIFF field definitions to tif_dirinfo.c,\n\tand also fixes an error in a comment.  Adds the photometric values\n\tto tif_print.c, and fixes a bug.  These changes are by Steve\n\tUnderwood.\n\n2012-08-13  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_write.c: Fix bug rewriting image tiles in a\n\tcompressed file: http://trac.osgeo.org/gdal/ticket/4771\n\n2012-08-02  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_dirread.c: report error in case of mismatch value\n\tcounts for tags (ie. DotRange).\n\n2012-07-26  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* libtiff/{tiffio.h, tif_dirinfo.c, libtiff.def}: Add six new\n \tfunctions TIFFFieldTag(), TIFFFieldName(), TIFFFieldDataType(),\n\tTIFFFieldPassCount(), TIFFFieldReadCount(), TIFFFieldWriteCount()\n\tas external accessors for the opaque type TIFFField.\n\n\t* tools/tiffset.c: Make tiffset use the above functions instead of\n\trelying on library private headers.\n\n2012-07-19  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Fix two places where t2p_error didn't get set\n\tafter a malloc failure.  No crash risk AFAICS, but the program\n\tmight not report exit code 1 as desired.  h/t mancha@mac.hush.com\n\n2012-07-18  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Fail when TIFFSetDirectory() fails.  This\n\tprevents core dumps or perhaps even arbitrary code execution when\n\tprocessing a corrupt input file (CVE-2012-3401).\n\n2012-07-06  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/raw_decode.c (main): Test fixes to work with IJG JPEG 7+.\n\tIJG JPEG 7+ uses a different upsampling algorithm which produces\n\tdifferent numeric results.\n\n\t* libtiff/tif_jpeg.c (JPEGPreDecode): Patch from Even Rouault to\n\twork with IJG JPEG 7+.\n\n2012-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/raw_decode.c: Add changes so that test can run with build\n\tdirectory outside of source directory.\n\n2012-07-02  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: Fix handling when writing RGBA jpeg compressed\n\timagery (http://trac.osgeo.org/gdal/ticket/4732)\n\n2012-06-20  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_fax3.c: fix memory initialization of runs, only\n\tpartly done.\n\n\t* libtiff/tif_pixarlog.c: Make sure tbuf is large enough for one\n\tfull \"stride\" past the end.\n\n2012-06-19  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_packbits.c: fix read past end of data buffer.\n\n2012-06-15  Frank Warmerdam  <warmerdam@google.com>\n\n\t*  libtiff 4.0.2 released.\n\n\t* tools/tif2pdf.c, tools/tifdump.c: avoid unitialized variable\n\twarnings with clang.\n\n2012-06-15  Tom Lane  <tgl@sss.pgh.pa.us>\n\n\t* tools/tiff2pdf.c: Defend against integer overflows while\n\tcalculating required buffer sizes (CVE-2012-2113).\n\n2012-06-12  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_print.c: Be careful about printing corrupt inknames.\n\n\t* libtiff/tif_fax3.c: Ensure runs array is initialized to zeros.\n\n2012-06-07  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_print.c: avoid pretty printing other fields when\n\twe don't have the proper amount and type of data or if the field\n\tis actually autodefined.\n\n2012-06-05  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_tile.c, libtiff/tif_strip.c: Ensure that illegal\n\tycbcrsubsampling values result in a runtime error, not just an\n\tassertion.\n\n\t* tests/custom_dir.c: Add testing of EXIF and custom directory\n\treading and writing.\n\n\t* libtiff/tif_dir.c, libtiff/tiffio.h: Add TIFFCreateCustomDirectory()\n\tand TIFFCreateEXIFDirectory() functions.\n\n\t* libtiff/tif_dir.c, tif_print.c : Remove FIELD_CUSTOM handling for\n\tPAGENUMBER, HALFTONEHINTS, and YCBCRSUBSAMPLING.  Implement DOTRANGE\n\tdifferently.  This is to avoid using special TIFFGetField/TIFFSetField\n\trules for these fields in non-image directories (like EXIF).\n\n2012-06-04  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: Remove code for fixing up h_sampling and v_sampling\n\tin JPEGPreDecode().  If a fixup will be done it needs to be done sooner\n\tin JPEGFixupTagsSubsampling() or else buffer sized may be wrong.\n\n2012-06-01  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tools/tiffinfo.c: Do not try to read image data in EXIF directories.\n\n\t* libtiff/tif_getimage.c: added support for _SEPARATED CMYK images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2379\n\n\t* libtiff/tif_unix.c: use strerror() to return a more specific error message\n\ton failed open.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2341\n\n\t* libtiff/tif_jpeg.c: Fix JPEGDecodeRaw() bugs.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2386\n\n\t* tests/decode_raw.c, tests/images/quad-tile.jpg.tiff: add limited support\n\tfor testing jpeg in tiff image decoding including the \"raw\" decode interface.\n\n2012-05-31  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_jpeg.c: avoid overrunning the end of the output buffer in\n\tJPEGDecodeRaw() - mostly likely to occur when there is confusion about\n\tsampling values.\n\n\t* libtiff/tif_read.c: Make sure tif_rawdatasize is cleared when tif_rawdata is freed.\n\n\t* libtiff/tif_getimage.c: Add support for greyscale+alpha c/o J\u00e9r\u00e9mie Laval.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2398\n\n2012-05-29  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_dir.c: avoid using specific set/get logic to process fields in custom directories,\n\tlike EXIF directories.  This fixes problems like a tag \"320\" existing in a custom directory getting\n\tprocessed as if it were a colormap when it isn't really.  Damn the wide variety of argument formulations\n\tto get/set functions for different tags!\n\n\t* libtiff/tif_dir.c: Ensure that we keep track of when tif_rawdata\n\tis a pointer into an mmap()ed file via TIFF_BUFFERMMAP flag.\n\n2012-05-24  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_pixarlog.c: Allocate working buffer one word larger since we \"forward\n\taccumulate\" and overwrite the end by one word in at least some cases.\n\n2012-05-23  Frank Warmerdam  <warmerdam@google.com>\n\n\t* libtiff/tif_pixarlog.c: avoid accessing out of the lookup arrays for out of range inputs.\n\n\t* tools/tiffinfo.c: initialize h=0 to avoid undefined variable for degenerate files.\n\n\t* libtiff/tif_ojpeg.c: if OJPEGWriteHeader() fails once do not bother trying again on\n\tthe same image.\n\n\t* libtiff/tif_ojpeg.c: make things more resilient in the face of files without\n\tstripbytecounts or stripoffsets or where loading these fails.\n\n\t* libtiff/tif_print.c: be careful about whether min/max values are singular\n\tor one per sample.\n\n\t* libtiff/tif_print.c: Avoid confusion about count size when printing custom fields.\n\tMay affect things like ISOSpeedRatings.\n\n\t* libtiff/tif_dir.c: avoid one byte past end of ink names reading\n\tin some cases.\n\n2012-05-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* man/TIFFGetField.3tiff: Correct the 'count' field type in the\n\texample for how to retreive the value of unsupported tags.\n\n2012-03-30  Frank Warmerdam  <warmerdam@google.com>\n\n\t* tif_getimage.c: Fix size overflow (zdi-can-1221,CVE-2012-1173)\n\tcare of Tom Lane @ Red Hat.\n\n2012-02-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.1 released.\n\n\t* Update automake used to 1.11.3.\n\n\t* libtiff/tiffio.h: Use double-underbar syntax in GCC printf\n\tattribute specification to lessen the risk of accidental macro\n\tsubstitution.  Patch from Vincent Torri.\n\n2012-01-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c, libtiff/tif_dirread.c: Extra caution around\n\tassumption tag fetching is always successful.\n\n\t* libtiff/tif_jpeg.c: Extra caution for case where sp is NULL.\n\n2012-01-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Add support for using library symbol versioning on\n\tELF systems with the GNU linker.  Support is enabled via\n\t--enable-ld-version-script.  Disabled by default for now until\n\tthere is a decision for how to deploy a libtiff with versioned\n\tsymbols after libtiff 4.0.0 was already released.\n\n2011-12-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_win32.c: Eliminate some minor 64-bit warnings in\n\n\ttif_win32.c.  Patch by Edward Lam.\n\n\t* configure.ac: Add libtiff private dependency on -llzma for\n\tpkg-config.  Patch by Mark Brand.\n\tUpdated Automake to 1.11.2.\n\n2011-12-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0 released.\n\n2011-12-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c, libtiff/tif_read.c: more cautious checking\n\tof _TIFFFillStriles() results (#gdal 4372)\n\n2011-12-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: fixes to deal with invalid files where\n\t_TIFFFillStriles() fails, and we try to chop up strips (gdal #4372)\n\n\t* libtiff/tif_dirread.c: fix error reporting when there is no\n\ttag information struct and name (gdal #4373)\n\n2011-10-22  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Update GNU libtool to 2.4.2.\n\n\t* tools/tiffsplit.c (tiffcp): TIFFGetField count field should be\n\tuint32 type for TIFFTAG_JPEGTABLES.  Patch by Christophe\n\tDeroulers.\n\n2011-06-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Restore TIFFMergeFieldInfo.\n\n2011-05-31  Jim Meyering  <meyering@redhat.com>\n\n\t* libtiff/tif_dirread.c (TIFFFetchStripThing): Free \"data\" also\n\tupon failure to allocate \"resizeddata\".\n\t* tools/tiff2ps.c (PSDataBW): Zero buffer *after* checking for\n\tallocation failure, not before.\n\t* libtiff/tif_ojpeg.c: plug leaks on OJPEG read failure path\n\t* tools/rgb2ycbcr.c (cvtRaster): unchecked malloc\n\t* libtiff/tif_jpeg.c, tools/tiff2pdf.c, tools/tiff2ps.c: mark\n\tNULL-deref and possible overflow\n\t* tools/tiff2pdf.c: remove decl+set of set-but-not-used local, \"written\"\n\t* libtiff/tif_jpeg.c (JPEGInitializeLibJPEG): Remove declaration\n\tand set of otherwise unused local, data_is_empty.\n\t* libtiff/tif_jpeg.c (JPEGDecodeRaw) [JPEG_LIB_MK1_OR_12BIT]:\n\tDiagnose out-of-memory failure and return 0 rather than\n\tdereferencing NULL.\n\n2011-05-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: produce special error message for zero tag\n\tdirectories instead of error out on the malloc(0) failure.\n\n2011-05-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Restore TIFFMergeFieldInfo() and\n\trelated declarations as they are in active use by libraries\n\tsuch as libgeotiff, and work just fine.  (#2315)\n\n2011-04-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c,tiffio.h: Remove the obsolete\n\tTIFFMergeFieldInfo/TIFFFindFieldInfo/TIFFFindFieldInfoByName API.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2315\n\n\t* libtiff/libtiff.def: add some missing (64bit) APIs.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2316\n\n2011-04-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0beta7 released.\n\n2011-04-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Should use AC_CANONICAL_HOST since host specifies\n\tthe run-time target whereas target is used to specify the final\n\toutput target if the package is a build tool (like a compiler),\n\twhich libtiff is not.  Resolves libtiff bug 2307 \"Use\n\tAC_CANONICAL_HOST macro\".\n\n2011-04-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Support configuring TIFF_INT64_FORMAT and\n\tTIFF_UINT64_FORMAT appropriately for MinGW32.\n\n\t* tools/tiffdump.c (ReadDirectory): MinGW32 needs to use WIN32\n\tprintf conventions for 64-bit types because it uses the WIN32 CRT.\n\n\t* libtiff/{tif_dumpmode.c,tif_luv.c,tif_lzw.c,tif_print.c,\n\ttif_read.c,tif_strip.c,tif_thunder.c}: MinGW32 needs to use WIN32\n\tprintf conventions for 64-bit types because it uses the WIN32 CRT.\n\n\t* tools/tiff2pdf.c (t2p_write_pdf_string): Fix printf syntax not\n\tunderstood by WIN32 CRT.\n\n\t* libtiff/tif_ojpeg.c: Fixes to compile with MinGW32 GCC.\n\n\t* tools/fax2ps.c (main): Use tmpfile() rather than mkstemp() since\n\tit is much more portable.  Tmpfile is included in ISO/IEC\n\t9899:1990 and the WIN32 CRT.\n\n2011-03-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffset.c: add -d and -sd switches to allow operation on\n\ta particular directory, not just the first (jef).\n\n2011-03-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_thunder.c: Correct potential buffer overflow with\n\tthunder encoded files with wrong bitspersample set.  The libtiff\n\tdevelopment team would like to thank Marin Barbella and TippingPoint's\n\tZero Day Initiative for reporting this vulnerability (ZDI-CAN-1004,\n\tCVE-2011-1167).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2300\n\n2011-03-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.h: Fix to last change allowing zero length\n\truns at the start of a scanline - needed for legal cases.\n\n2011-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.h: Protect against a fax VL(n) codeword commanding\n\ta move left.  Without this, a malicious input file can generate an\n\tindefinitely large series of runs without a0 ever reaching the right\n\tmargin, thus overrunning our buffer of run lengths.  Per CVE-2011-0192.\n\tThis is a modified version of a patch proposed by Drew Yao of Apple\n\tProduct Security.  It adds an unexpected() report, and disallows the\n\tequality case, since emitting a run without increasing a0 still allows\n\tbuffer overrun.\n\n2011-02-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: avoid divide by zero in degenerate case (#2296)\n\n\t* tools/tiff2rgba.c: close source file on error to make leak\n\tdetection easier.\n\n\t* libtiff/tif_getimage.c: avoid leaks if TIFFRGBAImageBegin() fails.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2295\n\n2011-02-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzma.c: Maintain tif_rawcc/tif_rawcp (CHUNKY_STRING_READ\n\t_SUPPORT)\n\n2011-02-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure.ac, configure: Added support for --enable-chunky-strip-read\n\tconfigure option to enable the experimental feature from a couple\n\tmonths ago for reading big strips in chunks.\n\n\t* configure.ac, tif_read.c, tif_readdir.c, tif_dir.h, tiffiop.h,\n\ttif_write.c, tif_print.c, tif_jpeg.c, tif_dirwrite.c, tif_write.c:\n\tImplement optional support for deferring the load of strip/tile\n\toffset and size tags for optimized scanning of directories.  Enabled\n\twith the --enable-defer-strile-load configure option (DEFER_STRILE_LOAD\n\t#define in tif_config.h).\n\n2011-02-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: remove unused variable.\n\n2011-02-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_win32.c: avoid error/warning buffer overrun problem\n\twith non-console (popup message) builds on win32.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2293\n\n2011-01-24  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/{tif_dir.{h,c}, tif_dirinfo.c, tif_dirread.c, tif_dirwrite.c,\n\ttif_print.c, tiff.h, tiffiop.h} : Added support for\n\tTIFFTAG_SMINSAMPLEVALUE and TIFFTAG_SMAXSAMPLEVALUE to have different\n\tvalues for each sample. Presents the min/max of all samples by default for\n\tcompatibility. TIFFSetField/TIFFGetField can be made to handle those tags\n\tas arrays by changing the new TIFFTAG_PERSAMPLE pseudo tag.\n\thttp://www.asmail.be/msg0055458208.html\n\n2011-01-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_pixarlog.c: Note that tif_rawcc/tif_rawcp are not\n\tmaintained.\n\n\t* libtiff/tif_zip.c: Maintain tif_rawcc/tif_rawcp when decoding\n\tfor CHUNKY_STRIP_READ_SUPPORT.\n\n\t* libtiff/tif_jpeg.c: ensure that rawcc and rawcp are maintained\n\tduring JPEGPreDecode and JPEGDecode calls.\n\t* libtiff/tif_read.c: larger read ahead for CHUNKY_STRIP_READ_SUPPORT,\n\tas compression formats like JPEG keep 16 lines interleaved in a sense\n\tand might need to touch\tquite a bit of data.\n\n\thttp://trac.osgeo.org/gdal/ticket/3894\n\n2011-01-03  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: Fix regressions with 2 and 3 band images\n\tcaused by commit on 2010-12-14.  Submitted by e-mail from\n\tEven Rouault <even.rouault@mines-paris.org>\n\n2010-12-31  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirwrite.c: Fixed writing of TIFFTAG_REFERENCEBLACKWHITE.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2266\n\n2010-12-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c, man/tiffcp.1: Added support for specifying the\n\tcompression level parameter (preset) for Deflate and LZMA encoders,\n\te.g \"-c lzma:p1\" or \"-c zip:p9\".\n\n\t* libtiff/tif_lzma.c: Properly set the LZMA2 compression level\n\t(preset) in LZMAVSetField().\n\n2010-12-18  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/Makefile.am (libtiff_la_SOURCES): Added tif_lzma.c to\n\tMakefile.\n\n2010-12-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/{tif_codec.c, tif_config.h.in, tiff.h,\n\ttiffiop.h, tif_lzma.c}, tools/tiffcp.c, man/tiffcp.1: Implement a new\n\tTIFF compression scheme LZMA reserving a new value 34925 for\n\tCompression tag. As per\n\tbug http://bugzilla.maptools.org/show_bug.cgi?id=2221\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: tolerate some cases where\n\tFIELD_COLORMAP is missing\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2189\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_read.c: change read_ahead to tmsize_t\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2222\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* configure.ac, libtiff/Makefile.am: Build tif_win32.c on\n\tWindows except on Cygwin\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2224\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/gif2tiff.c: fix buffer overrun\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2270\n\n2010-12-14  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: reduce usage of JCS_UNKNOWN in order\n\tto improve compatibility with various viewers\n\tsubmitted by e-mail from Dwight Kelly <dkelly@apago.com>\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/fax2ps.c: be consistent with page-numbering\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2225\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_color.c: prevent crash in handling bad TIFFs\n\tresolves CVE-2010-2595\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2208\n\n2010-12-13  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiffcrop.c: new release by Richard Nolde\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2004\n\n2010-12-12  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: fix colors for images with RGBA\n\tinterleaved data\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2250\n\n2010-12-12  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: fix for Zeiss LSM and Canon CR2 files\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2164\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: remove invalid duplication for Lab\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2162\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: fix use of clumplines calculation\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2149\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/fax2ps.c: replace unsafe tmpfile() with mkstemp()\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2118\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_ojpeg.c, libtiff/tif_pixarlog.c,\n\t  libtiff/tif_zip.c: fix build errors for VC6\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2105\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_stream.cxx: warnings cleanup\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2091\n\t* libtiff/tif_dirread.c: warnings cleanup\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2092\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2pdf.c: add fill-page option\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2051\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_dirread.c: modify warnings\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2016\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_ojpeg.c: fix buffer overflow on problem data\n        http://bugzilla.maptools.org/show_bug.cgi?id=1999\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiffinfoce.c: strip byte counts are uint64* now\n\n2010-12-11  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_ojpeg.c: fix crash when reading a TIFF with a zero\n        or missing byte-count tag\n        * tools/tiffsplit.c: abort when reading a TIFF without a byte-count\n        per http://bugzilla.maptools.org/show_bug.cgi?id=1996\n\n2010-12-08  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_dirread.c: fix crash when reading a badly-constructed\n        TIFF per http://bugzilla.maptools.org/show_bug.cgi?id=1994\n\n2010-12-06  Lee Howard <faxguy@howardsilvan.com>\n\n        * libtiff/tif_open.c: Fix mode check before opening a file.\n        http://bugzilla.maptools.org/show_bug.cgi?id=1906\n\n2010-11-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff-4.pc.in: Added libtiff pkg-config .pc file support.\n\tPatch by Vincent Torri.\n\n2010-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffinfo.c: avoid direct reference to _TIFFerrorHandler.\n\n\t* libtiff/tif_config.vc.h: define snprintf to _snprintf for tiff2pdf.\n\n\t* libtiff/libtiff.def: export _TIFFCheckMalloc for tools.\n\n2010-09-25  Lee Howard <faxguy@howardsilvan.com>\n\n\t* tools/tiff2ps.c: improvements and enhancements from Richard Nolde\n\twith additional command line options for Document Title,\n\tDocument Creator, and Page Orientation\n\n2010-07-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Patch from Richard Nolde to avoid a\n\tpotentially unterminated buffer due to using an exceptionally long\n\tfile name.\n\n2010-07-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Fixed ID buffer filling in\n\tt2p_write_pdf_trailer(), thanks to Dmitry V. Levin.\n\n2010-07-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Really reset the tag count in CheckDirCount()\n\tto expected value as the warning message suggests. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1963\n\n2010-07-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Properly handle TIFFTAG_PAGENUMBER,\n\tTIFFTAG_HALFTONEHINTS, TIFFTAG_YCBCRSUBSAMPLING, TIFFTAG_DOTRANGE\n\twhich should be set by value.\n\n\t* libtiff/tif_dirinfo.c: Don't use assertions in _TIFFFieldWithTag()\n\tand _TIFFFieldWithName() if the tag is not found in the tag table.\n\tThis should be normal situation and returned NULL value should be\n\tproperly handled by the caller.\n\n2010-07-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Avoid wrong math du to the signed/unsigned\n\tinteger type conversions. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2207\n\n\t* tools/{tiff2bw.c, thumbnail.c, pal2rgb.c}: Fix the count for\n\tWhitePoint tag as per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2042\n\n\t* libtiff/tif_getimage.c: Check the number of samples per pixel when\n\tworking with YCbCr image in PickContigCase(). As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2216\n\n\t* libtiff/tif_dir.c: Set the bogus post-decoding hook when processing\n\tTIFFTAG_BITSPERSAMPLE in _TIFFVSetField() for the case of 8 bit when\n\twe don't need any post-processing. That helps to reset the hook if we\n\tpreviously set this field to some other value and the hook was\n\tinitialized accordingly. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2035\n\n2010-07-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffgt.c: Properly check the raster buffer allocations for\n\tinteger overflows. As per bug\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2108\n\n\t* m4/acinclude.m4: Update GL/GLU/GLUt/Pthread macros from the\n\tupstream.\n\n\t* libtiff/{tif_aux.c, tif_strip.c, tif_tile.c, tiffiop.h}: Move\n\tmultiply_32() and multiply_64() functions into tif_aux.c file and\n\trename them into _TIFFMultiply32() and _TIFFMultiply64() respectively.\n\n2010-06-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Better generation of ID field in\n\tt2p_write_pdf_trailer(). Get rid of GCC aliasing warnings.\n\n\t* tools/tiff2pdf.c: Fixed computation of the tile buffer size when\n\tconverting JPEG encoded tiles.\n\n\t* tools/tiff2pdf.c: Better handling of string fields, use static\n\tstring buffers instead of dynamically allocated, use strncpy() instead\n\tof strcpy(), control the string lengths.\n\n2010-06-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Initialize buffer arrays with zero to avoid\n\treferencing to uninitialized memory in some cases (e.g. when tile size\n\tset bigger than the image size).\n\n2010-06-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Patch from Richard Nolde. Reject YCbCr\n\tsubsampled data since tiffcrop currently doesn't support it.  Fix\n\tJPEG support.\n\n2010-06-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Fix invocation of tag compare function (#2201)\n\n\t* tools/tiff2pdf.c: Fix assorted bugs in tiff2pdf: missing \"return\"\n\tin t2p_read_tiff_size() causes t2p->tiff_datasize to be set entirely\n\twrong for COMPRESSION_JPEG case, resulting in memory stomp if actual\n\tsize is larger.  Also, there are a bunch of places that try to\n\tmemset() a malloc'd buffer before checking for malloc failure, which\n\twould result in core dump if there actually were a failure. (#2211)\n\n2010-06-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): Need more castings to\n\tavoid compiler warnings if parameter types are not sign\n\tconsistent.\n\n\t* libtiff 4.0.0alpha6 released.\n\n\t* tools/tiffcrop.c: Applied patch from Richard Nolde: Corrected\n\tEuropean page size dimensions.  Added an option to allow the user\n\tto specify a custom page size on the command line.  Fix the case\n\twhere a page size specified with a fractional part was being\n\tcoerced to an integer by retyping the variables that define the\n\tpaper size.\n\n\t* html/index.html: Update for the 3.9.3 release.\n\n\t* tools/tiffcp.c (tiffcp): Applied Tom Lane's patch to reject\n\tYCbCr subsampled data since tiffcp currently doesn't support it.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2097\n\n\t* Update libtool to version 2.2.10.\n\n2010-06-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): Work properly if\n\tmultiplier is zero.\n\n2010-06-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_fax3.c (Fax3SetupState): Yesterday's fix for\n\tCVE-2010-1411 was not complete.\n\n\t* libtiff/tiffiop.h (TIFFSafeMultiply): New macro to safely\n\tmultiply two integers.  Returns zero if there is an integer\n\toverflow.\n\n\t* tools/tiffcp.c (main): tiffcp should not leak memory if an error\n\tis reported when reading the input file.\n\n2010-06-08  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Update libtool to version 2.2.8.\n\n\t* libtiff/tif_fax3.c (Fax3SetupState): Avoid under-allocation of\n\tbuffer due to integer overflow in TIFFroundup() and several other\n\tpotential overflows.  In conjunction with the fix to TIFFhowmany(),\n\tfixes CVE-2010-1411.\n\n\t* libtiff/tiffiop.h (TIFFhowmany): Return zero if parameters would\n\tresult in an integer overflow. This causes TIFFroundup() to also\n\treturn zero if there would be an integer overflow.\n\n\t* contrib: Add an emacs formatting mode footer to all source files\n\tso that emacs can be effectively used.\n\n2010-06-03  Oliver Chen Feng <scip8183@gmail.com>\n\n\t* libtiff/tools/tiffcp.c: add a new option -x to force merged tiff\n\tfile PAGENUMBER value in sequence for users who care the page\n\tsequence, this will also prevent tiff2pdf from creating pdf file from\n\tthe merged tiff file with wrong page sequence.\n\n2010-05-08  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirread.c: Restored TIFFReadDirEntryFloat function in order\n\tto add missing TIFF_SETGET_FLOAT case to TIFFFetchNormalTag.\n\t* libtiff/tif_dirinfo.c: Use correct set_field_type for\n\tTIFFTAG_PIXAR_FOVCOT so it is readable again (regression from 3.9.2).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2192\n\n2010-05-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Ensure that quality is always set in\n\tJPEGPreEncode(), not just when we want to output local tables.\n\tOtherwise the quality used during compression may not be right and\n\tmight not match the tables in the tables tag.   This bug only occurs\n\twhen seeking between directories in the midst of writing blocks.\n\thttp://trac.osgeo.org/gdal/ticket/3539\n\n2010-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* html/man/TIFFGetField.3tiff.html, html/man/TIFFSetField.3tiff.html:\n\tRegenerated from the source.\n\n2010-05-05  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_print.c: Fixed printing of TIFFTAG_REFERENCEBLACKWHITE which\n\thad stopped working. Also made it always print 6 floats instead of\n\t2*SamplesPerPixel.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2191\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2186\n\t* man/TIFFGetField.3tiff, man/TIFFSetField.3tiff: Fixed doc to reflect the\n\tfact that libtiff considers TIFFTAG_REFERENCEBLACKWHITE to be 6 floats.\n\n2010-05-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Fix to use memcmp(), not memcpy() when checking\n\tif the jpeg table was written.  This is a fix for the last fix on 04-21.\n\n2010-04-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: avoid preparing jpeg tables everytime\n\tJPEGSetupEncode() is called if the tables already seem to be\n\testablished.  This prevents spurious updates and rewriting of\n\tdirectories with jpegtables when doing updates to existing images.\n\thttp://trac.osgeo.org/gdal/ticket/3539\n\n2010-04-20  Olivier Paquet  <olivier.paquet@gmail.com>\n\n\t* libtiff/tif_dirinfo.c: Use correct set_field_type for\n\tTIFFTAG_PIXAR_IMAGEFULLWIDTH, TIFFTAG_PIXAR_IMAGEFULLLENGTH,\n\tTIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN and TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA.\n\tThey were unreadable with TIFF_SETGET_UNDEFINED, a regression from 3.9.2.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2139\n\n2010-04-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dir.c (_TIFFVSetField): Add a special error case for\n\twhen the tag count value is zero.  Error handling is still a\n\tregression since in 3.9.2, empty tags are skipped (with a warning)\n\trather than returning a hard error and refusing to read the file.\n\n\t* tools/ppm2tiff.c (main): While case for parsing comment line\n\trequires extra parenthesis to work as expected.  Reported by\n\tThomas Sinclair.\n\n2010-04-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_read.c (primarily): Add support for\n\tCHUNKY_STRIP_READ_SUPPORT where large strips are\n\tread in chunks for applications using TIFFReadScanline().\n\tThis is intended to make it more practical work with very\n\tlarge compressed one-strip files.   Feature is off by default.\n\tEnable by defining CHUNK_STRIP_READ_SUPPORT as a macro.\n\thttp://trac.osgeo.org/gdal/ticket/3514\n\n2010-03-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_flush.c: Use TIFFRewriteDirectory() when flushing\n\tdirectories so previously placed directories will be migrated to\n\tthe end of file if needed.\n\n2010-03-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: change type of dec_bitsleft field to uint64\n\tto support operating on strips/tiles of more than 256MB.\n\thttp://trac.osgeo.org/gdal/ticket/3512\n\n2010-03-10  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_aux.c (_TIFFCheckRealloc): Improve error message so\n\tthat it is clearly a memory allocation error message, and also\n\tincludes the size of the allocation request.\n\n2010-02-22  Lee Howard  <faxguy@howardsilvan.com>\n\n\t* libtiff/tif_jpeg.c: Do not generate a JPEGTables tag when creating\n\tthe JPEG TIFF as is is not required in order to prevent it from\n\tbeing unused and filled with invalid data.  (Leave it to be\n\tgenerated by later activity.)\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2135\n\t* tools/tiff2pdf.c: Write the JPEG SOI headers into the TIFF strip\n\tdata rather than skipping them.  This fixes the ability to view in\n\tAcrobat Reader, Evince, and Ghostscript.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2135\n\t* libtiff/tif_fax3.c: Don't return error on badly-terminated MMR\n\tstrips.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2029\n\n2009-12-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Made JPEGDecodeRaw() check for buffer overruns.\n\tMade so that when working with downsampled images a stub function\n\treporting an error is used for tif_decoderow.  We cannot meaningfully\n\tsupport reading scanlines in this situation.  (#1936)\n\n\t* libtiff/tif_jpeg.c: Ensure that tif_scanlinesize is computed after\n\tresetting of the upsampling values (gdal:#3259).\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1936\n\n2009-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/dbs/tiff-grayscale.c, contrib/tif-palette.c,\n\ttools/ras2tiff.c: Fix resource leaks on error.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2121\n\n\t* libtiff/tif_{aux.c,dir.c,dir.h,dirinfo.c}: Return to handling\n\tTIFFTAG_REFERENCEBLACKWHITE as a field in the TIFF directory instead\n\tof as a custom(generic) field to avoid a potential reentrancy problem.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2125\n\n\t* libtiff/tif_color.c, libtiff/tif_getimage.c, libtiff/tiffio.h,\n\tman/TIFFcolor.3tiff: Make TIFFDisplay argument in TIFFCIELabToRGBInit\n\tconst, and display_sRGB static and const.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2124\n\n2009-11-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0alpha5 released.\n\n2009-11-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c: Updated tiffcrop from Richard Nolde.  This\n\tversion has undergone substantial testing with arbitrary sample\n\tbit depths.  Also eliminates GCC compilation warnings.\n\n2009-11-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* port/libport.h: Add extern declarations for getopt standard\n\tglobals.\n\n2009-10-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_lzw.c (LZWDecode, LZWDecodeCompat): Fix warnings\n\tnoticed in 64-bit build of libtiff with Visual Studio 2005.\n\tResolves \"Bug 2067 - Visual Studio 2005 64-bit warnings in\n\ttif_lzw.c\", http://bugzilla.maptools.org/show_bug.cgi?id=2067\n\n\t* libtiff/tif_pixarlog.c (PixarLogEncode): Fix non-important\n\twarning noticed in Visual Studio 2005 build. Resolves \"Bug 2068 -\n\tVisual Studio 2005 64-bit warning in tif_pixarlog.c\",\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2068\n\n2009-10-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_dirread.c: Eliminate GCC \"dereferencing type-punned\n\tpointer\" warnings.\n\n2009-10-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/tools.html: Add manual page links, and a summary\n\tdescription of tiffcrop.\n\n2009-10-07  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: x86_64 should use the same fill order as i386.\n\n2009-09-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: New tiffcrop from Richard\n\tNolde.  Major updates to add significant functionality for reading\n\tand writing tile based images with bit depths not a multiple of 8\n\twhich cannot be handled by tiffcp.\n\n2009-09-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_ojpeg.c (OJPEGWriteHeaderInfo): IJG JPEG 7 needs\n\tdo_fancy_upsampling=FALSE in order to read raw data.  Resolves\n\t\"Bug 2090 - OJPEG crash with libjpeg v7\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2090\n\n2009-09-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Fixed error recognition handling in RGBA\n\tinterface when stoponerror is set.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2071\n\n2009-08-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/{tiffcrop.c,tiffgt.c}: Applied patch from Oden Eriksson to\n\tfix build with gcc when using the \"-Wformat\n\t-Werror=format-security\" flags.\n\n2009-08-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/{bmp2tiff_palette.sh, bmp2tiff_rgb.sh, gif2tiff.sh,\n\tppm2tiff_pbm.sh, ppm2tiff_pgm.sh, ppm2tiff_ppm.sh}: Additional\n\tutilities tests.\n\n2009-08-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffinfo.c: tiffinfo should return error status to the\n\tcaller.  Register a private error callback to accomplish that.\n\n\t* test/Makefile.am (TIFFIMAGES): Add test images in BMP, GIF, and\n\tPNM formats so that we will be able to test more of the tools.\n\tWhile adding these test images I notice that bmp2tiff and gif2tiff\n\tonly support ancient versions of their respective formats.\n\n2009-08-27  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff 4.0.0alpha4 released.\n\n\t* HOWTO-RELEASE: Improved release instructions.\n\n2009-08-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* man/{TIFFClose.3tiff,raw2tiff.1,tiffcmp.1,tiffsplit.1}: Applied\n\tfixes for \"Bug 2023 - nroff errors in manual pages\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2023\n\n\t* tools/{rgb2ycbcr.c, tiff2rgba.c}: Applied fixes for \"Bug 2079 -\n\tCVE-2009-2347 libtiff: integer overflows in various inter-color\n\tspace conversion tools\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2079\n\n\t* libtiff/tif_print.c (TIFFPrintDirectory): Apply fix from Jay\n\tBerkenbilt for \"Bug 2024 - possible null pointer dereference with\n\tone-line fix\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2024\n\n\t* libtiff/tif_dirread.c (TIFFReadCustomDirectory): Apply patch\n\tfrom Jay Berkenbilt for \"Bug 1895 - logic error in tif_dirread.c:\n\tsegfault after setting tdir_tag = IGNORE\".\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1895\n\n2009-08-23  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am, test/tiffcrop*.sh: Split previously existing\n\ttiffcrop.sh into a collection of many specific tests.  Re-wrote\n\tall of the existing tests to be based on some simple shell\n\tfunctions.  Make distcheck works again.\n\n\tExport certain variables (MAKE, MAKEFLAGS, MEMCHECK) to tests and\n\tadded 'memcheck' and 'ptrcheck' targets to make it easy to run the\n\ttests under valgrind.\n\n2009-08-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/tiffcp-logluv.sh: Fix test so that it works with a VPATH\n\tbuild.\n\n\t* test/Makefile.am (AUTOMAKE_OPTIONS): Colorized tests was not\n\tactually activated since it needed to be enabled in this\n\tMakefile.am.  Also activated parallel-tests mode since it offers\n\tuseful features such as per-test .log files and a summary test\n\treport .log file.\n\n2009-08-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Updated autotools.  Autoconf 2.64, Automake 1.11,\n\tlibtool 2.2.6.  Enabled support for silent build rules\n\t(--enable-silent-rules or 'make V=0') and colorized tests.\n\n\t* html/{index.html, v3.9.0.html}: Update for 3.9.0 release.\n\n2009-06-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tests/tiffcp-logluv.sh: minimal testing of sgilog compression.\n\n\t* tools/tiffcp.c: add -c sgilog support.\n\n\t* libtiff/tif_luv.c: correct return codes from encoderow to be\n\t1 on success instead of zero.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2069\n\n\t* libtiff/tif_lzw.c: back out patch from #2065 and apply patch from\n\t#1085 for a better underflow fix that errors properly.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2065\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1985\n\n2009-06-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_strip.c: Remove an inappropriate assertion that often\n\tfails on oddly sized 12bit jpeg compressed ycbcr images.\n\n2009-06-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: Fix buffer underflow bug.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2065\n\n2009-06-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure.ac, libtiff/tif_jpeg.c, libtiff/tif_jpeg_12.c: add support\n\tfor dual mode 8/12 bit jpeg support.\n\n2009-06-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: do not override the planar configuration to be\n\tcontig for one sample files if planar configuration is already set.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2057\n\n2009-06-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Add TIFFUnsetField.\n\n2009-05-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tif_jpeg.c,tif_ojpeg.c,tif_getimage.c}: Fixed various\n\terror reports to use \"%s\" as format string.\n\thttp://trac.osgeo.org/gdal/ticket/2976\n\n2009-03-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tif_fax3.c,tif_jpeg.c,tif_ojpeg.c}: Fix printdir chaining\n\tfor some codecs (#2020).\n\n2009-02-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_luv.c: Fix handling of tiled logluv images.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=2005\n\n2009-02-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Improve allocation safety when allocated\n\tbuffer for large tags.  (#1998)  Related to (#1993)\n\n2009-02-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffcrop.c: Don't default image->res_unit to INCH.  Now the\n\ttest suite should pass.\n\n2009-02-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Re-incorporated a sanity check on tag size,\n\tbut at the 2GB boundary to avoid overflow on 32bit systems.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1993\n\n\t* libtiff/tif_dirread.c: Remove some assertions that blow due to\n\tcorrupt files rather than in response to library internal\n\tinconsistencies.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1995\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1991\n\n\t* libtiff/tif_dirread.c: Fixed testing for failed result from\n\tTIFFReadDirectoryFindFieldInfo().\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1992\n\n2009-01-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_predict.c: Add support for 32bit integer horz. predictors.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1911\n\n\t* libtiff/tif_dirwrite.c: Fix byte swapping of next directory offset.\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1924\n\n\t* tools/tiffcrop.c: initialize xres/yres values.\n\n\t* test/*.sh - default ${srcdir} to local directory.\n\n\t* test/common.sh - start verbose mode after common settings.\n\n\t* libtiff/tif_dirinfo.c: Replace lfind() with local equivelent to\n\tavoid type mismatches on different platforms.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1889\n\n2009-01-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/{fax2tiff.c,thumbnail.c,tiff2pdf.c,tiff2ps.c,tiffdump.c,\n\ttiffsplit.c}: avoid warnings, mostly 32bit/64bit casting issues.\n\n\t* port,tools: Introduce libport.h, and include in tools if NEED_LIBPORT\n\tdefined, primarily to reduce prototype warnings on windows.\n\n\t* libtiff/tif_dirinfo.c,tif_dirread.c: Avoid warnings\n\tabout unused parameters, and uninitialized variables.\n\n2009-01-21  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/common.sh: Execute tests like 'make VERBOSE=TRUE check' in\n\torder to trace full execution detail while executing the test suite.\n\n2009-01-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffsplit.c: fix sampleformat to be shortv instead of longv.\n\n2009-01-20  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am (CLEANFILES): Make sure that test output files\n\tare removed by 'make clean'\n\n\t* Update autotools for 4.0.0 beta3\n\n\t* 4.0.0 beta3 produced.\n\n2009-01-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/tiffcrop.sh: New test script for tiffcrop from Richard\n\tNolde.\n\n\t* tools/tiff2ps.c: Remove spurious message to stderr.\n\n2009-01-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2ps.c: Incorporated significant functionality update\n\tfrom Richard Nolde.  In particular, support for rotating the image\n\tby 90, 180, 270, and 'auto' has been added.\n\n\t* man/tiffcrop.1: Incorporated documentation updates from Richard\n\tNolde.\n\n\t* tools/tiffcrop.c: Incorporated significant functionality update\n\tfrom Richard Nolde.\n\n2008-12-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiffio.h: GCC will now validate format specifications\n\tfor TIFFError(), TIFFErrorExt(), TIFFWarning(), and\n\tTIFFWarningExt() in order to reveal bugs.\n\n\t* Many fixes throughout to work better as a 64-bit build.\n\n2008-12-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/{tiff2pdf.c, tiff2ps.c, tiffinfo.c}: Offset and length\n\ttags now require 64-bit parameter rather than 32-bit.\n\n\t* libtiff/tif_dirread.c: Fixed issues with unaligned access to\n\t64-bit values.\n\n\t* tools/thumbnail.c: Eliminate crash noticed while running test\n\tsuite.\n\n2008-12-29  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_ojpeg.c (OJPEGLibjpegJpegSourceMgrFillInputBuffer):\n\tInitialize stack variables to avoid compiler warning.\n\n\t* tools/tiffinfoce.c (main): Use toff_t for offset type when\n\tretrieving offset of EXIF IFD.\n\n\t* libtiff/tiffio.h: Undeprecate toff_t and restore its use in the\n\tTIFFClientOpen() callback and other external function definitions.\n\n\t* tools/tiffinfo.c (main): Offset to EXIF IFD requires a 64-bit\n\ttype now.  Fixes crash when dumping files containing an EXIF IFD.\n\n\t* m4/libtool.m4: Update to libtool 2.2.6.\n\n2008-12-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c, tiffio.h: Introduce TIFFUnsetField() function.\n\n\t* libtiff/tif_jpeg.c: Avoid errors if the application writes a full\n\tstrip for the last partial strip in a jpeg compressed file.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1981\n\n2008-10-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_flush.c: Make sure that BEENWRITING is cleared when\n\twe take the shortcut to only update the strip/tile offsets in place.\n\thttp://trac.osgeo.org/gdal/ticket/2621\n\n2008-10-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jbig.c: Support the JBIG-KIT 2.0 (compatibility with\n\tthe older versions retained).\n\n2008-10-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Add #ifdefs for changes needed if using\n\tIPP enabled version of libjpeg from Intel.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1951\n\n2008-09-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Use byte counts of proper size (uint64).\n\tRequired for libtiff 4.0.\n\n\t* tools/tiffsplit.c: Use dynamically allocated array instead of static\n\twhen constructing output file names.\n\n2008-09-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Get rid of unsafe strcpy()/strcat() calls when\n\tdoing the filename/path construction.\n\n\t* tools/tiff2pdf.c: More appropriate format string in\n\tt2p_write_pdf_string(); avoid signed/unsigned mismatch.\n\n\t* libtiff/tif_lzw.c: Properly zero out the codetable. As per bug\n\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1929\n\n\t* libtiff/tif_lzw.c: Properly zero out the string table. Fixes\n\tCVE-2008-2327 security issue.\n\n2008-09-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Avoid unused TIFFReadDirEntryFloat() function.\n\n\t* libtiff/tif_dirwrite.c: modified to write IFDs as either IFD8 or IFD\n\tdepending on whether the file is bigtiff or classic tiff.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1917\n\n2008-08-12  Edward Lam  <edward@sidefx.com>\n\n\t* tools/tiffdump.c: When compiling for Microsoft Windows, apply\n\tconsistent (__int64) casting when testing if _lseeki64 has\n\tsuccessfully seeked as requested.  This is necessary for large\n\tfile support to work since off_t is only 32-bit.\n\n2008-07-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_strip.c: Replace assertions related to samplesperpixel != 3 or\n\tthe subsampling values not being 1, 2 or 4 (for jpeg compressed images)\n\twith control logic to return runtime errors (c/o Even Rouault) (#1927).\n\n2008-06-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffcrop.c: Fix some portability problems.\n\n\t* libtiff/tif_ojpeg.c: Use same jpeg/win32 boolean/FAR hacks as are\n\tused in tif_jpeg.c.\n\n\t* libtiff/tif_win32.c: Ensure TIFFOpenW() uses same FILE_SHARE flags\n\tas TIFFOpen().\n\n2008-06-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Fix alignment problems affecting architectures\n\tlike Sparc/Solaris.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1892\n\n2008-05-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff.def: Add TIFFFindField\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1891\n\n2008-05-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_config.*.h, tiffconf.*.h: Remove SIZEOF_LONG definition, unused.\n\n\t* li2008-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\nbtiff/tif_win32.c: Replace custom Win32 memory api with generic\n\tPOSIX one.  No apparent value to use of GlobalAlloc() in the modern\n\tage.  http://bugzilla.maptools.org/show_bug.cgi?id=1885\n\n\t* libtiff/tiffconf.vc.h: Added JBIG_SUPPORT and MDI_SUPPORT items\n\tin windows version (care of Edward Lam).\n\n2008-05-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_codec.c: Avoid NULL pointer dereferencing for exotic\n\tcompression codec codes.\n\n\t* tif_dirwrite.c: fix potential memory leak.\n\n\t* tif_dirread.c: Fix unchecked malloc result.\n\n2008-05-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test {tiff2pdf.sh tiff2ps-EPS1.sh tiff2ps-PS1.sh tiff2ps-PS2.sh\n\ttiff2ps-PS3.sh tiffcp-g3-1d-fill.sh tiffcp-g3-1d.sh\n\ttiffcp-g3-2d-fill.sh tiffcp-g3-2d.sh tiffcp-g3.sh tiffcp-g4.sh\n\ttiffcp-split-join.sh tiffcp-split.sh tiffcp-thumbnail.sh\n\ttiffdump.sh tiffinfo.sh}: Added more test scripts based on\n\tsuggestions from Lee Howard posted to the tiff list on 13 Sep\n\t2007.\n\n2008-05-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.c: Add an assert in an effort to detect a\n\tpossible runtime problem reported by coverity.\n\n\t* contrib/iptcutil/iptcutil.c: Fixed memory leak of str.\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: Major update from Richard Nolde.\n\thttp://bugzilla.maptools.org/show_bug.cgi?id=1888\n\n\t* tools/tiffdither.c: remove dead onestrip code.  avoid memory leak.\n\n\t* tools/rgb2ycbcr.c: fix memory leak of raster buffer.\n\n\t* tools/tiffcp.c: Simplify inknames code to avoid pointless test.\n\tCleanup scanline allocation to avoid coverity warning.\n\n\t* tools/thumbnail.c: Check for TIFFOpen() failure.\n\n2008-05-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Use TIFF_SETGET_ASCII for PIXAR_TEXTUREFORMAT\n\tand PIXAR_WRAPMODES instead of TIFF_SETGET_UNDEFINED.  Not exactly clear\n\twhy this is needed.\n\n2008-05-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* Makefile.am (ACLOCAL_AMFLAGS): Libtool 2.2.4 does not like\n\t\"ACLOCAL_AMFLAGS=-I ./m4\".  It wants \"ACLOCAL_AMFLAGS=-I m4\".\n\n2008-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* test/: Test suite updated. Everything is passed now.\n\n\t* libtiff/tif_dirinfo.c: Fixed description of the\n\tTIFFTAG_NUMBEROFINKS tag.\n\n2008-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_dirwrite.c, tiffiop.h}:\n\tGet rid of some of \"dereferencing type-punned\" warnings by converting\n\ttdir_offset field of TIFFDirEntry structure into union.\n\n2008-04-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_flush.c, tif_dirwrite.c, tiffio.h, tiffiop.h}:\n\tTIFFRewriteField() renamed into _TIFFRewriteField() and moved out\n\tfrom the public interface. Type of its 'count' parameter changed\n\tfrom uint32 to tmsize_t.\n\n\t* /libtiff/tiffiop.h: Make tif_nfields and tif_nfieldscompat fields\n\tof the tiff structure have the size_t type instead of uint32.\n\n2008-04-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Added support for MSVS 6.0.\n\n\t* libtiff/tif_dirread.c: Use custom functions _TIFFUInt64ToFloat()\n\tand _TIFFUInt64ToDouble() to convert 64-bit integers into floating\n\tpoint values on MSVS 6.0 platform.\n\n2008-03-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: Removed sanity checks on tags larger than 4MB in\n\tTIFFReadDirEntryArray() since they are interfering with seemingly\n\tlegitimate files.  http://trac.osgeo.org/gdal/ticket/2005\n\n2008-02-09  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Added handling for the case of number of values for\n\tPageNumber tag different from 2 (previously resulted in an assert\n\tindicating lack of handling and was forgotten about)\n\n2008-02-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Do not try to fixup subsampling tags based on\n\tthe actual jpeg data stream if the first strip/tile has zero size.\n\tThis is the case when GDAL creates a new file with zero sizes, closes\n\tand reopens it.\n\n2008-01-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c: fix up 64bit issues (from Edward Lam).\n\n2008-01-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: #ifdef out lots of unused functions.\n\n\t* Makefile.vc, libtiff/Makefile.vc, tools/Makefile.vc: Improve clean\n\ttargets.\n\n\t* tools/tiffinfo.c, tools/tiffcmp.c, tools/gif2tiff.c, tools/bmp2tiff.c\n\ttools/tiff2pdf.c: Fix 64-bit warnings when compiling under MSVC 2005\n\t(x64).\n\n\t* tools/tiffset.c: Changes to reflect the fact that TIFFFieldWithTag()\n\tand TIFFFieldWithName() now return TIFFField pointers instead of\n\tTIFFFieldInfo pointers.\n\n\t* tools/tiffdump.c: Added ssize_t typedef on Windows since it doesn't\n\texist. This makes it compile again on Windows\n\n\t* tif_aux.c, tif_getimage.c, tif_next.c, tif_predict.c, tif_win32.c,\n\ttiffconf.vc.h: Various 64bit fixes from Edward Lam identified on win64.\n\n\t* test/rewrite_tag.c: New test for TIFFRewriteField().\n\n2007-12-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Added TIFFRewriteField().  This new function\n\trewrites one field \"on disk\" updating an existing directory\n\tentry.  Lots of limitations still...\n\n\t* tiffiop.h, tif_write.c, tif_dirread.c, tif_flush.c: Keep track of\n\tTIFF_DIRTYSTRIP separately from TIFF_DIRTYDIRECT to indicate that\n\tthe strip offset/size values are dirty but nothing else about the\n\tdirectory is dirty.  In flush handle \"just stripmaps dirty\" as a\n\tspecial case that just rewrites these values without otherwise\n\tmodifying the directory on disk using TIFFRewriteField().\n\n\tWe also modify logic so that in update mode the directory is not\n\tmarked dirty on read, but only when something is changed.  This\n\tmeans we need to keep track of updates to the stripmap stuff in\n\tTIFFAppendToStrip().\n\n2007-12-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_jpeg.c: Improve ability to switch between encoding and decoding\n\tin the jpeg code (gdal bug #2033).\n\n2007-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dir.c, tif_dirread.c, tif_dirwrite.c, tif_read.c, tif_write.c,\n\ttiffiop.h: Added TIFF_BUF4WRITE flag to indicate if contents of the\n\trawcp/rawcc buffer are for writing and thus may require flushing.\n\tNecessary to distinguish whether they need to be written to disk when\n\tin mixed read/write mode and doing a mixture of writing followed by\n\treading.  http://trac.osgeo.org/gdal/ticket/1758\n\n2007-11-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.com, libtiff/tif_vms.c: Better OpenVMS support. Patches\n\tfrom Alexey Chupahin.\n\n2007-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_write.c: Rip out the fancy logic in TIFFAppendToStrip() for\n\testablishing if an existing tile can be rewritten to the same location\n\tby comparing the current size to all the other blocks in the same\n\tdirectory.  This is dangerous in many situations and can easily\n\tcorrupt a file.  (observed in esoteric GDAL situation that's hard to\n\tdocument).  This change involves leaving the stripbytecount[] values\n\tunaltered till TIFFAppendToStrip().  Now we only write a block back\n\tto the same location it used to be at if the new data is the same\n\tsize or smaller - otherwise we move it to the end of file.\n\n\t* tif_dirwrite.c: Try to avoid writing out a full readbuffer of tile\n\tdata when writing the directory just because we have BEENWRITING at\n\tsome point in the past.  This was causing odd junk to be written out\n\tin a tile of data when a single tile had an interleaving of reading\n\tand writing with reading last.  (highlighted by gdal\n\tautotest/gcore/tif_write.py test 7.\n\n\t* tif_predict.c: use working buffer in PredictorEncodeTile to avoid\n\tmodifying callers buffer.\n\thttp://trac.osgeo.org/gdal/ticket/1965\n\n\t* tif_predict.c/h: more fixes related to last item, keeping a\n\tdistinct pfunc for encode and decode cases as these were getting\n\tmixed up sometimes.\n\thttp://trac.osgeo.org/gdal/ticket/1948\n\n2007-11-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_predict.c/h, tif_lzw.c, tif_zip.c: Improvements so that\n\tpredictor based encoding and decoding works in read-write update\n\tmode properly.\n\thttp://trac.osgeo.org/gdal/ticket/1948\n\n2007-10-24  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Fixed problem with bogus file triggering\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG) in\n\tChopUpSingleUncompressedStrip\n\n2007-10-22  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_jpeg.c: Resolved buffer incrementation bug that lead to faulty images\n\tat best, access violation at worst, when subsampled JPEG compressed imagery\n\tis decoded without the JPEG_COLORMODE feature\n\n2007-10-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/index.html: Update \"people responsible\" section.\n\n2007-10-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fix problem with alpha setting in some cases\n\tas reported on the mailing list.\n\n2007-10-01  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* changed some more incorrect %lud printf flags to %lu\n\n2007-09-29  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Strip chopping interfered badly with uncompressed\n\tsubsampled images because it tried to divide subsampled rowblocks,\n\tleading to all sorts of errors throughout the library for these\n\timages. Fixed by making strip chopping divide in row counts that\n\tare a multiple of vertical subsampling value.\n\n2007-09-28  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Logical cast working around compiler warning\n\n\t* tif_read.c: Correction of some error flags and parameter lists\n\n2007-09-27  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirread.c: Made calculation of td_maxsamplevalue more robust\n\twhen dealing with large bitspersample values, shutting up purification\n\ttools that warn about truncation, though it remains incorrect and\n\tindicates a conceptual problem there.\n\n\t* tif_open.c: Moved early exit in case of 'h' flag (to disable reading\n\tof first IFD) to proper place because it badly interfered with memory\n\tmapping, resulting in mapping flag even with dummy mapping functions\n\tthat returned 0 whilst at the same time the mapping tif_size wasn't\n\tset, thus resulting in continuous incorrect beyond-eof errors.\n\n2007-09-24  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_dirinfo.c: Fixed (MSVC) compiler reports about\n\tinconsistent use of const in tiffFields and exifFields definition\n\n2007-09-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Always write tile/strip offsets and sizes\n\tusing LONG8 type when output format is BigTIFF.  The\n\tTIFFWriteDirectoryTagLongLong8Array() function was restructured\n\taccordingly.\n\n\t* tif_dirread.c: Improvements to error reporting text in\n\tTIFFFetchDirectory().\n\n2007-09-19  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/images: Added a small collection of test images for use by\n\ttest programs and scripts.\n\t* test/tiffinfo.sh: A trivial example test script.\n\t* test/common.sh: Added small script for setting the environment\n\tused by script-based tests.\n\n2007-08-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: Write the tif_nextdiroff value instead of a fixed\n\tzero when writing directory contents to preserve the ability to\n\trewrite directories in place, even in the middle of a directory\n\tchain.\n\n\t* tif_dirinfo.c:  _TIFFMergeFields() now only merges in field\n\tdefinitions that are missing.  Existing definitions are silently\n\tignored.\n\n\t* tif_dirread.c: Add runtime error for fields for which no definition\n\tis found (in addition to an assert for developers) in\n\tTIFFFetchNormalTag().  Not sure if this is needed, but it seems\n\tprudent.\n\n2007-08-10  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: removed SubsamplingHor and SubsamplingVer\n\tfrom _TIFFRGBAImage structure to revert unwanted ABI change.\n\n2007-08-10  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_win32.c: use SetFilePointer instead of\n\tSetFilePointerEx, as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1580\n\n2007-07-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_stream.cxx: Put all callback functions declarations\n\tinside extern \"C\" block.\n\n\t* libtiff/{tif_lzw.c, tif_luv.c, tif_dumpmode.c, tif_print.c,\n\ttif_read.c, tif_strip.c, tif_thunder.c}: Use \"%I64d\" printf()\n\tformatter instead of \"%lld\" with MSVC compiler.\n\n\t* libtiff/{tiffiop.h, tif_aux.c}:  Added _TIFFUInt64ToFloat() and\n\t_TIFFUInt64ToDouble() functions.\n\n2007-07-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Handle the case of MSVC 6 when using 64-bit\n\tinteger constants.\n\n\t* libtiff/{Makefile.am, Makefile.v}: Do not distribute tiffconf.h,\n\tremove tif_config.h/tiffconf.h during cleaning. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1573\n\n\t* libtiff/tif_unix.c: Do not use O_LARGEFILE. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1577\n\n2007-07-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 4.0.0alpha released.\n\n2007-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Added missed extern optind as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1567\n\n\t* libtiff/{tif_close.c, tif_dirinfo.c, tiffiop.c, tif_dirread.c,\n\ttif_dir.h, tif_dir.c, tiffio.h}: Transition to the new-style tag\n\textending scheme completed.\n\n2007-07-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_stream.cxx: Adapt to use toff_t again.  Update to\n\tuse standard C++ library size types and attempt to detect overflow\n\tcases.\n\n2007-07-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_jpeg.c, tif_dir.h, tif_dir.c, tif_dirinfo.c, tiffio.h,\n\ttif_ojpeg.c, tif_print.c, tif_fax3.c, tif_dirread.c}: More work on new\n\ttag extending scheme. Use the new scheme everywhere.\n\n\t* libtiff/{tif_zip.c, tif_predict.c, tif_pixarlog.c, tif_luv.c,\n\ttif_fax3.c, tif_dirread.c, tif_dirwrite.c, tif_close.c, tif_ojpeg.c,\n\ttif_jpeg.c, tif_dirinfo.c, tif_dir.h, tiffio.h, tiffiop.h}:\n\tTIFFFIeldInfo structure replaced with TIFFField structure.\n\tTIFFFieldInfo retained for the backward compatibility.\n\n2007-07-05  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiff2pdf.c: Fix a compile problem when JPEG_SUPPORT is not\n\tdefined.\n\n2007-07-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tiff.h, tiffio.h, libtiff.def}: Unused\n\tTIFFReassignTagToIgnore() function and TIFFIgnoreSense enumeration\n\tremoved.\n\n\t* libtiff/{tif_dirinfo.c, tif_fax3.c, tif_jbig.c, tif_jpeg.c}: Move\n\ttags TIFFTAG_FAXRECVPARAMS, TIFFTAG_FAXSUBADDRESS,\n\tTIFFTAG_FAXRECVTIME and TIFFTAG_FAXDCS to the common tag directory.\n\tThese tags are not codec-specific and relate to image content, so\n\tprocess them as other normal tags.\n\n\t* libtiff/{tiffio.h, tif_dir.h}: TIFFTagValue structure moved from the\n\tpublic tiffio.h to private tif_dir.h.\n\n\t* contrib/{acorn, mac-cw, mac-mpw}: Removed as unmaintained and\n\toutdated.\n\n2007-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff{tif_acorn.c, tif_apple.c, tif_atari.c, tif_msdos.c,\n\ttif_win3.c}: Obsoleted portability stuff removed.\n\n\t* tools/tiff2ps.c:  Added support 16-bit images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1566\n\n\tPatch from William Bader.\n\n\t* tools/tiff2pdf.c: Fix for TIFFTAG_JPEGTABLES tag fetching and\n\tsignificant upgrade of the whole utility as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1560\n\n\tNow we don't need tiffiop.h in tiff2pdf anymore and will open output\n\tPDF file using TIFFClientOpen() machinery as it is implemented\n\tby Leon Bottou.\n\n2007-06-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Fix typo when substituting value for unsigned 8 bit type.\n\tAdded support for a TIFF_PTRDIFF_T type to use when doing pointer arithmetic.\n\tAdded support for a TIFF_SSIZE_T in order to return memory sizes but still\n\tallow returning -1 for errors.\n\t* libtiff/tiffconf.vc.h: Add porting type defintions for WIN32.\n\n2007-06-25  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* port/strtoull.c: New porting function in case strtoull() is not\n\tavailable on the target system.\n\t* configure.ac: Add configure support for determining sized types\n\tin a portable way and performing necessary substitutions in\n\ttif_config.h and tiffconf.h.  Updated tiff.h to use the new\n\tdefinitions.\n\n2007-04-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Check the tmpfile() return status as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=154\n\n2007-04-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tif_dirread.c, tif_dirinfo.c, tif_jpeg.c,\n\ttif_fax3.c, tif_jbig.c, tif_luv.c, tif_ojpeg.c, tif_pixarlog.c,\n\ttif_predict.c, tif_zip.c}: Finally fix bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1274\n\n\tby introducing _TIFFMergeFieldInfo() returning integer error status\n\tinstead of void in case of problems with field merging (e.g., if the\n\tfield with such a tag already registered). TIFFMergeFieldInfo() in\n\tpublic API remains void. Use _TIFFMergeFieldInfo() everywhere and\n\tcheck returned value.\n\n2007-04-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/addtiffo/tif_overview.c: Fix problems with odd sized output\n\tblocks in TIFF_DownSample_Subsampled() (bug 1542).\n\n2007-04-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Changed JPEGInitializeLibJPEG() so that it\n\twill convert from decompressor to compressor or compress to decompress\n\tif required by the force arguments.  This works around a problem in\n\twhere the JPEGFixupTestSubsampling() may cause a decompressor to\n\tbe setup on a directory when later a compressor is required with the\n\tforce flag set.  Occurs with the addtiffo program for instance.\n\n2007-04-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: Significant update in\n\tfunctionality from Richard Nolde. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1525\n\n2007-03-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_fax3.c: \"inline static\" -> \"static inline\" for IRIC CC.\n\n2007-03-17  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* start of BigTIFF upgrade - CVS HEAD unstable until further notice\n\n2007-03-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: workaround for 'Fractional scanline' error reading\n\tOJPEG images with rowsperstrip that is not a multiple of vertical subsampling\n\tfactor. This bug is mentioned in:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1390\n\thttp://www.asmail.be/msg0054766825.html\n\n2007-03-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_win32.c: made inclusion of windows.h unconditional\n\n\t* libtiff/tif_win32.c: replaced preprocessor indication for consiously\n\tunused arguments by standard C indication for the same\n\n2007-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Use uint32 type instead of tsize_t in byte\n\tcounters in TIFFFetchData(). Should finally fix the issue\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=890\n\n2007-02-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Properly handle tags with TIFF_VARIABLE writecount.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1350\n\n\t* libtiff/tif_dirread.c: Added special function to handle\n\tSubjectDistance EXIF tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1362\n\n\t* tools/tiff2pdf.c: Do not assume inches when the resolution units\n\tdo not specified. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1366\n\n\t* tools/{tiffcp.c, tiffcrop.c}: Do not change RowsPerStrip value if\n\tit was set as infinite. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1368\n\n\t* tools/tiffcrop.c, man/tiffcrop.1: New tiffcrop utility contributed\n\tby Richard Nolde. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1383\n\n2007-02-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Workaround for incorrect TIFFs with\n\tExtraSamples == 999 produced by Corel Draw. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1490\n\n\t* libtiff/{tif_dirread.c, tif_read.c}: Type of the byte counters\n\tchanged from tsize_t to uint32 to be able to work with data arrays\n\tlarger than 2GB. Fixes bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=890\n\n\tIdea submitted by Matt Hancher.\n\n2007-01-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tif2rgba.c: This utility does not work properly on big-endian\n\tarchitectures. It was fixed including the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1149\n\n2007-01-15  Mateusz Loskot <mateusz@loskot.net>\n\n\t* Submitted libtiff port for Windows CE platform\n\t* libtiff/tif_config.wince.h: Added configuration header for WinCE.\n\t* libtiff/tiffconf.wince.h: Ported old configuration header for WinCE.\n\t* libtiff/tif_wince.c: Added WinCE-specific implementation of some\n\tfunctons from tif_win32.c.\n\t* libtiff/tif_win32.c: Disabled some functions already reimplemented in tif_wince.c.\n\t* libtiff/tiffiop.h, port/lfind.c: Added conditional include of some\n\tstandard header files for Windows CE build.\n\t* tools/tiffinfoce.c: Ported tiffinfo utility for Windows CE.\n\n2006-11-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: TIFFAppendToStrip() - clear sorted flag if\n\twe move a strip.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1359\n\n2006-10-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: More fixes for vulnerabilities, reported\n\tin Gentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n\t* libtiff/contrib/dbs/xtiff/xtiff.c: Make xtiff utility compilable.\n\tThough it is still far from the state of being working and useful.\n\n2006-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Save the state of printdir codec dependent\n\tmethod.\n\n\t* libtiff/tif_jpeg.c: Save the state of printdir codec dependent method\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1273\n\n\t* libtiff/tif_win32.c: Fixed problem with offset value manipulation\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1322\n\n\t* libtiff/{tif_read.c, tif_jpeg.c, tif_dir.c}: More fixes for\n\tvulnerabilities, reported in Gentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n2006-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_fax3.c, tif_next.c, tif_pixarlog.c}: Fixed multiple\n\tvulnerabilities, as per\tGentoo bug ():\n\n\thttp://bugs.gentoo.org/show_bug.cgi?id=142383\n\n2006-09-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c, libtiff/tif_zip.c: Fixed problems with mixing\n\tencoding and decoding on the same read-write TIFF handle.  The LZW\n\tcode can now maintain encode and decode state at the same time. The\n\tZIP code will switch back and forth as needed.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=757\n\n2006-09-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff: Rename config.h.vc and tif_config.h.vc to config.vc.h and\n\ttif_config.vc.h for easier identification by folks using an IDE.\n\n2006-07-25  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_msdos.c: Avoid handle leak for failed opens.  c/o Thierry Pierron\n\n2006-07-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: take care not to flush out buffer of strip/tile\n\tdata in _TIFFWriteDirectory if TIFF_BEENWRITING not set.  Relates\n\tto bug report by Peng Gao with black strip at bottom of images.\n\n2006-07-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirwrite.c: make sure to use uint32 for wordcount in\n\tTIFFWriteNormanTag if writecount is VARIABLE2 for ASCII fields.\n\tIt already seems to have been done for other field types.  Needed\n\tfor \"tiffset\" on files with geotiff ascii text.\n\n2006-07-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* {configure.ac, libtiff/tif_config.h.vc, libtiff/tif_jbig.c}\n\t(JBIGDecode): jbg_newlen is not available in older JBIG-KIT and\n\tits use does not appear to be required, so use it only when it is\n\tavailable.\n\n2006-06-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Added missed EXIF tag ColorSpace (40961).\n\n\t* libtiff/tif_dirread.c: Move IFD fetching code in the separate\n\tfunction TIFFFetchDirectory() avoiding code duplication in\n\tTIFFReadDirectory() and TIFFReadCustomDirectory().\n\n2006-06-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fix handling of -q values.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=587\n\n2006-06-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_readdir.c: Added case in EstimateStripByteCounts() for tiled\n\tfiles.  Modified TIFFReadDirectory() to not invoke\n\tEstimateStripByteCounts() for case where entry 0 and 1 are unequal\n\tbut one of them is zero.\n\t  http://bugzilla.remotesensing.org/show_bug.cgi?id=1204\n\n2006-06-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_open.c, tif_dirread.c, tiffiop.h}: Move IFD looping\n\tchecking code in the separate function TIFFCheckDirOffset().\n\n\t* libtiff/tif_aux.c: Added _TIFFCheckRealloc() function.\n\n\t* tools/tiffcmp.c: Fixed floating point comparison logic as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1191\n\n\t* libtiff/tif_fax3.c: Fixed problems in fax decoder as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1194\n\n\t* tools/tiff2pdf.c: Fixed buffer overflow condition in\n\tt2p_write_pdf_string() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1196\n\n2006-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* {configure, configure.ac, libtiff/tif_jbig.c, tools/tiffcp.c}: Added\n\tsupport for JBIG compression scheme (34661 code) contributed by Lee\n\tHoward. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=896\n\n\t* configure, configure.ac: OJPEG support enabled by default.\n\n\t* contrib/ojpeg/: Removed. New OJPEG support does not need this patch.\n\n2006-06-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/{tif_dirinfo.c, tif_print.c} : Fix crash in\n\tTIFFPrintDirectory().  Joris Van Damme authored the fix.\n\n2006-04-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Unified line ending characters (always use '\\n')\n\tas per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1163\n\n\t* README.vms, Makefile.am, configure.com, libtiff/{Makefile.am,\n\ttif_config.h-vms, tif_stream.cxx, tif_vms.c, tiffconf.h-vms}:\n\tAdded support for OpenVMS by Alexey Chupahin, elvis_75@mail.ru.\n\n2006-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{fax2ps.c, fax2tiff.c, ppm2tiff.c, ras2tiff.c, tiff2pdf.c}:\n\tProperly set the binary mode for stdin stream as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1141\n\n\t* man/{bmp2tiff.1, fax2ps.1, fax2tiff.1, gif2tiff.1, ras2tiff.1,\n\traw2tiff.1, rgb2ycbcr.1, sgi2tiff.1, tiff2bw.1, tiff2pdf.1, tiff2ps.1,\n\ttiff2rgba.1, tiffcmp.1, tiffcp.1, tiffdither.1,\ttiffdump.1, tiffgt.1,\n\ttiffset.1}: Improvements in page formatting as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1140\n\n\t* html/tools.html, html/man/Makefile.am, tools/tiff2pdf.c: Fixed\n\ttypos as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1139\n\n2006-04-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* nmake.opt: use /EHsc for VS2005 compatibility.  Also define\n\t_CRT_SECURE_NO_DEPRECATE to avoid noise on VS2005.\n\n2006-04-12  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: Added support for planarconfig separate\n\tnon-subsampled YCbCr (i.e. separate YCbCr with subsampling [1,1])\n\n2006-04-11  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: Revision of all RGB(A) put routines\n\t- Conversion of unassociated alpha to associated alpha now done with\n\t  more performant LUT, and calculation more correct\n\t- Conversion of 16bit data to 8bit data now done with\n\t  more performant LUT, and calculation more correct\n\t- Bugfix of handling of 16bit RGB with unassociated alpha\n\n2006-04-11  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c:\n\t- When there is no alpha, gtTileSeparate and gtStripSeparate allocated\n\t  buffer for alpha strile and filled it, only to never read it back.\n\t  Removed allocation and fill.\n\t- Minor rename of vars in gtTileSeparate and gtStripSeparate\n\t  anticipating planned functionality extension\n\n2006-04-08  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: renamed pickTileContigCase to PickContigCase\n\tand pickTileSeparateCase to PickSeparateCase as both work on strips as\n\twell\n\n\t* libtiff/tif_getimage.c: moved img->get selection from\n\tTIFFRGBAImageBegin into PickContigCase and PickSeparateCase to create\n\tlogical hook for planned functionality extension\n\n2006-04-08  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_ojpeg.c: resolved memory leak that was a consequence\n\tof inappropriate use of jpeg_abort instead of jpeg_destroy\n\n2006-04-07  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: replaced usage of TIFFScanlineSize in\n\tgtStripContig with TIFFNewScanlineSize so as to fix buggy behaviour\n\ton subsampled images - this ought to get sorted when we feel brave\n\tenough to replace TIFFScanlineSize alltogether\n\n\t* libtiff/tif_ojpeg.c: fixed bug in OJPEGReadSkip\n\n2006-04-04  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tiffio.h: added new type tstrile_t\n\n\t* libtiff/tif_dir.h: changed types of td_stripsperimage and td_nstrips\n\tto new tstrile_t, types of td_stripoffset and td_stripbytecount to\n\ttoff_t*\n\n\t* libtiff/tif_ojpeg.c: totally new implementation\n\n\t* libtiff/tif_dirread.c: added several hacks to suit new support of\n\tOJPEG\n\n\t* libtiff/tif_getimage.c: removed TIFFTAG_JPEGCOLORMODE handling\n\tof OJPEG images in favor of tif_getimage.c native handling of\n\tYCbCr and desubsampling\n\n2006-03-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: JPEGVSetField() so that altering the photometric\n\tinterpretation causes the \"upsampled\" flag to be recomputed.  Fixes\n\tpeculiar bug where photometric flag had to be set before jpegcolormode\n\tflag.\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_jpeg.c: strip size related bugfix in encode raw\n\n\t* libtiff/tif_strip.c: temporarilly added two new versions of\n\tTIFFScanlineSize\n\t  - TIFFNewScanlineSize: proposed new version, after all related\n\t    issues and side-effects are sorted out\n\t  - TIFFOldScanlineSize: old version, from prior to 2006-03-21 change\n\tThis needs further sorting out.\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* contrib/addtiffo/tif_ovrcache.c: bugfix to correctly pass size\n\tof last truncated strip data to TIFFWriteEncodedStrip\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/{tif_jpeg.c, tif_strip.c}: bugfix of tif_jpeg decode raw\n\n2006-03-25  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tif_getimage.c: bugfix/rewrite of putcontig8bitYCbCr22tile\n\n\t* libtiff/tif_getimage.c: added putcontig8bitYCbCr12tile\n\n\t* libtiff/tif_read.c: added support for new TIFF_NOREADRAW flag to\n\tprepare\tthe path for new tif_ojpeg.c\n\n2006-03-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.2 released.\n\n\t* tools/Makefile.am: Use runtime paths linker flags when rpath\n\toption enabled.\n\n2006-03-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed exports as per bug\n\thttp://bugzilla.remotesensing.org/attachment.cgi?id=337\n\n\t* contrib/addtiffo/Makefile.vc, libtiff/Makefile.vc, port/Makefile.vc,\n\ttools/Makefile.vc: Makefiles improvements as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1128\n\n\t* nmake.opt libtiff/{tif_config.h.vc, tif_unix.c, tiffio.h},\n\ttools/{fax2ps.c, fax2tiff.c, tiff2pdf.c}: Fixed win32 I/O functions\n\tusage as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1127\n\n\t* libtiff/tif_strip.c: Take subsampling in account when calculating\n\tTIFFScanlineSize().\n\n\t* tools/tiffcp.c: Do not set RowsPerStrip bigger than image length.\n\n2006-03-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Fixed wrong TIFFerror() invocations as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1125\n\n\t* tools/fax2ps.c: Fixed reading the input stream from stdin as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1124\n\n2006-03-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffiop.h: Added decalration for\n\t_TIFFSetDefaultCompressionState().\n\n\t* libtiff/{tif_jpeg.c, tif_fax3.c, tif_zip.c, tif_pixarlog.c,\n\ttif_lzw.c, tif_luv.c}: Use _TIFFSetDefaultCompressionState() in all\n\tcodec cleanup methods. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1120\n\n2006-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Do not cleanup codec state in TIFFInitJPEG(). As\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1119\n\n\t* tools/raw2tiff.c: Do not set RowsPerStrip larger than ImageLength.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1110\n\n\t* libtiff/tiffiop.h: dblparam_t typedef removed; GLOBALDATA macro\n\tremoved; move here the STRIP_SIZE_DEFAULT macro definition.\n\n\t* libtiff/{tif_dirread.c, tif_strip.c}: Removed STRIP_SIZE_DEFAULT\n\tmacro definition.\n\n\t* libtiff/tif_dir.c: Use double type instead of dblparam_t.\n\n2006-03-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Do not check the PlanarConfig tag presence\n\tin TIFFReadDirectory, because it is always set at the start of\n\tfunction and we allow TIFFs without that tag set.\n\n2005-03-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.1 released.\n\n2006-03-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Fixed error reporting in TIFFFetchAnyArray()\n\tfunction as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/tif_dirread.c: More wise check for integer overflow\n\tcondition as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/{tif_jpeg.c, tif_pixarlog.c, tif_fax3.c, tif_zip.c}:\n\tProperly restore setfield/getfield methods in cleanup functions. As\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n2006-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_predict.c, tif_predict.h}: Added new function\n\tTIFFPredictorCleanup() to restore parent decode/encode/field methods.\n\n\t* libtiff/{tif_lzw.c, tif_pixarlog.c, tif_zip.c}: Use\n\tTIFFPredictorCleanup() in codec cleanup methods. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n\t* libtiff/tif_dirread.c: Fixed integer overflow condition in\n\tTIFFFetchData() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1102\n\n2006-03-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_ojpeg.c: Set the ReferenceBlackWhite with the\n\tTIFFSetField() method, not directly. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1043\n\n\t* tools/ppm2tiff.c: Added support for PBM files as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1044\n\n2006-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Small code rearrangement in TIFFWriteScanline()\n\tto avoid crash as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1081.\n\n2006-02-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Functions t2p_sample_rgbaa_to_rgb() and\n\tt2p_sample_rgba_to_rgb() was used in place of each other, that was\n\tresulted in problems with RGBA images with associated alpha.\n\tAs per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1097\n\n2006-02-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Properly write TIFFTAG_DOTRANGE tag as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1088.\n\n\t* libtiff/tif_print.c: Properly read TIFFTAG_PAGENUMBER,\n\tTIFFTAG_HALFTONEHINTS, TIFFTAG_YCBCRSUBSAMPLING and TIFFTAG_DOTRANGE\n\ttags as per bug http://bugzilla.remotesensing.org/show_bug.cgi?id=1088.\n\n\t* tools/tiff2ps.c: Properly scale all the pages when converting\n\tmultipage TIFF with /width/height/center options set. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1080\n\n2006-02-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Do not create output file until all option checks\n\twill be done. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1072\n\n\t* tools/bmp2tiff.c: Added ability to create multipage TIFFs from the\n\tlist of input files as per bug:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1077\n\n2006-02-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_tile.c: Fix error reporting in TIFFCheckTile() as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1063.\n\n\t* tools/tiffgt.c: Avoid crashing in case of image unsupported by\n\tTIFFRGBAImage interface.\n\n\t* libtiff/tif_color.c: Avoid overflow in case of wrong input as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=1065.\n\n2006-02-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: Fixed support for non-YCbCr encoded JPEG\n\tcompressed TIFF files, per submission from Dan Cobra.\n\n2006-02-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_packbits.c, tif_win32.c}: Properly\n\tcast values to avoid warnings. As per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n\t* libtiff/tif_dirinfo.c: Use TIFF_NOTYPE instead of 0 when\n\tappropriate. As per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n\t* libtiff/tif_aux.c: Fixed type of temporary variable in\n\t_TIFFCheckMalloc() as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1033.\n\n2006-02-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_aux.c: Return static array when fetching default\n\tYCbCrCoefficients (another problem, reported a the\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1029 entry).\n\n2006-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Special handling for PageNumber, HalftoneHints,\n\tYCbCrSubsampling and DotRange tags as per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1029\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1034\n\n\t* libtiff/tif_dirread.c: Use _TIFFGetExifFieldInfo() instead of\n\t_TIFFGetFieldInfo() in TIFFReadEXIFDirectory() call as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1026.\n\n2006-01-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtool related stuff updated from the 2.1a branch.\n\n2006-01-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/bmp2tiff,pal2rgb,ppm2tiff,ras2tiff,raw2tiff,sgi2tiff,\n\ttiff2bw,tiffcp: Fixed jpeg option processing so -c jpeg:r:50 works\n\tproperly as per bug:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1025\n\n2006-01-09  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Fix with_default_strip_size comparison as reported\n\tby Norihiko Murase.\n\n2006-01-08  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* test/Makefile.am (LIBTIFF): Due to linking against libtiff\n\tincorrectly, tests were not actually testing the uninstalled\n\tlibtiff.  Now they are.\n\n2006-01-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Change definitions for TIFFTAG_ICCPROFILE,\n\tTIFFTAG_PHOTOSHOP, TIFFTAG_RICHTIFFIPTC, TIFFTAG_XMLPACKET: readcount\n\tshould be uint32 value.\n\n2006-01-02  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/man/Makefile.am (htmldoc): Fix htmldoc rule so that it can\n\tbe used if build directory is not the same as source directory.\n\t* man/{TIFFGetField.3tiff, TIFFSetField.3tiff}: Documented\n\tTIFFTAG_PHOTOSHOP, TIFFTAG_RICHTIFFIPTC, and TIFFTAG_XMLPACKET,\n\tand re-sorted tag names in alphabetical order.\n\n2005-12-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.8.0 released.\n\n2005-12-28  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/bmp2tiff.c (main): Fixed warning regarding returning\n\tinconsistent types from a condition.\n\t* tools/tiffcmp.c (CheckLongTag): Eliminate warning due to printf\n\tformat.\n\t* tools/bmp2tiff.c: Reduce compilation warnings on big-endian CPUs.\n\n2005-12-28  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* html/{index.html, support.hml, libtiff.html}: Cleaned up HTML\n\n2005-12-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Added VC_EXTRALEAN definition before including\n\twindows.h, to reduce the compile time.\n\n2005-12-26  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Improve compilation under MinGW.\n\n2005-12-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_dirread.c, tif_dirinfo.c}:\n\ttiffFieldInfo and exifFieldInfo arrays definitions moved back to\n\ttif_dirinfo.c; added _TIFFGetFieldInfo() and _TIFFGetExifFieldInfo()\n\tprivate functions to retrieve FieldInfo arrays.\n\n2005-12-24  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/build.html: Added some additional instructions for when\n\tbuilding using MSVC under Windows.  Also fixed two HTML syntax\n\terrors and used HTML Tidy to tidy up the HTML syntax and\n\tformatting.\n\n2005-12-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dir.c, tif_dir.h, tif_dirwrite.c,\n\ttif_print.c, tif_getimage.c}: Make InkSet, NumberOfInks, DotRange and\n\tStoNits tags custom.\n\n2005-12-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dir.c, tif_dir.h, tif_print.c}: Make\n\tWhitePoint tag custom.\n\n\t* libtiff/{tif_dir.h, tiff.h}: More EXIF tags added.\n\n2005-12-23  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/tiffio.h: fixed typo that potentially resulted in\n\tredefininition of USE_WIN32_FILEIO\n\n\t* libtiff/*: Added more 'dual-mode' error handling: Done TIFFWarning\n\tcalls in core LibTiff.\n\n2005-12-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_print.c}: Make RichTIFFIPTC,\n\tPhotoshop and ICCProfile tags custom.\n\n2005-12-21  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* libtiff/*, contrib/*: Added 'dual-mode' error handling, enabling\n\tnewer code to get context indicator in error handler and still\n\tremain compatible with older code: Done TIFFError calls everywhere\n\texcept in tools\n\n2005-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Added many error reporting messages; fixed integer\n\toverflow as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=789\n\n2005-12-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* contrib/addtiffo/*: Major upgrade by Joris to support subsampled\n\tYCbCr images in jpeg compressed TIFF files.\n\n2005-12-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Return non-zero status when reading fails (again).\n\n2005-12-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Return non-zero status when reading fails.\n\n2005-12-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tiff.h}: Added more EXIF tags.\n\n2005-12-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_print.c}: Make XMLPacket tag\n\tcustom.\n\n\t* tools/tiffinfo.c: Print EXIF directory contents if exist.\n\n\t* libtiff/tiff.h: Few EXIF tag numbers added.\n\n\t* libtiff/{tif_dirinfo.c, tif_dirread.c, tif_dir.h, tif_dir.c,\n\ttiffio.h}: Preliminary support to read custom directories. New\n\tfunctions: TIFFReadCustomDirectory() and TIFFReadEXIFDirectory().\n\n2005-12-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirinfo.c, tif_dirread.c, tif_dir.h, tif_dir.c}:\n\tMore work to implement custom directory read support.\n\n\t* libtiff/{tif_aux.c, tif_dirinfo.c, tif_dirread.c, tif_dir.h,\n\ttif_dir.c, tif_print.c}: Make YCbCrCoefficients and ReferenceBlackWhite\n\ttags custom.\n\n2005-12-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: One more workaround for broken\n\tStripByteCounts tag. Handle the case when StripByteCounts array filled\n\twith completely wrong values.\n\n2005-11-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Release file descriptor in case of failure\n\tin the TIFFOpenW() function as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1003\n\n\t* libtiff/tif_dirinfo.c: Correctly yse bsearch() and lfind()\n\tfunctions as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1008\n\n2005-11-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_open.c, tiff.h, tiffdump.c: Incorporate preliminary support\n\tfor MS MDI format.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=1002\n\n\t* .cvsignore: many files added, and a few update according\n\tto suggestion of Brad HArds on tiff mailing list.\n\n2005-11-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def, tiffiop.h, tiffio.h: Made TIFFFreeDirectory\n\tpublic.\n\n2005-10-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Properly calculate sizes of temporary arrays\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=943\n\n\t* tools/fax2tiff.c: Added option '-r' to set RowsPerStrip parameter\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=944\n\n\t* tools/tiffdump.c: Fixed typeshift and typemask arrays initialization\n\tproblem as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=946\n\n\t* tools/bmp2tiff.c: Fixed possible integer overflow error as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=965\n\n\t* libtiff/tif_dirinfo.c: Make XResolution, YResolution and\n\tResolutionUnit tags modifiable during write process. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=977\n\n\t* tools/tiffsplit.c: Copy fax related fields over splitted parts\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=983\n\n2005-10-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: Don't try and split single strips into \"0\" strips\n\tin ChopUpSingleUncompressedStrip.  This happens in some degenerate\n\tcases (like 1x1 files with stripbytecounts==0 (gtsmall.jp2 embed tiff)\n\n2005-10-20  Joris Van Damme  <joris.at.lebbeke@skynet.be>\n\n\t* tif_fax3.c: changed 'at scanline ...' style warning/errors\n\twith incorrect use of tif_row, to 'at line ... of\n\tstrip/tile ...' style\n\n2005-10-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_write.c: fixed setting of planarconfig as per bug report\n\ton the mailing list from Joris.\n\n2005-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, configure, nmake.opt, libtiff/{tif_config.h,\n\ttif_dirread.c}: Make the default strip size configurable via the\n\t--with-default-strip-size and STRIP_SIZE_DEFAULT options.\n\n2005-09-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* html/support.html: Fixed link to documentation on Greg Ward's\n\tLogLuv TIFF format.\n\n2005-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Fixed crash when reading malformed tags.\n\n2005-09-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Added missed 'break' statement as per bug\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=932\n\n2005-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.4 released.\n\n\t* {configure, configure.ac, Makefile.am, autogen.sh}: Applied patch\n\tfrom Patrick Welche (all scripts moved in the 'config' and 'm4'\n\tdirectories).\n\n2005-09-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: reintroduce seek to avoid problem on solaris.\n\n2005-09-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: When prefreeing tv->value in TIFFSetFieldV\n\talso set it to NULL to avoid double free when re-setting custom\n\tstring fields as per:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=922\n\n2005-08-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: avoid signed/unsigned warning.\n\n\t* libtiff/tif_dirread.c: removed unused variable.\n\n2005-07-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: Fixed up support for swapping \"double complex\"\n\tvalues (128 bits as 2 64 bits doubles).  GDAL gcore tests now\n\tpass on bigendian (macosx) system.\n\n2005-07-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_aux.c, tif_dirread.c, tif_fax3.c, tiffiop.h}: Rename\n\tCheckMalloc() function to _TIFFCheckMalloc() and make it available\n\tglobally as an internal helper routine.\n\n2005-07-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: More improvements in the \"pass by value\" part of\n\tthe custom tags handling code.\n\n2005-07-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_dirinfo.c}: Do not upcast BYTEs to\n\tSHORTs in the TIFFFetchByteArray(). Remove TIFFFetchExtraSamples()\n\tfunction, use TIFFFetchNormalTag() instead as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=831\n\n\tRemove TIFFFetchExtraSamples() function, use TIFFFetchNormalTag()\n\tinstead.\n\n\t* libtiff/tiffconf.h.in: One more attempt to fix the AIX bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2005-07-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_print.c: Fixed printing of the BYTE and SBYTE arrays.\n\n\t* tools/tiffdump.c: Added support for TIFF_IFD datatype.\n\n2005-07-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Do not check the PlanarConfiguration field in\n\tthe TIFFWriteCheck() function in case of single band images (as per\n\tTIFF spec).\n\n2005-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* SConstruct, libtiff/SConstruct: Added the first very preliminary\n\tsupport for SCons software building tool (http://www.scons.org/).\n\tThis is experimental infrastructure and it will exist along with the\n\tautotools mechanics.\n\n2005-07-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* port/{getopt.c, strcasecmp.c, strtoul.c}: Update modules from\n\tthe NetBSD source tree (the old\t4-clause BSD license changed to\n\tthe new 3-clause one).\n\n\t* configure.ac, port/lfind.c, libtiff/tiffiop.h: Added lfind()\n\treplacement module.\n\n\t* port/dummy.c: Make the dummy function static.\n\n2005-07-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed WhitePoint tag copying.\n\n\t* libtiff/{tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_print.c}:\n\tMake FieldOfViewCotangent, MatrixWorldToScreen, MatrixWorldToCamera,\n\tImageFullWidth, ImageFullLength and PrimaryChromaticities tags custom.\n\n2005-07-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.3 released.\n\n\t* configure, configure.ac: Do not use empty -R option when linking\n\twith --enable-rpath.\n\n2005-07-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_open.c}: Added open option 'h' to avoid\n\treading the first IFD when needed. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=875\n\n\t* libtiff/tif_color.c: Better use of TIFFmin() macro to avoid side\n\teffects.\n\n2005-06-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Print two characters per loop in the\n\tt2p_write_pdf_trailer(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=594\n\n\t* tools/tiffgt.c: Use MacOS X OpenGL framework when appropriate. As\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=844\n\n\t* acinclude.m4: Updated to latest OpenGL test macros versions.\n\n\t* libtiff/tiff.h: Use correct int size on Sparc 64bit/Sun compiler\n\tplatform. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=855\n\n2005-06-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Added support for ClipPath, XClipPathUnits\n\tand YClipPathUnits tags.\n\n2005-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/addtiffo/tif_ovrcache.c: Properly extract tile/strip size;\n\tuse pixel sized shift in contigous case.\n\n2005-06-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/addtiffo/{tif_overview.c, tif_ovrcache.c, tif_ovrcache.h}:\n\tMake overviews working for contiguos images.\n\n2005-06-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Replace runtime endianess check with the compile\n\ttime one.\n\n\t* libtiff/tif_predict.c: Floating point predictor now works on\n\tbig-endian hosts.\n\n2005-06-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Use _TIFFsetString() function when read custom\n\tASCII values.\n\n\t* libtiff/{tif_dirinfo.c, tif_dir.h, tif_dir.c, tif_print.c}: Make\n\tDocumentName, Artist, HostComputer, ImageDescription, Make, Model,\n\tCopyright, DateTime, PageName, TextureFormat, TextureWrapModes and\n\tTargetPrinter tags custom.\n\n\t* libtiff/tif_jpeg.c: Cleanup the codec state depending on\n\tTIFF_CODERSETUP flag (to fix memry leaks).\n\n\t* libtiff/tif_jpeg.c: Initialize JPEGTables array with zero after\n\tallocating.\n\n2005-05-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/Makefile.am: Added workaround for\n\tOpenBSD/MirOS soname problem as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=838\n\n\t* libtiff/tif_dirwrite.c: Use tdir_count when calling\n\tTIFFCvtNativeToIEEEDouble() in the TIFFWriteDoubleArray() function as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=845\n\n2005-05-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: Fixed format string when read PPM file header with\n\tthe fscanf() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=861\n\n\t* libtiff/{tif_dirinfo.c, tif_print.c}: TIFFFetchByteArray() returns\n\tuint16 array when fetching the BYTE and SBYTE filds, so we should\n\tconsider result as pointer to uint16 array and not as array of chars.\n\tAs per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=831\n\n\t* libtiff/tif_dir.c: More efficient custom tags retrieval as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=830\n\n\t* libtiff/tif_win32.c: Use FILE_SHARE_READ | FILE_SHARE_WRITE share\n\tmode in CreateFile() call as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=829\n\n\t* libtiff/Makefile.am: Fixed parallel compilation of the libtiff and\n\tlibtiffxx libraries as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=826\n\n\t* contrib/addtiffo/{tif_overview.c, tif_ovrcache.h}: Sinchronized with\n\tGDAL.\n\n2005-05-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Substantial fix for addtiffo problems with\n\tJPEG encoded TIFF files.  Pre-allocate lots of space for jpegtables\n\tin directory.\n\n2005-05-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Changed the code that computes\n\tstripbytecount[0] if it appears bogus to ignore if stripoffset[0] is\n\tzero. This is a common case with GDAL indicating a \"null\" tile/strip.\n\n2005-05-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Check for JPEGTables tag presence before copying.\n\n2005-05-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Applied similar change to\n\tTIFFFetchPerSampleLongs and TIFFFetchPerSampleAnys.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=843\n\n\t* libtiff/tif_jpeg.c: added LIB_JPEG_MK1 support in JPEGDecodeRaw().\n\n2005-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\t* tools/tiff2pdfr.c, man/tiff2pdf.1: Calculate the tile width properly;\n\tadded new option '-b' to use interpolation in output PDF files (Bruno\n\tLedoux).\n\n2005-05-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Ensure that broken files with too many\n\tvalues in PerSampleShorts work ok instead of crashing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=843\n\n2005-04-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdither.c: Copy the PhotometricInterpretation tag from the\n\tinput file.\n\n2005-04-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_predict.c: Added ability to encode floating point\n\tpredictor, as per TIFF Technical Note 3.\n\n2005-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_predict.h, tif_predict.c}: Added ability to decode\n\tfloating point predictor, as per TIFF Technical Note 3.\n\n2005-04-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tiffiop.h, tif_dir.c, tif_read.c, tif_swab.c}:\n\tAdded _TIFFSwab24BitData() and TIFFSwabArrayOfLong() functions used to\n\tswap 24-bit floating point values.\n\n\t* libtiff/tiff.h: Added predictor constants.\n\n2005-04-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dir.c}: Use uint32 type for appropriate\n\tvalues in _TIFFVSetField() function. Inspired by the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=816\n\n\t* man/TIFFSetField.3tiff: Fixed definition of the TIFFTAG_INKNAMES tag\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=816\n\n2005-03-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Do not read header in case the output file\n\tshould be truncated (Ron).\n\n\t* libtiff/{tif_dirinfo.c, tif_config.h.vc}: Use lfind() instead\n\tof bsearch() in _TIFFFindFieldInfoByName() function (Ron).\n\n\t* libtiff/{tiff.h, tif_dirinfo.c}: Fixes in EXIF tag ordering (Ron).\n\n2005-03-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/Makefile.am: Use libtool machinery to pass\n\trpath option.\n\n2005-03-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_print.c}: Handle all data types in custom\n\ttags.\n\n2005-03-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/dirinfo.c: Added DNG tags.\n\n\t* libtiff/{tif_dir.c, tif_print.c}: More improvements in custom tag\n\thandling code.\n\n\t* libtiff/tiff.h: More comments; added missed DNG tag (LensInfo);\n\tadded DNG 1.1.0.0 tags.\n\n\t* tools/tif2pdf.c: Fixed problem with alpha channel handling as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=794\n\n\t* man/TIFFGetField.3tiff: Add a note about autoregistered tags.\n\n2005-03-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* nmake.opt: Build with Win32 CRT library by default.\n\n\t* tools/tiff2ps.c: Fixed typo in page size handling code.\n\n\t* libtiff/{tif_dir.c, tif_print.c}: Support for custom tags, passed\n\tby value.\n\n\t* libtiff/{tiff.h, tif_dirinfo.c, tiffiop.h}: Added EXIF related tags.\n\n2005-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.2 released.\n\n2005-03-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcmp.c: Added ability to compare the 32-bit integer and\n\tfloating point data; complain on unsupported bit depths.\n\n2005-03-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tif_stream.cxx: Use ios namespace instead of ios_base to support\n\tGCC 2.95.\n\n\t* libtiff/{tiff.h, tif_fax3.tif, tif_jpeg.c}: Applied correct patch from\n\tLee Howard for HylaFax DCS tag\n\t(see http://bugzilla.remotesensing.org/show_bug.cgi?id=771)\n\n2005-03-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, configure.ac: Use -rpath option instead of -R as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=732\n\n\t* libtiff/{tiff.h, tif_fax3.tif, tif_jpeg.c}: Applied patch from Lee\n\tHoward to support a new tag TIFFTAG_FAXDCS (34911) used in HylaFax\n\tsoftware. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=771\n\n\t* nmake.opt, html/build.html: Add more comments, change the config\n\tfile organization a bit as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=764\n\n\t* tools/tiffcmp.c: Use properly sized buffer in short arrays comparison\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=785\n\n2005-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: More logic to guess missed strip size as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=705\n\n\t* tools/fax2ps.c: Replace insecure mktemp() function with the\n\ttmpfile() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=786\n\n2005-02-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Changed the int8 definition to be always signed char\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=727\n\n\t* libtiff/tiffio.h: Move TIFFOpenW() function into the extern \"C\"{}\n\tblock as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=763\n\n2005-02-03  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Fix problem on big-endian CPUs so that images\n\tdisplay more correctly.  Images display brighter than they should\n\ton a Sun workstation.\n\n2005-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Estimate strip size in case of wrong or\n\tsuspicious values in the tags. As per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=705\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=320\n\n\t* tools/tiff2ps.c: Fixed problem with page sizes as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=742\n\n2005-01-31  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiff.h (TIFFTAG_TILEWIDTH): Corrected description.\n\t(TIFFTAG_TILELENGTH): Corrected description.\n\n2005-01-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac: Fixes for --with-docdir option as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=759\n\n\t* libtiff/tif_open.c: Remove unnesessary TIFFSeekFile() call as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=756\n\n\t* libtiff/tif_stream.cxx: Fixes for C++ stream interface from\n\tMichael Rinne and Edward Lam.\n\n2005-01-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac: Make the documentation directory location configurable\n\tvia the --with-docdir option (as suggested by Jeremy C. Reed).\n\n\t* libtiff/tif_color.c: Use double as the second argument of pow()\n\tfunction in TIFFCIELabToRGBInit(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=741\n\n\t* libtiff/tif_pixarlog.c: Avoid warnings when converting float to\n\tinteger as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=740\n\n\t* libtiff/tif_getimage.c: Always fill the error message buffer in\n\tTIFFRGBAImageBegin() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=739\n\n2005-01-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Added ability to read/write the fax specific\n\tTIFFTAG_FAXRECVPARAMS, TIFFTAG_FAXSUBADDRESS and TIFFTAG_FAXRECVTIME\n\ttags as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=736\n\n\t* libtiff/tif_win32.c: Fixed message formatting in functions\n\tWin32WarningHandler() and Win32ErrorHandler() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=735\n\n\t* tools/tiff2ps.c: Interpret the -w and -h options independently. As\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=689\n\n2005-01-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Move the color conversion routines in the 'extern\n\t\"C\"' section as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=727\n\n\t* libtiff/tiff.h: Restore back the workaround for AIX Visual Age C\n\tcompiler to avoid double definition of BSD types as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n\t* libtiff/Makefile.am: Place the C++ stream API in the separate\n\tlibrary called libtiffxx to avoid unneeded dependencies. Probably\n\tthere will be more C++ API in the future. As per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=733\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=730\n\n2005-01-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffdump.c: Fixed problem when read broken TIFFs with the\n\twrong tag counts (Dmitry V. Levin, Martin Pitt).\n\n\t* configure.ac: Replace --disable-c++ with the --disable-cxx option as\n\tper bug http://bugzilla.remotesensing.org/show_bug.cgi?id=730\n\n2004-12-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: More fixes for multiple-alpha-channelled\n\tRGB-images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=713\n\n\n\t* tools/tiffset.c: Convert character option to integer value as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=725\n\n2004-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.1 released.\n\n\t* html/tiffset.1.html: Add missed manual page as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=678\n\n\t* libtiff/tiff.h: Revert back libtiff data type definitions as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=687\n\n2004-12-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Do not forget about TIFF_VARIABLE2 when\n\tchecking for tag count in TIFFReadDirectory() function. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=713\n\n\t* libtiff/{tif_dirread.c, tif_fax3.c}: More argument checking in\n\tCheckMallock() function.\n\n\t* libtiff/tif_getimage.c: Support for multiple-alpha-channelled\n\tRGB-images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=718\n\n2004-12-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: #define A1 bracketing for clean build on\n\tSunPro compiler.\n\n2004-12-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* autogen.sh: aclocal and autoheader should be executed after\n\tlibtoolize.  Also add '-I .' to aclocal invocation to check\n\tcurrent directory for macros.\n\n2004-12-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Always write TIFFTAG_SUBIFD using LONG type\n\tas per bugs\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=703\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=704\n\n2004-12-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* nmake.opt: Link with the user32.lib in windowed mode. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=697\n\n\t* libtiff/tif_win32.c: Use char* strings instead of TCHAR in windowed\n\tmode as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=697\n\n\t* libtiff/tif_config.in.vc: Removed unneded definitions for\n\tread/open/close/lseek functions to fix the\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=680\n\n2004-12-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.c, tif_dirread.c}: Remove TIFFReassignTagToIgnore()\n\tcall from the TIFFReadDirectory() function. TIFFReassignTagToIgnore\n\tmust be removed in the future, as it was never used properly. As per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=692\n\n2004-11-30  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: Added a work-around in order to allow\n\tcompilation with the heavily modified version of libjpeg delivered\n\twith Cygwin.\n\n2004-11-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Properly handle tags, which have the uint32\n\tcounts. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=693\n\n\t* tools/fax2ps.c: Be able to extract the first page (#0). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=690\n\n2004-11-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_unix.c: Make UNIX module compilable (and usable)\n\ton Windows.\n\n\t* nmake.opt: Add missed DLLNAME variable.\n\n2004-11-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/makefile.vc: make it easier to rename the libtiff DLL.\n\n2004-11-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* man/libtiff.3tiff: Improvements in the \"LIST OF ROUTINES\" table as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=545\n\n\t* man/tiffset.1: Added manual page for tiffset tool written by Jay\n\tBerkenbilt. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=678\n\n2004-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_error.c: fixed TIFFerror call to be TIFFError.\n\n2004-11-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/document.html: Updated Adobe web links as per email from Joris.\n\n2004-11-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.hxx, tiffio.h}: C++ stream interface moved to new\n\tfile tiffio.hxx. We don't have any C++ in tiffio.h, those who want to\n\tuse C++ streams should #include <tiffio.hxx>.\n\n2004-11-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Added Adobe DNG tags.\n\n\t* libtiff/tif_win32.c: Typo fixed.\n\n\t* libtiff/{tif_stream.cxx, tiffio.h}: C++ stream interface updated to\n\tbe compliant with the latest standard. Appropriate additions in\n\tmakefiles now completed.\n\n2004-11-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c, libtiff/tif_dirinfo.c: Properly handle the\n\tdifferent tag types. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=600\n\n2004-11-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_aux.c: Set the appropriate ReferenceBlackWhite array for\n\tYCbCr image which lacks that tag (noted by Hans Petter Selasky).\n\n2004-11-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_color.c: Division by zero fixed (Hans Petter Selasky).\n\n2004-11-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_stream.cxx, tiffio.h}: Added C++ stream interface\n\tcontributed by Edward Lam (see\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=654 for details).\n\tThough no changes in any makefiles yet.\n\n2004-11-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: Removed close() in TIFFClientOpen() if file\n\tis bad. This is the callers responsibility.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=651\n\n2004-11-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_win32.c, libtiff.def}: Added TIFFOpenW()\n\tfunction to work with the double byte strings (used to represent\n\tfilenames in some locales). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=625\n\n\t* libtiff/tif_dirread.c: Fixed problem when fetching BitsPerSample and\n\tCompression tags of type LONG from broken TIFFS as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=662\n\n\t* libtiff/tif_dirinfo.c: Fixed definition for TIFFTAG_RICHTIFFIPTC,\n\tthe writecount should have uint32 type. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=662\n\n\t* libtiff/tif_write.c: Fixed wrong if() statement in\n\tTIFFAppendToStrip() function as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=660\n\n2004-11-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Change definition for TIFFTAG_EXTRASAMPLES\n\tfield. The caller should supply a count when setting this field. As\n\tper bug\n\n\t http://bugzilla.remotesensing.org/show_bug.cgi?id=648\n\n\t* libtiff/{tif_jpeg.c, tif_ojpeg.c}: TIFFTAG_JPEGTABLES should have\n\tuint32 count. Use this type everywhere.\n\n2004-11-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_next.c: avoid use of u_long and u_char types.  Bug 653.\n\n2004-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2rgba.c: removed extra newlines in usage message.\n\n2004-10-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirwrite.c: Improvements in tag writing code.\n\n\t* tools/tiff2ps.c: Fixed wrong variable data type when read Position\n\ttags (Tristan Hill).\n\n2004-10-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiffiop.h: added fallback definition of assert() if we\n\tdon't have assert.h.\n\n2004-10-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Fixed case with the wrong decode routines\n\tchoosing when the incorrect Group4Options tag set. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=323\n\n\t* libtiff/tif_dirwrite.c: Fixed problem with passing count variable of\n\twrong type when writing the TIFF_BYTE/TIFF_SBYTE tags in\n\tTIFFWriteNormalTag().\n\n2004-10-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed wrong variable data type when read Resolution\n\ttags (Peter Fales).\n\n\t* tools/{bmp2tiff.c, raw2tiff.c}: Get rid of stream I/O functions.\n\n2004-10-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2pdf.c: added casts to avoid warnings.\n\n\t* libtiff/libtiff.def: Added several more entry points required\n\tto link fax2tiff.c against the DLL on windows.\n\n2004-10-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, configure.ac: Added --enable-rpath option to embed linker\n\tpaths into library binary.\n\n2004-10-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: Check the malloc return value (Dmitry V. Levin).\n\n\t* libtiff/{tif_strip.c, tif_tile.c}: Zero division problem fixed\n\t(Vladimir Nadvornik, Dmitry V. Levin).\n\n2004-10-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0 released.\n\n2004-10-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tif_jpeg.c: There seems to be no need to include stdio.h\n\tin this file so its inclusion is removed.  Including stdio.h\n\tsometimes incurs an INT32 typedef conflict between MinGW's\n\tbasetsd.h and libjpeg's jmorecfg.h.\n\n2004-10-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* man/bmp2tiff.1: Added manual page for bmp2tiff utility.\n\n2004-10-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffcmp.c (leof): Renamed from 'eof' in order to avoid\n\tconflict noticed under MinGW.\n\t* ltmain.sh: Fix for MinGW compilation.\n\n2004-10-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/tiffsplit.1: Fixed to indicate using aaa-zzz, not aa-zz.\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=635\n\n2004-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirread.c, tif_jpeg.c, tif_luv.c, tif_ojpeg.c,\n\ttif_pixarlog.c, tif_write.c}: Handle the zero strip/tile sizes\n\tproperly (Dmitry V. Levin, Marcus Meissner).\n\n2004-10-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Type of the TIFFTAG_SUBIFD field changed\n\tto TIFF_IFD.\n\n2004-10-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tif.c: Check the space allocation results.\n\n2004-10-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Initialize td_tilewidth and td_tilelength fields\n\tof the TIFFDirectory structure with the 0 instead of -1 to avoid\n\tconfusing integer overflows in TIFFTileRowSize() for striped images.\n\n\t* tools/tiff2pdf.c: Fixed TransferFunction tag handling reported\n\tby Ross A. Finlayson.\n\n\t* libtiff/tif_dir.c: Fixed custom tags handling as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=629\n\n2004-10-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Fix bug with tif_foundfield and reallocation\n\tof tif_fieldinfo.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=630\n\n2004-10-04  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* contrib/iptcutil/README: Added the missing README which goes\n\talong with iptcutil.\n\n2004-10-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_compress.c: Improved error reporting in\n\tTIFFGetConfiguredCODECs() (Dmitry V. Levin).\n\n2004-10-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0beta2 released.\n\n\t* libtiff/{tif_aux.c, tif_compress.c, tif_dirinfo.c, tif_dirwrite.c,\n\ttif_extension.c, tif_fax3.c, tif_luv.c, tif_packbits.c,\n\ttif_pixarlog.c, tif_write.c}: Added checks for failed memory\n\tallocations and\tinteger overflows (Dmitry V. Levin).\n\n\t* libtiff/tiff.h: Missed TIFF_BIGTIFF_VERSION constant added.\n\n2004-10-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: added a more informative message if a BigTIFF\n\tfile is opened.\n\n2004-09-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: changed type of XMLPacket (tag 700) to\n\tTIFFTAG_BYTE instead of TIFFTAG_UNDEFINED to comply with the info\n\tin the Adobe XMP Specification.\n\n2004-09-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_jpeg.c, tif_pixarlog.c}: Use _TIFFmemset() instead of\n\tmemset().\n\n\t* libtiff/{tif_dirread.c, tif_strip.c, tif_tile.c}: Applied patches\n\tfrom Dmitry V. Levin to fix possible integer overflow problems.\n\n2004-09-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Check for allocated buffers before clearing\n\t(Dmitry V. Levin).\n\n2004-09-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dir.h, tif_dir.c, tif_dirread.c, tif_write.c}:\n\tOptimize checking for the strip bounds.\n\n\t* libtiff/{tif_dirread.c, tif_strip.c}: TIFFScanlineSize() and\n\tTIFFRasterScanlineSize() functions report zero in the case of integer\n\toverflow now. Properly handle this case in TIFFReadDirectory()\n\t(patches from Dmitry V. Levin).\n\n2004-09-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_dirinfo.c, tif_strip.c, tif_tile.c}: Use TIFFhowmany8()\n\tmacro where appropriate.\n\n\t* tools/tiff2bw.c: Write ImageWidth/Height tags to output file, as\n\tnoted by Gennady Khokhorin.\n\n\t* libtiff/tif_dirread.c: Always check the return values, returned\n\tby the _TIFFmalloc() (Dmitry V. Levin).\n\n\t* libtiff/tif_dir.c: Fixed possible integer overflow _TIFFset*Array()\n\tfunctions (Dmitry V. Levin).\n\n\t* libtiff/{tif_dirread.c, tif_dir.c, tif_write.c}:\n\tPotential memory leak fixed in TIFFReadDirectory(), _TIFFVSetField(),\n\tTIFFGrowStrips() (found by Dmitry V. Levin).\n\n2004-09-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_compress.c}: Added TIFFGetConfiguredCODECs()\n\tto get the list of configured codecs.\n\n\t* libtiff/{tiffiop.h, tif_dirread.c}: More overflow fixes from\n\tDmitry V. Levin.\n\n2004-09-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Applied patch from Dmitry V. Levin to fix\n\tpossible integer overflow in CheckMalloc() function.\n\n2004-09-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_strip.c}: Use TIFFhowmany8() macro instead\n\tof plain TIFFhowmany() where appropriate.\n\n2004-09-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Initialize arrays after space allocation.\n\n2004-09-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0beta released.\n\n\t* libtiff/{tif_luv.c, tif_next.c, tif_thunder.c}: Several buffer\n\toverruns fixed, as noted by Chris Evans.\n\n2004-09-14  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* commit: Added a script to make it more convenient to commit\n\tupdates.  The CVS commit message is extracted from this ChangeLog\n\tfile.\n\n2004-09-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, configure, aclocal.m4, libtiff/{mkspans.c, tif_fax3.c,\n\ttif_getimage.c, tif_luv.c, tif_lzw.c, tif_ojpeg.c, tif_packbits.c,\n\ttif_predict.c, tif_read.c, tif_swab.c, tif_thunder.c, tif_write.c,\n\ttif_dir.c, tif_dirread.c, tif_dirwrite.c, tif_jpeg.c, tif_dirinfo.c,\n\ttif_vms.c, tif_print.c, tif_strip.c, tif_tile.c, tif_dir.h,\n\ttif_config.h.in, tiffiop.h}:\n\tGet rid of BSD data types (u_char, u_short, u_int, u_long).\n\n2004-09-13  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* libtiff/tiff.h: Fix column tagging. Reference current Adobe XMP\n\tspecification. Reference libtiff bug tracking system to submit\n\tprivate tag additions.\n\n2004-09-12  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* tools/tiffgt.c: Include \"tif_config.h\".\n\n\t* configure.ac: Use AM_PROG_CC_C_O since it is now needed to build\n\ttiffgt.  This results in the 'compile' script being added to the\n\tproject.\n\n\t* tools/Makefile.am (tiffgt_CFLAGS): Add extra build options\n\trequired to find OpenGL headers necessary to build tiffgt.  Also\n\tensure that the libtiff that we built is used rather than some other\n\tlibtiff installed on the system.\n\n2004-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, acinclude.m4, aclocal.m4: New macros to detect GLUT\n\tlibraries.\n\n2004-09-11  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n\n\t* configure.ac: Pass library configuration defines via\n\ttif_config.h rather than extending CPPFLAGS. Configure a\n\tlibtiff/tiffconf.h in order to satisfy application requirements\n\t(not used by library build). Do not define _POSIX_C_SOURCE=2 since\n\tthis causes failure to build on systems which properly respect\n\tthis request.\n\n\t* libtiff/tiffconf.h.in: New file to act as the template for the\n\tconfigured tiffconf.h\n\n\t* libtiff/files.lst (HDRS): Install the configured tiffconf.h.\n\n2004-09-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/internals.html: Split off a discussion of adding new tags\n\tinto addingtags.html.\n\n2004-09-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* test/{ascii_tag.c, long_tag.c}: Preliminary test suite added.\n\n\t* tools/tiff2pdf.c: Fixed reading TransferFunction tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n\t* libtiff/tif_print.c: Fixes in InkNames and NumberOfInks reporting.\n\n\t* libtiff/tif_dirread.c: Don't reject to read tags of the\n\tSamplesPerPixel size when the tag count is greater than number of\n\tsamples as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=576\n\n\t* libtiff/tiff.h: Use _TIFF_DATA_TYPEDEFS_ guardian to switch off\n\tdefining int8/uint8/... etc. types. As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=607\n\n2004-09-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c, tools/tiffmedian.c: fiddle with include files\n\tto avoid compile warnings about getopt() and a few other things.\n\n2004-09-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Use memcpy() function instead of pointer\n\tassigning magic in TIFFFetchFloat().\n\n2004-09-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_open.c}: Applied patches from Joris Van Damme\n\tto avoid requirement for tiffiop.h inclusion in some applications. See\n\there\n\n\thttp://www.asmail.be/msg0054799560.html\n\n\tfor details.\n\n\t* tools/fax2tiff.c: Use the new functions in the code.\n\n2004-08-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Initialize arrays properly.\n\n\t* tools/tiff2ps.c: Avoid zero division in setupPageState() function;\n\tproperly initialize array in PSDataBW().\n\n2004-08-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: More fixes for bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n\tfrom Ross Finlayson.\n\n2004-08-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed problem with uninitialized values.\n\n\t* libtiff/tif_dir.c: Initialize tif_foundfield data member in the\n\tTIFFDefaultDirectory() (in addition to 2004-08-19 fix).\n\n\t* tools/tiff2pdf.c: Fixed a bunch of problems as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=590\n\n2004-08-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Applied patch from Ross Finlayson that checks\n\tthat the input file has compression, photometric interpretation,\n\tetcetra, tags or if not than a more descriptive error is returned.\n\n\t* libtiff/tif_dirread.c: Fixed problem in TIFFReadDirectory() in the\n\tcode, responsible for tag data type checking.\n\n2004-08-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dirinfo.c}: Fixed problem with the static\n\tvariable as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=593\n\n2004-08-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ras2tiff.c: Fixed issue with missed big-endian checks as per\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=586\n\n2004-08-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_config.h.in, tif_config.h.vc}: config.h.in and\n\tconfig.h.vc files renamed in the tif_config.h.in and tif_config.h.vc.\n\n2004-07-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: LZW compression code is merged back from the\n\tseparate package. All libtiff tools are updated to not advertise an\n\tabcence of LZW support.\n\n2004-07-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffio.h: Revert thandle_t back to void* type.\n\n2004-07-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_read.c, tif_tile.c, tif_strip.c}: Fixes in error\n\tmessages, as suggested by Bernd Herd.\n\n2004-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Call TIFFError() instead of producing warnings\n\twhen setting custom tags by value. Reported by Eric Fieleke.\n\n2004-06-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tiff.c: Add missed RawsPerStrip setting.\n\n2004-06-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/bmp2tiff.c: Added new utility to convert Windows BMP files\n\tinto TIFFs.\n\n2004-06-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.7.0alpha released.\n\n2004-06-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiff.h, tif_dirwrite.c, tif_fax3.c, tif_packbits.c,}: Get rid\n\tof ugly 64-bit hacks, replace them with the clever (autoconf based )\n\tones :-).\n\n\t* libtiff/tiffio.h: Define thandle_t as int, not void* (may cause\n\tproblems in 64-bit environment).\n\n2004-06-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffset.c: tiffset now can set any libtiff supported tags.\n\tTags can be supplied by the mnemonic name or number.\n\n\t* libtiff/{tiffio.h, tif_dir.h, tif_dirinfo.c,}: Added two new\n\tfunctions TIFFFindFieldInfoByName() and TIFFFieldWithName().\n\n2004-05-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_ojpeg.c: Fixed problem with duplicated SOI and SOF\n\tmarkers as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=581\n\n2004-05-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Don't forget to copy Photometric\n\tInterpretation tag.\n\n2004-05-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_open.c, tiffio.h}: New function added:\n\tTIFFIsBigEndian(). Function returns nonzero if given was file written\n\tin big-endian order.\n\n\t* tools/tiffsplit.c: Fixed problem with unproperly written multibyte\n\tfiles. Now output files will be written using the same byte order\n\tflag as\tin the input image. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=574\n\n\tfor details.\n\n2004-05-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: added (untested) support for printing\n\tSSHORT, SLONG and SRATIONAL fields.\n\n\t* tools/tiffcp.c: close output file on normal exit.\n\n2004-05-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Avoid reading CCITT compression options\n\tif compression type mismatches. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=565\n\n2004-04-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_strip.c: Never return 0 from the\n\tTIFFNumberOfStrips().\n\n2004-04-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Workaround for broken TIFF writers which\n\tstore single SampleFormat value for multisampled images. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=562\n\n2004-04-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure.ac, libtiff/{tiff.h, config.h.in}: Added tests for int8,\n\tint16 and int32 types to avoid complains on some compilers. Details at\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2004-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2pdf.c: Fixed problem with unaligned access as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=555\n\n2004-04-14  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Allow in-place updating of the compressed\n\timages (don't work properly with all codecs). For details see GDAL bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=534\n\n2004-04-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_jpeg.c: Workaround for wrong sampling factors used\n\tin the Intergarph JPEG compressed TIFF images as per bug:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=532\n\n2004-04-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: close clientdata if TIFFClientOpen() fails\n\tvia bad2.\n\n2004-03-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Properly set Photometric Interpretation in case of\n\tJPEG compression of grayscale images.\n\n\t* tools/tiffcp.c: Don't emit warnings when Orientation tag does not\n\tpresent in the input image.\n\n2004-03-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* {many}: The first attempt to switch to autotools.\n\n2004-03-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Use dummy mmap/munmap functions in\n\tTIFFClientOpen() when the appropriate client functions was not\n\tsupplied by user.\n\n2004-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/ycbcr.c: fixed main() declaration as per:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=513\n\n2004-02-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffsplit.c: Copy JPEGTables tag contents for JPEG compressed\n\timages. Reported by Artem Mirolubov.\n\n\t* libtiff/tif_dirread.c: Fixed problem with handling TIFF_UNDEFINED\n\ttag type in TIFFFetchNormalTag() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=508\n\n2004-02-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_codec.c: Fixed typo in TIFFInitPackBits name as per:\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=494\n\n2004-02-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_fax3.c: Fixed problem with CCITT encoding modes as per\n\tbug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=483\n\n\tBut we need more work on fax codec to support update mode.\n\n2004-01-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Added TIFFCurrentDirOffset, TIFFWriteCheck,\n\tTIFFRGBAImageOK, and TIFFNumberOfDirectories as suggested by\n\tScott Reynolds.\n\n2004-01-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiff.h: Fixed tag definitions for TIFFTAG_YCLIPPATHUNITS\n\tand TIFFTAG_INDEXED as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=475\n\n\t* libtiff/{tif_win32.c, tif_unix.c}: Check whether the pointer is\n\tNULL before proceeding further as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=474\n\n\tCheck results, returned by the TIFFFdOpen() before returning and close\n\tfile if TIFFFdOpen() failed as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n\t* libtiff/tif_open.c: More fixes for\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n2004-01-28  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{libtiff.def, tif_close.c, tiffio.h, tif_open.c}: Separate\n\tTIFFCleanup() from the TIFFClose() in order to fix the bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=468\n\n\t* tools/tiffcp.c: Fixed problem with wrong interpretation of the\n\tInkNames tag as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=466\n\n\tMemory leak fixed.\n\n2004-01-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Fixed handling of writable ASCII tags that\n\tare field_passcount=TRUE properly.  Arguably anonymous custom tags\n\tshould be declared as passcount=FALSE, but I don't want to change\n\tthat without a careful review.\n\n2004-01-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_write.c: Fixed reporting size of the buffer in case of\n\tstripped image in TIFFWriteBufferSetup(). As per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=460\n\n2004-01-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Incomplete cleanup in TIFFFreeDirectory(),\n\tpatch from Gerben Koopmans.\n\n\t* libtiff/tif_dirread.c: Check field_passcount value before setting\n\tthe value of undefined type, patch from Gerben Koopmans.\n\n2004-01-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed problem with wrong Photometric setting for\n\tnon-RGB images.\n\n2003-12-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_win32.c: Fixed problem with _TIFFrealloc() when the NULL\n\tpointer passed. Patch supplied by Larry Grill.\n\n\t* libtiff/{tiff.h, tif_fax3.c}:Fixes for AMD 64 platform as\n\tsuggested by Jeremy C. Reed.\n\n2003-12-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff 3.6.1 released.\n\n2003-12-24  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* config.guess, config.sub: Updated from the recent upstream.\n\n2003-12-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_color, tif_getimage.c, tiffio.h}, man/TIFFcolor.3t:\n\tMore cleanups in color conversion interface, added appropriate manual\n\tpage.\n\n2003-12-19  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_extension.c, tif_dirinfo.c, tiff.h}: Warnings fixed as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=357\n\n\t* tools/tiff2ps.c: Added support for alpha channel. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=428\n\n\t* libtiff/{libtiff.def, tif_color.c, tif_getimage.c, tiffio.h}:\n\tInterface for Lab->RGB color conversion is finally cleaned up.\n\tAdded support for ReferenceBlackWhite tag handling when converted from\n\tYCbCr color space. The latter closes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=120\n\n2003-12-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tiffio.h}: Avoid warnings.\n\n\t* libtiff/makefile.vc, tools/makefile.vc: Support for IJG JPEG\n\tlibrary.\n\n2003-12-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_aux.c}: Read WhitePoint tag from the\n\tfile and properly use it for CIE Lab->RGB transform.\n\n2003-12-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_color.c, tiffio.h}: YCbCr->RGB\n\tconversion routines now in the tif_color.c module. New function\n\tTIFFYCbCrtoRGB() available in TIFF API.\n\n\t* libtiff/tif_dirwrite.c: Handle TIFF_IFD tag type correctly.\n\n2003-12-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tif_color.c, tiffio.h}: Improvements in\n\tCIE Lab conversion code. Start moving YCbCr stuff to the tif_color.c\n\tmodule.\n\n\t* libtiff/{tif_getimage.c, tiffio.h}, man{TIFFReadRGBAImage.3t,\n\tTIFFReadRGBAStrip.3t, TIFFReadRGBATile.3t, TIFFRGBAImage.3t}:\n\tFinally resolved problems with orientation handling. TIFFRGBAImage\n\tinterface now properly supports all possible orientations, i.e. images\n\twill be flipped both in horizontal and vertical directions if\n\trequired. 'Known bugs' section now removed from the appropriate manual\n\tpages. Closed bug entry:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=322\n\n2003-12-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dir.c: Fixed order of the parameters in TIFFError()\n\tfunction calls as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=440\n\n2003-11-28 Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* tools/tiff2pdf.c:  Some bugs fixed.\n\n2003-11-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_luv.c: Fixed bug in 48-bit to 24-bit conversion routine,\n\treported by Antonio Scuri.\n\n\t* man/tiff2pdf.1: Few improvements in page layout.\n\n\t* Makefile.in, /man/Makefile.in, /html/man/tiff2pdf.1.html:\n\t Added support fpr tiff2pdf manual page.\n\n2003-11-26 Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* /man/tiff2pdf.1:  File added to repository.\n\n2003-11-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in, /tools/{Makefile.in, makefile.vc}:\n\t Added support fpr tiff2pdf utility.\n\n2003-11-25  Ross Finlayson  <libtiff@apexinternetsoftware.com>\n\n\t* /tools/tiff2pdf.c:  File added to repository.\n\n2003-11-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/raw2tiff.c: sqrtf() replaced with sqrt().\n\n2003-11-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/raw2tiff.c: #include <getopt.h> removed.\n\n\t* tools/{Makefile.in, tiffgt.c}: Unmaintained and platform dependent\n\tsgigt utility removed and replaced with the completely rewritten\n\tportable tiffgt tool (depend on OpenGL and GLUT). Initial revision,\n\tthere is a lot of things to improve.\n\n\t* libtiff/tif_ojpeg.c: TIFFVGetField() function now can properly\n\textract the fields from the OJPEG files. Patch supplied by Ross\n\tFinlayson.\n\n\t* libtiff/{tiffio.h, tif_codec.c}, man/{libtiff.3t, TIFFcodec.3t}:\n\tAdded new function TIFFIsCODECConfigured(), suggested by Ross\n\tFinlayson.\n\n2003-11-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirinfo.c: Implemented binary search in\n\t_TIFFMergeFieldInfo(). Patch supplied by Ross Finlayson.\n\n\t* libtiff/tif_dir.h: _TIFFFindOrRegisterdInfo declaration replaced\n\twith _TIFFFindOrRegisterFieldInfo as reported by Ross Finlayson.\n\n2003-11-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: do not mark all anonymously defined tags to be\n\tIGNOREd.\n\n2003-11-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/pds/{tif_pdsdirread.c, tif_pdsdirwrite.c}: Use\n\tTIFFDataWidth() function insted of tiffDataWidth array.\n\n2003-11-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiff.h, tif_dirinfo.c}: Added support for IFD (13)\n\tdatatype, intruduced in \"Adobe PageMaker TIFF Tech. Notes\".\n\n2003-11-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Makefile.in: fixed missing backslash for tif_color.c in list.\n\n2003-11-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_color.c, tif_getimage.c, tiffio.h, Makefile.in}:\n\tNew color space conversion code: CIE L*a*b* 1976 images now supported\n\tby the TIFFRGBAImage interface. All introduced routines go to new\n\tmodule tif_color.c. Eventually all color conversion functions should\n\tbe moved there.\n\n2003-11-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{ras2tiff.c, rasterfile.h}: Properly determine SUN Rasterfiles\n\twith the reverse byte order (it is reported by the magic header\n\tfield). Problem reported by Andreas Wiesmann.\n\n\t* tools/raw2tiff.c, man/raw2tiff.1: Few improvements in correlation\n\tcalculation function. Guessing mechanics now documented in manual page.\n\n2003-11-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Implemented image size guessing using\n\tcorrelation coefficient calculation between two neighbour lines.\n\n2003-11-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_tile.c: remove spurious use of \"s\" (sample) in the\n\tplanarconfig_contig case in TIFFComputeTile().\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=387\n\n2003-11-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffiop.h: New macros: TIFFmax, TIFFmin and TIFFrint.\n\n2003-11-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffio.h, tif_strip.c}, man/{TIFFstrip.3t, libtiff.3t}:\n\tAdded TIFFRawStripSize() function as suggested by Chris Hanson.\n\n2003-11-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_lzw.c, tif_fax3.c}: Proper support for update mode as\n\tper bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=424\n\n2003-10-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added TIFFReadRGBAImageOriented.\n\n\t* html/build.html: Added note about GNU make requirement.\n\n2003-10-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Fixes in using MAKEFLAGS as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=418\n\n\t* port/install.sh.in: Option -p added to the mkdir command to create\n\tall directory tree structure before installing.\n\n2003-10-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/tiff2ps.c: #include <strings.h> replaced with the\n\t#include <string.h>.\n\n2003-10-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Add an absolute path to the test_pics.sh call.\n\n2003-10-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tiffcomp.h: #define _BSDTYPES_DEFINED when defining BSD\n\ttypedefs.\n\n2003-10-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, libtiff/{Makefile.in, mkversion.c}:\n\tRelative buildings fixed.\n\n\t* tools/Makefile.in: Added \"-I../libtiff\" to the tiffset building\n\trule.\n\n2003-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in: Added missed v3.6.0.html.\n\n\t* libtiff/tiffio.h: Typo fixed: ORIENTATION_BOTTOMLEFT replaced with\n\tORIENTATION_BOTLEFT.\n\n2003-10-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* 3.6.0 final release.\n\n2003-10-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tif_getimage.c, tiffio.h}, man/TIFFReadRGBAImage.3t: New\n\tfunction TIFFReadRGBAImageOriented() implemented to retrieve raster\n\tarray with user-specified origin position as suggested by Jason Frank.\n\tSee\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=322\n\n\tfor details.\n\n\t* tools/tiff2rgba.c: Switched to use TIFFReadRGBAImageOriented()\n\tinstead of TIFFReadRGBAImage().\n\n\t* tools/tiff2ps.c: Fixed possible endless loop as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=404\n\n2003-09-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Check field counter against number of fields\n\tin order to fix\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=366\n\n\t* libtiff/tif_fax3.c: Fix wrong line numbering as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=342\n\n2003-09-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/{tiffiop.h, tif_dirread.c, tif_dir.c, tif_open.c,\n\ttif_close.c}: Store a list of opened IFD to prevent looping as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=383\n\n2003-09-23  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: More fixes for\tEstimateStripByteCounts(). See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=358\n\n2003-08-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffmedian.c: int declaration replaced with the uint32 to\n\tsupport large images as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=382\n\n2003-08-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n \t* libtiff/Makefile.in: Fixed problem with building in different\n\tdirectory.\n\n\t* tools/tiff2ps.c: Added missing #include <strings.h>.\n\n\t* libtiff/tif_dirwrite.c: More fixes for custom tags code\n\tfrom Ashley Dreier.\n\n2003-08-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Added page size setting when creating PS Level 2.\n\tPatch submitted by Balatoni Denes (with corrections from Tom\n\tKacvinsky).\n\n\t* tools/tiff2ps.c: Fixed PS comment emitted when FlateDecode is\n\tbeing used. Reported by Tom Kacvinsky.\n\n\t* libtiff/tif_dirwrite.c: Fixed problem with custom tags writing,\n\treported by Ashley Dreier.\n\n\t* libtiff/tif_print.c: Fixed problem with float tags reading, support\n\tfor printing RATIONAL and BYTE tags added.\n\n2003-08-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: Move LZW codec state block allocation back to\n\tTIFFInitLZW(), because its initialization in LZWSetupDecode() cause\n\tproblems with predictor initialization. Remove O_RDONLY check during\n\tstate block allocation to be able open LZW compressed files in update\n\tmode.\n\n\tProblem exist for libtiff version of the tif_lzw.c module. One from\n\tlzw-compression-kit hasn't such troubles.\n\n2003-08-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: modified tif_write.c so that the various\n\tencoded write functions use tif_postdecode() to apply byte order\n\tswapping (swab) to the application passed data buffer if the same\n\twould be done when reading.  This allows us to write pixel data with\n\tmore than 8 bits per sample to existing files of a non-native byte\n\torder.  One side effect of this change is the applications buffer\n\titself is altered in this case by the act of writing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=171\n\n2003-07-25  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: avoid signed/unsigned casting warning\n\tinitializing typemask as per patch from J.A. Strother.\n\n\t* tools/tiffcp.c: fixed signed/unsigned casting warning.\n\n\t* libtiff/tif_print.c: dos2unix conversion.\n\n\t* tools/tiffsplit.c: increased the maximum number of pages that\n\tcan be split.  Patch provided by Andrew J. Montalenti.\n\n2003-07-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Added option `-p' to explicitly select color\n\tspace of input image data. Closes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=364\n\n2003-07-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_aux.c, tif_codec.c, tif_dir.c, tif_dirread.c, tif_extension.c,\n\ttif_fax3.c, tif_getimage.c, tif_luv.c, tif_lzw.c, tif_next.c,\n\ttif_packbits.c, tif_predict.c, tif_print.c, tif_swab.c, tif_thunder.c:\n\tavoid casting warning at /W4.\n\n2003-07-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/thumbnail.c: Memory leak fixed as reported by Robert S. Kissel.\n\n2003-06-30  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_pixarlog.c: Unused variables removed.\n\n\t* libtiff/{tif_dirread.c, tif_dir.c}: Fixed problem with\n\tEstimateStripByteCounts() as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=358\n\n\t* libtiff/{tif_dirwrite.c, tif_packbits.c}: Fixed compilation on\n\t64-bit architectures as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=357\n\n\t* libtiff/tif_dirinfo.c: TIFFDataWidth() returns 0 in case of\n\tunknown data type.\n\n2003-06-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_print.c: fixed some serious bugs when printing\n\tcustom tags ... almost certain to crash.\n\n\t* libtiff/tif_dirread.c: Don't ignore custom fields that are\n\tautodefined.  Not sure how this got to be like this.\n\n2003-06-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* 3.6.0 Beta2 released.\n\n\t* tools/tiffcmp.c, man/tiffcmp.1: Fixed problem with unused data\n\tcomparing as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=349\n\n\t`-z' option now can be used to set the number of reported different\n\tbytes.\n\n2003-06-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c, man/tiffcp.1: Added possibility to specify value -1\n\tto -r option to get the entire image as one strip. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=343\n\n\tfor details.\n\n2003-06-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Set the correct RowsPerStrip and PageNumber\n\tvalues as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=343\n\n2003-05-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: modified segment_height calculation to always\n\tbe a full height tile for tiled images.  Also changed error to just\n\tbe a warning.\n\n2003-05-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Page numbering fixed, as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=341\n\n2003-05-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/ojpeg/{Makefile.in, jdhuff.h, jinclude.h, ojpeg.c, README},\n\tconfigure, Makefile.in:\tSwitched back to the old behaviour. Likely\n\tbetter solution should be found for OJPEG support.\n\n2003-05-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/mkversion.c: Fixed problem with wrong string size when\n\treading RELEASE-DATE file.\n\n2003-05-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c: Fixed bug in Ascii85EncodeBlock() function: array\n\tindex was out of range.\n\n2003-05-06  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* contrib/ojpeg/{Makefile.in, jdhuff.h, jinclude.h, ojpeg.c, README},\n\tconfigure, Makefile.in:\tImproved libtiff compilation with OJPEG\n\tsupport. Now no need for patching IJG JPEG library, hack requred by\n\tlibtiff will be compiled and used in-place. Implemented with\n\tsuggestion and help from Bill Allombert, Debian's libjpeg maintainer.\n\n\t* libtiff/tif_aux.c: Properly handle TIFFTAG_PREDICTOR in\n\tTIFFVGetFieldDefaulted() function.\n\n2003-05-05  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: PPM header parser improved: now able to skip\n\tcomments.\n\n\t* tools/tiffdither.c: Fixed problem with bit fill order tag setting:\n\twas not copied from source image.\n\n\t* libtiff/getimage.c: Workaround for some images without correct\n\tinfo about alpha channel as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=331\n\n2003-04-29  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps.c, man/tiff2ps.1: Add ability to generate PS Level 3.\n\tIt basically allows one to use the /flateDecode filter for ZIP\n\tcompressed TIFF images. Patch supplied by Tom Kacvinsky. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=328\n\n\t* tools/tiff2ps.c: Force deadzone printing when EPS output specified\n\tas per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=325\n\n2003-04-17  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Removed additional check for StripByteCounts\n\tdue to problems with multidirectory images. Quality of error messages\n\timproved.\n\n2003-04-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiffcp.c: Fixed problem with colorspace conversion for JPEG\n\tencoded images. See bug entries\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=275\n\n\tand\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=23\n\n\t* libtiff/tif_dirread.c: Additional check for StripByteCounts\n\tcorrectness. Fixes\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=320\n\n2003-03-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/{fax2ps.c, fax2tiff.c, gif2tiff.c, pal2rgb.c, ppm2tiff.c,\n\tras2tiff.c, raw2tiff.c, rgb2ycbcr.c, thumbnail.c, tiff2bw.c,\n\ttiff2ps.c, tiff2rgba.c, tiffcp.c, tiffdither.c, tiffinfo.c,\n\ttiffmedian.c}: Added library version reporting facility to all tools.\n\n2003-03-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* port/install.sh.in: Fixed problems with install producing paths\n\tlike ///usr/local/lib on cygwin.\n\n2003-02-27  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c, man/fax2tiff.1: New switch (-X) to set width of\n\traw input page. Patch supplied by Julien Gaulmin. See\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=293\n\n\tfor details.\n\n2003-02-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fixed up the tif_postdecode settings\n\tresponsible for byte swapping complex image data.\n\n\t* libtiff/tif_lzw.c: fixed so that decoder state isn't allocated till\n\tLZWSetupDecode().  Needed to read LZW files in \"r+\" mode.\n\n2003-02-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/ppm2tiff.c: Fixed problem with too many arguments.\n\n2003-02-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/raw2tiff.c: Memory leak fixed.\n\n2003-02-03  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c, man/fax2tiff.1: Applied patch from Julien Gaulmin\n\t(thanks, Julien!). More switches for fax2tiff tool for better control\n\tof input and output. Details at\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=272\n\n2003-02-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Modified to defer initialization of jpeg\n\tlibrary so that we can check if there is already any tile/strip data\n\tbefore deciding between creating a compressor or a decompressor.\n\n2003-01-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_write.c: TIFFWriteCheck() now fails if the image is\n\ta pre-existing compressed image.  That is, image writing to\n\tpre-existing compressed images is not allowed.\n\n\t* libtiff/tif_open.c: Removed error if opening a compressed file\n\tin update mode.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=198\n\n2003-01-31  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* config.guess, config.sub: Updated to recent upstream versions.\n\n2003-01-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* cut 3.6.0 Beta release.\n\n2002-12-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2ps.c, man/fax2ps.1: Page size was determined\n\tin wrong way as per bug\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=239\n\n2002-12-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Allow wrong sized arrays in\n\tTIFFFetchStripThing().\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=49\n\n2002-12-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fix problem with test on td_customValueCount.\n\tWas using realloc even first time.  Fix by Igor Venevtsev.\n\n2002-11-30  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dir.c: fixed bug with resetting an existing custom\n\tfield value.\n\n\t* libtiff/tif_dir.c: Fixed potential problem with ascii \"custom\"\n\ttags in TIFFVGetField() ... added missing break.\n\n2002-10-14  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2ps.c: fixes a problem where \"tiff2ps -1e\" did not make\n\tthe scanline buffer long enough when writing rgb triplets.\n\tThe scanline needs to be 3 X the number of dots or else it will\n\tcontain\tan incomplete triplet and programs that try to separate\n\tthe eps by redefining the colorimage operator will get messed up.\n\tPatch supplied by William Bader.\n\n\t* Makefile.in: added tif_extension.c to file list as per\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=218.\n\n2002-10-11  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* configure, config.site, libtiff/{tif_unix.c, Makefile.in}: Fix for\n\tlarge files (>2GiB) supporting. New option in the config.site:\n\tLARGEFILE=\"yes\". Should be enough for I/O of the large files.\n\n2002-10-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/html/v3.6.0.html: new release notes.\n\n\t* libtiff/index.html: removed faq, cvs snapshot cruft.  Added email\n\tlink for Andrey.  Pointer to v3.6.0.html.\n\n\t* libtiff/Makefile.in: added direct rule for tiffvers.h for release.\n\n2002-10-07  Andrey Kiselev  <dron@ak4719.spb.edu>\n\t* tools/tiff2ps.c, man/tiff2ps.1: Applied patch form Sebastian Eken\n\t(thanks, Sebastian!). New switches:\n\t-b # for a bottom margin of # inches\n\t-c   center image\n\t-l # for a left margin of # inches\n\t-r   rotate the image by 180 degrees\n\tNew features merged with code for shrinking/overlapping.\n\tPreviously added -c and -n switches (for overriding PS units) renamed\n\tin -x and -y respectively.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=200\n\n\t* html/man/*.html: Updated from actual manual pages.\n\n2002-10-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: fixed problem with boolean defined with wrong\n\tsize on windows.  Use #define boolean hack.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=188\n\n\t* libtiff/tiff.h: Don't do special type handling in tiff.h unless\n\tUSING_VISUALAGE is defined.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2002-10-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: added COMPRESSION_JP2000.\n\n2002-10-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_dirread.c: Another fix for the fetching SBYTE arrays\n\tby the TIFFFetchByteArray() function. Should finally resolve\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=52\n\n\t* configure: Set -DPIXARLOG_SUPPORT option along with -DZIP_SUPPORT\n\n\t* html/Makefile.in: New targets added: html and groffhtml for\n\tproducing HTML representations of the manual pages automatically.\n\thtml target uses man2html tool, groffhtml uses groff tool.\n\n2002-09-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: Added SCO OpenServer 5.0.6 support\n\tfrom John H. DuBois III.\n\n2002-09-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* Makefile.in, /man/{raw2tiff.1, Makefile.in, libtiff.3}: Added\n\tmanual page for raw2tiff(1) tool.\n\n2002-09-12  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/{tiffio.h, tif_dir.h}: TIFFDataWidth() declaration moved to\n\tthe tiffio.h header file.\n\n\t* Makefile.in, /man/{TIFFDataWidth.3t, Makefile.in, libtiff.3}: Added\n\tmanual page for TIFFDataWidth() function\n\n2002-09-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirread.c: Expand v[2] to v[4] in TIFFFetchShortPair()\n\tas per http://bugzilla.remotesensing.org/show_bug.cgi?id=196.\n\n\t* tools/tiff2ps.c: Don't emit BeginData/EndData DSC comments\n\tsince we are unable to properly include the amount to skip.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=80\n\n2002-09-02  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/tif_dirread.c: Fixed problem with SBYTE type data fetching\n\tin TIFFFetchByteArray(). Problem described at\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=52\n\n2002-08-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/tif_dirinfo.c: Further additions to free custom fields\n\tin _TIFFSetupFieldInfo() function.\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=169 for details.\n\n\t* /libtiff/tif_lzw.c: Additional consistency checking added in\n\tLZWDecode() and LZWDecodeCompat().\n\tFixes http://bugzilla.remotesensing.org/show_bug.cgi?id=190\n\tand http://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n\t* /libtiff/tif_lzw.c:\n\tAdded check for valid code lengths in LZWDecode() and\n\tLZWDecodeCompat(). Fixes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=115\n\n2002-08-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /libtiff/{Makefile.vc, libtiff.def}:\n\tMissed declarations added.\n\n2002-08-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_getimage.c: Ensure that TIFFRGBAImageBegin() returns the\n\treturn code from the underlying pick function.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=177\n\n\t* tif_dir.h: changed FIELD_CODEC to 66 from 64 to avoid overlap\n\twith FIELD_CUSTOM as mentioned in bug 169.\n\n\t* tif_close.c: added logic to free dynamically created anonymous\n\tfield definitions to correct a small memory leak.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=169\n\n2002-08-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/{raw2tiff.c, Makefile.in, Makefile.lcc, Makefile.vc}:\n\tNew tool: raw2tiff --- raw images to TIFF converter. No manual page yet.\n\n2002-07-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Fixed problem with setting of nrows in\n\tJPEGDecode() as per bugzilla bug (issue 1):\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=129\n\n\t* libtiff/{tif_jpeg.c,tif_strip.c,tif_print.c}: Hacked tif_jpeg.c to\n\tfetch TIFFTAG_YCBCRSUBSAMPLING from the jpeg data stream if it isn't\n\tpresent in the tiff tags.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\n\t* libtiff/tif_read.c, libtiff/tif_write.c: TIFFReadScanline() and\n\tTIFFWriteScanline() now set tif_row explicitly in case the codec has\n\tfooled with the value.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=129\n\n2002-06-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* /tools/tiff2ps.c: Added workaround for some software that may crash\n\twhen last strip of image contains fewer number of scanlines than\n\tspecified by the `/Height' variable. See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=164\n\tfor explanation.\n\n2002-06-21  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps, man/tiff2ps.1: New functionality for tiff2ps utility:\n\tsplitting long images in several pages. See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=142 for explanation.\n\tPatch granted by John Williams <williams@morinda.com>.\n\n2002-06-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/contrib/win95: renamed to contrib/win_dib.  Added new\n\tTiffile.cpp example of converting TIFF files into a DIB on Win32.\n\tThis one is described in:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=143\n\n\t* libtiff/tif_ojpeg.c: Major upgrade from Scott.  See details at:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=156\n\n2002-05-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps: New commandline switches to override resolution\n\tunits obtained from the input file. Closes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=131\n\n2002-04-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed declaration.\n\n2002-04-22  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/fax2tiff.c: Updated to reflect latest changes in libtiff.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=125\n\n2002-04-20  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_open.c: Pointers to custom procedures\n\tin TIFFClientOpen() are checked to be not NULL-pointers.\n\n2002-04-18  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/libtiff.def: Added missed declarations.\n\n\t* libtiff/tif_pixarlog.c: Updated for using tif_tagmethods structure.\n\n2002-04-16  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_lzw.c: Additional checks for data integrity introduced.\n\tShould finally close\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n2002-04-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/tiff2ps: Division by zero fixed.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=88\n\n2002-04-09  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dirwrite.c, tif_write.c, tiffio.h:\n\tTIFFCheckpointDirectory() routine added.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=124\n\n\t* man/: TIFFWriteDirectory.3t,  Makefile.in: Added description\n\tfor the new function.\n\n2002-04-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_codec.c, tif_compress.c, tiffiop.h: Introduced\n\tadditional members tif->tif_decodestatus and tif->tif_encodestatus\n\tfor correct handling of unconfigured codecs (we should not try to read\n\tdata or to define data size without correct codecs).\n\n\t* libtiff/tif_getimage.c: The way of codecs checking in TIFFRGBAImageOK\n\tchanged. Now it has used tif->tif_decodestatus and\n\ttif->tif_encodestatus.\n\tShould fix http://bugzilla.remotesensing.org/show_bug.cgi?id=119 (in\n\tcase of __cvs_8.tif test image).\n\n\t* libtiff/: tif_dirinfo.c, tif_dirread.c: Somebody makes a bug in\n\ttif_dirread.c when TIFFCreateAnonFieldInfo was introduced.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=119 in case\n\tof _cvs_00000-00.tif, _cvs_00000-01.tif and _cvs_00000-02.tif.\n\n2002-04-04  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_lzw.c: Assertions in LZWDecode and LZWDecodeCompat\n\treplaced by warnings. Now libtiff should read corrupted LZW-compressed\n\tfiles by skipping bad strips.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=100\n\n2002-04-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: Removed some dead code.\n\n\t* libtiff/*: Cleanup some warnings.\n\n\t* libtiff/tif_dir.c: Fixed bug with count returned by TIFFGetField()\n\tfor variable length FIELD_CUSTOM values.  Was int * but should be\n\tu_short *.\n\n2002-04-01  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* tools/: tifcp.c: Added support for 'Orientation' tag in tiffcp\n\tutility (at cpStripToTile routine).\n\n2002-03-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirread.c: avoid div-by-zero if rowbytes is zero in chop func.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=111\n\n\t* tif_print.c: Fixed so that ASCII FIELD_CUSTOM values with\n\tpasscount set FALSE can be printed (such as TIFFTAG_SOFTWARE).\n\n\t* libtiff/tif_dir.c,tif_dirinfo.c,tif_dir.h,tif_ojpeg.c: modified so\n\tthat TIFFTAG_SOFTWARE uses FIELD_CUSTOM as an example.\n\n2002-03-26  Dwight Kelly  <dbmalloc@remotesensing.org>\n\n\t* libtiff/: tiff.h, tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_dirread.c,\n\ttif_dirwrite.c: Added get/put code for new tag XMLPACKET as defined\n\tin Adobe XMP Technote. Added missing INKSET tag value from TIFF 6.0 spec\n\tINKSET_MULTIINK (=2). Added missing tags from Adobe TIFF technotes:\n\tCLIPPATH, XCLIPPATHUNITS, YCLIPPATHUNITS, OPIIMAGEID, OPIPROXY and\n\tINDEXED. Added PHOTOMETRIC tag value from TIFF technote 4 ICCLAB (=9).\n\n2002-03-26  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_getimage.c: TIFFReadRGBAStrip and TIFFReadRGBATile\n\tnow also uses TIFFRGBAImageOK before reading. This is additional fix\n\tfor http://bugzilla.remotesensing.org/show_bug.cgi?id=110\n\n2002-03-25  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_getimage.c: Additional check for supported\n\tcodecs added in TIFFRGBAImageOK and TIFFReadRGBAImage now uses\n\tTIFFRGBAImageOK before reading.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=110\n\n2002-03-15  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dir.c, tif_dir.h, tif_dirinfo.c, tif_dirread.c,\n\ttif_dirwrite.c: Added routine TIFFDataWidth for detrmining\n\tTIFFDataType sizes instead of working with tiffDataWidth array\n\tdirectly. Should prevent out-of-borders bugs in case of unknown or\n\tbroken data types.  EstimateStripByteCounts routine modified, so it\n\twon't work when tags with uknown sizes founded.\n\tCloses http://bugzilla.remotesensing.org/show_bug.cgi?id=109\n\n2002-03-13  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/tif_getimage.c: Added support for correct handling\n\t`Orientation' tag in gtTileContig. Should be added in other gt*\n\tfunctions as well, but I have not images for testing yet. Partially\n\tresolves http://bugzilla.remotesensing.org/show_bug.cgi?id=23\n\n2002-03-10  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/: tif_dirinfo.c, tif_dirwrite.c: Added possibility to\n\tread broken TIFFs with LONG type used for TIFFTAG_COMPRESSION,\n\tTIFFTAG_BITSPERSAMPLE, TIFFTAG_PHOTOMETRIC.  Closes\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=99\n\n2002-03-08  Andrey Kiselev  <dron@ak4719.spb.edu>\n\n\t* libtiff/Makefile.in, tools/Makefile.in: Shared library will not\n\tbe stripped when installing, utility binaries will do.\tCloses\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=93\n\n2002-02-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/TIFFGetField: fixed type of TIFFTAG_COPYRIGHT.\n\n\t* man/libtiff.3t: added copyright tag info.\n\n2002-02-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/{tiff.h,tif_fax3.c}: Add support for __arch64__.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=94\n\n\t* man/Makefile.in: Patch DESTDIR handling\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=95\n\n\t* configure: OpenBSD changes for Sparc64 and DSO version.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=96\n\n2002-02-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* config.site/configure: added support for OJPEG=yes option to enable\n\tOJPEG support from config.site.\n\n2002-01-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/document.html: fixed links for TIFf 6 docs.\n\n2002-01-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* config.guess, config.sub: Updated from ftp.gnu.org/pub/config.\n\n\t* libtiff/tif_read.c: Fixed TIFFReadEncodedStrip() to fail if the\n\tdecodestrip function returns anything not greater than zero as per\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=97\n\n\t* configure: Modify CheckForBigEndian so it can work in a cross\n\tcompiled situation.\n\n2002-01-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiffdump.c: include TIFFTAG_JPEGTABLES in tag list.\n\n\t* tools/tiffset.c: fix bug in error reporting.\n\n\t* tools/tiffcp.c: fix several warnings that show up with -Wall.\n\n2002-01-04  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: fixed computation of segment_width for\n\ttiles files to avoid error about it not matching the\n\tcinfo.d.image_width values (\"JPEGPreDecode: Improper JPEG strip/tile\n\tsize.\") for ITIFF files.  Apparently the problem was incorporated since\n\t3.5.5, presumably during the OJPEG/JPEG work recently.\n\n2001-12-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: Changes for building on MacOS 10.1.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=94\n\n\t* libtiff/tif_getimage.c: If DEFAULT_EXTRASAMPLE_AS_ALPHA is 1\n\t(defined in tiffconf.h - 1 by default) then the RGBA interface\n\twill assume that a fourth extra sample is ASSOCALPHA if the\n\tEXTRASAMPLE value isn't set for it.  This changes the behaviour of\n\tthe library, but makes it work better with RGBA files produced by\n\tlots of applications that don't mark the alpha values properly.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=93\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=65\n\n2001-12-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: allow jpeg data stream sampling values to\n\toverride those from tiff directory.  This makes this work with\n\tImageGear generated files.\n\n2001-12-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/Makefile.in: added missing images per bug 92.\n\n\t* port/Makefile.in: fixed clean target per bug 92.\n\n2001-11-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Reissue 3.5.7 release.\n\n\t* libtiff/mkversion.c: Fix output of TIFF_VERSION to be\n\tYYYYMMDD so that it is increasing over time.\n\n\t* Makefile.in: Ensure that tiffvers.h is regenerated in the\n\tmake release target.\n\n\t* Makefile.in: added libtiff/tiffvers.h to the release file list.\n\n2001-11-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* added html/v3.5.7.html, updated html/index.html.\n\n\t* Makefile.in: added contrib/addtiffo/tif_ovrcache.{c,h}.\n\n2001-11-15  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure: fixed test for -lm.\n\n2001-11-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added PHOTOMETRIC_ITULAB as per bug 90.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=90\n\n2001-10-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: I have created COMPRESSION_CCITT_T4,\n\tCOMPRESSION_CCITT_T6, TIFFTAG_T4OPTIONS and TIFFTAG_T6OPTIONS aliases\n\tin keeping with TIFF 6.0 standard in tiff.h\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=83\n\n2001-09-26  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirwrite.c: added TIFFRewriteDirectory() function.\n\tUpdated TIFFWriteDirectory man page to include TIFFRewriteDirectory.\n\n2001-09-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_lzw.c: Avoid MS VC++ 5.0 optimization bug.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=78\n\n\t* libtiff/tif_lzw.c: added dummy LZWSetupEncode() to report an\n\terror about LZW not being available.\n\n\t* libtiff/tif_dir.c: propagate failure to initialize compression\n\tback from TIFFSetField() as an error status, so applications can\n\tdetect failure.\n\n\t* libtiff/tif_dir.c: removed the auto replacement of\n\tCOMPRESSION_LZW with COMPRESSION_NONE in _TIFFVSetField().\n\n\t* Removed Makefile, tools/Makefile, port/install.sh, man/Makefile\n\tfrom CVS as they are all supposed to be auto-generated by configure.\n\n2001-09-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: new update from Scott.\n\n2001-09-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtif/tif_fax3.c: Removed #ifdef PURIFY logic, and modified to\n\talways use the \"safe\" version, even if there is a very slight\n\tcost in performance.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=54\n\n\t* libtiff/Makefile.in: Fixed @DSOSUB_VERSION to be @DSOSUF_VERSION@\n\tin two places.\n\n\t* libtiff/tif_getimage.c: Fixed problem with reading strips or\n\ttiles that don't start on a tile boundary.  Fix contributed by\n\tJosep Vallverdu (from HP), and further described in bug 47.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=47\n\n\t* tools/tiff2ps.c: added OJPEG YCbCr to RGB support.\n\n\t* libtiff/tif_ojpeg.c: Applied substantial patch from Scott.\n\n2001-09-06  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_packbits.c: fixed memory overrun error.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=77\n\n2001-08-31  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: relax handling of contig case where\n\tthere are extra samples that are supposed to be ignored.  This\n\tshould now work for 8bit greyscale or palletted images.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=75\n\n2001-08-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Don't complain for CMYK (separated)\n\timages with more than four samples per pixel.  See:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=73\n\n2001-08-10  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Use memmove() instead of TIFFmemcpy()\n\tin TIFFReadRGBATile() to avoid issues in cases of overlapping\n\tbuffers.  See Bug 69 in Bugzilla.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=69\n\n\t* tools/tiff2rgba.c: fixed getopt() call so that -b works again.\n\n2001-08-09  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h, libtiff/tif_fax3.c: added check for __LP64__\n\twhen checking for 64 bit architectures as per bugzilla bug 67.\n\n2001-07-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* man/Makefile.in: add TIFFClientOpen link as per debian submitted\n\tbug 66.\n\n2001-07-20  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_jpeg.c: Define HAVE_BOOLEAN on windows if RPCNDR.H\n\thas been included.\n\n2001-07-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_open.c: Seek back to zero after failed read,\n\tbefore writing header.\n\n2001-07-18  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: updates from Scott.  Handles colors\n\tmuch better.  Now depends on having patched libjpeg as per\n\tpatch in contrib/ojpeg/*.\n\n2001-07-17  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* */Makefile.in: added DESTDIR support.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=60\n\n2001-07-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, libtiff/Makefile.in: applied OpenBSD patches\n\tas per:\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=61\n\n2001-06-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_getimage.c: Fixed so that failure is properly\n\treported by gtTileContig, gtStripContig, gtTileSeparate and\n\tgtStripSeparate.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=51\n\n\t* tiffcmp.c: Fixed multi samples per pixel support for ContigCompare.\n\tUpdated bug section of tiffcmp.1 to note tiled file issues.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=53\n\n2001-06-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure: Changes for DSO generation on AIX provided by\n\tJohn Marquart <jomarqua@indiana.edu>.\n\n\t* configure, libtiff/Makeifle.in: Modified to build DSOs properly\n\ton Darwin thanks to Robert Krajewski (rpk@alum.mit.edu) and\n\tKeisuke Fujii (fujiik@jlcuxf.kek.jp).\n\n2001-06-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tools/tiff2rgba.c: added -n flag to avoid emitting alpha component.\n\n\t* man/tiff2rgba.1: new\n\n2001-05-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added tiffset and tif_ojpeg to the dist lists in Makefile.in.\n\n2001-05-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tools/thumbnail.c: changed default output compression\n\tto packbits from LZW since LZW isn't generally available.\n\n2001-05-12  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_ojpeg.c: New.\n\tlibtiff/tif_jpeg.c, tiffconf.h, tif_getimage.c: changes related\n\tto OJPEG support.\n\n\tScott Marovich <marovich@hpl.hp.com> supplied OJPEG support.\n\n2001-05-11  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tiff.h: removed, it duplicates libtiff/tiff.h.\n\n2001-05-08  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: moved pixar and copyright flags to\n\tensure everything is in order.\n\n\t* libtiff/libtiff.def: added TIFFCreateDirectory and\n\tTIFFDefaultStripSize as per:\n\n\t  http://bugzilla.remotesensing.org/show_bug.cgi?id=46\n\n2001-05-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: Modified the TIFF_BYTE definition for\n\tTIFFTAG_PHOTOSHOP to use a writecount of TIFF_VARIABLE2 (-3) to\n\tforce use of uint32 counts instead of short counts.\n\n\t* libtiff/tif_dirwrite.c: Added support for TIFF_VARIABLE2 in the\n\tcase of writing TIFF_BYTE/TIFF_SBYTE fields.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=43\n\n2001-05-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_dirinfo.c: removed duplicate TIFFTAG_PHOTOSHOP as per\n\tbug report http://bugzilla.remotesensing.org/show_bug.cgi?id=44\n\n2001-04-05  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tiffio.h: removed C++ style comment.\n\n\t* configure: fixed up SCRIPT_SH/SHELL handling.\n\n\t* Makefile.in: Fixed SCRIPT_SH/SHELL handling.\n\n\t* config.guess: documented more variables as per bug 40.\n\n2001-04-03  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, *Makefile.in: Various changes to improve configuration\n\tfor HP/UX specifically, and also in general.  They include:\n\t - Try to handle /usr/bin/sh instead of /bin/sh where necessary.\n\t - Upgrade to HP/UX 10.x+ compiler, linker and dso options.\n\t - Fixed mmap() test to avoid MMAP_FIXED ... it isn't available on HP\n\t - Use -${MAKEFLAGS} in sub makes from makefiles.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=40\n\n2001-04-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiff.h: Applied hac to try and resolve the problem\n\twith the inttypes.h include file on AIX.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n\t* VERSION: update to 3.5.7 beta in preparation for release.\n\n\t* configure/config.site: modified to check if -lm is needed for\n\tMACHDEPLIBS if not supplied by config.site.  Needed for Darwin.\n\n\t* config.guess: updated wholesale to an FSF version apparently\n\tfrom 1998 (as opposed to 1994).  This is mainly inspired by\n\tproviding for MacOS X support.\n\n2001-03-29  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* configure, Makefile.in, etc: added support for OPTIMIZER being\n\tset from config.site.\n\n2001-03-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* fax2ps.c: Helge (libtiff at oldach.net) submitted fix:\n\n\tHere's a fix for fax2ps that corrects behaviour for non-Letter paper\n\tsizes. It fixes two problems:\n\n\tWithout\tscaling (-S) the fax is now centered on the page size specified\n\twith -H\tand/or -W. Before, fax2ps was using an obscure and practially\n\tuseless algorithm to allocate the image relative to Letter sized paper\n\twhich sometime sled to useless whitespace on the paper, while at the\n\tsame time cutting of the faxes printable area at the opposite border.\n\n\tSecond, scaling now preserves aspect ratio, which makes unusual faxes\n\t(in particular short ones) print properly.\n\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=35\n\n\t* tiff2ps.c/tiff2ps.1: Substantial changes to tiff2ps by\n\tBruce A. Mallett.  See check message for detailed information\n\ton all the changes, including a faster encoder, fixes for level\n\t2 PostScript, and support for the imagemask operator.\n\n2001-03-27  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tiffio.h: Changed \"#if LOGLUV_PUBLIC\" to\n\t\"#ifdef LOGLUV_PUBLIC\" so it will work with VisualAge on AIX.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=39\n\n2001-03-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_dirinfo.c: moved definition of copyright tag in field list.\n\tApparently they have to be in sorted order by tag id.\n\n2001-03-13  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_getimage.c: Added support for 16bit minisblack/miniswhite\n\timages in RGBA interface.\n\n2001-03-02  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added TIFFTAG_COPYRIGHT support.\n\n2001-02-19  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Brent Roman contributed updated tiffcp utility (and tiffcp.1)\n\twith support for extracting subimages with the ,n syntax, and also\n\tadding the -b bias removal flag.\n\n2001-02-16  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/libtiff.def: Brent Roman submitted new version adding\n\tserveral missing entry points.\n\n\t* libtiff/tif_dirinfo.c: don't declare tiffFieldInfo static on VMS.\n\tSome sort of weird VMS thing.\n\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=31\n\n\t* tif_luv.c/tiff.h/tiffio.h:\n\tNew version of TIFF LogLuv (SGILOG) modules contributed by Greg Ward\n\t(greg@shutterfly.com).  He writes:\n\n\t1) I improved the gamut-mapping function in tif_luv.c for imaginary\n\tcolors, because some images were being super-saturated on the input\n\tside and this resulted in some strange color shifts in the output.\n\n\t2) I added a psuedotag in tiff.h to control random dithering during\n\tLogLuv encoding.  This is turned off by default for 32-bit LogLuv and\n\ton for 24-bit LogLuv output.  Dithering improves the average color\n\taccuracy over the image.\n\n\t3) I added a #define for LOG_LUV_PUBLIC, which is enabled by default in\n\ttiffio.h, to expose internal routines for converting between LogLuv and\n\tXYZ coordinates.  This is helpful for writing more efficient,\n\tspecialized conversion routines, especially for reading LogLuv files.\n\n\tChanges applied with minor edits.\n\n2001-01-23  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* tif_fax3.c: keep rw_mode flag internal to fax3 state to remember\n\twhether we are encoding or decoding.  This is to ensure graceful\n\trecovery if TIFFClientOpen() discovers an attempt to open a compressed\n\tfile for \"r+\" access, and subsequently close it, as it resets the\n\ttif_mode flag to O_RDONLY in this case to avoid writes, confusing the\n\tcompressor's concept of whether it is in encode or decode mode.\n\n2001-01-08  Mike Welles <mike@bangstate.com>\n\n\t* Makefile.in:  Now cleaning up after itself after creating the .tar.gz and .zip\n\n2001-01-07  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* html/libtiff.html: Fixed arguments in example for TIFFRGBAImageGet()\n\tas per bug report by Patrick Connor.\n\n2000-12-28  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added RELEASE-DATE file to release file list.\n\n\t* Fixed libtiff/makefile.vc to make tiffvers.h not version.h.\n\n2000-12-22  Mike Welles <mike@bangstate.com>\n        * added link to CVS mirror from index.html\n\n\t* updated html/internals.html to note that LZW compression is\n\t  not supported by default.\n\n2000-12-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* updated html/libtiff.html to not point at Niles' old JPL web site\n\tfor the man pages, point at www.libtiff.org.\n\n2000-12-21  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/tif_apple.c: Applied \"Carbon\" support patches supplied by\n\tLeonard Rosenthol <leonardr@lazerware.com>.  May interfere\n\twith correct building on older systems.  If so, please let me know.\n\n2000-12-19 Mike Welles <mike@bangsate.com>\n\n\t* Took out LZW Encoding from tif_lzw.c\n\n\t* Created HOWTO-RELEASE\n\n\t* Created html/v3.5.6.html\n\n\t* updated index.html\n\n2000-12-01  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* Added patches for EOFB support in tif_fax3.c and tif_fax3.h.\n\tPatches supplied by Frank Cringle <fdc@cliwe.ping.de>\n\tExample file at: ftp://ftp.remotesensing.org/pub/libtiff/eofb_396.tif\n\n2000-11-24  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* libtiff/Makefile.in: Added an installPrivateHdrs and install-private\n\ttarget so that the private headers required by libgeotiff can be\n\tinstalled with the others.  They are not installed by default.\n\n\t* libtiff/Makefile.in: Added @MACHLIBDEPS@ to LINUXdso and GNULDdso\n\ttargets so libtiff.so will be built with an explicit dependency\n\ton libm.so.\n\n\t* libtiff/Makefile.in: Use softlinks to link libtiff.so.3 to\n\tlibtiff.so.3.5.5.\n\n\t* libtiff/Makefile.in & configure: Remove all references to the ALPHA\n\tfile, or ALPHA version logic.  Added stuff about DIST_POINT in\n\tplace of DIST_TYPE and the alpha release number stuff.\n\n2000-11-22  Frank Warmerdam  <warmerdam@pobox.com>\n\n\t* I have applied a patch from Steffen Moeller <moeller@ebi.ac.uk> to\n\tthe configure script so that it now accepts the --prefix, and\n\t--exec-prefix directives.\n\n2000-11-13  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* I have made a variety of modifications in an effort to ensure the\n\tTIFFLIB_VERSION macro is automatically generated from the RELEASE-DATE\n\tfile which seems to be updated regularly.\n\n\t o mkversion.c now reads RELEASE-DATE and emits TIFFLIB_VERSION in\n\t   version include file.\n\t o renamed version.h to tiffvers.h because we now have to install it\n\t   with the public libtiff include files.\n\t o include tiffvers.h in tiffio.h.\n\t o updated tif_version.c to use tiffvers.h.\n\t o Updated Makefile.in accordingly.\n\n\t* As per http://bugzilla.remotesensing.org/show_bug.cgi?id=25\n\tI have updated the win32 detection rules in tiffcomp.h.\n\n2000-10-20  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_getimage.c: Fixed RGBA translation for YCbCr images for which\n\tthe strip/tile width and height aren't multiples of the sampling size.\n\tSee http://bugzilla.remotesensing.org/show_bug.cgi?id=20\n\tSome patches from Rick LaMont of Dot C Software.\n\n\t* Modified tif_packbits.c encoder to avoid compressing more\n\tdata than provided if rowsize doesn't factor into provided data\n\t(such as occurs for YCbCr).\n\n2000-10-19  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tools/rgb2ycbcr.c: fixed output strip size to account for vertical\n\troundup if rows_per_strip not a multiple of vertical sample size.\n\n2000-10-16  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_dir.c: Clear TIFF_ISTILED flag in TIFFDefaultDirectory\n\tas per http://bugzilla.remotesensing.org/show_bug.cgi?id=18\n\tfrom vandrove@vc.cvut.cz.\n\n\t* Modified tif_packbits.c decoding to avoid overrunning the\n\toutput buffer, and to issue a warning if data needs to be\n\tdiscarded.  See http://bugzilla.remotesensing.org/show_bug.cgi?id=18\n\n2000-10-12  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Modified tiff2bw to ensure portions add to 100%, and that\n\twhite is properly recovered.\n\n\tSee bug http://bugzilla.remotesensing.org/show_bug.cgi?id=15\n\tPatch c/o Stanislav Brabec <utx@penguin.cz>\n\n2000-09-30  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Modified TIFFClientOpen() to emit an error on an attempt to\n\topen a comperessed file for update (O_RDWR/r+) access.  This is\n\tbecause the compressor/decompressor code gets very confused when\n\tthe mode is O_RDWR, assuming this means writing only.  See\n\tbug http://bugzilla.remotesensing.org/show_bug.cgi?id=13\n\n2000-09-27  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Added GNULDdso target an`d switched linux and freebsd to use it.\n\n2000-09-26  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Applied patch for 0x0000 sequences in tif_fax3.h's definition\n\tof EXPAND1D() as per bug 11 (from Roman).\n\n2000-09-25  Frank Warmerdam  <warmerda@cs46980-c>\n\t* Fixed tiffcomp.h to avoid win32 stuff if unix #defined, to improve\n\tcygwin compatibility.\n\n\t* Applied patch from Roman Shpount to tif_fax3.c.  This seems to\n\tbe a proper fix to the buffer sizing problem.  See\n\thttp://bugzilla.remotesensing.org/show_bug.cgi?id=11\n\n\t* Fixed tif_getimage.c to fix overrun bug with YCbCr images without\n\tdownsampling.  http://bugzilla.remotesensing.org/show_bug.cgi?id=10\n\tThanks to Nick Lamb <njl98r@ecs.soton.ac.uk> for reporting the\n\tbug and proving the patch.\n\n2000-09-18  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Fixed tif_jpeg.c so avoid destroying the decompressor before\n\twe are done access data thanks to bug report from:\n\tMichael Eckstein <eckstein@gepro.cz>.\n\n\t* Reverted tif_flush change.\n\n2000-09-14  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_flush.c: Changed so that TIFFFlushData() doesn't return an\n\terror when TIFF_BEENWRITING is not set.  This ensures that the\n\tdirectory contents can still be flushed by TIFFFlush().\n\n2000-08-14  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* tif_open.c: Don't set MMAP for O_RDWR files.\n\n\t* tif_open.c: Set STRIPCHOP_DEFAULT for O_RDWR as well as O_RDONLY\n\tso that files opened for update can be strip chopped too.\n\n\t* tif_read.c: fixed up bug with files missing rowsperstrip and\n\tthe strips per separation fix done a few weeks ago.\n\n2000-07-17  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Tentatively added support for SAMPLEFORMAT_COMPLEXIEEEFP, and\n\tSAMPLEFORMAT_COMPLEXINT.\n\n2000-07-13  Mike Welles <mike@onshore.com>\n\n\t* index.html, bugs.html: added bugzilla info.\n\n2000-07-12  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* tif_read.c: fix subtle bug with determining the number of\n\trows for strips that are the last strip in a separation but\n\tnot the last strip of all in TIFFReadEncodedStrip().\n\n\t* Applied 16/32 bit fix to tif_fax3.c.  Fix supplied by\n\tPeter Skarpetis <peters@serendipity-software.com.au>\n\n2000-06-15  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* Modified tiffio.h logic with regard to including windows.h.  It\n\twon't include it when building with __CYGWIN__.\n\n2000-05-11  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* README: update to mention www.libtiff.org, don't list Sam's old\n\temail address.\n\n\t* configure: Fixed DSO test for Linux as per patch from\n\t  Jan Van Buggenhout <chipzz@Ace.ULYSSIS.Student.KULeuven.Ac.Be>.\n\n2000-04-21  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* libtiff/tif_dirread.c: Don't use estimate strip byte count for\n\tone tile/strip images with an offset, and byte count of zero. These\n\tcould be \"unpopulated\" images.\n\n2000-04-18  Frank Warmerdam  <warmerda@rommel.atlsci.com>\n\n\t* contrib/addtiffo: Added \"averaging\" resampling option.\n\n\t* tools/tiffsplit.c: Copy TIFFTAG_SAMPLEFORMAT.\n\nTue Apr 18 16:18:08 2000  Frank Warmerdam  <warmerda@esabot.atlsci.com>\n\n\t* tools/Makefile.in: Modified to install properly on SGI.\n\n2000-04-12  Mike Welles\t     <mike@onshore.com>\n\t* configure:  Fixed stupid mistake in libc6 test on Linux\n\n2000-04-04  Mike Welles\t     <mike@onshore.com>\n\t* tif_win32.c:  Applied patch to fix overreads and ovverwrites\n\t  caught by BoundsChecker.  From Arvan Pritchard\n\t  <arvan.pritchard@infomatix.co.uk>  (untested).\n\n\t* tif_getimage.c:  Applied patch to silence VC6 warnings.  From\n\t  Arvan Pritchard <arvan.pritchard@informatix.co.uk>\n\n\t* tif_lzw.c:  Applied patch to silence VC6 warnings.  From\n\t  Arvan Pritchard <arvan.pritchard@informatix.co.uk>\n\n2000-03-28  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* Added contrib/stream (stream io) code submitted by Avi Bleiweiss.\n\n2000-03-28  Frank Warmerdam  <warmerda@cs46980-c>    *** 3.5.5 release ***\n\n\t* fax2ps: Fixed mixup of width and height in bounding box statement\n\tas per submission by Nalin Dahyabhai <nalin@redhat.com>.\n\n2000-03-27  Mike Welles\t     <mike@onshore.com>\n\n\t* fax2ps:  Modified printruns to take uint32 instead of uint16.\n\tPatch courtesy of Bernt Herd <herd@herdsoft.com>\n\n2000-03-20  Mike Welles\t     <mike@onshore.com>\n\n\t* configure: added test for libc6 for linux targets.  Bug reported by\n        Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* Added 3.5 docs to html/Makefile.in.\n\tThanks to  Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* configure: fixed bugs in sed scripts\n\t(applied sed script s:/@:s;@:;s:/s;;:;: to configure).\n\tfix submitted to Stanislav Brabec <utx@k332.feld.cvut.cz>\n\n\t* tools/iptcutil was not in files list, and wasn't being\n\tadded to tar archive.  Updated Makefile.in.\n\n2000-03-17  Frank Warmerdam  <warmerda@cs46980-c>\n\n\t* tif_fax3.c: Fixed serious bug introduced during the uint16->uint32\n\tconversion for the run arrays.\n\n2000-03-03  Frank Warmerdam  <warmerda@cs46980-c.mtnk1.on.wave.home.com>\n\n\t* Set td_sampleformat default to SAMPLEFORMAT_UINT instead of\n\tSAMPLEFORMAT_VOID in TIFFDefaultDirectory() in tif_dir.c.\n\n2000-03-02  Frank Warmerdam  <warmerda@cs46980-c.mtnk1.on.wave.home.com>\n\n\t* Added \"GetDefaulted\" support for TIFFTAG_SAMPLEFORMAT in tif_aux.c.\n\n\t* Patched tif_fax3.c so that dsp->runs is allocated a bit bigger\n\tto avoid overruns encountered with frle_bug.tif.\n\nTue Feb 15 22:01:05 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Fixed tools/tiffcmp so that stopondiff testing works.\n\t  Patch care of Joseph Orost <joe@sanskrit.lz.att.com>.\n\n2000-01-28    <warmerda@CS46980-B>\n\n\t* Modified tif_unix.c to support 2-4GB seeks if USE_64BIT_API is\n\t  set to 1, and added default (off) setting in tiffconf.h.  This\n\t  should eventually be set by the configure script somehow.\n\n\t  The original work on all these 2-4GB changes was done by\n\t  Peter Smith (psmith@creo.com).\n\n\t* Modified tif_win32.c to support 2-4GB seeks.\n\n\t* tentatively changed toff_t to be unsigned instead of signed to\n\t  facilitate support for 2-4GB files.\n\n\t* Updated a variety of files to use toff_t.  Fixed some mixups\n\t  between toff_t and tsize_t.\n\nFri Jan 28 10:13:49 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Largely reimplemented contrib/addtiffo to avoid temp files,\n\tupdating the TIFF file in place.  Fixed a few other bugs to.\n\n\t* Set tif_rawdatasize to zero when freeing raw data buffer in\n\tTIFFWriteDirectory().\n\n\t* Enabled \"REWRITE_HACK\" in tif_write.c by default.\n\n\t* Fix bug in tif_write.c when switching between reading one directory\n\tand writing to another.\n\n\t* Made TIFFWriteCheck() public, and added TIFFCreateDirectory()\n\nWed Jan  5 12:37:48 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added TIFFmemory(3t) functions to libtiff.def.\n\nTue Jan  4 13:39:00 2000  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added libtiff/libtiff.def to TIFFILES distribution list.\n\nMon Dec 27 12:13:39 EST 1999  Mike Welles <mike@onshore.com>\n\n\t* Created lzw compression kit, as a new module (libtiff-lzw-compression-kit).\n\n\t* Altered descriptions in tools to reflect \"by default\" lzw not supported\n\n\t* Updated index.html to note lzw compression kit.\n\nTue Dec 21 14:01:51 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added fax3sm_winnt.c to distribution list in Makefile.in.\n\nTue Dec 21 11:04:45 EST 1999  Mike Welles <mike@onshore.com> *** 3.5.4 release ***\n\n\t* Aadded Pixar tag support.  Contributed by Phil Beffery <phil@pixar.com>\n\n\t* Made one more change to tif_dir.c for removal of LZW compression. Also added notice\n\t  when LZW compression invoked.\n\n\t* Changed default compression in tools to TIFF_PACKBITS, and changed usage descriptions\n\t  in tools to reflect removal of LZW compression\n\nMon Dec 20 18:39:02 EST 1999  Mike Welles  <mike@onshore.com>\n\n        * Fixed bug that caused LZW (non) compression to segfault. Added\n\t  warning about LZW compression removed being removed, and why.\n\n\t* Added nostrip to install in tools/Makefile.in so that debugging\n\t  symbols are kept.\n\nTue Dec  7 12:04:47 EST 1999  Mike Welles  <mike@onshore.com>\n\n\t* Added patch from Ivo Penzar <ivo.penzar@infolink-software.com>,\n\t  supporting Adobe ZIP deflate.  Untested.\n\nSat Dec  4 15:47:11 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Made Packbits the default compression in tools/tiff2rgba.c instead\n\tof LZW.\n\nTue Nov 30 14:41:43 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>    *** 3.5.3. release ***\n\n\t* Added tif_luv to contrib/djgpp/Makefile.lib.\n\nTue Nov 30 14:15:32 EST 1999   Mike Welles <mike@onshore.com>\n\n        * Added zip creation to relase makefile target\n\n\t* Added html for TIFFWriteTile.3t man page.\n\nTue Nov 30 09:20:16 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added some changes to tif_write.c to support rewriting existing\n\tfixed sized tiles and strips.  Code mods disabled by default, only\n\tenabled if REWRITE_HACK is defined for now.\n\nMon Nov 29 11:43:42 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added TIFFWriteTile.3t man page.\n\nSun Nov 28 20:36:18 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added notes on use of makefile.vc in build.html, and fixed\n\temail subscription address.\n\n199-11-28  Mike Welles <mike@onshore.com>\n\n\t*  Fixed apocalypse-inducing y2k bug in contrib/ras/ras2tiff.c\n\n\t*  Did some casts cleaning up to reduce compiler warnings in tif_fax3.c,\n\t   from Bruce Carmeron <cameron@petris.com> -- modifications of\n\t   changes made by Frank (sun cc still complained on cast).\n\n\t*  Added tiffconf.h to install target per request from Bill\n\t   Radcliffe <billr@corbis.com>: \"We need a way for ImageMagick to\n \t   know features have been compiled into the TIFF library in order to\n\t   handle things properly\".\n\nSat Nov 27 16:49:21 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* fixed various VC++ warnings as suggested by Gilles Vollant\n\t<info@winimage.com>.\n\nWed Nov 24 12:08:16 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Modified TIFFquery.3t man pages info on TIFFIsByteSwapped() to\n\tnot imply applications are responsible for image data swapping.\n\n1999-11-22  Mike Welles <mike@onshore.com>\n\t*  HTML-ized the man pages, added to html/man\n\n\t*  Removed LZW Compression to comply with Unisys patent extortion.\n\n1999-09-29  Mike Welles\t\t<mike@onshore.com>\n\t*  Corrected one remaining 16 -> 32 bit value in tif_fax3.c,\n\t   From Ivo Penzar <ivo.penzar@infolink-software.com.\n\n\t*  Added patch from Ivo Penzar to have TiffAdvanceDirectory handle\n\t   memory mapped files. <ivo.penzar@infolink-software.com>\n\n1999-09-26  Mike Welles \t<mike@onshore.com>  *** 3.5.2 release ***\n\t* Corrected alpha versioning.\n\n\t* Removed distinction between  alpha and release targets in Makefile.in.\n\n\t* added release.stamp target, which tags cvs tree, and updates\n\t  \"RELEASE-DATE\"\n\n\t* added releasediff target, which diffs tree with source as of\n\t  date in \"RELEASE-DATE\"\n\n\t* Ticked up version to 3.5.2 (alpha 01 -- but I think we'll moving\n\t  away from alpha/non-alpha distinctions).\n\n\t* updated html to reflect release\n\n1999-09-23    <warmerda@CS46980-B>\n\n\t* Set O_BINARY for tif_unix.c open() ... used on cygwin for instance.\n\n\t* Added CYGWIN case in configure.\n\nFri Sep 17 00:13:51 CEST 1999  Mike Welles <mike@onshore.com>\n\n\t* Applied Francois Dagand's patch to handle fax decompression bug.\n\t  (sizes >= 65536 were failing)\n\nTue Sep 14 21:31:43 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Applied \"a\" mode fix to tif_win32.c/TIFFOpen() as suggested\n\t  by Christopher Lawton <clawton@mathworks.com>\n\nWed Sep  8 08:19:18 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added IRIX/gcc, and OSF/1 4.x support on behalf of\n\t  Albert Chin-A-Young <china@thewrittenword.com>\n\n\t* Added TIFFReassignTagToIgnore() API on behalf of\n\t  Bruce Cameron <cameron@petris.com>.  Man page still pending.\n\nWed Aug 25 11:39:07 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added test target in Makefile, test_pics.sh script and pics/*.rpt\n\tfiles to provide for a rudimentary testsuite.\n\n\t* Added contrib/tags back from old distribution ... fixed up a bit.\n\n1999-08-16    <warmerda@CS46980-B>\n\n\t* Added simple makefile.vc makefiles for building with MS VC++\n\ton Windows NT/98/95 in console mode.  Stuff in contrib/win* make give\n\tbetter solutions for some users.\n\nMon Aug 16 21:52:11 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* Added addtiffo (add overviews to a TIFF file) in contrib.  Didn't\n\tput it in tools since part of it is in C++.\n\n1999-08-16  Michael L. Welles  <mike@kurtz.fake>\n\n\t* Updated html/index.html with anon CVS instructions.\n\nMon Aug 16 13:18:41 1999  Frank Warmerdam  <warmerda@gdal.velocet.ca>\n\n\t* pre-remove so link before softlink in LINUXdso action in\n\tlibtiff/Makefile.in to avoid failure on LINUXdso builds other than\n\tthe first.\n\n\t* Fixed problem with cvtcmap() in tif_getimage.c modifying the\n\tcolormaps owned by the TIFF handle itself when trying to fixup wrong\n\t(eight bit) colormaps.  Corrected by maintaining a private copy of\n\tthe colormap.\n\n\t* Added TIFFReadRGBATile()/TIFFReadRGBAStrip() support in\n\ttif_getimage.c.\n\n\t* CVS Repository placed at remotesensing.org.  ChangeLog added.\n", "/* $Id$ */\n\n/* tiffcrop.c -- a port of tiffcp.c extended to include manipulations of\n * the image data through additional options listed below\n *\n * Original code:\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n * Additions (c) Richard Nolde 2006-2010 \n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS OR ANY OTHER COPYRIGHT  \n * HOLDERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL \n * DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, \n * DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND \n * ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE\n * OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Some portions of the current code are derived from tiffcp, primarly in \n * the areas of lowlevel reading and writing of TAGS, scanlines and tiles though\n * some of the original functions have been extended to support arbitrary bit\n * depths. These functions are presented at the top of this file.\n *\n * Add support for the options below to extract sections of image(s) \n * and to modify the whole image or selected portions of each image by\n * rotations, mirroring, and colorscale/colormap inversion of selected\n * types of TIFF images when appropriate. Some color model dependent \n * functions are restricted to bilevel or 8 bit per sample data.\n * See the man page for the full explanations.\n *\n * New Options: \n * -h             Display the syntax guide.\n * -v             Report the version and last build date for tiffcrop and libtiff.\n * -z x1,y1,x2,y2:x3,y3,x4,y4:..xN,yN,xN + 1, yN + 1 \n *                Specify a series of coordinates to define rectangular\n *                regions by the top left and lower right corners.\n * -e c|d|i|m|s   export mode for images and selections from input images\n *   combined     All images and selections are written to a single file (default)\n *                with multiple selections from one image combined into a single image\n *   divided      All images and selections are written to a single file\n *                with each selection from one image written to a new image\n *   image        Each input image is written to a new file (numeric filename sequence)\n *                with multiple selections from the image combined into one image\n *   multiple     Each input image is written to a new file (numeric filename sequence)\n *                with each selection from the image written to a new image\n *   separated    Individual selections from each image are written to separate files\n * -U units       [in, cm, px ] inches, centimeters or pixels\n * -H #           Set horizontal resolution of output images to #\n * -V #           Set vertical resolution of output images to #\n * -J #           Horizontal margin of output page to # expressed in current\n *                units when sectioning image into columns x rows \n *                using the -S cols:rows option.\n * -K #           Vertical margin of output page to # expressed in current\n *                units when sectioning image into columns x rows\n *                using the -S cols:rows option.\n * -X #           Horizontal dimension of region to extract expressed in current\n *                units\n * -Y #           Vertical dimension of region to extract expressed in current\n *                units\n * -O orient      Orientation for output image, portrait, landscape, auto\n * -P page        Page size for output image segments, eg letter, legal, tabloid,\n *                etc.\n * -S cols:rows   Divide the image into equal sized segments using cols across\n *                and rows down\n * -E t|l|r|b     Edge to use as origin\n * -m #,#,#,#     Margins from edges for selection: top, left, bottom, right\n *                (commas separated)\n * -Z #:#,#:#     Zones of the image designated as zone X of Y, \n *                eg 1:3 would be first of three equal portions measured\n *                from reference edge\n * -N odd|even|#,#-#,#|last \n *                Select sequences and/or ranges of images within file\n *                to process. The words odd or even may be used to specify\n *                all odd or even numbered images the word last may be used\n *                in place of a number in the sequence to indicate the final\n *                image in the file without knowing how many images there are.\n * -R #           Rotate image or crop selection by 90,180,or 270 degrees\n *                clockwise  \n * -F h|v         Flip (mirror) image or crop selection horizontally\n *                or vertically \n * -I [black|white|data|both]\n *                Invert color space, eg dark to light for bilevel and grayscale images\n *                If argument is white or black, set the PHOTOMETRIC_INTERPRETATION \n *                tag to MinIsBlack or MinIsWhite without altering the image data\n *                If the argument is data or both, the image data are modified:\n *                both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,\n *                data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag\n * -D input:<filename1>,output:<filename2>,format:<raw|txt>,level:N,debug:N\n *                Dump raw data for input and/or output images to individual files\n *                in raw (binary) format or text (ASCII) representing binary data\n *                as strings of 1s and 0s. The filename arguments are used as stems\n *                from which individual files are created for each image. Text format\n *                includes annotations for image parameters and scanline info. Level\n *                selects which functions dump data, with higher numbers selecting\n *                lower level, scanline level routines. Debug reports a limited set\n *                of messages to monitor progess without enabling dump logs.\n */\n\nstatic   char tiffcrop_version_id[] = \"2.4\";\nstatic   char tiffcrop_rev_date[] = \"12-13-2010\";\n\n#include \"tif_config.h\"\n#include \"tiffiop.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n\n#ifndef HAVE_GETOPT\nextern int getopt(int argc, char * const argv[], const char *optstring);\n#endif\n\n#ifdef NEED_LIBPORT\n# include \"libport.h\"\n#endif\n\n#include \"tiffio.h\"\n\n#if defined(VMS)\n# define unlink delete\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#define TIFF_UINT32_MAX     0xFFFFFFFFU\n\n#ifndef streq\n#define\tstreq(a,b)\t(strcmp((a),(b)) == 0)\n#endif\n#define\tstrneq(a,b,n)\t(strncmp((a),(b),(n)) == 0)\n\n#define\tTRUE\t1\n#define\tFALSE\t0\n\n#ifndef TIFFhowmany\n#define TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))\n#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)\n#endif\n\n/*\n * Definitions and data structures required to support cropping and image\n * manipulations.\n */\n\n#define EDGE_TOP      1\n#define EDGE_LEFT     2\n#define EDGE_BOTTOM   3\n#define EDGE_RIGHT    4\n#define EDGE_CENTER   5\n\n#define MIRROR_HORIZ  1\n#define MIRROR_VERT   2\n#define MIRROR_BOTH   3\n#define ROTATECW_90   8\n#define ROTATECW_180 16\n#define ROTATECW_270 32\n#define ROTATE_ANY (ROTATECW_90 | ROTATECW_180 | ROTATECW_270)\n\n#define CROP_NONE     0\n#define CROP_MARGINS  1\n#define CROP_WIDTH    2\n#define CROP_LENGTH   4\n#define CROP_ZONES    8\n#define CROP_REGIONS 16\n#define CROP_ROTATE  32\n#define CROP_MIRROR  64\n#define CROP_INVERT 128\n\n/* Modes for writing out images and selections */\n#define ONE_FILE_COMPOSITE       0 /* One file, sections combined sections */\n#define ONE_FILE_SEPARATED       1 /* One file, sections to new IFDs */\n#define FILE_PER_IMAGE_COMPOSITE 2 /* One file per image, combined sections */\n#define FILE_PER_IMAGE_SEPARATED 3 /* One file per input image */\n#define FILE_PER_SELECTION       4 /* One file per selection */\n\n#define COMPOSITE_IMAGES         0 /* Selections combined into one image */  \n#define SEPARATED_IMAGES         1 /* Selections saved to separate images */\n\n#define STRIP    1\n#define TILE     2\n\n#define MAX_REGIONS   8  /* number of regions to extract from a single page */\n#define MAX_OUTBUFFS  8  /* must match larger of zones or regions */\n#define MAX_SECTIONS 32  /* number of sections per page to write to output */\n#define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */\n#define MAX_SAMPLES   8  /* maximum number of samples per pixel supported */\n#define MAX_BITS_PER_SAMPLE 64 /* maximum bit depth supported */\n#define MAX_EXPORT_PAGES 999999  /* maximum number of export pages per file */\n\n#define DUMP_NONE   0\n#define DUMP_TEXT   1\n#define DUMP_RAW    2\n\n/* Offsets into buffer for margins and fixed width and length segments */\nstruct offset {\n  uint32  tmargin;\n  uint32  lmargin;\n  uint32  bmargin;\n  uint32  rmargin;\n  uint32  crop_width;\n  uint32  crop_length;\n  uint32  startx;\n  uint32  endx;\n  uint32  starty;\n  uint32  endy;\n};\n\n/* Description of a zone within the image. Position 1 of 3 zones would be \n * the first third of the image. These are computed after margins and \n * width/length requests are applied so that you can extract multiple \n * zones from within a larger region for OCR or barcode recognition.\n */\n\nstruct  buffinfo {\n  uint32 size;           /* size of this buffer */\n  unsigned char *buffer; /* address of the allocated buffer */\n};\n\nstruct  zone {\n  int   position;  /* ordinal of segment to be extracted */\n  int   total;     /* total equal sized divisions of crop area */\n  };\n\nstruct  pageseg {\n  uint32 x1;        /* index of left edge */\n  uint32 x2;        /* index of right edge */\n  uint32 y1;        /* index of top edge */\n  uint32 y2;        /* index of bottom edge */\n  int    position;  /* ordinal of segment to be extracted */\n  int    total;     /* total equal sized divisions of crop area */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped zone */\n};\n\nstruct  coordpairs {\n  double X1;        /* index of left edge in current units */\n  double X2;        /* index of right edge in current units */\n  double Y1;        /* index of top edge in current units */\n  double Y2;        /* index of bottom edge in current units */\n};\n\nstruct  region {\n  uint32 x1;        /* pixel offset of left edge */\n  uint32 x2;        /* pixel offset of right edge */\n  uint32 y1;        /* pixel offset of top edge */\n  uint32 y2;        /* picel offset of bottom edge */\n  uint32 width;     /* width in pixels */\n  uint32 length;    /* length in pixels */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped region */\n  unsigned char *buffptr; /* address of start of the region */\n};\n\n/* Cropping parameters from command line and image data \n * Note: This should be renamed to proc_opts and expanded to include all current globals\n * if possible, but each function that accesses global variables will have to be redone.\n */\nstruct crop_mask {\n  double width;           /* Selection width for master crop region in requested units */\n  double length;          /* Selection length for master crop region in requesed units */\n  double margins[4];      /* Top, left, bottom, right margins */\n  float  xres;            /* Horizontal resolution read from image*/\n  float  yres;            /* Vertical resolution read from image */\n  uint32 combined_width;  /* Width of combined cropped zones */\n  uint32 combined_length; /* Length of combined cropped zones */\n  uint32 bufftotal;       /* Size of buffer needed to hold all the cropped region */\n  uint16 img_mode;        /* Composite or separate images created from zones or regions */\n  uint16 exp_mode;        /* Export input images or selections to one or more files */\n  uint16 crop_mode;       /* Crop options to be applied */\n  uint16 res_unit;        /* Resolution unit for margins and selections */\n  uint16 edge_ref;        /* Reference edge for sections extraction and combination */\n  uint16 rotation;        /* Clockwise rotation of the extracted region or image */\n  uint16 mirror;          /* Mirror extracted region or image horizontally or vertically */\n  uint16 invert;          /* Invert the color map of image or region */\n  uint16 photometric;     /* Status of photometric interpretation for inverted image */\n  uint16 selections;      /* Number of regions or zones selected */\n  uint16 regions;         /* Number of regions delimited by corner coordinates */\n  struct region regionlist[MAX_REGIONS]; /* Regions within page or master crop region */\n  uint16 zones;           /* Number of zones delimited by Ordinal:Total requested */\n  struct zone zonelist[MAX_REGIONS]; /* Zones indices to define a region */\n  struct coordpairs corners[MAX_REGIONS]; /* Coordinates of upper left and lower right corner */\n};\n\n#define MAX_PAPERNAMES 49\n#define MAX_PAPERNAME_LENGTH 15\n#define DEFAULT_RESUNIT      RESUNIT_INCH\n#define DEFAULT_PAGE_HEIGHT   14.0\n#define DEFAULT_PAGE_WIDTH     8.5\n#define DEFAULT_RESOLUTION   300\n#define DEFAULT_PAPER_SIZE  \"legal\"\n\n#define ORIENTATION_NONE       0\n#define ORIENTATION_PORTRAIT   1\n#define ORIENTATION_LANDSCAPE  2\n#define ORIENTATION_SEASCAPE   4\n#define ORIENTATION_AUTO      16\n\n#define PAGE_MODE_NONE         0\n#define PAGE_MODE_RESOLUTION   1\n#define PAGE_MODE_PAPERSIZE    2\n#define PAGE_MODE_MARGINS      4\n#define PAGE_MODE_ROWSCOLS     8\n\n#define INVERT_DATA_ONLY      10\n#define INVERT_DATA_AND_TAG   11\n\nstruct paperdef {\n  char   name[MAX_PAPERNAME_LENGTH];\n  double width;\n  double length;\n  double asratio;\n  };\n\n/* European page sizes corrected from update sent by \n * thomas . jarosch @ intra2net . com on 5/7/2010\n * Paper Size       Width   Length  Aspect Ratio */\nstruct paperdef PaperTable[MAX_PAPERNAMES] = {\n  {\"default\",         8.500,  14.000,  0.607},\n  {\"pa4\",             8.264,  11.000,  0.751},\n  {\"letter\",          8.500,  11.000,  0.773},\n  {\"legal\",           8.500,  14.000,  0.607},\n  {\"half-letter\",     8.500,   5.514,  1.542},\n  {\"executive\",       7.264,  10.528,  0.690},\n  {\"tabloid\",        11.000,  17.000,  0.647},\n  {\"11x17\",          11.000,  17.000,  0.647},\n  {\"ledger\",         17.000,  11.000,  1.545},\n  {\"archa\",           9.000,  12.000,  0.750},\n  {\"archb\",          12.000,  18.000,  0.667},\n  {\"archc\",          18.000,  24.000,  0.750},\n  {\"archd\",          24.000,  36.000,  0.667},\n  {\"arche\",          36.000,  48.000,  0.750},\n  {\"csheet\",         17.000,  22.000,  0.773},\n  {\"dsheet\",         22.000,  34.000,  0.647},\n  {\"esheet\",         34.000,  44.000,  0.773},\n  {\"superb\",         11.708,  17.042,  0.687},\n  {\"commercial\",      4.139,   9.528,  0.434},\n  {\"monarch\",         3.889,   7.528,  0.517},\n  {\"envelope-dl\",     4.333,   8.681,  0.499},\n  {\"envelope-c5\",     6.389,   9.028,  0.708},\n  {\"europostcard\",    4.139,   5.833,  0.710},\n  {\"a0\",             33.110,  46.811,  0.707},\n  {\"a1\",             23.386,  33.110,  0.706},\n  {\"a2\",             16.535,  23.386,  0.707},\n  {\"a3\",             11.693,  16.535,  0.707},\n  {\"a4\",              8.268,  11.693,  0.707},\n  {\"a5\",              5.827,   8.268,  0.705},\n  {\"a6\",              4.134,   5.827,  0.709},\n  {\"a7\",              2.913,   4.134,  0.705},\n  {\"a8\",              2.047,   2.913,  0.703},\n  {\"a9\",              1.457,   2.047,  0.712},\n  {\"a10\",             1.024,   1.457,  0.703},\n  {\"b0\",             39.370,  55.669,  0.707},\n  {\"b1\",             27.835,  39.370,  0.707},\n  {\"b2\",             19.685,  27.835,  0.707},\n  {\"b3\",             13.898,  19.685,  0.706},\n  {\"b4\",              9.843,  13.898,  0.708},\n  {\"b5\",              6.929,   9.843,  0.704},\n  {\"b6\",              4.921,   6.929,  0.710},\n  {\"c0\",             36.102,  51.063,  0.707},\n  {\"c1\",             25.512,  36.102,  0.707},\n  {\"c2\",             18.031,  25.512,  0.707},\n  {\"c3\",             12.756,  18.031,  0.707},\n  {\"c4\",              9.016,  12.756,  0.707},\n  {\"c5\",              6.378,   9.016,  0.707},\n  {\"c6\",              4.488,   6.378,  0.704},\n  {\"\",                0.000,   0.000,  1.000}\n};\n\n/* Structure to define input image parameters */\nstruct image_data {\n  float  xres;\n  float  yres;\n  uint32 width;\n  uint32 length;\n  uint16 res_unit;\n  uint16 bps;\n  uint16 spp;\n  uint16 planar;\n  uint16 photometric;\n  uint16 orientation;\n  uint16 compression;\n  uint16 adjustments;\n};\n\n/* Structure to define the output image modifiers */\nstruct pagedef {\n  char          name[16];\n  double        width;    /* width in pixels */\n  double        length;   /* length in pixels */\n  double        hmargin;  /* margins to subtract from width of sections */\n  double        vmargin;  /* margins to subtract from height of sections */\n  double        hres;     /* horizontal resolution for output */\n  double        vres;     /* vertical resolution for output */\n  uint32        mode;     /* bitmask of modifiers to page format */\n  uint16        res_unit; /* resolution unit for output image */\n  unsigned int  rows;     /* number of section rows */\n  unsigned int  cols;     /* number of section cols */\n  unsigned int  orient;   /* portrait, landscape, seascape, auto */\n};\n\nstruct dump_opts {\n  int  debug;\n  int  format;\n  int  level;\n  char mode[4];\n  char infilename[PATH_MAX + 1];\n  char outfilename[PATH_MAX + 1];\n  FILE *infile;\n  FILE *outfile;\n  };\n\n/* globals */\nstatic int    outtiled = -1;\nstatic uint32 tilewidth = 0;\nstatic uint32 tilelength = 0;\n\nstatic uint16 config = 0;\nstatic uint16 compression = 0;\nstatic uint16 predictor = 0;\nstatic uint16 fillorder = 0;\nstatic uint32 rowsperstrip = 0;\nstatic uint32 g3opts = 0;\nstatic int    ignore = FALSE;\t\t/* if true, ignore read errors */\nstatic uint32 defg3opts = (uint32) -1;\nstatic int    quality = 100;\t\t/* JPEG quality */\n/* static int    jpegcolormode = -1;        was JPEGCOLORMODE_RGB;  */\nstatic int    jpegcolormode = JPEGCOLORMODE_RGB;\nstatic uint16 defcompression = (uint16) -1;\nstatic uint16 defpredictor = (uint16) -1;\nstatic int    pageNum = 0;\nstatic int    little_endian = 1;\n\n/* Functions adapted from tiffcp with additions or significant modifications */\nstatic int  readContigStripsIntoBuffer   (TIFF*, uint8*);\nstatic int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\nstatic int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\nstatic int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);\nstatic int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\nstatic int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t, \n                                         uint16, uint16, struct dump_opts *);\nstatic int processCompressOptions(char*);\nstatic void usage(void);\n\n/* All other functions by Richard Nolde,  not found in tiffcp */\nstatic void initImageData (struct image_data *);\nstatic void initCropMasks (struct crop_mask *);\nstatic void initPageSetup (struct pagedef *, struct pageseg *, struct buffinfo []);\nstatic void initDumpOptions(struct dump_opts *);\n\n/* Command line and file naming functions */\nvoid  process_command_opts (int, char *[], char *, char *, uint32 *,\n\t                    uint16 *, uint16 *, uint32 *, uint32 *, uint32 *,\n\t\t            struct crop_mask *, struct pagedef *, \n                            struct dump_opts *, \n                            unsigned int *, unsigned int *);\nstatic  int update_output_file (TIFF **, char *, int, char *, unsigned int *);\n\n\n/*  * High level functions for whole image manipulation */\nstatic int  get_page_geometry (char *, struct pagedef*);\nstatic int  computeInputPixelOffsets(struct crop_mask *, struct image_data *, \n                                     struct offset *);\nstatic int  computeOutputPixelOffsets (struct crop_mask *, struct image_data *,\n\t\t\t\t       struct pagedef *, struct pageseg *,\n                                       struct dump_opts *);\nstatic int  loadImage(TIFF *, struct image_data *, struct dump_opts *, unsigned char **);\nstatic int  correct_orientation(struct image_data *, unsigned char **);\nstatic int  getCropOffsets(struct image_data *, struct crop_mask *, struct dump_opts *);\nstatic int  processCropSelections(struct image_data *, struct crop_mask *, \n                                  unsigned char **, struct buffinfo []);\nstatic int  writeSelections(TIFF *, TIFF **, struct crop_mask *, struct image_data *,\n                            struct dump_opts *, struct buffinfo [],\n                            char *, char *, unsigned int*, unsigned int);\n\n/* Section functions */\nstatic int  createImageSection(uint32, unsigned char **);\nstatic int  extractImageSection(struct image_data *, struct pageseg *, \n                                unsigned char *, unsigned char *);\nstatic int  writeSingleSection(TIFF *, TIFF *, struct image_data *,\n                               struct dump_opts *, uint32, uint32,\n\t\t\t       double, double, unsigned char *);\nstatic int  writeImageSections(TIFF *, TIFF *, struct image_data *,\n                               struct pagedef *, struct pageseg *, \n                               struct dump_opts *, unsigned char *, \n                               unsigned char **);\n/* Whole image functions */\nstatic int  createCroppedImage(struct image_data *, struct crop_mask *, \n                               unsigned char **, unsigned char **);\nstatic int  writeCroppedImage(TIFF *, TIFF *, struct image_data *image,\n                              struct dump_opts * dump,\n                              uint32, uint32, unsigned char *, int, int);\n\n/* Image manipulation functions */\nstatic int rotateContigSamples8bits(uint16, uint16, uint16, uint32, \n                                    uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples16bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples24bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples32bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateImage(uint16, struct image_data *, uint32 *, uint32 *,\n \t\t       unsigned char **);\nstatic int mirrorImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\nstatic int invertImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\n\n/* Functions to reverse the sequence of samples in a scanline */\nstatic int reverseSamples8bits  (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples16bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples24bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples32bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamplesBytes  (uint16, uint16, uint32, uint8 *, uint8 *);\n\n/* Functions for manipulating individual samples in an image */\nstatic int extractSeparateRegion(struct image_data *, struct crop_mask *,\n\t\t \t\t unsigned char *, unsigned char *, int);\nstatic int extractCompositeRegions(struct image_data *,  struct crop_mask *,\n\t\t\t\t   unsigned char *, unsigned char *);\nstatic int extractContigSamples8bits (uint8 *, uint8 *, uint32,\n \t                             tsample_t, uint16, uint16, \n                                     tsample_t, uint32, uint32);\nstatic int extractContigSamples16bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples24bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples32bits (uint8 *, uint8 *, uint32,\n\t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamplesBytes (uint8 *, uint8 *, uint32, \n                                      tsample_t, uint16, uint16, \n\t\t\t\t      tsample_t, uint32, uint32);\nstatic int extractContigSamplesShifted8bits (uint8 *, uint8 *, uint32,\n \t                                     tsample_t, uint16, uint16,\n                                             tsample_t, uint32, uint32,\n                                             int);\nstatic int extractContigSamplesShifted16bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted24bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted32bits (uint8 *, uint8 *, uint32,\n\t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,\n  \t                                    uint32, uint32, tsample_t, uint16,\n\t\t\t\t\t    uint16, uint16, struct dump_opts *);\n\n/* Functions to combine separate planes into interleaved planes */\nstatic int combineSeparateSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                        uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t\t\tuint32, uint32, tsample_t, uint16,\n                                        FILE *, int, int);\n\nstatic int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                            uint32, uint32, uint16, uint16, \n                                            FILE *, int, int);\nstatic int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t  \t\t    uint32, uint32, uint32, uint32, \n                                            tsample_t, uint16, FILE *, int, int);\n\n/* Dump functions for debugging */\nstatic void dump_info  (FILE *, int, char *, char *, ...);\nstatic int  dump_data  (FILE *, int, char *, unsigned char *, uint32);\nstatic int  dump_byte  (FILE *, int, char *, unsigned char);\nstatic int  dump_short (FILE *, int, char *, uint16);\nstatic int  dump_long  (FILE *, int, char *, uint32);\nstatic int  dump_wide  (FILE *, int, char *, uint64);\nstatic int  dump_buffer (FILE *, int, uint32, uint32, uint32, unsigned char *);\n\n/* End function declarations */\n/* Functions derived in whole or in part from tiffcp */\n/* The following functions are taken largely intact from tiffcp */\n\nstatic   char* usage_info[] = {\n\"usage: tiffcrop [options] source1 ... sourceN  destination\",\n\"where options are:\",\n\" -h\t\tPrint this syntax listing\",\n\" -v\t\tPrint tiffcrop version identifier and last revision date\",\n\" \",\n\" -a\t\tAppend to output instead of overwriting\",\n\" -d offset\tSet initial directory offset, counting first image as one, not zero\",\n\" -p contig\tPack samples contiguously (e.g. RGBRGB...)\",\n\" -p separate\tStore samples separately (e.g. RRR...GGG...BBB...)\",\n\" -s\t\tWrite output in strips\",\n\" -t\t\tWrite output in tiles\",\n\" -i\t\tIgnore read errors\",\n\" \",\n\" -r #\t\tMake each strip have no more than # rows\",\n\" -w #\t\tSet output tile width (pixels)\",\n\" -l #\t\tSet output tile length (pixels)\",\n\" \",\n\" -f lsb2msb\tForce lsb-to-msb FillOrder for output\",\n\" -f msb2lsb\tForce msb-to-lsb FillOrder for output\",\n\"\",\n\" -c lzw[:opts]\t Compress output with Lempel-Ziv & Welch encoding\",\n\" -c zip[:opts]\t Compress output with deflate encoding\",\n\" -c jpeg[:opts] Compress output with JPEG encoding\",\n\" -c packbits\t Compress output with packbits encoding\",\n\" -c g3[:opts]\t Compress output with CCITT Group 3 encoding\",\n\" -c g4\t\t Compress output with CCITT Group 4 encoding\",\n\" -c none\t Use no compression algorithm on output\",\n\" \",\n\"Group 3 options:\",\n\" 1d\t\tUse default CCITT Group 3 1D-encoding\",\n\" 2d\t\tUse optional CCITT Group 3 2D-encoding\",\n\" fill\t\tByte-align EOL codes\",\n\"For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs\",\n\" \",\n\"JPEG options:\",\n\" #\t\tSet compression quality level (0-100, default 100)\",\n\" raw\t\tOutput color image as raw YCbCr\",\n\" rgb\t\tOutput color image as RGB\",\n\"For example, -c jpeg:rgb:50 to get JPEG-encoded RGB data with 50% comp. quality\",\n\" \",\n\"LZW and deflate options:\",\n\" #\t\tSet predictor value\",\n\"For example, -c lzw:2 to get LZW-encoded data with horizontal differencing\",\n\" \",\n\"Page and selection options:\",\n\" -N odd|even|#,#-#,#|last         sequences and ranges of images within file to process\",\n\"             The words odd or even may be used to specify all odd or even numbered images.\",\n\"             The word last may be used in place of a number in the sequence to indicate.\",\n\"             The final image in the file without knowing how many images there are.\",\n\"             Numbers are counted from one even though TIFF IFDs are counted from zero.\",\n\" \",\n\" -E t|l|r|b  edge to use as origin for width and length of crop region\",\n\" -U units    [in, cm, px ] inches, centimeters or pixels\",\n\" \",\n\" -m #,#,#,#  margins from edges for selection: top, left, bottom, right separated by commas\",\n\" -X #        horizontal dimension of region to extract expressed in current units\",\n\" -Y #        vertical dimension of region to extract expressed in current units\",\n\" -Z #:#,#:#  zones of the image designated as position X of Y,\",\n\"             eg 1:3 would be first of three equal portions measured from reference edge\",\n\" -z x1,y1,x2,y2:...:xN,yN,xN+1,yN+1\",\n\"             regions of the image designated by upper left and lower right coordinates\",\n\"\",\n\"Export grouping options:\",\n\" -e c|d|i|m|s    export mode for images and selections from input images.\",\n\"                 When exporting a composite image from multiple zones or regions\",\n\"                 (combined and image modes), the selections must have equal sizes\",\n\"                 for the axis perpendicular to the edge specified with -E.\",\n\"    c|combined   All images and selections are written to a single file (default).\",\n\"                 with multiple selections from one image combined into a single image.\",\n\"    d|divided    All images and selections are written to a single file\",\n\"                 with each selection from one image written to a new image.\",\n\"    i|image      Each input image is written to a new file (numeric filename sequence)\",\n\"                 with multiple selections from the image combined into one image.\",\n\"    m|multiple   Each input image is written to a new file (numeric filename sequence)\",\n\"                 with each selection from the image written to a new image.\",\n\"    s|separated  Individual selections from each image are written to separate files.\",\n\"\",\n\"Output options:\",\n\" -H #        Set horizontal resolution of output images to #\",\n\" -V #        Set vertical resolution of output images to #\",\n\" -J #        Set horizontal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" -K #        Set verticalal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" \",\n\" -O orient    orientation for output image, portrait, landscape, auto\",\n\" -P page      page size for output image segments, eg letter, legal, tabloid, etc\",\n\"              use #.#x#.# to specify a custom page size in the currently defined units\",\n\"              where #.# represents the width and length\",        \n\" -S cols:rows Divide the image into equal sized segments using cols across and rows down.\",\n\" \",\n\" -F hor|vert|both\",\n\"             flip (mirror) image or region horizontally, vertically, or both\",\n\" -R #        [90,180,or 270] degrees clockwise rotation of image or extracted region\",\n\" -I [black|white|data|both]\",\n\"             invert color space, eg dark to light for bilevel and grayscale images\",\n\"             If argument is white or black, set the PHOTOMETRIC_INTERPRETATION \",\n\"             tag to MinIsBlack or MinIsWhite without altering the image data\",\n\"             If the argument is data or both, the image data are modified:\",\n\"             both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,\",\n\"             data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag\",\n\" \",\n\"-D opt1:value1,opt2:value2,opt3:value3:opt4:value4\",\n\"             Debug/dump program progress and/or data to non-TIFF files.\",\n\"             Options include the following and must be joined as a comma\",\n\"             separate list. The use of this option is generally limited to\",\n\"             program debugging and development of future options.\",\n\" \",\n\"   debug:N   Display limited program progress indicators where larger N\",\n\"             increase the level of detail. Note: Tiffcrop may be compiled with\",\n\"             -DDEVELMODE to enable additional very low level debug reporting.\",\n\"\",\n\"   Format:txt|raw  Format any logged data as ASCII text or raw binary \",\n\"             values. ASCII text dumps include strings of ones and zeroes\",\n\"             representing the binary values in the image data plus identifying headers.\",\n\" \",\n\"   level:N   Specify the level of detail presented in the dump files.\",\n\"             This can vary from dumps of the entire input or output image data to dumps\",\n\"             of data processed by specific functions. Current range of levels is 1 to 3.\",\n\" \",\n\"   input:full-path-to-directory/input-dumpname\",\n\" \",\n\"   output:full-path-to-directory/output-dumpnaem\",\n\" \",\n\"             When dump files are being written, each image will be written to a separate\",\n\"             file with the name built by adding a numeric sequence value to the dumpname\",\n\"             and an extension of .txt for ASCII dumps or .bin for binary dumps.\",\n\" \",\n\"             The four debug/dump options are independent, though it makes little sense to\",\n\"             specify a dump file without specifying a detail level.\",\n\" \",\nNULL\n};\n\n/* This function could be modified to pass starting sample offset \n * and number of samples as args to select fewer than spp\n * from input image. These would then be passed to individual \n * extractContigSampleXX routines.\n */\nstatic int readContigTilesIntoBuffer (TIFF* in, uint8* buf, \n                                      uint32 imagelength, \n                                      uint32 imagewidth, \n                                      uint32 tw, uint32 tl,\n                                      tsample_t spp, uint16 bps)\n  {\n  int status = 1;\n  tsample_t sample = 0;\n  tsample_t count = spp; \n  uint32 row, col, trow;\n  uint32 nrow, ncol;\n  uint32 dst_rowsize, shift_width;\n  uint32 bytes_per_sample, bytes_per_pixel;\n  uint32 trailing_bits, prev_trailing_bits;\n  uint32 tile_rowsize  = TIFFTileRowSize(in);\n  uint32 src_offset, dst_offset;\n  uint32 row_offset, col_offset;\n  uint8 *bufp = (uint8*) buf;\n  unsigned char *src = NULL;\n  unsigned char *dst = NULL;\n  tsize_t tbytes = 0, tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(in);\n  unsigned char *tilebuf = NULL;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  tile_buffsize = tilesize;\n  if (tilesize == 0 || tile_rowsize == 0)\n  {\n     TIFFError(\"readContigTilesIntoBuffer\", \"Tile size or tile rowsize is zero\");\n     exit(-1);\n  }\n\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"readContigTilesIntoBuffer\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != (tile_buffsize / tile_rowsize))\n    {\n    \tTIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n        exit(-1);\n    }\n    }\n\n  /* Add 3 padding bytes for extractContigSamplesShifted32bits */\n  if( (size_t) tile_buffsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n  tilebuf = _TIFFmalloc(tile_buffsize + 3);\n  if (tilebuf == 0)\n    return 0;\n  tilebuf[tile_buffsize] = 0;\n  tilebuf[tile_buffsize+1] = 0;\n  tilebuf[tile_buffsize+2] = 0;\n\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n      if (tbytes < tilesize  && !ignore)\n        {\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\n\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n                  (unsigned long)tilesize);\n\t\t  status = 0;\n                  _TIFFfree(tilebuf);\n\t\t  return status;\n\t}\n      \n      row_offset = row * dst_rowsize;\n      col_offset = ((col * bps * spp) + 7)/ 8;\n      bufp = buf + row_offset + col_offset;\n\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      /* Each tile scanline will start on a byte boundary but it\n       * has to be merged into the scanline for the entire\n       * image buffer and the previous segment may not have\n       * ended on a byte boundary\n       */\n      /* Optimization for common bit depths, all samples */\n      if (((bps % 8) == 0) && (count == spp))\n        {\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n          bufp += (imagewidth * bps * spp) / 8;\n\t  }\n        }\n      else\n        {\n\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n        prev_trailing_bits = trailing_bits = 0;\n        trailing_bits = (ncol * bps * spp) % 8;\n\n\t/*\tfor (trow = 0; tl < nrow; trow++) */\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n          src = tilebuf + src_offset;\n\t  dst_offset = (row + trow) * dst_rowsize;\n          dst = buf + dst_offset + col_offset;\n          switch (shift_width)\n            {\n            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n                                                   spp, bps, count, 0, ncol))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 1: if (bps == 1)\n                      { \n                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n                                                            sample, spp,\n                                                            bps, count,\n                                                            0, ncol,\n                                                            prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t\t      break;\n\t\t      }\n                    else\n                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n                                                             sample, spp,\n                                                             bps, count,\n                                                             0, ncol,\n                                                             prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t            break;\n            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 3:\n            case 4:\n            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\n\t\t     return 1;\n\t    }\n          }\n        prev_trailing_bits += trailing_bits;\n        /* if (prev_trailing_bits > 7) */\n\t/*   prev_trailing_bits-= 8; */\n\t}\n      }\n    }\n\n  _TIFFfree(tilebuf);\n  return status;\n  }\n\nstatic int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp && s < MAX_SAMPLES; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }\n\nstatic int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)\n  {\n  uint32 row, nrows, rowsperstrip;\n  tstrip_t strip = 0;\n  tsize_t stripsize;\n\n  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  for (row = 0; row < imagelength; row += rowsperstrip)\n    {\n    nrows = (row + rowsperstrip > imagelength) ?\n\t     imagelength - row : rowsperstrip;\n    stripsize = TIFFVStripSize(out, nrows);\n    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)\n      {\n      TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n      return 1;\n      }\n    buf += stripsize;\n    }\n\n  return 0;\n  }\n\n/* Abandon plans to modify code so that plannar orientation separate images\n * do not have all samples for each channel written before all samples\n * for the next channel have been abandoned.\n * Libtiff internals seem to depend on all data for a given sample\n * being contiguous within a strip or tile when PLANAR_CONFIG is \n * separate. All strips or tiles of a given plane are written\n * before any strips or tiles of a different plane are stored.\n */\nstatic int \nwriteBufferToSeparateStrips (TIFF* out, uint8* buf, \n\t\t\t     uint32 length, uint32 width, uint16 spp,\n\t\t\t     struct dump_opts *dump)\n  {\n  uint8   *src;\n  uint16   bps;\n  uint32   row, nrows, rowsize, rowsperstrip;\n  uint32   bytes_per_sample;\n  tsample_t s;\n  tstrip_t strip = 0;\n  tsize_t  stripsize = TIFFStripSize(out);\n  tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);\n  tsize_t  total_bytes = 0;\n  tdata_t  obuf;\n\n  (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n  bytes_per_sample = (bps + 7) / 8;\n  if( width == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / width ||\n      bps * spp * width > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (bps * spp * width) + 7\");\n      return 1;\n  }\n  rowsize = ((bps * spp * width) + 7U) / 8; /* source has interleaved samples */\n  if( bytes_per_sample == 0 ||\n      rowsperstrip > TIFF_UINT32_MAX / bytes_per_sample ||\n      rowsperstrip * bytes_per_sample > TIFF_UINT32_MAX / (width + 1) )\n  {\n      TIFFError(TIFFFileName(out),\n                \"Error, uint32 overflow when computing rowsperstrip * \"\n                \"bytes_per_sample * (width + 1)\");\n      return 1;\n  }\n  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); \n\n  obuf = _TIFFmalloc (rowstripsize);\n  if (obuf == NULL)\n    return 1;\n  \n  for (s = 0; s < spp; s++)\n    {\n    for (row = 0; row < length; row += rowsperstrip)\n      {\n      nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;\n\n      stripsize = TIFFVStripSize(out, nrows);\n      src = buf + (row * rowsize);\n      total_bytes += stripsize;\n      memset (obuf, '\\0', rowstripsize);\n      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n        {\n        _TIFFfree(obuf);\n        return 1;\n\t}\n      if ((dump->outfile != NULL) && (dump->level == 1))\n        {\n        dump_info(dump->outfile, dump->format,\"\", \n                  \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\", \n                  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);\n        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\n\t}\n\n      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n        {\n\tTIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n\t_TIFFfree(obuf);\n\treturn 1;\n\t}\n      }\n    }      \n\n  _TIFFfree(obuf);\n  return 0;\n}\n\n/* Extract all planes from contiguous buffer into a single tile buffer \n * to be written out as a tile.\n */\nstatic int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts* dump)\n  {\n  uint16 bps;\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint32 tile_rowsize  = TIFFTileRowSize(out);\n  uint8* bufp = (uint8*) buf;\n  tsize_t tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(out);\n  unsigned char *tilebuf = NULL;\n\n  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||\n      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||\n      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )\n      return 1;\n\n  if (tilesize == 0 || tile_rowsize == 0 || tl == 0 || tw == 0)\n  {\n    TIFFError(\"writeBufferToContigTiles\", \"Tile size, tile row size, tile width, or tile length is zero\");\n    exit(-1);\n  }\n  \n  tile_buffsize = tilesize;\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"writeBufferToContigTiles\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != tile_buffsize / tile_rowsize)\n    {\n\tTIFFError(\"writeBufferToContigTiles\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    }\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n\n  tilebuf = _TIFFmalloc(tile_buffsize);\n  if (tilebuf == 0)\n    return 1;\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\", \n                  \"Unable to extract data to tile for row %lu, col %lu\",\n                  (unsigned long) row, (unsigned long)col);\n\t_TIFFfree(tilebuf);\n\treturn 1;\n        }\n\n      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\",\n\t          \"Cannot write tile at %lu %lu\",\n\t          (unsigned long) col, (unsigned long) row);\n\t _TIFFfree(tilebuf);\n\treturn 1;\n\t}\n      }\n    }\n  _TIFFfree(tilebuf);\n\n  return 0;\n  } /* end writeBufferToContigTiles */\n\n/* Extract each plane from contiguous buffer into a single tile buffer \n * to be written out as a tile.\n */\nstatic int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts * dump)\n  {\n  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint16 bps;\n  tsample_t s;\n  uint8* bufp = (uint8*) buf;\n\n  if (obuf == NULL)\n    return 1;\n\n  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7 )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      _TIFFfree(obuf);\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n         \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n\n      for (s = 0; s < spp; s++)\n        {\n\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)\n          {\n\t  TIFFError(\"writeBufferToSeparateTiles\", \n                    \"Unable to extract data to tile for row %lu, col %lu sample %d\",\n                    (unsigned long) row, (unsigned long)col, (int)s);\n\t  _TIFFfree(obuf);\n\t  return 1;\n          }\n\n\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)\n          {\n\t   TIFFError(\"writeBufferToseparateTiles\",\n\t             \"Cannot write tile at %lu %lu sample %lu\",\n\t             (unsigned long) col, (unsigned long) row,\n\t             (unsigned long) s);\n\t   _TIFFfree(obuf);\n\t   return 1;\n\t  }\n\t}\n      }\n    }\n  _TIFFfree(obuf);\n\n  return 0;\n  } /* end writeBufferToSeparateTiles */\n\nstatic void\nprocessG3Options(char* cp)\n{\n\tif( (cp = strchr(cp, ':')) ) {\n\t\tif (defg3opts == (uint32) -1)\n\t\t\tdefg3opts = 0;\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while( (cp = strchr(cp, ':')) );\n\t}\n}\n\nstatic int\nprocessCompressOptions(char* opt)\n  {\n  char* cp = NULL;\n\n  if (strneq(opt, \"none\",4))\n    {\n    defcompression = COMPRESSION_NONE;\n    }\n  else if (streq(opt, \"packbits\"))\n    {\n    defcompression = COMPRESSION_PACKBITS;\n    }\n  else if (strneq(opt, \"jpeg\", 4))\n    {\n    cp = strchr(opt, ':');\n    defcompression = COMPRESSION_JPEG;\n\n    while (cp)\n      {\n      if (isdigit((int)cp[1]))\n\tquality = atoi(cp + 1);\n      else if (strneq(cp + 1, \"raw\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RAW;\n      else if (strneq(cp + 1, \"rgb\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RGB;\n      else\n\tusage();\n      cp = strchr(cp + 1, ':');\n      }\n    }\n  else if (strneq(opt, \"g3\", 2))\n    {\n    processG3Options(opt);\n    defcompression = COMPRESSION_CCITTFAX3;\n    }\n  else if (streq(opt, \"g4\"))\n    {\n    defcompression = COMPRESSION_CCITTFAX4;\n    }\n  else if (strneq(opt, \"lzw\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_LZW;\n    }\n  else if (strneq(opt, \"zip\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_ADOBE_DEFLATE;\n   }\n  else\n    return (0);\n\n  return (1);\n  }\n\nstatic void\nusage(void)\n  {\n  int i;\n\n  fprintf(stderr, \"\\n%s\\n\", TIFFGetVersion());\n  for (i = 0; usage_info[i] != NULL; i++)\n    fprintf(stderr, \"%s\\n\", usage_info[i]);\n  exit(-1);\n  }\n\n#define\tCopyField(tag, v) \\\n    if (TIFFGetField(in, tag, &v)) TIFFSetField(out, tag, v)\n#define\tCopyField2(tag, v1, v2) \\\n    if (TIFFGetField(in, tag, &v1, &v2)) TIFFSetField(out, tag, v1, v2)\n#define\tCopyField3(tag, v1, v2, v3) \\\n    if (TIFFGetField(in, tag, &v1, &v2, &v3)) TIFFSetField(out, tag, v1, v2, v3)\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n    if (TIFFGetField(in, tag, &v1, &v2, &v3, &v4)) TIFFSetField(out, tag, v1, v2, v3, v4)\n\nstatic void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped\",\n                          tag, type);\n\t}\n}\n\nstatic struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n} tags[] = {\n\t{ TIFFTAG_SUBFILETYPE,\t\t1, TIFF_LONG },\n\t{ TIFFTAG_THRESHHOLDING,\t1, TIFF_SHORT },\n\t{ TIFFTAG_DOCUMENTNAME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_IMAGEDESCRIPTION,\t1, TIFF_ASCII },\n\t{ TIFFTAG_MAKE,\t\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_MODEL,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_MINSAMPLEVALUE,\t1, TIFF_SHORT },\n\t{ TIFFTAG_MAXSAMPLEVALUE,\t1, TIFF_SHORT },\n\t{ TIFFTAG_XRESOLUTION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_YRESOLUTION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_PAGENAME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_XPOSITION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_YPOSITION,\t\t1, TIFF_RATIONAL },\n\t{ TIFFTAG_RESOLUTIONUNIT,\t1, TIFF_SHORT },\n\t{ TIFFTAG_SOFTWARE,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_DATETIME,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_ARTIST,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_HOSTCOMPUTER,\t\t1, TIFF_ASCII },\n\t{ TIFFTAG_WHITEPOINT,\t\t(uint16) -1, TIFF_RATIONAL },\n\t{ TIFFTAG_PRIMARYCHROMATICITIES,(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_HALFTONEHINTS,\t2, TIFF_SHORT },\n\t{ TIFFTAG_INKSET,\t\t1, TIFF_SHORT },\n\t{ TIFFTAG_DOTRANGE,\t\t2, TIFF_SHORT },\n\t{ TIFFTAG_TARGETPRINTER,\t1, TIFF_ASCII },\n\t{ TIFFTAG_SAMPLEFORMAT,\t\t1, TIFF_SHORT },\n\t{ TIFFTAG_YCBCRCOEFFICIENTS,\t(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_YCBCRSUBSAMPLING,\t2, TIFF_SHORT },\n\t{ TIFFTAG_YCBCRPOSITIONING,\t1, TIFF_SHORT },\n\t{ TIFFTAG_REFERENCEBLACKWHITE,\t(uint16) -1,TIFF_RATIONAL },\n\t{ TIFFTAG_EXTRASAMPLES,\t\t(uint16) -1, TIFF_SHORT },\n\t{ TIFFTAG_SMINSAMPLEVALUE,\t1, TIFF_DOUBLE },\n\t{ TIFFTAG_SMAXSAMPLEVALUE,\t1, TIFF_DOUBLE },\n\t{ TIFFTAG_STONITS,\t\t1, TIFF_DOUBLE },\n};\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n\n#define\tCopyTag(tag, count, type)\tcpTag(in, out, tag, count, type)\n\n/* Functions written by Richard Nolde, with exceptions noted. */\nvoid  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32 *dirnum,\n\t                    uint16 *defconfig, uint16 *deffillorder, uint32 *deftilewidth,\n                            uint32 *deftilelength, uint32 *defrowsperstrip,\n\t\t            struct crop_mask *crop_data, struct pagedef *page, \n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hil:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'h':\tusage();\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unkown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': TIFFError(\"Library Release\", \"%s\", TIFFGetVersion());\n                TIFFError (\"Tiffcrop version\", \"%s, last updated: %s\", \n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n \t        TIFFError (\"Tiffcp code\", \"Copyright (c) 1988-1997 Sam Leffler\");\n\t\tTIFFError (\"           \", \"Copyright (c) 1991-1997 Silicon Graphics, Inc\");\n                TIFFError (\"Tiffcrop additions\", \"Copyright (c) 2007-2010 Richard Nolde\");\n\t        exit (0);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%d %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (-1);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (-1);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned ouput pages */ \n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned ouput pages*/ \n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (-1);                   \n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (-1);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (-1);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(-1);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (-1);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\t/*NOTREACHED*/\n      }\n    }\n  }  /* end process_command_opts */\n\n/* Start a new output file if one has not been previously opened or\n * autoindex is set to non-zero. Update page and file counters\n * so TIFFTAG PAGENUM will be correct in image.\n */\nstatic int \nupdate_output_file (TIFF **tiffout, char *mode, int autoindex,\n                    char *outname, unsigned int *page)\n  {\n  static int findex = 0;    /* file sequence indicator */\n  char  *sep;\n  char   filenum[16];\n  char   export_ext[16];\n  char   exportname[PATH_MAX];\n\n  if (autoindex && (*tiffout != NULL))\n    {   \n    /* Close any export file that was previously opened */\n    TIFFClose (*tiffout);\n    *tiffout = NULL;\n    }\n\n  strcpy (export_ext, \".tiff\");\n  memset (exportname, '\\0', PATH_MAX);\n\n  /* Leave room for page number portion of the new filename */\n  strncpy (exportname, outname, PATH_MAX - 16);\n  if (*tiffout == NULL)   /* This is a new export file */\n    {\n    if (autoindex)\n      { /* create a new filename for each export */\n      findex++;\n      if ((sep = strstr(exportname, \".tif\")) || (sep = strstr(exportname, \".TIF\")))\n        {\n        strncpy (export_ext, sep, 5);\n        *sep = '\\0';\n        }\n      else\n        strncpy (export_ext, \".tiff\", 5);\n      export_ext[5] = '\\0';\n\n      /* MAX_EXPORT_PAGES limited to 6 digits to prevent string overflow of pathname */\n      if (findex > MAX_EXPORT_PAGES)\n\t{\n\tTIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES);\n        return 1;\n        }\n\n      snprintf(filenum, sizeof(filenum), \"-%03d%s\", findex, export_ext);\n      filenum[14] = '\\0';\n      strncat (exportname, filenum, 15);\n      }\n    exportname[PATH_MAX - 1] = '\\0';\n\n    *tiffout = TIFFOpen(exportname, mode);\n    if (*tiffout == NULL)\n      {\n      TIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname);\n      return 1;\n      }\n    *page = 0; \n\n    return 0;\n    }\n  else \n    (*page)++;\n\n  return 0;\n  } /* end update_output_file */\n\n\nint\nmain(int argc, char* argv[])\n  {\n\n#if !HAVE_DECL_OPTARG\n  extern int optind;\n#endif\n  uint16 defconfig = (uint16) -1;\n  uint16 deffillorder = 0;\n  uint32 deftilewidth = (uint32) 0;\n  uint32 deftilelength = (uint32) 0;\n  uint32 defrowsperstrip = (uint32) 0;\n  uint32 dirnum = 0;\n\n  TIFF *in = NULL;\n  TIFF *out = NULL;\n  char  mode[10];\n  char *mp = mode;\n\n  /** RJN additions **/\n  struct image_data image;     /* Image parameters for one image */\n  struct crop_mask  crop;      /* Cropping parameters for all images */\n  struct pagedef    page;      /* Page definition for output pages */\n  struct pageseg    sections[MAX_SECTIONS];  /* Sections of one output page */\n  struct buffinfo   seg_buffs[MAX_SECTIONS]; /* Segment buffer sizes and pointers */\n  struct dump_opts  dump;                  /* Data dump options */\n  unsigned char *read_buff    = NULL;      /* Input image data buffer */\n  unsigned char *crop_buff    = NULL;      /* Crop area buffer */\n  unsigned char *sect_buff    = NULL;      /* Image section buffer */\n  unsigned char *sect_src     = NULL;      /* Image section buffer pointer */\n  unsigned int  imagelist[MAX_IMAGES + 1]; /* individually specified images */\n  unsigned int  image_count  = 0;\n  unsigned int  dump_images  = 0;\n  unsigned int  next_image   = 0;\n  unsigned int  next_page    = 0;\n  unsigned int  total_pages  = 0;\n  unsigned int  total_images = 0;\n  unsigned int  end_of_input = FALSE;\n  int    seg, length;\n  char   temp_filename[PATH_MAX + 1];\n\n  little_endian = *((unsigned char *)&little_endian) & '1';\n\n  initImageData(&image);\n  initCropMasks(&crop);\n  initPageSetup(&page, sections, seg_buffs);\n  initDumpOptions(&dump);\n\n  process_command_opts (argc, argv, mp, mode, &dirnum, &defconfig, \n                        &deffillorder, &deftilewidth, &deftilelength, &defrowsperstrip,\n\t                &crop, &page, &dump, imagelist, &image_count);\n\n  if (argc - optind < 2)\n    usage();\n\n  if ((argc - optind) == 2)\n    pageNum = -1;\n  else\n    total_images = 0;\n  /* read multiple input files and write to output file(s) */\n  while (optind < argc - 1)\n    {\n    in = TIFFOpen (argv[optind], \"r\");\n    if (in == NULL)\n      return (-3);\n\n    /* If only one input file is specified, we can use directory count */\n    total_images = TIFFNumberOfDirectories(in); \n    if (image_count == 0)\n      {\n      dirnum = 0;\n      total_pages = total_images; /* Only valid with single input file */\n      }\n    else\n      {\n      dirnum = (tdir_t)(imagelist[next_image] - 1);\n      next_image++;\n\n      /* Total pages only valid for enumerated list of pages not derived\n       * using odd, even, or last keywords.\n       */\n      if (image_count >  total_images)\n\timage_count = total_images;\n      \n      total_pages = image_count;\n      }\n\n    /* MAX_IMAGES is used for special case \"last\" in selection list */\n    if (dirnum == (MAX_IMAGES - 1))\n      dirnum = total_images - 1;\n\n    if (dirnum > (total_images))\n      {\n      TIFFError (TIFFFileName(in), \n      \"Invalid image number %d, File contains only %d images\", \n\t\t (int)dirnum + 1, total_images);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    if (dirnum != 0 && !TIFFSetDirectory(in, (tdir_t)dirnum))\n      {\n      TIFFError(TIFFFileName(in),\"Error, setting subdirectory at %d\", dirnum);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    end_of_input = FALSE;\n    while (end_of_input == FALSE)\n      {\n      config = defconfig;\n      compression = defcompression;\n      predictor = defpredictor;\n      fillorder = deffillorder;\n      rowsperstrip = defrowsperstrip;\n      tilewidth = deftilewidth;\n      tilelength = deftilelength;\n      g3opts = defg3opts;\n\n      if (dump.format != DUMP_NONE)\n        {\n        /* manage input and/or output dump files here */\n\tdump_images++;\n        length = strlen(dump.infilename);\n        if (length > 0)\n          {\n          if (dump.infile != NULL)\n            fclose (dump.infile);\n\n          /* dump.infilename is guaranteed to be NUL termimated and have 20 bytes \n             fewer than PATH_MAX */ \n          snprintf(temp_filename, sizeof(temp_filename), \"%s-read-%03d.%s\",\n\t\t   dump.infilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t    TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.infile, dump.format, \"Reading image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        length = strlen(dump.outfilename);\n        if (length > 0)\n          {\n          if (dump.outfile != NULL)\n            fclose (dump.outfile);\n\n          /* dump.outfilename is guaranteed to be NUL termimated and have 20 bytes \n             fewer than PATH_MAX */ \n          snprintf(temp_filename, sizeof(temp_filename), \"%s-write-%03d.%s\",\n\t\t   dump.outfilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t      TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.outfile, dump.format, \"Writing image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        }\n\n      if (dump.debug)\n         TIFFError(\"main\", \"Reading image %4d of %4d total pages.\", dirnum + 1, total_pages);\n\n      if (loadImage(in, &image, &dump, &read_buff))\n        {\n        TIFFError(\"main\", \"Unable to load source image\");\n        exit (-1);\n        }\n\n      /* Correct the image orientation if it was not ORIENTATION_TOPLEFT.\n       */\n      if (image.adjustments != 0)\n        {\n\tif (correct_orientation(&image, &read_buff))\n\t    TIFFError(\"main\", \"Unable to correct image orientation\");\n        }\n\n      if (getCropOffsets(&image, &crop, &dump))\n        {\n        TIFFError(\"main\", \"Unable to define crop regions\");\n        exit (-1);\n\t}\n\n      if (crop.selections > 0)\n        {\n        if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n          {\n          TIFFError(\"main\", \"Unable to process image selections\");\n          exit (-1);\n\t  }\n\t}\n      else  /* Single image segment without zones or regions */\n        {\n        if (createCroppedImage(&image, &crop, &read_buff, &crop_buff))\n          {\n          TIFFError(\"main\", \"Unable to create output image\");\n          exit (-1);\n\t  }\n\t}\n      if (page.mode == PAGE_MODE_NONE)\n        {  /* Whole image or sections not based on output page size */\n        if (crop.selections > 0)\n          {\n\t  writeSelections(in, &out, &crop, &image, &dump, seg_buffs,\n                          mp, argv[argc - 1], &next_page, total_pages);\n          }\n\telse  /* One file all images and sections */\n          {\n\t  if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1],\n                                  &next_page))\n             exit (1);\n          if (writeCroppedImage(in, out, &image, &dump,crop.combined_width, \n                                crop.combined_length, crop_buff, next_page, total_pages))\n            {\n             TIFFError(\"main\", \"Unable to write new image\");\n             exit (-1);\n\t    }\n          }\n\t}\n      else\n        {\n\t/* If we used a crop buffer, our data is there, otherwise it is\n         * in the read_buffer\n         */\n\tif (crop_buff != NULL)  \n\t  sect_src = crop_buff;\n        else\n          sect_src = read_buff;\n        /* Break input image into pages or rows and columns */\n        if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump))\n          {\n          TIFFError(\"main\", \"Unable to compute output section data\");\n          exit (-1);\n\t  }\n        /* If there are multiple files on the command line, the final one is assumed \n         * to be the output filename into which the images are written.\n         */\n\tif (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page))\n          exit (1);\n\n\tif (writeImageSections(in, out, &image, &page, sections, &dump, sect_src, &sect_buff))\n          {\n          TIFFError(\"main\", \"Unable to write image sections\");\n          exit (-1);\n\t  }\n        }\n\n      /* No image list specified, just read the next image */\n      if (image_count == 0)\n        dirnum++;\n      else\n        {\n\tdirnum = (tdir_t)(imagelist[next_image] - 1);\n        next_image++;\n        }\n\n      if (dirnum == MAX_IMAGES - 1)\n        dirnum = TIFFNumberOfDirectories(in) - 1;\n\n      if (!TIFFSetDirectory(in, (tdir_t)dirnum))\n        end_of_input = TRUE;\n      }\n    TIFFClose(in);\n    optind++;\n    }\n\n  /* If we did not use the read buffer as the crop buffer */\n  if (read_buff)\n    _TIFFfree(read_buff);\n\n  if (crop_buff)\n    _TIFFfree(crop_buff);\n\n  if (sect_buff)\n    _TIFFfree(sect_buff);\n\n   /* Clean up any segment buffers used for zones or regions */\n  for (seg = 0; seg < crop.selections; seg++)\n    _TIFFfree (seg_buffs[seg].buffer);\n\n  if (dump.format != DUMP_NONE)\n    {\n    if (dump.infile != NULL)\n     fclose (dump.infile);\n\n    if (dump.outfile != NULL)\n      {\n      dump_info (dump.outfile, dump.format, \"\", \"Completed run for %s\", TIFFFileName(out));\n      fclose (dump.outfile);\n      }\n    }\n\n  TIFFClose(out);\n\n  return (0);\n  } /* end main */\n\n\n/* Debugging functions */\nstatic int dump_data (FILE *dumpfile, int format, char *dump_tag, unsigned char *data, uint32 count)\n  {\n  int j, k;\n  uint32 i;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (i = 0; i < count; i++)\n      {\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n\tbitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n        }\n      dump_array[8] = '\\0';\n      fprintf (dumpfile,\" %s\", dump_array);\n      }\n    fprintf (dumpfile,\"\\n\");\n    }\n  else\n    {\n    if ((fwrite (data, 1, count, dumpfile)) != count)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_byte (FILE *dumpfile, int format, char *dump_tag, unsigned char data)\n  {\n  int j, k;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 7; j < 8; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      }\n    dump_array[8] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 1, 1, dumpfile)) != 1)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_short (FILE *dumpfile, int format, char *dump_tag, uint16 data)\n  {\n  int j, k;\n  char  dump_array[20];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 15; k >= 0; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[17] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 2, 1, dumpfile)) != 2)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic int dump_long (FILE *dumpfile, int format, char *dump_tag, uint32 data)\n  {\n  int j, k;\n  char  dump_array[40];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 31; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint32)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[35] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 4, 1, dumpfile)) != 4)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n  return (0);\n  }\n\nstatic int dump_wide (FILE *dumpfile, int format, char *dump_tag, uint64 data)\n  {\n  int j, k;\n  char  dump_array[80];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 63; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint64)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[71] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 8, 1, dumpfile)) != 8)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }\n\nstatic void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...)\n  {\n  if (format == DUMP_TEXT)\n    {\n    va_list ap;\n    va_start(ap, msg);\n    fprintf(dumpfile, \"%s \", prefix);\n    vfprintf(dumpfile, msg, ap);\n    fprintf(dumpfile, \"\\n\");\n    va_end(ap);\n    }\n  }\n\nstatic int dump_buffer (FILE* dumpfile, int format, uint32 rows, uint32 width, \n                 uint32 row, unsigned char *buff)\n  {\n  int j, k;\n  uint32 i;\n  unsigned char * dump_ptr;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  for (i = 0; i < rows; i++)\n    {\n    dump_ptr = buff + (i * width);\n    if (format == DUMP_TEXT)\n      dump_info (dumpfile, format, \"\", \n                 \"Row %4d, %d bytes at offset %d\",\n\t         row + i + 1, width, row * width);\n     \n    for (j = 0, k = width; k >= 10; j += 10, k -= 10, dump_ptr += 10)\n      dump_data (dumpfile, format, \"\", dump_ptr, 10);\n    if (k > 0)\n      dump_data (dumpfile, format, \"\", dump_ptr, k);\n    }\n  return (0);\n  }\n\n/* Extract one or more samples from an interleaved buffer. If count == 1,\n * only the sample plane indicated by sample will be extracted.  If count > 1, \n * count samples beginning at sample will be extracted. Portions of a \n * scanline can be extracted by specifying a start and end value.\n */\n\nstatic int \nextractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols, \n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int i, bytes_per_sample, sindex;\n  uint32 col, dst_rowsize, bit_offset;\n  uint32 src_byte /*, src_bit */;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  dst_rowsize = (bps * (end - start) * count) / 8;\n\n  bytes_per_sample = (bps + 7) / 8; \n  /* Optimize case for copying all samples */\n  if (count == spp)\n    {\n    src = in + (start * spp * bytes_per_sample);\n    _TIFFmemcpy (dst, src, dst_rowsize);\n    }\n  else\n    {\n    for (col = start; col < end; col++)\n      {\n      for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n        {\n        bit_offset = col * bps * spp;\n        if (sindex == 0)\n          {\n          src_byte = bit_offset / 8;\n          /* src_bit  = bit_offset % 8; */\n          }\n        else\n          {\n          src_byte = (bit_offset + (sindex * bps)) / 8;\n          /* src_bit  = (bit_offset + (sindex * bps)) % 8; */\n          }\n        src = in + src_byte;\n        for (i = 0; i < bytes_per_sample; i++)\n            *dst++ = *src++;\n        }\n      }\n    }\n\n  return (0);\n  } /* end extractContigSamplesBytes */\n\nstatic int\nextractContigSamples8bits (uint8 *in, uint8 *out, uint32 cols,\n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n  \n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end extractContigSamples8bits */\n\nstatic int\nextractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols, \n                            tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n\n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        { \n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamples16bits */\n\n\nstatic int\nextractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                    tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16) /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    } \n  \n  return (0);\n  } /* end extractContigSamples24bits */\n\nstatic int\nextractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,\n                            tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t    tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16)  | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 32)\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamples32bits */\n\nstatic int\nextractContigSamplesShifted8bits (uint8 *in, uint8 *out, uint32 cols,\n                                  tsample_t sample, uint16 spp, uint16 bps, \n\t\t\t          tsample_t count, uint32 start, uint32 end,\n \t                          int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n      if ((col == start) && (sindex == sample))\n        buff2 = *src & ((uint8)-1) << (shift);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ |= buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n\tbuff2 = buff2 | (buff1 >> ready_bits);\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end extractContigSamplesShifted8bits */\n\nstatic int\nextractContigSamplesShifted16bits (uint8 *in, uint8 *out, uint32 cols, \n                                   tsample_t sample, uint16 spp, uint16 bps, \n  \t\t\t           tsample_t count, uint32 start, uint32 end,\n \t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits = (uint16)-1 >> (16 - bps);\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint16)-1) << (8 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        buff2 = buff2 | (buff1 >> ready_bits);\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamplesShifted16bits */\n\n\nstatic int\nextractContigSamplesShifted24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                           tsample_t sample, uint16 spp, uint16 bps, \n                                   tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint32)-1) << (16 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16)  /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n   \n  return (0);\n  } /* end extractContigSamplesShifted24bits */\n\nstatic int\nextractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,\n                                   tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t           tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = shift;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      if ((col == start) && (sindex == sample))\n        buff2 = buff3 & ((uint64)-1) << (32 - shift);\n\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  } /* end extractContigSamplesShifted32bits */\n\nstatic int\nextractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                     tsample_t sample, uint16 spp, uint16 bps, \n                             struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row, first_col = 0;\n  uint32 dst_rowsize, dst_offset;\n  tsample_t count = 1;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src_rowsize = ((bps * spp * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols) + 7) / 8;\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, first_col, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, first_col, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  } /* end extractContigSamplesToBuffer */\n\nstatic int\nextractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,\n\t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row;\n  uint32 dst_rowsize, dst_offset;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToTileBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n\n  src_rowsize = ((bps * spp * imagewidth) + 7) / 8;\n  dst_rowsize = ((bps * tilewidth * count) + 7) / 8;\n\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, 0, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, 0, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, 0, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToTileBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  } /* end extractContigSamplesToTileBuffer */\n\nstatic int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n\n        return 1;\n} /* end readContigStripsIntoBuffer */\n\nstatic int \ncombineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,\n                             FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n\n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * spp * cols) + 7) / 8;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    row_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = row_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        src += bytes_per_sample;\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamplesBytes */\n\nstatic int\ncombineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                            uint32 rows, uint16 spp, uint16 bps, \n \t                    FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  /* int    bytes_per_sample = 0; */\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamples8bits */\n\nstatic int\ncombineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n \t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateSamples16bits */\n\nstatic int\ncombineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateSamples24bits */\n\nstatic int\ncombineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n          longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateSamples32bits */\n\nstatic int \ncombineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                                 uint32 cols, uint32 rows, uint32 imagewidth,\n                                 uint32 tw, uint16 spp, uint16 bps,\n                                 FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = imagewidth * bytes_per_sample * spp;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n#ifdef DEVELMODE\n    TIFFError(\"\",\"Tile row %4d, Src offset %6d   Dst offset %6d\", \n              row, src_offset, dst - out);\n#endif\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = src_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamplesBytes */\n\nstatic int\ncombineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                                 uint32 rows, uint32 imagewidth, \n                                 uint32 tw, uint16 spp, uint16 bps, \n \t                         FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamples8bits */\n\nstatic int\ncombineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  } /* end combineSeparateTileSamples16bits */\n\nstatic int\ncombineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateTileSamples24bits */\n\nstatic int\ncombineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\t  longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  } /* end combineSeparateTileSamples32bits */\n\n\nstatic int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  } /* end readSeparateStripsIntoBuffer */\n\nstatic int\nget_page_geometry (char *name, struct pagedef *page)\n    {\n    char *ptr;\n    int n; \n\n    for (ptr = name; *ptr; ptr++)\n      *ptr = (char)tolower((int)*ptr);\n\n    for (n = 0; n < MAX_PAPERNAMES; n++)\n      {\n      if (strcmp(name, PaperTable[n].name) == 0)\n        {\n\tpage->width = PaperTable[n].width;\n\tpage->length = PaperTable[n].length;\n        strncpy (page->name, PaperTable[n].name, 15);\n        page->name[15] = '\\0';\n        return (0);\n        }\n      }\n\n  return (1);\n  }\n\n\nstatic void\ninitPageSetup (struct pagedef *page, struct pageseg *pagelist, \n               struct buffinfo seg_buffs[])\n   {\n   int i; \n\n   strcpy (page->name, \"\");\n   page->mode = PAGE_MODE_NONE;\n   page->res_unit = RESUNIT_NONE;\n   page->hres = 0.0;\n   page->vres = 0.0;\n   page->width = 0.0;\n   page->length = 0.0;\n   page->hmargin = 0.0;\n   page->vmargin = 0.0;\n   page->rows = 0;\n   page->cols = 0;\n   page->orient = ORIENTATION_NONE;\n\n   for (i = 0; i < MAX_SECTIONS; i++)\n     {\n     pagelist[i].x1 = (uint32)0;\n     pagelist[i].x2 = (uint32)0;\n     pagelist[i].y1 = (uint32)0;\n     pagelist[i].y2 = (uint32)0;\n     pagelist[i].buffsize = (uint32)0;\n     pagelist[i].position = 0;\n     pagelist[i].total = 0;\n     }\n\n   for (i = 0; i < MAX_OUTBUFFS; i++)\n     {\n     seg_buffs[i].size = 0;\n     seg_buffs[i].buffer = NULL;\n     }\n   }\n\nstatic void\ninitImageData (struct image_data *image)\n  {\n  image->xres = 0.0;\n  image->yres = 0.0;\n  image->width = 0;\n  image->length = 0;\n  image->res_unit = RESUNIT_NONE;\n  image->bps = 0;\n  image->spp = 0;\n  image->planar = 0;\n  image->photometric = 0;\n  image->orientation = 0;\n  image->compression = COMPRESSION_NONE;\n  image->adjustments = 0;\n  }\n\nstatic void\ninitCropMasks (struct crop_mask *cps)\n   {\n   int i;\n\n   cps->crop_mode = CROP_NONE;\n   cps->res_unit  = RESUNIT_NONE;\n   cps->edge_ref  = EDGE_TOP;\n   cps->width = 0;\n   cps->length = 0;\n   for (i = 0; i < 4; i++)\n     cps->margins[i] = 0.0;\n   cps->bufftotal = (uint32)0;\n   cps->combined_width = (uint32)0;\n   cps->combined_length = (uint32)0;\n   cps->rotation = (uint16)0;\n   cps->photometric = INVERT_DATA_AND_TAG;\n   cps->mirror   = (uint16)0;\n   cps->invert   = (uint16)0;\n   cps->zones    = (uint32)0;\n   cps->regions  = (uint32)0;\n   for (i = 0; i < MAX_REGIONS; i++)\n     {\n     cps->corners[i].X1 = 0.0;\n     cps->corners[i].X2 = 0.0;\n     cps->corners[i].Y1 = 0.0;\n     cps->corners[i].Y2 = 0.0;\n     cps->regionlist[i].x1 = 0;\n     cps->regionlist[i].x2 = 0;\n     cps->regionlist[i].y1 = 0;\n     cps->regionlist[i].y2 = 0;\n     cps->regionlist[i].width = 0;\n     cps->regionlist[i].length = 0;\n     cps->regionlist[i].buffsize = 0;\n     cps->regionlist[i].buffptr = NULL;\n     cps->zonelist[i].position = 0;\n     cps->zonelist[i].total = 0;\n     }\n   cps->exp_mode = ONE_FILE_COMPOSITE;\n   cps->img_mode = COMPOSITE_IMAGES;\n   }\n\nstatic void initDumpOptions(struct dump_opts *dump)\n  {\n  dump->debug  = 0;\n  dump->format = DUMP_NONE;\n  dump->level  = 1;\n  sprintf (dump->mode, \"w\");\n  memset (dump->infilename, '\\0', PATH_MAX + 1);\n  memset (dump->outfilename, '\\0',PATH_MAX + 1);\n  dump->infile = NULL;\n  dump->outfile = NULL;\n  }\n\n/* Compute pixel offsets into the image for margins and fixed regions */\nstatic int\ncomputeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,\n                         struct offset *off)\n  {\n  double scale;\n  float xres, yres;\n  /* Values for these offsets are in pixels from start of image, not bytes,\n   * and are indexed from zero to width - 1 or length - 1 */\n  uint32 tmargin, bmargin, lmargin, rmargin;\n  uint32 startx, endx;   /* offsets of first and last columns to extract */\n  uint32 starty, endy;   /* offsets of first and last row to extract */\n  uint32 width, length, crop_width, crop_length; \n  uint32 i, max_width, max_length, zwidth, zlength, buffsize;\n  uint32 x1, x2, y1, y2;\n\n  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER)\n    {\n    xres = 1.0;\n    yres = 1.0;\n    }\n  else\n    {\n    if (((image->xres == 0) || (image->yres == 0)) && \n         (crop->res_unit != RESUNIT_NONE) &&\n\t((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||\n \t (crop->crop_mode & CROP_LENGTH)  || (crop->crop_mode & CROP_WIDTH)))\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Cannot compute margins or fixed size sections without image resolution\");\n      TIFFError(\"computeInputPixelOffsets\", \"Specify units in pixels and try again\");\n      return (-1);\n      }\n    xres = image->xres;\n    yres = image->yres;\n    }\n\n  /* Translate user units to image units */\n  scale = 1.0;\n  switch (crop->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (image->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (image->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  if (crop->crop_mode & CROP_REGIONS)\n    {\n    max_width = max_length = 0;\n    for (i = 0; i < crop->regions; i++)\n      {\n      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))\n        {\n\tx1 = (uint32) (crop->corners[i].X1 * scale * xres);\n\tx2 = (uint32) (crop->corners[i].X2 * scale * xres);\n\ty1 = (uint32) (crop->corners[i].Y1 * scale * yres);\n\ty2 = (uint32) (crop->corners[i].Y2 * scale * yres);\n        }\n      else\n        {\n\tx1 = (uint32) (crop->corners[i].X1);\n\tx2 = (uint32) (crop->corners[i].X2);\n\ty1 = (uint32) (crop->corners[i].Y1);\n\ty2 = (uint32) (crop->corners[i].Y2);       \n\t}\n      if (x1 < 1)\n        crop->regionlist[i].x1 = 0;\n      else\n        crop->regionlist[i].x1 = (uint32) (x1 - 1);\n\n      if (x2 > image->width - 1)\n        crop->regionlist[i].x2 = image->width - 1;\n      else\n        crop->regionlist[i].x2 = (uint32) (x2 - 1);\n      zwidth  = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1; \n\n      if (y1 < 1)\n        crop->regionlist[i].y1 = 0;\n      else\n        crop->regionlist[i].y1 = (uint32) (y1 - 1);\n\n      if (y2 > image->length - 1)\n        crop->regionlist[i].y2 = image->length - 1;\n      else\n        crop->regionlist[i].y2 = (uint32) (y2 - 1);\n\n      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1; \n\n      if (zwidth > max_width)\n        max_width = zwidth;\n      if (zlength > max_length)\n        max_length = zlength;\n\n      buffsize = (uint32)\n          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));\n\n      crop->regionlist[i].buffsize = buffsize;\n      crop->bufftotal += buffsize;\n      if (crop->img_mode == COMPOSITE_IMAGES)\n        {\n        switch (crop->edge_ref)\n          {\n          case EDGE_LEFT:\n          case EDGE_RIGHT:\n               crop->combined_length = zlength;\n               crop->combined_width += zwidth;\n               break;\n          case EDGE_BOTTOM:\n          case EDGE_TOP:  /* width from left, length from top */\n          default:\n               crop->combined_width = zwidth;\n               crop->combined_length += zlength;\n\t       break;\n          }\n\t}\n      }\n    return (0);\n    }\n  \n  /* Convert crop margins into offsets into image\n   * Margins are expressed as pixel rows and columns, not bytes\n   */\n  if (crop->crop_mode & CROP_MARGINS)\n    {\n    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n      { /* User has specified pixels as reference unit */\n      tmargin = (uint32)(crop->margins[0]);\n      lmargin = (uint32)(crop->margins[1]);\n      bmargin = (uint32)(crop->margins[2]);\n      rmargin = (uint32)(crop->margins[3]);\n      }\n    else\n      { /* inches or centimeters specified */\n      tmargin = (uint32)(crop->margins[0] * scale * yres);\n      lmargin = (uint32)(crop->margins[1] * scale * xres);\n      bmargin = (uint32)(crop->margins[2] * scale * yres);\n      rmargin = (uint32)(crop->margins[3] * scale * xres);\n      }\n\n    if ((lmargin + rmargin) > image->width)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined left and right margins exceed image width\");\n      lmargin = (uint32) 0;\n      rmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((tmargin + bmargin) > image->length)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined top and bottom margins exceed image length\"); \n      tmargin = (uint32) 0; \n      bmargin = (uint32) 0;\n      return (-1);\n      }\n    }\n  else\n    { /* no margins requested */\n    tmargin = (uint32) 0;\n    lmargin = (uint32) 0;\n    bmargin = (uint32) 0;\n    rmargin = (uint32) 0;\n    }\n\n  /* Width, height, and margins are expressed as pixel offsets into image */\n  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)crop->width;\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)crop->length;\n    else\n      length = image->length - tmargin - bmargin;\n    }\n  else\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)(crop->width * scale * image->xres);\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)(crop->length * scale * image->yres);\n    else\n      length = image->length - tmargin - bmargin;\n    }\n\n  off->tmargin = tmargin;\n  off->bmargin = bmargin;\n  off->lmargin = lmargin;\n  off->rmargin = rmargin;\n\n  /* Calculate regions defined by margins, width, and length. \n   * Coordinates expressed as 0 to imagewidth - 1, imagelength - 1,\n   * since they are used to compute offsets into buffers */\n  switch (crop->edge_ref) {\n    case EDGE_BOTTOM:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         endy = image->length - bmargin - 1;\n         if ((endy - length) <= tmargin)\n           starty = tmargin;\n         else\n           starty = endy - length + 1;\n         break;\n    case EDGE_RIGHT:\n         endx = image->width - rmargin - 1;\n         if ((endx - width) <= lmargin)\n           startx = lmargin;\n         else\n           startx = endx - width + 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    case EDGE_TOP:  /* width from left, length from top */\n    case EDGE_LEFT:\n    default:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    }\n  off->startx = startx;\n  off->starty = starty;\n  off->endx   = endx;\n  off->endy   = endy;\n\n  crop_width  = endx - startx + 1;\n  crop_length = endy - starty + 1;\n\n  if (crop_width <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n               \"Invalid left/right margins and /or image crop width requested\");\n    return (-1);\n    }\n  if (crop_width > image->width)\n    crop_width = image->width;\n\n  if (crop_length <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n              \"Invalid top/bottom margins and /or image crop length requested\");\n    return (-1);\n    }\n  if (crop_length > image->length)\n    crop_length = image->length;\n\n  off->crop_width = crop_width;\n  off->crop_length = crop_length;\n\n  return (0);\n  } /* end computeInputPixelOffsets */\n\n/* \n * Translate crop options into pixel offsets for one or more regions of the image.\n * Options are applied in this order: margins, specific width and length, zones,\n * but all are optional. Margins are relative to each edge. Width, length and\n * zones are relative to the specified reference edge. Zones are expressed as\n * X:Y where X is the ordinal value in a set of Y equal sized portions. eg.\n * 2:3 would indicate the middle third of the region qualified by margins and\n * any explicit width and length specified. Regions are specified by coordinates\n * of the top left and lower right corners with range 1 to width or height.\n */\n\nstatic int\ngetCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump)\n  {\n  struct offset offsets;\n  int    i;\n  int32  test;\n  uint32 seg, total, need_buff = 0;\n  uint32 buffsize;\n  uint32 zwidth, zlength;\n\n  memset(&offsets, '\\0', sizeof(struct offset));\n  crop->bufftotal = 0;\n  crop->combined_width  = (uint32)0;\n  crop->combined_length = (uint32)0;\n  crop->selections = 0;\n\n  /* Compute pixel offsets if margins or fixed width or length specified */\n  if ((crop->crop_mode & CROP_MARGINS) ||\n      (crop->crop_mode & CROP_REGIONS) ||\n      (crop->crop_mode & CROP_LENGTH)  || \n      (crop->crop_mode & CROP_WIDTH))\n    {\n    if (computeInputPixelOffsets(crop, image, &offsets))\n      {\n      TIFFError (\"getCropOffsets\", \"Unable to compute crop margins\");\n      return (-1);\n      }\n    need_buff = TRUE;\n    crop->selections = crop->regions;\n    /* Regions are only calculated from top and left edges with no margins */\n    if (crop->crop_mode & CROP_REGIONS)\n      return (0);\n    }\n  else\n    { /* cropped area is the full image */\n    offsets.tmargin = 0;\n    offsets.lmargin = 0;\n    offsets.bmargin = 0;\n    offsets.rmargin = 0;\n    offsets.crop_width = image->width;\n    offsets.crop_length = image->length;\n    offsets.startx = 0;\n    offsets.endx = image->width - 1;\n    offsets.starty = 0;\n    offsets.endy = image->length - 1;\n    need_buff = FALSE;\n    }\n\n  if (dump->outfile != NULL)\n    {\n    dump_info (dump->outfile, dump->format, \"\", \"Margins: Top: %d  Left: %d  Bottom: %d  Right: %d\", \n           offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin); \n    dump_info (dump->outfile, dump->format, \"\", \"Crop region within margins: Adjusted Width:  %6d  Length: %6d\", \n           offsets.crop_width, offsets.crop_length);\n    }\n\n  if (!(crop->crop_mode & CROP_ZONES)) /* no crop zones requested */\n    {\n    if (need_buff == FALSE)  /* No margins or fixed width or length areas */\n      {\n      crop->selections = 0;\n      crop->combined_width  = image->width;\n      crop->combined_length = image->length;\n      return (0);\n      }\n    else \n      {\n      /* Use one region for margins and fixed width or length areas\n       * even though it was not formally declared as a region.\n       */\n      crop->selections = 1;\n      crop->zones = 1;\n      crop->zonelist[0].total = 1;\n      crop->zonelist[0].position = 1;\n      }\n    }     \n  else\n    crop->selections = crop->zones;\n\n  for (i = 0; i < crop->zones; i++)\n    {\n    seg = crop->zonelist[i].position;\n    total = crop->zonelist[i].total;\n\n    switch (crop->edge_ref) \n      {\n      case EDGE_LEFT: /* zones from left to right, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx + \n                                  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);\n           test = (int32)offsets.startx + \n                  (int32)(offsets.crop_width * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n\t       crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_BOTTOM: /* width from left, zones from bottom to top */\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n\t     crop->regionlist[i].y1 = 0;\n           else\n\t     crop->regionlist[i].y1 = test + 1;\n\n           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n             if (test > (int32)(image->length - 1))\n               crop->regionlist[i].y2 = image->length - 1;\n             else \n               crop->regionlist[i].y2 = test;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_RIGHT: /* zones from right to left, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx +\n                                  (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);\n           test = offsets.startx + \n\t          (offsets.crop_width * (total - seg + 1) * 1.0 / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n               crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_TOP: /* width from left, zones from top to bottom */\n      default:\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\n           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->length - 1))\n\t       crop->regionlist[i].y2 = image->length - 1;\n             else\n\t       crop->regionlist[i].y2 = test - 1;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      } /* end switch statement */\n\n    buffsize = (uint32)\n          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));\n    crop->regionlist[i].width = (uint32) zwidth;\n    crop->regionlist[i].length = (uint32) zlength;\n    crop->regionlist[i].buffsize = buffsize;\n    crop->bufftotal += buffsize;\n\n\n  if (dump->outfile != NULL)\n    dump_info (dump->outfile, dump->format, \"\",  \"Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\",\n                    i + 1, (uint32)zwidth, (uint32)zlength,\n\t\t    crop->regionlist[i].x1, crop->regionlist[i].x2, \n                    crop->regionlist[i].y1, crop->regionlist[i].y2);\n    }\n\n  return (0);\n  } /* end getCropOffsets */\n\n\nstatic int\ncomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n                           struct pagedef *page, struct pageseg *sections,\n                           struct dump_opts* dump)\n  {\n  double scale;\n  double pwidth, plength;          /* Output page width and length in user units*/\n  uint32 iwidth, ilength;          /* Input image width and length in pixels*/\n  uint32 owidth, olength;          /* Output image width and length in pixels*/\n  uint32 orows, ocols;             /* rows and cols for output */\n  uint32 hmargin, vmargin;         /* Horizontal and vertical margins */\n  uint32 x1, x2, y1, y2, line_bytes;\n  /* unsigned int orientation; */\n  uint32 i, j, k;\n \n  scale = 1.0;\n  if (page->res_unit == RESUNIT_NONE)\n    page->res_unit = image->res_unit;\n\n  switch (image->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (page->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (page->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  /* get width, height, resolutions of input image selection */\n  if (crop->combined_width > 0)\n    iwidth = crop->combined_width;\n  else\n    iwidth = image->width;\n  if (crop->combined_length > 0)\n    ilength = crop->combined_length;\n  else\n    ilength = image->length;\n\n  if (page->hres <= 1.0)\n    page->hres = image->xres;\n  if (page->vres <= 1.0)\n    page->vres = image->yres;\n\n  if ((page->hres < 1.0) || (page->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* If no page sizes are being specified, we just use the input image size to\n   * calculate maximum margins that can be taken from image.\n   */\n  if (page->width <= 0)\n    pwidth = iwidth;\n  else\n    pwidth = page->width;\n\n  if (page->length <= 0)\n    plength = ilength;\n  else\n    plength = page->length;\n\n  if (dump->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     page->name, page->vres, page->hres,\n             page->hmargin, page->vmargin);\n    TIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\", \n           page->res_unit, scale, pwidth, plength);\n    }\n\n  /* compute margins at specified unit and resolution */\n  if (page->mode & PAGE_MODE_MARGINS)\n    {\n    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n      { /* inches or centimeters specified */\n      hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));\n      }\n    else\n      { /* Otherwise user has specified pixels as reference unit */\n      hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));\n      }\n\n    if ((hmargin * 2.0) > (pwidth * page->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      hmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((vmargin * 2.0) > (plength * page->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      vmargin = (uint32) 0; \n      return (-1);\n      }\n    }\n  else\n    {\n    hmargin = 0;\n    vmargin = 0;\n    }\n\n  if (page->mode & PAGE_MODE_ROWSCOLS )\n    {\n    /* Maybe someday but not for now */\n    if (page->mode & PAGE_MODE_MARGINS)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    owidth  = TIFFhowmany(iwidth, page->cols);\n    olength = TIFFhowmany(ilength, page->rows);\n    }\n  else\n    {\n    if (page->mode & PAGE_MODE_PAPERSIZE )\n      {\n      owidth  = (uint32)((pwidth * page->hres) - (hmargin * 2));\n      olength = (uint32)((plength * page->vres) - (vmargin * 2));\n      }\n    else\n      {\n      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));\n      olength = (uint32)(ilength - (vmargin * 2 * page->vres));\n      }\n    }\n\n  if (owidth > iwidth)\n    owidth = iwidth;\n  if (olength > ilength)\n    olength = ilength;\n\n  /* Compute the number of pages required for Portrait or Landscape */\n  switch (page->orient)\n    {\n    case ORIENTATION_NONE:\n    case ORIENTATION_PORTRAIT:\n         ocols = TIFFhowmany(iwidth, owidth);\n         orows = TIFFhowmany(ilength, olength);\n         /* orientation = ORIENTATION_PORTRAIT; */\n         break;\n\n    case ORIENTATION_LANDSCAPE:\n         ocols = TIFFhowmany(iwidth, olength);\n         orows = TIFFhowmany(ilength, owidth);\n         x1 = olength;\n         olength = owidth;\n         owidth = x1;\n         /* orientation = ORIENTATION_LANDSCAPE; */\n         break;\n\n    case ORIENTATION_AUTO:\n    default:\n         x1 = TIFFhowmany(iwidth, owidth);\n         x2 = TIFFhowmany(ilength, olength); \n         y1 = TIFFhowmany(iwidth, olength);\n         y2 = TIFFhowmany(ilength, owidth); \n\n         if ( (x1 * x2) < (y1 * y2))\n           { /* Portrait */\n           ocols = x1;\n           orows = x2;\n           /* orientation = ORIENTATION_PORTRAIT; */\n\t   }\n         else\n           { /* Landscape */\n           ocols = y1;\n           orows = y2;\n           x1 = olength;\n           olength = owidth;\n           owidth = x1;\n           /* orientation = ORIENTATION_LANDSCAPE; */\n           }\n    }\n\n  if (ocols < 1)\n    ocols = 1;\n  if (orows < 1)\n    orows = 1;\n\n  /* If user did not specify rows and cols, set them from calcuation */\n  if (page->rows < 1)\n    page->rows = orows;\n  if (page->cols < 1)\n    page->cols = ocols;\n\n  line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp;\n\n  if ((page->rows * page->cols) > MAX_SECTIONS)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* build the list of offsets for each output section */\n  for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++)\n    {\n    y1 = (uint32)(olength * i);\n    y2 = (uint32)(olength * (i +  1) - 1);\n    if (y2 >= ilength)\n      y2 = ilength - 1;\n    for (j = 0; j < ocols; j++, k++)\n      {\n      x1 = (uint32)(owidth * j); \n      x2 = (uint32)(owidth * (j + 1) - 1);\n      if (x2 >= iwidth)\n        x2 = iwidth - 1;\n      sections[k].x1 = x1;\n      sections[k].x2 = x2;\n      sections[k].y1 = y1;\n      sections[k].y2 = y2;\n      sections[k].buffsize = line_bytes * olength;\n      sections[k].position = k + 1;\n      sections[k].total = orows * ocols;\n      } \n    } \n  return (0);\n  } /* end computeOutputPixelOffsets */\n\nstatic int\nloadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n\nstatic int  correct_orientation(struct image_data *image, unsigned char **work_buff_ptr)\n  {\n  uint16 mirror, rotation;\n  unsigned char *work_buff;\n\n  work_buff = *work_buff_ptr;\n  if ((image == NULL) || (work_buff == NULL))\n    {\n    TIFFError (\"correct_orientatin\", \"Invalid image or buffer pointer\");\n    return (-1);\n    }\n\n  if ((image->adjustments & MIRROR_HORIZ) || (image->adjustments & MIRROR_VERT))\n    {\n    mirror = (uint16)(image->adjustments & MIRROR_BOTH);\n    if (mirrorImage(image->spp, image->bps, mirror, \n        image->width, image->length, work_buff))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to mirror image\");\n      return (-1);\n      }\n    }\n\n  if (image->adjustments & ROTATE_ANY)\n    {\n    if (image->adjustments & ROTATECW_90)\n      rotation = (uint16) 90;\n    else\n    if (image->adjustments & ROTATECW_180)\n      rotation = (uint16) 180;\n    else\n    if (image->adjustments & ROTATECW_270)\n      rotation = (uint16) 270;\n    else\n      {\n      TIFFError (\"correct_orientation\", \"Invalid rotation value: %d\", \n                  image->adjustments & ROTATE_ANY);\n      return (-1);\n      }\n \n    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to rotate image\");\n      return (-1);\n      }\n    image->orientation = ORIENTATION_TOPLEFT;\n    }\n\n  return (0);\n  } /* end correct_orientation */\n\n\n/* Extract multiple zones from an image and combine into a single composite image */\nstatic int\nextractCompositeRegions(struct image_data *image,  struct crop_mask *crop, \n                        unsigned char *read_buff, unsigned char *crop_buff)\n  {\n  int       shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32    i, trailing_bits, prev_trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_rowsize, dst_rowsize, src_offset, dst_offset;\n  uint32    crop_width, crop_length, img_width /*, img_length */;\n  uint32    prev_length, prev_width, composite_width;\n  uint16    bps, spp;\n  uint8    *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract one or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src = read_buff;\n  dst = crop_buff;\n\n  /* These are setup for adding additional sections */\n  prev_width = prev_length = 0;\n  prev_trailing_bits = trailing_bits = 0;\n  composite_width = crop->combined_width;\n  crop->combined_width = 0;\n  crop->combined_length = 0;\n\n  for (i = 0; i < crop->selections; i++)\n    {\n    /* rows, columns, width, length are expressed in pixels */\n    first_row = crop->regionlist[i].y1;\n    last_row  = crop->regionlist[i].y2;\n    first_col = crop->regionlist[i].x1;\n    last_col  = crop->regionlist[i].x2;\n\n    crop_width = last_col - first_col + 1;\n    crop_length = last_row - first_row + 1;\n\n    /* These should not be needed for composite images */\n    crop->regionlist[i].width = crop_width;\n    crop->regionlist[i].length = crop_length;\n    crop->regionlist[i].buffptr = crop_buff;\n\n    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n    dst_rowsize = (((crop_width * bps * count) + 7) / 8);\n\n    switch (crop->edge_ref)\n      {\n      default:\n      case EDGE_TOP:\n      case EDGE_BOTTOM:\n\t   if ((i > 0) && (crop_width != crop->regionlist[i - 1].width))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal width regions can be combined for -E top or bottom\");\n\t     return (1);\n             }\n\n           crop->combined_width = crop_width;\n           crop->combined_length += crop_length;\n\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + (prev_length * dst_rowsize);\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                                      spp, bps, count, first_col,\n                                                      last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n             }\n           prev_length += crop_length;\n\t   break;\n      case EDGE_LEFT:  /* splice the pieces of each row together, side by side */\n      case EDGE_RIGHT:\n\t   if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal length regions can be combined for -E left or right\");\n\t     return (1);\n             }\n           crop->combined_width += crop_width;\n           crop->combined_length = crop_length;\n           dst_rowsize = (((composite_width * bps * count) + 7) / 8);\n           trailing_bits = (crop_width * bps * count) % 8;\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + prev_width;\n\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width,\n                                                      sample, spp, bps, count,\n                                                      first_col, last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n              case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n\t     }\n\t   prev_width += (crop_width * bps * count) / 8;\n           prev_trailing_bits += trailing_bits;\n           if (prev_trailing_bits > 7)\n\t     prev_trailing_bits-= 8;\n\t   break;\n      }\n    }\n  if (crop->combined_width != composite_width)\n    TIFFError(\"combineSeparateRegions\",\"Combined width does not match composite width\");\n      \n  return (0);\n  }  /* end extractCompositeRegions */\n\n/* Copy a single region of input buffer to an output buffer. \n * The read functions used copy separate plane data into a buffer \n * as interleaved samples rather than separate planes so the same\n * logic works to extract regions regardless of the way the data \n * are organized in the input file. This function can be used to\n * extract one or more samples from the input image by updating the \n * parameters for starting sample and number of samples to copy in the\n * fifth and eighth arguments of the call to extractContigSamples.\n * They would be passed as new elements of the crop_mask struct.\n */\n\nstatic int\nextractSeparateRegion(struct image_data *image,  struct crop_mask *crop,\n                      unsigned char *read_buff, unsigned char *crop_buff,\n                      int region)\n  {\n  int     shift_width, prev_trailing_bits = 0;\n  uint32  bytes_per_sample, bytes_per_pixel;\n  uint32  src_rowsize, dst_rowsize;\n  uint32  row, first_row, last_row, first_col, last_col;\n  uint32  src_offset, dst_offset;\n  uint32  crop_width, crop_length, img_width /*, img_length */;\n  uint16  bps, spp;\n  uint8  *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract more or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0; /* Byte aligned data only */\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = crop->regionlist[region].y1;\n  last_row  = crop->regionlist[region].y2;\n  first_col = crop->regionlist[region].x1;\n  last_col  = crop->regionlist[region].x2;\n\n  crop_width = last_col - first_col + 1;\n  crop_length = last_row - first_row + 1;\n\n  crop->regionlist[region].width = crop_width;\n  crop->regionlist[region].length = crop_length;\n  crop->regionlist[region].buffptr = crop_buff;\n\n  src = read_buff;\n  dst = crop_buff;\n  src_rowsize = ((img_width * bps * spp) + 7) / 8;\n  dst_rowsize = (((crop_width * bps * spp) + 7) / 8);\n\n  for (row = first_row; row <= last_row; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = (row  - first_row) * dst_rowsize;\n    src = read_buff + src_offset;\n    dst = crop_buff + dst_offset;\n\n    switch (shift_width)\n      {\n      case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                             spp, bps, count, first_col,\n                                             last_col + 1))\n                {\n\t        TIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t        return (1);\n\t        }\n\t      break;\n      case 1: if (bps == 1)\n                { \n                if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                      sample, spp, bps, count, \n                                                      first_col, last_col + 1,\n                                                      prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t\t  break;\n\t\t}\n              else\n                if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                       sample, spp, bps, count, \n                                                       first_col, last_col + 1,\n                                                       prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t      break;\n      case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      case 3:\n      case 4:\n      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      default: TIFFError(\"extractSeparateRegion\", \"Unsupported bit depth %d\", bps);\n\t       return (1);\n      }\n    }\n          \n  return (0);\n  }  /* end extractSeparateRegion */\n\nstatic int\nextractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n  /* unsigned  char *src, *dst; */\n#endif\n\n  uint32    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32    img_length;\n#endif\n  uint32    j, shift1, shift2, trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_offset, dst_offset, row_offset, col_offset;\n  uint32    offset1, offset2, full_bytes;\n  uint32    sect_width;\n#ifdef DEVELMODE\n  uint32    sect_length;\n#endif\n  uint16    bps, spp;\n\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n  static char *bitarray = NULL;\n#endif\n\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n\n#ifdef DEVELMODE\n  /* src = src_buff; */\n  /* dst = sect_buff; */\n#endif\n  src_offset = 0;\n  dst_offset = 0;\n\n#ifdef DEVELMODE\n  if (bitarray == NULL)\n    {\n    if ((bitarray = (char *)malloc(img_width)) == NULL)\n      {\n      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n      return (-1);\n      }\n    }\n#endif\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n  img_rowsize = ((img_width * bps + 7) / 8) * spp;\n  full_bytes = (sect_width * spp * bps) / 8;   /* number of COMPLETE bytes per row in section */\n  trailing_bits = (sect_width * bps) % 8;\n\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\n\t   img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n\n  if ((bps % 8) == 0)\n    {\n    col_offset = first_col * spp * bps / 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* row_offset = row * img_width * spp * bps / 8; */\n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { /* bps != 8 */\n    shift1  = spp * ((first_col * bps) % 8);\n    shift2  = spp * ((last_col * bps) % 8);\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* pull out the first byte */\n      row_offset = row * img_rowsize;\n      offset1 = row_offset + (first_col * bps / 8);\n      offset2 = row_offset + (last_col * bps / 8);\n\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\", \n                 row, offset1, shift1, offset2, shift2); \n#endif\n\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) /* the region is byte and sample alligned */\n        {\n\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n\n#ifdef DEVELMODE\n\tTIFFError (\"\", \"        Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n\t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\", \n                              offset2, dst_offset); \n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   /* each destination byte will have to be built from two source bytes*/\n        {\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); \n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n\t  bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n\t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); \n#endif\n\t  if (shift2 > shift1)\n            {\n\t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n            sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Shift2 > Shift1\\n\"); \n#endif\n            }\n          else\n            {\n\t    if (shift2 < shift1)\n              {\n              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n\t      sect_buff[dst_offset] &= bytebuff2;\n#ifdef DEVELMODE\n\t      TIFFError (\"\", \"        Shift2 < Shift1\\n\"); \n#endif\n              }\n#ifdef DEVELMODE\n            else\n\t      TIFFError (\"\", \"        Shift2 == Shift1\\n\"); \n#endif\n            }\n\t  }\n#ifdef DEVELMODE\n\t  sprintf(&bitarray[28], \" \");\n\t  sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n\n  return (0);\n  } /* end extractImageSection */\n\nstatic int \nwriteSelections(TIFF *in, TIFF **out, struct crop_mask *crop, \n                struct image_data *image, struct dump_opts *dump,\n                struct buffinfo seg_buffs[], char *mp, char *filename, \n                unsigned int *page, unsigned int total_pages)\n  {\n  int i, page_count;\n  int autoindex = 0;\n  unsigned char *crop_buff = NULL;\n\n  /* Where we open a new file depends on the export mode */  \n  switch (crop->exp_mode)\n    {\n    case ONE_FILE_COMPOSITE: /* Regions combined into single image */\n         autoindex = 0;\n         crop_buff = seg_buffs[0].buffer;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = total_pages;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length,\n                               crop_buff, *page, total_pages))\n            {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t break;\n    case ONE_FILE_SEPARATED: /* Regions as separated images */\n         autoindex = 0;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = crop->selections * total_pages;\n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t   }\n         break;\n    case FILE_PER_IMAGE_COMPOSITE: /* Regions as composite image */\n         autoindex = 1;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n\n         crop_buff = seg_buffs[0].buffer;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length, \n                               crop_buff, *page, total_pages))\n           {\n           TIFFError(\"writeRegions\", \"Unable to write new image\");\n           return (-1);\n           }\n         break;\n    case FILE_PER_IMAGE_SEPARATED: /* Regions as separated images */\n         autoindex = 1;\n         page_count = crop->selections;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n                \n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n         break;\n    case FILE_PER_SELECTION:\n         autoindex = 1;\n\t page_count = 1;\n         for (i = 0; i < crop->selections; i++)\n           {\n           if (update_output_file (out, mp, autoindex, filename, page))\n             return (1);\n\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n\t break;\n    default: return (1);\n    }\n\n  return (0);\n  } /* end writeRegions */\n\nstatic int\nwriteImageSections(TIFF *in, TIFF *out, struct image_data *image,\n\t\t   struct pagedef *page, struct pageseg *sections,\n\t\t   struct dump_opts * dump, unsigned char *src_buff,\n                   unsigned char **sect_buff_ptr)\n  {\n  double  hres, vres;\n  uint32  i, k, width, length, sectsize;\n  unsigned char *sect_buff = *sect_buff_ptr;\n\n  hres = page->hres;\n  vres = page->vres;\n\n  k = page->cols * page->rows;\n  if ((k < 1) || (k > MAX_SECTIONS))\n   {\n   TIFFError(\"writeImageSections\",\n\t     \"%d Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);\n   return (-1);\n   }\n\n  for (i = 0; i < k; i++)\n    {\n    width  = sections[i].x2 - sections[i].x1 + 1;\n    length = sections[i].y2 - sections[i].y1 + 1;\n    sectsize = (uint32)\n\t    ceil((width * image->bps + 7) / (double)8) * image->spp * length;\n    /* allocate a buffer if we don't have one already */\n    if (createImageSection(sectsize, sect_buff_ptr))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\");\n      exit (-1);\n      }\n    sect_buff = *sect_buff_ptr;\n\n    if (extractImageSection (image, &sections[i], src_buff, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to extract image sections\");\n      exit (-1);\n      }\n\n  /* call the write routine here instead of outside the loop */\n    if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to write image section\");\n      exit (-1);\n      }\n    }\n\n  return (0);\n  } /* end writeImageSections */\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n */\nstatic int  \nwriteSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n                   struct dump_opts *dump, uint32 width, uint32 length,\n                   double hres, double vres,\n                   unsigned char *sect_buff)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  /*  Calling this seems to reset the compression mode on the TIFF *in file.\n  TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);\n  */\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n\n  spp = image->spp;\n  bps = image->bps;\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n  /* This is the global variable compression which is set \n   * if the user has specified a command line option for \n   * a compression option.  Should be passed around in one\n   * of the parameters instead of as a global. If no user\n   * option specified it will still be (uint16) -1. */\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    { /* OJPEG is no longer supported for writing so upgrade to JPEG */\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else /* Use the compression from the input file */\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* holdout mask */\n      {\n      TIFFError (\"writeSingleSection\",\n                 \"JPEG compression cannot be used with %s image data\",\n\t\t (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n    else\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n    }\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input photometric: %s\",\n\t    (input_photometric == PHOTOMETRIC_RGB) ? \"RGB\" :\n\t    ((input_photometric == PHOTOMETRIC_YCBCR) ?  \"YCbCr\" : \"Not RGB or YCbCr\"));\n#endif\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeSingleSection\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard.\n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    /* These are references to GLOBAL variables set by defaults\n     * and /or the compression flag\n     */\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeSingleSection\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\tbreak;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     if (pageNum < 0) /* only one input file */\n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n     else \n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Update these since they are overwritten from input res by loop above */\n  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);\n  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);\n    else\n      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigStrips (out, sect_buff, length);\n    else\n      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeSingleSection */\n\n\n/* Create a buffer to write one section at a time */\nstatic int\ncreateImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n    *sect_buff_ptr = sect_buff;\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n\tfree (sect_buff);\n        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  if (!sect_buff)\n    {\n    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n    return (-1);\n    }\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }  /* end createImageSection */\n\n\n/* Process selections defined by regions, zones, margins, or fixed sized areas */\nstatic int\nprocessCropSelections(struct image_data *image, struct crop_mask *crop, \n                      unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n  {\n  int       i;\n  uint32    width, length, total_width, total_length;\n  tsize_t   cropsize;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *next_buff = NULL;\n  tsize_t   prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  if (crop->img_mode == COMPOSITE_IMAGES)\n    {\n    cropsize = crop->bufftotal;\n    crop_buff = seg_buffs[0].buffer; \n    if (!crop_buff)\n      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    else\n      {\n      prev_cropsize = seg_buffs[0].size;\n      if (prev_cropsize < cropsize)\n        {\n        next_buff = _TIFFrealloc(crop_buff, cropsize);\n        if (! next_buff)\n          {\n          _TIFFfree (crop_buff);\n          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n          }\n        else\n          crop_buff = next_buff;\n        }\n      }\n\n    if (!crop_buff)\n      {\n      TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n      return (-1);\n      }\n \n    _TIFFmemset(crop_buff, 0, cropsize);\n    seg_buffs[0].buffer = crop_buff;\n    seg_buffs[0].size = cropsize;\n\n    /* Checks for matching width or length as required */\n    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n      return (1);\n\n    if (crop->crop_mode & CROP_INVERT)\n      {\n      switch (crop->photometric)\n        {\n        /* Just change the interpretation */\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n\t     image->photometric = crop->photometric;\n\t     break;\n        case INVERT_DATA_ONLY:\n        case INVERT_DATA_AND_TAG:\n             if (invertImage(image->photometric, image->spp, image->bps, \n                             crop->combined_width, crop->combined_length, crop_buff))\n               {\n               TIFFError(\"processCropSelections\", \n                         \"Failed to invert colorspace for composite regions\");\n               return (-1);\n               }\n             if (crop->photometric == INVERT_DATA_AND_TAG)\n               {\n               switch (image->photometric)\n                 {\n                 case PHOTOMETRIC_MINISWHITE:\n \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n\t              break;\n                 case PHOTOMETRIC_MINISBLACK:\n \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n\t              break;\n                 default:\n\t              break;\n\t         }\n\t       }\n             break;\n        default: break;\n        }\n      }\n\n    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n    if (crop->crop_mode & CROP_MIRROR)\n      {\n      if (mirrorImage(image->spp, image->bps, crop->mirror, \n                      crop->combined_width, crop->combined_length, crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\", \n\t         (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n        return (-1);\n        }\n      }\n\n    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n      {\n      if (rotateImage(crop->rotation, image, &crop->combined_width, \n                      &crop->combined_length, &crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \n                  \"Failed to rotate composite regions by %d degrees\", crop->rotation);\n        return (-1);\n        }\n      seg_buffs[0].buffer = crop_buff;\n      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n                            * image->spp) * crop->combined_length; \n      }\n    }\n  else  /* Separated Images */\n    {\n    total_width = total_length = 0;\n    for (i = 0; i < crop->selections; i++)\n      {\n      cropsize = crop->bufftotal;\n      crop_buff = seg_buffs[i].buffer; \n      if (!crop_buff)\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n      else\n        {\n        prev_cropsize = seg_buffs[0].size;\n        if (prev_cropsize < cropsize)\n          {\n          next_buff = _TIFFrealloc(crop_buff, cropsize);\n          if (! next_buff)\n            {\n            _TIFFfree (crop_buff);\n            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n            }\n          else\n            crop_buff = next_buff;\n          }\n        }\n\n      if (!crop_buff)\n        {\n        TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n        }\n \n      _TIFFmemset(crop_buff, 0, cropsize);\n      seg_buffs[i].buffer = crop_buff;\n      seg_buffs[i].size = cropsize;\n\n      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n        {\n\tTIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i);\n        return (-1);\n        }\n    \n      width  = crop->regionlist[i].width;\n      length = crop->regionlist[i].length;\n\n      if (crop->crop_mode & CROP_INVERT)\n        {\n        switch (crop->photometric)\n          {\n          /* Just change the interpretation */\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n\t       image->photometric = crop->photometric;\n\t       break;\n          case INVERT_DATA_ONLY:\n          case INVERT_DATA_AND_TAG:\n               if (invertImage(image->photometric, image->spp, image->bps, \n                               width, length, crop_buff))\n                 {\n                 TIFFError(\"processCropSelections\", \n                           \"Failed to invert colorspace for region\");\n                 return (-1);\n                 }\n               if (crop->photometric == INVERT_DATA_AND_TAG)\n                 {\n                 switch (image->photometric)\n                   {\n                   case PHOTOMETRIC_MINISWHITE:\n \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n\t                break;\n                   case PHOTOMETRIC_MINISBLACK:\n \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n\t                break;\n                   default:\n\t                break;\n\t           }\n\t         }\n               break;\n          default: break;\n          }\n        }\n\n      if (crop->crop_mode & CROP_MIRROR)\n        {\n        if (mirrorImage(image->spp, image->bps, crop->mirror, \n                        width, length, crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\", \n\t           (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n          return (-1);\n          }\n        }\n\n      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n        {\n\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n\t\t\t&crop->regionlist[i].length, &crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \n                    \"Failed to rotate crop region by %d degrees\", crop->rotation);\n          return (-1);\n          }\n        total_width  += crop->regionlist[i].width;\n        total_length += crop->regionlist[i].length;\n        crop->combined_width = total_width;\n        crop->combined_length = total_length;\n        seg_buffs[i].buffer = crop_buff;\n        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n                               * image->spp) * crop->regionlist[i].length; \n        }\n      }\n    }\n  return (0);\n  } /* end processCropSelections */\n\n/* Copy the crop section of the data from the current image into a buffer\n * and adjust the IFD values to reflect the new size. If no cropping is\n * required, use the origial read buffer as the crop buffer.\n *\n * There is quite a bit of redundancy between this routine and the more\n * specialized processCropSelections, but this provides\n * the most optimized path when no Zones or Regions are required.\n */\nstatic int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %d degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  } /* end createCroppedImage */\n\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n * Use of global variables for config, compression and others\n * should be replaced by addition to the crop_mask struct (which\n * will be renamed to proc_opts indicating that is controlls\n * user supplied processing options, not just cropping) and \n * then passed in as an argument.\n */\nstatic int  \nwriteCroppedImage(TIFF *in, TIFF *out, struct image_data *image, \n                  struct dump_opts *dump, uint32 width, uint32 length, \n                  unsigned char *crop_buff, int pagenum, int total_pages)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n  spp = image->spp;\n  bps = image->bps;\n\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeCroppedImage\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    {\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */\n      {\n      TIFFError (\"writeCroppedImage\",\n                 \"JPEG compression cannot be used with %s image data\",\n      \t        (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      {\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n      }\n    else\n      {\n      if (input_compression == COMPRESSION_SGILOG ||\n          input_compression == COMPRESSION_SGILOG24)\n        {\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\t  PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n        }\n      else\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n      }\n    }\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeCroppedImage\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard. \n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\t\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeCroppedImage\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n        if (bps != 1)\n          {\n\t  TIFFError(\"writeCroppedImage\",\n            \"Group 3/4 compression is not usable with bps > 1\");\n          return (-1);\n\t  }\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n        break;\n    case COMPRESSION_NONE:\n         break;\n    default: break;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write contiguous tile data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate tile data for page %d\", pagenum);\n      }\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigStrips (out, crop_buff, length))\n        TIFFError(\"\",\"Unable to write contiguous strip data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate strip data for page %d\", pagenum);\n      }\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFError(\"\",\"Failed to write IFD for page number %d\", pagenum);\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeCroppedImage */\n\nstatic int\nrotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   row, rowsize = 0, bit_offset = 0;\n  uint8    matchbits = 0, maskbits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n\n  for (row = 0; row < length ; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*next) & matchbits) << (src_bit);\n\n       /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        {\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples8bits */\n\n\nstatic int\nrotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint16   matchbits = 0, maskbits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint16)-1 >> (16 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (next[0] << 8) | next[1];\n      else\n        buff1 = (next[1] << 8) | next[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples16bits */\n\nstatic int\nrotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   matchbits = 0, maskbits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> (32 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n      else\n\tbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 16)\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  }  /* end rotateContigSamples24bits */\n\nstatic int\nrotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 row, rowsize, bit_offset;\n  uint32 src_byte, src_bit;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> (64 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n        longbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end rotateContigSamples32bits */\n\n\n/* Rotate an image by a multiple of 90 degrees clockwise */\nstatic int\nrotateImage(uint16 rotation, struct image_data *image, uint32 *img_width, \n            uint32 *img_length, unsigned char **ibuff_ptr)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, src_offset, dst_offset;\n  uint32   i, col, width, length;\n  uint32   colsize, buffsize, col_offset, pix_offset;\n  unsigned char *ibuff;\n  unsigned char *src;\n  unsigned char *dst;\n  uint16   spp, bps;\n  float    res_temp;\n  unsigned char *rbuff = NULL;\n\n  width  = *img_width;\n  length = *img_length;\n  spp = image->spp;\n  bps = image->bps;\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  colsize = ((bps * spp * length) + 7) / 8;\n  if ((colsize * width) > (rowsize * length))\n    buffsize = (colsize + 1) * width;\n  else\n    buffsize = (rowsize + 1) * length;\n\n  bytes_per_sample = (bps + 7) / 8;\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  switch (rotation)\n    {\n    case 0:\n    case 360: return (0);\n    case 90:\n    case 180:\n    case 270: break;\n    default:  TIFFError(\"rotateImage\", \"Invalid rotation angle %d\", rotation);\n              return (-1);\n    }\n\n  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize)))\n    {\n    TIFFError(\"rotateImage\", \"Unable to allocate rotation buffer of %1u bytes\", buffsize);\n    return (-1);\n    }\n  _TIFFmemset(rbuff, '\\0', buffsize);\n\n  ibuff = *ibuff_ptr;\n  switch (rotation)\n    {\n    case 180: if ((bps % 8) == 0) /* byte alligned data */\n                { \n                src = ibuff;\n                pix_offset = (spp * bps) / 8;\n                for (row = 0; row < length; row++)\n                   {\n\t\t   dst_offset = (length - row - 1) * rowsize;\n                   for (col = 0; col < width; col++)\n                     { \n\t\t     col_offset = (width - col - 1) * pix_offset;\n                     dst = rbuff + dst_offset + col_offset;\n\n\t\t     for (i = 0; i  < bytes_per_pixel; i++)\n\t\t       *dst++ = *src++;\n                     }\n                   }\n                }\n\t      else\n                { /* non 8 bit per sample data */ \n                for (row = 0; row < length; row++)\n                  {\n\t\t  src_offset = row * rowsize;\n\t\t  dst_offset = (length - row - 1) * rowsize;\n\t\t  src = ibuff + src_offset;\n                  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (reverseSamples8bits(spp, bps, width, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (reverseSamples16bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n                    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n              break;\n\n    case 90:  if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel);\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src -= rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = (length - 1) * rowsize;\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n\t      break;\n\n    case 270: if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = col * bytes_per_pixel;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src += rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = 0;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n              break;\n    default:\n              break;\n    }\n\n  return (0);\n  } /* end rotateImage */\n\nstatic int\nreverseSamples8bits (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte, src_bit;\n  uint32   bit_offset = 0;\n  uint8    match_bits = 0, mask_bits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples8bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint8)-1 >> ( 8 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (8 - src_bit - bps); \n      buff1 = ((*src) & match_bits) << (src_bit);\n\n      if (ready_bits < 8)\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      ready_bits += bps;\n      }\n    }\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  } /* end reverseSamples8bits */\n\n\nstatic int\nreverseSamples16bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint16   match_bits = 0, mask_bits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint16)-1 >> (16 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (16 - high_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n      \n      if (ready_bits < 8)\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  } /* end reverseSamples16bits */\n\nstatic int\nreverseSamples24bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint32   match_bits = 0, mask_bits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples24bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint32)-1 >> (32 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (32 - high_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n\n      if (ready_bits < 16)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  } /* end reverseSamples24bits */\n\n\nstatic int\nreverseSamples32bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 bit_offset;\n  uint32 src_byte = 0, high_bit = 0;\n  uint32 col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 mask_bits = 0, match_bits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples32bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint64)-1 >> (64 - bps);\n  dst = obuff;\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (64 - high_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n        longbuff2 = longbuff1;\n\t}\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & match_bits) << (high_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end reverseSamples32bits */\n\nstatic int\nreverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  /* Use memcpy for multiple bytes per sample data */\n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: /* Use byte copy only for single byte per sample data */\n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } /* end reverseSamplesBytes */\n\n\n/* Mirror an image horizontally or vertically */\nstatic int\nmirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, row_offset;\n  unsigned char *line_buff = NULL;\n  unsigned char *src;\n  unsigned char *dst;\n\n  src = ibuff;\n  rowsize = ((width * bps * spp) + 7) / 8;\n  switch (mirror)\n    {\n    case MIRROR_BOTH:\n    case MIRROR_VERT: \n             line_buff = (unsigned char *)_TIFFmalloc(rowsize);\n             if (line_buff == NULL)\n               {\n\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);\n               return (-1);\n               }\n\n             dst = ibuff + (rowsize * (length - 1));\n             for (row = 0; row < length / 2; row++)\n               {\n\t      _TIFFmemcpy(line_buff, src, rowsize);\n\t      _TIFFmemcpy(src, dst,  rowsize);\n\t      _TIFFmemcpy(dst, line_buff, rowsize);\n               src += (rowsize);\n               dst -= (rowsize);                                 \n               }\n             if (line_buff)\n               _TIFFfree(line_buff);\n             if (mirror == MIRROR_VERT)\n               break;\n    case MIRROR_HORIZ :\n              if ((bps % 8) == 0) /* byte alligned data */\n                { \n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  dst = ibuff + row_offset + rowsize;\n                  if (reverseSamplesBytes(spp, bps, width, src, dst))\n                    {\n\t\t    return (-1);\n                    }\n\t\t  }\n\t\t}\n\t      else\n                { /* non 8 bit per sample  data */\n                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1)))\n                  {\n                  TIFFError(\"mirrorImage\", \"Unable to allocate mirror line buffer\");\n                  return (-1);\n                  }\n                bytes_per_sample = (bps + 7) / 8;\n                bytes_per_pixel  = ((bps * spp) + 7) / 8;\n                if (bytes_per_pixel < (bytes_per_sample + 1))\n                  shift_width = bytes_per_pixel;\n                else\n                  shift_width = bytes_per_sample + 1;\n\n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  _TIFFmemset (line_buff, '\\0', rowsize);\n                  switch (shift_width)\n                    {\n                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    default: TIFFError(\"mirrorImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(line_buff);\n                             return (-1);      \n                    }\n\t\t  }\n                if (line_buff)\n                  _TIFFfree(line_buff);\n\t\t}\n             break;\n\n    default: TIFFError (\"mirrorImage\", \"Invalid mirror axis %d\", mirror);\n             return (-1);\n             break;\n    }\n\n  return (0);\n  }\n\n/* Invert the light and dark values for a bilevel or grayscale image */\nstatic int\ninvertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff)\n  {\n  uint32   row, col;\n  unsigned char  bytebuff1, bytebuff2, bytebuff3, bytebuff4;\n  unsigned char *src;\n  uint16        *src_uint16;\n  uint32        *src_uint32;\n\n  if (spp != 1)\n    {\n    TIFFError(\"invertImage\", \"Image inversion not supported for more than one sample per pixel\");\n    return (-1);\n    }\n\n  if (photometric !=  PHOTOMETRIC_MINISWHITE && photometric !=  PHOTOMETRIC_MINISBLACK)\n    {\n    TIFFError(\"invertImage\", \"Only black and white and grayscale images can be inverted\");\n    return (-1);\n    }\n\n  src = work_buff;\n  if (src == NULL)\n    {\n    TIFFError (\"invertImage\", \"Invalid crop buffer passed to invertImage\");\n    return (-1);\n    }\n\n  switch (bps)\n    {\n    case 32: src_uint32 = (uint32 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32;\n                  src_uint32++;\n                 }\n            break;\n    case 16: src_uint16 = (uint16 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint16 = (uint16)0xFFFF - *src_uint16;\n                  src_uint16++;\n                 }\n            break;\n    case 8: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\t*src = (uint8)255 - *src;\n                 src++;\n                }\n            break;\n    case 4: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\tbytebuff1 = 16 - (uint8)(*src & 240 >> 4);\n\t\tbytebuff2 = 16 - (*src & 15);\n\t\t*src = bytebuff1 << 4 & bytebuff2;\n                src++;\n                }\n            break;\n    case 2: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col++)\n                {\n\t\tbytebuff1 = 4 - (uint8)(*src & 192 >> 6);\n\t\tbytebuff2 = 4 - (uint8)(*src & 48  >> 4);\n\t\tbytebuff3 = 4 - (uint8)(*src & 12  >> 2);\n\t\tbytebuff4 = 4 - (uint8)(*src & 3);\n\t\t*src = (bytebuff1 << 6) || (bytebuff2 << 4) || (bytebuff3 << 2) || bytebuff4;\n                src++;\n                }\n            break;\n    case 1: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col += 8 /(spp * bps))\n                {\n                *src = ~(*src);\n                src++;\n                }\n            break;\n    default: TIFFError(\"invertImage\", \"Unsupported bit depth %d\", bps);\n      return (-1);\n    }\n\n  return (0);\n  }\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n"], "filenames": ["ChangeLog", "tools/tiffcrop.c"], "buggy_code_start_loc": [0, 3701], "buggy_code_end_loc": [0, 3702], "fixing_code_start_loc": [1, 3701], "fixing_code_end_loc": [8, 3702], "type": "CWE-119", "message": "LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted TIFF image, related to \"WRITE of size 2048\" and libtiff/tif_next.c:64:9.", "other": {"cve": {"id": "CVE-2016-10272", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-24T19:59:00.347", "lastModified": "2017-03-31T01:59:00.550", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted TIFF image, related to \"WRITE of size 2048\" and libtiff/tif_next.c:64:9."}, {"lang": "es", "value": "LibTIFF 4.0.7 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica) o posiblemente tener otro impacto no especificado a trav\u00e9s de una imagen TIFF manipulada, relacionado con \"WRITE de tama\u00f1o 2048\" y libtiff/tif_next.c:64:9."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libtiff:libtiff:4.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "FE968DD2-24BE-4417-A6DF-D79E40E07766"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97197", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2017/01/01/libtiff-multiple-heap-based-buffer-overflow/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/vadz/libtiff/commit/9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vadz/libtiff/commit/9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a"}}