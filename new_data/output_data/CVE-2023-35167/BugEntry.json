{"buggy_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.20.5] - 2023-06-11\n\n- fixed issue #200 transactions on mongo db\n\n## [0.20.4] - 2023-06-05\n\n- fixed issue with columns in postgres with casing in the db - sa `createdAt`\n- Issue #196 fixed - load options in live query\n- Fixed issue with `apiReadAllowed:false` when `apiUpdateAllowed` is set to undefined\n\n## [0.20.3] - 2023-05-23\n\n- Improved Open API Support\n\n## [0.20.2] - 2023-05-22\n\n- createdAt & updatedAt are by default `allowApiUpdate` false\n- Added `apiPrefix` to `BackendMethod` `options` to allow more control over backend method routes. #189\n\n## [0.20.1] - 2023-05-17\n\n- Improved support for compound id entity\n- Minor bug fixes\n- Improved memory usage\n\n## [0.20.0] - 2023-05-08\n\n- Added `handle` method for using remult in `next.js` api handlers. see [using remult in a next.js api handler](https://remult.dev/tutorials/react-next/appendix-1-get-server-side-props.html#using-remult-in-a-next-js-api-handler)\n- Added `remult-sveltekit` see [Add remult to your project](https://remult.dev/docs/add-remult-to-your-app.html#sveltekit)\n- Added support for `next.js` App Router. See [Add remult to your project](https://remult.dev/docs/add-remult-to-your-app.html#next-js-app-router)\n\n## [0.19.0] - 2023-03-26\n\n- `Repository`\n  - Added a `validate` method that returns an `ErrorInfo` object if invalid.\n  - Added a `fields` member that can be used to access the metadata of specific fields, for example:\n    ```ts\n    repo.fields.title.caption\n    //or\n    repo.fields.title.inputType\n    ```\n  - The `insert`, `validate`, `create`, `save` and `update` value will now run `fromJson` and `toJson` for field values that do not match their type - for consistent behavior with the `api`\n- `FieldMetadata`\n  - Added `apiUpdateAllowed` to query if `update` is allowed for this field\n  - Added `includedInApi` to query of this field would be returned from the backend as part of the api\n  - Added `displayValue` that can be used to achieve a consistent way a field is displayed.\n  - Added `toInput` and `fromInput` methods that'll help with translating values from and to inputs.\n- `getId` method added to `IdMetadata` to enable extracting the id from immutable objects, this is mainly useful for entities where the `id` column is not called `id` :)\n  ```ts\n  repo.metadata.idMetadata.getId(task)\n  ```\n-\n\n### Breaking Changes\n\n- In `EntityMetadata` the `apiUpdateAllowed`, `apiDeleteAllowed` and `apiInsertAllowed` that previously were boolean fields, are now methods that accepts item and return true or false. This is useful for cases where the apiAllowed rules refer to the specific values of an entity.\n  ```ts\n  // Previously\n  if (repo.metadata.apiDeleteAllowed) {\n  }\n  // Now\n  if (repo.metadata.apiDeleteAllowed(task)) {\n  }\n  ```\n- The `validate` method in `EntityRef` and `ControllerRef` that previously returned true if valid, now returns `undefined` if valid and `ErrorInfo` if invalid\n- `FieldMetadata`'s `ValueConverter` field's members are now mandatory and no longer optional - it's expected that they'll be implemented\n", "import type { MongoClient, Db } from 'mongodb';\nimport { DataProvider, EntityDataProvider, EntityFilter, EntityMetadata, Remult } from '.';\nimport { RepositoryOverloads } from './src/remult3';\nexport declare class MongoDataProvider implements DataProvider {\n    private db;\n    private client;\n    constructor(db: Db, client: MongoClient);\n    static getDb(remult?: Remult): Db;\n    getEntityDataProvider(entity: EntityMetadata<any>): EntityDataProvider;\n    transaction(action: (dataProvider: DataProvider) => Promise<void>): Promise<void>;\n    static filterToRaw<entityType>(entity: RepositoryOverloads<entityType>, condition: EntityFilter<entityType>): Promise<{\n        $and: any[];\n    } | {\n        $and?: undefined;\n    }>;\n}\n", "import { ClassType } from \"../../classType\";\nimport { Remult } from \"../context\";\nimport { DataProvider } from \"../data-interfaces\";\nimport { Repository } from \"../remult3\";\nimport { CategoriesForTesting } from \"../tests/remult-3-entities\";\nimport { Status } from \"../tests/testModel/models\";\nexport declare function itWithFocus(key: string, what: () => Promise<void>, focus?: boolean): void;\nexport declare function testAll(key: string, what: dbTestWhatSignature, focus?: boolean, options?: {\n    exclude?: string[];\n}): void;\nexport declare function addDatabaseToTest(tester: dbTestMethodSignature, key?: string): dbTestMethodSignature;\nexport declare function testInMemory(key: string, what: dbTestWhatSignature, focus?: boolean): void;\nexport declare const TestDbs: {\n    restDataProvider: string;\n    mongo: string;\n};\nexport declare type dbTestWhatSignature = ((db: {\n    db: DataProvider;\n    remult: Remult;\n    createEntity<entityType>(entity: ClassType<entityType>): Promise<Repository<entityType>>;\n}) => Promise<void>);\nexport declare type dbTestMethodSignature = ((key: string, what: dbTestWhatSignature, focus: boolean) => void) & {\n    key?: string;\n};\nexport declare function testAllDbs<T extends CategoriesForTesting>(key: string, doTest: (helper: {\n    remult: Remult;\n    createData: (doInsert?: (insert: (id: number, name: string, description?: string, status?: Status) => Promise<void>) => Promise<void>, entity?: {\n        new (): CategoriesForTesting;\n    }) => Promise<Repository<T>>;\n    insertFourRows: () => Promise<Repository<T>>;\n}) => Promise<any>, focus?: boolean): Promise<void>;\n", "import { AndFilter, customUrlToken, buildFilterFromRequestParameters } from './filter/filter-interfaces';\nimport { doTransaction, Remult, UserInfo } from './context';\nimport { Filter } from './filter/filter-interfaces';\nimport { FindOptions, Repository, EntityRef, rowHelperImplementation, EntityFilter } from './remult3';\nimport { ErrorInfo } from './data-interfaces';\nimport { ForbiddenError } from './server-action';\nimport { findOptionsToJson, liveQueryAction } from './data-providers/rest-data-provider';\nimport { QueryData } from './live-query/SubscriptionServer';\n\n\nexport class DataApi<T = any> {\n\n  constructor(private repository: Repository<T>, private remult: Remult) {\n  }\n  httpGet(res: DataApiResponse, req: DataApiRequest, serializeContext: () => Promise<any>) {\n    const action = req?.get(\"__action\");\n    if (action?.startsWith(liveQueryAction))\n      return this.liveQuery(res, req, undefined, serializeContext, getLiveQueryChannel(action.substring(liveQueryAction.length), this.remult.user?.id));\n    switch (action) {\n      case \"get\":\n      case \"count\":\n        return this.count(res, req, undefined);\n    }\n    return this.getArray(res, req, undefined);\n\n  }\n  async httpPost(res: DataApiResponse, req: DataApiRequest, body: any, serializeContext: () => Promise<any>) {\n    const action = req?.get(\"__action\");\n    if (action?.startsWith(liveQueryAction))\n      return this.liveQuery(res, req, undefined, serializeContext, getLiveQueryChannel(action.substring(liveQueryAction.length), this.remult.user?.id));\n    switch (action) {\n      case \"get\":\n        return this.getArray(res, req, body);\n      case \"count\":\n        return this.count(res, req, body);\n      case \"endLiveQuery\":\n        await this.remult.liveQueryStorage.remove(getLiveQueryChannel(body.id, this.remult.user?.id));\n        res.success(\"ok\");\n        return;\n      default:\n        return this.post(res, body);\n    }\n  }\n  static defaultGetLimit = 0;\n  async get(response: DataApiResponse, id: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    await this.doOnId(response, id, async row => response.success(this.repository.getEntityRef(row).toApiJson()));\n  }\n  async count(response: DataApiResponse, request: DataApiRequest, filterBody?: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n\n      response.success({ count: +await this.repository.count(await this.buildWhere(request, filterBody)) });\n    } catch (err) {\n      response.error(err);\n    }\n  }\n\n\n  async getArrayImpl(response: DataApiResponse, request: DataApiRequest, filterBody: any) {\n\n    let findOptions: FindOptions<T> = { load: () => [] };\n    findOptions.where = await this.buildWhere(request, filterBody);\n\n    if (request) {\n\n      let sort = <string>request.get(\"_sort\");\n      if (sort != undefined) {\n        let dir = request.get('_order');\n        findOptions.orderBy = determineSort(sort, dir);\n\n      }\n      let limit = +request.get(\"_limit\");\n      if (!limit && DataApi.defaultGetLimit)\n        limit = DataApi.defaultGetLimit;\n      findOptions.limit = limit;\n      findOptions.page = +request.get(\"_page\");\n\n    }\n    if (this.remult.isAllowed(this.repository.metadata.options.apiRequireId)) {\n      let hasId = false;\n      let w = await Filter.fromEntityFilter(this.repository.metadata, findOptions.where);\n      if (w) {\n        w.__applyToConsumer({\n          containsCaseInsensitive: () => { },\n          isDifferentFrom: () => { },\n          isEqualTo: (col, val) => {\n            if (this.repository.metadata.idMetadata.isIdField(col))\n              hasId = true;\n          },\n          custom: () => { },\n          databaseCustom: () => { },\n          isGreaterOrEqualTo: () => { },\n          isGreaterThan: () => { },\n          isIn: () => { },\n          isLessOrEqualTo: () => { },\n          isLessThan: () => { },\n          isNotNull: () => { },\n          isNull: () => { },\n\n          or: () => { }\n        });\n      }\n      if (!hasId) {\n        response.forbidden();\n        throw new ForbiddenError();\n      }\n    }\n    const r = await this.repository.find(findOptions)\n      .then(async r => {\n        return await Promise.all(r.map(async y => this.repository.getEntityRef(y).toApiJson()));\n      });\n    return { r, findOptions };\n\n  }\n\n  async getArray(response: DataApiResponse, request: DataApiRequest, filterBody?: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n\n\n      const { r } = await this.getArrayImpl(response, request, filterBody)\n\n      response.success(r);\n    }\n    catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n  async liveQuery(response: DataApiResponse, request: DataApiRequest, filterBody: any, serializeContext: () => Promise<any>, queryChannel: string) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n      const r = await this.getArrayImpl(response, request, filterBody)\n      const data: QueryData = {\n        requestJson: await serializeContext(),\n        findOptionsJson: findOptionsToJson(r.findOptions, this.repository.metadata),\n        lastIds: r.r.map(y => this.repository.metadata.idMetadata.getId(y))\n      }\n      await this.remult.liveQueryStorage.add(\n        {\n          entityKey: this.repository.metadata.key,\n          id: queryChannel,\n          data\n        }\n      );\n      response.success(r.r);\n    }\n    catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n  private async buildWhere(request: DataApiRequest, filterBody: any): Promise<EntityFilter<any>> {\n    var where: EntityFilter<any>[] = [];\n    if (this.repository.metadata.options.apiPrefilter) {\n      if (typeof this.repository.metadata.options.apiPrefilter === \"function\")\n        where.push(await this.repository.metadata.options.apiPrefilter());\n      else\n        where.push(this.repository.metadata.options.apiPrefilter);\n    }\n    if (request) {\n      where.push(buildFilterFromRequestParameters(this.repository.metadata, {\n        get: key => {\n          let result = request.get(key);\n          if (key.startsWith(customUrlToken) && result)\n            return JSON.parse(result);\n          return result;\n        }\n      }));\n    }\n    if (filterBody)\n      where.push(Filter.entityFilterFromJson(this.repository.metadata, filterBody))\n    return { $and: where };\n  }\n\n\n\n  private async doOnId(response: DataApiResponse, id: any, what: (row: T) => Promise<void>) {\n    try {\n\n\n\n      await this.repository.find({\n        where: { $and: [this.repository.metadata.options.apiPrefilter, this.repository.metadata.idMetadata.getIdFilter(id)] } as EntityFilter<any>\n      })\n        .then(async r => {\n          if (r.length == 0)\n            response.notFound();\n          else if (r.length > 1)\n            response.error({ message: \"id is not unique\" });\n          else\n            await what(r[0]);\n        });\n    } catch (err) {\n      response.error(err);\n    }\n  }\n  async put(response: DataApiResponse, id: any, body: any) {\n\n    await this.doOnId(response, id, async row => {\n      let ref = this.repository.getEntityRef(row) as rowHelperImplementation<T>;\n      await ref._updateEntityBasedOnApi(body);\n      if (!ref.apiUpdateAllowed) {\n        response.forbidden();\n        return;\n      }\n      await ref.save();\n      response.success(ref.toApiJson());\n    });\n  }\n\n  async delete(response: DataApiResponse, id: any) {\n    await this.doOnId(response, id, async row => {\n\n      if (!this.repository.getEntityRef(row).apiDeleteAllowed) {\n        response.forbidden();\n        return;\n      }\n      await this.repository.getEntityRef(row).delete();\n      response.deleted();\n    });\n  }\n\n\n  async post(response: DataApiResponse, body: any) {\n\n    try {\n\n      const insert = async (what: any) => {\n        let newr = this.repository.create();\n        await (this.repository.getEntityRef(newr) as rowHelperImplementation<T>)._updateEntityBasedOnApi(what);\n        if (!this.repository.getEntityRef(newr).apiInsertAllowed) {\n          throw new ForbiddenError();\n        }\n        await this.repository.getEntityRef(newr).save();\n        return this.repository.getEntityRef(newr).toApiJson()\n      }\n      if (Array.isArray(body)) {\n        const result = [];\n        await doTransaction(this.remult, async () => {\n          for (const item of body) {\n            result.push(await insert(item));\n          }\n        });\n        response.created(result);\n      }\n      else response.created(await insert(body));\n    } catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n\n}\n\nexport interface DataApiResponse {\n  success(data: any): void;\n  deleted(): void;\n  created(data: any): void;\n  notFound(): void;\n  error(data: ErrorInfo): void;\n  forbidden(): void;\n  progress(progress: number): void;\n\n}\n\n\n\n\nexport interface DataApiRequest {\n  get(key: string): any;\n}\nexport function determineSort(sortUrlParm: string, dirUrlParam: string) {\n  let dirItems: string[] = [];\n  if (dirUrlParam)\n    dirItems = dirUrlParam.split(',');\n  let result: any = {};\n  sortUrlParm.split(',').map((name, i) => {\n    let key = name.trim();\n    if (i < dirItems.length && dirItems[i].toLowerCase().trim().startsWith(\"d\"))\n      return result[key] = \"desc\";\n    else\n      return result[key] = \"asc\";\n  });\n  return result;\n\n}\n\n\n\nexport function serializeError(data: ErrorInfo) {\n  if (data instanceof TypeError) {\n    data = { message: data.message, stack: data.stack };\n  }\n  let x = JSON.parse(JSON.stringify(data));\n  if (!x.message && !x.modelState)\n    data = { message: data.message, stack: data.stack };\n  if (typeof x === 'string')\n    data = { message: x };\n  return data;\n}\n\n\nexport function getLiveQueryChannel(queryId: string, userId: string) {\n  return `users:${userId}:queries:${queryId}`\n}", "import { TestDataApiResponse } from \"../TestDataApiResponse\";\nimport { Done } from \"../Done\";\nimport { createData } from \"../createData\";\n\nimport { DataApi } from '../../data-api';\n\n\n\nimport { isBackend, Remult } from '../../context';\nimport { Categories as newCategories } from '../remult-3-entities';\nimport { Field, Entity as EntityDecorator, EntityBase } from '../../remult3';\nimport { testAsIfOnBackend } from \"../testHelper.spec\";\nimport { Filter } from \"../../filter/filter-interfaces\";\n\n\n\n\ndescribe(\"data api\", () => {\n  let remult = new Remult();\n  it(\"getArray works with predefined filter\", async () => {\n\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n      expect(data[0].id).toBe(2);\n\n      d.ok();\n    };\n    await api.getArray(t, undefined);\n    d.test();\n\n  });\n  it(\"get works with predefined filter\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    });\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n\n      expect(data.id).toBe(2);\n\n      d.ok();\n    };\n    await api.get(t, 2);\n    d.test();\n  });\n  it(\"get id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.get(t, 1);\n    d.test();\n  });\n  it(\"delete id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.delete(t, 1);\n    d.test();\n  });\n  it(\"delete id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.deleted = () => {\n      d.ok();\n    };\n    await api.delete(t, 2);\n    d.test();\n  });\n  it(\"put id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = () => {\n      d.ok();\n    };\n    await api.put(t, 2, { name: 'YAEL' });\n    d.test();\n  });\n  it(\"put id 1 works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.put(t, 1, { name: 'YAEL' });\n    d.test();\n  });\n  it(\"getArray works with predefined filter\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(0);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        if (x == c.create()._.fields.description.metadata.key)\n          return \"a\";\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter1 \", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 2\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest2);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 3\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest3);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 3 inherit\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest3Inherit);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 4\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest4);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter and inheritance\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTestThatInherits);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n\n  it(\"works with predefined Entity Filter\", async () => {\n    let [c] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    });\n    expect((await c.findFirst({ id: 1 })).categoryName).toBe('noam');\n    expect((await c.findId(1)).categoryName).toBe('noam');\n  });\n\n});\n\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: { description: 'b' }\n})\nclass stam1 extends newCategories {\n\n}\ndescribe(\"\", () => {\n  it(\"works with predefined Entity Filter\", async () => {\n    testAsIfOnBackend(async () => {\n      let [c] = await createData(async (i) => {\n        await i(1, 'noam', 'a');\n        await i(2, 'yael', 'b');\n        await i(3, 'yoni', 'a');\n      }, stam1);\n      let r = await c.find();\n      expect(r.length).toBe(1, 'array length');\n      expect(r[0].id).toBe(2, 'value of first row');\n      expect(await c.count()).toBe(1, 'count');\n      expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n      expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n    });\n  });\n})\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: async () => ({ description: 'b' })\n})\nclass stam2 extends newCategories {\n\n}\ndescribe(\"\", () => {\n  it(\"works with predefined Entity Filter lambda\", async () => {\n    testAsIfOnBackend(async () => {\n\n      let [c] = await createData(async (i) => {\n        await i(1, 'noam', 'a');\n        await i(2, 'yael', 'b');\n        await i(3, 'yoni', 'a');\n      }, stam2);\n      let r = await c.find();\n      expect(r.length).toBe(1, 'array length');\n      expect(r[0].id).toBe(2, 'value of first row');\n      expect(await c.count()).toBe(1, 'count');\n      expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n      expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n    })\n  });\n})\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: async () => ({ description: 'b' })\n})\nclass stam3 extends newCategories {\n\n}\nit(\"backend filter only works on backend\", async () => {\n  let [c] = await createData(async (i) => {\n    await i(1, 'noam', 'a');\n    await i(2, 'yael', 'b');\n    await i(3, 'yoni', 'a');\n  }, stam3);\n  expect(isBackend()).toBe(false);\n  let r = await c.find();\n  expect(r.length).toBe(3, 'array length');\n  expect(await c.count()).toBe(3, 'count');\n  await testAsIfOnBackend(async () => {\n    expect(await c.count()).toBe(1, 'count');\n    expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n    expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n  });\n});\n\n@EntityDecorator<CategoriesForThisTest>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: { description: 'b' }\n\n})\nclass CategoriesForThisTest extends newCategories { }\n@EntityDecorator<CategoriesForThisTest>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: () => ({ description: 'b' })\n\n})\nclass CategoriesForThisTest2 extends newCategories { }\n@EntityDecorator<CategoriesForThisTestThatInherits>(undefined, {\n  backendPrefilter: () => ({ categoryName: { $contains: 'a' } })\n\n})\nclass CategoriesForThisTestThatInherits extends CategoriesForThisTest2 { }\n\n\n@EntityDecorator<CategoriesForThisTest3>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: CategoriesForThisTest3.myFilter()\n\n})\nclass CategoriesForThisTest3 extends newCategories {\n  static myFilter = Filter.createCustom<CategoriesForThisTest3>(async (remult) => ({ description: 'b' }), \"key\");\n}\n@EntityDecorator<CategoriesForThisTest3Inherit>(undefined, {\n\n})\nclass CategoriesForThisTest3Inherit extends CategoriesForThisTest3 {\n\n}\n@EntityDecorator<CategoriesForThisTest4>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: () => CategoriesForThisTest4.myFilter()\n\n})\nclass CategoriesForThisTest4 extends newCategories {\n  static myFilter = Filter.createCustom<CategoriesForThisTest4>(async (remult) => ({ description: 'b' }));\n}", "import { Component, NgZone, OnInit } from '@angular/core';\nimport { Remult, Entity, IdEntity, Fields, Controller, InMemoryDataProvider, Sort, BackendMethod, remult, SubscriptionChannel, ProgressListener, Field } from 'remult';\nimport { GridSettings } from '@remult/angular/interfaces';\nimport { DialogConfig } from '../../../../angular';\nimport * as ably from 'ably';\nimport { Observable } from 'rxjs';\nimport { HttpClient } from '@angular/common/http';\n\n\n\n\n\n@Controller(\"blabla\")\n\n@Component({\n  selector: 'app-products',\n  templateUrl: './products.component.html',\n  styleUrls: ['./products.component.scss']\n  //,changeDetection: ChangeDetectionStrategy.OnPush\n})\n@DialogConfig({\n  height: '1500px'\n})\nexport class ProductsComponent {\n  constructor(private remult: Remult, private zone: NgZone, private http: HttpClient) {\n\n\n  }\n\n  tasks: Task[] = [];\n\n  async ngOnInit() {\n    remult.repo(Task).liveQuery({\n      load: () => []\n    }).subscribe(info => this.tasks = info.applyChanges(this.tasks))\n\n  }\n\n  countRemult = {};\n\n\n\n}\n\n@Entity(\"categories\", { allowApiRead: false })\nexport class Category {\n  @Fields.cuid()\n  id = ''\n  @Fields.string()\n  name = ''\n}\n\n@Entity(\"tasks\", {\n  allowApiCrud: true\n})\nexport class Task {\n  @Fields.autoIncrement()\n  id = 0\n  @Fields.string<Task>()\n  title = ''\n  @Fields.boolean()\n  completed = false\n\n  @Field(() => Category)\n  category?: Category\n\n\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async entityStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  async entityInstance() {\n    return \"ok\"\n  }\n  @Fields.string({ allowApiUpdate: false })\n  apiUpdateNotAllowed = '';\n  @Fields.string({ includeInApi: false })\n  includeInApiFalse = '';\n  @Fields.string({ serverExpression: () => '' })\n  serverExpression = '';\n}\n\nexport class TasksController {\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async undecoratedStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true })\n  static async testTrans() {\n    const repo = remult.repo(Task);\n    await repo.insert({ title: \"before error\" });\n    throw new Error(\"RRRRR\")\n    await repo.insert({ title: \"After Error\" })\n  }\n}\n@Controller(\"Decorated/myStuff/someMoreStuff\")\nexport class TasksControllerDecorated {\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async decoratedStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  async decorated() {\n    return \"ok\";\n  }\n}"], "fixing_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.20.6] - 2023-06-19\n\n- Fixed an issue when apiPrefilter was an arrow function, it did not affect get of a specific resource\n\n## [0.20.5] - 2023-06-11\n\n- fixed issue #200 transactions on mongo db\n\n## [0.20.4] - 2023-06-05\n\n- fixed issue with columns in postgres with casing in the db - sa `createdAt`\n- Issue #196 fixed - load options in live query\n- Fixed issue with `apiReadAllowed:false` when `apiUpdateAllowed` is set to undefined\n\n## [0.20.3] - 2023-05-23\n\n- Improved Open API Support\n\n## [0.20.2] - 2023-05-22\n\n- createdAt & updatedAt are by default `allowApiUpdate` false\n- Added `apiPrefix` to `BackendMethod` `options` to allow more control over backend method routes. #189\n\n## [0.20.1] - 2023-05-17\n\n- Improved support for compound id entity\n- Minor bug fixes\n- Improved memory usage\n\n## [0.20.0] - 2023-05-08\n\n- Added `handle` method for using remult in `next.js` api handlers. see [using remult in a next.js api handler](https://remult.dev/tutorials/react-next/appendix-1-get-server-side-props.html#using-remult-in-a-next-js-api-handler)\n- Added `remult-sveltekit` see [Add remult to your project](https://remult.dev/docs/add-remult-to-your-app.html#sveltekit)\n- Added support for `next.js` App Router. See [Add remult to your project](https://remult.dev/docs/add-remult-to-your-app.html#next-js-app-router)\n\n## [0.19.0] - 2023-03-26\n\n- `Repository`\n  - Added a `validate` method that returns an `ErrorInfo` object if invalid.\n  - Added a `fields` member that can be used to access the metadata of specific fields, for example:\n    ```ts\n    repo.fields.title.caption\n    //or\n    repo.fields.title.inputType\n    ```\n  - The `insert`, `validate`, `create`, `save` and `update` value will now run `fromJson` and `toJson` for field values that do not match their type - for consistent behavior with the `api`\n- `FieldMetadata`\n  - Added `apiUpdateAllowed` to query if `update` is allowed for this field\n  - Added `includedInApi` to query of this field would be returned from the backend as part of the api\n  - Added `displayValue` that can be used to achieve a consistent way a field is displayed.\n  - Added `toInput` and `fromInput` methods that'll help with translating values from and to inputs.\n- `getId` method added to `IdMetadata` to enable extracting the id from immutable objects, this is mainly useful for entities where the `id` column is not called `id` :)\n  ```ts\n  repo.metadata.idMetadata.getId(task)\n  ```\n-\n\n### Breaking Changes\n\n- In `EntityMetadata` the `apiUpdateAllowed`, `apiDeleteAllowed` and `apiInsertAllowed` that previously were boolean fields, are now methods that accepts item and return true or false. This is useful for cases where the apiAllowed rules refer to the specific values of an entity.\n  ```ts\n  // Previously\n  if (repo.metadata.apiDeleteAllowed) {\n  }\n  // Now\n  if (repo.metadata.apiDeleteAllowed(task)) {\n  }\n  ```\n- The `validate` method in `EntityRef` and `ControllerRef` that previously returned true if valid, now returns `undefined` if valid and `ErrorInfo` if invalid\n- `FieldMetadata`'s `ValueConverter` field's members are now mandatory and no longer optional - it's expected that they'll be implemented\n", "import type { MongoClient, Db, ClientSession } from 'mongodb';\nimport { DataProvider, EntityDataProvider, EntityFilter, EntityMetadata, Remult } from '.';\nimport { RepositoryOverloads } from './src/remult3';\nexport declare class MongoDataProvider implements DataProvider {\n    private db;\n    private client;\n    constructor(db: Db, client: MongoClient, options?: {\n        session?: ClientSession;\n        disableTransactions?: boolean;\n    });\n    session?: ClientSession;\n    disableTransactions: boolean;\n    static getDb(remult?: Remult): {\n        db: Db;\n        session: ClientSession;\n    };\n    getEntityDataProvider(entity: EntityMetadata<any>): EntityDataProvider;\n    transaction(action: (dataProvider: DataProvider) => Promise<void>): Promise<void>;\n    static filterToRaw<entityType>(entity: RepositoryOverloads<entityType>, condition: EntityFilter<entityType>): Promise<{\n        $and: any[];\n    } | {\n        $and?: undefined;\n    }>;\n}\n", "import { ClassType } from \"../../classType\";\nimport { Remult } from \"../context\";\nimport { DataProvider } from \"../data-interfaces\";\nimport { Repository } from \"../remult3\";\nimport { CategoriesForTesting } from \"../tests/remult-3-entities\";\nimport { Status } from \"../tests/testModel/models\";\nexport declare function itWithFocus(key: string, what: () => Promise<void>, focus?: boolean): void;\nexport declare function testAll(key: string, what: dbTestWhatSignature, focus?: boolean, options?: {\n    exclude?: string[];\n}): void;\nexport declare function addDatabaseToTest(tester: dbTestMethodSignature, key?: string): dbTestMethodSignature;\nexport declare function testInMemory(key: string, what: dbTestWhatSignature, focus?: boolean): void;\nexport declare const TestDbs: {\n    restDataProvider: string;\n    mongo: string;\n    inMemory: string;\n};\nexport declare type dbTestWhatSignature = ((db: {\n    db: DataProvider;\n    remult: Remult;\n    createEntity<entityType>(entity: ClassType<entityType>): Promise<Repository<entityType>>;\n}) => Promise<void>);\nexport declare type dbTestMethodSignature = ((key: string, what: dbTestWhatSignature, focus: boolean) => void) & {\n    key?: string;\n};\nexport declare function testAllDbs<T extends CategoriesForTesting>(key: string, doTest: (helper: {\n    remult: Remult;\n    createData: (doInsert?: (insert: (id: number, name: string, description?: string, status?: Status) => Promise<void>) => Promise<void>, entity?: {\n        new (): CategoriesForTesting;\n    }) => Promise<Repository<T>>;\n    insertFourRows: () => Promise<Repository<T>>;\n}) => Promise<any>, focus?: boolean): Promise<void>;\n", "import { AndFilter, customUrlToken, buildFilterFromRequestParameters } from './filter/filter-interfaces';\nimport { doTransaction, Remult, UserInfo } from './context';\nimport { Filter } from './filter/filter-interfaces';\nimport { FindOptions, Repository, EntityRef, rowHelperImplementation, EntityFilter } from './remult3';\nimport { ErrorInfo } from './data-interfaces';\nimport { ForbiddenError } from './server-action';\nimport { findOptionsToJson, liveQueryAction } from './data-providers/rest-data-provider';\nimport { QueryData } from './live-query/SubscriptionServer';\n\n\nexport class DataApi<T = any> {\n\n  constructor(private repository: Repository<T>, private remult: Remult) {\n  }\n  httpGet(res: DataApiResponse, req: DataApiRequest, serializeContext: () => Promise<any>) {\n    const action = req?.get(\"__action\");\n    if (action?.startsWith(liveQueryAction))\n      return this.liveQuery(res, req, undefined, serializeContext, getLiveQueryChannel(action.substring(liveQueryAction.length), this.remult.user?.id));\n    switch (action) {\n      case \"get\":\n      case \"count\":\n        return this.count(res, req, undefined);\n    }\n    return this.getArray(res, req, undefined);\n\n  }\n  async httpPost(res: DataApiResponse, req: DataApiRequest, body: any, serializeContext: () => Promise<any>) {\n    const action = req?.get(\"__action\");\n    if (action?.startsWith(liveQueryAction))\n      return this.liveQuery(res, req, undefined, serializeContext, getLiveQueryChannel(action.substring(liveQueryAction.length), this.remult.user?.id));\n    switch (action) {\n      case \"get\":\n        return this.getArray(res, req, body);\n      case \"count\":\n        return this.count(res, req, body);\n      case \"endLiveQuery\":\n        await this.remult.liveQueryStorage.remove(getLiveQueryChannel(body.id, this.remult.user?.id));\n        res.success(\"ok\");\n        return;\n      default:\n        return this.post(res, body);\n    }\n  }\n  static defaultGetLimit = 0;\n  async get(response: DataApiResponse, id: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    await this.doOnId(response, id, async row => response.success(this.repository.getEntityRef(row).toApiJson()));\n  }\n  async count(response: DataApiResponse, request: DataApiRequest, filterBody?: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n\n      response.success({ count: +await this.repository.count(await this.buildWhere(request, filterBody)) });\n    } catch (err) {\n      response.error(err);\n    }\n  }\n\n\n  async getArrayImpl(response: DataApiResponse, request: DataApiRequest, filterBody: any) {\n\n    let findOptions: FindOptions<T> = { load: () => [] };\n    findOptions.where = await this.buildWhere(request, filterBody);\n\n    if (request) {\n\n      let sort = <string>request.get(\"_sort\");\n      if (sort != undefined) {\n        let dir = request.get('_order');\n        findOptions.orderBy = determineSort(sort, dir);\n\n      }\n      let limit = +request.get(\"_limit\");\n      if (!limit && DataApi.defaultGetLimit)\n        limit = DataApi.defaultGetLimit;\n      findOptions.limit = limit;\n      findOptions.page = +request.get(\"_page\");\n\n    }\n    if (this.remult.isAllowed(this.repository.metadata.options.apiRequireId)) {\n      let hasId = false;\n      let w = await Filter.fromEntityFilter(this.repository.metadata, findOptions.where);\n      if (w) {\n        w.__applyToConsumer({\n          containsCaseInsensitive: () => { },\n          isDifferentFrom: () => { },\n          isEqualTo: (col, val) => {\n            if (this.repository.metadata.idMetadata.isIdField(col))\n              hasId = true;\n          },\n          custom: () => { },\n          databaseCustom: () => { },\n          isGreaterOrEqualTo: () => { },\n          isGreaterThan: () => { },\n          isIn: () => { },\n          isLessOrEqualTo: () => { },\n          isLessThan: () => { },\n          isNotNull: () => { },\n          isNull: () => { },\n\n          or: () => { }\n        });\n      }\n      if (!hasId) {\n        response.forbidden();\n        throw new ForbiddenError();\n      }\n    }\n    const r = await this.repository.find(findOptions)\n      .then(async r => {\n        return await Promise.all(r.map(async y => this.repository.getEntityRef(y).toApiJson()));\n      });\n    return { r, findOptions };\n\n  }\n\n  async getArray(response: DataApiResponse, request: DataApiRequest, filterBody?: any) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n\n\n      const { r } = await this.getArrayImpl(response, request, filterBody)\n\n      response.success(r);\n    }\n    catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n  async liveQuery(response: DataApiResponse, request: DataApiRequest, filterBody: any, serializeContext: () => Promise<any>, queryChannel: string) {\n    if (!this.repository.metadata.apiReadAllowed) {\n      response.forbidden();\n      return;\n    }\n    try {\n      const r = await this.getArrayImpl(response, request, filterBody)\n      const data: QueryData = {\n        requestJson: await serializeContext(),\n        findOptionsJson: findOptionsToJson(r.findOptions, this.repository.metadata),\n        lastIds: r.r.map(y => this.repository.metadata.idMetadata.getId(y))\n      }\n      await this.remult.liveQueryStorage.add(\n        {\n          entityKey: this.repository.metadata.key,\n          id: queryChannel,\n          data\n        }\n      );\n      response.success(r.r);\n    }\n    catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n  private async buildWhere(request: DataApiRequest, filterBody: any): Promise<EntityFilter<any>> {\n    var where: EntityFilter<any>[] = [];\n    if (this.repository.metadata.options.apiPrefilter) {\n      if (typeof this.repository.metadata.options.apiPrefilter === \"function\")\n        where.push(await this.repository.metadata.options.apiPrefilter());\n      else\n        where.push(this.repository.metadata.options.apiPrefilter);\n    }\n    if (request) {\n      where.push(buildFilterFromRequestParameters(this.repository.metadata, {\n        get: key => {\n          let result = request.get(key);\n          if (key.startsWith(customUrlToken) && result)\n            return JSON.parse(result);\n          return result;\n        }\n      }));\n    }\n    if (filterBody)\n      where.push(Filter.entityFilterFromJson(this.repository.metadata, filterBody))\n    return { $and: where };\n  }\n\n\n\n  private async doOnId(response: DataApiResponse, id: any, what: (row: T) => Promise<void>) {\n    try {\n\n      var where: EntityFilter<any>[] = [this.repository.metadata.idMetadata.getIdFilter(id)];\n      if (this.repository.metadata.options.apiPrefilter) {\n        if (typeof this.repository.metadata.options.apiPrefilter === \"function\")\n          where.push(await this.repository.metadata.options.apiPrefilter());\n        else\n          where.push(this.repository.metadata.options.apiPrefilter);\n      }\n\n      await this.repository.find({\n        where: { $and: where } as EntityFilter<any>\n      })\n        .then(async r => {\n          if (r.length == 0)\n            response.notFound();\n          else if (r.length > 1)\n            response.error({ message: \"id is not unique\" });\n          else\n            await what(r[0]);\n        });\n    } catch (err) {\n      response.error(err);\n    }\n  }\n  async put(response: DataApiResponse, id: any, body: any) {\n\n    await this.doOnId(response, id, async row => {\n      let ref = this.repository.getEntityRef(row) as rowHelperImplementation<T>;\n      await ref._updateEntityBasedOnApi(body);\n      if (!ref.apiUpdateAllowed) {\n        response.forbidden();\n        return;\n      }\n      await ref.save();\n      response.success(ref.toApiJson());\n    });\n  }\n\n  async delete(response: DataApiResponse, id: any) {\n    await this.doOnId(response, id, async row => {\n\n      if (!this.repository.getEntityRef(row).apiDeleteAllowed) {\n        response.forbidden();\n        return;\n      }\n      await this.repository.getEntityRef(row).delete();\n      response.deleted();\n    });\n  }\n\n\n  async post(response: DataApiResponse, body: any) {\n\n    try {\n\n      const insert = async (what: any) => {\n        let newr = this.repository.create();\n        await (this.repository.getEntityRef(newr) as rowHelperImplementation<T>)._updateEntityBasedOnApi(what);\n        if (!this.repository.getEntityRef(newr).apiInsertAllowed) {\n          throw new ForbiddenError();\n        }\n        await this.repository.getEntityRef(newr).save();\n        return this.repository.getEntityRef(newr).toApiJson()\n      }\n      if (Array.isArray(body)) {\n        const result = [];\n        await doTransaction(this.remult, async () => {\n          for (const item of body) {\n            result.push(await insert(item));\n          }\n        });\n        response.created(result);\n      }\n      else response.created(await insert(body));\n    } catch (err) {\n      if (err.isForbiddenError)\n        response.forbidden();\n      else\n        response.error(err);\n    }\n  }\n\n}\n\nexport interface DataApiResponse {\n  success(data: any): void;\n  deleted(): void;\n  created(data: any): void;\n  notFound(): void;\n  error(data: ErrorInfo): void;\n  forbidden(): void;\n  progress(progress: number): void;\n\n}\n\n\n\n\nexport interface DataApiRequest {\n  get(key: string): any;\n}\nexport function determineSort(sortUrlParm: string, dirUrlParam: string) {\n  let dirItems: string[] = [];\n  if (dirUrlParam)\n    dirItems = dirUrlParam.split(',');\n  let result: any = {};\n  sortUrlParm.split(',').map((name, i) => {\n    let key = name.trim();\n    if (i < dirItems.length && dirItems[i].toLowerCase().trim().startsWith(\"d\"))\n      return result[key] = \"desc\";\n    else\n      return result[key] = \"asc\";\n  });\n  return result;\n\n}\n\n\n\nexport function serializeError(data: ErrorInfo) {\n  if (data instanceof TypeError) {\n    data = { message: data.message, stack: data.stack };\n  }\n  let x = JSON.parse(JSON.stringify(data));\n  if (!x.message && !x.modelState)\n    data = { message: data.message, stack: data.stack };\n  if (typeof x === 'string')\n    data = { message: x };\n  return data;\n}\n\n\nexport function getLiveQueryChannel(queryId: string, userId: string) {\n  return `users:${userId}:queries:${queryId}`\n}", "import { TestDataApiResponse } from \"../TestDataApiResponse\";\nimport { Done } from \"../Done\";\nimport { createData } from \"../createData\";\n\nimport { DataApi } from '../../data-api';\n\n\n\nimport { isBackend, Remult } from '../../context';\nimport { Categories as newCategories } from '../remult-3-entities';\nimport { Field, Entity as EntityDecorator, EntityBase } from '../../remult3';\nimport { testAsIfOnBackend } from \"../testHelper.spec\";\nimport { Filter } from \"../../filter/filter-interfaces\";\n\n\n\n\ndescribe(\"data api\", () => {\n  let remult = new Remult();\n  it(\"getArray works with predefined filter\", async () => {\n\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n      expect(data[0].id).toBe(2);\n\n      d.ok();\n    };\n    await api.getArray(t, undefined);\n    d.test();\n\n  });\n  it(\"get works with predefined filter\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    });\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n\n      expect(data.id).toBe(2);\n\n      d.ok();\n    };\n    await api.get(t, 2);\n    d.test();\n  });\n  it(\"get id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.get(t, 1);\n    d.test();\n  });\n  it(\"delete id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.delete(t, 1);\n    d.test();\n  });\n  it(\"delete id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.deleted = () => {\n      d.ok();\n    };\n    await api.delete(t, 2);\n    d.test();\n  });\n  it(\"put id  works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = () => {\n      d.ok();\n    };\n    await api.put(t, 2, { name: 'YAEL' });\n    d.test();\n  });\n  it(\"put id 1 works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.put(t, 1, { name: 'YAEL' });\n    d.test();\n  });\n  it(\"put id 1 works with predefined filterand shouldnt return anything\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest2);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.notFound = () => {\n      d.ok();\n    };\n    await api.put(t, 1, { name: 'YAEL' });\n    d.test();\n  });\n  it(\"getArray works with predefined filter\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(0);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        if (x == c.create()._.fields.description.metadata.key)\n          return \"a\";\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter1 \", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 2\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest2);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 3\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest3);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 3 inherit\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest3Inherit);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter 4\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTest4);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n  it(\"getArray works with predefined filter and inheritance\", async () => {\n    let [c, remult] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    }, CategoriesForThisTestThatInherits);\n    var api = new DataApi(c, remult);\n    let t = new TestDataApiResponse();\n    let d = new Done();\n    t.success = data => {\n      expect(data.length).toBe(1);\n\n      d.ok();\n    };\n    await api.getArray(t, {\n      get: x => {\n        return undefined;\n      }\n    });\n    d.test();\n  });\n\n  it(\"works with predefined Entity Filter\", async () => {\n    let [c] = await createData(async (i) => {\n      await i(1, 'noam', 'a');\n      await i(2, 'yael', 'b');\n      await i(3, 'yoni', 'a');\n    });\n    expect((await c.findFirst({ id: 1 })).categoryName).toBe('noam');\n    expect((await c.findId(1)).categoryName).toBe('noam');\n  });\n\n});\n\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: { description: 'b' }\n})\nclass stam1 extends newCategories {\n\n}\ndescribe(\"\", () => {\n  it(\"works with predefined Entity Filter\", async () => {\n    testAsIfOnBackend(async () => {\n      let [c] = await createData(async (i) => {\n        await i(1, 'noam', 'a');\n        await i(2, 'yael', 'b');\n        await i(3, 'yoni', 'a');\n      }, stam1);\n      let r = await c.find();\n      expect(r.length).toBe(1, 'array length');\n      expect(r[0].id).toBe(2, 'value of first row');\n      expect(await c.count()).toBe(1, 'count');\n      expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n      expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n    });\n  });\n})\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: async () => ({ description: 'b' })\n})\nclass stam2 extends newCategories {\n\n}\ndescribe(\"\", () => {\n  it(\"works with predefined Entity Filter lambda\", async () => {\n    testAsIfOnBackend(async () => {\n\n      let [c] = await createData(async (i) => {\n        await i(1, 'noam', 'a');\n        await i(2, 'yael', 'b');\n        await i(3, 'yoni', 'a');\n      }, stam2);\n      let r = await c.find();\n      expect(r.length).toBe(1, 'array length');\n      expect(r[0].id).toBe(2, 'value of first row');\n      expect(await c.count()).toBe(1, 'count');\n      expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n      expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n    })\n  });\n})\n@EntityDecorator<stam1>('categories', {\n  backendPrefilter: async () => ({ description: 'b' })\n})\nclass stam3 extends newCategories {\n\n}\nit(\"backend filter only works on backend\", async () => {\n  let [c] = await createData(async (i) => {\n    await i(1, 'noam', 'a');\n    await i(2, 'yael', 'b');\n    await i(3, 'yoni', 'a');\n  }, stam3);\n  expect(isBackend()).toBe(false);\n  let r = await c.find();\n  expect(r.length).toBe(3, 'array length');\n  expect(await c.count()).toBe(3, 'count');\n  await testAsIfOnBackend(async () => {\n    expect(await c.count()).toBe(1, 'count');\n    expect(await c.findFirst({ id: 1 })).toBe(undefined, 'find first');\n    expect((await c.findFirst({ id: 1 }, { createIfNotFound: true }))._.isNew()).toBe(true, 'lookup ');\n  });\n});\n\n@EntityDecorator<CategoriesForThisTest>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: { description: 'b' }\n\n})\nclass CategoriesForThisTest extends newCategories { }\n@EntityDecorator<CategoriesForThisTest>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: () => ({ description: 'b' })\n\n})\nclass CategoriesForThisTest2 extends newCategories { }\n@EntityDecorator<CategoriesForThisTestThatInherits>(undefined, {\n  backendPrefilter: () => ({ categoryName: { $contains: 'a' } })\n\n})\nclass CategoriesForThisTestThatInherits extends CategoriesForThisTest2 { }\n\n\n@EntityDecorator<CategoriesForThisTest3>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: CategoriesForThisTest3.myFilter()\n\n})\nclass CategoriesForThisTest3 extends newCategories {\n  static myFilter = Filter.createCustom<CategoriesForThisTest3>(async (remult) => ({ description: 'b' }), \"key\");\n}\n@EntityDecorator<CategoriesForThisTest3Inherit>(undefined, {\n\n})\nclass CategoriesForThisTest3Inherit extends CategoriesForThisTest3 {\n\n}\n@EntityDecorator<CategoriesForThisTest4>(undefined, {\n  allowApiUpdate: true,\n  allowApiDelete: true,\n  apiPrefilter: () => CategoriesForThisTest4.myFilter()\n\n})\nclass CategoriesForThisTest4 extends newCategories {\n  static myFilter = Filter.createCustom<CategoriesForThisTest4>(async (remult) => ({ description: 'b' }));\n}", "import { Component, NgZone, OnInit } from '@angular/core';\nimport { Remult, Entity, IdEntity, Fields, Controller, InMemoryDataProvider, Sort, BackendMethod, remult, SubscriptionChannel, ProgressListener, Field } from 'remult';\nimport { GridSettings } from '@remult/angular/interfaces';\nimport { DialogConfig } from '../../../../angular';\nimport * as ably from 'ably';\nimport { Observable } from 'rxjs';\nimport { HttpClient } from '@angular/common/http';\n\n\n\n\n\n@Controller(\"blabla\")\n\n@Component({\n  selector: 'app-products',\n  templateUrl: './products.component.html',\n  styleUrls: ['./products.component.scss']\n  //,changeDetection: ChangeDetectionStrategy.OnPush\n})\n@DialogConfig({\n  height: '1500px'\n})\nexport class ProductsComponent {\n  constructor(private remult: Remult, private zone: NgZone, private http: HttpClient) {\n\n\n  }\n\n  tasks: Task[] = [];\n\n  async ngOnInit() {\n    remult.repo(Task).liveQuery({\n      load: () => []\n    }).subscribe(info => this.tasks = info.applyChanges(this.tasks))\n\n  }\n\n  countRemult = {};\n\n\n\n}\n\n@Entity<Category>(\"categories\", {\n  allowApiCrud: true, apiPrefilter: () => ({\n    id: { $ne: \"clj30u9o500000kr3956ph9ep\" }\n  })\n})\nexport class Category {\n  @Fields.cuid()\n  id = ''\n  @Fields.string()\n  name = ''\n}\n\n@Entity(\"tasks\", {\n  allowApiCrud: true\n})\nexport class Task {\n  @Fields.autoIncrement()\n  id = 0\n  @Fields.string<Task>()\n  title = ''\n  @Fields.boolean()\n  completed = false\n\n  @Field(() => Category)\n  category?: Category\n\n\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async entityStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  async entityInstance() {\n    return \"ok\"\n  }\n  @Fields.string({ allowApiUpdate: false })\n  apiUpdateNotAllowed = '';\n  @Fields.string({ includeInApi: false })\n  includeInApiFalse = '';\n  @Fields.string({ serverExpression: () => '' })\n  serverExpression = '';\n}\n\nexport class TasksController {\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async undecoratedStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true })\n  static async testTrans() {\n    const repo = remult.repo(Task);\n    await repo.insert({ title: \"before error\" });\n    throw new Error(\"RRRRR\")\n    await repo.insert({ title: \"After Error\" })\n  }\n}\n@Controller(\"Decorated/myStuff/someMoreStuff\")\nexport class TasksControllerDecorated {\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  static async decoratedStatic() {\n    return \"ok\";\n  }\n  @BackendMethod({ allowed: true, apiPrefix: 'noam' })\n  async decorated() {\n    return \"ok\";\n  }\n}"], "filenames": ["CHANGELOG.md", "misc/dts-compare/remult-mongo.d.ts", "misc/dts-compare/src/shared-tests/db-tests-setup.d.ts", "projects/core/src/data-api.ts", "projects/core/src/tests/test-data-api/predefined-filter.spec.ts", "projects/test-angular/src/app/products-test/products.component.ts"], "buggy_code_start_loc": [3, 1, 15, 198, 124, 45], "buggy_code_end_loc": [3, 9, 15, 202, 124, 46], "fixing_code_start_loc": [4, 1, 16, 198, 125, 45], "fixing_code_end_loc": [8, 17, 17, 208, 140, 50], "type": "CWE-284", "message": "Remult is a CRUD framework for full-stack TypeScript. If you used the apiPrefilter option of the `@Entity` decorator, by setting it to a function that returns a filter that prevents unauthorized access to data, an attacker who knows the `id` of an entity instance is not authorized to access, can gain read, update and delete access to it. The issue is fixed in version 0.20.6. As a workaround, set the `apiPrefilter` option to a filter object instead of a function.", "other": {"cve": {"id": "CVE-2023-35167", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-23T20:15:09.227", "lastModified": "2023-07-05T16:17:49.733", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Remult is a CRUD framework for full-stack TypeScript. If you used the apiPrefilter option of the `@Entity` decorator, by setting it to a function that returns a filter that prevents unauthorized access to data, an attacker who knows the `id` of an entity instance is not authorized to access, can gain read, update and delete access to it. The issue is fixed in version 0.20.6. As a workaround, set the `apiPrefilter` option to a filter object instead of a function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:remult:remult:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.20.6", "matchCriteriaId": "AD3B9675-5858-4D19-BAC9-FB474B5A650D"}]}]}], "references": [{"url": "https://github.com/remult/remult/commit/6892ae97134126d8710ef7302bb2fc37730994c5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/remult/remult/releases/tag/v0.20.6", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/remult/remult/security/advisories/GHSA-7hh3-3x64-v2g9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/remult/remult/commit/6892ae97134126d8710ef7302bb2fc37730994c5"}}