{"buggy_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Nyholm\\Psr7\\ServerRequest;\nuse Nyholm\\Psr7\\Stream;\nuse Nyholm\\Psr7\\UploadedFile;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Riverline\\MultiPartParser\\Part;\nuse RuntimeException;\n\nuse function str_starts_with;\n\n/**\n * Bridges PSR-7 requests and responses with API Gateway or ALB event/response formats.\n */\nfinal class Psr7Bridge\n{\n    private const UPLOADED_FILES_PREFIX = 'bref_upload_';\n\n    /**\n     * Create a PSR-7 server request from an AWS Lambda HTTP event.\n     */\n    public static function convertRequest(HttpRequestEvent $event, Context $context): ServerRequestInterface\n    {\n        $headers = $event->getHeaders();\n\n        [$files, $parsedBody] = self::parseBodyAndUploadedFiles($event);\n        [$user, $password] = $event->getBasicAuthCredentials();\n\n        $server = array_filter([\n            'CONTENT_LENGTH' => $headers['content-length'][0] ?? null,\n            'CONTENT_TYPE' => $event->getContentType(),\n            'DOCUMENT_ROOT' => getcwd(),\n            'QUERY_STRING' => $event->getQueryString(),\n            'REQUEST_METHOD' => $event->getMethod(),\n            'SERVER_NAME' => $event->getServerName(),\n            'SERVER_PORT' => $event->getServerPort(),\n            'SERVER_PROTOCOL' => $event->getProtocol(),\n            'PATH_INFO' => $event->getPath(),\n            'HTTP_HOST' => $headers['host'] ?? null,\n            'REMOTE_ADDR' => $event->getSourceIp(),\n            'REMOTE_PORT' => $event->getRemotePort(),\n            'REQUEST_TIME' => time(),\n            'REQUEST_TIME_FLOAT' => microtime(true),\n            'REQUEST_URI' => $event->getUri(),\n            'PHP_AUTH_USER' => $user,\n            'PHP_AUTH_PW' => $password,\n        ]);\n\n        foreach ($headers as $name => $values) {\n            $server['HTTP_' . strtoupper(str_replace('-', '_', (string) $name))] = $values[0];\n        }\n\n        /**\n         * Nyholm/psr7 does not rewind body streams, we do it manually\n         * so that users can fetch the content of the body directly.\n         */\n        $bodyStream = Stream::create($event->getBody());\n        $bodyStream->rewind();\n\n        $request = new ServerRequest(\n            $event->getMethod(),\n            $event->getUri(),\n            $event->getHeaders(),\n            $bodyStream,\n            $event->getProtocolVersion(),\n            $server\n        );\n\n        foreach ($event->getPathParameters() as $key => $value) {\n            $request = $request->withAttribute($key, $value);\n        }\n\n        return $request->withUploadedFiles($files)\n            ->withCookieParams($event->getCookies())\n            ->withQueryParams($event->getQueryParameters())\n            ->withParsedBody($parsedBody)\n            ->withAttribute('lambda-event', $event)\n            ->withAttribute('lambda-context', $context);\n    }\n\n    /**\n     * Create a ALB/API Gateway response from a PSR-7 response.\n     */\n    public static function convertResponse(ResponseInterface $response): HttpResponse\n    {\n        $response->getBody()->rewind();\n        $body = $response->getBody()->getContents();\n\n        return new HttpResponse($body, $response->getHeaders(), $response->getStatusCode());\n    }\n\n    private static function parseBodyAndUploadedFiles(HttpRequestEvent $event): array\n    {\n        $bodyString = $event->getBody();\n        $files = [];\n        $parsedBody = null;\n        $contentType = $event->getContentType();\n        if ($contentType !== null && $event->getMethod() === 'POST') {\n            if (str_starts_with($contentType, 'application/x-www-form-urlencoded')) {\n                parse_str($bodyString, $parsedBody);\n            } else {\n                $document = new Part(\"Content-type: $contentType\\r\\n\\r\\n\" . $bodyString);\n                if ($document->isMultiPart()) {\n                    $parsedBody = [];\n                    foreach ($document->getParts() as $part) {\n                        if ($part->isFile()) {\n                            $tmpPath = tempnam(sys_get_temp_dir(), self::UPLOADED_FILES_PREFIX);\n                            if ($tmpPath === false) {\n                                throw new RuntimeException('Unable to create a temporary directory');\n                            }\n                            file_put_contents($tmpPath, $part->getBody());\n                            $file = new UploadedFile($tmpPath, filesize($tmpPath), UPLOAD_ERR_OK, $part->getFileName(), $part->getMimeType());\n\n                            self::parseKeyAndInsertValueInArray($files, $part->getName(), $file);\n                        } else {\n                            self::parseKeyAndInsertValueInArray($parsedBody, $part->getName(), $part->getBody());\n                        }\n                    }\n                }\n            }\n        }\n        return [$files, $parsedBody];\n    }\n\n    /**\n     * Parse a string key like \"files[id_cards][jpg][]\" and do $array['files']['id_cards']['jpg'][] = $value\n     */\n    private static function parseKeyAndInsertValueInArray(array &$array, string $key, mixed $value): void\n    {\n        if (! str_contains($key, '[')) {\n            $array[$key] = $value;\n\n            return;\n        }\n\n        $parts = explode('[', $key); // files[id_cards][jpg][] => [ 'files',  'id_cards]', 'jpg]', ']' ]\n        $pointer = &$array;\n\n        foreach ($parts as $k => $part) {\n            if ($k === 0) {\n                $pointer = &$pointer[$part];\n\n                continue;\n            }\n\n            // Skip two special cases:\n            // [[ in the key produces empty string\n            // [test : starts with [ but does not end with ]\n            if ($part === '' || ! str_ends_with($part, ']')) {\n                // Malformed key, we use it \"as is\"\n                $array[$key] = $value;\n\n                return;\n            }\n\n            $part = substr($part, 0, -1); // The last char is a ] => remove it to have the real key\n\n            if ($part === '') { // [] case\n                $pointer = &$pointer[];\n            } else {\n                $pointer = &$pointer[$part];\n            }\n        }\n\n        $pointer = $value;\n    }\n\n    /**\n     * Cleanup previously uploaded files.\n     */\n    public static function cleanupUploadedFiles(): void\n    {\n        // See https://github.com/brefphp/bref/commit/c77d9f5abf021f29fa96b5720b7b84adbd199092#r137983026\n        $tmpFiles = glob(sys_get_temp_dir() . '/' . self::UPLOADED_FILES_PREFIX . '[A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9]');\n\n        if ($tmpFiles !== false) {\n            foreach ($tmpFiles as $file) {\n                if (is_file($file)) {\n                    // Silence warnings, we don't want to crash the whole runtime\n                    @unlink($file);\n                }\n            }\n        }\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Test\\HttpRequestProxyTest;\nuse PHPUnit\\Framework\\TestCase;\n\nabstract class CommonHttpTest extends TestCase implements HttpRequestProxyTest\n{\n    public function provide\u00a0API\u00a0Gateway\u00a0versions(): array\n    {\n        return [\n            'v1' => [1],\n            'v2' => [2],\n        ];\n    }\n\n    public function test\u00a0request\u00a0with\u00a0no\u00a0version\u00a0fallbacks\u00a0to\u00a0v1()\n    {\n        $this->fromFixture(__DIR__ . '/Fixture/ag-no-version.json');\n\n        $this->assertBody('');\n        $this->assertContentType(null);\n        $this->assertHeaders([\n            'accept' => ['*/*'],\n            'accept-encoding' => ['gzip, deflate'],\n            'cache-control' => ['no-cache'],\n            'host' => ['example.org'],\n            'user-agent' => ['PostmanRuntime/7.20.1'],\n            'x-amzn-trace-id' => ['Root=1-ffffffff-ffffffffffffffffffffffff'],\n            'x-forwarded-for' => ['1.1.1.1'],\n            'x-forwarded-port' => ['443'],\n            'x-forwarded-proto' => ['https'],\n        ]);\n        $this->assertMethod('GET');\n        $this->assertUri('/path');\n        $this->assertSourceIp('1.1.1.1');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0simple\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-simple.json\");\n\n        $this->assertBody('');\n        $this->assertContentType(null);\n        $this->assertCookies([]);\n        $this->assertHeaders([\n            'accept' => ['*/*'],\n            'accept-encoding' => ['gzip, deflate'],\n            'cache-control' => ['no-cache'],\n            'host' => ['example.org'],\n            'user-agent' => ['PostmanRuntime/7.20.1'],\n            'x-amzn-trace-id' => ['Root=1-ffffffff-ffffffffffffffffffffffff'],\n            'x-forwarded-for' => ['1.1.1.1'],\n            'x-forwarded-port' => ['443'],\n            'x-forwarded-proto' => ['https'],\n        ]);\n        $this->assertMethod('GET');\n        $this->assertPath('/path');\n        $this->assertProtocol('HTTP/1.1');\n        $this->assertProtocolVersion('1.1');\n        $this->assertQueryParameters([]);\n        $this->assertQueryString('');\n        $this->assertRemotePort(443);\n        $this->assertServerName('example.org');\n        $this->assertServerPort(443);\n        $this->assertUri('/path');\n        $this->assertHasMultiHeader(false);\n        $this->assertSourceIp('1.1.1.1');\n    }\n\n    public function test\u00a0v1\u00a0stage\u00a0prefix\u00a0is\u00a0not\u00a0included\u00a0in\u00a0the\u00a0URL()\n    {\n        $this->fromFixture(__DIR__ . '/Fixture/ag-v1-stage-prefix.json');\n\n        $this->assertPath('/path');\n        $this->assertUri('/path');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0query\u00a0string(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string.json\");\n\n        $this->assertPath('/path');\n        $this->assertQueryParameters(['foo' => 'bar', 'baz.bar' => 'foo']);\n        $this->assertQueryString('foo=bar&baz.bar=foo');\n        $this->assertUri('/path?foo=bar&baz.bar=foo');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0multivalues\u00a0query\u00a0string\u00a0have\u00a0basic\u00a0support(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string-multivalue.json\");\n\n        $this->assertQueryParameters([\n            'foo' => ['bar', 'baz'],\n            'cards' => ['birthday'],\n            'colors' => [['red'], ['blue']],\n            'shapes' => ['a' => ['square', 'triangle']],\n            'myvar' => 'abc',\n            'foo.bar' => ['baz'],\n            'array' => ['one', 'two'],\n        ]);\n        $this->assertQueryString('foo%5B0%5D=bar&foo%5B1%5D=baz&cards%5B0%5D=birthday&colors%5B0%5D%5B0%5D=red&colors%5B1%5D%5B0%5D=blue&shapes%5Ba%5D%5B0%5D=square&shapes%5Ba%5D%5B1%5D=triangle&myvar=abc&foo.bar%5B0%5D=baz&array%5B0%5D=one&array%5B1%5D=two');\n        $this->assertUri('/path?foo%5B0%5D=bar&foo%5B1%5D=baz&cards%5B0%5D=birthday&colors%5B0%5D%5B0%5D=red&colors%5B1%5D%5B0%5D=blue&shapes%5Ba%5D%5B0%5D=square&shapes%5Ba%5D%5B1%5D=triangle&myvar=abc&foo.bar%5B0%5D=baz&array%5B0%5D=one&array%5B1%5D=two');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0arrays\u00a0in\u00a0query\u00a0string(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string-arrays.json\");\n\n        $this->assertQueryParameters([\n            'vars' => [\n                'val1' => 'foo',\n                'val2' => ['bar'],\n            ],\n            'foo.bar' => ['baz'],\n        ]);\n        if ($version === 2) {\n            // Numeric keys are added as an artifact of us parsing the query string\n            // Both format are valid and semantically identical\n            $this->assertQueryString('vars%5Bval1%5D=foo&vars%5Bval2%5D%5B0%5D=bar&foo.bar%5B0%5D=baz');\n            $this->assertUri('/path?vars%5Bval1%5D=foo&vars%5Bval2%5D%5B0%5D=bar&foo.bar%5B0%5D=baz');\n        } else {\n            $this->assertQueryString('vars%5Bval1%5D=foo&vars%5Bval2%5D%5B%5D=bar&foo.bar%5B%5D=baz');\n            $this->assertUri('/path?vars%5Bval1%5D=foo&vars%5Bval2%5D%5B%5D=bar&foo.bar%5B%5D=baz');\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0custom\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-custom.json\");\n        $this->assertHeader('x-my-header', ['Hello world']);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0custom\u00a0multi\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-custom-multivalue.json\");\n        if ($version === 2) {\n            // In v2, multi-value headers are joined by a comma\n            // See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n            $this->assertHeader('x-my-header', ['Hello world,Hello john']);\n        } else {\n            $this->assertHeader('x-my-header', ['Hello world', 'Hello john']);\n            $this->assertHasMultiHeader(true);\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0numeric\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-numeric.json\");\n        $this->assertHeader('12345', ['Hello world']);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0numeric\u00a0multi\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-numeric-multivalue.json\");\n        if ($version === 2) {\n            // In v2, multi-value headers are joined by a comma\n            // See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n            $this->assertHeader('12345', ['Hello world,Hello john']);\n        } else {\n            $this->assertHeader('12345', ['Hello world', 'Hello john']);\n            $this->assertHasMultiHeader(true);\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0raw\u00a0body(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-json.json\");\n\n        $this->assertMethod('PUT');\n        $this->assertContentType('application/json');\n        $this->assertHeader('content-length', [13]);\n        $this->assertBody('{\"foo\":\"bar\"}');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form.json\");\n\n        $this->assertMethod('POST');\n        $this->assertContentType('application/x-www-form-urlencoded');\n        $this->assertHeader('content-length', [15]);\n        $this->assertBody('foo=bar&bim=baz');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0form\u00a0data\u00a0and\u00a0content\u00a0type(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-content-type.json\");\n\n        $this->assertContentType('application/x-www-form-urlencoded;charset=UTF-8');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    public function provideHttpMethodsWithRequestBodySupport(): array\n    {\n        return [\n            'POST v1' => [\n                'version' => 1,\n                'method' => 'POST',\n            ],\n            'POST v2' => [\n                'version' => 2,\n                'method' => 'POST',\n            ],\n            'PUT v1' => [\n                'version' => 1,\n                'method' => 'PUT',\n            ],\n            'PUT v2' => [\n                'version' => 2,\n                'method' => 'PUT',\n            ],\n            'PATCH v1' => [\n                'version' => 1,\n                'method' => 'PATCH',\n            ],\n            'PATCH v2' => [\n                'version' => 2,\n                'method' => 'PATCH',\n            ],\n        ];\n    }\n\n    /**\n     * @see https://github.com/brefphp/bref/issues/162\n     *\n     * @dataProvider provideHttpMethodsWithRequestBodySupport\n     */\n    public function test\u00a0request\u00a0with\u00a0body\u00a0and\u00a0no\u00a0content\u00a0length(int $version, string $method)\n    {\n        // These requests do not have a Content-Length header on purpose\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-missing-content-length-$method.json\");\n\n        $this->assertMethod($method);\n        // We check the header is added automatically\n        $this->assertHeader('content-length', [13]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0supports\u00a0utf8\u00a0characters\u00a0in\u00a0body(int $version)\n    {\n        // These requests have a multibyte body: 'Hello \ud83c\udf0d'\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-utf8.json\");\n\n        $this->assertBody('Hello \ud83c\udf0d');\n        // We check the header is added automatically and takes multibyte into account\n        $this->assertHeader('content-length', [10]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0the\u00a0content\u00a0type\u00a0header\u00a0is\u00a0not\u00a0case\u00a0sensitive(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-content-type-lower-case.json\");\n\n        $this->assertContentType('application/json');\n        $this->assertHeader('content-length', [13]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [152]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"foo\\\"\\r\n\\r\nbar\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"bim\\\"\\r\n\\r\nbaz\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0form\u00a0data\u00a0containing\u00a0arrays(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-arrays.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [186]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"delete[categories][]\\\"\\r\n\\r\n123\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"delete[categories][]\\\"\\r\n\\r\n456\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody([\n            'delete' => [\n                'categories' => [\n                    '123',\n                    '456',\n                ],\n            ],\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0malformed\u00a0multipart\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-arrays-malformed.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"key0[key1][key2][\\\"\\r\n\\r\n123\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody(['key0' => ['key1' => ['key2' => '123']]]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0file\u00a0uploads(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-files.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [323]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"lorem.txt\\\"\\r\nContent-Type: text/plain\\r\n\\r\nLorem ipsum dolor sit amet,\nconsectetur adipiscing elit.\n\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"bar\\\"; filename=\\\"cars.csv\\\"\\r\n\\r\nYear,Make,Model\n1997,Ford,E350\n2000,Mercury,Cougar\n\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody([]);\n        $this->assertUploadedFile(\n            'foo',\n            'lorem.txt',\n            'text/plain',\n            0,\n            57,\n            \"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit.\\n\"\n        );\n        $this->assertUploadedFile(\n            'bar',\n            'cars.csv',\n            'application/octet-stream',\n            0,\n            51,\n            \"Year,Make,Model\\n1997,Ford,E350\\n2000,Mercury,Cougar\\n\"\n        );\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0cookies(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-cookies.json\");\n\n        $this->assertCookies([\n            'tz' => 'Europe/Paris',\n            'four' => 'two + 2',\n            'theme' => 'light',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0invalid\u00a0cookies(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-cookies-invalid.json\");\n\n        // See https://stackoverflow.com/a/61695783/245552\n        $this->assertCookies([], 'foo');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0base64\u00a0encoded\u00a0body(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-base64.json\");\n\n        $this->assertMethod('POST');\n        $this->assertContentType('application/x-www-form-urlencoded');\n        $this->assertHeader('content-length', [7]);\n        $this->assertBody('foo=bar');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0PUT\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-PUT.json\");\n        $this->assertMethod('PUT');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0PATCH\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-PATCH.json\");\n        $this->assertMethod('PATCH');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0DELETE\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-DELETE.json\");\n        $this->assertMethod('DELETE');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0OPTIONS\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-OPTIONS.json\");\n        $this->assertMethod('OPTIONS');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0path\u00a0parameters(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-path-parameters.json\");\n        $this->assertPathParameters([\n            'bar' => 'abc',\n            'baz' => 'def',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0basic\u00a0auth(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-basic-auth.json\");\n\n        $this->assertBasicAuthUser('fake');\n        $this->assertBasicAuthPassword('secret');\n    }\n\n    abstract protected function fromFixture(string $file): void;\n\n    abstract protected function assertBody(string $expected): void;\n\n    abstract protected function assertContentType(?string $expected): void;\n\n    abstract protected function assertCookies(array $expected, string |null $expectedHeader = null): void;\n\n    abstract protected function assertHeaders(array $expected): void;\n\n    abstract protected function assertHeader(string $header, array $expectedValue): void;\n\n    abstract protected function assertMethod(string $expected): void;\n\n    abstract protected function assertPath(string $expected): void;\n\n    abstract protected function assertQueryString(string $expected): void;\n\n    abstract protected function assertQueryParameters(array $expected): void;\n\n    abstract protected function assertProtocol(string $expected): void;\n\n    abstract protected function assertProtocolVersion(string $expected): void;\n\n    abstract protected function assertRemotePort(int $expected): void;\n\n    abstract protected function assertServerName(string $expected): void;\n\n    abstract protected function assertServerPort(int $expected): void;\n\n    abstract protected function assertUri(string $expected): void;\n\n    abstract protected function assertHasMultiHeader(bool $expected): void;\n\n    abstract protected function assertParsedBody(array $expected): void;\n\n    abstract protected function assertSourceIp(string $expected): void;\n\n    abstract protected function assertBasicAuthUser(string $expected): void;\n\n    abstract protected function assertBasicAuthPassword(string $expected): void;\n\n    abstract protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void;\n\n    abstract protected function assertPathParameters(array $expected): void;\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Event\\Http\\HttpRequestEvent;\nuse Bref\\Event\\InvalidLambdaEvent;\n\nclass HttpRequestEventTest extends CommonHttpTest\n{\n    private HttpRequestEvent $event;\n\n    protected function fromFixture(string $file): void\n    {\n        $this->event = new HttpRequestEvent(json_decode(file_get_contents($file), true, 512, JSON_THROW_ON_ERROR));\n    }\n\n    protected function assertBody(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getBody());\n    }\n\n    protected function assertContentType(?string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getContentType());\n        if ($expected) {\n            $this->assertHeader('content-type', [$expected]);\n        }\n    }\n\n    protected function assertCookies(array $expected, string |null $expectedHeader = null): void\n    {\n        $this->assertEquals($expected, $this->event->getCookies());\n\n        // Also check that the cookies are available in the HTTP headers (they should be)\n        if ($expectedHeader === null) {\n            $expectedHeader = array_map(function (string $value, string $key): string {\n                return $key . '=' . urlencode($value);\n            }, $expected, array_keys($expected));\n            $expectedHeader = implode('; ', $expectedHeader);\n        }\n        $this->assertEquals($expectedHeader, $this->event->getHeaders()['cookie'][0] ?? '');\n    }\n\n    protected function assertHeaders(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getHeaders());\n    }\n\n    protected function assertHeader(string $header, array $expectedValue): void\n    {\n        $this->assertArrayHasKey($header, $this->event->getHeaders());\n        $this->assertEquals($expectedValue, $this->event->getHeaders()[$header]);\n    }\n\n    protected function assertMethod(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getMethod());\n    }\n\n    protected function assertPath(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getPath());\n    }\n\n    protected function assertQueryString(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getQueryString());\n    }\n\n    protected function assertQueryParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getQueryParameters());\n    }\n\n    protected function assertProtocol(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getProtocol());\n    }\n\n    protected function assertProtocolVersion(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getProtocolVersion());\n    }\n\n    protected function assertRemotePort(int $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getRemotePort());\n    }\n\n    protected function assertServerName(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getServerName());\n    }\n\n    protected function assertServerPort(int $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getServerPort());\n    }\n\n    protected function assertUri(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getUri());\n    }\n\n    protected function assertHasMultiHeader(bool $expected): void\n    {\n        $this->assertEquals($expected, $this->event->hasMultiHeader());\n    }\n\n    protected function assertSourceIp(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getSourceIp());\n    }\n\n    protected function assertParsedBody(array $expected): void\n    {\n        // Not applicable here since the class doesn't parse the body\n    }\n\n    protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void {\n        // Not applicable here since the class doesn't parse the body\n    }\n\n    protected function assertPathParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getPathParameters());\n    }\n\n    protected function assertBasicAuthUser(string $expected): void\n    {\n        [$user] = $this->event->getBasicAuthCredentials();\n        $this->assertEquals($expected, $user);\n    }\n\n    protected function assertBasicAuthPassword(string $expected): void\n    {\n        [$user, $pass] = $this->event->getBasicAuthCredentials();\n        $this->assertEquals($expected, $pass);\n    }\n\n    public function test\u00a0empty\u00a0invocation\u00a0will\u00a0have\u00a0friendly\u00a0error\u00a0message()\n    {\n        $message = \"This handler expected to be invoked with a API Gateway or ALB event (check that you are using the correct Bref runtime: https://bref.sh/docs/runtimes/#bref-runtimes).\\nInstead, the handler was invoked with invalid event data: null\";\n\n        $this->expectException(InvalidLambdaEvent::class);\n        $this->expectExceptionMessage($message);\n\n        new HttpRequestEvent(null);\n    }\n\n    /**\n     * @dataProvider provide\u00a0query\u00a0strings\n     */\n    public function test\u00a0query\u00a0string\u00a0to\u00a0array(string $query, array $expectedOutput)\n    {\n        $reflection = new \\ReflectionClass(HttpRequestEvent::class);\n        $method = $reflection->getMethod('queryStringToArray');\n        $method->setAccessible(true);\n        $result = $method->invokeArgs($reflection->newInstanceWithoutConstructor(), [$query]);\n\n        $this->assertEquals($expectedOutput, $result);\n    }\n\n    public function provide\u00a0query\u00a0strings(): iterable\n    {\n        yield ['', []];\n\n        yield [\n            'foo_bar=2',\n            [\n                'foo_bar' => '2',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&foo.bar=v2',\n            [\n                'foo_bar' => 'v1',\n                'foo.bar' => 'v2',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&foo.bar=v2&foo.bar_extra=v3&foo_bar3=v4',\n            [\n                'foo_bar' => 'v1',\n                'foo.bar' => 'v2',\n                'foo.bar_extra' => 'v3',\n                'foo_bar3' => 'v4',\n            ],\n        ];\n\n        yield [\n            'foo_bar.baz=v1',\n            [\n                'foo_bar.baz' => 'v1',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&k[foo.bar]=v2',\n            [\n                'foo_bar' => 'v1',\n                'k' => ['foo.bar' => 'v2'],\n            ],\n        ];\n\n        yield [\n            'k.1=v.1&k.2[s.k1]=v.2&k.2[s.k2]=v.3',\n            [\n                'k.1' => 'v.1',\n                'k.2' => [\n                    's.k1' => 'v.2',\n                    's.k2' => 'v.3',\n                ],\n            ],\n        ];\n\n        yield [\n            'foo.bar%5B0%5D=v1&foo.bar_extra%5B0%5D=v2&foo.bar.extra%5B0%5D=v3',\n            [\n                'foo.bar' => ['v1'],\n                'foo.bar_extra' => ['v2'],\n                'foo.bar.extra' => ['v3'],\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider provide\u00a0query\u00a0strings\u00a0for\u00a0event\n     */\n    public function test\u00a0query\u00a0string\u00a0will\u00a0be\u00a0parsed\u00a0correctly(array $expected, string $normalizedQs, string $queryString)\n    {\n        $event = new HttpRequestEvent([\n            'httpMethod' => 'GET',\n            'version' => '2.0',\n            'rawQueryString' => $queryString,\n        ]);\n\n        self::assertSame($expected, $event->getQueryParameters());\n        self::assertSame($normalizedQs, $event->getQueryString());\n    }\n\n    public function provide\u00a0query\u00a0strings\u00a0for\u00a0event(): array\n    {\n        return [\n            [['foo' => 'bar'], 'foo=bar', 'foo=bar'],\n            [['foo' => 'bar  '], 'foo=bar%20%20', '   foo=bar  '],\n            [['?foo' => 'bar'], '%3Ffoo=bar', '?foo=bar'],\n            [['#foo' => 'bar'], '%23foo=bar', '#foo=bar'],\n            [['foo' => 'bar'], 'foo=bar', '&foo=bar'],\n            [['foo' => 'bar', 'bar' => 'foo'], 'foo=bar&bar=foo', 'foo=bar&bar=foo'],\n            [['foo' => 'bar', 'bar' => 'foo'], 'foo=bar&bar=foo', 'foo=bar&&bar=foo'],\n            [['foo' => ['bar' => ['baz' => ['bax' => 'bar']]]], 'foo%5Bbar%5D%5Bbaz%5D%5Bbax%5D=bar', 'foo[bar][baz][bax]=bar'],\n            [['foo' => ['bar' => 'bar']], 'foo%5Bbar%5D=bar', 'foo[bar] [baz]=bar'],\n            [['foo' => ['bar' => ['baz' => ['bar', 'foo']]]], 'foo%5Bbar%5D%5Bbaz%5D%5B0%5D=bar&foo%5Bbar%5D%5Bbaz%5D%5B1%5D=foo', 'foo[bar][baz][]=bar&foo[bar][baz][]=foo'],\n            [['foo' => ['bar' => [['bar'], ['foo']]]], 'foo%5Bbar%5D%5B0%5D%5B0%5D=bar&foo%5Bbar%5D%5B1%5D%5B0%5D=foo', 'foo[bar][][]=bar&foo[bar][][]=foo'],\n            [['option' => ''], 'option=', 'option'],\n            [['option' => '0'], 'option=0', 'option=0'],\n            [['option' => '1'], 'option=1', 'option=1'],\n            [['foo' => 'bar=bar=='], 'foo=bar%3Dbar%3D%3D', 'foo=bar=bar=='],\n            [['options' => ['option' => '0']], 'options%5Boption%5D=0', 'options[option]=0'],\n            [['options' => ['option' => 'foobar']], 'options%5Boption%5D=foobar', 'options[option]=foobar'],\n            [['sum' => '10\\\\2=5'], 'sum=10%5C2%3D5', 'sum=10%5c2%3d5'],\n\n            // Special cases\n            [\n                [\n                    'a' => '<==  foo bar  ==>',\n                    'b' => '###Hello World###',\n                ],\n                'a=%3C%3D%3D%20%20foo%20bar%20%20%3D%3D%3E&b=%23%23%23Hello%20World%23%23%23',\n                'a=%3c%3d%3d%20%20foo%20bar%20%20%3d%3d%3e&b=%23%23%23Hello%20World%23%23%23',\n            ],\n            [\n                [\n                    'a' => '<==  foo bar  ==>',\n                    'b' => '###Hello World###',\n                ],\n                'a=%3C%3D%3D%20%20foo%20bar%20%20%3D%3D%3E&b=%23%23%23Hello%20World%23%23%23',\n                'a=%3c%3d%3d%20%20foo+bar++%3d%3d%3e&b=%23%23%23Hello+World%23%23%23',\n            ],\n            [\n                ['str' => \"A string with containing \\0\\0\\0 nulls\"],\n                'str=A%20string%20with%20containing%20%00%00%00%20nulls',\n                'str=A%20string%20with%20containing%20%00%00%00%20nulls',\n            ],\n            [\n                [\n                    'arr_1' => 'sid',\n                    'arr' => ['4' => 'fred'],\n                ],\n                'arr_1=sid&arr%5B4%5D=fred',\n                'arr[1=sid&arr[4][2=fred',\n            ],\n            [\n                [\n                    'arr_1' => 'sid',\n                    'arr' => ['4' => ['[2' => 'fred']],\n                ],\n                'arr_1=sid&arr%5B4%5D%5B%5B2%5D=fred',\n                'arr[1=sid&arr[4][[2][3[=fred',\n            ],\n        ];\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Bref\\Event\\Http\\HttpRequestEvent;\nuse Bref\\Event\\Http\\Psr7Bridge;\nuse Nyholm\\Psr7\\Response;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\UploadedFileInterface;\n\nuse function assert;\n\nclass Psr7BridgeTest extends CommonHttpTest\n{\n    private ServerRequestInterface $request;\n\n    public function test\u00a0I\u00a0can\u00a0create\u00a0a\u00a0response\u00a0from\u00a0a\u00a0PSR7\u00a0response()\n    {\n        $psr7Response = new Response(404, [\n            'Content-Type' => 'application/json',\n        ], json_encode(['foo' => 'bar'], JSON_THROW_ON_ERROR));\n\n        $response = Psr7Bridge::convertResponse($psr7Response);\n        self::assertSame([\n            'isBase64Encoded' => false,\n            'statusCode' => 404,\n            'headers' => [\n                'Content-Type' => 'application/json',\n            ],\n            'body' => json_encode(['foo' => 'bar'], JSON_THROW_ON_ERROR),\n        ], $response->toApiGatewayFormat());\n    }\n\n    protected function fromFixture(string $file): void\n    {\n        $event = new HttpRequestEvent(json_decode(file_get_contents($file), true, 512, JSON_THROW_ON_ERROR));\n        $this->request = Psr7Bridge::convertRequest($event, Context::fake());\n    }\n\n    protected function assertBody(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getBody()->getContents());\n    }\n\n    protected function assertContentType(?string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getHeaderLine('Content-Type'));\n    }\n\n    protected function assertCookies(array $expected, string |null $expectedHeader = null): void\n    {\n        $this->assertEquals($expected, $this->request->getCookieParams());\n    }\n\n    protected function assertHeaders(array $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getHeaders());\n    }\n\n    protected function assertMethod(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getMethod());\n        $this->assertEquals($expected, $this->request->getServerParams()['REQUEST_METHOD']);\n    }\n\n    protected function assertPath(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getUri()->getPath());\n    }\n\n    protected function assertQueryString(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getUri()->getQuery());\n        $this->assertEquals($expected, $this->request->getServerParams()['QUERY_STRING'] ?? '');\n    }\n\n    protected function assertQueryParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getQueryParams());\n    }\n\n    protected function assertProtocol(string $expected): void\n    {\n        $this->assertEquals($expected, 'HTTP/' . $this->request->getProtocolVersion());\n        $this->assertEquals($expected, $this->request->getServerParams()['SERVER_PROTOCOL']);\n    }\n\n    protected function assertProtocolVersion(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getProtocolVersion());\n    }\n\n    protected function assertHeader(string $header, array $expectedValue): void\n    {\n        $this->assertTrue($this->request->hasHeader($header));\n        $this->assertEquals($expectedValue, $this->request->getHeader($header));\n    }\n\n    protected function assertRemotePort(int $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertServerName(string $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertServerPort(int $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertUri(string $expected): void\n    {\n        $this->assertEquals($expected, (string) $this->request->getUri());\n        $this->assertEquals($expected, $this->request->getServerParams()['REQUEST_URI']);\n    }\n\n    protected function assertHasMultiHeader(bool $expected): void\n    {\n        // Not applicable here\n    }\n\n    protected function assertParsedBody(array $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getParsedBody());\n    }\n\n    protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void {\n        $uploadedFiles = $this->request->getUploadedFiles();\n        $uploadedFile = $uploadedFiles[$key];\n        assert($uploadedFile instanceof UploadedFileInterface);\n        $this->assertEquals($filename, $uploadedFile->getClientFilename());\n        $this->assertEquals($mimeType, $uploadedFile->getClientMediaType());\n        $this->assertEquals($error, $uploadedFile->getError());\n        $this->assertEquals($size, $uploadedFile->getSize());\n        $this->assertEquals($content, $uploadedFile->getStream()->getContents());\n    }\n\n    protected function assertPathParameters(array $expected): void\n    {\n        $parameters = $this->request->getAttributes();\n        unset($parameters['lambda-event'], $parameters['lambda-context']);\n        $this->assertEquals($expected, $parameters);\n    }\n\n    protected function assertSourceIp(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['REMOTE_ADDR']);\n    }\n\n    protected function assertBasicAuthUser(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['PHP_AUTH_USER']);\n    }\n\n    protected function assertBasicAuthPassword(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['PHP_AUTH_PW']);\n    }\n}\n"], "fixing_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Nyholm\\Psr7\\ServerRequest;\nuse Nyholm\\Psr7\\Stream;\nuse Nyholm\\Psr7\\UploadedFile;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Riverline\\MultiPartParser\\Part;\nuse RuntimeException;\n\nuse function str_starts_with;\n\n/**\n * Bridges PSR-7 requests and responses with API Gateway or ALB event/response formats.\n */\nfinal class Psr7Bridge\n{\n    private const UPLOADED_FILES_PREFIX = 'bref_upload_';\n\n    /**\n     * Create a PSR-7 server request from an AWS Lambda HTTP event.\n     */\n    public static function convertRequest(HttpRequestEvent $event, Context $context): ServerRequestInterface\n    {\n        $headers = $event->getHeaders();\n\n        [$files, $parsedBody] = self::parseBodyAndUploadedFiles($event);\n        [$user, $password] = $event->getBasicAuthCredentials();\n\n        $server = array_filter([\n            'CONTENT_LENGTH' => $headers['content-length'][0] ?? null,\n            'CONTENT_TYPE' => $event->getContentType(),\n            'DOCUMENT_ROOT' => getcwd(),\n            'QUERY_STRING' => $event->getQueryString(),\n            'REQUEST_METHOD' => $event->getMethod(),\n            'SERVER_NAME' => $event->getServerName(),\n            'SERVER_PORT' => $event->getServerPort(),\n            'SERVER_PROTOCOL' => $event->getProtocol(),\n            'PATH_INFO' => $event->getPath(),\n            'HTTP_HOST' => $headers['host'] ?? null,\n            'REMOTE_ADDR' => $event->getSourceIp(),\n            'REMOTE_PORT' => $event->getRemotePort(),\n            'REQUEST_TIME' => time(),\n            'REQUEST_TIME_FLOAT' => microtime(true),\n            'REQUEST_URI' => $event->getUri(),\n            'PHP_AUTH_USER' => $user,\n            'PHP_AUTH_PW' => $password,\n        ]);\n\n        foreach ($headers as $name => $values) {\n            $server['HTTP_' . strtoupper(str_replace('-', '_', (string) $name))] = $values[0];\n        }\n\n        /**\n         * Nyholm/psr7 does not rewind body streams, we do it manually\n         * so that users can fetch the content of the body directly.\n         */\n        $bodyStream = Stream::create($event->getBody());\n        $bodyStream->rewind();\n\n        $request = new ServerRequest(\n            $event->getMethod(),\n            $event->getUri(),\n            $event->getHeaders(),\n            $bodyStream,\n            $event->getProtocolVersion(),\n            $server\n        );\n\n        foreach ($event->getPathParameters() as $key => $value) {\n            $request = $request->withAttribute($key, $value);\n        }\n\n        return $request->withUploadedFiles($files)\n            ->withCookieParams($event->getCookies())\n            ->withQueryParams($event->getQueryParameters())\n            ->withParsedBody($parsedBody)\n            ->withAttribute('lambda-event', $event)\n            ->withAttribute('lambda-context', $context);\n    }\n\n    /**\n     * Create a ALB/API Gateway response from a PSR-7 response.\n     */\n    public static function convertResponse(ResponseInterface $response): HttpResponse\n    {\n        $response->getBody()->rewind();\n        $body = $response->getBody()->getContents();\n\n        return new HttpResponse($body, $response->getHeaders(), $response->getStatusCode());\n    }\n\n    /**\n     * @return array{0: array<string, UploadedFile>, 1: array<string, mixed>|null}\n     */\n    private static function parseBodyAndUploadedFiles(HttpRequestEvent $event): array\n    {\n        $contentType = $event->getContentType();\n        if ($contentType === null || $event->getMethod() !== 'POST') {\n            return [[], null];\n        }\n\n        if (str_starts_with($contentType, 'application/x-www-form-urlencoded')) {\n            $parsedBody = [];\n            parse_str($event->getBody(), $parsedBody);\n            return [[], $parsedBody];\n        }\n\n        // Parse the body as multipart/form-data\n        $document = new Part(\"Content-type: $contentType\\r\\n\\r\\n\" . $event->getBody());\n        if (!$document->isMultiPart()) {\n            return [[], null];\n        }\n        $files = [];\n        $queryString = '';\n        foreach ($document->getParts() as $part) {\n            if ($part->isFile()) {\n                            $tmpPath = tempnam(sys_get_temp_dir(), self::UPLOADED_FILES_PREFIX);\n                if ($tmpPath === false) {\n                    throw new RuntimeException('Unable to create a temporary directory');\n                }\n                file_put_contents($tmpPath, $part->getBody());\n                $file = new UploadedFile($tmpPath, filesize($tmpPath), UPLOAD_ERR_OK, $part->getFileName(), $part->getMimeType());\n                self::parseKeyAndInsertValueInArray($files, $part->getName(), $file);\n            } else {\n                // Temporarily store as a query string so that we can use PHP's native parse_str function to parse keys\n                $queryString .= urlencode($part->getName()) . '=' . urlencode($part->getBody()) . '&';\n            }\n        }\n        if ($queryString !== '') {\n            $parsedBody = [];\n            parse_str($queryString, $parsedBody);\n        } else {\n            $parsedBody = null;\n        }\n        return [$files, $parsedBody];\n    }\n\n    /**\n     * Parse a string key like \"files[id_cards][jpg][]\" and do $array['files']['id_cards']['jpg'][] = $value\n     */\n    private static function parseKeyAndInsertValueInArray(array &$array, string $key, mixed $value): void\n    {\n        if (! str_contains($key, '[')) {\n            $array[$key] = $value;\n\n            return;\n        }\n\n        $parts = explode('[', $key); // files[id_cards][jpg][] => [ 'files',  'id_cards]', 'jpg]', ']' ]\n        $pointer = &$array;\n\n        foreach ($parts as $k => $part) {\n            if ($k === 0) {\n                $pointer = &$pointer[$part];\n\n                continue;\n            }\n\n            // Skip two special cases:\n            // [[ in the key produces empty string\n            // [test : starts with [ but does not end with ]\n            if ($part === '' || ! str_ends_with($part, ']')) {\n                // Malformed key, we use it \"as is\"\n                $array[$key] = $value;\n\n                return;\n            }\n\n            $part = substr($part, 0, -1); // The last char is a ] => remove it to have the real key\n\n            if ($part === '') { // [] case\n                $pointer = &$pointer[];\n            } else {\n                $pointer = &$pointer[$part];\n            }\n        }\n\n        $pointer = $value;\n    }\n\n    /**\n     * Cleanup previously uploaded files.\n     */\n    public static function cleanupUploadedFiles(): void\n    {\n        // See https://github.com/brefphp/bref/commit/c77d9f5abf021f29fa96b5720b7b84adbd199092#r137983026\n        $tmpFiles = glob(sys_get_temp_dir() . '/' . self::UPLOADED_FILES_PREFIX . '[A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9][A-Za-z0-9]');\n\n        if ($tmpFiles !== false) {\n            foreach ($tmpFiles as $file) {\n                if (is_file($file)) {\n                    // Silence warnings, we don't want to crash the whole runtime\n                    @unlink($file);\n                }\n            }\n        }\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Test\\HttpRequestProxyTest;\nuse PHPUnit\\Framework\\TestCase;\n\nabstract class CommonHttpTest extends TestCase implements HttpRequestProxyTest\n{\n    public function provide\u00a0API\u00a0Gateway\u00a0versions(): array\n    {\n        return [\n            'v1' => [1],\n            'v2' => [2],\n        ];\n    }\n\n    public function test\u00a0request\u00a0with\u00a0no\u00a0version\u00a0fallbacks\u00a0to\u00a0v1()\n    {\n        $this->fromFixture(__DIR__ . '/Fixture/ag-no-version.json');\n\n        $this->assertBody('');\n        $this->assertContentType(null);\n        $this->assertHeaders([\n            'accept' => ['*/*'],\n            'accept-encoding' => ['gzip, deflate'],\n            'cache-control' => ['no-cache'],\n            'host' => ['example.org'],\n            'user-agent' => ['PostmanRuntime/7.20.1'],\n            'x-amzn-trace-id' => ['Root=1-ffffffff-ffffffffffffffffffffffff'],\n            'x-forwarded-for' => ['1.1.1.1'],\n            'x-forwarded-port' => ['443'],\n            'x-forwarded-proto' => ['https'],\n        ]);\n        $this->assertMethod('GET');\n        $this->assertUri('/path');\n        $this->assertSourceIp('1.1.1.1');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0simple\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-simple.json\");\n\n        $this->assertBody('');\n        $this->assertContentType(null);\n        $this->assertCookies([]);\n        $this->assertHeaders([\n            'accept' => ['*/*'],\n            'accept-encoding' => ['gzip, deflate'],\n            'cache-control' => ['no-cache'],\n            'host' => ['example.org'],\n            'user-agent' => ['PostmanRuntime/7.20.1'],\n            'x-amzn-trace-id' => ['Root=1-ffffffff-ffffffffffffffffffffffff'],\n            'x-forwarded-for' => ['1.1.1.1'],\n            'x-forwarded-port' => ['443'],\n            'x-forwarded-proto' => ['https'],\n        ]);\n        $this->assertMethod('GET');\n        $this->assertPath('/path');\n        $this->assertProtocol('HTTP/1.1');\n        $this->assertProtocolVersion('1.1');\n        $this->assertQueryParameters([]);\n        $this->assertQueryString('');\n        $this->assertRemotePort(443);\n        $this->assertServerName('example.org');\n        $this->assertServerPort(443);\n        $this->assertUri('/path');\n        $this->assertHasMultiHeader(false);\n        $this->assertSourceIp('1.1.1.1');\n    }\n\n    public function test\u00a0v1\u00a0stage\u00a0prefix\u00a0is\u00a0not\u00a0included\u00a0in\u00a0the\u00a0URL()\n    {\n        $this->fromFixture(__DIR__ . '/Fixture/ag-v1-stage-prefix.json');\n\n        $this->assertPath('/path');\n        $this->assertUri('/path');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0query\u00a0string(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string.json\");\n\n        $this->assertPath('/path');\n        $this->assertQueryParameters(['foo' => 'bar', 'baz.bar' => 'foo']);\n        $this->assertQueryString('foo=bar&baz.bar=foo');\n        $this->assertUri('/path?foo=bar&baz.bar=foo');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0multivalues\u00a0query\u00a0string\u00a0have\u00a0basic\u00a0support(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string-multivalue.json\");\n\n        $this->assertQueryParameters([\n            'foo' => ['bar', 'baz'],\n            'cards' => ['birthday'],\n            'colors' => [['red'], ['blue']],\n            'shapes' => ['a' => ['square', 'triangle']],\n            'myvar' => 'abc',\n            'foo.bar' => ['baz'],\n            'array' => ['one', 'two'],\n        ]);\n        $this->assertQueryString('foo%5B0%5D=bar&foo%5B1%5D=baz&cards%5B0%5D=birthday&colors%5B0%5D%5B0%5D=red&colors%5B1%5D%5B0%5D=blue&shapes%5Ba%5D%5B0%5D=square&shapes%5Ba%5D%5B1%5D=triangle&myvar=abc&foo.bar%5B0%5D=baz&array%5B0%5D=one&array%5B1%5D=two');\n        $this->assertUri('/path?foo%5B0%5D=bar&foo%5B1%5D=baz&cards%5B0%5D=birthday&colors%5B0%5D%5B0%5D=red&colors%5B1%5D%5B0%5D=blue&shapes%5Ba%5D%5B0%5D=square&shapes%5Ba%5D%5B1%5D=triangle&myvar=abc&foo.bar%5B0%5D=baz&array%5B0%5D=one&array%5B1%5D=two');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0arrays\u00a0in\u00a0query\u00a0string(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-query-string-arrays.json\");\n\n        $this->assertQueryParameters([\n            'vars' => [\n                'val1' => 'foo',\n                'val2' => ['bar'],\n            ],\n            'foo.bar' => ['baz'],\n        ]);\n        if ($version === 2) {\n            // Numeric keys are added as an artifact of us parsing the query string\n            // Both format are valid and semantically identical\n            $this->assertQueryString('vars%5Bval1%5D=foo&vars%5Bval2%5D%5B0%5D=bar&foo.bar%5B0%5D=baz');\n            $this->assertUri('/path?vars%5Bval1%5D=foo&vars%5Bval2%5D%5B0%5D=bar&foo.bar%5B0%5D=baz');\n        } else {\n            $this->assertQueryString('vars%5Bval1%5D=foo&vars%5Bval2%5D%5B%5D=bar&foo.bar%5B%5D=baz');\n            $this->assertUri('/path?vars%5Bval1%5D=foo&vars%5Bval2%5D%5B%5D=bar&foo.bar%5B%5D=baz');\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0custom\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-custom.json\");\n        $this->assertHeader('x-my-header', ['Hello world']);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0custom\u00a0multi\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-custom-multivalue.json\");\n        if ($version === 2) {\n            // In v2, multi-value headers are joined by a comma\n            // See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n            $this->assertHeader('x-my-header', ['Hello world,Hello john']);\n        } else {\n            $this->assertHeader('x-my-header', ['Hello world', 'Hello john']);\n            $this->assertHasMultiHeader(true);\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0numeric\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-numeric.json\");\n        $this->assertHeader('12345', ['Hello world']);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0numeric\u00a0multi\u00a0header(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-numeric-multivalue.json\");\n        if ($version === 2) {\n            // In v2, multi-value headers are joined by a comma\n            // See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n            $this->assertHeader('12345', ['Hello world,Hello john']);\n        } else {\n            $this->assertHeader('12345', ['Hello world', 'Hello john']);\n            $this->assertHasMultiHeader(true);\n        }\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0raw\u00a0body(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-json.json\");\n\n        $this->assertMethod('PUT');\n        $this->assertContentType('application/json');\n        $this->assertHeader('content-length', [13]);\n        $this->assertBody('{\"foo\":\"bar\"}');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form.json\");\n\n        $this->assertMethod('POST');\n        $this->assertContentType('application/x-www-form-urlencoded');\n        $this->assertHeader('content-length', [15]);\n        $this->assertBody('foo=bar&bim=baz');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0form\u00a0data\u00a0and\u00a0content\u00a0type(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-content-type.json\");\n\n        $this->assertContentType('application/x-www-form-urlencoded;charset=UTF-8');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    public function provideHttpMethodsWithRequestBodySupport(): array\n    {\n        return [\n            'POST v1' => [\n                'version' => 1,\n                'method' => 'POST',\n            ],\n            'POST v2' => [\n                'version' => 2,\n                'method' => 'POST',\n            ],\n            'PUT v1' => [\n                'version' => 1,\n                'method' => 'PUT',\n            ],\n            'PUT v2' => [\n                'version' => 2,\n                'method' => 'PUT',\n            ],\n            'PATCH v1' => [\n                'version' => 1,\n                'method' => 'PATCH',\n            ],\n            'PATCH v2' => [\n                'version' => 2,\n                'method' => 'PATCH',\n            ],\n        ];\n    }\n\n    /**\n     * @see https://github.com/brefphp/bref/issues/162\n     *\n     * @dataProvider provideHttpMethodsWithRequestBodySupport\n     */\n    public function test\u00a0request\u00a0with\u00a0body\u00a0and\u00a0no\u00a0content\u00a0length(int $version, string $method)\n    {\n        // These requests do not have a Content-Length header on purpose\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-missing-content-length-$method.json\");\n\n        $this->assertMethod($method);\n        // We check the header is added automatically\n        $this->assertHeader('content-length', [13]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0supports\u00a0utf8\u00a0characters\u00a0in\u00a0body(int $version)\n    {\n        // These requests have a multibyte body: 'Hello \ud83c\udf0d'\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-utf8.json\");\n\n        $this->assertBody('Hello \ud83c\udf0d');\n        // We check the header is added automatically and takes multibyte into account\n        $this->assertHeader('content-length', [10]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0the\u00a0content\u00a0type\u00a0header\u00a0is\u00a0not\u00a0case\u00a0sensitive(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-content-type-lower-case.json\");\n\n        $this->assertContentType('application/json');\n        $this->assertHeader('content-length', [13]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [152]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"foo\\\"\\r\n\\r\nbar\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"bim\\\"\\r\n\\r\nbaz\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody([\n            'foo' => 'bar',\n            'bim' => 'baz',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0form\u00a0data\u00a0containing\u00a0arrays(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-arrays.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [186]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"delete[categories][]\\\"\\r\n\\r\n123\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"delete[categories][]\\\"\\r\n\\r\n456\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody([\n            'delete' => [\n                'categories' => [\n                    '123',\n                    '456',\n                ],\n            ],\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0malformed\u00a0multipart\u00a0form\u00a0data(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-arrays-malformed.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"key0[key1][key2][\\\"\\r\n\\r\n123\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody(['key0' => ['key1' => ['key2' => '123']]]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0multipart\u00a0file\u00a0uploads(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-form-multipart-files.json\");\n\n        $this->assertContentType('multipart/form-data; boundary=testBoundary');\n        $this->assertHeader('content-length', [323]);\n        $body = \"--testBoundary\\r\nContent-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"lorem.txt\\\"\\r\nContent-Type: text/plain\\r\n\\r\nLorem ipsum dolor sit amet,\nconsectetur adipiscing elit.\n\\r\n--testBoundary\\r\nContent-Disposition: form-data; name=\\\"bar\\\"; filename=\\\"cars.csv\\\"\\r\n\\r\nYear,Make,Model\n1997,Ford,E350\n2000,Mercury,Cougar\n\\r\n--testBoundary--\\r\n\";\n        $this->assertBody($body);\n        $this->assertParsedBody(null);\n        $this->assertUploadedFile(\n            'foo',\n            'lorem.txt',\n            'text/plain',\n            0,\n            57,\n            \"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit.\\n\"\n        );\n        $this->assertUploadedFile(\n            'bar',\n            'cars.csv',\n            'application/octet-stream',\n            0,\n            51,\n            \"Year,Make,Model\\n1997,Ford,E350\\n2000,Mercury,Cougar\\n\"\n        );\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0cookies(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-cookies.json\");\n\n        $this->assertCookies([\n            'tz' => 'Europe/Paris',\n            'four' => 'two + 2',\n            'theme' => 'light',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0invalid\u00a0cookies(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-cookies-invalid.json\");\n\n        // See https://stackoverflow.com/a/61695783/245552\n        $this->assertCookies([], 'foo');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0POST\u00a0request\u00a0with\u00a0base64\u00a0encoded\u00a0body(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-body-base64.json\");\n\n        $this->assertMethod('POST');\n        $this->assertContentType('application/x-www-form-urlencoded');\n        $this->assertHeader('content-length', [7]);\n        $this->assertBody('foo=bar');\n        $this->assertParsedBody([\n            'foo' => 'bar',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0PUT\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-PUT.json\");\n        $this->assertMethod('PUT');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0PATCH\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-PATCH.json\");\n        $this->assertMethod('PATCH');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0DELETE\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-DELETE.json\");\n        $this->assertMethod('DELETE');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0OPTIONS\u00a0request(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-method-OPTIONS.json\");\n        $this->assertMethod('OPTIONS');\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0path\u00a0parameters(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-path-parameters.json\");\n        $this->assertPathParameters([\n            'bar' => 'abc',\n            'baz' => 'def',\n        ]);\n    }\n\n    /**\n     * @dataProvider provide\u00a0API\u00a0Gateway\u00a0versions\n     */\n    public function test\u00a0request\u00a0with\u00a0basic\u00a0auth(int $version)\n    {\n        $this->fromFixture(__DIR__ . \"/Fixture/ag-v$version-header-basic-auth.json\");\n\n        $this->assertBasicAuthUser('fake');\n        $this->assertBasicAuthPassword('secret');\n    }\n\n    abstract protected function fromFixture(string $file): void;\n\n    abstract protected function assertBody(string $expected): void;\n\n    abstract protected function assertContentType(?string $expected): void;\n\n    abstract protected function assertCookies(array $expected, string |null $expectedHeader = null): void;\n\n    abstract protected function assertHeaders(array $expected): void;\n\n    abstract protected function assertHeader(string $header, array $expectedValue): void;\n\n    abstract protected function assertMethod(string $expected): void;\n\n    abstract protected function assertPath(string $expected): void;\n\n    abstract protected function assertQueryString(string $expected): void;\n\n    abstract protected function assertQueryParameters(array $expected): void;\n\n    abstract protected function assertProtocol(string $expected): void;\n\n    abstract protected function assertProtocolVersion(string $expected): void;\n\n    abstract protected function assertRemotePort(int $expected): void;\n\n    abstract protected function assertServerName(string $expected): void;\n\n    abstract protected function assertServerPort(int $expected): void;\n\n    abstract protected function assertUri(string $expected): void;\n\n    abstract protected function assertHasMultiHeader(bool $expected): void;\n\n    abstract protected function assertParsedBody(array|null $expected): void;\n\n    abstract protected function assertSourceIp(string $expected): void;\n\n    abstract protected function assertBasicAuthUser(string $expected): void;\n\n    abstract protected function assertBasicAuthPassword(string $expected): void;\n\n    abstract protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void;\n\n    abstract protected function assertPathParameters(array $expected): void;\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Event\\Http\\HttpRequestEvent;\nuse Bref\\Event\\InvalidLambdaEvent;\n\nclass HttpRequestEventTest extends CommonHttpTest\n{\n    private HttpRequestEvent $event;\n\n    protected function fromFixture(string $file): void\n    {\n        $this->event = new HttpRequestEvent(json_decode(file_get_contents($file), true, 512, JSON_THROW_ON_ERROR));\n    }\n\n    protected function assertBody(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getBody());\n    }\n\n    protected function assertContentType(?string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getContentType());\n        if ($expected) {\n            $this->assertHeader('content-type', [$expected]);\n        }\n    }\n\n    protected function assertCookies(array $expected, string |null $expectedHeader = null): void\n    {\n        $this->assertEquals($expected, $this->event->getCookies());\n\n        // Also check that the cookies are available in the HTTP headers (they should be)\n        if ($expectedHeader === null) {\n            $expectedHeader = array_map(function (string $value, string $key): string {\n                return $key . '=' . urlencode($value);\n            }, $expected, array_keys($expected));\n            $expectedHeader = implode('; ', $expectedHeader);\n        }\n        $this->assertEquals($expectedHeader, $this->event->getHeaders()['cookie'][0] ?? '');\n    }\n\n    protected function assertHeaders(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getHeaders());\n    }\n\n    protected function assertHeader(string $header, array $expectedValue): void\n    {\n        $this->assertArrayHasKey($header, $this->event->getHeaders());\n        $this->assertEquals($expectedValue, $this->event->getHeaders()[$header]);\n    }\n\n    protected function assertMethod(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getMethod());\n    }\n\n    protected function assertPath(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getPath());\n    }\n\n    protected function assertQueryString(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getQueryString());\n    }\n\n    protected function assertQueryParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getQueryParameters());\n    }\n\n    protected function assertProtocol(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getProtocol());\n    }\n\n    protected function assertProtocolVersion(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getProtocolVersion());\n    }\n\n    protected function assertRemotePort(int $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getRemotePort());\n    }\n\n    protected function assertServerName(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getServerName());\n    }\n\n    protected function assertServerPort(int $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getServerPort());\n    }\n\n    protected function assertUri(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getUri());\n    }\n\n    protected function assertHasMultiHeader(bool $expected): void\n    {\n        $this->assertEquals($expected, $this->event->hasMultiHeader());\n    }\n\n    protected function assertSourceIp(string $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getSourceIp());\n    }\n\n    protected function assertParsedBody(array|null $expected): void\n    {\n        // Not applicable here since the class doesn't parse the body\n    }\n\n    protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void {\n        // Not applicable here since the class doesn't parse the body\n    }\n\n    protected function assertPathParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->event->getPathParameters());\n    }\n\n    protected function assertBasicAuthUser(string $expected): void\n    {\n        [$user] = $this->event->getBasicAuthCredentials();\n        $this->assertEquals($expected, $user);\n    }\n\n    protected function assertBasicAuthPassword(string $expected): void\n    {\n        [$user, $pass] = $this->event->getBasicAuthCredentials();\n        $this->assertEquals($expected, $pass);\n    }\n\n    public function test\u00a0empty\u00a0invocation\u00a0will\u00a0have\u00a0friendly\u00a0error\u00a0message()\n    {\n        $message = \"This handler expected to be invoked with a API Gateway or ALB event (check that you are using the correct Bref runtime: https://bref.sh/docs/runtimes/#bref-runtimes).\\nInstead, the handler was invoked with invalid event data: null\";\n\n        $this->expectException(InvalidLambdaEvent::class);\n        $this->expectExceptionMessage($message);\n\n        new HttpRequestEvent(null);\n    }\n\n    /**\n     * @dataProvider provide\u00a0query\u00a0strings\n     */\n    public function test\u00a0query\u00a0string\u00a0to\u00a0array(string $query, array $expectedOutput)\n    {\n        $reflection = new \\ReflectionClass(HttpRequestEvent::class);\n        $method = $reflection->getMethod('queryStringToArray');\n        $method->setAccessible(true);\n        $result = $method->invokeArgs($reflection->newInstanceWithoutConstructor(), [$query]);\n\n        $this->assertEquals($expectedOutput, $result);\n    }\n\n    public function provide\u00a0query\u00a0strings(): iterable\n    {\n        yield ['', []];\n\n        yield [\n            'foo_bar=2',\n            [\n                'foo_bar' => '2',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&foo.bar=v2',\n            [\n                'foo_bar' => 'v1',\n                'foo.bar' => 'v2',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&foo.bar=v2&foo.bar_extra=v3&foo_bar3=v4',\n            [\n                'foo_bar' => 'v1',\n                'foo.bar' => 'v2',\n                'foo.bar_extra' => 'v3',\n                'foo_bar3' => 'v4',\n            ],\n        ];\n\n        yield [\n            'foo_bar.baz=v1',\n            [\n                'foo_bar.baz' => 'v1',\n            ],\n        ];\n\n        yield [\n            'foo_bar=v1&k[foo.bar]=v2',\n            [\n                'foo_bar' => 'v1',\n                'k' => ['foo.bar' => 'v2'],\n            ],\n        ];\n\n        yield [\n            'k.1=v.1&k.2[s.k1]=v.2&k.2[s.k2]=v.3',\n            [\n                'k.1' => 'v.1',\n                'k.2' => [\n                    's.k1' => 'v.2',\n                    's.k2' => 'v.3',\n                ],\n            ],\n        ];\n\n        yield [\n            'foo.bar%5B0%5D=v1&foo.bar_extra%5B0%5D=v2&foo.bar.extra%5B0%5D=v3',\n            [\n                'foo.bar' => ['v1'],\n                'foo.bar_extra' => ['v2'],\n                'foo.bar.extra' => ['v3'],\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider provide\u00a0query\u00a0strings\u00a0for\u00a0event\n     */\n    public function test\u00a0query\u00a0string\u00a0will\u00a0be\u00a0parsed\u00a0correctly(array $expected, string $normalizedQs, string $queryString)\n    {\n        $event = new HttpRequestEvent([\n            'httpMethod' => 'GET',\n            'version' => '2.0',\n            'rawQueryString' => $queryString,\n        ]);\n\n        self::assertSame($expected, $event->getQueryParameters());\n        self::assertSame($normalizedQs, $event->getQueryString());\n    }\n\n    public function provide\u00a0query\u00a0strings\u00a0for\u00a0event(): array\n    {\n        return [\n            [['foo' => 'bar'], 'foo=bar', 'foo=bar'],\n            [['foo' => 'bar  '], 'foo=bar%20%20', '   foo=bar  '],\n            [['?foo' => 'bar'], '%3Ffoo=bar', '?foo=bar'],\n            [['#foo' => 'bar'], '%23foo=bar', '#foo=bar'],\n            [['foo' => 'bar'], 'foo=bar', '&foo=bar'],\n            [['foo' => 'bar', 'bar' => 'foo'], 'foo=bar&bar=foo', 'foo=bar&bar=foo'],\n            [['foo' => 'bar', 'bar' => 'foo'], 'foo=bar&bar=foo', 'foo=bar&&bar=foo'],\n            [['foo' => ['bar' => ['baz' => ['bax' => 'bar']]]], 'foo%5Bbar%5D%5Bbaz%5D%5Bbax%5D=bar', 'foo[bar][baz][bax]=bar'],\n            [['foo' => ['bar' => 'bar']], 'foo%5Bbar%5D=bar', 'foo[bar] [baz]=bar'],\n            [['foo' => ['bar' => ['baz' => ['bar', 'foo']]]], 'foo%5Bbar%5D%5Bbaz%5D%5B0%5D=bar&foo%5Bbar%5D%5Bbaz%5D%5B1%5D=foo', 'foo[bar][baz][]=bar&foo[bar][baz][]=foo'],\n            [['foo' => ['bar' => [['bar'], ['foo']]]], 'foo%5Bbar%5D%5B0%5D%5B0%5D=bar&foo%5Bbar%5D%5B1%5D%5B0%5D=foo', 'foo[bar][][]=bar&foo[bar][][]=foo'],\n            [['option' => ''], 'option=', 'option'],\n            [['option' => '0'], 'option=0', 'option=0'],\n            [['option' => '1'], 'option=1', 'option=1'],\n            [['foo' => 'bar=bar=='], 'foo=bar%3Dbar%3D%3D', 'foo=bar=bar=='],\n            [['options' => ['option' => '0']], 'options%5Boption%5D=0', 'options[option]=0'],\n            [['options' => ['option' => 'foobar']], 'options%5Boption%5D=foobar', 'options[option]=foobar'],\n            [['sum' => '10\\\\2=5'], 'sum=10%5C2%3D5', 'sum=10%5c2%3d5'],\n\n            // Special cases\n            [\n                [\n                    'a' => '<==  foo bar  ==>',\n                    'b' => '###Hello World###',\n                ],\n                'a=%3C%3D%3D%20%20foo%20bar%20%20%3D%3D%3E&b=%23%23%23Hello%20World%23%23%23',\n                'a=%3c%3d%3d%20%20foo%20bar%20%20%3d%3d%3e&b=%23%23%23Hello%20World%23%23%23',\n            ],\n            [\n                [\n                    'a' => '<==  foo bar  ==>',\n                    'b' => '###Hello World###',\n                ],\n                'a=%3C%3D%3D%20%20foo%20bar%20%20%3D%3D%3E&b=%23%23%23Hello%20World%23%23%23',\n                'a=%3c%3d%3d%20%20foo+bar++%3d%3d%3e&b=%23%23%23Hello+World%23%23%23',\n            ],\n            [\n                ['str' => \"A string with containing \\0\\0\\0 nulls\"],\n                'str=A%20string%20with%20containing%20%00%00%00%20nulls',\n                'str=A%20string%20with%20containing%20%00%00%00%20nulls',\n            ],\n            [\n                [\n                    'arr_1' => 'sid',\n                    'arr' => ['4' => 'fred'],\n                ],\n                'arr_1=sid&arr%5B4%5D=fred',\n                'arr[1=sid&arr[4][2=fred',\n            ],\n            [\n                [\n                    'arr_1' => 'sid',\n                    'arr' => ['4' => ['[2' => 'fred']],\n                ],\n                'arr_1=sid&arr%5B4%5D%5B%5B2%5D=fred',\n                'arr[1=sid&arr[4][[2][3[=fred',\n            ],\n        ];\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Bref\\Event\\Http\\HttpRequestEvent;\nuse Bref\\Event\\Http\\Psr7Bridge;\nuse Nyholm\\Psr7\\Response;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\UploadedFileInterface;\n\nuse function assert;\n\nclass Psr7BridgeTest extends CommonHttpTest\n{\n    private ServerRequestInterface $request;\n\n    public function test\u00a0I\u00a0can\u00a0create\u00a0a\u00a0response\u00a0from\u00a0a\u00a0PSR7\u00a0response()\n    {\n        $psr7Response = new Response(404, [\n            'Content-Type' => 'application/json',\n        ], json_encode(['foo' => 'bar'], JSON_THROW_ON_ERROR));\n\n        $response = Psr7Bridge::convertResponse($psr7Response);\n        self::assertSame([\n            'isBase64Encoded' => false,\n            'statusCode' => 404,\n            'headers' => [\n                'Content-Type' => 'application/json',\n            ],\n            'body' => json_encode(['foo' => 'bar'], JSON_THROW_ON_ERROR),\n        ], $response->toApiGatewayFormat());\n    }\n\n    protected function fromFixture(string $file): void\n    {\n        $event = new HttpRequestEvent(json_decode(file_get_contents($file), true, 512, JSON_THROW_ON_ERROR));\n        $this->request = Psr7Bridge::convertRequest($event, Context::fake());\n    }\n\n    protected function assertBody(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getBody()->getContents());\n    }\n\n    protected function assertContentType(?string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getHeaderLine('Content-Type'));\n    }\n\n    protected function assertCookies(array $expected, string |null $expectedHeader = null): void\n    {\n        $this->assertEquals($expected, $this->request->getCookieParams());\n    }\n\n    protected function assertHeaders(array $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getHeaders());\n    }\n\n    protected function assertMethod(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getMethod());\n        $this->assertEquals($expected, $this->request->getServerParams()['REQUEST_METHOD']);\n    }\n\n    protected function assertPath(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getUri()->getPath());\n    }\n\n    protected function assertQueryString(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getUri()->getQuery());\n        $this->assertEquals($expected, $this->request->getServerParams()['QUERY_STRING'] ?? '');\n    }\n\n    protected function assertQueryParameters(array $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getQueryParams());\n    }\n\n    protected function assertProtocol(string $expected): void\n    {\n        $this->assertEquals($expected, 'HTTP/' . $this->request->getProtocolVersion());\n        $this->assertEquals($expected, $this->request->getServerParams()['SERVER_PROTOCOL']);\n    }\n\n    protected function assertProtocolVersion(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getProtocolVersion());\n    }\n\n    protected function assertHeader(string $header, array $expectedValue): void\n    {\n        $this->assertTrue($this->request->hasHeader($header));\n        $this->assertEquals($expectedValue, $this->request->getHeader($header));\n    }\n\n    protected function assertRemotePort(int $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertServerName(string $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertServerPort(int $expected): void\n    {\n        // Nothing to do\n    }\n\n    protected function assertUri(string $expected): void\n    {\n        $this->assertEquals($expected, (string) $this->request->getUri());\n        $this->assertEquals($expected, $this->request->getServerParams()['REQUEST_URI']);\n    }\n\n    protected function assertHasMultiHeader(bool $expected): void\n    {\n        // Not applicable here\n    }\n\n    protected function assertParsedBody(array|null $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getParsedBody());\n    }\n\n    protected function assertUploadedFile(\n        string $key,\n        string $filename,\n        string $mimeType,\n        int $error,\n        int $size,\n        string $content\n    ): void {\n        $uploadedFiles = $this->request->getUploadedFiles();\n        $uploadedFile = $uploadedFiles[$key];\n        assert($uploadedFile instanceof UploadedFileInterface);\n        $this->assertEquals($filename, $uploadedFile->getClientFilename());\n        $this->assertEquals($mimeType, $uploadedFile->getClientMediaType());\n        $this->assertEquals($error, $uploadedFile->getError());\n        $this->assertEquals($size, $uploadedFile->getSize());\n        $this->assertEquals($content, $uploadedFile->getStream()->getContents());\n    }\n\n    protected function assertPathParameters(array $expected): void\n    {\n        $parameters = $this->request->getAttributes();\n        unset($parameters['lambda-event'], $parameters['lambda-context']);\n        $this->assertEquals($expected, $parameters);\n    }\n\n    protected function assertSourceIp(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['REMOTE_ADDR']);\n    }\n\n    protected function assertBasicAuthUser(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['PHP_AUTH_USER']);\n    }\n\n    protected function assertBasicAuthPassword(string $expected): void\n    {\n        $this->assertEquals($expected, $this->request->getServerParams()['PHP_AUTH_PW']);\n    }\n}\n"], "filenames": ["src/Event/Http/Psr7Bridge.php", "tests/Event/Http/CommonHttpTest.php", "tests/Event/Http/HttpRequestEventTest.php", "tests/Event/Http/Psr7BridgeTest.php"], "buggy_code_start_loc": [95, 404, 115, 126], "buggy_code_end_loc": [125, 558, 116, 127], "fixing_code_start_loc": [96, 404, 115, 126], "fixing_code_end_loc": [138, 558, 116, 127], "type": "CWE-400", "message": "Bref enable serverless PHP on AWS Lambda. When Bref is used with the Event-Driven Function runtime and the handler is a `RequestHandlerInterface`, then the Lambda event is converted to a PSR7 object. During the conversion process, if the request is a MultiPart, each part is parsed and for each which contains a file, it is extracted and saved in `/tmp` with a random filename starting with `bref_upload_`. The flow mimics what plain PHP does but it does not delete the temporary files when the request has been processed. An attacker could fill the Lambda instance disk by performing multiple MultiPart requests containing files. This vulnerability is patched in 2.1.13.", "other": {"cve": {"id": "CVE-2024-24752", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T16:17:14.487", "lastModified": "2024-02-09T01:45:17.263", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bref enable serverless PHP on AWS Lambda. When Bref is used with the Event-Driven Function runtime and the handler is a `RequestHandlerInterface`, then the Lambda event is converted to a PSR7 object. During the conversion process, if the request is a MultiPart, each part is parsed and for each which contains a file, it is extracted and saved in `/tmp` with a random filename starting with `bref_upload_`. The flow mimics what plain PHP does but it does not delete the temporary files when the request has been processed. An attacker could fill the Lambda instance disk by performing multiple MultiPart requests containing files. This vulnerability is patched in 2.1.13."}, {"lang": "es", "value": "Bref habilita PHP sin servidor en AWS Lambda. Cuando se usa Bref con el tiempo de ejecuci\u00f3n de la funci\u00f3n controlada por eventos y el controlador es \"RequestHandlerInterface\", el evento Lambda se convierte en un objeto PSR7. Durante el proceso de conversi\u00f3n, si la solicitud es MultiPart, cada parte se analiza y, para cada una de las que contiene un archivo, se extrae y se guarda en `/tmp` con un nombre de archivo aleatorio que comienza con `bref_upload_`. El flujo imita lo que hace el PHP plano pero no elimina los archivos temporales cuando se procesa la solicitud. Un atacante podr\u00eda llenar el disco de la instancia de Lambda realizando m\u00faltiples solicitudes MultiPart que contengan archivos. Esta vulnerabilidad est\u00e1 parcheada en 2.1.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mnapoli:bref:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.13", "matchCriteriaId": "D8473D9F-5007-4ADC-B256-FD331BB522A0"}]}]}], "references": [{"url": "https://github.com/brefphp/bref/commit/350788de12880b6fd64c4c318ba995388bec840e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/brefphp/bref/security/advisories/GHSA-x4hh-frx8-98r5", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/brefphp/bref/commit/350788de12880b6fd64c4c318ba995388bec840e"}}