{"buggy_code": ["import Router from '@koa/router';\nimport json from 'koa-json-body';\nimport httpSignature from '@peertube/http-signature';\n\nimport { renderActivity } from '@/remote/activitypub/renderer/index.js';\nimport renderNote from '@/remote/activitypub/renderer/note.js';\nimport renderKey from '@/remote/activitypub/renderer/key.js';\nimport { renderPerson } from '@/remote/activitypub/renderer/person.js';\nimport renderEmoji from '@/remote/activitypub/renderer/emoji.js';\nimport Outbox, { packActivity } from './activitypub/outbox.js';\nimport Followers from './activitypub/followers.js';\nimport Following from './activitypub/following.js';\nimport Featured from './activitypub/featured.js';\nimport { inbox as processInbox } from '@/queue/index.js';\nimport { isSelfHost } from '@/misc/convert-host.js';\nimport { Notes, Users, Emojis, NoteReactions } from '@/models/index.js';\nimport { ILocalUser, User } from '@/models/entities/user.js';\nimport { In, IsNull, Not } from 'typeorm';\nimport { renderLike } from '@/remote/activitypub/renderer/like.js';\nimport { getUserKeypair } from '@/misc/keypair-store.js';\nimport renderFollow from '@/remote/activitypub/renderer/follow.js';\n\n// Init router\nconst router = new Router();\n\n//#region Routing\n\nfunction inbox(ctx: Router.RouterContext) {\n\tlet signature;\n\n\ttry {\n\t\tsignature = httpSignature.parseRequest(ctx.req, { 'headers': [] });\n\t} catch (e) {\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\tprocessInbox(ctx.request.body, signature);\n\n\tctx.status = 202;\n}\n\nconst ACTIVITY_JSON = 'application/activity+json; charset=utf-8';\nconst LD_JSON = 'application/ld+json; profile=\"https://www.w3.org/ns/activitystreams\"; charset=utf-8';\n\nfunction isActivityPubReq(ctx: Router.RouterContext) {\n\tctx.response.vary('Accept');\n\tconst accepted = ctx.accepts('html', ACTIVITY_JSON, LD_JSON);\n\treturn typeof accepted === 'string' && !accepted.match(/html/);\n}\n\nexport function setResponseType(ctx: Router.RouterContext) {\n\tconst accept = ctx.accepts(ACTIVITY_JSON, LD_JSON);\n\tif (accept === LD_JSON) {\n\t\tctx.response.type = LD_JSON;\n\t} else {\n\t\tctx.response.type = ACTIVITY_JSON;\n\t}\n}\n\n// inbox\nrouter.post('/inbox', json(), inbox);\nrouter.post('/users/:user/inbox', json(), inbox);\n\n// note\nrouter.get('/notes/:note', async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst note = await Notes.findOneBy({\n\t\tid: ctx.params.note,\n\t\tvisibility: In(['public' as const, 'home' as const]),\n\t\tlocalOnly: false,\n\t});\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\t// \u30ea\u30e2\u30fc\u30c8\u3060\u3063\u305f\u3089\u30ea\u30c0\u30a4\u30ec\u30af\u30c8\n\tif (note.userHost != null) {\n\t\tif (note.uri == null || isSelfHost(note.userHost)) {\n\t\t\tctx.status = 500;\n\t\t\treturn;\n\t\t}\n\t\tctx.redirect(note.uri);\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderNote(note, false));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n});\n\n// note activity\nrouter.get('/notes/:note/activity', async ctx => {\n\tconst note = await Notes.findOneBy({\n\t\tid: ctx.params.note,\n\t\tuserHost: IsNull(),\n\t\tvisibility: In(['public' as const, 'home' as const]),\n\t\tlocalOnly: false,\n\t});\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await packActivity(note));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n});\n\n// outbox\nrouter.get('/users/:user/outbox', Outbox);\n\n// followers\nrouter.get('/users/:user/followers', Followers);\n\n// following\nrouter.get('/users/:user/following', Following);\n\n// featured\nrouter.get('/users/:user/collections/featured', Featured);\n\n// publickey\nrouter.get('/users/:user/publickey', async ctx => {\n\tconst userId = ctx.params.user;\n\n\tconst user = await Users.findOneBy({\n\t\tid: userId,\n\t\thost: IsNull(),\n\t});\n\n\tif (user == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tconst keypair = await getUserKeypair(user.id);\n\n\tif (Users.isLocalUser(user)) {\n\t\tctx.body = renderActivity(renderKey(user, keypair));\n\t\tctx.set('Cache-Control', 'public, max-age=180');\n\t\tsetResponseType(ctx);\n\t} else {\n\t\tctx.status = 400;\n\t}\n});\n\n// user\nasync function userInfo(ctx: Router.RouterContext, user: User | null) {\n\tif (user == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderPerson(user as ILocalUser));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n}\n\nrouter.get('/users/:user', async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst userId = ctx.params.user;\n\n\tconst user = await Users.findOneBy({\n\t\tid: userId,\n\t\thost: IsNull(),\n\t\tisSuspended: false,\n\t});\n\n\tawait userInfo(ctx, user);\n});\n\nrouter.get('/@:user', async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst user = await Users.findOneBy({\n\t\tusernameLower: ctx.params.user.toLowerCase(),\n\t\thost: IsNull(),\n\t\tisSuspended: false,\n\t});\n\n\tawait userInfo(ctx, user);\n});\n//#endregion\n\n// emoji\nrouter.get('/emojis/:emoji', async ctx => {\n\tconst emoji = await Emojis.findOneBy({\n\t\thost: IsNull(),\n\t\tname: ctx.params.emoji,\n\t});\n\n\tif (emoji == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderEmoji(emoji));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n});\n\n// like\nrouter.get('/likes/:like', async ctx => {\n\tconst reaction = await NoteReactions.findOneBy({ id: ctx.params.like });\n\n\tif (reaction == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tconst note = await Notes.findOneBy({ id: reaction.noteId });\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderLike(reaction, note));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n});\n\n// follow\nrouter.get('/follows/:follower/:followee', async ctx => {\n\t// This may be used before the follow is completed, so we do not\n\t// check if the following exists.\n\n\tconst [follower, followee] = await Promise.all([\n\t\tUsers.findOneBy({\n\t\t\tid: ctx.params.follower,\n\t\t\thost: IsNull(),\n\t\t}),\n\t\tUsers.findOneBy({\n\t\t\tid: ctx.params.followee,\n\t\t\thost: Not(IsNull()),\n\t\t}),\n\t]);\n\n\tif (follower == null || followee == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(renderFollow(follower, followee));\n\tctx.set('Cache-Control', 'public, max-age=180');\n\tsetResponseType(ctx);\n});\n\nexport default router;\n"], "fixing_code": ["import Router from \"@koa/router\";\nimport bodyParser from \"koa-bodyparser\";\nimport * as crypto from 'crypto';\nimport httpSignature from \"@peertube/http-signature\";\n\nimport { In, IsNull, Not } from \"typeorm\";\nimport config from \"@/config/index.js\";\nimport { apLogger } from '@/remote/activitypub/logger.js';\nimport { renderActivity } from \"@/remote/activitypub/renderer/index.js\";\nimport renderNote from \"@/remote/activitypub/renderer/note.js\";\nimport renderKey from \"@/remote/activitypub/renderer/key.js\";\nimport { renderPerson } from \"@/remote/activitypub/renderer/person.js\";\nimport renderEmoji from \"@/remote/activitypub/renderer/emoji.js\";\nimport { inbox as processInbox } from \"@/queue/index.js\";\nimport { isSelfHost } from \"@/misc/convert-host.js\";\nimport { Notes, Users, Emojis, NoteReactions } from \"@/models/index.js\";\nimport { ILocalUser, User } from \"@/models/entities/user.js\";\nimport { renderLike } from \"@/remote/activitypub/renderer/like.js\";\nimport { getUserKeypair } from \"@/misc/keypair-store.js\";\nimport renderFollow from \"@/remote/activitypub/renderer/follow.js\";\nimport Featured from \"./activitypub/featured.js\";\nimport Following from \"./activitypub/following.js\";\nimport Followers from \"./activitypub/followers.js\";\nimport Outbox, { packActivity } from \"./activitypub/outbox.js\";\nimport { IActivity } from \"@/remote/activitypub/type.js\";\nimport Koa from \"koa\";\n\nconst logger = apLogger;\n\n// Init router\nconst router = new Router();\n\n//#region Routing\n\nfunction inbox(ctx: Router.RouterContext) {\n\t// \u7f72\u540d\u306e\u691c\u8a3c\n\t// referenced: https://github.com/mei23/misskey/pull/4749\n\tlet signature: httpSignature.IParsedSignature;\n\n\ttry {\n\t\t// \u30d8\u30c3\u30c0\u30fc\u306e\u691c\u8a3c\u306f\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u6295\u3052\u308b\n\t\tsignature = httpSignature.parseRequest(ctx.req, { \"headers\": [\"(request-target)\", \"digest\", \"host\", \"date\"] });\n\t} catch (e) {\n\t\tlogger.warn(\"inbox: signature parse error\");\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\t// Digest\u30d8\u30c3\u30c0\u30fc\u306e\u691c\u8a3c\n\tconst digest = ctx.req.headers.digest;\n\tif (typeof digest !== \"string\") {\n\t\t//logger.warn(\"Invalid digest (not string)\")\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\tconst match = digest.match(/^([0-9A-Za-z-]+)=(.+)$/);\n\n\tif (match == null) {\n\t\tlogger.warn(\"Invalid digest (match == null)\")\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\tconst digestAlgo = match[1];\n\tconst digestExpected = match[2];\n\n\tif (digestAlgo.toUpperCase() !== \"SHA-256\") {\n\t\t// \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u306a\u3044\n\t\tlogger.warn(\"digestAlgo is not supported\")\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\tconst digestActual = crypto.createHash(\"sha256\").update(ctx.request.rawBody).digest(\"base64\")\n\n\tif (digestExpected !== digestActual) {\n\t\t// \u4e0d\u6b63\u306a\u30c0\u30a4\u30b8\u30a7\u30b9\u30c8\n\t\tlogger.warn(\"Invalid digest (digestExpected !== digestActual)\")\n\t\tctx.status = 401;\n\t\treturn;\n\t}\n\n\n\tif (!signature.params.headers.includes(\"host\") || ctx.headers.host !== config.host) {\n\t\t// Host not specified or not match.\n\t\tlogger.warn(\"Invalid host header\")\n\t\tctx.status = 400;\n\t\treturn;\n\t}\n\n\tconst activity = ctx.request.body as IActivity;\n\tprocessInbox(activity, signature);\n\n\tctx.status = 202;\n}\n\nconst ACTIVITY_JSON = \"application/activity+json; charset=utf-8\";\nconst LD_JSON = \"application/ld+json; profile=\\\"https://www.w3.org/ns/activitystreams\\\"; charset=utf-8\";\n\nfunction isActivityPubReq(ctx: Router.RouterContext) {\n\tctx.response.vary(\"Accept\");\n\tconst accepted = ctx.accepts(\"html\", ACTIVITY_JSON, LD_JSON);\n\treturn typeof accepted === \"string\" && !accepted.match(/html/);\n}\n\nexport function setResponseType(ctx: Router.RouterContext) {\n\tconst accept = ctx.accepts(ACTIVITY_JSON, LD_JSON);\n\tif (accept === LD_JSON) {\n\t\tctx.response.type = LD_JSON;\n\t} else {\n\t\tctx.response.type = ACTIVITY_JSON;\n\t}\n}\n\nasync function parseJsonBodyOrFail(ctx: Router.RouterContext, next: Koa.Next) {\n\tconst koaBodyParser = bodyParser({\n\t\tenableTypes: [\"json\"],\n\t\tdetectJSON: () => true,\n\t});\n\n\ttry {\n\t\tawait koaBodyParser(ctx, next);\n\t}\n\tcatch {\n\t\tctx.status = 400;\n\t\treturn;\n\t}\n}\n\n\n// inbox\nrouter.post(\"/inbox\", parseJsonBodyOrFail, inbox);\nrouter.post(\"/users/:user/inbox\", parseJsonBodyOrFail, inbox);\n\n// note\nrouter.get(\"/notes/:note\", async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst note = await Notes.findOneBy({\n\t\tid: ctx.params.note,\n\t\tvisibility: In([\"public\" as const, \"home\" as const]),\n\t\tlocalOnly: false,\n\t});\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\t// \u30ea\u30e2\u30fc\u30c8\u3060\u3063\u305f\u3089\u30ea\u30c0\u30a4\u30ec\u30af\u30c8\n\tif (note.userHost != null) {\n\t\tif (note.uri == null || isSelfHost(note.userHost)) {\n\t\t\tctx.status = 500;\n\t\t\treturn;\n\t\t}\n\t\tctx.redirect(note.uri);\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderNote(note, false));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n});\n\n// note activity\nrouter.get(\"/notes/:note/activity\", async ctx => {\n\tconst note = await Notes.findOneBy({\n\t\tid: ctx.params.note,\n\t\tuserHost: IsNull(),\n\t\tvisibility: In([\"public\" as const, \"home\" as const]),\n\t\tlocalOnly: false,\n\t});\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await packActivity(note));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n});\n\n// outbox\nrouter.get(\"/users/:user/outbox\", Outbox);\n\n// followers\nrouter.get(\"/users/:user/followers\", Followers);\n\n// following\nrouter.get(\"/users/:user/following\", Following);\n\n// featured\nrouter.get(\"/users/:user/collections/featured\", Featured);\n\n// publickey\nrouter.get(\"/users/:user/publickey\", async ctx => {\n\tconst userId = ctx.params.user;\n\n\tconst user = await Users.findOneBy({\n\t\tid: userId,\n\t\thost: IsNull(),\n\t});\n\n\tif (user == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tconst keypair = await getUserKeypair(user.id);\n\n\tif (Users.isLocalUser(user)) {\n\t\tctx.body = renderActivity(renderKey(user, keypair));\n\t\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\t\tsetResponseType(ctx);\n\t} else {\n\t\tctx.status = 400;\n\t}\n});\n\n// user\nasync function userInfo(ctx: Router.RouterContext, user: User | null) {\n\tif (user == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderPerson(user as ILocalUser));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n}\n\nrouter.get(\"/users/:user\", async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst userId = ctx.params.user;\n\n\tconst user = await Users.findOneBy({\n\t\tid: userId,\n\t\thost: IsNull(),\n\t\tisSuspended: false,\n\t});\n\n\tawait userInfo(ctx, user);\n});\n\nrouter.get(\"/@:user\", async (ctx, next) => {\n\tif (!isActivityPubReq(ctx)) return await next();\n\n\tconst user = await Users.findOneBy({\n\t\tusernameLower: ctx.params.user.toLowerCase(),\n\t\thost: IsNull(),\n\t\tisSuspended: false,\n\t});\n\n\tawait userInfo(ctx, user);\n});\n//#endregion\n\n// emoji\nrouter.get(\"/emojis/:emoji\", async ctx => {\n\tconst emoji = await Emojis.findOneBy({\n\t\thost: IsNull(),\n\t\tname: ctx.params.emoji,\n\t});\n\n\tif (emoji == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderEmoji(emoji));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n});\n\n// like\nrouter.get(\"/likes/:like\", async ctx => {\n\tconst reaction = await NoteReactions.findOneBy({ id: ctx.params.like });\n\n\tif (reaction == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tconst note = await Notes.findOneBy({ id: reaction.noteId });\n\n\tif (note == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(await renderLike(reaction, note));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n});\n\n// follow\nrouter.get(\"/follows/:follower/:followee\", async ctx => {\n\t// This may be used before the follow is completed, so we do not\n\t// check if the following exists.\n\n\tconst [follower, followee] = await Promise.all([\n\t\tUsers.findOneBy({\n\t\t\tid: ctx.params.follower,\n\t\t\thost: IsNull(),\n\t\t}),\n\t\tUsers.findOneBy({\n\t\t\tid: ctx.params.followee,\n\t\t\thost: Not(IsNull()),\n\t\t}),\n\t]);\n\n\tif (follower == null || followee == null) {\n\t\tctx.status = 404;\n\t\treturn;\n\t}\n\n\tctx.body = renderActivity(renderFollow(follower, followee));\n\tctx.set(\"Cache-Control\", \"public, max-age=180\");\n\tsetResponseType(ctx);\n});\n\nexport default router;\n"], "filenames": ["packages/backend/src/server/activitypub.ts"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [251], "fixing_code_start_loc": [1], "fixing_code_end_loc": [322], "type": "CWE-20", "message": "nexkey is a microblogging platform. Insufficient validation of ActivityPub requests received in inbox could allow any user to impersonate another user in certain circumstances. This issue has been patched in version 12.122.2.", "other": {"cve": {"id": "CVE-2023-49095", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-30T07:15:09.133", "lastModified": "2023-12-05T17:31:04.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nexkey is a microblogging platform. Insufficient validation of ActivityPub requests received in inbox could allow any user to impersonate another user in certain circumstances. This issue has been patched in version 12.122.2."}, {"lang": "es", "value": "nexkey es una plataforma de microblogging. Una validaci\u00f3n insuficiente de las solicitudes de ActivityPub recibidas en la bandeja de entrada podr\u00eda permitir que cualquier usuario se haga pasar por otro usuario en determinadas circunstancias. Este problema se solucion\u00f3 en la versi\u00f3n 12.122.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nexryai:nexkey:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "12.122.2", "matchCriteriaId": "0A765E23-8158-4CD7-ACF2-66ECF9A3FA1E"}]}]}], "references": [{"url": "https://github.com/nexryai/nexkey/commit/b96da0eac5a1e75abba94cf926f1251842829bab", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nexryai/nexkey/security/advisories/GHSA-fpxw-rw9v-2gmx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nexryai/nexkey/commit/b96da0eac5a1e75abba94cf926f1251842829bab"}}