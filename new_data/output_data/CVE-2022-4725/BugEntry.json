{"buggy_code": ["/*\n * Copyright 2013-2019 Amazon Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *    http://aws.amazon.com/apache2.0\n *\n * This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES\n * OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.amazonaws.regions;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\n/**\n * Parses a region metadata file to pull out information about the available\n * regions, names, IDs, and what service endpoints are available in each region.\n *\n * @deprecated The SDK no longer supports a regions.xml override\n */\n@Deprecated\npublic class RegionMetadataParser {\n\n    private static final String REGION_TAG = \"Region\";\n    private static final String REGION_ID_TAG = \"Name\";\n    private static final String DOMAIN_TAG = \"Domain\";\n    private static final String ENDPOINT_TAG = \"Endpoint\";\n    private static final String SERVICE_TAG = \"ServiceName\";\n    private static final String HTTP_TAG = \"Http\";\n    private static final String HTTPS_TAG = \"Https\";\n    private static final String HOSTNAME_TAG = \"Hostname\";\n\n    /**\n     * Parses the specified input stream and returns a {@code RegionMetadata}\n     * object.\n     *\n     * @param input the input stream to parse\n     * @return the parsed region metadata\n     * @throws IOException on error\n     */\n    public static RegionMetadata parse(final InputStream input)\n            throws IOException {\n\n        return new RegionMetadata(internalParse(input, false));\n    }\n\n    /**\n     * @deprecated since this object is stateless\n     */\n    @Deprecated\n    public RegionMetadataParser() {\n    }\n\n    /**\n     * Parses the specified input stream and returns a list of the regions\n     * declared in it. By default, verification on the region endpoints is\n     * disabled.\n     *\n     * @param input The stream containing the region metadata to parse.\n     * @return The list of parsed regions.\n     * @deprecated in favor of {@link #parse(InputStream)}\n     */\n    @Deprecated\n    public List<Region> parseRegionMetadata(InputStream input)\n            throws IOException {\n\n        return internalParse(input, false);\n    }\n\n    /**\n     * Parses the specified input stream and optionally verifies that all of the\n     * endpoints end in \".amazonaws.com\". This method is deprecated, since not\n     * all valid AWS endpoints end in \".amazonaws.com\" any more.\n     *\n     * @param input The stream containing the region metadata to parse.\n     * @param endpointVerification Whether to verify each region endpoint\n     * @return The list of parsed regions.\n     * @deprecated in favor of {@link #parse(InputStream)}\n     */\n    @Deprecated\n    public List<Region> parseRegionMetadata(final InputStream input,\n            final boolean endpointVerification)\n            throws IOException {\n\n        return internalParse(input, endpointVerification);\n    }\n\n    @SuppressWarnings(\"checkstyle:emptyblock\")\n    private static List<Region> internalParse(\n            final InputStream input,\n            final boolean endpointVerification) throws IOException {\n\n        Document document;\n        try {\n\n            DocumentBuilderFactory factory =\n                    DocumentBuilderFactory.newInstance();\n\n            DocumentBuilder documentBuilder = factory.newDocumentBuilder();\n            document = documentBuilder.parse(input);\n\n        } catch (IOException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw new IOException(\"Unable to parse region metadata file: \"\n                    + exception.getMessage(),\n                    exception);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException exception) {\n            }\n        }\n\n        NodeList regionNodes = document.getElementsByTagName(REGION_TAG);\n        List<Region> regions = new ArrayList<Region>();\n        for (int i = 0; i < regionNodes.getLength(); i++) {\n            Node node = regionNodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                regions.add(parseRegionElement(element, endpointVerification));\n            }\n        }\n\n        return regions;\n    }\n\n    private static Region parseRegionElement(\n            final Element regionElement,\n            final boolean endpointVerification) {\n\n        String name = getChildElementValue(REGION_ID_TAG, regionElement);\n        String domain = getChildElementValue(DOMAIN_TAG, regionElement);\n\n        Region region = new Region(name, domain);\n\n        NodeList endpointNodes =\n                regionElement.getElementsByTagName(ENDPOINT_TAG);\n\n        for (int i = 0; i < endpointNodes.getLength(); i++) {\n            addRegionEndpoint(region,\n                    (Element) endpointNodes.item(i),\n                    endpointVerification);\n        }\n\n        return region;\n    }\n\n    private static void addRegionEndpoint(\n            final Region region,\n            final Element endpointElement,\n            final boolean endpointVerification) {\n\n        String serviceName = getChildElementValue(SERVICE_TAG, endpointElement);\n        String hostname = getChildElementValue(HOSTNAME_TAG, endpointElement);\n        String http = getChildElementValue(HTTP_TAG, endpointElement);\n        String https = getChildElementValue(HTTPS_TAG, endpointElement);\n\n        if (endpointVerification && !verifyLegacyEndpoint(hostname)) {\n            throw new IllegalStateException(\"Invalid service endpoint (\"\n                    + hostname + \") is detected.\");\n        }\n\n        region.getServiceEndpoints().put(serviceName, hostname);\n        region.getHttpSupport().put(serviceName, \"true\".equals(http));\n        region.getHttpsSupport().put(serviceName, \"true\".equals(https));\n    }\n\n    private static String getChildElementValue(\n            final String tagName,\n            final Element element) {\n\n        Node tagNode = element.getElementsByTagName(tagName).item(0);\n        if (tagNode == null)\n            return null;\n        NodeList nodes = tagNode.getChildNodes();\n        Node node = nodes.item(0);\n\n        return node.getNodeValue();\n    }\n\n    /**\n     * Returns whether the provided endpoint is a \"valid\" AWS service endpoint\n     * ending in \".amazonaws.com\".\n     */\n    private static boolean verifyLegacyEndpoint(String endpoint) {\n        return endpoint.endsWith(\".amazonaws.com\");\n    }\n}\n", "/*\n * Copyright 2010-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n\npackage com.amazonaws.util;\n\nimport com.amazonaws.logging.Log;\nimport com.amazonaws.logging.LogFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.ByteBuffer;\nimport java.util.Date;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\n/**\n * Utility methods for extracting data from XML documents using Xpath\n * expressions.\n */\npublic class XpathUtils {\n\n    /** Shared logger */\n    private static Log log = LogFactory.getLog(XpathUtils.class);\n\n    private static DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\n    /**\n     * InputStream to Document.\n     * @param is the input stream.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(InputStream is)\n            throws SAXException, IOException, ParserConfigurationException {\n        is = new NamespaceRemovingInputStream(is);\n        Document doc = factory.newDocumentBuilder().parse(is);\n        is.close();\n\n        return doc;\n    }\n\n    /**\n     * Xml string to Document.\n     * @param xml the xml string.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(String xml) throws SAXException,\n            IOException, ParserConfigurationException {\n        return documentFrom(new ByteArrayInputStream(xml.getBytes(StringUtils.UTF8)));\n    }\n\n    /**\n     * URL to Document,\n     * @param url the URL.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(URL url) throws SAXException,\n            IOException, ParserConfigurationException {\n        return documentFrom(url.openStream());\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the results as a\n     * Double.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Double result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Double asDouble(String expression, Node node)\n            throws XPathExpressionException {\n        String doubleString = evaluateAsString(expression, node);\n        return (isEmptyString(doubleString)) ? null : Double.valueOf(doubleString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * string.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The string result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static String asString(String expression, Node node)\n            throws XPathExpressionException {\n        return evaluateAsString(expression, node);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as an\n     * Integer.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Integer result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Integer asInteger(String expression, Node node)\n            throws XPathExpressionException {\n        String intString = evaluateAsString(expression, node);\n        return (isEmptyString(intString)) ? null : Integer.valueOf(intString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Boolean.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Boolean result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Boolean asBoolean(String expression, Node node)\n            throws XPathExpressionException {\n        String booleanString = evaluateAsString(expression, node);\n        return (isEmptyString(booleanString)) ? null : Boolean.valueOf(booleanString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Float.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Float result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Float asFloat(String expression, Node node)\n            throws XPathExpressionException {\n        String floatString = evaluateAsString(expression, node);\n        return (isEmptyString(floatString)) ? null : Float.valueOf(floatString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Long.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Long result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Long asLong(String expression, Node node)\n            throws XPathExpressionException {\n        String longString = evaluateAsString(expression, node);\n        return (isEmptyString(longString)) ? null : Long.valueOf(longString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Byte.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Byte result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Byte asByte(String expression, Node node)\n            throws XPathExpressionException {\n        String byteString = evaluateAsString(expression, node);\n        return (isEmptyString(byteString)) ? null : Byte.valueOf(byteString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Date. Assumes that the node's text is formatted as an ISO 8601 date, as\n     * specified by xs:dateTime.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Date result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Date asDate(String expression, Node node)\n            throws XPathExpressionException {\n        String dateString = evaluateAsString(expression, node);\n        if (isEmptyString(dateString))\n            return null;\n\n        return DateUtils.parseISO8601Date(dateString);\n    }\n\n    /**\n     * Evaluates the specified xpath expression, base64 decodes the data and\n     * returns the result as a ByteBuffer.\n     *\n     * @param expression The Xpath expression to evaluate.\n     * @param node The node on which to evaluate the expression.\n     * @return A ByteBuffer of base64 decoded data from the result of evaluating\n     *         the specified Xpath expression.\n     * @throws XPathExpressionException If there are any problems evaluating the\n     *             Xpath expression.\n     */\n    public static ByteBuffer asByteBuffer(String expression, Node node)\n            throws XPathExpressionException {\n        String base64EncodedString = evaluateAsString(expression, node);\n        if (isEmptyString(base64EncodedString))\n            return null;\n\n        if (!isEmpty(node)) {\n            byte[] decodedBytes = Base64.decode(base64EncodedString);\n            return ByteBuffer.wrap(decodedBytes);\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the specified node is null or has no children.\n     *\n     * @param node The node to test.\n     * @return True if the specified node is null or has no children.\n     */\n    public static boolean isEmpty(Node node) {\n        return (node == null);\n    }\n\n    /**\n     * Returns the length of the specified node list.\n     *\n     * @param list The node list to measure.\n     * @return The length of the specified node list.\n     */\n    public static int nodeLength(NodeList list) {\n        return list == null ? 0 : list.getLength();\n    }\n\n    /**\n     * Evaluates the specified expression on the specified node and returns the\n     * result as a String.\n     *\n     * @param expression The Xpath expression to evaluate.\n     * @param node The node on which to evaluate the expression.\n     * @return The result of evaluating the specified expression, or null if the\n     *         evaluation didn't return any result.\n     * @throws XPathExpressionException If there are any problems evaluating the\n     *             Xpath expression.\n     */\n    private static String evaluateAsString(String expression, Node node)\n            throws XPathExpressionException {\n        if (isEmpty(node))\n            return null;\n\n        if (!\".\".equals(expression)) {\n            /*\n             * If the expression being evaluated doesn't select a node, we want\n             * to return null to distinguish between cases where a node isn't\n             * present (which should be represented as null) and when a node is\n             * present, but empty (which should be represented as the empty\n             * string). We skip this test if the expression is \".\" since we've\n             * already checked that the node exists.\n             */\n            if (asNode(expression, node) == null)\n                return null;\n        }\n\n        String s = xpath().evaluate(expression, node);\n\n        return s.trim();\n    }\n\n    /**\n     * @param nodeName the node name.\n     * @param node the node.\n     * @return the Node.\n     * @throws XPathExpressionException\n     */\n    public static Node asNode(String nodeName, Node node)\n            throws XPathExpressionException {\n        if (node == null)\n            return null;\n        return (Node) xpath().evaluate(nodeName, node, XPathConstants.NODE);\n    }\n\n    /**\n     * @return true if the specified string is null or empty.\n     *\n     * @param s The string to test.\n     * @return True if the specified string is null or empty.\n     */\n    private static boolean isEmptyString(String s) {\n        if (s == null)\n            return true;\n        if (\"\".equals(s.trim()))\n            return true;\n\n        return false;\n    }\n\n    /**\n     * @return a new instance of XPath, which is not thread safe and not\n     * reentrant.\n     */\n    public static XPath xpath() {\n        return XPathFactory.newInstance().newXPath();\n    }\n\n}\n"], "fixing_code": ["/*\n * Copyright 2013-2019 Amazon Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *    http://aws.amazon.com/apache2.0\n *\n * This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES\n * OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.amazonaws.regions;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\n/**\n * Parses a region metadata file to pull out information about the available\n * regions, names, IDs, and what service endpoints are available in each region.\n *\n * @deprecated The SDK no longer supports a regions.xml override\n */\n@Deprecated\npublic class RegionMetadataParser {\n\n    private static final String REGION_TAG = \"Region\";\n    private static final String REGION_ID_TAG = \"Name\";\n    private static final String DOMAIN_TAG = \"Domain\";\n    private static final String ENDPOINT_TAG = \"Endpoint\";\n    private static final String SERVICE_TAG = \"ServiceName\";\n    private static final String HTTP_TAG = \"Http\";\n    private static final String HTTPS_TAG = \"Https\";\n    private static final String HOSTNAME_TAG = \"Hostname\";\n\n    /**\n     * Parses the specified input stream and returns a {@code RegionMetadata}\n     * object.\n     *\n     * @param input the input stream to parse\n     * @return the parsed region metadata\n     * @throws IOException on error\n     */\n    public static RegionMetadata parse(final InputStream input)\n            throws IOException {\n\n        return new RegionMetadata(internalParse(input, false));\n    }\n\n    /**\n     * @deprecated since this object is stateless\n     */\n    @Deprecated\n    public RegionMetadataParser() {\n    }\n\n    /**\n     * Parses the specified input stream and returns a list of the regions\n     * declared in it. By default, verification on the region endpoints is\n     * disabled.\n     *\n     * @param input The stream containing the region metadata to parse.\n     * @return The list of parsed regions.\n     * @deprecated in favor of {@link #parse(InputStream)}\n     */\n    @Deprecated\n    public List<Region> parseRegionMetadata(InputStream input)\n            throws IOException {\n\n        return internalParse(input, false);\n    }\n\n    /**\n     * Parses the specified input stream and optionally verifies that all of the\n     * endpoints end in \".amazonaws.com\". This method is deprecated, since not\n     * all valid AWS endpoints end in \".amazonaws.com\" any more.\n     *\n     * @param input The stream containing the region metadata to parse.\n     * @param endpointVerification Whether to verify each region endpoint\n     * @return The list of parsed regions.\n     * @deprecated in favor of {@link #parse(InputStream)}\n     */\n    @Deprecated\n    public List<Region> parseRegionMetadata(final InputStream input,\n            final boolean endpointVerification)\n            throws IOException {\n\n        return internalParse(input, endpointVerification);\n    }\n\n    @SuppressWarnings(\"checkstyle:emptyblock\")\n    private static List<Region> internalParse(\n            final InputStream input,\n            final boolean endpointVerification) throws IOException {\n\n        Document document;\n        try {\n\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder documentBuilder = factory.newDocumentBuilder();\n            document = documentBuilder.parse(input);\n\n        } catch (IOException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw new IOException(\"Unable to parse region metadata file: \"\n                    + exception.getMessage(),\n                    exception);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException exception) {\n            }\n        }\n\n        NodeList regionNodes = document.getElementsByTagName(REGION_TAG);\n        List<Region> regions = new ArrayList<Region>();\n        for (int i = 0; i < regionNodes.getLength(); i++) {\n            Node node = regionNodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                regions.add(parseRegionElement(element, endpointVerification));\n            }\n        }\n\n        return regions;\n    }\n\n    private static Region parseRegionElement(\n            final Element regionElement,\n            final boolean endpointVerification) {\n\n        String name = getChildElementValue(REGION_ID_TAG, regionElement);\n        String domain = getChildElementValue(DOMAIN_TAG, regionElement);\n\n        Region region = new Region(name, domain);\n\n        NodeList endpointNodes =\n                regionElement.getElementsByTagName(ENDPOINT_TAG);\n\n        for (int i = 0; i < endpointNodes.getLength(); i++) {\n            addRegionEndpoint(region,\n                    (Element) endpointNodes.item(i),\n                    endpointVerification);\n        }\n\n        return region;\n    }\n\n    private static void addRegionEndpoint(\n            final Region region,\n            final Element endpointElement,\n            final boolean endpointVerification) {\n\n        String serviceName = getChildElementValue(SERVICE_TAG, endpointElement);\n        String hostname = getChildElementValue(HOSTNAME_TAG, endpointElement);\n        String http = getChildElementValue(HTTP_TAG, endpointElement);\n        String https = getChildElementValue(HTTPS_TAG, endpointElement);\n\n        if (endpointVerification && !verifyLegacyEndpoint(hostname)) {\n            throw new IllegalStateException(\"Invalid service endpoint (\"\n                    + hostname + \") is detected.\");\n        }\n\n        region.getServiceEndpoints().put(serviceName, hostname);\n        region.getHttpSupport().put(serviceName, \"true\".equals(http));\n        region.getHttpsSupport().put(serviceName, \"true\".equals(https));\n    }\n\n    private static String getChildElementValue(\n            final String tagName,\n            final Element element) {\n\n        Node tagNode = element.getElementsByTagName(tagName).item(0);\n        if (tagNode == null)\n            return null;\n        NodeList nodes = tagNode.getChildNodes();\n        Node node = nodes.item(0);\n\n        return node.getNodeValue();\n    }\n\n    /**\n     * Returns whether the provided endpoint is a \"valid\" AWS service endpoint\n     * ending in \".amazonaws.com\".\n     */\n    private static boolean verifyLegacyEndpoint(String endpoint) {\n        return endpoint.endsWith(\".amazonaws.com\");\n    }\n}\n", "/*\n * Copyright 2010-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n\npackage com.amazonaws.util;\n\nimport com.amazonaws.logging.Log;\nimport com.amazonaws.logging.LogFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.ByteBuffer;\nimport java.util.Date;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\n/**\n * Utility methods for extracting data from XML documents using Xpath\n * expressions.\n */\npublic class XpathUtils {\n\n    /** Shared logger */\n    private static Log log = LogFactory.getLog(XpathUtils.class);\n\n    private static DocumentBuilderFactory factory = getDocumentBuilderFactory();\n\n\n    /**\n     * Creates new documentbuilderfactory object\n     * @return DocumentBuilderFactory.\n     */\n    private static DocumentBuilderFactory getDocumentBuilderFactory() {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setXIncludeAware(false); // Default false for java 8. Disable XML Inclusions leading to SSRF - https://portswigger.net/web-security/xxe/lab-xinclude-attack\n            dbf.setExpandEntityReferences(false);\n            return dbf;\n        }\n        catch (ParserConfigurationException exception){\n            return null;\n        }\n    }\n\n    /**\n     * InputStream to Document.\n     * @param is the input stream.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(InputStream is)\n            throws SAXException, IOException, ParserConfigurationException {\n        is = new NamespaceRemovingInputStream(is);\n        Document doc = factory.newDocumentBuilder().parse(is);\n        is.close();\n\n        return doc;\n    }\n\n    /**\n     * Xml string to Document.\n     * @param xml the xml string.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(String xml) throws SAXException,\n            IOException, ParserConfigurationException {\n        return documentFrom(new ByteArrayInputStream(xml.getBytes(StringUtils.UTF8)));\n    }\n\n    /**\n     * URL to Document,\n     * @param url the URL.\n     * @return the Document.\n     * @throws SAXException\n     * @throws IOException\n     * @throws ParserConfigurationException\n     */\n    public static Document documentFrom(URL url) throws SAXException,\n            IOException, ParserConfigurationException {\n        return documentFrom(url.openStream());\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the results as a\n     * Double.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Double result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Double asDouble(String expression, Node node)\n            throws XPathExpressionException {\n        String doubleString = evaluateAsString(expression, node);\n        return (isEmptyString(doubleString)) ? null : Double.valueOf(doubleString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * string.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The string result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static String asString(String expression, Node node)\n            throws XPathExpressionException {\n        return evaluateAsString(expression, node);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as an\n     * Integer.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Integer result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Integer asInteger(String expression, Node node)\n            throws XPathExpressionException {\n        String intString = evaluateAsString(expression, node);\n        return (isEmptyString(intString)) ? null : Integer.valueOf(intString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Boolean.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Boolean result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Boolean asBoolean(String expression, Node node)\n            throws XPathExpressionException {\n        String booleanString = evaluateAsString(expression, node);\n        return (isEmptyString(booleanString)) ? null : Boolean.valueOf(booleanString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Float.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Float result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Float asFloat(String expression, Node node)\n            throws XPathExpressionException {\n        String floatString = evaluateAsString(expression, node);\n        return (isEmptyString(floatString)) ? null : Float.valueOf(floatString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Long.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Long result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Long asLong(String expression, Node node)\n            throws XPathExpressionException {\n        String longString = evaluateAsString(expression, node);\n        return (isEmptyString(longString)) ? null : Long.valueOf(longString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Byte.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Byte result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Byte asByte(String expression, Node node)\n            throws XPathExpressionException {\n        String byteString = evaluateAsString(expression, node);\n        return (isEmptyString(byteString)) ? null : Byte.valueOf(byteString);\n    }\n\n    /**\n     * Evaluates the specified XPath expression and returns the result as a\n     * Date. Assumes that the node's text is formatted as an ISO 8601 date, as\n     * specified by xs:dateTime.\n     *\n     * @param expression The XPath expression to evaluate.\n     * @param node The node to run the expression on.\n     * @return The Date result.\n     * @throws XPathExpressionException If there was a problem processing the\n     *             specified XPath expression.\n     */\n    public static Date asDate(String expression, Node node)\n            throws XPathExpressionException {\n        String dateString = evaluateAsString(expression, node);\n        if (isEmptyString(dateString))\n            return null;\n\n        return DateUtils.parseISO8601Date(dateString);\n    }\n\n    /**\n     * Evaluates the specified xpath expression, base64 decodes the data and\n     * returns the result as a ByteBuffer.\n     *\n     * @param expression The Xpath expression to evaluate.\n     * @param node The node on which to evaluate the expression.\n     * @return A ByteBuffer of base64 decoded data from the result of evaluating\n     *         the specified Xpath expression.\n     * @throws XPathExpressionException If there are any problems evaluating the\n     *             Xpath expression.\n     */\n    public static ByteBuffer asByteBuffer(String expression, Node node)\n            throws XPathExpressionException {\n        String base64EncodedString = evaluateAsString(expression, node);\n        if (isEmptyString(base64EncodedString))\n            return null;\n\n        if (!isEmpty(node)) {\n            byte[] decodedBytes = Base64.decode(base64EncodedString);\n            return ByteBuffer.wrap(decodedBytes);\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the specified node is null or has no children.\n     *\n     * @param node The node to test.\n     * @return True if the specified node is null or has no children.\n     */\n    public static boolean isEmpty(Node node) {\n        return (node == null);\n    }\n\n    /**\n     * Returns the length of the specified node list.\n     *\n     * @param list The node list to measure.\n     * @return The length of the specified node list.\n     */\n    public static int nodeLength(NodeList list) {\n        return list == null ? 0 : list.getLength();\n    }\n\n    /**\n     * Evaluates the specified expression on the specified node and returns the\n     * result as a String.\n     *\n     * @param expression The Xpath expression to evaluate.\n     * @param node The node on which to evaluate the expression.\n     * @return The result of evaluating the specified expression, or null if the\n     *         evaluation didn't return any result.\n     * @throws XPathExpressionException If there are any problems evaluating the\n     *             Xpath expression.\n     */\n    private static String evaluateAsString(String expression, Node node)\n            throws XPathExpressionException {\n        if (isEmpty(node))\n            return null;\n\n        if (!\".\".equals(expression)) {\n            /*\n             * If the expression being evaluated doesn't select a node, we want\n             * to return null to distinguish between cases where a node isn't\n             * present (which should be represented as null) and when a node is\n             * present, but empty (which should be represented as the empty\n             * string). We skip this test if the expression is \".\" since we've\n             * already checked that the node exists.\n             */\n            if (asNode(expression, node) == null)\n                return null;\n        }\n\n        String s = xpath().evaluate(expression, node);\n\n        return s.trim();\n    }\n\n    /**\n     * @param nodeName the node name.\n     * @param node the node.\n     * @return the Node.\n     * @throws XPathExpressionException\n     */\n    public static Node asNode(String nodeName, Node node)\n            throws XPathExpressionException {\n        if (node == null)\n            return null;\n        return (Node) xpath().evaluate(nodeName, node, XPathConstants.NODE);\n    }\n\n    /**\n     * @return true if the specified string is null or empty.\n     *\n     * @param s The string to test.\n     * @return True if the specified string is null or empty.\n     */\n    private static boolean isEmptyString(String s) {\n        if (s == null)\n            return true;\n        if (\"\".equals(s.trim()))\n            return true;\n\n        return false;\n    }\n\n    /**\n     * @return a new instance of XPath, which is not thread safe and not\n     * reentrant.\n     */\n    public static XPath xpath() {\n        return XPathFactory.newInstance().newXPath();\n    }\n\n}\n"], "filenames": ["aws-android-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadataParser.java", "aws-android-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java"], "buggy_code_start_loc": [112, 48], "buggy_code_end_loc": [115, 49], "fixing_code_start_loc": [112, 48], "fixing_code_end_loc": [116, 67], "type": "CWE-918", "message": "A vulnerability was found in AWS SDK 2.59.0. It has been rated as critical. This issue affects the function XpathUtils of the file aws-android-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java of the component XML Parser. The manipulation leads to server-side request forgery. Upgrading to version 2.59.1 is able to address this issue. The name of the patch is c3e6d69422e1f0c80fe53f2d757b8df97619af2b. It is recommended to upgrade the affected component. The identifier VDB-216737 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4725", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T15:15:12.130", "lastModified": "2023-01-05T19:10:45.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in AWS SDK 2.59.0. It has been rated as critical. This issue affects the function XpathUtils of the file aws-android-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java of the component XML Parser. The manipulation leads to server-side request forgery. Upgrading to version 2.59.1 is able to address this issue. The name of the patch is c3e6d69422e1f0c80fe53f2d757b8df97619af2b. It is recommended to upgrade the affected component. The identifier VDB-216737 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_software_development_kit:*:*:*:*:*:android:*:*", "versionEndExcluding": "2.59.1", "matchCriteriaId": "CF9C5D60-F079-43FF-ABE3-EA862BDFCD34"}]}]}], "references": [{"url": "https://github.com/aws-amplify/aws-sdk-android/commit/c3e6d69422e1f0c80fe53f2d757b8df97619af2b", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aws-amplify/aws-sdk-android/pull/3100", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aws-amplify/aws-sdk-android/releases/tag/release_v2.59.1", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216737", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aws-amplify/aws-sdk-android/commit/c3e6d69422e1f0c80fe53f2d757b8df97619af2b"}}