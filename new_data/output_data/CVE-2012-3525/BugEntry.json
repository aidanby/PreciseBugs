{"buggy_code": ["/*\n * jabberd - Jabber Open Source Server\n * Copyright (c) 2002 Jeremie Miller, Thomas Muldowney,\n *                    Ryan Eatmon, Robert Norris\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n */\n\n#define _GNU_SOURCE\n#include <string.h>\n\n#include \"s2s.h\"\n\n#include <idna.h>\n\n/*\n * we handle packets going from the router to the world, and stuff\n * that comes in on connections we initiated.\n *\n * action points:\n *\n *   out_packet(s2s, nad) - send this packet out\n *     - extract to domain\n *     - get dbconn for this domain using out_route\n *       - if dbconn not available bounce packet\n *       - DONE\n *     - if conn in progress (tcp)\n *       - add packet to queue for this domain\n *       - DONE\n *     - if dbconn state valid for this domain, or packet is dialback\n *       - send packet\n *       - DONE\n *     - if dbconn state invalid for this domain\n *       - bounce packet (502)\n *       - DONE\n *     - add packet to queue for this domain\n *     - if dbconn state inprogress for this domain\n *       - DONE\n *     - out_dialback(dbconn, from, to)\n *\n *   out_route(s2s, route, out, allow_bad)\n *     - if dbconn not found\n *       - check internal resolver cache for domain\n *       - if not found\n *         - ask resolver for name\n *         - DONE\n *       - if outgoing ip/port is to be reused\n *         - get dbconn for any valid ip/port\n *         - if dbconn not found\n *            - create new dbconn\n *            - initiate connect to ip/port\n *            - DONE\n *       - create new dbconn\n *       - initiate connect to ip/port\n *       - DONE\n *\n *   out_dialback(dbconn, from, to) - initiate dialback\n *     - generate dbkey: sha1(secret+remote+stream id)\n *     - send auth request: <result to='them' from='us'>dbkey</result>\n *     - set dbconn state for this domain to inprogress\n *     - DONE\n *\n *   out_resolve(s2s, query) - responses from resolver\n *     - store ip/port/ttl in resolver cache\n *     - flush domain queue -> out_packet(s2s, domain)\n *     - DONE\n *\n *   event_STREAM - ip/port open\n *     - get dbconn for this sx\n *     - for each route handled by this conn, out_dialback(dbconn, from, to)\n *     - DONE\n *\n *   event_PACKET: <result from='them' to='us' type='xxx'/> - response to our auth request\n *     - get dbconn for this sx\n *     - if type valid\n *       - set dbconn state for this domain to valid\n *       - flush dbconn queue for this domain -> out_packet(s2s, pkt)\n *       - DONE\n *     - set dbconn state for this domain to invalid\n *     - bounce dbconn queue for this domain (502)\n *     - DONE\n *\n *   event_PACKET: <verify from='them' to='us' id='123' type='xxx'/> - incoming stream authenticated\n *     - get dbconn for given id\n *     - if type is valid\n *       - set dbconn state for this domain to valid\n *     - send result: <result to='them' from='us' type='xxx'/>\n *     - DONE\n */\n\n/* forward decls */\nstatic int _out_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void *arg);\nstatic int _out_sx_callback(sx_t s, sx_event_t e, void *data, void *arg);\nstatic void _out_result(conn_t out, nad_t nad);\nstatic void _out_verify(conn_t out, nad_t nad);\nstatic void _dns_result_aaaa(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data);\nstatic void _dns_result_a(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data);\n\n/** queue the packet */\nstatic void _out_packet_queue(s2s_t s2s, pkt_t pkt) {\n    char *rkey = s2s_route_key(NULL, pkt->from->domain, pkt->to->domain);\n    jqueue_t q = (jqueue_t) xhash_get(s2s->outq, rkey);\n\n    if(q == NULL) {\n        log_debug(ZONE, \"creating new out packet queue for '%s'\", rkey);\n        q = jqueue_new();\n        q->key = rkey;\n        xhash_put(s2s->outq, q->key, (void *) q);\n    } else {\n        free(rkey);\n    }\n\n    log_debug(ZONE, \"queueing packet for '%s'\", q->key);\n\n    jqueue_push(q, (void *) pkt, 0);\n}\n\nstatic void _out_dialback(conn_t out, char *rkey, int rkeylen) {\n    char *c, *dbkey, *tmp;\n    nad_t nad;\n    int elem, ns;\n    int from_len, to_len;\n    time_t now;\n\n    now = time(NULL);\n\n    c = memchr(rkey, '/', rkeylen);\n    from_len = c - rkey;\n    c++;\n    to_len = rkeylen - (c - rkey);\n\n    /* kick off the dialback */\n    tmp = strndup(c, to_len);\n    dbkey = s2s_db_key(NULL, out->s2s->local_secret, tmp, out->s->id);\n    free(tmp);\n\n    nad = nad_new();\n\n    /* request auth */\n    ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");\n    elem = nad_append_elem(nad, ns, \"result\", 0);\n    nad_set_attr(nad, elem, -1, \"from\", rkey, from_len);\n    nad_set_attr(nad, elem, -1, \"to\", c, to_len);\n    nad_append_cdata(nad, dbkey, strlen(dbkey), 1);\n\n    log_debug(ZONE, \"sending auth request for %.*s (key %s)\", rkeylen, rkey, dbkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] sending dialback auth request for route '%.*s'\", out->fd->fd, out->ip, out->port, rkeylen, rkey);\n\n    /* off it goes */\n    sx_nad_write(out->s, nad);\n\n    free(dbkey);\n\n    /* we're in progress now */\n    xhash_put(out->states, pstrdupx(xhash_pool(out->states), rkey, rkeylen), (void *) conn_INPROGRESS);\n\n    /* record the time that we set conn_INPROGRESS state */\n    xhash_put(out->states_time, pstrdupx(xhash_pool(out->states_time), rkey, rkeylen), (void *) now);\n}\n\nvoid _out_dns_mark_bad(conn_t out) {\n    if (out->s2s->dns_bad_timeout > 0) {\n        dnsres_t bad;\n        char *ipport;\n\n        /* mark this host as bad */\n        ipport = dns_make_ipport(out->ip, out->port);\n        bad = xhash_get(out->s2s->dns_bad, ipport);\n        if (bad == NULL) {\n            bad = (dnsres_t) calloc(1, sizeof(struct dnsres_st));\n            bad->key = ipport;\n            xhash_put(out->s2s->dns_bad, ipport, bad);\n        }\n        bad->expiry = time(NULL) + out->s2s->dns_bad_timeout;\n    }\n}\n\nint dns_select(s2s_t s2s, char *ip, int *port, time_t now, dnscache_t dns, int allow_bad) {\n    /* list of results */\n    dnsres_t l_reuse[DNS_MAX_RESULTS];\n    dnsres_t l_aaaa[DNS_MAX_RESULTS];\n    dnsres_t l_a[DNS_MAX_RESULTS];\n    dnsres_t l_bad[DNS_MAX_RESULTS];\n    /* running weight sums of results */\n    int rw_reuse[DNS_MAX_RESULTS];\n    int rw_aaaa[DNS_MAX_RESULTS];\n    int rw_a[DNS_MAX_RESULTS];\n    int s_reuse = 0, s_aaaa = 0, s_a = 0, s_bad = 0; /* count */\n    int p_reuse = 0, p_aaaa = 0, p_a = 0; /* list prio */\n    int wt_reuse = 0, wt_aaaa = 0, wt_a = 0; /* weight total */\n    int c_expired_good = 0;\n    union xhashv xhv;\n    dnsres_t res;\n    char *ipport;\n    int ipport_len;\n    char *c;\n    int c_len;\n    char *tmp;\n\n    /* for all results:\n     * - if not expired\n     *   - put highest priority reuseable addrs into list1\n     *   - put highest priority ipv6 addrs into list2\n     *   - put highest priority ipv4 addrs into list3\n     *   - put bad addrs into list4\n     * - pick weighted random entry from first non-empty list\n     */\n\n    if (dns->results == NULL) {\n        log_debug(ZONE, \"negative cache entry for '%s'\", dns->name);\n        return -1;\n    }\n    log_debug(ZONE, \"selecting DNS result for '%s'\", dns->name);\n\n    xhv.dnsres_val = &res;\n    if (xhash_iter_first(dns->results)) {\n        dnsres_t bad = NULL;\n        do {\n            xhash_iter_get(dns->results, (const char **) &ipport, &ipport_len, xhv.val);\n\n            if (s2s->dns_bad_timeout > 0)\n                bad = xhash_getx(s2s->dns_bad, ipport, ipport_len);\n\n            if (now > res->expiry) {\n                /* good host? */\n                if (bad == NULL)\n                    c_expired_good++;\n\n                log_debug(ZONE, \"host '%s' expired\", res->key);\n                continue;\n            } else if (bad != NULL && !(now > bad->expiry)) {\n                /* bad host (connection failure) */\n                l_bad[s_bad++] = res;\n\n                log_debug(ZONE, \"host '%s' bad\", res->key);\n            } else if (s2s->out_reuse && xhash_getx(s2s->out_host, ipport, ipport_len) != NULL) {\n                /* existing connection */\n                log_debug(ZONE, \"host '%s' exists\", res->key);\n                if (s_reuse == 0 || p_reuse > res->prio) {\n                    p_reuse = res->prio;\n                    s_reuse = 0;\n                    wt_reuse = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_reuse) {\n                    l_reuse[s_reuse] = res;\n                    wt_reuse += res->weight;\n                    rw_reuse[s_reuse] = wt_reuse;\n                    s_reuse++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_reuse);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            } else if (memchr(ipport, ':', ipport_len) != NULL) {\n                /* ipv6 */\n                log_debug(ZONE, \"host '%s' IPv6\", res->key);\n                if (s_aaaa == 0 || p_aaaa > res->prio) {\n                    p_aaaa = res->prio;\n                    s_aaaa = 0;\n                    wt_aaaa = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_aaaa) {\n                    l_aaaa[s_aaaa] = res;\n                    wt_aaaa += res->weight;\n                    rw_aaaa[s_aaaa] = wt_aaaa;\n                    s_aaaa++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_aaaa);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            } else {\n                /* ipv4 */\n                log_debug(ZONE, \"host '%s' IPv4\", res->key);\n                if (s_a == 0 || p_a > res->prio) {\n                    p_a = res->prio;\n                    s_a = 0;\n                    wt_a = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_a) {\n                    l_a[s_a] = res;\n                    wt_a += res->weight;\n                    rw_a[s_a] = wt_a;\n                    s_a++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_a);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            }\n        } while(xhash_iter_next(dns->results));\n    }\n\n    /* pick a result at weighted random (RFC 2782)\n     * all weights are guaranteed to be >= 16 && <= 16776960\n     * (assuming max 50 hosts, the total/running sums won't exceed 2^31)\n     */\n    ipport = NULL;\n    if (s_reuse > 0) {\n        int i, r;\n\n        log_debug(ZONE, \"using existing hosts, total weight %d\", wt_reuse);\n        assert((wt_reuse + 1) > 0);\n\n        r = rand() % (wt_reuse + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_reuse; i++)\n            if (rw_reuse[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_reuse[i]->key, rw_reuse[i]);\n\n                ipport = l_reuse[i]->key;\n                break;\n            }\n    } else if (s_aaaa > 0 && (s_a == 0 || p_aaaa <= p_a)) {\n        int i, r;\n\n        log_debug(ZONE, \"using IPv6 hosts, total weight %d\", wt_aaaa);\n        assert((wt_aaaa + 1) > 0);\n\n        r = rand() % (wt_aaaa + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_aaaa; i++)\n            if (rw_aaaa[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_aaaa[i]->key, rw_aaaa[i]);\n\n                ipport = l_aaaa[i]->key;\n                break;\n            }\n    } else if (s_a > 0) {\n        int i, r;\n\n        log_debug(ZONE, \"using IPv4 hosts, total weight %d\", wt_a);\n        assert((wt_a + 1) > 0);\n\n        r = rand() % (wt_a + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_a; i++)\n            if (rw_a[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_a[i]->key, rw_a[i]);\n\n                ipport = l_a[i]->key;\n                break;\n            }\n    } else if (s_bad > 0) {\n        ipport = l_bad[rand() % s_bad]->key;\n\n        log_debug(ZONE, \"using bad hosts, allow_bad=%d\", allow_bad);\n\n        /* there are expired good hosts, expire cache immediately */\n        if (c_expired_good > 0) {\n            log_debug(ZONE, \"expiring this DNS cache entry, %d expired hosts\",\n                c_expired_good);\n\n            dns->expiry = 0;\n        }\n\n        if (!allow_bad)\n            return -1;\n    }\n\n    /* results cannot all expire before the collection does */\n    assert(ipport != NULL);\n\n    /* copy the ip and port to the packet */\n    ipport_len = strlen(ipport);\n    c = strchr(ipport, '/');\n    strncpy(ip, ipport, c-ipport);\n    ip[c-ipport] = '\\0';\n    c++;\n    c_len = ipport_len - (c - ipport);\n    tmp = strndup(c, c_len);\n    *port = atoi(tmp);\n    free(tmp);\n\n    return 0;\n}\n\n/** find/make a connection for a route */\nint out_route(s2s_t s2s, char *route, int routelen, conn_t *out, int allow_bad) {\n    dnscache_t dns;\n    char ipport[INET6_ADDRSTRLEN + 16], *dkey, *c;\n    time_t now;\n    int reuse = 0;\n    char ip[INET6_ADDRSTRLEN] = {0};\n    int port, c_len, from_len;\n\n    c = memchr(route, '/', routelen);\n    from_len = c - route;\n    c++;\n    c_len = routelen - (c - route);\n    dkey = strndup(c, c_len);\n\n    log_debug(ZONE, \"trying to find connection for '%s'\", dkey);\n    *out = (conn_t) xhash_get(s2s->out_dest, dkey);\n    if(*out == NULL) {\n        log_debug(ZONE, \"connection for '%s' not found\", dkey);\n\n        /* check resolver cache for ip/port */\n        dns = xhash_get(s2s->dnscache, dkey);\n        if(dns == NULL) {\n            /* new resolution */\n            log_debug(ZONE, \"no dns for %s, preparing for resolution\", dkey);\n\n            dns = (dnscache_t) calloc(1, sizeof(struct dnscache_st));\n\n            strcpy(dns->name, dkey);\n\n            xhash_put(s2s->dnscache, dns->name, (void *) dns);\n\n#if 0\n            /* this is good for testing */\n            dns->pending = 0;\n            strcpy(dns->ip, \"127.0.0.1\");\n            dns->port = 3000;\n            dns->expiry = time(NULL) + 99999999;\n#endif\n        }\n\n        /* resolution in progress */\n        if(dns->pending) {\n            log_debug(ZONE, \"pending resolution\");\n            free(dkey);\n            return 0;\n        }\n\n        /* has it expired (this is 0 for new cache objects, so they're always expired */\n        now = time(NULL); /* each entry must be expired no earlier than the collection */\n        if(now > dns->expiry) {\n            /* resolution required */\n            log_debug(ZONE, \"requesting resolution for %s\", dkey);\n\n            dns->init_time = time(NULL);\n            dns->pending = 1;\n\n            dns_resolve_domain(s2s, dns);\n            free(dkey);\n            return 0;\n        }\n\n        /* dns is valid */\n        if (dns_select(s2s, ip, &port, now, dns, allow_bad)) {\n            /* failed to find anything acceptable */\n            free(dkey);\n            return -1;\n        }\n\n        /* re-request resolution if dns_select expired the data */\n        if (now > dns->expiry) {\n            /* resolution required */\n            log_debug(ZONE, \"requesting resolution for %s\", dkey);\n\n            dns->init_time = time(NULL);\n            dns->pending = 1;\n\n            dns_resolve_domain(s2s, dns);\n\n            free(dkey);\n            return 0;\n        }\n\n        /* generate the ip/port pair, this is the hash key for the conn */\n        snprintf(ipport, INET6_ADDRSTRLEN + 16, \"%s/%d\", ip, port);\n\n        /* try to re-use an existing connection */\n        if (s2s->out_reuse)\n            *out = (conn_t) xhash_get(s2s->out_host, ipport);\n\n        if (*out != NULL) {\n            log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] using connection for '%s'\", (*out)->fd->fd, (*out)->ip, (*out)->port, dkey);\n\n            /* associate existing connection with domain */\n            xhash_put(s2s->out_dest, s2s->out_reuse ? pstrdup(xhash_pool((*out)->routes), dkey) : dkey, (void *) *out);\n\n            reuse = 1;\n        } else{\n            /* no conn, create one */\n            *out = (conn_t) calloc(1, sizeof(struct conn_st));\n\n            (*out)->s2s = s2s;\n\n            (*out)->key = strdup(ipport);\n            if (s2s->out_reuse)\n                (*out)->dkey = NULL;\n            else\n                (*out)->dkey = dkey;\n\n            strcpy((*out)->ip, ip);\n            (*out)->port = port;\n\n            (*out)->states = xhash_new(101);\n            (*out)->states_time = xhash_new(101);\n\n            (*out)->routes = xhash_new(101);\n\n            (*out)->init_time = time(NULL);\n\n            if (s2s->out_reuse)\n                xhash_put(s2s->out_host, (*out)->key, (void *) *out);\n            xhash_put(s2s->out_dest, s2s->out_reuse ? pstrdup(xhash_pool((*out)->routes), dkey) : dkey, (void *) *out);\n\n            xhash_put((*out)->routes, pstrdupx(xhash_pool((*out)->routes), route, routelen), (void *) 1);\n\n            /* connect */\n            log_debug(ZONE, \"initiating connection to %s\", ipport);\n\n            /* APPLE: multiple origin_ips may be specified; use IPv6 if possible or otherwise IPv4 */\n            int ip_is_v6 = 0;\n            if (strchr(ip, ':') != NULL)\n                ip_is_v6 = 1;\n            int i;\n            for (i = 0; i < s2s->origin_nips; i++) {\n                // only bother with mio_connect if the src and dst IPs are of the same type\n                if ((ip_is_v6 && (strchr(s2s->origin_ips[i], ':') != NULL)) ||          // both are IPv6\n                            (! ip_is_v6 && (strchr(s2s->origin_ips[i], ':') == NULL)))  // both are IPv4\n                    (*out)->fd = mio_connect(s2s->mio, port, ip, s2s->origin_ips[i], _out_mio_callback, (void *) *out);\n\n                if ((*out)->fd != NULL) break;\n            }\n\n            if ((*out)->fd == NULL) {\n                log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] mio_connect error: %s (%d)\", -1, (*out)->ip, (*out)->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n                _out_dns_mark_bad(*out);\n\n                if (s2s->out_reuse)\n                   xhash_zap(s2s->out_host, (*out)->key);\n                xhash_zap(s2s->out_dest, dkey);\n\n                xhash_free((*out)->states);\n                xhash_free((*out)->states_time);\n\n                xhash_free((*out)->routes);\n\n                free((*out)->key);\n                free((*out)->dkey);\n                free(*out);\n                *out = NULL;\n\n                /* try again without allowing bad hosts */\n                return out_route(s2s, route, routelen, out, 0);\n            } else {\n                log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing connection for '%s'\", (*out)->fd->fd, (*out)->ip, (*out)->port, dkey);\n\n                (*out)->s = sx_new(s2s->sx_env, (*out)->fd->fd, _out_sx_callback, (void *) *out);\n\n#ifdef HAVE_SSL\n                /* Send a stream version of 1.0 if we can do STARTTLS */\n                if(s2s->sx_ssl != NULL) {\n                    sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, dkey, pstrdupx(xhash_pool((*out)->routes), route, from_len), \"1.0\");\n                } else {\n                    sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, NULL, NULL, NULL);\n                }\n#else\n                sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, NULL, NULL, NULL);\n#endif\n                /* dkey is now used by the hash table */\n                return 0;\n            }\n        }\n    } else {\n        log_debug(ZONE, \"connection for '%s' found (%d %s/%d)\", dkey, (*out)->fd->fd, (*out)->ip, (*out)->port);\n    }\n\n    /* connection in progress, or re-using connection: add to routes list */\n    if (!(*out)->online || reuse) {\n        if (xhash_getx((*out)->routes, route, routelen) == NULL)\n            xhash_put((*out)->routes, pstrdupx(xhash_pool((*out)->routes), route, routelen), (void *) 1);\n    }\n\n    free(dkey);\n    return 0;\n}\n\nvoid out_pkt_free(pkt_t pkt)\n{\n    nad_free(pkt->nad);\n    jid_free(pkt->from);\n    jid_free(pkt->to);\n    free(pkt);\n}\n\n/** send a packet out */\nint out_packet(s2s_t s2s, pkt_t pkt) {\n    char *rkey;\n    int rkeylen;\n    conn_t out;\n    conn_state_t state;\n    int ret;\n\n    /* perform check against whitelist */\n    if (s2s->enable_whitelist > 0 &&\n            (pkt->to->domain != NULL) &&\n            (s2s_domain_in_whitelist(s2s, pkt->to->domain) == 0)) {\n        log_write(s2s->log, LOG_NOTICE, \"sending a packet to domain not in the whitelist, dropping it\");\n        if (pkt->to != NULL)\n            jid_free(pkt->to);\n        if (pkt->from != NULL)\n            jid_free(pkt->from);\n        if (pkt->nad != NULL)\n            nad_free(pkt->nad);\n        free(pkt);\n\n        return;\n    }\n\n    /* new route key */\n    rkey = s2s_route_key(NULL, pkt->from->domain, pkt->to->domain);\n    rkeylen = strlen(rkey);\n\n    /* get a connection */\n    ret = out_route(s2s, rkey, rkeylen, &out, 1);\n\n    if (out == NULL) {\n        /* connection not available, queue packet */\n        _out_packet_queue(s2s, pkt);\n\n        /* check if out_route was successful in attempting a connection */\n        if (ret) {\n            /* bounce queue */\n            out_bounce_route_queue(s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n            free(rkey);\n            return -1;\n        }\n\n        free(rkey);\n        return 0;\n    }\n\n    /* connection in progress */\n    if(!out->online) {\n        log_debug(ZONE, \"connection in progress, queueing packet\");\n\n        _out_packet_queue(s2s, pkt);\n\n        free(rkey);\n        return 0;\n    }\n\n    /* connection state */\n    state = (conn_state_t) xhash_get(out->states, rkey);\n\n    /* valid conns or dialback packets */\n    if(state == conn_VALID || pkt->db) {\n        log_debug(ZONE, \"writing packet for %s to outgoing conn %d\", rkey, out->fd->fd);\n\n        /* send it straight out */\n        if(pkt->db) {\n            /* if this is a db:verify packet, increment counter and set timestamp */\n            if(NAD_ENAME_L(pkt->nad, 0) == 6 && strncmp(\"verify\", NAD_ENAME(pkt->nad, 0), 6) == 0) {\n                out->verify++;\n                out->last_verify = time(NULL);\n            }\n\n            /* dialback packet */\n            sx_nad_write(out->s, pkt->nad);\n        } else {\n            /* if the outgoing stanza has a jabber:client namespace, remove it so that the stream jabber:server namespaces will apply (XMPP 11.2.2) */\n            int ns = nad_find_namespace(pkt->nad, 1, uri_CLIENT, NULL);\n            if(ns >= 0) {\n               /* clear the namespaces of elem 0 (internal route element) and elem 1 (message|iq|presence) */\n               pkt->nad->elems[0].ns = -1;\n               pkt->nad->elems[0].my_ns = -1;\n               pkt->nad->elems[1].ns = -1;\n               pkt->nad->elems[1].my_ns = -1;\n            }\n\n            /* send it out */\n            sx_nad_write_elem(out->s, pkt->nad, 1);\n        }\n\n        /* update timestamp */\n        out->last_packet = time(NULL);\n\n        jid_free(pkt->from);\n        jid_free(pkt->to);\n        free(pkt);\n\n        free(rkey);\n        return 0;\n    }\n\n    /* can't be handled yet, queue */\n    _out_packet_queue(s2s, pkt);\n\n    /* if dialback is in progress, then we're done for now */\n    if(state == conn_INPROGRESS) {\n        free(rkey);\n        return 0;\n    }\n\n    /* this is a new route - send dialback auth request to piggyback on the existing connection */\n    if (out->s2s->require_tls == 0 || out->s->ssf > 0) {\n    _out_dialback(out, rkey, rkeylen);\n    }\n    free(rkey);\n    return 0;\n}\n\nchar *dns_make_ipport(char *host, int port) {\n    char *c;\n    assert(port > 0 && port < 65536);\n\n    c = (char *) malloc(strlen(host) + 7);\n    sprintf(c, \"%s/%d\", host, port);\n    return c;\n}\n\nstatic void _dns_add_result(dnsquery_t query, char *ip, int port, int prio, int weight, unsigned int ttl) {\n    char *ipport = dns_make_ipport(ip, port);\n    dnsres_t res = xhash_get(query->results, ipport);\n\n    if (res != NULL) {\n        if (prio < res->prio)\n            res->prio = prio;\n\n        if (prio < res->prio) {\n            /* duplicate host at lower prio - reset weight */\n            res->weight = weight;\n        } else if (prio == res->prio) {\n            /* duplicate host at same prio - add to weight */\n            res->weight += weight;\n            if (res->weight > (65535 << 8))\n                res->weight = (65535 << 8);\n        }\n\n        if (ttl > res->expiry)\n            res->expiry = ttl;\n\n        if (ttl > query->expiry)\n            query->expiry = ttl;\n\n        log_debug(ZONE, \"dns result updated for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else if (xhash_count(query->results) < DNS_MAX_RESULTS) {\n        res = pmalloc(xhash_pool(query->results), sizeof(struct dnsres_st));\n        res->key = pstrdup(xhash_pool(query->results), ipport);\n        res->prio = prio;\n        res->weight = weight;\n        res->expiry = ttl;\n\n        if (ttl > query->expiry)\n            query->expiry = ttl;\n\n        xhash_put(query->results, res->key, res);\n\n        log_debug(ZONE, \"dns result added for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else {\n        log_debug(ZONE, \"dns result ignored for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            prio, (weight >> 8), ttl);\n    }\n\n    free(ipport);\n}\n\nstatic void _dns_add_host(dnsquery_t query, char *ip, int port, int prio, int weight, unsigned int ttl) {\n    char *ipport = dns_make_ipport(ip, port);\n    dnsres_t res = xhash_get(query->hosts, ipport);\n\n    /* update host weights:\n     *  RFC 2482 \"In the presence of records containing weights greater\n     *  than 0, records with weight 0 should have a very small chance of\n     *  being selected.\"\n     * 0       -> 16\n     * 1-65535 -> 256-16776960\n     */\n    if (weight == 0)\n        weight = 1 << 4;\n    else\n        weight <<= 8;\n\n    if (res != NULL) {\n        if (prio < res->prio)\n            res->prio = prio;\n\n        if (prio < res->prio) {\n            /* duplicate host at lower prio - reset weight */\n            res->weight = weight;\n        } else if (prio == res->prio) {\n            /* duplicate host at same prio - add to weight */\n            res->weight += weight;\n            if (res->weight > (65535 << 8))\n                res->weight = (65535 << 8);\n        }\n\n        if (ttl > res->expiry)\n            res->expiry = ttl;\n\n        log_debug(ZONE, \"dns host updated for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else if (xhash_count(query->hosts) < DNS_MAX_RESULTS) {\n        res = pmalloc(xhash_pool(query->hosts), sizeof(struct dnsres_st));\n        res->key = pstrdup(xhash_pool(query->hosts), ipport);\n        res->prio = prio;\n        res->weight = weight;\n        res->expiry = ttl;\n\n        xhash_put(query->hosts, res->key, res);\n\n        log_debug(ZONE, \"dns host added for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else {\n        log_debug(ZONE, \"dns host ignored for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            prio, (weight >> 8), ttl);\n    }\n\n    free(ipport);\n}\n\n/* this function is called with a NULL ctx to start the SRV process */\nstatic void _dns_result_srv(struct dns_ctx *ctx, struct dns_rr_srv *result, void *data) {\n    dnsquery_t query = data;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n        log_debug(ZONE, \"dns failure for %s@%p: SRV %s (%d)\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i], dns_status(ctx));\n    } else if (result != NULL) {\n        int i;\n\n        log_debug(ZONE, \"dns response for %s@%p: SRV %s %d (%d)\", query->name, query,\n            result->dnssrv_qname, result->dnssrv_nrr, result->dnssrv_ttl);\n\n        for (i = 0; i < result->dnssrv_nrr; i++) {\n            if (strlen(result->dnssrv_srv[i].name) > 0\n                    && result->dnssrv_srv[i].port > 0\n                    && result->dnssrv_srv[i].port < 65536) {\n                log_debug(ZONE, \"dns response for %s@%p: SRV %s[%d] %s/%d (%d/%d)\", query->name,\n                    query, result->dnssrv_qname, i,\n                    result->dnssrv_srv[i].name, result->dnssrv_srv[i].port,\n                    result->dnssrv_srv[i].priority, result->dnssrv_srv[i].weight);\n\n                _dns_add_host(query, result->dnssrv_srv[i].name,\n                    result->dnssrv_srv[i].port, result->dnssrv_srv[i].priority,\n                    result->dnssrv_srv[i].weight, result->dnssrv_ttl);\n            }\n        }\n\n        free(result);\n    }\n\n    /* check next SRV service name */\n    query->srv_i++;\n    if (query->srv_i < query->s2s->lookup_nsrv) {\n        log_debug(ZONE, \"dns request for %s@%p: SRV %s\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i]);\n\n        query->query = dns_submit_srv(NULL, query->name, query->s2s->lookup_srv[query->srv_i], \"tcp\",\n            DNS_NOSRCH, _dns_result_srv, query);\n\n        /* if submit failed, call ourselves with a NULL result */\n        if (query->query == NULL)\n            _dns_result_srv(ctx, NULL, query);\n    } else {\n        /* no more SRV records to check, resolve hosts */\n        if (xhash_count(query->hosts) > 0) {\n            _dns_result_a(NULL, NULL, query);\n\n        /* no SRV records returned, resolve hostname */\n        } else {\n            query->cur_host = strdup(query->name);\n            query->cur_port = 5269;\n            query->cur_prio = 0;\n            query->cur_weight = 0;\n            query->cur_expiry = 0;\n            if (query->s2s->resolve_aaaa) {\n                log_debug(ZONE, \"dns request for %s@%p: AAAA %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a6(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_aaaa, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_aaaa(ctx, NULL, query);\n            } else {\n                log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a4(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_a, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_a(ctx, NULL, query);\n            }\n        }\n    }\n}\n\nstatic void _dns_result_aaaa(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data) {\n    dnsquery_t query = data;\n    char ip[INET6_ADDRSTRLEN];\n    int i;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n        log_debug(ZONE, \"dns failure for %s@%p: AAAA %s (%d)\", query->name, query,\n            query->cur_host, dns_status(ctx));\n    } else if (result != NULL) {\n        log_debug(ZONE, \"dns response for %s@%p: AAAA %s %d (%d)\", query->name, query,\n            result->dnsa6_qname, result->dnsa6_nrr, result->dnsa6_ttl);\n\n        if (query->cur_expiry > 0 && result->dnsa6_ttl > query->cur_expiry)\n            result->dnsa6_ttl = query->cur_expiry;\n\n        for (i = 0; i < result->dnsa6_nrr; i++) {\n            if (inet_ntop(AF_INET6, &result->dnsa6_addr[i], ip, INET6_ADDRSTRLEN) != NULL) {\n                log_debug(ZONE, \"dns response for %s@%p: AAAA %s[%d] %s/%d\", query->name,\n                    query, result->dnsa6_qname, i, ip, query->cur_port);\n\n                _dns_add_result(query, ip, query->cur_port,\n                    query->cur_prio, query->cur_weight, result->dnsa6_ttl);\n            }\n        }\n    }\n\n    if (query->cur_host != NULL) {\n        /* do ipv4 resolution too */\n        log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->cur_host);\n\n        query->query = dns_submit_a4(NULL, query->cur_host,\n            DNS_NOSRCH, _dns_result_a, query);\n\n        /* if submit failed, call ourselves with a NULL result */\n        if (query->query == NULL)\n            _dns_result_a(ctx, NULL, query);\n    } else {\n        /* uh-oh */\n        log_debug(ZONE, \"dns result for %s@%p: AAAA host vanished...\", query->name, query);\n        _dns_result_a(NULL, NULL, query);\n    }\n\n    free(result);\n}\n\n/* try /etc/hosts if the A process did not return any results */\nstatic int _etc_hosts_lookup(const char *cszName, char *szIP, const int ciMaxIPLen) {\n#define EHL_LINE_LEN 260\n    int iSuccess = 0;\n    size_t iLen;\n    char szLine[EHL_LINE_LEN + 1]; /* one extra for the space character (*) */\n    char *pcStart, *pcEnd;\n    FILE *fHosts;\n\n    do {\n        /* initialization */\n        fHosts = NULL;\n\n        /* sanity checks */\n        if ((cszName == NULL) || (szIP == NULL) || (ciMaxIPLen <= 0))\n            break;\n        szIP[0] = 0;\n\n        /* open the hosts file */\n#ifdef _WIN32\n        pcStart = getenv(\"WINDIR\");\n        if (pcStart != NULL) {\n            sprintf(szLine, \"%s\\\\system32\\\\drivers\\\\etc\\\\hosts\", pcStart);\n        } else {\n            strcpy(szLine, \"C:\\\\WINDOWS\\\\system32\\\\drivers\\\\etc\\\\hosts\");\n        }\n#else\n        strcpy(szLine, \"/etc/hosts\");\n#endif\n        fHosts = fopen(szLine, \"r\");\n        if (fHosts == NULL)\n            break;\n\n        /* read line by line ... */\n        while (fgets(szLine, EHL_LINE_LEN, fHosts) != NULL) {\n            /* remove comments */\n            pcStart = strchr (szLine, '#');\n            if (pcStart != NULL)\n                *pcStart = 0;\n            strcat(szLine, \" \"); /* append a space character for easier parsing (*) */\n\n            /* first to appear: IP address */\n            iLen = strspn(szLine, \"1234567890.\");\n            if ((iLen < 7) || (iLen > 15)) /* superficial test for anything between x.x.x.x and xxx.xxx.xxx.xxx */\n                continue;\n            pcEnd = szLine + iLen;\n            *pcEnd = 0;\n            pcEnd++; /* not beyond the end of the line yet (*) */\n\n            /* check strings separated by blanks, tabs or newlines */\n            pcStart = pcEnd + strspn(pcEnd, \" \\t\\n\");\n            while (*pcStart != 0) {\n                pcEnd = pcStart + strcspn(pcStart, \" \\t\\n\");\n                *pcEnd = 0;\n                pcEnd++; /* not beyond the end of the line yet (*) */\n\n                if (strcasecmp(pcStart, cszName) == 0) {\n                    strncpy(szIP, szLine, ciMaxIPLen - 1);\n                    szIP[ciMaxIPLen - 1] = '\\0';\n                    iSuccess = 1;\n                    break;\n                }\n\n                pcStart = pcEnd + strspn(pcEnd, \" \\t\\n\");\n            }\n            if (iSuccess)\n                break;\n        }\n    } while (0);\n\n    if (fHosts != NULL)\n        fclose(fHosts);\n\n    return (iSuccess);\n}\n\n/* this function is called with a NULL ctx to start the A/AAAA process */\nstatic void _dns_result_a(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data) {\n    dnsquery_t query = data;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n#define DRA_IP_LEN 16\n        char szIP[DRA_IP_LEN];\n        if (_etc_hosts_lookup (query->name, szIP, DRA_IP_LEN)) {\n            log_debug(ZONE, \"/etc/lookup for %s@%p: %s (%d)\", query->name,\n                query, szIP, query->s2s->etc_hosts_ttl);\n\n            _dns_add_result (query, szIP, query->cur_port,\n                query->cur_prio, query->cur_weight, query->s2s->etc_hosts_ttl);\n        } else {\n            log_debug(ZONE, \"dns failure for %s@%p: A %s (%d)\", query->name, query,\n                query->cur_host, dns_status(ctx));\n        }\n    } else if (result != NULL) {\n        char ip[INET_ADDRSTRLEN];\n        int i;\n\n        log_debug(ZONE, \"dns response for %s@%p: A %s %d (%d)\", query->name,\n            query, result->dnsa4_qname, result->dnsa4_nrr, result->dnsa4_ttl);\n\n        if (query->cur_expiry > 0 && result->dnsa4_ttl > query->cur_expiry)\n            result->dnsa4_ttl = query->cur_expiry;\n\n        for (i = 0; i < result->dnsa4_nrr; i++) {\n            if (inet_ntop(AF_INET, &result->dnsa4_addr[i], ip, INET_ADDRSTRLEN) != NULL) {\n                log_debug(ZONE, \"dns response for %s@%p: A %s[%d] %s/%d\", query->name,\n                    query, result->dnsa4_qname, i, ip, query->cur_port);\n\n                _dns_add_result(query, ip, query->cur_port,\n                    query->cur_prio, query->cur_weight, result->dnsa4_ttl);\n            }\n        }\n\n        free(result);\n    }\n\n    /* resolve the next host in the list */\n    if (xhash_iter_first(query->hosts)) {\n        char *ipport, *c, *tmp;\n        int ipport_len, ip_len, port_len;\n        dnsres_t res;\n        union xhashv xhv;\n\n        xhv.dnsres_val = &res;\n\n        /* get the first entry */\n        xhash_iter_get(query->hosts, (const char **) &ipport, &ipport_len, xhv.val);\n\n        /* remove the host from the list */\n        xhash_iter_zap(query->hosts);\n\n        c = memchr(ipport, '/', ipport_len);\n        ip_len = c - ipport;\n        c++;\n        port_len = ipport_len - (c - ipport);\n\n        /* resolve hostname */\n        free(query->cur_host);\n        query->cur_host = strndup(ipport, ip_len);\n        tmp = strndup(c, port_len);\n        query->cur_port = atoi(tmp);\n        free(tmp);\n        query->cur_prio = res->prio;\n        query->cur_weight = res->weight;\n        query->cur_expiry = res->expiry;\n        log_debug(ZONE, \"dns ttl for %s@%p limited to %d\", query->name, query, query->cur_expiry);\n\n        if (query->s2s->resolve_aaaa) {\n            log_debug(ZONE, \"dns request for %s@%p: AAAA %s\", query->name, query, query->cur_host);\n\n            query->query = dns_submit_a6(NULL, query->cur_host, DNS_NOSRCH, _dns_result_aaaa, query);\n\n            /* if submit failed, call ourselves with a NULL result */\n            if (query->query == NULL)\n                _dns_result_aaaa(ctx, NULL, query);\n        } else {\n            log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->cur_host);\n\n            query->query = dns_submit_a4(NULL, query->cur_host, DNS_NOSRCH, _dns_result_a, query);\n\n            /* if submit failed, call ourselves with a NULL result */\n            if (query->query == NULL)\n                _dns_result_a(ctx, NULL, query);\n        }\n\n    /* finished */\n    } else {\n        time_t now = time(NULL);\n        char *domain;\n\n        free(query->cur_host);\n        query->cur_host = NULL;\n\n        log_debug(ZONE, \"dns requests for %s@%p complete: %d (%d)\", query->name,\n            query, xhash_count(query->results), query->expiry);\n\n        /* update query TTL */\n        if (query->expiry > query->s2s->dns_max_ttl)\n            query->expiry = query->s2s->dns_max_ttl;\n\n        if (query->expiry < query->s2s->dns_min_ttl)\n            query->expiry = query->s2s->dns_min_ttl;\n\n        query->expiry += now;\n\n        /* update result TTLs - the query expiry MUST NOT be longer than all result expiries */\n        if (xhash_iter_first(query->results)) {\n            union xhashv xhv;\n            dnsres_t res;\n\n            xhv.dnsres_val = &res;\n\n            do {\n                xhash_iter_get(query->results, NULL, NULL, xhv.val);\n\n                if (res->expiry > query->s2s->dns_max_ttl)\n                    res->expiry = query->s2s->dns_max_ttl;\n\n                if (res->expiry < query->s2s->dns_min_ttl)\n                    res->expiry = query->s2s->dns_min_ttl;\n\n                res->expiry += now;\n            } while(xhash_iter_next(query->results));\n        }\n\n        xhash_free(query->hosts);\n        query->hosts = NULL;\n        if (idna_to_unicode_8z8z(query->name, &domain, 0) != IDNA_SUCCESS) {\n            log_write(query->s2s->log, LOG_ERR, \"idna dns decode for %s failed\", query->name);\n            /* fake empty results to shortcut resolution failure */\n            xhash_free(query->results);\n            query->results = xhash_new(71);\n            query->expiry = time(NULL) + 99999999;\n            domain = strdup(query->name);\n        }\n        out_resolve(query->s2s, domain, query->results, query->expiry);\n        free(domain);\n        free(query->name);\n        free(query);\n    }\n}\n\nvoid dns_resolve_domain(s2s_t s2s, dnscache_t dns) {\n    dnsquery_t query = (dnsquery_t) calloc(1, sizeof(struct dnsquery_st));\n\n    query->s2s = s2s;\n    query->results = xhash_new(71);\n    if (idna_to_ascii_8z(dns->name, &query->name, 0) != IDNA_SUCCESS) {\n        log_write(s2s->log, LOG_ERR, \"idna dns encode for %s failed\", dns->name);\n        /* shortcut resolution failure */\n        query->expiry = time(NULL) + 99999999;\n        out_resolve(query->s2s, dns->name, query->results, query->expiry);\n        return;\n    }\n    query->hosts = xhash_new(71);\n    query->srv_i = -1;\n    query->expiry = 0;\n    query->cur_host = NULL;\n    query->cur_port = 0;\n    query->cur_expiry = 0;\n    query->query = NULL;\n    dns->query = query;\n\n    log_debug(ZONE, \"dns resolve for %s@%p started\", query->name, query);\n\n    /* - resolve all SRV records to host/port\n     * - if no results, include domain/5269\n     * - resolve all host/port combinations\n     * - return result\n     */\n    _dns_result_srv(NULL, NULL, query);\n}\n\n/** responses from the resolver */\nvoid out_resolve(s2s_t s2s, char *domain, xht results, time_t expiry) {\n    dnscache_t dns;\n\n    /* no results, resolve failed */\n    if(xhash_count(results) == 0) {\n        dns = xhash_get(s2s->dnscache, domain);\n        if (dns != NULL) {\n            /* store negative DNS cache */\n            xhash_free(dns->results);\n            dns->query = NULL;\n            dns->results = NULL;\n            dns->expiry = expiry;\n            dns->pending = 0;\n        }\n\n        log_write(s2s->log, LOG_NOTICE, \"dns lookup for %s failed\", domain);\n\n        /* bounce queue */\n        out_bounce_domain_queues(s2s, domain, stanza_err_REMOTE_SERVER_NOT_FOUND);\n\n        xhash_free(results);\n        return;\n    }\n\n    log_write(s2s->log, LOG_NOTICE, \"dns lookup for %s returned %d result%s (ttl %d)\",\n        domain, xhash_count(results), xhash_count(results)!=1?\"s\":\"\", expiry - time(NULL));\n\n    /* get the cache entry */\n    dns = xhash_get(s2s->dnscache, domain);\n\n    if(dns == NULL) {\n        /* retry using punycode */\n        char *punydomain;\n        if (idna_to_ascii_8z(domain, &punydomain, 0) == IDNA_SUCCESS) {\n            dns = xhash_get(s2s->dnscache, punydomain);\n            free(punydomain);\n        }\n    }\n\n    if(dns == NULL) {\n        log_write(s2s->log, LOG_ERR, \"weird, never requested %s resolution\", domain);\n        return;\n    }\n\n    /* fill it out */\n    xhash_free(dns->results);\n    dns->query = NULL;\n    dns->results = results;\n    dns->expiry = expiry;\n    dns->pending = 0;\n\n    out_flush_domain_queues(s2s, domain);\n\n    /* delete the cache entry if caching is disabled */\n    if (!s2s->dns_cache_enabled && !dns->pending) {\n        xhash_free(dns->results);\n        xhash_zap(s2s->dnscache, domain);\n        free(dns);\n    }\n}\n\n/** mio callback for outgoing conns */\nstatic int _out_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void *arg) {\n    conn_t out = (conn_t) arg;\n    char ipport[INET6_ADDRSTRLEN + 17];\n    int nbytes;\n\n    switch(a) {\n        case action_READ:\n            log_debug(ZONE, \"read action on fd %d\", fd->fd);\n\n            /* they did something */\n            out->last_activity = time(NULL);\n\n            ioctl(fd->fd, FIONREAD, &nbytes);\n            if(nbytes == 0) {\n                sx_kill(out->s);\n                return 0;\n            }\n\n            return sx_can_read(out->s);\n\n        case action_WRITE:\n            log_debug(ZONE, \"write action on fd %d\", fd->fd);\n\n            /* update activity timestamp */\n            out->last_activity = time(NULL);\n\n            return sx_can_write(out->s);\n\n        case action_CLOSE:\n            log_debug(ZONE, \"close action on fd %d\", fd->fd);\n\n            jqueue_push(out->s2s->dead, (void *) out->s, 0);\n\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] disconnect, packets: %i\", fd->fd, out->ip, out->port, out->packet_count);\n\n\n            if (out->s2s->out_reuse) {\n                /* generate the ip/port pair */\n                snprintf(ipport, INET6_ADDRSTRLEN + 16, \"%s/%d\", out->ip, out->port);\n\n                xhash_zap(out->s2s->out_host, ipport);\n            }\n\n            if (xhash_iter_first(out->routes)) {\n                char *rkey;\n                int rkeylen;\n                char *c;\n                int c_len;\n\n                /* remove all the out_dest entries */\n                do {\n                    xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n                    c = memchr(rkey, '/', rkeylen);\n                    c++;\n                    c_len = rkeylen - (c - rkey);\n\n                    log_debug(ZONE, \"route '%.*s'\", rkeylen, rkey);\n                    if (xhash_getx(out->s2s->out_dest, c, c_len) != NULL) {\n                        log_debug(ZONE, \"removing dest entry for '%.*s'\", c_len, c);\n                        xhash_zapx(out->s2s->out_dest, c, c_len);\n                    }\n                } while(xhash_iter_next(out->routes));\n            }\n\n            if (xhash_iter_first(out->routes)) {\n                char *rkey;\n                int rkeylen;\n                jqueue_t q;\n                int npkt;\n\n                /* retry all the routes */\n                do {\n                    xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n\n                    q = xhash_getx(out->s2s->outq, rkey, rkeylen);\n                    if (out->s2s->retry_limit > 0 && q != NULL && jqueue_age(q) > out->s2s->retry_limit) {\n                        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] retry limit reached for '%.*s' queue\", fd->fd, out->ip, out->port, rkeylen, rkey);\n                        q = NULL;\n                    }\n\n                    if (q != NULL && (npkt = jqueue_size(q)) > 0 && xhash_get(out->states, rkey) != (void*) conn_INPROGRESS) {\n                        conn_t retry;\n\n                        log_debug(ZONE, \"retrying connection for '%.*s' queue\", rkeylen, rkey);\n                        if (!out_route(out->s2s, rkey, rkeylen, &retry, 0)) {\n                            log_debug(ZONE, \"retry successful\");\n\n                            if (retry != NULL) {\n                                /* flush queue */\n                                out_flush_route_queue(out->s2s, rkey, rkeylen);\n                            }\n                        } else {\n                            log_debug(ZONE, \"retry failed\");\n\n                            /* bounce queue */\n                            out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n                            _out_dns_mark_bad(out);\n                        }\n                    } else {\n                        /* bounce queue */\n                        out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_REMOTE_SERVER_TIMEOUT);\n                        _out_dns_mark_bad(out);\n                    }\n                } while(xhash_iter_next(out->routes));\n            }\n\n            jqueue_push(out->s2s->dead_conn, (void *) out, 0);\n\n        case action_ACCEPT:\n            break;\n    }\n\n    return 0;\n}\n\nvoid send_dialbacks(conn_t out)\n{\n  char *rkey;\n  int rkeylen;\n\n  if (out->s2s->dns_bad_timeout > 0) {\n      dnsres_t bad = xhash_get(out->s2s->dns_bad, out->key);\n\n      if (bad != NULL) {\n          log_debug(ZONE, \"removing bad host entry for '%s'\", out->key);\n          xhash_zap(out->s2s->dns_bad, out->key);\n          free(bad->key);\n          free(bad);\n      }\n  }\n\n  if (xhash_iter_first(out->routes)) {\n       log_debug(ZONE, \"sending dialback packets for %s\", out->key);\n       do {\n            xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n            _out_dialback(out, rkey, rkeylen);\n          } while(xhash_iter_next(out->routes));\n  }\n\n  return;\n}\n\nstatic int _out_sx_callback(sx_t s, sx_event_t e, void *data, void *arg) {\n    conn_t out = (conn_t) arg;\n    sx_buf_t buf = (sx_buf_t) data;\n    int len, ns, elem, starttls = 0;\n    sx_error_t *sxe;\n    nad_t nad;\n\n    switch(e) {\n        case event_WANT_READ:\n            log_debug(ZONE, \"want read\");\n            mio_read(out->s2s->mio, out->fd);\n            break;\n\n        case event_WANT_WRITE:\n            log_debug(ZONE, \"want write\");\n            mio_write(out->s2s->mio, out->fd);\n            break;\n\n        case event_READ:\n            log_debug(ZONE, \"reading from %d\", out->fd->fd);\n\n            /* do the read */\n            len = recv(out->fd->fd, buf->data, buf->len, 0);\n\n            if(len < 0) {\n                if(MIO_WOULDBLOCK) {\n                    buf->len = 0;\n                    return 0;\n                }\n\n                log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] read error: %s (%d)\", out->fd->fd, out->ip, out->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n                if (!out->online) {\n                    _out_dns_mark_bad(out);\n                }\n\n                sx_kill(s);\n\n                return -1;\n            }\n\n            else if(len == 0) {\n                /* they went away */\n                sx_kill(s);\n\n                return -1;\n            }\n\n            log_debug(ZONE, \"read %d bytes\", len);\n\n            buf->len = len;\n\n            return len;\n\n        case event_WRITE:\n            log_debug(ZONE, \"writing to %d\", out->fd->fd);\n\n            len = send(out->fd->fd, buf->data, buf->len, 0);\n            if(len >= 0) {\n                log_debug(ZONE, \"%d bytes written\", len);\n                return len;\n            }\n\n            if(MIO_WOULDBLOCK)\n                return 0;\n\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] write error: %s (%d)\", out->fd->fd, out->ip, out->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n            if (!out->online) {\n                _out_dns_mark_bad(out);\n            }\n\n            sx_kill(s);\n\n            return -1;\n\n        case event_ERROR:\n            sxe = (sx_error_t *) data;\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] error: %s (%s)\", out->fd->fd, out->ip, out->port, sxe->generic, sxe->specific);\n\n            /* mark as bad if we did not manage to connect or there is unrecoverable stream error */\n            if (!out->online ||\n                    (sxe->code == SX_ERR_STREAM &&\n                        (strstr(sxe->specific, \"host-gone\") ||        /* it's not there now */\n                         strstr(sxe->specific, \"host-unknown\") ||     /* they do not service the host */\n                         strstr(sxe->specific, \"not-authorized\") ||   /* they do not want us there */\n                         strstr(sxe->specific, \"see-other-host\") ||   /* we do not support redirections yet */\n                         strstr(sxe->specific, \"system-shutdown\") ||  /* they are going down */\n                         strstr(sxe->specific, \"policy-violation\") || /* they do not want us there */\n                         strstr(sxe->specific, \"remote-connection-failed\") ||  /* the required remote entity is gone */\n                         strstr(sxe->specific, \"unsupported-encoding\") ||      /* they do not like our encoding */\n                         strstr(sxe->specific, \"undefined-condition\") ||       /* something bad happend */\n                         strstr(sxe->specific, \"internal-server-error\") ||     /* that server is broken */\n                         strstr(sxe->specific, \"unsupported-version\")          /* they do not support our stream version */\n                        ))) {\n                _out_dns_mark_bad(out);\n            }\n\n            sx_kill(s);\n\n            return -1;\n\n        case event_OPEN:\n            log_debug(ZONE, \"OPEN event for %s\", out->key);\n            break;\n\n        case event_STREAM:\n            /* check stream version - NULl = pre-xmpp (some jabber1 servers) */\n            log_debug(ZONE, \"STREAM event for %s stream version is %s\", out->key, out->s->res_version);\n\n            /* first time, bring them online */\n            if(!out->online) {\n                log_debug(ZONE, \"outgoing conn to %s is online\", out->key);\n\n                /* if no stream version from either side, kick off dialback for each route, */\n                /* otherwise wait for stream features */\n                if (((out->s->res_version==NULL) || (out->s2s->sx_ssl == NULL)) && out->s2s->require_tls == 0) {\n                     log_debug(ZONE, \"no stream version, sending dialbacks for %s immediately\", out->key);\n                     out->online = 1;\n                     send_dialbacks(out);\n                } else\n                     log_debug(ZONE, \"outgoing conn to %s - waiting for STREAM features\", out->key);\n            }\n\n            break;\n\n        case event_PACKET:\n            /* we're counting packets */\n            out->packet_count++;\n            out->s2s->packet_count++;\n\n            nad = (nad_t) data;\n\n            /* watch for the features packet - STARTTLS and/or SASL*/\n            if ((out->s->res_version!=NULL)\n                 && NAD_NURI_L(nad, NAD_ENS(nad, 0)) == strlen(uri_STREAMS)\n                 && strncmp(uri_STREAMS, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_STREAMS)) == 0\n                 && NAD_ENAME_L(nad, 0) == 8 && strncmp(\"features\", NAD_ENAME(nad, 0), 8) == 0) {\n                log_debug(ZONE, \"got the stream features packet\");\n\n#ifdef HAVE_SSL\n                /* starttls if we can */\n                if(out->s2s->sx_ssl != NULL && s->ssf == 0) {\n                    ns = nad_find_scoped_namespace(nad, uri_TLS, NULL);\n                    if(ns >= 0) {\n                        elem = nad_find_elem(nad, 0, ns, \"starttls\", 1);\n                        if(elem >= 0) {\n                            log_debug(ZONE, \"got STARTTLS in stream features\");\n                            if(sx_ssl_client_starttls(out->s2s->sx_ssl, s, out->s2s->local_pemfile) == 0) {\n                                starttls = 1;\n                                nad_free(nad);\n                                return 0;\n                            }\n                            log_write(out->s2s->log, LOG_ERR, \"unable to establish encrypted session with peer\");\n                        }\n                    }\n                }\n\n                /* If we're not establishing a starttls connection, send dialbacks */\n                if (!starttls) {\n                    if (out->s2s->require_tls == 0 || s->ssf > 0) {\n                     log_debug(ZONE, \"No STARTTLS, sending dialbacks for %s\", out->key);\n                     out->online = 1;\n                     send_dialbacks(out);\n                    } else {\n                        log_debug(ZONE, \"No STARTTLS, dialbacks disabled for non-TLS connections, cannot complete negotiation\");\n                    }\n                }\n#else\n                if (out->s2s->require_tls == 0) {\n                out->online = 1;\n                send_dialbacks(out);\n                }\n#endif\n            }\n\n\n            /* we only accept dialback packets */\n            if(NAD_ENS(nad, 0) < 0 || NAD_NURI_L(nad, NAD_ENS(nad, 0)) != uri_DIALBACK_L || strncmp(uri_DIALBACK, NAD_NURI(nad, NAD_ENS(nad, 0)), uri_DIALBACK_L) != 0) {\n                log_debug(ZONE, \"got a non-dialback packet on an outgoing conn, dropping it\");\n                nad_free(nad);\n                return 0;\n            }\n\n            /* and then only result and verify */\n            if(NAD_ENAME_L(nad, 0) == 6) {\n                if(strncmp(\"result\", NAD_ENAME(nad, 0), 6) == 0) {\n                    _out_result(out, nad);\n                    return 0;\n                }\n\n                if(strncmp(\"verify\", NAD_ENAME(nad, 0), 6) == 0) {\n                    _out_verify(out, nad);\n                    return 0;\n                }\n            }\n\n            log_debug(ZONE, \"unknown dialback packet, dropping it\");\n\n            nad_free(nad);\n            return 0;\n\n        case event_CLOSED:\n            if (out->fd != NULL) {\n            mio_close(out->s2s->mio, out->fd);\n                out->fd = NULL;\n            }\n            return -1;\n    }\n\n    return 0;\n}\n\n/** process incoming auth responses */\nstatic void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}\n\n/** incoming stream authenticated */\nstatic void _out_verify(conn_t out, nad_t nad) {\n    int attr, ns;\n    jid_t from, to;\n    conn_t in;\n    char *rkey;\n    int valid;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db verify packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db verify packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"id\", NULL);\n    if(attr < 0) {\n        log_debug(ZONE, \"missing id on db verify packet\");\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    /* get the incoming conn */\n    in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));\n    if(in == NULL) {\n        log_debug(ZONE, \"got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n\n    attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");\n    if(attr >= 0) {\n        xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        valid = 1;\n    } else {\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now invalid\", in->fd->fd, in->ip, in->port, rkey);\n        valid = 0;\n    }\n\n    free(rkey);\n\n    nad_free(nad);\n\n    /* decrement outstanding verify counter */\n    --out->verify;\n\n    /* let them know what happened */\n    nad = nad_new();\n\n    ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");\n    nad_append_elem(nad, ns, \"result\", 0);\n    nad_append_attr(nad, -1, \"to\", from->domain);\n    nad_append_attr(nad, -1, \"from\", to->domain);\n    nad_append_attr(nad, -1, \"type\", valid ? \"valid\" : \"invalid\");\n\n    /* off it goes */\n    sx_nad_write(in->s, nad);\n\n    /* if invalid, close the stream */\n    if (!valid) {\n        /* generate stream error */\n        sx_error(in->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n        /* close the incoming stream */\n        sx_close(in->s);\n    }\n\n    jid_free(from);\n    jid_free(to);\n}\n\n/* bounce all packets in the queues for domain */\nint out_bounce_domain_queues(s2s_t s2s, const char *domain, int err)\n{\n  char *rkey;\n  int rkeylen;\n  int pktcount = 0;\n\n  if (xhash_iter_first(s2s->outq)) {\n      do {\n          xhash_iter_get(s2s->outq, (const char **) &rkey, &rkeylen, NULL);\n          if(s2s_route_key_match(NULL, (char *) domain, rkey, rkeylen))\n              pktcount += out_bounce_route_queue(s2s, rkey, rkeylen, err);\n      } while(xhash_iter_next(s2s->outq));\n  }\n\n  return pktcount;\n}\n\n/* bounce all packets in the queue for route */\nint out_bounce_route_queue(s2s_t s2s, char *rkey, int rkeylen, int err)\n{\n  jqueue_t q;\n  pkt_t pkt;\n  int pktcount = 0;\n\n  q = xhash_getx(s2s->outq, rkey, rkeylen);\n  if(q == NULL)\n     return 0;\n\n  while((pkt = jqueue_pull(q)) != NULL) {\n     /* only packets with content, in namespace jabber:client and not already errors */\n     if(pkt->nad->ecur > 1 && NAD_NURI_L(pkt->nad, NAD_ENS(pkt->nad, 1)) == strlen(uri_CLIENT) && strncmp(NAD_NURI(pkt->nad, NAD_ENS(pkt->nad, 1)), uri_CLIENT, strlen(uri_CLIENT)) == 0 && nad_find_attr(pkt->nad, 0, -1, \"error\", NULL) < 0) {\n         sx_nad_write(s2s->router, stanza_tofrom(stanza_tofrom(stanza_error(pkt->nad, 1, err), 1), 0));\n         pktcount++;\n     }\n     else\n         nad_free(pkt->nad);\n\n     jid_free(pkt->to);\n     jid_free(pkt->from);\n     free(pkt);\n  }\n\n  /* delete queue and remove domain from queue hash */\n  log_debug(ZONE, \"deleting out packet queue for %.*s\", rkeylen, rkey);\n  rkey = q->key;\n  jqueue_free(q);\n  xhash_zap(s2s->outq, rkey);\n  free(rkey);\n\n  return pktcount;\n}\n\nint out_bounce_conn_queues(conn_t out, int err)\n{\n  char *rkey;\n  int rkeylen;\n  int pktcount = 0;\n\n  /* bounce queues for all domains handled by this connection - iterate through routes */\n  if (xhash_iter_first(out->routes)) {\n      do {\n          xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n          pktcount += out_bounce_route_queue(out->s2s, rkey, rkeylen, err);\n      } while(xhash_iter_next(out->routes));\n  }\n\n  return pktcount;\n}\n\nvoid out_flush_domain_queues(s2s_t s2s, const char *domain) {\n  char *rkey;\n  int rkeylen;\n  char *c;\n  int c_len;\n\n  if (xhash_iter_first(s2s->outq)) {\n      do {\n          xhash_iter_get(s2s->outq, (const char **) &rkey, &rkeylen, NULL);\n          c = memchr(rkey, '/', rkeylen);\n          c++;\n          c_len = rkeylen - (c - rkey);\n          if (strncmp(domain, c, c_len) == 0)\n              out_flush_route_queue(s2s, rkey, rkeylen);\n      } while(xhash_iter_next(s2s->outq));\n  }\n}\n\nvoid out_flush_route_queue(s2s_t s2s, char *rkey, int rkeylen) {\n    jqueue_t q;\n    pkt_t pkt;\n    int npkt, i, ret;\n\n    q = xhash_getx(s2s->outq, rkey, rkeylen);\n    if(q == NULL)\n        return;\n\n    npkt = jqueue_size(q);\n    log_debug(ZONE, \"flushing %d packets for '%.*s' to out_packet\", npkt, rkeylen, rkey);\n\n    for(i = 0; i < npkt; i++) {\n        pkt = jqueue_pull(q);\n        if(pkt) {\n            ret = out_packet(s2s, pkt);\n            if (ret) {\n                /* uh-oh. the queue was deleted...\n                   q and pkt have been freed\n                   if q->key == rkey, rkey has also been freed */\n                return;\n            }\n        }\n    }\n\n    /* delete queue for route and remove route from queue hash */\n    if (jqueue_size(q) == 0) {\n        log_debug(ZONE, \"deleting out packet queue for '%.*s'\", rkeylen, rkey);\n        rkey = q->key;\n        jqueue_free(q);\n        xhash_zap(s2s->outq, rkey);\n        free(rkey);\n    } else {\n        log_debug(ZONE, \"emptied queue gained more packets...\");\n    }\n}\n"], "fixing_code": ["/*\n * jabberd - Jabber Open Source Server\n * Copyright (c) 2002 Jeremie Miller, Thomas Muldowney,\n *                    Ryan Eatmon, Robert Norris\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n */\n\n#define _GNU_SOURCE\n#include <string.h>\n\n#include \"s2s.h\"\n\n#include <idna.h>\n\n/*\n * we handle packets going from the router to the world, and stuff\n * that comes in on connections we initiated.\n *\n * action points:\n *\n *   out_packet(s2s, nad) - send this packet out\n *     - extract to domain\n *     - get dbconn for this domain using out_route\n *       - if dbconn not available bounce packet\n *       - DONE\n *     - if conn in progress (tcp)\n *       - add packet to queue for this domain\n *       - DONE\n *     - if dbconn state valid for this domain, or packet is dialback\n *       - send packet\n *       - DONE\n *     - if dbconn state invalid for this domain\n *       - bounce packet (502)\n *       - DONE\n *     - add packet to queue for this domain\n *     - if dbconn state inprogress for this domain\n *       - DONE\n *     - out_dialback(dbconn, from, to)\n *\n *   out_route(s2s, route, out, allow_bad)\n *     - if dbconn not found\n *       - check internal resolver cache for domain\n *       - if not found\n *         - ask resolver for name\n *         - DONE\n *       - if outgoing ip/port is to be reused\n *         - get dbconn for any valid ip/port\n *         - if dbconn not found\n *            - create new dbconn\n *            - initiate connect to ip/port\n *            - DONE\n *       - create new dbconn\n *       - initiate connect to ip/port\n *       - DONE\n *\n *   out_dialback(dbconn, from, to) - initiate dialback\n *     - generate dbkey: sha1(secret+remote+stream id)\n *     - send auth request: <result to='them' from='us'>dbkey</result>\n *     - set dbconn state for this domain to inprogress\n *     - DONE\n *\n *   out_resolve(s2s, query) - responses from resolver\n *     - store ip/port/ttl in resolver cache\n *     - flush domain queue -> out_packet(s2s, domain)\n *     - DONE\n *\n *   event_STREAM - ip/port open\n *     - get dbconn for this sx\n *     - for each route handled by this conn, out_dialback(dbconn, from, to)\n *     - DONE\n *\n *   event_PACKET: <result from='them' to='us' type='xxx'/> - response to our auth request\n *     - get dbconn for this sx\n *     - if type valid\n *       - set dbconn state for this domain to valid\n *       - flush dbconn queue for this domain -> out_packet(s2s, pkt)\n *       - DONE\n *     - set dbconn state for this domain to invalid\n *     - bounce dbconn queue for this domain (502)\n *     - DONE\n *\n *   event_PACKET: <verify from='them' to='us' id='123' type='xxx'/> - incoming stream authenticated\n *     - get dbconn for given id\n *     - if type is valid\n *       - set dbconn state for this domain to valid\n *     - send result: <result to='them' from='us' type='xxx'/>\n *     - DONE\n */\n\n/* forward decls */\nstatic int _out_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void *arg);\nstatic int _out_sx_callback(sx_t s, sx_event_t e, void *data, void *arg);\nstatic void _out_result(conn_t out, nad_t nad);\nstatic void _out_verify(conn_t out, nad_t nad);\nstatic void _dns_result_aaaa(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data);\nstatic void _dns_result_a(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data);\n\n/** queue the packet */\nstatic void _out_packet_queue(s2s_t s2s, pkt_t pkt) {\n    char *rkey = s2s_route_key(NULL, pkt->from->domain, pkt->to->domain);\n    jqueue_t q = (jqueue_t) xhash_get(s2s->outq, rkey);\n\n    if(q == NULL) {\n        log_debug(ZONE, \"creating new out packet queue for '%s'\", rkey);\n        q = jqueue_new();\n        q->key = rkey;\n        xhash_put(s2s->outq, q->key, (void *) q);\n    } else {\n        free(rkey);\n    }\n\n    log_debug(ZONE, \"queueing packet for '%s'\", q->key);\n\n    jqueue_push(q, (void *) pkt, 0);\n}\n\nstatic void _out_dialback(conn_t out, char *rkey, int rkeylen) {\n    char *c, *dbkey, *tmp;\n    nad_t nad;\n    int elem, ns;\n    int from_len, to_len;\n    time_t now;\n\n    now = time(NULL);\n\n    c = memchr(rkey, '/', rkeylen);\n    from_len = c - rkey;\n    c++;\n    to_len = rkeylen - (c - rkey);\n\n    /* kick off the dialback */\n    tmp = strndup(c, to_len);\n    dbkey = s2s_db_key(NULL, out->s2s->local_secret, tmp, out->s->id);\n    free(tmp);\n\n    nad = nad_new();\n\n    /* request auth */\n    ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");\n    elem = nad_append_elem(nad, ns, \"result\", 0);\n    nad_set_attr(nad, elem, -1, \"from\", rkey, from_len);\n    nad_set_attr(nad, elem, -1, \"to\", c, to_len);\n    nad_append_cdata(nad, dbkey, strlen(dbkey), 1);\n\n    log_debug(ZONE, \"sending auth request for %.*s (key %s)\", rkeylen, rkey, dbkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] sending dialback auth request for route '%.*s'\", out->fd->fd, out->ip, out->port, rkeylen, rkey);\n\n    /* off it goes */\n    sx_nad_write(out->s, nad);\n\n    free(dbkey);\n\n    /* we're in progress now */\n    xhash_put(out->states, pstrdupx(xhash_pool(out->states), rkey, rkeylen), (void *) conn_INPROGRESS);\n\n    /* record the time that we set conn_INPROGRESS state */\n    xhash_put(out->states_time, pstrdupx(xhash_pool(out->states_time), rkey, rkeylen), (void *) now);\n}\n\nvoid _out_dns_mark_bad(conn_t out) {\n    if (out->s2s->dns_bad_timeout > 0) {\n        dnsres_t bad;\n        char *ipport;\n\n        /* mark this host as bad */\n        ipport = dns_make_ipport(out->ip, out->port);\n        bad = xhash_get(out->s2s->dns_bad, ipport);\n        if (bad == NULL) {\n            bad = (dnsres_t) calloc(1, sizeof(struct dnsres_st));\n            bad->key = ipport;\n            xhash_put(out->s2s->dns_bad, ipport, bad);\n        }\n        bad->expiry = time(NULL) + out->s2s->dns_bad_timeout;\n    }\n}\n\nint dns_select(s2s_t s2s, char *ip, int *port, time_t now, dnscache_t dns, int allow_bad) {\n    /* list of results */\n    dnsres_t l_reuse[DNS_MAX_RESULTS];\n    dnsres_t l_aaaa[DNS_MAX_RESULTS];\n    dnsres_t l_a[DNS_MAX_RESULTS];\n    dnsres_t l_bad[DNS_MAX_RESULTS];\n    /* running weight sums of results */\n    int rw_reuse[DNS_MAX_RESULTS];\n    int rw_aaaa[DNS_MAX_RESULTS];\n    int rw_a[DNS_MAX_RESULTS];\n    int s_reuse = 0, s_aaaa = 0, s_a = 0, s_bad = 0; /* count */\n    int p_reuse = 0, p_aaaa = 0, p_a = 0; /* list prio */\n    int wt_reuse = 0, wt_aaaa = 0, wt_a = 0; /* weight total */\n    int c_expired_good = 0;\n    union xhashv xhv;\n    dnsres_t res;\n    char *ipport;\n    int ipport_len;\n    char *c;\n    int c_len;\n    char *tmp;\n\n    /* for all results:\n     * - if not expired\n     *   - put highest priority reuseable addrs into list1\n     *   - put highest priority ipv6 addrs into list2\n     *   - put highest priority ipv4 addrs into list3\n     *   - put bad addrs into list4\n     * - pick weighted random entry from first non-empty list\n     */\n\n    if (dns->results == NULL) {\n        log_debug(ZONE, \"negative cache entry for '%s'\", dns->name);\n        return -1;\n    }\n    log_debug(ZONE, \"selecting DNS result for '%s'\", dns->name);\n\n    xhv.dnsres_val = &res;\n    if (xhash_iter_first(dns->results)) {\n        dnsres_t bad = NULL;\n        do {\n            xhash_iter_get(dns->results, (const char **) &ipport, &ipport_len, xhv.val);\n\n            if (s2s->dns_bad_timeout > 0)\n                bad = xhash_getx(s2s->dns_bad, ipport, ipport_len);\n\n            if (now > res->expiry) {\n                /* good host? */\n                if (bad == NULL)\n                    c_expired_good++;\n\n                log_debug(ZONE, \"host '%s' expired\", res->key);\n                continue;\n            } else if (bad != NULL && !(now > bad->expiry)) {\n                /* bad host (connection failure) */\n                l_bad[s_bad++] = res;\n\n                log_debug(ZONE, \"host '%s' bad\", res->key);\n            } else if (s2s->out_reuse && xhash_getx(s2s->out_host, ipport, ipport_len) != NULL) {\n                /* existing connection */\n                log_debug(ZONE, \"host '%s' exists\", res->key);\n                if (s_reuse == 0 || p_reuse > res->prio) {\n                    p_reuse = res->prio;\n                    s_reuse = 0;\n                    wt_reuse = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_reuse) {\n                    l_reuse[s_reuse] = res;\n                    wt_reuse += res->weight;\n                    rw_reuse[s_reuse] = wt_reuse;\n                    s_reuse++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_reuse);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            } else if (memchr(ipport, ':', ipport_len) != NULL) {\n                /* ipv6 */\n                log_debug(ZONE, \"host '%s' IPv6\", res->key);\n                if (s_aaaa == 0 || p_aaaa > res->prio) {\n                    p_aaaa = res->prio;\n                    s_aaaa = 0;\n                    wt_aaaa = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_aaaa) {\n                    l_aaaa[s_aaaa] = res;\n                    wt_aaaa += res->weight;\n                    rw_aaaa[s_aaaa] = wt_aaaa;\n                    s_aaaa++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_aaaa);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            } else {\n                /* ipv4 */\n                log_debug(ZONE, \"host '%s' IPv4\", res->key);\n                if (s_a == 0 || p_a > res->prio) {\n                    p_a = res->prio;\n                    s_a = 0;\n                    wt_a = 0;\n\n                    log_debug(ZONE, \"reset prio list, using prio %d\", res->prio);\n                }\n                if (res->prio <= p_a) {\n                    l_a[s_a] = res;\n                    wt_a += res->weight;\n                    rw_a[s_a] = wt_a;\n                    s_a++;\n\n                    log_debug(ZONE, \"added host with weight %d (%d), running weight %d\",\n                        (res->weight >> 8), res->weight, wt_a);\n                } else {\n                    log_debug(ZONE, \"ignored host with prio %d\", res->prio);\n                }\n            }\n        } while(xhash_iter_next(dns->results));\n    }\n\n    /* pick a result at weighted random (RFC 2782)\n     * all weights are guaranteed to be >= 16 && <= 16776960\n     * (assuming max 50 hosts, the total/running sums won't exceed 2^31)\n     */\n    ipport = NULL;\n    if (s_reuse > 0) {\n        int i, r;\n\n        log_debug(ZONE, \"using existing hosts, total weight %d\", wt_reuse);\n        assert((wt_reuse + 1) > 0);\n\n        r = rand() % (wt_reuse + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_reuse; i++)\n            if (rw_reuse[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_reuse[i]->key, rw_reuse[i]);\n\n                ipport = l_reuse[i]->key;\n                break;\n            }\n    } else if (s_aaaa > 0 && (s_a == 0 || p_aaaa <= p_a)) {\n        int i, r;\n\n        log_debug(ZONE, \"using IPv6 hosts, total weight %d\", wt_aaaa);\n        assert((wt_aaaa + 1) > 0);\n\n        r = rand() % (wt_aaaa + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_aaaa; i++)\n            if (rw_aaaa[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_aaaa[i]->key, rw_aaaa[i]);\n\n                ipport = l_aaaa[i]->key;\n                break;\n            }\n    } else if (s_a > 0) {\n        int i, r;\n\n        log_debug(ZONE, \"using IPv4 hosts, total weight %d\", wt_a);\n        assert((wt_a + 1) > 0);\n\n        r = rand() % (wt_a + 1);\n        log_debug(ZONE, \"random number %d\", r);\n\n        for (i = 0; i < s_a; i++)\n            if (rw_a[i] >= r) {\n                log_debug(ZONE, \"selected host '%s', running weight %d\",\n                    l_a[i]->key, rw_a[i]);\n\n                ipport = l_a[i]->key;\n                break;\n            }\n    } else if (s_bad > 0) {\n        ipport = l_bad[rand() % s_bad]->key;\n\n        log_debug(ZONE, \"using bad hosts, allow_bad=%d\", allow_bad);\n\n        /* there are expired good hosts, expire cache immediately */\n        if (c_expired_good > 0) {\n            log_debug(ZONE, \"expiring this DNS cache entry, %d expired hosts\",\n                c_expired_good);\n\n            dns->expiry = 0;\n        }\n\n        if (!allow_bad)\n            return -1;\n    }\n\n    /* results cannot all expire before the collection does */\n    assert(ipport != NULL);\n\n    /* copy the ip and port to the packet */\n    ipport_len = strlen(ipport);\n    c = strchr(ipport, '/');\n    strncpy(ip, ipport, c-ipport);\n    ip[c-ipport] = '\\0';\n    c++;\n    c_len = ipport_len - (c - ipport);\n    tmp = strndup(c, c_len);\n    *port = atoi(tmp);\n    free(tmp);\n\n    return 0;\n}\n\n/** find/make a connection for a route */\nint out_route(s2s_t s2s, char *route, int routelen, conn_t *out, int allow_bad) {\n    dnscache_t dns;\n    char ipport[INET6_ADDRSTRLEN + 16], *dkey, *c;\n    time_t now;\n    int reuse = 0;\n    char ip[INET6_ADDRSTRLEN] = {0};\n    int port, c_len, from_len;\n\n    c = memchr(route, '/', routelen);\n    from_len = c - route;\n    c++;\n    c_len = routelen - (c - route);\n    dkey = strndup(c, c_len);\n\n    log_debug(ZONE, \"trying to find connection for '%s'\", dkey);\n    *out = (conn_t) xhash_get(s2s->out_dest, dkey);\n    if(*out == NULL) {\n        log_debug(ZONE, \"connection for '%s' not found\", dkey);\n\n        /* check resolver cache for ip/port */\n        dns = xhash_get(s2s->dnscache, dkey);\n        if(dns == NULL) {\n            /* new resolution */\n            log_debug(ZONE, \"no dns for %s, preparing for resolution\", dkey);\n\n            dns = (dnscache_t) calloc(1, sizeof(struct dnscache_st));\n\n            strcpy(dns->name, dkey);\n\n            xhash_put(s2s->dnscache, dns->name, (void *) dns);\n\n#if 0\n            /* this is good for testing */\n            dns->pending = 0;\n            strcpy(dns->ip, \"127.0.0.1\");\n            dns->port = 3000;\n            dns->expiry = time(NULL) + 99999999;\n#endif\n        }\n\n        /* resolution in progress */\n        if(dns->pending) {\n            log_debug(ZONE, \"pending resolution\");\n            free(dkey);\n            return 0;\n        }\n\n        /* has it expired (this is 0 for new cache objects, so they're always expired */\n        now = time(NULL); /* each entry must be expired no earlier than the collection */\n        if(now > dns->expiry) {\n            /* resolution required */\n            log_debug(ZONE, \"requesting resolution for %s\", dkey);\n\n            dns->init_time = time(NULL);\n            dns->pending = 1;\n\n            dns_resolve_domain(s2s, dns);\n            free(dkey);\n            return 0;\n        }\n\n        /* dns is valid */\n        if (dns_select(s2s, ip, &port, now, dns, allow_bad)) {\n            /* failed to find anything acceptable */\n            free(dkey);\n            return -1;\n        }\n\n        /* re-request resolution if dns_select expired the data */\n        if (now > dns->expiry) {\n            /* resolution required */\n            log_debug(ZONE, \"requesting resolution for %s\", dkey);\n\n            dns->init_time = time(NULL);\n            dns->pending = 1;\n\n            dns_resolve_domain(s2s, dns);\n\n            free(dkey);\n            return 0;\n        }\n\n        /* generate the ip/port pair, this is the hash key for the conn */\n        snprintf(ipport, INET6_ADDRSTRLEN + 16, \"%s/%d\", ip, port);\n\n        /* try to re-use an existing connection */\n        if (s2s->out_reuse)\n            *out = (conn_t) xhash_get(s2s->out_host, ipport);\n\n        if (*out != NULL) {\n            log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] using connection for '%s'\", (*out)->fd->fd, (*out)->ip, (*out)->port, dkey);\n\n            /* associate existing connection with domain */\n            xhash_put(s2s->out_dest, s2s->out_reuse ? pstrdup(xhash_pool((*out)->routes), dkey) : dkey, (void *) *out);\n\n            reuse = 1;\n        } else{\n            /* no conn, create one */\n            *out = (conn_t) calloc(1, sizeof(struct conn_st));\n\n            (*out)->s2s = s2s;\n\n            (*out)->key = strdup(ipport);\n            if (s2s->out_reuse)\n                (*out)->dkey = NULL;\n            else\n                (*out)->dkey = dkey;\n\n            strcpy((*out)->ip, ip);\n            (*out)->port = port;\n\n            (*out)->states = xhash_new(101);\n            (*out)->states_time = xhash_new(101);\n\n            (*out)->routes = xhash_new(101);\n\n            (*out)->init_time = time(NULL);\n\n            if (s2s->out_reuse)\n                xhash_put(s2s->out_host, (*out)->key, (void *) *out);\n            xhash_put(s2s->out_dest, s2s->out_reuse ? pstrdup(xhash_pool((*out)->routes), dkey) : dkey, (void *) *out);\n\n            xhash_put((*out)->routes, pstrdupx(xhash_pool((*out)->routes), route, routelen), (void *) 1);\n\n            /* connect */\n            log_debug(ZONE, \"initiating connection to %s\", ipport);\n\n            /* APPLE: multiple origin_ips may be specified; use IPv6 if possible or otherwise IPv4 */\n            int ip_is_v6 = 0;\n            if (strchr(ip, ':') != NULL)\n                ip_is_v6 = 1;\n            int i;\n            for (i = 0; i < s2s->origin_nips; i++) {\n                // only bother with mio_connect if the src and dst IPs are of the same type\n                if ((ip_is_v6 && (strchr(s2s->origin_ips[i], ':') != NULL)) ||          // both are IPv6\n                            (! ip_is_v6 && (strchr(s2s->origin_ips[i], ':') == NULL)))  // both are IPv4\n                    (*out)->fd = mio_connect(s2s->mio, port, ip, s2s->origin_ips[i], _out_mio_callback, (void *) *out);\n\n                if ((*out)->fd != NULL) break;\n            }\n\n            if ((*out)->fd == NULL) {\n                log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] mio_connect error: %s (%d)\", -1, (*out)->ip, (*out)->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n                _out_dns_mark_bad(*out);\n\n                if (s2s->out_reuse)\n                   xhash_zap(s2s->out_host, (*out)->key);\n                xhash_zap(s2s->out_dest, dkey);\n\n                xhash_free((*out)->states);\n                xhash_free((*out)->states_time);\n\n                xhash_free((*out)->routes);\n\n                free((*out)->key);\n                free((*out)->dkey);\n                free(*out);\n                *out = NULL;\n\n                /* try again without allowing bad hosts */\n                return out_route(s2s, route, routelen, out, 0);\n            } else {\n                log_write(s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing connection for '%s'\", (*out)->fd->fd, (*out)->ip, (*out)->port, dkey);\n\n                (*out)->s = sx_new(s2s->sx_env, (*out)->fd->fd, _out_sx_callback, (void *) *out);\n\n#ifdef HAVE_SSL\n                /* Send a stream version of 1.0 if we can do STARTTLS */\n                if(s2s->sx_ssl != NULL) {\n                    sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, dkey, pstrdupx(xhash_pool((*out)->routes), route, from_len), \"1.0\");\n                } else {\n                    sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, NULL, NULL, NULL);\n                }\n#else\n                sx_client_init((*out)->s, S2S_DB_HEADER, uri_SERVER, NULL, NULL, NULL);\n#endif\n                /* dkey is now used by the hash table */\n                return 0;\n            }\n        }\n    } else {\n        log_debug(ZONE, \"connection for '%s' found (%d %s/%d)\", dkey, (*out)->fd->fd, (*out)->ip, (*out)->port);\n    }\n\n    /* connection in progress, or re-using connection: add to routes list */\n    if (!(*out)->online || reuse) {\n        if (xhash_getx((*out)->routes, route, routelen) == NULL)\n            xhash_put((*out)->routes, pstrdupx(xhash_pool((*out)->routes), route, routelen), (void *) 1);\n    }\n\n    free(dkey);\n    return 0;\n}\n\nvoid out_pkt_free(pkt_t pkt)\n{\n    nad_free(pkt->nad);\n    jid_free(pkt->from);\n    jid_free(pkt->to);\n    free(pkt);\n}\n\n/** send a packet out */\nint out_packet(s2s_t s2s, pkt_t pkt) {\n    char *rkey;\n    int rkeylen;\n    conn_t out;\n    conn_state_t state;\n    int ret;\n\n    /* perform check against whitelist */\n    if (s2s->enable_whitelist > 0 &&\n            (pkt->to->domain != NULL) &&\n            (s2s_domain_in_whitelist(s2s, pkt->to->domain) == 0)) {\n        log_write(s2s->log, LOG_NOTICE, \"sending a packet to domain not in the whitelist, dropping it\");\n        if (pkt->to != NULL)\n            jid_free(pkt->to);\n        if (pkt->from != NULL)\n            jid_free(pkt->from);\n        if (pkt->nad != NULL)\n            nad_free(pkt->nad);\n        free(pkt);\n\n        return;\n    }\n\n    /* new route key */\n    rkey = s2s_route_key(NULL, pkt->from->domain, pkt->to->domain);\n    rkeylen = strlen(rkey);\n\n    /* get a connection */\n    ret = out_route(s2s, rkey, rkeylen, &out, 1);\n\n    if (out == NULL) {\n        /* connection not available, queue packet */\n        _out_packet_queue(s2s, pkt);\n\n        /* check if out_route was successful in attempting a connection */\n        if (ret) {\n            /* bounce queue */\n            out_bounce_route_queue(s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n            free(rkey);\n            return -1;\n        }\n\n        free(rkey);\n        return 0;\n    }\n\n    /* connection in progress */\n    if(!out->online) {\n        log_debug(ZONE, \"connection in progress, queueing packet\");\n\n        _out_packet_queue(s2s, pkt);\n\n        free(rkey);\n        return 0;\n    }\n\n    /* connection state */\n    state = (conn_state_t) xhash_get(out->states, rkey);\n\n    /* valid conns or dialback packets */\n    if(state == conn_VALID || pkt->db) {\n        log_debug(ZONE, \"writing packet for %s to outgoing conn %d\", rkey, out->fd->fd);\n\n        /* send it straight out */\n        if(pkt->db) {\n            /* if this is a db:verify packet, increment counter and set timestamp */\n            if(NAD_ENAME_L(pkt->nad, 0) == 6 && strncmp(\"verify\", NAD_ENAME(pkt->nad, 0), 6) == 0) {\n                out->verify++;\n                out->last_verify = time(NULL);\n            }\n\n            /* dialback packet */\n            sx_nad_write(out->s, pkt->nad);\n        } else {\n            /* if the outgoing stanza has a jabber:client namespace, remove it so that the stream jabber:server namespaces will apply (XMPP 11.2.2) */\n            int ns = nad_find_namespace(pkt->nad, 1, uri_CLIENT, NULL);\n            if(ns >= 0) {\n               /* clear the namespaces of elem 0 (internal route element) and elem 1 (message|iq|presence) */\n               pkt->nad->elems[0].ns = -1;\n               pkt->nad->elems[0].my_ns = -1;\n               pkt->nad->elems[1].ns = -1;\n               pkt->nad->elems[1].my_ns = -1;\n            }\n\n            /* send it out */\n            sx_nad_write_elem(out->s, pkt->nad, 1);\n        }\n\n        /* update timestamp */\n        out->last_packet = time(NULL);\n\n        jid_free(pkt->from);\n        jid_free(pkt->to);\n        free(pkt);\n\n        free(rkey);\n        return 0;\n    }\n\n    /* can't be handled yet, queue */\n    _out_packet_queue(s2s, pkt);\n\n    /* if dialback is in progress, then we're done for now */\n    if(state == conn_INPROGRESS) {\n        free(rkey);\n        return 0;\n    }\n\n    /* this is a new route - send dialback auth request to piggyback on the existing connection */\n    if (out->s2s->require_tls == 0 || out->s->ssf > 0) {\n    _out_dialback(out, rkey, rkeylen);\n    }\n    free(rkey);\n    return 0;\n}\n\nchar *dns_make_ipport(char *host, int port) {\n    char *c;\n    assert(port > 0 && port < 65536);\n\n    c = (char *) malloc(strlen(host) + 7);\n    sprintf(c, \"%s/%d\", host, port);\n    return c;\n}\n\nstatic void _dns_add_result(dnsquery_t query, char *ip, int port, int prio, int weight, unsigned int ttl) {\n    char *ipport = dns_make_ipport(ip, port);\n    dnsres_t res = xhash_get(query->results, ipport);\n\n    if (res != NULL) {\n        if (prio < res->prio)\n            res->prio = prio;\n\n        if (prio < res->prio) {\n            /* duplicate host at lower prio - reset weight */\n            res->weight = weight;\n        } else if (prio == res->prio) {\n            /* duplicate host at same prio - add to weight */\n            res->weight += weight;\n            if (res->weight > (65535 << 8))\n                res->weight = (65535 << 8);\n        }\n\n        if (ttl > res->expiry)\n            res->expiry = ttl;\n\n        if (ttl > query->expiry)\n            query->expiry = ttl;\n\n        log_debug(ZONE, \"dns result updated for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else if (xhash_count(query->results) < DNS_MAX_RESULTS) {\n        res = pmalloc(xhash_pool(query->results), sizeof(struct dnsres_st));\n        res->key = pstrdup(xhash_pool(query->results), ipport);\n        res->prio = prio;\n        res->weight = weight;\n        res->expiry = ttl;\n\n        if (ttl > query->expiry)\n            query->expiry = ttl;\n\n        xhash_put(query->results, res->key, res);\n\n        log_debug(ZONE, \"dns result added for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else {\n        log_debug(ZONE, \"dns result ignored for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            prio, (weight >> 8), ttl);\n    }\n\n    free(ipport);\n}\n\nstatic void _dns_add_host(dnsquery_t query, char *ip, int port, int prio, int weight, unsigned int ttl) {\n    char *ipport = dns_make_ipport(ip, port);\n    dnsres_t res = xhash_get(query->hosts, ipport);\n\n    /* update host weights:\n     *  RFC 2482 \"In the presence of records containing weights greater\n     *  than 0, records with weight 0 should have a very small chance of\n     *  being selected.\"\n     * 0       -> 16\n     * 1-65535 -> 256-16776960\n     */\n    if (weight == 0)\n        weight = 1 << 4;\n    else\n        weight <<= 8;\n\n    if (res != NULL) {\n        if (prio < res->prio)\n            res->prio = prio;\n\n        if (prio < res->prio) {\n            /* duplicate host at lower prio - reset weight */\n            res->weight = weight;\n        } else if (prio == res->prio) {\n            /* duplicate host at same prio - add to weight */\n            res->weight += weight;\n            if (res->weight > (65535 << 8))\n                res->weight = (65535 << 8);\n        }\n\n        if (ttl > res->expiry)\n            res->expiry = ttl;\n\n        log_debug(ZONE, \"dns host updated for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else if (xhash_count(query->hosts) < DNS_MAX_RESULTS) {\n        res = pmalloc(xhash_pool(query->hosts), sizeof(struct dnsres_st));\n        res->key = pstrdup(xhash_pool(query->hosts), ipport);\n        res->prio = prio;\n        res->weight = weight;\n        res->expiry = ttl;\n\n        xhash_put(query->hosts, res->key, res);\n\n        log_debug(ZONE, \"dns host added for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            res->prio, (res->weight >> 8), res->expiry);\n    } else {\n        log_debug(ZONE, \"dns host ignored for %s@%p: %s (%d/%d/%d)\", query->name, query, ipport,\n            prio, (weight >> 8), ttl);\n    }\n\n    free(ipport);\n}\n\n/* this function is called with a NULL ctx to start the SRV process */\nstatic void _dns_result_srv(struct dns_ctx *ctx, struct dns_rr_srv *result, void *data) {\n    dnsquery_t query = data;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n        log_debug(ZONE, \"dns failure for %s@%p: SRV %s (%d)\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i], dns_status(ctx));\n    } else if (result != NULL) {\n        int i;\n\n        log_debug(ZONE, \"dns response for %s@%p: SRV %s %d (%d)\", query->name, query,\n            result->dnssrv_qname, result->dnssrv_nrr, result->dnssrv_ttl);\n\n        for (i = 0; i < result->dnssrv_nrr; i++) {\n            if (strlen(result->dnssrv_srv[i].name) > 0\n                    && result->dnssrv_srv[i].port > 0\n                    && result->dnssrv_srv[i].port < 65536) {\n                log_debug(ZONE, \"dns response for %s@%p: SRV %s[%d] %s/%d (%d/%d)\", query->name,\n                    query, result->dnssrv_qname, i,\n                    result->dnssrv_srv[i].name, result->dnssrv_srv[i].port,\n                    result->dnssrv_srv[i].priority, result->dnssrv_srv[i].weight);\n\n                _dns_add_host(query, result->dnssrv_srv[i].name,\n                    result->dnssrv_srv[i].port, result->dnssrv_srv[i].priority,\n                    result->dnssrv_srv[i].weight, result->dnssrv_ttl);\n            }\n        }\n\n        free(result);\n    }\n\n    /* check next SRV service name */\n    query->srv_i++;\n    if (query->srv_i < query->s2s->lookup_nsrv) {\n        log_debug(ZONE, \"dns request for %s@%p: SRV %s\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i]);\n\n        query->query = dns_submit_srv(NULL, query->name, query->s2s->lookup_srv[query->srv_i], \"tcp\",\n            DNS_NOSRCH, _dns_result_srv, query);\n\n        /* if submit failed, call ourselves with a NULL result */\n        if (query->query == NULL)\n            _dns_result_srv(ctx, NULL, query);\n    } else {\n        /* no more SRV records to check, resolve hosts */\n        if (xhash_count(query->hosts) > 0) {\n            _dns_result_a(NULL, NULL, query);\n\n        /* no SRV records returned, resolve hostname */\n        } else {\n            query->cur_host = strdup(query->name);\n            query->cur_port = 5269;\n            query->cur_prio = 0;\n            query->cur_weight = 0;\n            query->cur_expiry = 0;\n            if (query->s2s->resolve_aaaa) {\n                log_debug(ZONE, \"dns request for %s@%p: AAAA %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a6(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_aaaa, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_aaaa(ctx, NULL, query);\n            } else {\n                log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a4(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_a, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_a(ctx, NULL, query);\n            }\n        }\n    }\n}\n\nstatic void _dns_result_aaaa(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data) {\n    dnsquery_t query = data;\n    char ip[INET6_ADDRSTRLEN];\n    int i;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n        log_debug(ZONE, \"dns failure for %s@%p: AAAA %s (%d)\", query->name, query,\n            query->cur_host, dns_status(ctx));\n    } else if (result != NULL) {\n        log_debug(ZONE, \"dns response for %s@%p: AAAA %s %d (%d)\", query->name, query,\n            result->dnsa6_qname, result->dnsa6_nrr, result->dnsa6_ttl);\n\n        if (query->cur_expiry > 0 && result->dnsa6_ttl > query->cur_expiry)\n            result->dnsa6_ttl = query->cur_expiry;\n\n        for (i = 0; i < result->dnsa6_nrr; i++) {\n            if (inet_ntop(AF_INET6, &result->dnsa6_addr[i], ip, INET6_ADDRSTRLEN) != NULL) {\n                log_debug(ZONE, \"dns response for %s@%p: AAAA %s[%d] %s/%d\", query->name,\n                    query, result->dnsa6_qname, i, ip, query->cur_port);\n\n                _dns_add_result(query, ip, query->cur_port,\n                    query->cur_prio, query->cur_weight, result->dnsa6_ttl);\n            }\n        }\n    }\n\n    if (query->cur_host != NULL) {\n        /* do ipv4 resolution too */\n        log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->cur_host);\n\n        query->query = dns_submit_a4(NULL, query->cur_host,\n            DNS_NOSRCH, _dns_result_a, query);\n\n        /* if submit failed, call ourselves with a NULL result */\n        if (query->query == NULL)\n            _dns_result_a(ctx, NULL, query);\n    } else {\n        /* uh-oh */\n        log_debug(ZONE, \"dns result for %s@%p: AAAA host vanished...\", query->name, query);\n        _dns_result_a(NULL, NULL, query);\n    }\n\n    free(result);\n}\n\n/* try /etc/hosts if the A process did not return any results */\nstatic int _etc_hosts_lookup(const char *cszName, char *szIP, const int ciMaxIPLen) {\n#define EHL_LINE_LEN 260\n    int iSuccess = 0;\n    size_t iLen;\n    char szLine[EHL_LINE_LEN + 1]; /* one extra for the space character (*) */\n    char *pcStart, *pcEnd;\n    FILE *fHosts;\n\n    do {\n        /* initialization */\n        fHosts = NULL;\n\n        /* sanity checks */\n        if ((cszName == NULL) || (szIP == NULL) || (ciMaxIPLen <= 0))\n            break;\n        szIP[0] = 0;\n\n        /* open the hosts file */\n#ifdef _WIN32\n        pcStart = getenv(\"WINDIR\");\n        if (pcStart != NULL) {\n            sprintf(szLine, \"%s\\\\system32\\\\drivers\\\\etc\\\\hosts\", pcStart);\n        } else {\n            strcpy(szLine, \"C:\\\\WINDOWS\\\\system32\\\\drivers\\\\etc\\\\hosts\");\n        }\n#else\n        strcpy(szLine, \"/etc/hosts\");\n#endif\n        fHosts = fopen(szLine, \"r\");\n        if (fHosts == NULL)\n            break;\n\n        /* read line by line ... */\n        while (fgets(szLine, EHL_LINE_LEN, fHosts) != NULL) {\n            /* remove comments */\n            pcStart = strchr (szLine, '#');\n            if (pcStart != NULL)\n                *pcStart = 0;\n            strcat(szLine, \" \"); /* append a space character for easier parsing (*) */\n\n            /* first to appear: IP address */\n            iLen = strspn(szLine, \"1234567890.\");\n            if ((iLen < 7) || (iLen > 15)) /* superficial test for anything between x.x.x.x and xxx.xxx.xxx.xxx */\n                continue;\n            pcEnd = szLine + iLen;\n            *pcEnd = 0;\n            pcEnd++; /* not beyond the end of the line yet (*) */\n\n            /* check strings separated by blanks, tabs or newlines */\n            pcStart = pcEnd + strspn(pcEnd, \" \\t\\n\");\n            while (*pcStart != 0) {\n                pcEnd = pcStart + strcspn(pcStart, \" \\t\\n\");\n                *pcEnd = 0;\n                pcEnd++; /* not beyond the end of the line yet (*) */\n\n                if (strcasecmp(pcStart, cszName) == 0) {\n                    strncpy(szIP, szLine, ciMaxIPLen - 1);\n                    szIP[ciMaxIPLen - 1] = '\\0';\n                    iSuccess = 1;\n                    break;\n                }\n\n                pcStart = pcEnd + strspn(pcEnd, \" \\t\\n\");\n            }\n            if (iSuccess)\n                break;\n        }\n    } while (0);\n\n    if (fHosts != NULL)\n        fclose(fHosts);\n\n    return (iSuccess);\n}\n\n/* this function is called with a NULL ctx to start the A/AAAA process */\nstatic void _dns_result_a(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data) {\n    dnsquery_t query = data;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n#define DRA_IP_LEN 16\n        char szIP[DRA_IP_LEN];\n        if (_etc_hosts_lookup (query->name, szIP, DRA_IP_LEN)) {\n            log_debug(ZONE, \"/etc/lookup for %s@%p: %s (%d)\", query->name,\n                query, szIP, query->s2s->etc_hosts_ttl);\n\n            _dns_add_result (query, szIP, query->cur_port,\n                query->cur_prio, query->cur_weight, query->s2s->etc_hosts_ttl);\n        } else {\n            log_debug(ZONE, \"dns failure for %s@%p: A %s (%d)\", query->name, query,\n                query->cur_host, dns_status(ctx));\n        }\n    } else if (result != NULL) {\n        char ip[INET_ADDRSTRLEN];\n        int i;\n\n        log_debug(ZONE, \"dns response for %s@%p: A %s %d (%d)\", query->name,\n            query, result->dnsa4_qname, result->dnsa4_nrr, result->dnsa4_ttl);\n\n        if (query->cur_expiry > 0 && result->dnsa4_ttl > query->cur_expiry)\n            result->dnsa4_ttl = query->cur_expiry;\n\n        for (i = 0; i < result->dnsa4_nrr; i++) {\n            if (inet_ntop(AF_INET, &result->dnsa4_addr[i], ip, INET_ADDRSTRLEN) != NULL) {\n                log_debug(ZONE, \"dns response for %s@%p: A %s[%d] %s/%d\", query->name,\n                    query, result->dnsa4_qname, i, ip, query->cur_port);\n\n                _dns_add_result(query, ip, query->cur_port,\n                    query->cur_prio, query->cur_weight, result->dnsa4_ttl);\n            }\n        }\n\n        free(result);\n    }\n\n    /* resolve the next host in the list */\n    if (xhash_iter_first(query->hosts)) {\n        char *ipport, *c, *tmp;\n        int ipport_len, ip_len, port_len;\n        dnsres_t res;\n        union xhashv xhv;\n\n        xhv.dnsres_val = &res;\n\n        /* get the first entry */\n        xhash_iter_get(query->hosts, (const char **) &ipport, &ipport_len, xhv.val);\n\n        /* remove the host from the list */\n        xhash_iter_zap(query->hosts);\n\n        c = memchr(ipport, '/', ipport_len);\n        ip_len = c - ipport;\n        c++;\n        port_len = ipport_len - (c - ipport);\n\n        /* resolve hostname */\n        free(query->cur_host);\n        query->cur_host = strndup(ipport, ip_len);\n        tmp = strndup(c, port_len);\n        query->cur_port = atoi(tmp);\n        free(tmp);\n        query->cur_prio = res->prio;\n        query->cur_weight = res->weight;\n        query->cur_expiry = res->expiry;\n        log_debug(ZONE, \"dns ttl for %s@%p limited to %d\", query->name, query, query->cur_expiry);\n\n        if (query->s2s->resolve_aaaa) {\n            log_debug(ZONE, \"dns request for %s@%p: AAAA %s\", query->name, query, query->cur_host);\n\n            query->query = dns_submit_a6(NULL, query->cur_host, DNS_NOSRCH, _dns_result_aaaa, query);\n\n            /* if submit failed, call ourselves with a NULL result */\n            if (query->query == NULL)\n                _dns_result_aaaa(ctx, NULL, query);\n        } else {\n            log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->cur_host);\n\n            query->query = dns_submit_a4(NULL, query->cur_host, DNS_NOSRCH, _dns_result_a, query);\n\n            /* if submit failed, call ourselves with a NULL result */\n            if (query->query == NULL)\n                _dns_result_a(ctx, NULL, query);\n        }\n\n    /* finished */\n    } else {\n        time_t now = time(NULL);\n        char *domain;\n\n        free(query->cur_host);\n        query->cur_host = NULL;\n\n        log_debug(ZONE, \"dns requests for %s@%p complete: %d (%d)\", query->name,\n            query, xhash_count(query->results), query->expiry);\n\n        /* update query TTL */\n        if (query->expiry > query->s2s->dns_max_ttl)\n            query->expiry = query->s2s->dns_max_ttl;\n\n        if (query->expiry < query->s2s->dns_min_ttl)\n            query->expiry = query->s2s->dns_min_ttl;\n\n        query->expiry += now;\n\n        /* update result TTLs - the query expiry MUST NOT be longer than all result expiries */\n        if (xhash_iter_first(query->results)) {\n            union xhashv xhv;\n            dnsres_t res;\n\n            xhv.dnsres_val = &res;\n\n            do {\n                xhash_iter_get(query->results, NULL, NULL, xhv.val);\n\n                if (res->expiry > query->s2s->dns_max_ttl)\n                    res->expiry = query->s2s->dns_max_ttl;\n\n                if (res->expiry < query->s2s->dns_min_ttl)\n                    res->expiry = query->s2s->dns_min_ttl;\n\n                res->expiry += now;\n            } while(xhash_iter_next(query->results));\n        }\n\n        xhash_free(query->hosts);\n        query->hosts = NULL;\n        if (idna_to_unicode_8z8z(query->name, &domain, 0) != IDNA_SUCCESS) {\n            log_write(query->s2s->log, LOG_ERR, \"idna dns decode for %s failed\", query->name);\n            /* fake empty results to shortcut resolution failure */\n            xhash_free(query->results);\n            query->results = xhash_new(71);\n            query->expiry = time(NULL) + 99999999;\n            domain = strdup(query->name);\n        }\n        out_resolve(query->s2s, domain, query->results, query->expiry);\n        free(domain);\n        free(query->name);\n        free(query);\n    }\n}\n\nvoid dns_resolve_domain(s2s_t s2s, dnscache_t dns) {\n    dnsquery_t query = (dnsquery_t) calloc(1, sizeof(struct dnsquery_st));\n\n    query->s2s = s2s;\n    query->results = xhash_new(71);\n    if (idna_to_ascii_8z(dns->name, &query->name, 0) != IDNA_SUCCESS) {\n        log_write(s2s->log, LOG_ERR, \"idna dns encode for %s failed\", dns->name);\n        /* shortcut resolution failure */\n        query->expiry = time(NULL) + 99999999;\n        out_resolve(query->s2s, dns->name, query->results, query->expiry);\n        return;\n    }\n    query->hosts = xhash_new(71);\n    query->srv_i = -1;\n    query->expiry = 0;\n    query->cur_host = NULL;\n    query->cur_port = 0;\n    query->cur_expiry = 0;\n    query->query = NULL;\n    dns->query = query;\n\n    log_debug(ZONE, \"dns resolve for %s@%p started\", query->name, query);\n\n    /* - resolve all SRV records to host/port\n     * - if no results, include domain/5269\n     * - resolve all host/port combinations\n     * - return result\n     */\n    _dns_result_srv(NULL, NULL, query);\n}\n\n/** responses from the resolver */\nvoid out_resolve(s2s_t s2s, char *domain, xht results, time_t expiry) {\n    dnscache_t dns;\n\n    /* no results, resolve failed */\n    if(xhash_count(results) == 0) {\n        dns = xhash_get(s2s->dnscache, domain);\n        if (dns != NULL) {\n            /* store negative DNS cache */\n            xhash_free(dns->results);\n            dns->query = NULL;\n            dns->results = NULL;\n            dns->expiry = expiry;\n            dns->pending = 0;\n        }\n\n        log_write(s2s->log, LOG_NOTICE, \"dns lookup for %s failed\", domain);\n\n        /* bounce queue */\n        out_bounce_domain_queues(s2s, domain, stanza_err_REMOTE_SERVER_NOT_FOUND);\n\n        xhash_free(results);\n        return;\n    }\n\n    log_write(s2s->log, LOG_NOTICE, \"dns lookup for %s returned %d result%s (ttl %d)\",\n        domain, xhash_count(results), xhash_count(results)!=1?\"s\":\"\", expiry - time(NULL));\n\n    /* get the cache entry */\n    dns = xhash_get(s2s->dnscache, domain);\n\n    if(dns == NULL) {\n        /* retry using punycode */\n        char *punydomain;\n        if (idna_to_ascii_8z(domain, &punydomain, 0) == IDNA_SUCCESS) {\n            dns = xhash_get(s2s->dnscache, punydomain);\n            free(punydomain);\n        }\n    }\n\n    if(dns == NULL) {\n        log_write(s2s->log, LOG_ERR, \"weird, never requested %s resolution\", domain);\n        return;\n    }\n\n    /* fill it out */\n    xhash_free(dns->results);\n    dns->query = NULL;\n    dns->results = results;\n    dns->expiry = expiry;\n    dns->pending = 0;\n\n    out_flush_domain_queues(s2s, domain);\n\n    /* delete the cache entry if caching is disabled */\n    if (!s2s->dns_cache_enabled && !dns->pending) {\n        xhash_free(dns->results);\n        xhash_zap(s2s->dnscache, domain);\n        free(dns);\n    }\n}\n\n/** mio callback for outgoing conns */\nstatic int _out_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void *arg) {\n    conn_t out = (conn_t) arg;\n    char ipport[INET6_ADDRSTRLEN + 17];\n    int nbytes;\n\n    switch(a) {\n        case action_READ:\n            log_debug(ZONE, \"read action on fd %d\", fd->fd);\n\n            /* they did something */\n            out->last_activity = time(NULL);\n\n            ioctl(fd->fd, FIONREAD, &nbytes);\n            if(nbytes == 0) {\n                sx_kill(out->s);\n                return 0;\n            }\n\n            return sx_can_read(out->s);\n\n        case action_WRITE:\n            log_debug(ZONE, \"write action on fd %d\", fd->fd);\n\n            /* update activity timestamp */\n            out->last_activity = time(NULL);\n\n            return sx_can_write(out->s);\n\n        case action_CLOSE:\n            log_debug(ZONE, \"close action on fd %d\", fd->fd);\n\n            jqueue_push(out->s2s->dead, (void *) out->s, 0);\n\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] disconnect, packets: %i\", fd->fd, out->ip, out->port, out->packet_count);\n\n\n            if (out->s2s->out_reuse) {\n                /* generate the ip/port pair */\n                snprintf(ipport, INET6_ADDRSTRLEN + 16, \"%s/%d\", out->ip, out->port);\n\n                xhash_zap(out->s2s->out_host, ipport);\n            }\n\n            if (xhash_iter_first(out->routes)) {\n                char *rkey;\n                int rkeylen;\n                char *c;\n                int c_len;\n\n                /* remove all the out_dest entries */\n                do {\n                    xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n                    c = memchr(rkey, '/', rkeylen);\n                    c++;\n                    c_len = rkeylen - (c - rkey);\n\n                    log_debug(ZONE, \"route '%.*s'\", rkeylen, rkey);\n                    if (xhash_getx(out->s2s->out_dest, c, c_len) != NULL) {\n                        log_debug(ZONE, \"removing dest entry for '%.*s'\", c_len, c);\n                        xhash_zapx(out->s2s->out_dest, c, c_len);\n                    }\n                } while(xhash_iter_next(out->routes));\n            }\n\n            if (xhash_iter_first(out->routes)) {\n                char *rkey;\n                int rkeylen;\n                jqueue_t q;\n                int npkt;\n\n                /* retry all the routes */\n                do {\n                    xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n\n                    q = xhash_getx(out->s2s->outq, rkey, rkeylen);\n                    if (out->s2s->retry_limit > 0 && q != NULL && jqueue_age(q) > out->s2s->retry_limit) {\n                        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] retry limit reached for '%.*s' queue\", fd->fd, out->ip, out->port, rkeylen, rkey);\n                        q = NULL;\n                    }\n\n                    if (q != NULL && (npkt = jqueue_size(q)) > 0 && xhash_get(out->states, rkey) != (void*) conn_INPROGRESS) {\n                        conn_t retry;\n\n                        log_debug(ZONE, \"retrying connection for '%.*s' queue\", rkeylen, rkey);\n                        if (!out_route(out->s2s, rkey, rkeylen, &retry, 0)) {\n                            log_debug(ZONE, \"retry successful\");\n\n                            if (retry != NULL) {\n                                /* flush queue */\n                                out_flush_route_queue(out->s2s, rkey, rkeylen);\n                            }\n                        } else {\n                            log_debug(ZONE, \"retry failed\");\n\n                            /* bounce queue */\n                            out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n                            _out_dns_mark_bad(out);\n                        }\n                    } else {\n                        /* bounce queue */\n                        out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_REMOTE_SERVER_TIMEOUT);\n                        _out_dns_mark_bad(out);\n                    }\n                } while(xhash_iter_next(out->routes));\n            }\n\n            jqueue_push(out->s2s->dead_conn, (void *) out, 0);\n\n        case action_ACCEPT:\n            break;\n    }\n\n    return 0;\n}\n\nvoid send_dialbacks(conn_t out)\n{\n  char *rkey;\n  int rkeylen;\n\n  if (out->s2s->dns_bad_timeout > 0) {\n      dnsres_t bad = xhash_get(out->s2s->dns_bad, out->key);\n\n      if (bad != NULL) {\n          log_debug(ZONE, \"removing bad host entry for '%s'\", out->key);\n          xhash_zap(out->s2s->dns_bad, out->key);\n          free(bad->key);\n          free(bad);\n      }\n  }\n\n  if (xhash_iter_first(out->routes)) {\n       log_debug(ZONE, \"sending dialback packets for %s\", out->key);\n       do {\n            xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n            _out_dialback(out, rkey, rkeylen);\n          } while(xhash_iter_next(out->routes));\n  }\n\n  return;\n}\n\nstatic int _out_sx_callback(sx_t s, sx_event_t e, void *data, void *arg) {\n    conn_t out = (conn_t) arg;\n    sx_buf_t buf = (sx_buf_t) data;\n    int len, ns, elem, starttls = 0;\n    sx_error_t *sxe;\n    nad_t nad;\n\n    switch(e) {\n        case event_WANT_READ:\n            log_debug(ZONE, \"want read\");\n            mio_read(out->s2s->mio, out->fd);\n            break;\n\n        case event_WANT_WRITE:\n            log_debug(ZONE, \"want write\");\n            mio_write(out->s2s->mio, out->fd);\n            break;\n\n        case event_READ:\n            log_debug(ZONE, \"reading from %d\", out->fd->fd);\n\n            /* do the read */\n            len = recv(out->fd->fd, buf->data, buf->len, 0);\n\n            if(len < 0) {\n                if(MIO_WOULDBLOCK) {\n                    buf->len = 0;\n                    return 0;\n                }\n\n                log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] read error: %s (%d)\", out->fd->fd, out->ip, out->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n                if (!out->online) {\n                    _out_dns_mark_bad(out);\n                }\n\n                sx_kill(s);\n\n                return -1;\n            }\n\n            else if(len == 0) {\n                /* they went away */\n                sx_kill(s);\n\n                return -1;\n            }\n\n            log_debug(ZONE, \"read %d bytes\", len);\n\n            buf->len = len;\n\n            return len;\n\n        case event_WRITE:\n            log_debug(ZONE, \"writing to %d\", out->fd->fd);\n\n            len = send(out->fd->fd, buf->data, buf->len, 0);\n            if(len >= 0) {\n                log_debug(ZONE, \"%d bytes written\", len);\n                return len;\n            }\n\n            if(MIO_WOULDBLOCK)\n                return 0;\n\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] write error: %s (%d)\", out->fd->fd, out->ip, out->port, MIO_STRERROR(MIO_ERROR), MIO_ERROR);\n\n            if (!out->online) {\n                _out_dns_mark_bad(out);\n            }\n\n            sx_kill(s);\n\n            return -1;\n\n        case event_ERROR:\n            sxe = (sx_error_t *) data;\n            log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] error: %s (%s)\", out->fd->fd, out->ip, out->port, sxe->generic, sxe->specific);\n\n            /* mark as bad if we did not manage to connect or there is unrecoverable stream error */\n            if (!out->online ||\n                    (sxe->code == SX_ERR_STREAM &&\n                        (strstr(sxe->specific, \"host-gone\") ||        /* it's not there now */\n                         strstr(sxe->specific, \"host-unknown\") ||     /* they do not service the host */\n                         strstr(sxe->specific, \"not-authorized\") ||   /* they do not want us there */\n                         strstr(sxe->specific, \"see-other-host\") ||   /* we do not support redirections yet */\n                         strstr(sxe->specific, \"system-shutdown\") ||  /* they are going down */\n                         strstr(sxe->specific, \"policy-violation\") || /* they do not want us there */\n                         strstr(sxe->specific, \"remote-connection-failed\") ||  /* the required remote entity is gone */\n                         strstr(sxe->specific, \"unsupported-encoding\") ||      /* they do not like our encoding */\n                         strstr(sxe->specific, \"undefined-condition\") ||       /* something bad happend */\n                         strstr(sxe->specific, \"internal-server-error\") ||     /* that server is broken */\n                         strstr(sxe->specific, \"unsupported-version\")          /* they do not support our stream version */\n                        ))) {\n                _out_dns_mark_bad(out);\n            }\n\n            sx_kill(s);\n\n            return -1;\n\n        case event_OPEN:\n            log_debug(ZONE, \"OPEN event for %s\", out->key);\n            break;\n\n        case event_STREAM:\n            /* check stream version - NULl = pre-xmpp (some jabber1 servers) */\n            log_debug(ZONE, \"STREAM event for %s stream version is %s\", out->key, out->s->res_version);\n\n            /* first time, bring them online */\n            if(!out->online) {\n                log_debug(ZONE, \"outgoing conn to %s is online\", out->key);\n\n                /* if no stream version from either side, kick off dialback for each route, */\n                /* otherwise wait for stream features */\n                if (((out->s->res_version==NULL) || (out->s2s->sx_ssl == NULL)) && out->s2s->require_tls == 0) {\n                     log_debug(ZONE, \"no stream version, sending dialbacks for %s immediately\", out->key);\n                     out->online = 1;\n                     send_dialbacks(out);\n                } else\n                     log_debug(ZONE, \"outgoing conn to %s - waiting for STREAM features\", out->key);\n            }\n\n            break;\n\n        case event_PACKET:\n            /* we're counting packets */\n            out->packet_count++;\n            out->s2s->packet_count++;\n\n            nad = (nad_t) data;\n\n            /* watch for the features packet - STARTTLS and/or SASL*/\n            if ((out->s->res_version!=NULL)\n                 && NAD_NURI_L(nad, NAD_ENS(nad, 0)) == strlen(uri_STREAMS)\n                 && strncmp(uri_STREAMS, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_STREAMS)) == 0\n                 && NAD_ENAME_L(nad, 0) == 8 && strncmp(\"features\", NAD_ENAME(nad, 0), 8) == 0) {\n                log_debug(ZONE, \"got the stream features packet\");\n\n#ifdef HAVE_SSL\n                /* starttls if we can */\n                if(out->s2s->sx_ssl != NULL && s->ssf == 0) {\n                    ns = nad_find_scoped_namespace(nad, uri_TLS, NULL);\n                    if(ns >= 0) {\n                        elem = nad_find_elem(nad, 0, ns, \"starttls\", 1);\n                        if(elem >= 0) {\n                            log_debug(ZONE, \"got STARTTLS in stream features\");\n                            if(sx_ssl_client_starttls(out->s2s->sx_ssl, s, out->s2s->local_pemfile) == 0) {\n                                starttls = 1;\n                                nad_free(nad);\n                                return 0;\n                            }\n                            log_write(out->s2s->log, LOG_ERR, \"unable to establish encrypted session with peer\");\n                        }\n                    }\n                }\n\n                /* If we're not establishing a starttls connection, send dialbacks */\n                if (!starttls) {\n                    if (out->s2s->require_tls == 0 || s->ssf > 0) {\n                     log_debug(ZONE, \"No STARTTLS, sending dialbacks for %s\", out->key);\n                     out->online = 1;\n                     send_dialbacks(out);\n                    } else {\n                        log_debug(ZONE, \"No STARTTLS, dialbacks disabled for non-TLS connections, cannot complete negotiation\");\n                    }\n                }\n#else\n                if (out->s2s->require_tls == 0) {\n                out->online = 1;\n                send_dialbacks(out);\n                }\n#endif\n            }\n\n\n            /* we only accept dialback packets */\n            if(NAD_ENS(nad, 0) < 0 || NAD_NURI_L(nad, NAD_ENS(nad, 0)) != uri_DIALBACK_L || strncmp(uri_DIALBACK, NAD_NURI(nad, NAD_ENS(nad, 0)), uri_DIALBACK_L) != 0) {\n                log_debug(ZONE, \"got a non-dialback packet on an outgoing conn, dropping it\");\n                nad_free(nad);\n                return 0;\n            }\n\n            /* and then only result and verify */\n            if(NAD_ENAME_L(nad, 0) == 6) {\n                if(strncmp(\"result\", NAD_ENAME(nad, 0), 6) == 0) {\n                    _out_result(out, nad);\n                    return 0;\n                }\n\n                if(strncmp(\"verify\", NAD_ENAME(nad, 0), 6) == 0) {\n                    _out_verify(out, nad);\n                    return 0;\n                }\n            }\n\n            log_debug(ZONE, \"unknown dialback packet, dropping it\");\n\n            nad_free(nad);\n            return 0;\n\n        case event_CLOSED:\n            if (out->fd != NULL) {\n            mio_close(out->s2s->mio, out->fd);\n                out->fd = NULL;\n            }\n            return -1;\n    }\n\n    return 0;\n}\n\n/** process incoming auth responses */\nstatic void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}\n\n/** incoming stream authenticated */\nstatic void _out_verify(conn_t out, nad_t nad) {\n    int attr, ns;\n    jid_t from, to;\n    conn_t in;\n    char *rkey;\n    int valid;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db verify packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db verify packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"id\", NULL);\n    if(attr < 0) {\n        log_debug(ZONE, \"missing id on db verify packet\");\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    /* get the incoming conn */\n    in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));\n    if(in == NULL) {\n        log_debug(ZONE, \"got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n\n    attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");\n    if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {\n        xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        valid = 1;\n    } else {\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now invalid\", in->fd->fd, in->ip, in->port, rkey);\n        valid = 0;\n    }\n\n    free(rkey);\n\n    nad_free(nad);\n\n    /* decrement outstanding verify counter */\n    --out->verify;\n\n    /* let them know what happened */\n    nad = nad_new();\n\n    ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");\n    nad_append_elem(nad, ns, \"result\", 0);\n    nad_append_attr(nad, -1, \"to\", from->domain);\n    nad_append_attr(nad, -1, \"from\", to->domain);\n    nad_append_attr(nad, -1, \"type\", valid ? \"valid\" : \"invalid\");\n\n    /* off it goes */\n    sx_nad_write(in->s, nad);\n\n    /* if invalid, close the stream */\n    if (!valid) {\n        /* generate stream error */\n        sx_error(in->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n        /* close the incoming stream */\n        sx_close(in->s);\n    }\n\n    jid_free(from);\n    jid_free(to);\n}\n\n/* bounce all packets in the queues for domain */\nint out_bounce_domain_queues(s2s_t s2s, const char *domain, int err)\n{\n  char *rkey;\n  int rkeylen;\n  int pktcount = 0;\n\n  if (xhash_iter_first(s2s->outq)) {\n      do {\n          xhash_iter_get(s2s->outq, (const char **) &rkey, &rkeylen, NULL);\n          if(s2s_route_key_match(NULL, (char *) domain, rkey, rkeylen))\n              pktcount += out_bounce_route_queue(s2s, rkey, rkeylen, err);\n      } while(xhash_iter_next(s2s->outq));\n  }\n\n  return pktcount;\n}\n\n/* bounce all packets in the queue for route */\nint out_bounce_route_queue(s2s_t s2s, char *rkey, int rkeylen, int err)\n{\n  jqueue_t q;\n  pkt_t pkt;\n  int pktcount = 0;\n\n  q = xhash_getx(s2s->outq, rkey, rkeylen);\n  if(q == NULL)\n     return 0;\n\n  while((pkt = jqueue_pull(q)) != NULL) {\n     /* only packets with content, in namespace jabber:client and not already errors */\n     if(pkt->nad->ecur > 1 && NAD_NURI_L(pkt->nad, NAD_ENS(pkt->nad, 1)) == strlen(uri_CLIENT) && strncmp(NAD_NURI(pkt->nad, NAD_ENS(pkt->nad, 1)), uri_CLIENT, strlen(uri_CLIENT)) == 0 && nad_find_attr(pkt->nad, 0, -1, \"error\", NULL) < 0) {\n         sx_nad_write(s2s->router, stanza_tofrom(stanza_tofrom(stanza_error(pkt->nad, 1, err), 1), 0));\n         pktcount++;\n     }\n     else\n         nad_free(pkt->nad);\n\n     jid_free(pkt->to);\n     jid_free(pkt->from);\n     free(pkt);\n  }\n\n  /* delete queue and remove domain from queue hash */\n  log_debug(ZONE, \"deleting out packet queue for %.*s\", rkeylen, rkey);\n  rkey = q->key;\n  jqueue_free(q);\n  xhash_zap(s2s->outq, rkey);\n  free(rkey);\n\n  return pktcount;\n}\n\nint out_bounce_conn_queues(conn_t out, int err)\n{\n  char *rkey;\n  int rkeylen;\n  int pktcount = 0;\n\n  /* bounce queues for all domains handled by this connection - iterate through routes */\n  if (xhash_iter_first(out->routes)) {\n      do {\n          xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n          pktcount += out_bounce_route_queue(out->s2s, rkey, rkeylen, err);\n      } while(xhash_iter_next(out->routes));\n  }\n\n  return pktcount;\n}\n\nvoid out_flush_domain_queues(s2s_t s2s, const char *domain) {\n  char *rkey;\n  int rkeylen;\n  char *c;\n  int c_len;\n\n  if (xhash_iter_first(s2s->outq)) {\n      do {\n          xhash_iter_get(s2s->outq, (const char **) &rkey, &rkeylen, NULL);\n          c = memchr(rkey, '/', rkeylen);\n          c++;\n          c_len = rkeylen - (c - rkey);\n          if (strncmp(domain, c, c_len) == 0)\n              out_flush_route_queue(s2s, rkey, rkeylen);\n      } while(xhash_iter_next(s2s->outq));\n  }\n}\n\nvoid out_flush_route_queue(s2s_t s2s, char *rkey, int rkeylen) {\n    jqueue_t q;\n    pkt_t pkt;\n    int npkt, i, ret;\n\n    q = xhash_getx(s2s->outq, rkey, rkeylen);\n    if(q == NULL)\n        return;\n\n    npkt = jqueue_size(q);\n    log_debug(ZONE, \"flushing %d packets for '%.*s' to out_packet\", npkt, rkeylen, rkey);\n\n    for(i = 0; i < npkt; i++) {\n        pkt = jqueue_pull(q);\n        if(pkt) {\n            ret = out_packet(s2s, pkt);\n            if (ret) {\n                /* uh-oh. the queue was deleted...\n                   q and pkt have been freed\n                   if q->key == rkey, rkey has also been freed */\n                return;\n            }\n        }\n    }\n\n    /* delete queue for route and remove route from queue hash */\n    if (jqueue_size(q) == 0) {\n        log_debug(ZONE, \"deleting out packet queue for '%.*s'\", rkeylen, rkey);\n        rkey = q->key;\n        jqueue_free(q);\n        xhash_zap(s2s->outq, rkey);\n        free(rkey);\n    } else {\n        log_debug(ZONE, \"emptied queue gained more packets...\");\n    }\n}\n"], "filenames": ["s2s/out.c"], "buggy_code_start_loc": [1664], "buggy_code_end_loc": [1753], "fixing_code_start_loc": [1664], "fixing_code_end_loc": [1753], "type": "CWE-20", "message": "s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response.", "other": {"cve": {"id": "CVE-2012-3525", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-25T16:55:00.837", "lastModified": "2023-02-13T04:34:26.153", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response."}, {"lang": "es", "value": "s2s/out.c en jabberd2 v2.2.16 y anteriores no comprueba que se presente una solicitud para una respuesta XMPP Server Dialback, lo que permite a servidores remotos de XMPP falsificar dominios a trav\u00e9s (1) Verify Response o (2) Authorization Response."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jabber2:jabberd2:2.1.19:*:*:*:*:*:*:*", "matchCriteriaId": "24C9A9BA-FC37-4FED-B03B-02FD87DF4B51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.16", "matchCriteriaId": "9AA058DB-6786-489E-B560-1AE154607AAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1:*:*:*:*:*:*:*", "matchCriteriaId": "38A57C87-1E18-4DEC-864F-BFECA74FB8D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "8B3405FB-CEBD-4E9B-809C-CC436DB491CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "F7C16361-0A6A-46F1-9154-0EBAEF9424DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "DB738B5C-F549-4171-93F8-821F06D09B6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "136B0689-05C4-47AF-BCFC-5BAAD62DD2A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "BA729702-72F3-4BB4-8647-8938DDCA65B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "E32A9A5F-7669-4EC1-804E-8FDAD5FD3FAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "713D733B-C056-4A87-A0F3-669BD2B97EA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "5B695154-C52C-4A26-AB56-B9D301268BB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "33D8A7D9-1565-4CA2-832B-3B5A800E7185"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "64DA6F74-7F66-4C47-A05A-1F1143FEBF24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.11:*:*:*:*:*:*:*", "matchCriteriaId": "9A7B360C-9222-4862-A1A3-D939D8E5B906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.12:*:*:*:*:*:*:*", "matchCriteriaId": "BCC4B150-E318-430D-AB53-7FC4235534E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.13:*:*:*:*:*:*:*", "matchCriteriaId": "2E0A1409-AA29-4393-AF76-38D2F6621BDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.14:*:*:*:*:*:*:*", "matchCriteriaId": "B389FE79-E88D-4BD3-A3DB-5015FF9E78C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.15:*:*:*:*:*:*:*", "matchCriteriaId": "12B9B5DE-912B-4D76-A428-2A614918C1B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.16:*:*:*:*:*:*:*", "matchCriteriaId": "ACCAEDE2-B0C2-48CB-B0C3-594A6569B904"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.17:*:*:*:*:*:*:*", "matchCriteriaId": "C1B73387-35EC-440C-8B93-879BD66E39F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.18:*:*:*:*:*:*:*", "matchCriteriaId": "47426695-4686-4736-B27E-6800ACB43CF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.20:*:*:*:*:*:*:*", "matchCriteriaId": "6F846FB8-DCDA-4A24-9DD7-2F9C9AC3833F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.21:*:*:*:*:*:*:*", "matchCriteriaId": "8C9B9D48-5848-4313-9EDF-FDE562875EDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.22:*:*:*:*:*:*:*", "matchCriteriaId": "AB5C31E5-2441-4C53-9E10-3AB33FCF11A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.23:*:*:*:*:*:*:*", "matchCriteriaId": "703383CD-DF8D-4DA1-B322-8DE9E847A8CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.1.24:*:*:*:*:*:*:*", "matchCriteriaId": "B8A9F0E1-0A41-4C98-8467-0578D98AD0BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "769A2F0A-816C-458A-B579-CE8BB8FF5A12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "C0BD3313-4CF5-44EE-91EC-D6F0C23D0342"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "0D3E1C3C-FB3B-4941-A879-0F351959EB8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "98EE2C3A-67C4-45D5-80EE-3819F5AB1133"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "DB4C94F7-4093-46B5-9B2E-9F3B2BD462DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "2D9B7918-C678-4CE8-97B1-52AF3E17A356"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "10D9719B-B6AE-4AA1-9767-FD85DE12782B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "5C64CA72-E6D6-4981-AA23-447EA7FAFD7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "57CE98F9-FA6B-49D0-8410-BCD188E2F64C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "64A5D6D9-D045-4A0A-BBAB-21F2C228BC2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "595AFA35-92B5-4957-A2AA-DF9E09990438"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "45836D34-A47C-49F6-9A1A-3F8160611058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "89ED36F8-4D8C-406E-BE8A-F8C374227F8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "28D0CB97-3F6A-4CD6-A9A4-2F6743E13F35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "9923E4E2-ADB1-4729-97AE-C4EA19D5E6C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "69E01C9E-5B90-4044-B002-87A741CA6AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jabberd2:jabberd2:2.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "9042F295-2C75-4260-9A3F-A7A225B36EB1"}]}]}], "references": [{"url": "http://lists.apple.com/archives/security-announce/2013/Mar/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1538.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1539.html", "source": "secalert@redhat.com"}, {"url": "http://www.mail-archive.com/jabberd2%40lists.xiaoka.com/msg01903.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/08/22/5", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/08/22/6", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/55167", "source": "secalert@redhat.com"}, {"url": "http://xmpp.org/resources/security-notices/server-dialback/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=850872", "source": "secalert@redhat.com"}, {"url": "https://github.com/Jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/Jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d"}}