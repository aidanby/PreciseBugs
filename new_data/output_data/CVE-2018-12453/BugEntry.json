{"buggy_code": ["/*\n * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n#define STREAM_BYTES_PER_LISTPACK 2048\n\n/* Every stream item inside the listpack, has a flags field that is used to\n * mark the entry as deleted, or having the same field as the \"master\"\n * entry at the start of the listpack> */\n#define STREAM_ITEM_FLAG_NONE 0             /* No special flags. */\n#define STREAM_ITEM_FLAG_DELETED (1<<0)     /* Entry is delted. Skip it. */\n#define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  /* Same fields as master entry. */\n\nvoid streamFreeCG(streamCG *cg);\nvoid streamFreeNACK(streamNACK *na);\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);\n\n/* -----------------------------------------------------------------------\n * Low level stream encoding: a radix tree of listpacks.\n * ----------------------------------------------------------------------- */\n\n/* Create a new stream data structure. */\nstream *streamNew(void) {\n    stream *s = zmalloc(sizeof(*s));\n    s->rax = raxNew();\n    s->length = 0;\n    s->last_id.ms = 0;\n    s->last_id.seq = 0;\n    s->cgroups = NULL; /* Created on demand to save memory when not used. */\n    return s;\n}\n\n/* Free a stream, including the listpacks stored inside the radix tree. */\nvoid freeStream(stream *s) {\n    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);\n    if (s->cgroups)\n        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);\n    zfree(s);\n}\n\n/* Generate the next stream item ID given the previous one. If the current\n * milliseconds Unix time is greater than the previous one, just use this\n * as time part and start with sequence part of zero. Otherwise we use the\n * previous time (and never go backward) and increment the sequence. */\nvoid streamNextID(streamID *last_id, streamID *new_id) {\n    uint64_t ms = mstime();\n    if (ms > last_id->ms) {\n        new_id->ms = ms;\n        new_id->seq = 0;\n    } else {\n        new_id->ms = last_id->ms;\n        new_id->seq = last_id->seq+1;\n    }\n}\n\n/* This is just a wrapper for lpAppend() to directly use a 64 bit integer\n * instead of a string. */\nunsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {\n    char buf[LONG_STR_SIZE];\n    int slen = ll2string(buf,sizeof(buf),value);\n    return lpAppend(lp,(unsigned char*)buf,slen);\n}\n\n/* This is just a wrapper for lpReplace() to directly use a 64 bit integer\n * instead of a string to replace the current element. The function returns\n * the new listpack as return value, and also updates the current cursor\n * by updating '*pos'. */\nunsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {\n    char buf[LONG_STR_SIZE];\n    int slen = ll2string(buf,sizeof(buf),value);\n    return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);\n}\n\n/* This is a wrapper function for lpGet() to directly get an integer value\n * from the listpack (that may store numbers as a string), converting\n * the string if needed. */\nint64_t lpGetInteger(unsigned char *ele) {\n    int64_t v;\n    unsigned char *e = lpGet(ele,&v,NULL);\n    if (e == NULL) return v;\n    /* The following code path should never be used for how listpacks work:\n     * they should always be able to store an int64_t value in integer\n     * encoded form. However the implementation may change. */\n    long long ll;\n    int retval = string2ll((char*)e,v,&ll);\n    serverAssert(retval != 0);\n    v = ll;\n    return v;\n}\n\n/* Debugging function to log the full content of a listpack. Useful\n * for development and debugging. */\nvoid streamLogListpackContent(unsigned char *lp) {\n    unsigned char *p = lpFirst(lp);\n    while(p) {\n        unsigned char buf[LP_INTBUF_SIZE];\n        int64_t v;\n        unsigned char *ele = lpGet(p,&v,buf);\n        serverLog(LL_WARNING,\"- [%d] '%.*s'\", (int)v, (int)v, ele);\n        p = lpNext(lp,p);\n    }\n}\n\n/* Convert the specified stream entry ID as a 128 bit big endian number, so\n * that the IDs can be sorted lexicographically. */\nvoid streamEncodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    e[0] = htonu64(id->ms);\n    e[1] = htonu64(id->seq);\n    memcpy(buf,e,sizeof(e));\n}\n\n/* This is the reverse of streamEncodeID(): the decoded ID will be stored\n * in the 'id' structure passed by reference. The buffer 'buf' must point\n * to a 128 bit big-endian encoded ID. */\nvoid streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n\n/* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */\nint streamCompareID(streamID *a, streamID *b) {\n    if (a->ms > b->ms) return 1;\n    else if (a->ms < b->ms) return -1;\n    /* The ms part is the same. Check the sequence part. */\n    else if (a->seq > b->seq) return 1;\n    else if (a->seq < b->seq) return -1;\n    /* Everything is the same: IDs are equal. */\n    return 0;\n}\n\n/* Adds a new item into the stream 's' having the specified number of\n * field-value pairs as specified in 'numfields' and stored into 'argv'.\n * Returns the new entry ID populating the 'added_id' structure.\n *\n * If 'use_id' is not NULL, the ID is not auto-generated by the function,\n * but instead the passed ID is uesd to add the new entry. In this case\n * adding the entry may fail as specified later in this comment.\n *\n * The function returns C_OK if the item was added, this is always true\n * if the ID was generated by the function. However the function may return\n * C_ERR if an ID was given via 'use_id', but adding it failed since the\n * current top ID is greater or equal. */\nint streamAppendItem(stream *s, robj **argv, int numfields, streamID *added_id, streamID *use_id) {\n    /* If an ID was given, check that it's greater than the last entry ID\n     * or return an error. */\n    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) return C_ERR;\n\n    /* Add the new entry. */\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"$\",NULL,0);\n\n    size_t lp_bytes = 0;        /* Total bytes in the tail listpack. */\n    unsigned char *lp = NULL;   /* Tail listpack pointer. */\n\n    /* Get a reference to the tail node listpack. */\n    if (raxNext(&ri)) {\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n    }\n    raxStop(&ri);\n\n    /* Generate the new entry ID. */\n    streamID id;\n    if (use_id)\n        id = *use_id;\n    else\n        streamNextID(&s->last_id,&id);\n\n    /* We have to add the key into the radix tree in lexicographic order,\n     * to do so we consider the ID as a single 128 bit number written in\n     * big endian, so that the most significant bytes are the first ones. */\n    uint64_t rax_key[2];    /* Key in the radix tree containing the listpack.*/\n    streamID master_id;     /* ID of the master entry in the listpack. */\n\n    /* Create a new listpack and radix tree node if needed. Note that when\n     * a new listpack is created, we populate it with a \"master entry\". This\n     * is just a set of fields that is taken as refernce in order to compress\n     * the stream entries that we'll add inside the listpack.\n     *\n     * Note that while we use the first added entry fields to create\n     * the master entry, the first added entry is NOT represented in the master\n     * entry, which is a stand alone object. But of course, the first entry\n     * will compress well because it's used as reference.\n     *\n     * The master entry is composed like in the following example:\n     *\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     *\n     * count and deleted just represent respectively the total number of\n     * entries inside the listpack that are valid, and marked as deleted\n     * (delted flag in the entry flags set). So the total number of items\n     * actually inside the listpack (both deleted and not) is count+deleted.\n     *\n     * The real entries will be encoded with an ID that is just the\n     * millisecond and sequence difference compared to the key stored at\n     * the radix tree node containing the listpack (delta encoding), and\n     * if the fields of the entry are the same as the master enty fields, the\n     * entry flags will specify this fact and the entry fields and number\n     * of fields will be omitted (see later in the code of this function).\n     *\n     * The \"0\" entry at the end is the same as the 'lp-count' entry in the\n     * regular stream entries (see below), and marks the fact that there are\n     * no more entries, when we scan the stream from right to left. */\n\n    /* First of all, check if we can append to the current macro node or\n     * if we need to switch to the next one. 'lp' will be set to NULL if\n     * the current node is full. */\n    if (lp != NULL) {\n        if (server.stream_node_max_bytes &&\n            lp_bytes > server.stream_node_max_bytes)\n        {\n            lp = NULL;\n        } else if (server.stream_node_max_entries) {\n            int64_t count = lpGetInteger(lpFirst(lp));\n            if (count > server.stream_node_max_entries) lp = NULL;\n        }\n    }\n\n    int flags = STREAM_ITEM_FLAG_NONE;\n    if (lp == NULL || lp_bytes > server.stream_node_max_bytes) {\n        master_id = id;\n        streamEncodeID(rax_key,&id);\n        /* Create the listpack having the master entry ID and fields. */\n        lp = lpNew();\n        lp = lpAppendInteger(lp,1); /* One item, the one we are adding. */\n        lp = lpAppendInteger(lp,0); /* Zero deleted so far. */\n        lp = lpAppendInteger(lp,numfields);\n        for (int i = 0; i < numfields; i++) {\n            sds field = argv[i*2]->ptr;\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        }\n        lp = lpAppendInteger(lp,0); /* Master entry zero terminator. */\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n        /* The first entry we insert, has obviously the same fields of the\n         * master entry. */\n        flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n    } else {\n        serverAssert(ri.key_len == sizeof(rax_key));\n        memcpy(rax_key,ri.key,sizeof(rax_key));\n\n        /* Read the master ID from the radix tree key. */\n        streamDecodeID(rax_key,&master_id);\n        unsigned char *lp_ele = lpFirst(lp);\n\n        /* Update count and skip the deleted fields. */\n        int64_t count = lpGetInteger(lp_ele);\n        lp = lpReplaceInteger(lp,&lp_ele,count+1);\n        lp_ele = lpNext(lp,lp_ele); /* seek deleted. */\n        lp_ele = lpNext(lp,lp_ele); /* seek master entry num fields. */\n\n        /* Check if the entry we are adding, have the same fields\n         * as the master entry. */\n        int master_fields_count = lpGetInteger(lp_ele);\n        lp_ele = lpNext(lp,lp_ele);\n        if (numfields == master_fields_count) {\n            int i;\n            for (i = 0; i < master_fields_count; i++) {\n                sds field = argv[i*2]->ptr;\n                int64_t e_len;\n                unsigned char buf[LP_INTBUF_SIZE];\n                unsigned char *e = lpGet(lp_ele,&e_len,buf);\n                /* Stop if there is a mismatch. */\n                if (sdslen(field) != (size_t)e_len ||\n                    memcmp(e,field,e_len) != 0) break;\n                lp_ele = lpNext(lp,lp_ele);\n            }\n            /* All fields are the same! We can compress the field names\n             * setting a single bit in the flags. */\n            if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n        }\n    }\n\n    /* Populate the listpack with the new entry. We use the following\n     * encoding:\n     *\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     *\n     * However if the SAMEFIELD flag is set, we have just to populate\n     * the entry with the values, so it becomes:\n     *\n     * +-----+--------+-------+-/-+-------+--------+\n     * |flags|entry-id|value-1|...|value-N|lp-count|\n     * +-----+--------+-------+-/-+-------+--------+\n     *\n     * The entry-id field is actually two separated fields: the ms\n     * and seq difference compared to the master entry.\n     *\n     * The lp-count field is a number that states the number of listpack pieces\n     * that compose the entry, so that it's possible to travel the entry\n     * in reverse order: we can just start from the end of the listpack, read\n     * the entry, and jump back N times to seek the \"flags\" field to read\n     * the stream full entry. */\n    lp = lpAppendInteger(lp,flags);\n    lp = lpAppendInteger(lp,id.ms - master_id.ms);\n    lp = lpAppendInteger(lp,id.seq - master_id.seq);\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n        lp = lpAppendInteger(lp,numfields);\n    for (int i = 0; i < numfields; i++) {\n        sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        lp = lpAppend(lp,(unsigned char*)value,sdslen(value));\n    }\n    /* Compute and store the lp-count field. */\n    int lp_count = numfields;\n    lp_count += 3; /* Add the 3 fixed fields flags + ms-diff + seq-diff. */\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n        /* If the item is not compressed, it also has the fields other than\n         * the values, and an additional num-fileds field. */\n        lp_count += numfields+1;\n    }\n    lp = lpAppendInteger(lp,lp_count);\n\n    /* Insert back into the tree in order to update the listpack pointer. */\n    raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n    s->length++;\n    s->last_id = id;\n    if (added_id) *added_id = id;\n    return C_OK;\n}\n\n/* Trim the stream 's' to have no more than maxlen elements, and return the\n * number of elements removed from the stream. The 'approx' option, if non-zero,\n * specifies that the trimming must be performed in a approximated way in\n * order to maximize performances. This means that the stream may contain\n * more elements than 'maxlen', and elements are only removed if we can remove\n * a *whole* node of the radix tree. The elements are removed from the head\n * of the stream (older elements).\n *\n * The function may return zero if:\n *\n * 1) The stream is already shorter or equal to the specified max length.\n * 2) The 'approx' option is true and the head node had not enough elements\n *    to be deleted, leaving the stream with a number of elements >= maxlen.\n */\nint64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {\n    if (s->length <= maxlen) return 0;\n\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"^\",NULL,0);\n\n    int64_t deleted = 0;\n    while(s->length > maxlen && raxNext(&ri)) {\n        unsigned char *lp = ri.data, *p = lpFirst(lp);\n        int64_t entries = lpGetInteger(p);\n\n        /* Check if we can remove the whole node, and still have at\n         * least maxlen elements. */\n        if (s->length - entries >= maxlen) {\n            lpFree(lp);\n            raxRemove(s->rax,ri.key,ri.key_len,NULL);\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            s->length -= entries;\n            deleted += entries;\n            continue;\n        }\n\n        /* If we cannot remove a whole element, and approx is true,\n         * stop here. */\n        if (approx) break;\n\n        /* Otherwise, we have to mark single entries inside the listpack\n         * as deleted. We start by updating the entries/deleted counters. */\n        int64_t to_delete = s->length - maxlen;\n        serverAssert(to_delete < entries);\n        lp = lpReplaceInteger(lp,&p,entries-to_delete);\n        p = lpNext(lp,p); /* Seek deleted field. */\n        int64_t marked_deleted = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,marked_deleted+to_delete);\n        p = lpNext(lp,p); /* Seek num-of-fields in the master entry. */\n\n        /* Skip all the master fields. */\n        int64_t master_fields_count = lpGetInteger(p);\n        p = lpNext(lp,p); /* Seek the first field. */\n        for (int64_t j = 0; j < master_fields_count; j++)\n            p = lpNext(lp,p); /* Skip all master fields. */\n        p = lpNext(lp,p); /* Skip the zero master entry terminator. */\n\n        /* 'p' is now pointing to the first entry inside the listpack.\n         * We have to run entry after entry, marking entries as deleted\n         * if they are already not deleted. */\n        while(p) {\n            int flags = lpGetInteger(p);\n            int to_skip;\n\n            /* Mark the entry as deleted. */\n            if (!(flags & STREAM_ITEM_FLAG_DELETED)) {\n                flags |= STREAM_ITEM_FLAG_DELETED;\n                lp = lpReplaceInteger(lp,&p,flags);\n                deleted++;\n                s->length--;\n                if (s->length <= maxlen) break; /* Enough entries deleted. */\n            }\n\n            p = lpNext(lp,p); /* Skip ID ms delta. */\n            p = lpNext(lp,p); /* Skip ID seq delta. */\n            p = lpNext(lp,p); /* Seek num-fields or values (if compressed). */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                to_skip = master_fields_count;\n            } else {\n                to_skip = lpGetInteger(p);\n                to_skip = 1+(to_skip*2);\n            }\n\n            while(to_skip--) p = lpNext(lp,p); /* Skip the whole entry. */\n            p = lpNext(lp,p); /* Skip the final lp-count field. */\n        }\n\n        /* Here we should perform garbage collection in case at this point\n         * there are too many entries deleted inside the listpack. */\n        entries -= to_delete;\n        marked_deleted += to_delete;\n        if (entries + marked_deleted > 10 && marked_deleted > entries/2) {\n            /* TODO: perform a garbage collection. */\n        }\n\n        /* Update the listpack with the new pointer. */\n        raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n\n        break; /* If we are here, there was enough to delete in the current\n                  node, so no need to go to the next node. */\n    }\n\n    raxStop(&ri);\n    return deleted;\n}\n\n/* Initialize the stream iterator, so that we can call iterating functions\n * to get the next items. This requires a corresponding streamIteratorStop()\n * at the end. The 'rev' parameter controls the direction. If it's zero the\n * iteration is from the start to the end element (inclusive), otherwise\n * if rev is non-zero, the iteration is reversed.\n *\n * Once the iterator is initalized, we iterate like this:\n *\n *  streamIterator myiterator;\n *  streamIteratorStart(&myiterator,...);\n *  int64_t numfields;\n *  while(streamIteratorGetID(&myiterator,&ID,&numfields)) {\n *      while(numfields--) {\n *          unsigned char *key, *value;\n *          size_t key_len, value_len;\n *          streamIteratorGetField(&myiterator,&key,&value,&key_len,&value_len);\n *\n *          ... do what you want with key and value ...\n *      }\n *  }\n *  streamIteratorStop(&myiterator); */\nvoid streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {\n    /* Intialize the iterator and translates the iteration start/stop\n     * elements into a 128 big big-endian number. */\n    if (start) {\n        streamEncodeID(si->start_key,start);\n    } else {\n        si->start_key[0] = 0;\n        si->start_key[0] = 0;\n    }\n\n    if (end) {\n        streamEncodeID(si->end_key,end);\n    } else {\n        si->end_key[0] = UINT64_MAX;\n        si->end_key[0] = UINT64_MAX;\n    }\n\n    /* Seek the correct node in the radix tree. */\n    raxStart(&si->ri,s->rax);\n    if (!rev) {\n        if (start && (start->ms || start->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->start_key,\n                    sizeof(si->start_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"^\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"^\",NULL,0);\n        }\n    } else {\n        if (end && (end->ms || end->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->end_key,\n                    sizeof(si->end_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"$\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"$\",NULL,0);\n        }\n    }\n    si->stream = s;\n    si->lp = NULL; /* There is no current listpack right now. */\n    si->lp_ele = NULL; /* Current listpack cursor. */\n    si->rev = rev;  /* Direction, if non-zero reversed, from end to start. */\n}\n\n/* Return 1 and store the current item ID at 'id' if there are still\n * elements within the iteration range, otherwise return 0 in order to\n * signal the iteration terminated. */\nint streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {\n    while(1) { /* Will stop when element > stop_key or end of radix tree. */\n        /* If the current listpack is set to NULL, this is the start of the\n         * iteration or the previous listpack was completely iterated.\n         * Go to the next node. */\n        if (si->lp == NULL || si->lp_ele == NULL) {\n            if (!si->rev && !raxNext(&si->ri)) return 0;\n            else if (si->rev && !raxPrev(&si->ri)) return 0;\n            serverAssert(si->ri.key_len == sizeof(streamID));\n            /* Get the master ID. */\n            streamDecodeID(si->ri.key,&si->master_id);\n            /* Get the master fields count. */\n            si->lp = si->ri.data;\n            si->lp_ele = lpFirst(si->lp);           /* Seek items count */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */\n            si->master_fields_count = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek first field. */\n            si->master_fields_start = si->lp_ele;\n            /* Skip master fileds to seek the first entry. */\n            for (uint64_t i = 0; i < si->master_fields_count; i++)\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            /* We are now pointing the zero term of the master entry. If\n             * we are iterating in reverse order, we need to seek the\n             * end of the listpack. */\n            if (si->rev) si->lp_ele = lpLast(si->lp);\n        } else if (si->rev) {\n            /* If we are itereating in the reverse order, and this is not\n             * the first entry emitted for this listpack, then we already\n             * emitted the current entry, and have to go back to the previous\n             * one. */\n            int lp_count = lpGetInteger(si->lp_ele);\n            while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            /* Seek lp-count of prev entry. */\n            si->lp_ele = lpPrev(si->lp,si->lp_ele);\n        }\n\n        /* For every radix tree node, iterate the corresponding listpack,\n         * returning elements when they are within range. */\n        while(1) {\n            if (!si->rev) {\n                /* If we are going forward, skip the previous entry\n                 * lp-count field (or in case of the master entry, the zero\n                 * term field) */\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n                if (si->lp_ele == NULL) break;\n            } else {\n                /* If we are going backward, read the number of elements this\n                 * entry is composed of, and jump backward N times to seek\n                 * its start. */\n                int lp_count = lpGetInteger(si->lp_ele);\n                if (lp_count == 0) { /* We reached the master entry. */\n                    si->lp = NULL;\n                    si->lp_ele = NULL;\n                    break;\n                }\n                while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n\n            /* Get the flags entry. */\n            si->lp_flags = si->lp_ele;\n            int flags = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek ID. */\n\n            /* Get the ID: it is encoded as difference between the master\n             * ID and this entry ID. */\n            *id = si->master_id;\n            id->ms += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            id->seq += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,id);\n\n            /* The number of entries is here or not depending on the\n             * flags. */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                *numfields = si->master_fields_count;\n            } else {\n                *numfields = lpGetInteger(si->lp_ele);\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            }\n\n            /* If current >= start, and the entry is not marked as\n             * deleted, emit it. */\n            if (!si->rev) {\n                if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&\n                    !(flags & STREAM_ITEM_FLAG_DELETED))\n                {\n                    if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            } else {\n                if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&\n                    !(flags & STREAM_ITEM_FLAG_DELETED))\n                {\n                    if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            }\n\n            /* If we do not emit, we have to discard if we are going\n             * forward, or seek the previous entry if we are going\n             * backward. */\n            if (!si->rev) {\n                int to_discard = (flags & STREAM_ITEM_FLAG_SAMEFIELDS) ?\n                                    *numfields : *numfields*2;\n                for (int64_t i = 0; i < to_discard; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                int prev_times = 4; /* flag + id ms/seq diff + numfields. */\n                while(prev_times--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n        }\n\n        /* End of listpack reached. Try the next/prev radix tree node. */\n    }\n}\n\n/* Get the field and value of the current item we are iterating. This should\n * be called immediately after streamIteratorGetID(), and for each field\n * according to the number of fields returned by streamIteratorGetID().\n * The function populates the field and value pointers and the corresponding\n * lengths by reference, that are valid until the next iterator call, assuming\n * no one touches the stream meanwhile. */\nvoid streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {\n    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);\n        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);\n    } else {\n        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);\n        si->lp_ele = lpNext(si->lp,si->lp_ele);\n    }\n    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);\n    si->lp_ele = lpNext(si->lp,si->lp_ele);\n}\n\n/* Remove the current entry from the stream: can be called after the\n * GetID() API or after any GetField() call, however we need to iterate\n * a valid entry while calling this function. Moreover the function\n * requires the entry ID we are currently iterating, that was previously\n * returned by GetID().\n *\n * Note that after calling this function, next calls to GetField() can't\n * be performed: the entry is now deleted. Instead the iterator will\n * automatically re-seek to the next entry, so the caller should continue\n * with GetID(). */\nvoid streamIteratorRemoveEntry(streamIterator *si, streamID *current) {\n    unsigned char *lp = si->lp;\n    int64_t aux;\n\n    /* We do not really delete the entry here. Instead we mark it as\n     * deleted flagging it, and also incrementing the count of the\n     * deleted entries in the listpack header.\n     *\n     * We start flagging: */\n    int flags = lpGetInteger(si->lp_flags);\n    flags |= STREAM_ITEM_FLAG_DELETED;\n    lp = lpReplaceInteger(lp,&si->lp_flags,flags);\n\n    /* Change the valid/deleted entries count in the master entry. */\n    unsigned char *p = lpFirst(lp);\n    aux = lpGetInteger(p);\n    lp = lpReplaceInteger(lp,&p,aux-1);\n    p = lpNext(lp,p); /* Seek deleted field. */\n    aux = lpGetInteger(p);\n    lp = lpReplaceInteger(lp,&p,aux+1);\n\n    /* Update the number of entries counter. */\n    si->stream->length--;\n\n    /* Re-seek the iterator to fix the now messed up state. */\n    streamID start, end;\n    if (si->rev) {\n        streamDecodeID(si->start_key,&start);\n        end = *current;\n    } else {\n        start = *current;\n        streamDecodeID(si->end_key,&end);\n    }\n    streamIteratorStop(si);\n    streamIteratorStart(si,si->stream,&start,&end,si->rev);\n\n    /* TODO: perform a garbage collection here if the ration between\n     * deleted and valid goes over a certain limit. */\n}\n\n/* Stop the stream iterator. The only cleanup we need is to free the rax\n * itereator, since the stream iterator itself is supposed to be stack\n * allocated. */\nvoid streamIteratorStop(streamIterator *si) {\n    raxStop(&si->ri);\n}\n\n/* Delete the specified item ID from the stream, returning 1 if the item\n * was deleted 0 otherwise (if it does not exist). */\nint streamDeleteItem(stream *s, streamID *id) {\n    int deleted = 0;\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    if (streamIteratorGetID(&si,&myid,&numfields)) {\n        streamIteratorRemoveEntry(&si,&myid);\n        deleted = 1;\n    }\n    return deleted;\n}\n\n/* Emit a reply in the client output buffer by formatting a Stream ID\n * in the standard <ms>-<seq> format, using the simple string protocol\n * of REPL. */\nvoid addReplyStreamID(client *c, streamID *id) {\n    sds replyid = sdscatfmt(sdsempty(),\"+%U-%U\\r\\n\",id->ms,id->seq);\n    addReplySds(c,replyid);\n}\n\n/* Similar to the above function, but just creates an object, usually useful\n * for replication purposes to create arguments. */\nrobj *createObjectFromStreamID(streamID *id) {\n    return createObject(OBJ_STRING, sdscatfmt(sdsempty(),\"%U-%U\",\n                        id->ms,id->seq));\n}\n\n/* As a result of an explicit XCLAIM or XREADGROUP command, new entries\n * are created in the pending list of the stream and consumers. We need\n * to propagate this changes in the form of XCLAIM commands. */\nvoid streamPropagateXCLAIM(client *c, robj *key, robj *group, robj *id, streamNACK *nack) {\n    /* We need to generate an XCLAIM that will work in a idempotent fashion:\n     *\n     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>\n     *        RETRYCOUNT <count> FORCE JUSTID.\n     *\n     * Note that JUSTID is useful in order to avoid that XCLAIM will do\n     * useless work in the slave side, trying to fetch the stream item. */\n    robj *argv[12];\n    argv[0] = createStringObject(\"XCLAIM\",6);\n    argv[1] = key;\n    argv[2] = group;\n    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));\n    argv[4] = createStringObjectFromLongLong(0);\n    argv[5] = id;\n    argv[6] = createStringObject(\"TIME\",4);\n    argv[7] = createStringObjectFromLongLong(nack->delivery_time);\n    argv[8] = createStringObject(\"RETRYCOUNT\",10);\n    argv[9] = createStringObjectFromLongLong(nack->delivery_count);\n    argv[10] = createStringObject(\"FORCE\",5);\n    argv[11] = createStringObject(\"JUSTID\",6);\n    propagate(server.xclaimCommand,c->db->id,argv,12,PROPAGATE_AOF|PROPAGATE_REPL);\n    decrRefCount(argv[0]);\n    decrRefCount(argv[3]);\n    decrRefCount(argv[4]);\n    decrRefCount(argv[6]);\n    decrRefCount(argv[7]);\n    decrRefCount(argv[8]);\n    decrRefCount(argv[9]);\n    decrRefCount(argv[10]);\n    decrRefCount(argv[11]);\n}\n\n/* Send the specified range to the client 'c'. The range the client will\n * receive is between start and end inclusive, if 'count' is non zero, no more\n * than 'count' elemnets are sent. The 'end' pointer can be NULL to mean that\n * we want all the elements from 'start' till the end of the stream. If 'rev'\n * is non zero, elements are produced in reversed order from end to start.\n *\n * If group and consumer are not NULL, the function performs additional work:\n * 1. It updates the last delivered ID in the group in case we are\n *    sending IDs greater than the current last ID.\n * 2. If the requested IDs are already assigned to some other consumer, the\n *    function will not return it to the client.\n * 3. An entry in the pending list will be created for every entry delivered\n *    for the first time to this consumer.\n *\n * The behavior may be modified passing non-zero flags:\n *\n * STREAM_RWR_NOACK: Do not craete PEL entries, that is, the point \"3\" above\n *                   is not performed.\n * STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,\n *                        and return the number of entries emitted as usually.\n *                        This is used when the function is just used in order\n *                        to emit data and there is some higher level logic.\n *\n * The final argument 'spi' (stream propagatino info pointer) is a structure\n * filled with information needed to propagte the command execution to AOF\n * and slaves, in the case a consumer group was passed: we need to generate\n * XCLAIM commands to create the pending list into AOF/slaves in that case.\n *\n * If 'spi' is set to NULL no propagation will happen even if the group was\n * given, but currently such a feature is never used by the code base that\n * will always pass 'spi' and propagate when a group is passed.\n *\n * Note that this function is recursive in certian cases. When it's called\n * with a non NULL group and consumer argument, it may call\n * streamReplyWithRangeFromConsumerPEL() in order to get entries from the\n * consumer pending entries list. However such a function will then call\n * streamReplyWithRange() in order to emit single entries (found in the\n * PEL by ID) to the client. This is the use case for the STREAM_RWR_RAWENTRIES\n * flag.\n */\n#define STREAM_RWR_NOACK (1<<0)         /* Do not create entries in the PEL. */\n#define STREAM_RWR_RAWENTRIES (1<<1)    /* Do not emit protocol for array\n                                           boundaries, just the entries. */\nsize_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {\n    void *arraylen_ptr = NULL;\n    size_t arraylen = 0;\n    streamIterator si;\n    int64_t numfields;\n    streamID id;\n\n    /* If a group was passed, we check if the request is about messages\n     * never delivered so far (normally this happens when \">\" ID is passed).\n     *\n     * If instead the client is asking for some history, we serve it\n     * using a different function, so that we return entries *solely*\n     * from its own PEL. This ensures each consumer will always and only\n     * see the history of messages delivered to it and not yet confirmed\n     * as delivered. */\n    if (group && streamCompareID(start,&group->last_id) <= 0) {\n        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,\n                                                   consumer);\n    }\n\n    if (!(flags & STREAM_RWR_RAWENTRIES))\n        arraylen_ptr = addDeferredMultiBulkLength(c);\n    streamIteratorStart(&si,s,start,end,rev);\n    while(streamIteratorGetID(&si,&id,&numfields)) {\n        /* Update the group last_id if needed. */\n        if (group && streamCompareID(&id,&group->last_id) > 0)\n            group->last_id = id;\n\n        /* Emit a two elements array for each item. The first is\n         * the ID, the second is an array of field-value pairs. */\n        addReplyMultiBulkLen(c,2);\n        addReplyStreamID(c,&id);\n        addReplyMultiBulkLen(c,numfields*2);\n\n        /* Emit the field-value pairs. */\n        while(numfields--) {\n            unsigned char *key, *value;\n            int64_t key_len, value_len;\n            streamIteratorGetField(&si,&key,&value,&key_len,&value_len);\n            addReplyBulkCBuffer(c,key,key_len);\n            addReplyBulkCBuffer(c,value,value_len);\n        }\n\n        /* If a group is passed, we need to create an entry in the\n         * PEL (pending entries list) of this group *and* this consumer.\n         *\n         * Note that we cannot be sure about the fact the message is not\n         * already owned by another consumer, because the admin is able\n         * to change the consumer group last delivered ID using the\n         * XGROUP SETID command. So if we find that there is already\n         * a NACK for the entry, we need to associate it to the new\n         * consumer. */\n        if (group && !(flags & STREAM_RWR_NOACK)) {\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,&id);\n\n            /* Try to add a new NACK. Most of the time this will work and\n             * will not require extra lookups. We'll fix the problem later\n             * if we find that there is already a entry for this ID. */\n            streamNACK *nack = streamCreateNACK(consumer);\n            int retval = 0;\n            retval += raxTryInsert(group->pel,buf,sizeof(buf),nack,NULL);\n            retval += raxTryInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n\n            /* Now we can check if the entry was already busy, and\n             * in that case reassign the entry to the new consumer. */\n            if (retval == 0) {\n                streamFreeNACK(nack);\n                nack = raxFind(group->pel,buf,sizeof(buf));\n                serverAssert(nack != raxNotFound);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                /* Update the consumer and idle time. */\n                nack->consumer = consumer;\n                nack->delivery_time = mstime();\n                nack->delivery_count++;\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            } else if (retval == 1) {\n                serverPanic(\"NACK half-created. Should not be possible.\");\n            }\n\n            /* Propagate as XCLAIM. */\n            if (spi) {\n                robj *idarg = createObjectFromStreamID(&id);\n                streamPropagateXCLAIM(c,spi->keyname,spi->groupname,idarg,nack);\n                decrRefCount(idarg);\n            }\n        }\n\n        arraylen++;\n        if (count && count == arraylen) break;\n    }\n    streamIteratorStop(&si);\n    if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* This is an helper function for streamReplyWithRange() when called with\n * group and consumer arguments, but with a range that is referring to already\n * delivered messages. In this case we just emit messages that are already\n * in the history of the conusmer, fetching the IDs from its PEL.\n *\n * Note that this function does not have a 'rev' argument because it's not\n * possible to iterate in reverse using a group. Basically this function\n * is only called as a result of the XREADGROUP command.\n *\n * This function is more expensive because it needs to inspect the PEL and then\n * seek into the radix tree of the messages in order to emit the full message\n * to the client. However clients only reach this code path when they are\n * fetching the history of already retrieved messages, which is rare. */\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {\n    raxIterator ri;\n    unsigned char startkey[sizeof(streamID)];\n    unsigned char endkey[sizeof(streamID)];\n    streamEncodeID(startkey,start);\n    if (end) streamEncodeID(endkey,end);\n\n    size_t arraylen = 0;\n    void *arraylen_ptr = addDeferredMultiBulkLength(c);\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    while(raxNext(&ri) && (!count || arraylen < count)) {\n        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;\n        streamID thisid;\n        streamDecodeID(ri.key,&thisid);\n        if (streamReplyWithRange(c,s,&thisid,NULL,1,0,NULL,NULL,\n                                 STREAM_RWR_RAWENTRIES,NULL) == 0)\n        {\n            /* Note that we may have a not acknowledged entry in the PEL\n             * about a message that's no longer here because was removed\n             * by the user by other means. In that case we signal it emitting\n             * the ID but then a NULL entry for the fields. */\n            addReplyMultiBulkLen(c,2);\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n            addReply(c,shared.nullmultibulk);\n        } else {\n            streamNACK *nack = ri.data;\n            nack->delivery_time = mstime();\n            nack->delivery_count++;\n        }\n        arraylen++;\n    }\n    raxStop(&ri);\n    setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* -----------------------------------------------------------------------\n * Stream commands implementation\n * ----------------------------------------------------------------------- */\n\n/* Look the stream at 'key' and return the corresponding stream object.\n * The function creates a key setting it to an empty stream if needed. */\nrobj *streamTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (o == NULL) {\n        o = createStreamObject();\n        dbAdd(c->db,key,o);\n    } else {\n        if (o->type != OBJ_STREAM) {\n            addReply(c,shared.wrongtypeerr);\n            return NULL;\n        }\n    }\n    return o;\n}\n\n/* Helper function to convert a string to an unsigned long long value.\n * The function attempts to use the faster string2ll() function inside\n * Redis: if it fails, strtoull() is used instead. The function returns\n * 1 if the conversion happened successfully or 0 if the number is\n * invalid or out of range. */\nint string2ull(const char *s, unsigned long long *value) {\n    long long ll;\n    if (string2ll(s,strlen(s),&ll)) {\n        if (ll < 0) return 0; /* Negative values are out of range. */\n        *value = ll;\n        return 1;\n    }\n    errno = 0;\n    char *endptr = NULL;\n    *value = strtoull(s,&endptr,10);\n    if (errno == EINVAL || errno == ERANGE || !(*s != '\\0' && *endptr == '\\0'))\n        return 0; /* strtoull() failed. */\n    return 1; /* Conversion done! */\n}\n\n/* Parse a stream ID in the format given by clients to Redis, that is\n * <ms>-<seq>, and converts it into a streamID structure. If\n * the specified ID is invalid C_ERR is returned and an error is reported\n * to the client, otherwise C_OK is returned. The ID may be in incomplete\n * form, just stating the milliseconds time part of the stream. In such a case\n * the missing part is set according to the value of 'missing_seq' parameter.\n * The IDs \"-\" and \"+\" specify respectively the minimum and maximum IDs\n * that can be represented.\n *\n * If 'c' is set to NULL, no reply is sent to the client. */\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {\n    char buf[128];\n    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;\n    memcpy(buf,o->ptr,sdslen(o->ptr)+1);\n\n    /* Handle the \"-\" and \"+\" special cases. */\n    if (buf[0] == '-' && buf[1] == '\\0') {\n        id->ms = 0;\n        id->seq = 0;\n        return C_OK;\n    } else if (buf[0] == '+' && buf[1] == '\\0') {\n        id->ms = UINT64_MAX;\n        id->seq = UINT64_MAX;\n        return C_OK;\n    }\n\n    /* Parse <ms>-<seq> form. */\n    char *dot = strchr(buf,'-');\n    if (dot) *dot = '\\0';\n    unsigned long long ms, seq;\n    if (string2ull(buf,&ms) == 0) goto invalid;\n    if (dot && string2ull(dot+1,&seq) == 0) goto invalid;\n    if (!dot) seq = missing_seq;\n    id->ms = ms;\n    id->seq = seq;\n    return C_OK;\n\ninvalid:\n    if (c) addReplyError(c,\"Invalid stream ID specified as stream \"\n                           \"command argument\");\n    return C_ERR;\n}\n\n/* XADD key [MAXLEN <count>] <ID or *> [field value] [field value] ... */\nvoid xaddCommand(client *c) {\n    streamID id;\n    int id_given = 0; /* Was an ID different than \"*\" specified? */\n    long long maxlen = 0;   /* 0 means no maximum length. */\n    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so\n                               the maxium length is not applied verbatim. */\n    int maxlen_arg_idx = 0; /* Index of the count in MAXLEN, for rewriting. */\n\n    /* Parse options. */\n    int i = 2; /* This is the first argument position where we could\n                  find an option, or the ID. */\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (opt[0] == '*' && opt[1] == '\\0') {\n            /* This is just a fast path for the common case of auto-ID\n             * creation. */\n            break;\n        } else if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                approx_maxlen = 1;\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)\n                != C_OK) return;\n            i++;\n            maxlen_arg_idx = i;\n        } else {\n            /* If we are here is a syntax error or a valid ID. */\n            if (streamParseIDOrReply(c,c->argv[i],&id,0) != C_OK) return;\n            id_given = 1;\n            break;\n        }\n    }\n    int field_pos = i+1;\n\n    /* Check arity. */\n    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {\n        addReplyError(c,\"wrong number of arguments for XADD\");\n        return;\n    }\n\n    /* Lookup the stream at key. */\n    robj *o;\n    stream *s;\n    if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    s = o->ptr;\n\n    /* Append using the low level function and return the ID. */\n    if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,\n        &id, id_given ? &id : NULL)\n        == C_ERR)\n    {\n        addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"\n                        \"target stream top item\");\n        return;\n    }\n    addReplyStreamID(c,&id);\n\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xadd\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Remove older elements if MAXLEN was specified. */\n    if (maxlen) {\n        if (!streamTrimByLength(s,maxlen,approx_maxlen)) {\n            /* If no trimming was performed, for instance because approximated\n             * trimming length was specified, rewrite the MAXLEN argument\n             * as zero, so that the command is propagated without trimming. */\n            robj *zeroobj = createStringObjectFromLongLong(0);\n            rewriteClientCommandArgument(c,maxlen_arg_idx,zeroobj);\n            decrRefCount(zeroobj);\n        } else {\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        }\n    }\n\n    /* Let's rewrite the ID argument with the one actually generated for\n     * AOF/replication propagation. */\n    robj *idarg = createObjectFromStreamID(&id);\n    rewriteClientCommandArgument(c,i,idarg);\n    decrRefCount(idarg);\n\n    /* We need to signal to blocked clients that there is new data on this\n     * stream. */\n    if (server.blocked_clients_by_type[BLOCKED_STREAM])\n        signalKeyAsReady(c->db, c->argv[1]);\n}\n\n/* XRANGE/XREVRANGE actual implementation. */\nvoid xrangeGenericCommand(client *c, int rev) {\n    robj *o;\n    stream *s;\n    streamID startid, endid;\n    long long count = 0;\n    robj *startarg = rev ? c->argv[3] : c->argv[2];\n    robj *endarg = rev ? c->argv[2] : c->argv[3];\n\n    if (streamParseIDOrReply(c,startarg,&startid,0) == C_ERR) return;\n    if (streamParseIDOrReply(c,endarg,&endid,UINT64_MAX) == C_ERR) return;\n\n    /* Parse the COUNT option if any. */\n    if (c->argc > 4) {\n        for (int j = 4; j < c->argc; j++) {\n            int additional = c->argc-j-1;\n            if (strcasecmp(c->argv[j]->ptr,\"COUNT\") == 0 && additional >= 1) {\n                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)\n                    != C_OK) return;\n                if (count < 0) count = 0;\n                j++; /* Consume additional arg. */\n            } else {\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Return the specified range to the user. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    s = o->ptr;\n    streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);\n}\n\n/* XRANGE key start end [COUNT <n>] */\nvoid xrangeCommand(client *c) {\n    xrangeGenericCommand(c,0);\n}\n\n/* XREVRANGE key end start [COUNT <n>] */\nvoid xrevrangeCommand(client *c) {\n    xrangeGenericCommand(c,1);\n}\n\n/* XLEN */\nvoid xlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n    addReplyLongLong(c,s->length);\n}\n\n/* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N\n *       ID_1 ID_2 ... ID_N\n *\n * This function also implements the XREAD-GROUP command, which is like XREAD\n * but accepting the [GROUP group-name consumer-name] additional option.\n * This is useful because while XREAD is a read command and can be called\n * on slaves, XREAD-GROUP is not. */\n#define XREAD_BLOCKED_DEFAULT_COUNT 1000\nvoid xreadCommand(client *c) {\n    long long timeout = -1; /* -1 means, no BLOCK argument given. */\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;          /* True if NOACK option was specified. */\n    #define STREAMID_STATIC_VECTOR_LEN 8\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    streamCG **groups = NULL;\n    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */\n    robj *groupname = NULL;\n    robj *consumername = NULL;\n\n    /* Parse arguments. */\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc-i-1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o,\"BLOCK\") && moreargs) {\n            i++;\n            if (getTimeoutFromObjectOrReply(c,c->argv[i],&timeout,\n                UNIT_MILLISECONDS) != C_OK) return;\n        } else if (!strcasecmp(o,\"COUNT\") && moreargs) {\n            i++;\n            if (getLongLongFromObjectOrReply(c,c->argv[i],&count,NULL) != C_OK)\n                return;\n            if (count < 0) count = 0;\n        } else if (!strcasecmp(o,\"STREAMS\") && moreargs) {\n            streams_arg = i+1;\n            streams_count = (c->argc-streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c,\"Unbalanced XREAD list of streams: \"\n                                \"for each stream key an ID or '$' must be \"\n                                \"specified.\");\n                return;\n            }\n            streams_count /= 2; /* We have two arguments for each stream. */\n            break;\n        } else if (!strcasecmp(o,\"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The GROUP option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i+1];\n            consumername = c->argv[i+2];\n            i += 2;\n        } else if (!strcasecmp(o,\"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The NOACK option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* STREAMS option is mandatory. */\n    if (streams_arg == 0) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* If the user specified XREADGROUP then it must also\n     * provide the GROUP option. */\n    if (xreadgroup && groupname == NULL) {\n        addReplyError(c,\"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n\n    /* Parse the IDs and resolve the group name. */\n    if (streams_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*streams_count);\n    if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);\n\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        /* Specifying \"$\" as last-known-id means that the client wants to be\n         * served with just the messages that will arrive into the stream\n         * starting from now. */\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i-streams_count];\n        robj *o;\n        streamCG *group = NULL;\n\n        /* If a group was specified, than we need to be sure that the\n         * key and group actually exist. */\n        if (groupname) {\n            o = lookupKeyRead(c->db,key);\n            if (o && checkType(c,o,OBJ_STREAM)) goto cleanup;\n            if (o == NULL ||\n                (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n            {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                                       \"group '%s' in XREADGROUP with GROUP \"\n                                       \"option\",\n                                    (char*)key->ptr,(char*)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n\n        if (strcmp(c->argv[i]->ptr,\"$\") == 0) {\n            o = lookupKeyRead(c->db,key);\n            if (o && checkType(c,o,OBJ_STREAM)) goto cleanup;\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = s->last_id;\n            } else {\n                ids[id_idx].ms = 0;\n                ids[id_idx].seq = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr,\">\") == 0) {\n            if (!xreadgroup || groupname == NULL) {\n                addReplyError(c,\"The > ID can be specified only when calling \"\n                                \"XREADGROUP using the GROUP <group> \"\n                                \"<consumer> option.\");\n                goto cleanup;\n            }\n            ids[id_idx] = group->last_id;\n            continue;\n        }\n        if (streamParseIDOrReply(c,c->argv[i],ids+id_idx,0) != C_OK)\n            goto cleanup;\n    }\n\n    /* Try to serve the client synchronously. */\n    size_t arraylen = 0;\n    void *arraylen_ptr = NULL;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db,c->argv[streams_arg+i]);\n        if (o == NULL) continue;\n        stream *s = o->ptr;\n        streamID *gt = ids+i; /* ID must be greater than this. */\n        if (s->last_id.ms > gt->ms ||\n            (s->last_id.ms == gt->ms && s->last_id.seq > gt->seq))\n        {\n            arraylen++;\n            if (arraylen == 1) arraylen_ptr = addDeferredMultiBulkLength(c);\n            /* streamReplyWithRange() handles the 'start' ID as inclusive,\n             * so start from the next ID, since we want only messages with\n             * IDs greater than start. */\n            streamID start = *gt;\n            start.seq++; /* uint64_t can't overflow in this context. */\n\n            /* Emit the two elements sub-array consisting of the name\n             * of the stream and the data we extracted from it. */\n            addReplyMultiBulkLen(c,2);\n            addReplyBulk(c,c->argv[i+streams_arg]);\n            streamConsumer *consumer = NULL;\n            if (groups) consumer = streamLookupConsumer(groups[i],\n                                                        consumername->ptr,1);\n            streamPropInfo spi = {c->argv[i+streams_arg],groupname};\n            streamReplyWithRange(c,s,&start,NULL,count,0,\n                                 groups ? groups[i] : NULL,\n                                 consumer, noack, &spi);\n            if (groups) server.dirty++;\n        }\n    }\n\n     /* We replied synchronously! Set the top array len and return to caller. */\n    if (arraylen) {\n        setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n        goto cleanup;\n    }\n\n    /* Block if needed. */\n    if (timeout != -1) {\n        /* If we are inside a MULTI/EXEC and the list is empty the only thing\n         * we can do is treating it as a timeout (even with timeout 0). */\n        if (c->flags & CLIENT_MULTI) {\n            addReply(c,shared.nullmultibulk);\n            goto cleanup;\n        }\n        blockForKeys(c, BLOCKED_STREAM, c->argv+streams_arg, streams_count,\n                     timeout, NULL, ids);\n        /* If no COUNT is given and we block, set a relatively small count:\n         * in case the ID provided is too low, we do not want the server to\n         * block just to serve this client a huge stream of messages. */\n        c->bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;\n\n        /* If this is a XREADGROUP + GROUP we need to remember for which\n         * group and consumer name we are blocking, so later when one of the\n         * keys receive more data, we can call streamReplyWithRange() passing\n         * the right arguments. */\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            c->bpop.xread_group = groupname;\n            c->bpop.xread_consumer = consumername;\n        } else {\n            c->bpop.xread_group = NULL;\n            c->bpop.xread_consumer = NULL;\n        }\n        goto cleanup;\n    }\n\n    /* No BLOCK option, nor any stream we can serve. Reply as with a\n     * timeout happened. */\n    addReply(c,shared.nullmultibulk);\n    /* Continue to cleanup... */\n\ncleanup: /* Cleanup. */\n\n    /* The command is propagated (in the READGROUP form) as a side effect\n     * of calling lower level APIs. So stop any implicit propagation. */\n    preventCommandPropagation(c);\n    if (ids != static_ids) zfree(ids);\n    zfree(groups);\n}\n\n/* -----------------------------------------------------------------------\n * Low level implementation of consumer groups\n * ----------------------------------------------------------------------- */\n\n/* Create a NACK entry setting the delivery count to 1 and the delivery\n * time to the current time. The NACK consumer will be set to the one\n * specified as argument of the function. */\nstreamNACK *streamCreateNACK(streamConsumer *consumer) {\n    streamNACK *nack = zmalloc(sizeof(*nack));\n    nack->delivery_time = mstime();\n    nack->delivery_count = 1;\n    nack->consumer = consumer;\n    return nack;\n}\n\n/* Free a NACK entry. */\nvoid streamFreeNACK(streamNACK *na) {\n    zfree(na);\n}\n\n/* Free a consumer and associated data structures. Note that this function\n * will not reassign the pending messages associated with this consumer\n * nor will delete them from the stream, so when this function is called\n * to delete a consumer, and not when the whole stream is destroyed, the caller\n * should do some work before. */\nvoid streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); /* No value free callback: the PEL entries are shared\n                         between the consumer and the main stream PEL. */\n    sdsfree(sc->name);\n    zfree(sc);\n}\n\n/* Create a new consumer group in the context of the stream 's', having the\n * specified name and last server ID. If a consumer group with the same name\n * already existed NULL is returned, otherwise the pointer to the consumer\n * group is returned. */\nstreamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n\n/* Free a consumer group and all its associated data. */\nvoid streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n\n/* Lookup the consumer group in the specified stream and returns its\n * pointer, otherwise if there is no such group, NULL is returned. */\nstreamCG *streamLookupCG(stream *s, sds groupname) {\n    if (s->cgroups == NULL) return NULL;\n    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,\n                           sdslen(groupname));\n    return (cg == raxNotFound) ? NULL : cg;\n}\n\n/* Lookup the consumer with the specified name in the group 'cg': if the\n * consumer does not exist it is automatically created as a side effect\n * of calling this function, otherwise its last seen time is updated and\n * the existing consumer reference returned. */\nstreamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                               sdslen(name));\n    if (consumer == raxNotFound) {\n        if (!create) return NULL;\n        consumer = zmalloc(sizeof(*consumer));\n        consumer->name = sdsdup(name);\n        consumer->pel = raxNew();\n        raxInsert(cg->consumers,(unsigned char*)name,sdslen(name),\n                  consumer,NULL);\n    }\n    consumer->seen_time = mstime();\n    return consumer;\n}\n\n/* Delete the consumer specified in the consumer group 'cg'. The consumer\n * may have pending messages: they are removed from the PEL, and the number\n * of pending messages \"lost\" is returned. */\nuint64_t streamDelConsumer(streamCG *cg, sds name) {\n    streamConsumer *consumer = streamLookupConsumer(cg,name,0);\n    if (consumer == NULL) return 0;\n\n    uint64_t retval = raxSize(consumer->pel);\n\n    /* Iterate all the consumer pending messages, deleting every corresponding\n     * entry from the global entry. */\n    raxIterator ri;\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n        raxRemove(cg->pel,ri.key,ri.key_len,NULL);\n        streamFreeNACK(nack);\n    }\n    raxStop(&ri);\n\n    /* Deallocate the consumer. */\n    raxRemove(cg->consumers,(unsigned char*)name,sdslen(name),NULL);\n    streamFreeConsumer(consumer);\n    return retval;\n}\n\n/* -----------------------------------------------------------------------\n * Consumer groups commands\n * ----------------------------------------------------------------------- */\n\n/* XGROUP CREATE <key> <groupname> <id or $>\n * XGROUP SETID <key> <id or $>\n * XGROUP DELGROUP <key> <groupname>\n * XGROUP DELCONSUMER <key> <groupname> <consumername> */\nvoid xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}\n\n/* XACK <key> <group> <id> <id> ... <id>\n *\n * Acknowledge a message as processed. In practical terms we just check the\n * pendine entries list (PEL) of the group, and delete the PEL entry both from\n * the group and the consumer (pending messages are referenced in both places).\n *\n * Return value of the command is the number of messages successfully\n * acknowledged, that is, the IDs we were actually able to resolve in the PEL.\n */\nvoid xackCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Nothing to ack. */\n    if (o == NULL || group == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        streamID id;\n        unsigned char buf[sizeof(streamID)];\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL: it will have a reference to the\n         * NACK structure that will have a reference to the consumer, so that\n         * we are able to remove the entry from both PELs. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n        if (nack != raxNotFound) {\n            raxRemove(group->pel,buf,sizeof(buf),NULL);\n            raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c,acknowledged);\n}\n\n/* XPENDING <key> <group> [<start> <stop> <count>] [<consumer>]\n *\n * If start and stop are omitted, the command just outputs information about\n * the amount of pending messages for the key/group pair, together with\n * the minimum and maxium ID of pending messages.\n *\n * If start and stop are provided instead, the pending messages are returned\n * with informations about the current owner, number of deliveries and last\n * delivery time and so forth. */\nvoid xpendingCommand(client *c) {\n    int justinfo = c->argc == 3; /* Without the range just outputs general\n                                    informations about the PEL. */\n    robj *key = c->argv[1];\n    robj *groupname = c->argv[2];\n    robj *consumername = (c->argc == 7) ? c->argv[6] : NULL;\n    streamID startid, endid;\n    long long count;\n\n    /* Start and stop, and the consumer, can be omitted. */\n    if (c->argc != 3 && c->argc != 6 && c->argc != 7) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Parse start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (c->argc >= 6) {\n        if (getLongLongFromObjectOrReply(c,c->argv[5],&count,NULL) == C_ERR)\n            return;\n        if (streamParseIDOrReply(c,c->argv[3],&startid,0) == C_ERR)\n            return;\n        if (streamParseIDOrReply(c,c->argv[4],&endid,UINT64_MAX) == C_ERR)\n            return;\n    }\n\n    /* Lookup the key and the group inside the stream. */\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    streamCG *group;\n\n    if (o && checkType(c,o,OBJ_STREAM)) return;\n    if (o == NULL ||\n        (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n    {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                               \"group '%s'\",\n                               (char*)key->ptr,(char*)groupname->ptr);\n        return;\n    }\n\n    /* XPENDING <key> <group> variant. */\n    if (justinfo) {\n        addReplyMultiBulkLen(c,4);\n        /* Total number of messages in the PEL. */\n        addReplyLongLong(c,raxSize(group->pel));\n        /* First and last IDs. */\n        if (raxSize(group->pel) == 0) {\n            addReply(c,shared.nullbulk); /* Start. */\n            addReply(c,shared.nullbulk); /* End. */\n            addReply(c,shared.nullmultibulk); /* Clients. */\n        } else {\n            /* Start. */\n            raxIterator ri;\n            raxStart(&ri,group->pel);\n            raxSeek(&ri,\"^\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&startid);\n            addReplyStreamID(c,&startid);\n\n            /* End. */\n            raxSeek(&ri,\"$\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&endid);\n            addReplyStreamID(c,&endid);\n            raxStop(&ri);\n\n            /* Consumers with pending messages. */\n            raxStart(&ri,group->consumers);\n            raxSeek(&ri,\"^\",NULL,0);\n            void *arraylen_ptr = addDeferredMultiBulkLength(c);\n            size_t arraylen = 0;\n            while(raxNext(&ri)) {\n                streamConsumer *consumer = ri.data;\n                if (raxSize(consumer->pel) == 0) continue;\n                addReplyMultiBulkLen(c,2);\n                addReplyBulkCBuffer(c,ri.key,ri.key_len);\n                addReplyBulkLongLong(c,raxSize(consumer->pel));\n                arraylen++;\n            }\n            setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n            raxStop(&ri);\n        }\n    }\n    /* XPENDING <key> <group> <start> <stop> <count> [<consumer>] variant. */\n    else {\n        streamConsumer *consumer = consumername ?\n                                streamLookupConsumer(group,consumername->ptr,0):\n                                NULL;\n\n        /* If a consumer name was mentioned but it does not exist, we can\n         * just return an empty array. */\n        if (consumername && consumer == NULL) {\n            addReplyMultiBulkLen(c,0);\n            return;\n        }\n\n        rax *pel = consumer ? consumer->pel : group->pel;\n        unsigned char startkey[sizeof(streamID)];\n        unsigned char endkey[sizeof(streamID)];\n        raxIterator ri;\n        mstime_t now = mstime();\n\n        streamEncodeID(startkey,&startid);\n        streamEncodeID(endkey,&endid);\n        raxStart(&ri,pel);\n        raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n        void *arraylen_ptr = addDeferredMultiBulkLength(c);\n        size_t arraylen = 0;\n\n        while(count && raxNext(&ri) && memcmp(ri.key,endkey,ri.key_len) <= 0) {\n            streamNACK *nack = ri.data;\n\n            arraylen++;\n            count--;\n            addReplyMultiBulkLen(c,4);\n\n            /* Entry ID. */\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n\n            /* Consumer name. */\n            addReplyBulkCBuffer(c,nack->consumer->name,\n                                sdslen(nack->consumer->name));\n\n            /* Milliseconds elapsed since last delivery. */\n            mstime_t elapsed = now - nack->delivery_time;\n            if (elapsed < 0) elapsed = 0;\n            addReplyLongLong(c,elapsed);\n\n            /* Number of deliveries. */\n            addReplyLongLong(c,nack->delivery_count);\n        }\n        raxStop(&ri);\n        setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    }\n}\n\n/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>\n *        [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]\n *        [FORCE] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * If the message ID (among the specified ones) exists, and its idle\n * time greater or equal to <min-idle-time>, then the message new owner\n * becomes the specified <consumer>. If the minimum idle time specified\n * is zero, messages are claimed regardless of their idle time.\n *\n * All the messages that cannot be found inside the pending entries list\n * are ignored, but in case the FORCE option is used. In that case we\n * create the NACK (representing a not yet acknowledged message) entry in\n * the consumer group PEL.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0,\n * even if by using the IDLE or TIME options, the user can control the\n * new idle time.\n *\n * The options at the end can be used in order to specify more attributes\n * to set in the representation of the pending message:\n *\n * 1. IDLE <ms>:\n *      Set the idle time (last time it was delivered) of the message.\n *      If IDLE is not specified, an IDLE of 0 is assumed, that is,\n *      the time count is reset because the message has now a new\n *      owner trying to process it.\n *\n * 2. TIME <ms-unix-time>:\n *      This is the same as IDLE but instead of a relative amount of\n *      milliseconds, it sets the idle time to a specific unix time\n *      (in milliseconds). This is useful in order to rewrite the AOF\n *      file generating XCLAIM commands.\n *\n * 3. RETRYCOUNT <count>:\n *      Set the retry counter to the specified value. This counter is\n *      incremented every time a message is delivered again. Normally\n *      XCLAIM does not alter this counter, which is just served to clients\n *      when the XPENDING command is called: this way clients can detect\n *      anomalies, like messages that are never processed for some reason\n *      after a big number of delivery attempts.\n *\n * 4. FORCE:\n *      Creates the pending message entry in the PEL even if certain\n *      specified IDs are not already in the PEL assigned to a different\n *      client. However the message must be exist in the stream, otherwise\n *      the IDs of non existing messages are ignored.\n *\n * 5. JUSTID:\n *      Return just an array of IDs of messages successfully claimed,\n *      without returning the actual message.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument. */\n    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */\n    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */\n    int force = 0;\n    int justid = 0;\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or \"\n                              \"consumer group '%s'\", (char*)c->argv[1]->ptr,\n                              (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\n        \"Invalid min-idle-time argument for XCLAIM\")\n        != C_OK) return;\n    if (minidle < 0) minidle = 0;\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully claimed some message, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    int j;\n    for (j = 4; j < c->argc; j++) {\n        streamID id;\n        if (streamParseIDOrReply(NULL,c->argv[j],&id,0) != C_OK) break;\n    }\n    int last_id_arg = j-1; /* Next time we iterate the IDs we now the range. */\n\n    /* If we stopped because some IDs cannot be parsed, perhaps they\n     * are trailing options. */\n    time_t now = mstime();\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt,\"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt,\"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n        } else if (!strcasecmp(opt,\"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&retrycount,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n        } else {\n            addReplyErrorFormat(c,\"Unrecognized XCLAIM option '%s'\",opt);\n            return;\n        }\n    }\n\n    if (deliverytime != -1) {\n        /* If a delivery time was passed, either with IDLE or TIME, we\n         * do some sanity check on it, and set the deliverytime to now\n         * (which is a sane choice usually) if the value is bogus.\n         * To raise an error here is not wise because clients may compute\n         * the idle time doing some math startin from their local time,\n         * and this is not a good excuse to fail in case, for instance,\n         * the computed time is a bit in the future from our POV. */\n        if (deliverytime < 0 || deliverytime > now) deliverytime = now;\n    } else {\n        /* If no IDLE/TIME option was passed, we want the last delivery\n         * time to be now, so that the idle time of the message will be\n         * zero. */\n        deliverytime = now;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = streamLookupConsumer(group,c->argv[3]->ptr,1);\n    void *arraylenptr = addDeferredMultiBulkLength(c);\n    size_t arraylen = 0;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id;\n        unsigned char buf[sizeof(streamID)];\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n\n        /* If FORCE is passed, let's check if at least the entry\n         * exists in the Stream. In such case, we'll crate a new\n         * entry in the PEL from scratch, so that XCLAIM can also\n         * be used to create entries in the PEL. Useful for AOF\n         * and replication of consumer groups. */\n        if (force && nack == raxNotFound) {\n            streamIterator myiterator;\n            streamIteratorStart(&myiterator,o->ptr,&id,&id,0);\n            int64_t numfields;\n            int found = 0;\n            streamID item_id;\n            if (streamIteratorGetID(&myiterator,&item_id,&numfields)) found = 1;\n            streamIteratorStop(&myiterator);\n\n            /* Item must exist for us to create a NACK for it. */\n            if (!found) continue;\n\n            /* Create the NACK. */\n            nack = streamCreateNACK(NULL);\n            raxInsert(group->pel,buf,sizeof(buf),nack,NULL);\n        }\n\n        if (nack != raxNotFound) {\n            /* We need to check if the minimum idle time requested\n             * by the caller is satisfied by this entry. */\n            if (minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n            /* Remove the entry from the old consumer.\n             * Note that nack->consumer is NULL if we created the\n             * NACK above because of the FORCE option. */\n            if (nack->consumer)\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            /* Update the consumer and idle time. */\n            nack->consumer = consumer;\n            nack->delivery_time = deliverytime;\n            /* Set the delivery attempts counter if given. */\n            if (retrycount >= 0) nack->delivery_count = retrycount;\n            /* Add the entry in the new consumer local PEL. */\n            raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            /* Send the reply for this entry. */\n            if (justid) {\n                addReplyStreamID(c,&id);\n            } else {\n                streamReplyWithRange(c,o->ptr,&id,NULL,1,0,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n            }\n            arraylen++;\n\n            /* Propagate this change. */\n            streamPropagateXCLAIM(c,c->argv[1],c->argv[3],c->argv[j],nack);\n            server.dirty++;\n        }\n    }\n    setDeferredMultiBulkLength(c,arraylenptr,arraylen);\n    preventCommandPropagation(c);\n}\n\n\n/* XDEL <key> [<ID1> <ID2> ... <IDN>]\n *\n * Removes the specified entries from the stream. Returns the number\n * of items actaully deleted, that may be different from the number\n * of IDs passed in case certain IDs do not exist. */\nvoid xdelCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* We need to sanity check the IDs passed to start. Even if not\n     * a big issue, it is not great that the command is only partially\n     * executed becuase at some point an invalid ID is parsed. */\n    streamID id;\n    for (int j = 2; j < c->argc; j++) {\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n    }\n\n    /* Actaully apply the command. */\n    int deleted = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamParseIDOrReply(c,c->argv[j],&id,0); /* Retval already checked. */\n        deleted += streamDeleteItem(s,&id);\n    }\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xdel\",c->argv[1],c->db->id);\n    server.dirty += deleted;\n    addReplyLongLong(c,deleted);\n}\n\n/* General form: XTRIM <key> [... options ...]\n *\n * List of options:\n *\n * MAXLEN [~] <count>       -- Trim so that the stream will be capped at\n *                             the specified length. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MAXLEN option).\n */\n\n#define TRIM_STRATEGY_NONE 0\n#define TRIM_STRATEGY_MAXLEN 1\nvoid xtrimCommand(client *c) {\n    robj *o;\n\n    /* If the key does not exist, we are ok returning zero, that is, the\n     * number of elements removed from the stream. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* Argument parsing. */\n    int trim_strategy = TRIM_STRATEGY_NONE;\n    long long maxlen = 0;   /* 0 means no maximum length. */\n    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so\n                               the maxium length is not applied verbatim. */\n\n    /* Parse options. */\n    int i = 2; /* Start of options. */\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            trim_strategy = TRIM_STRATEGY_MAXLEN;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                approx_maxlen = 1;\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)\n                != C_OK) return;\n            i++;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* Perform the trimming. */\n    int64_t deleted = 0;\n    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n        deleted = streamTrimByLength(s,maxlen,approx_maxlen);\n    } else {\n        addReplyError(c,\"XTRIM called without an option to trim the stream\");\n        return;\n    }\n\n    /* Propagate the write if needed. */\n    if (deleted) {\n        signalModifiedKey(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\n/* XINFO CONSUMERS key group\n * XINFO GROUPS <key>\n * XINFO STREAM <key>\n * XINFO HELP. */\nvoid xinfoCommand(client *c) {\n    const char *help[] = {\n\"CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.\",\n\"GROUPS <key>                 -- Show the stream consumer groups.\",\n\"STREAM <key>                 -- Show information about the stream.\",\n\"HELP                         -- Print this help.\",\nNULL\n    };\n    stream *s = NULL;\n    char *opt;\n    robj *key;\n\n    /* HELP is special. Handle it ASAP. */\n    if (!strcasecmp(c->argv[1]->ptr,\"HELP\")) {\n        addReplyHelp(c, help);\n        return;\n    } else if (c->argc < 3) {\n        addReplyError(c,\"syntax error, try 'XINFO HELP'\");\n        return;\n    }\n\n    /* With the exception of HELP handled before any other sub commands, all\n     * the ones are in the form of \"<subcommand> <key>\". */\n    opt = c->argv[1]->ptr;\n    key = c->argv[2];\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    robj *o = lookupKeyWriteOrReply(c,key,shared.nokeyerr);\n    if (o == NULL) return;\n    s = o->ptr;\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CONSUMERS\") && c->argc == 4) {\n        /* XINFO CONSUMERS <key> <group>. */\n        streamCG *cg = streamLookupCG(s,c->argv[3]->ptr);\n        if (cg == NULL) {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)c->argv[3]->ptr, (char*)key->ptr);\n            return;\n        }\n\n        addReplyMultiBulkLen(c,raxSize(cg->consumers));\n        raxIterator ri;\n        raxStart(&ri,cg->consumers);\n        raxSeek(&ri,\"^\",NULL,0);\n        mstime_t now = mstime();\n        while(raxNext(&ri)) {\n            streamConsumer *consumer = ri.data;\n            mstime_t idle = now - consumer->seen_time;\n            if (idle < 0) idle = 0;\n\n            addReplyMultiBulkLen(c,6);\n            addReplyStatus(c,\"name\");\n            addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n            addReplyStatus(c,\"pending\");\n            addReplyLongLong(c,raxSize(consumer->pel));\n            addReplyStatus(c,\"idle\");\n            addReplyLongLong(c,idle);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"GROUPS\") && c->argc == 3) {\n        /* XINFO GROUPS <key>. */\n        if (s->cgroups == NULL) {\n            addReplyMultiBulkLen(c,0);\n            return;\n        }\n\n        addReplyMultiBulkLen(c,raxSize(s->cgroups));\n        raxIterator ri;\n        raxStart(&ri,s->cgroups);\n        raxSeek(&ri,\"^\",NULL,0);\n        while(raxNext(&ri)) {\n            streamCG *cg = ri.data;\n            addReplyMultiBulkLen(c,6);\n            addReplyStatus(c,\"name\");\n            addReplyBulkCBuffer(c,ri.key,ri.key_len);\n            addReplyStatus(c,\"consumers\");\n            addReplyLongLong(c,raxSize(cg->consumers));\n            addReplyStatus(c,\"pending\");\n            addReplyLongLong(c,raxSize(cg->pel));\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"STREAM\") && c->argc == 3) {\n        /* XINFO STREAM <key> (or the alias XINFO <key>). */\n        addReplyMultiBulkLen(c,12);\n        addReplyStatus(c,\"length\");\n        addReplyLongLong(c,s->length);\n        addReplyStatus(c,\"radix-tree-keys\");\n        addReplyLongLong(c,raxSize(s->rax));\n        addReplyStatus(c,\"radix-tree-nodes\");\n        addReplyLongLong(c,s->rax->numnodes);\n        addReplyStatus(c,\"groups\");\n        addReplyLongLong(c,s->cgroups ? raxSize(s->cgroups) : 0);\n\n        /* To emit the first/last entry we us the streamReplyWithRange()\n         * API. */\n        int count;\n        streamID start, end;\n        start.ms = start.seq = 0;\n        end.ms = end.seq = UINT64_MAX;\n        addReplyStatus(c,\"first-entry\");\n        count = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n        if (!count) addReply(c,shared.nullbulk);\n        addReplyStatus(c,\"last-entry\");\n        count = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n        if (!count) addReply(c,shared.nullbulk);\n    } else {\n        addReplyError(c,\"syntax error, try 'XINFO HELP'\");\n    }\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n#define STREAM_BYTES_PER_LISTPACK 2048\n\n/* Every stream item inside the listpack, has a flags field that is used to\n * mark the entry as deleted, or having the same field as the \"master\"\n * entry at the start of the listpack> */\n#define STREAM_ITEM_FLAG_NONE 0             /* No special flags. */\n#define STREAM_ITEM_FLAG_DELETED (1<<0)     /* Entry is delted. Skip it. */\n#define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  /* Same fields as master entry. */\n\nvoid streamFreeCG(streamCG *cg);\nvoid streamFreeNACK(streamNACK *na);\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);\n\n/* -----------------------------------------------------------------------\n * Low level stream encoding: a radix tree of listpacks.\n * ----------------------------------------------------------------------- */\n\n/* Create a new stream data structure. */\nstream *streamNew(void) {\n    stream *s = zmalloc(sizeof(*s));\n    s->rax = raxNew();\n    s->length = 0;\n    s->last_id.ms = 0;\n    s->last_id.seq = 0;\n    s->cgroups = NULL; /* Created on demand to save memory when not used. */\n    return s;\n}\n\n/* Free a stream, including the listpacks stored inside the radix tree. */\nvoid freeStream(stream *s) {\n    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);\n    if (s->cgroups)\n        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);\n    zfree(s);\n}\n\n/* Generate the next stream item ID given the previous one. If the current\n * milliseconds Unix time is greater than the previous one, just use this\n * as time part and start with sequence part of zero. Otherwise we use the\n * previous time (and never go backward) and increment the sequence. */\nvoid streamNextID(streamID *last_id, streamID *new_id) {\n    uint64_t ms = mstime();\n    if (ms > last_id->ms) {\n        new_id->ms = ms;\n        new_id->seq = 0;\n    } else {\n        new_id->ms = last_id->ms;\n        new_id->seq = last_id->seq+1;\n    }\n}\n\n/* This is just a wrapper for lpAppend() to directly use a 64 bit integer\n * instead of a string. */\nunsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {\n    char buf[LONG_STR_SIZE];\n    int slen = ll2string(buf,sizeof(buf),value);\n    return lpAppend(lp,(unsigned char*)buf,slen);\n}\n\n/* This is just a wrapper for lpReplace() to directly use a 64 bit integer\n * instead of a string to replace the current element. The function returns\n * the new listpack as return value, and also updates the current cursor\n * by updating '*pos'. */\nunsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {\n    char buf[LONG_STR_SIZE];\n    int slen = ll2string(buf,sizeof(buf),value);\n    return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);\n}\n\n/* This is a wrapper function for lpGet() to directly get an integer value\n * from the listpack (that may store numbers as a string), converting\n * the string if needed. */\nint64_t lpGetInteger(unsigned char *ele) {\n    int64_t v;\n    unsigned char *e = lpGet(ele,&v,NULL);\n    if (e == NULL) return v;\n    /* The following code path should never be used for how listpacks work:\n     * they should always be able to store an int64_t value in integer\n     * encoded form. However the implementation may change. */\n    long long ll;\n    int retval = string2ll((char*)e,v,&ll);\n    serverAssert(retval != 0);\n    v = ll;\n    return v;\n}\n\n/* Debugging function to log the full content of a listpack. Useful\n * for development and debugging. */\nvoid streamLogListpackContent(unsigned char *lp) {\n    unsigned char *p = lpFirst(lp);\n    while(p) {\n        unsigned char buf[LP_INTBUF_SIZE];\n        int64_t v;\n        unsigned char *ele = lpGet(p,&v,buf);\n        serverLog(LL_WARNING,\"- [%d] '%.*s'\", (int)v, (int)v, ele);\n        p = lpNext(lp,p);\n    }\n}\n\n/* Convert the specified stream entry ID as a 128 bit big endian number, so\n * that the IDs can be sorted lexicographically. */\nvoid streamEncodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    e[0] = htonu64(id->ms);\n    e[1] = htonu64(id->seq);\n    memcpy(buf,e,sizeof(e));\n}\n\n/* This is the reverse of streamEncodeID(): the decoded ID will be stored\n * in the 'id' structure passed by reference. The buffer 'buf' must point\n * to a 128 bit big-endian encoded ID. */\nvoid streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n\n/* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */\nint streamCompareID(streamID *a, streamID *b) {\n    if (a->ms > b->ms) return 1;\n    else if (a->ms < b->ms) return -1;\n    /* The ms part is the same. Check the sequence part. */\n    else if (a->seq > b->seq) return 1;\n    else if (a->seq < b->seq) return -1;\n    /* Everything is the same: IDs are equal. */\n    return 0;\n}\n\n/* Adds a new item into the stream 's' having the specified number of\n * field-value pairs as specified in 'numfields' and stored into 'argv'.\n * Returns the new entry ID populating the 'added_id' structure.\n *\n * If 'use_id' is not NULL, the ID is not auto-generated by the function,\n * but instead the passed ID is uesd to add the new entry. In this case\n * adding the entry may fail as specified later in this comment.\n *\n * The function returns C_OK if the item was added, this is always true\n * if the ID was generated by the function. However the function may return\n * C_ERR if an ID was given via 'use_id', but adding it failed since the\n * current top ID is greater or equal. */\nint streamAppendItem(stream *s, robj **argv, int numfields, streamID *added_id, streamID *use_id) {\n    /* If an ID was given, check that it's greater than the last entry ID\n     * or return an error. */\n    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) return C_ERR;\n\n    /* Add the new entry. */\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"$\",NULL,0);\n\n    size_t lp_bytes = 0;        /* Total bytes in the tail listpack. */\n    unsigned char *lp = NULL;   /* Tail listpack pointer. */\n\n    /* Get a reference to the tail node listpack. */\n    if (raxNext(&ri)) {\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n    }\n    raxStop(&ri);\n\n    /* Generate the new entry ID. */\n    streamID id;\n    if (use_id)\n        id = *use_id;\n    else\n        streamNextID(&s->last_id,&id);\n\n    /* We have to add the key into the radix tree in lexicographic order,\n     * to do so we consider the ID as a single 128 bit number written in\n     * big endian, so that the most significant bytes are the first ones. */\n    uint64_t rax_key[2];    /* Key in the radix tree containing the listpack.*/\n    streamID master_id;     /* ID of the master entry in the listpack. */\n\n    /* Create a new listpack and radix tree node if needed. Note that when\n     * a new listpack is created, we populate it with a \"master entry\". This\n     * is just a set of fields that is taken as refernce in order to compress\n     * the stream entries that we'll add inside the listpack.\n     *\n     * Note that while we use the first added entry fields to create\n     * the master entry, the first added entry is NOT represented in the master\n     * entry, which is a stand alone object. But of course, the first entry\n     * will compress well because it's used as reference.\n     *\n     * The master entry is composed like in the following example:\n     *\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     *\n     * count and deleted just represent respectively the total number of\n     * entries inside the listpack that are valid, and marked as deleted\n     * (delted flag in the entry flags set). So the total number of items\n     * actually inside the listpack (both deleted and not) is count+deleted.\n     *\n     * The real entries will be encoded with an ID that is just the\n     * millisecond and sequence difference compared to the key stored at\n     * the radix tree node containing the listpack (delta encoding), and\n     * if the fields of the entry are the same as the master enty fields, the\n     * entry flags will specify this fact and the entry fields and number\n     * of fields will be omitted (see later in the code of this function).\n     *\n     * The \"0\" entry at the end is the same as the 'lp-count' entry in the\n     * regular stream entries (see below), and marks the fact that there are\n     * no more entries, when we scan the stream from right to left. */\n\n    /* First of all, check if we can append to the current macro node or\n     * if we need to switch to the next one. 'lp' will be set to NULL if\n     * the current node is full. */\n    if (lp != NULL) {\n        if (server.stream_node_max_bytes &&\n            lp_bytes > server.stream_node_max_bytes)\n        {\n            lp = NULL;\n        } else if (server.stream_node_max_entries) {\n            int64_t count = lpGetInteger(lpFirst(lp));\n            if (count > server.stream_node_max_entries) lp = NULL;\n        }\n    }\n\n    int flags = STREAM_ITEM_FLAG_NONE;\n    if (lp == NULL || lp_bytes > server.stream_node_max_bytes) {\n        master_id = id;\n        streamEncodeID(rax_key,&id);\n        /* Create the listpack having the master entry ID and fields. */\n        lp = lpNew();\n        lp = lpAppendInteger(lp,1); /* One item, the one we are adding. */\n        lp = lpAppendInteger(lp,0); /* Zero deleted so far. */\n        lp = lpAppendInteger(lp,numfields);\n        for (int i = 0; i < numfields; i++) {\n            sds field = argv[i*2]->ptr;\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        }\n        lp = lpAppendInteger(lp,0); /* Master entry zero terminator. */\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n        /* The first entry we insert, has obviously the same fields of the\n         * master entry. */\n        flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n    } else {\n        serverAssert(ri.key_len == sizeof(rax_key));\n        memcpy(rax_key,ri.key,sizeof(rax_key));\n\n        /* Read the master ID from the radix tree key. */\n        streamDecodeID(rax_key,&master_id);\n        unsigned char *lp_ele = lpFirst(lp);\n\n        /* Update count and skip the deleted fields. */\n        int64_t count = lpGetInteger(lp_ele);\n        lp = lpReplaceInteger(lp,&lp_ele,count+1);\n        lp_ele = lpNext(lp,lp_ele); /* seek deleted. */\n        lp_ele = lpNext(lp,lp_ele); /* seek master entry num fields. */\n\n        /* Check if the entry we are adding, have the same fields\n         * as the master entry. */\n        int master_fields_count = lpGetInteger(lp_ele);\n        lp_ele = lpNext(lp,lp_ele);\n        if (numfields == master_fields_count) {\n            int i;\n            for (i = 0; i < master_fields_count; i++) {\n                sds field = argv[i*2]->ptr;\n                int64_t e_len;\n                unsigned char buf[LP_INTBUF_SIZE];\n                unsigned char *e = lpGet(lp_ele,&e_len,buf);\n                /* Stop if there is a mismatch. */\n                if (sdslen(field) != (size_t)e_len ||\n                    memcmp(e,field,e_len) != 0) break;\n                lp_ele = lpNext(lp,lp_ele);\n            }\n            /* All fields are the same! We can compress the field names\n             * setting a single bit in the flags. */\n            if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n        }\n    }\n\n    /* Populate the listpack with the new entry. We use the following\n     * encoding:\n     *\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     *\n     * However if the SAMEFIELD flag is set, we have just to populate\n     * the entry with the values, so it becomes:\n     *\n     * +-----+--------+-------+-/-+-------+--------+\n     * |flags|entry-id|value-1|...|value-N|lp-count|\n     * +-----+--------+-------+-/-+-------+--------+\n     *\n     * The entry-id field is actually two separated fields: the ms\n     * and seq difference compared to the master entry.\n     *\n     * The lp-count field is a number that states the number of listpack pieces\n     * that compose the entry, so that it's possible to travel the entry\n     * in reverse order: we can just start from the end of the listpack, read\n     * the entry, and jump back N times to seek the \"flags\" field to read\n     * the stream full entry. */\n    lp = lpAppendInteger(lp,flags);\n    lp = lpAppendInteger(lp,id.ms - master_id.ms);\n    lp = lpAppendInteger(lp,id.seq - master_id.seq);\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n        lp = lpAppendInteger(lp,numfields);\n    for (int i = 0; i < numfields; i++) {\n        sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        lp = lpAppend(lp,(unsigned char*)value,sdslen(value));\n    }\n    /* Compute and store the lp-count field. */\n    int lp_count = numfields;\n    lp_count += 3; /* Add the 3 fixed fields flags + ms-diff + seq-diff. */\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n        /* If the item is not compressed, it also has the fields other than\n         * the values, and an additional num-fileds field. */\n        lp_count += numfields+1;\n    }\n    lp = lpAppendInteger(lp,lp_count);\n\n    /* Insert back into the tree in order to update the listpack pointer. */\n    raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n    s->length++;\n    s->last_id = id;\n    if (added_id) *added_id = id;\n    return C_OK;\n}\n\n/* Trim the stream 's' to have no more than maxlen elements, and return the\n * number of elements removed from the stream. The 'approx' option, if non-zero,\n * specifies that the trimming must be performed in a approximated way in\n * order to maximize performances. This means that the stream may contain\n * more elements than 'maxlen', and elements are only removed if we can remove\n * a *whole* node of the radix tree. The elements are removed from the head\n * of the stream (older elements).\n *\n * The function may return zero if:\n *\n * 1) The stream is already shorter or equal to the specified max length.\n * 2) The 'approx' option is true and the head node had not enough elements\n *    to be deleted, leaving the stream with a number of elements >= maxlen.\n */\nint64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {\n    if (s->length <= maxlen) return 0;\n\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"^\",NULL,0);\n\n    int64_t deleted = 0;\n    while(s->length > maxlen && raxNext(&ri)) {\n        unsigned char *lp = ri.data, *p = lpFirst(lp);\n        int64_t entries = lpGetInteger(p);\n\n        /* Check if we can remove the whole node, and still have at\n         * least maxlen elements. */\n        if (s->length - entries >= maxlen) {\n            lpFree(lp);\n            raxRemove(s->rax,ri.key,ri.key_len,NULL);\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            s->length -= entries;\n            deleted += entries;\n            continue;\n        }\n\n        /* If we cannot remove a whole element, and approx is true,\n         * stop here. */\n        if (approx) break;\n\n        /* Otherwise, we have to mark single entries inside the listpack\n         * as deleted. We start by updating the entries/deleted counters. */\n        int64_t to_delete = s->length - maxlen;\n        serverAssert(to_delete < entries);\n        lp = lpReplaceInteger(lp,&p,entries-to_delete);\n        p = lpNext(lp,p); /* Seek deleted field. */\n        int64_t marked_deleted = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,marked_deleted+to_delete);\n        p = lpNext(lp,p); /* Seek num-of-fields in the master entry. */\n\n        /* Skip all the master fields. */\n        int64_t master_fields_count = lpGetInteger(p);\n        p = lpNext(lp,p); /* Seek the first field. */\n        for (int64_t j = 0; j < master_fields_count; j++)\n            p = lpNext(lp,p); /* Skip all master fields. */\n        p = lpNext(lp,p); /* Skip the zero master entry terminator. */\n\n        /* 'p' is now pointing to the first entry inside the listpack.\n         * We have to run entry after entry, marking entries as deleted\n         * if they are already not deleted. */\n        while(p) {\n            int flags = lpGetInteger(p);\n            int to_skip;\n\n            /* Mark the entry as deleted. */\n            if (!(flags & STREAM_ITEM_FLAG_DELETED)) {\n                flags |= STREAM_ITEM_FLAG_DELETED;\n                lp = lpReplaceInteger(lp,&p,flags);\n                deleted++;\n                s->length--;\n                if (s->length <= maxlen) break; /* Enough entries deleted. */\n            }\n\n            p = lpNext(lp,p); /* Skip ID ms delta. */\n            p = lpNext(lp,p); /* Skip ID seq delta. */\n            p = lpNext(lp,p); /* Seek num-fields or values (if compressed). */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                to_skip = master_fields_count;\n            } else {\n                to_skip = lpGetInteger(p);\n                to_skip = 1+(to_skip*2);\n            }\n\n            while(to_skip--) p = lpNext(lp,p); /* Skip the whole entry. */\n            p = lpNext(lp,p); /* Skip the final lp-count field. */\n        }\n\n        /* Here we should perform garbage collection in case at this point\n         * there are too many entries deleted inside the listpack. */\n        entries -= to_delete;\n        marked_deleted += to_delete;\n        if (entries + marked_deleted > 10 && marked_deleted > entries/2) {\n            /* TODO: perform a garbage collection. */\n        }\n\n        /* Update the listpack with the new pointer. */\n        raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n\n        break; /* If we are here, there was enough to delete in the current\n                  node, so no need to go to the next node. */\n    }\n\n    raxStop(&ri);\n    return deleted;\n}\n\n/* Initialize the stream iterator, so that we can call iterating functions\n * to get the next items. This requires a corresponding streamIteratorStop()\n * at the end. The 'rev' parameter controls the direction. If it's zero the\n * iteration is from the start to the end element (inclusive), otherwise\n * if rev is non-zero, the iteration is reversed.\n *\n * Once the iterator is initalized, we iterate like this:\n *\n *  streamIterator myiterator;\n *  streamIteratorStart(&myiterator,...);\n *  int64_t numfields;\n *  while(streamIteratorGetID(&myiterator,&ID,&numfields)) {\n *      while(numfields--) {\n *          unsigned char *key, *value;\n *          size_t key_len, value_len;\n *          streamIteratorGetField(&myiterator,&key,&value,&key_len,&value_len);\n *\n *          ... do what you want with key and value ...\n *      }\n *  }\n *  streamIteratorStop(&myiterator); */\nvoid streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {\n    /* Intialize the iterator and translates the iteration start/stop\n     * elements into a 128 big big-endian number. */\n    if (start) {\n        streamEncodeID(si->start_key,start);\n    } else {\n        si->start_key[0] = 0;\n        si->start_key[0] = 0;\n    }\n\n    if (end) {\n        streamEncodeID(si->end_key,end);\n    } else {\n        si->end_key[0] = UINT64_MAX;\n        si->end_key[0] = UINT64_MAX;\n    }\n\n    /* Seek the correct node in the radix tree. */\n    raxStart(&si->ri,s->rax);\n    if (!rev) {\n        if (start && (start->ms || start->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->start_key,\n                    sizeof(si->start_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"^\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"^\",NULL,0);\n        }\n    } else {\n        if (end && (end->ms || end->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->end_key,\n                    sizeof(si->end_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"$\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"$\",NULL,0);\n        }\n    }\n    si->stream = s;\n    si->lp = NULL; /* There is no current listpack right now. */\n    si->lp_ele = NULL; /* Current listpack cursor. */\n    si->rev = rev;  /* Direction, if non-zero reversed, from end to start. */\n}\n\n/* Return 1 and store the current item ID at 'id' if there are still\n * elements within the iteration range, otherwise return 0 in order to\n * signal the iteration terminated. */\nint streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {\n    while(1) { /* Will stop when element > stop_key or end of radix tree. */\n        /* If the current listpack is set to NULL, this is the start of the\n         * iteration or the previous listpack was completely iterated.\n         * Go to the next node. */\n        if (si->lp == NULL || si->lp_ele == NULL) {\n            if (!si->rev && !raxNext(&si->ri)) return 0;\n            else if (si->rev && !raxPrev(&si->ri)) return 0;\n            serverAssert(si->ri.key_len == sizeof(streamID));\n            /* Get the master ID. */\n            streamDecodeID(si->ri.key,&si->master_id);\n            /* Get the master fields count. */\n            si->lp = si->ri.data;\n            si->lp_ele = lpFirst(si->lp);           /* Seek items count */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */\n            si->master_fields_count = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek first field. */\n            si->master_fields_start = si->lp_ele;\n            /* Skip master fileds to seek the first entry. */\n            for (uint64_t i = 0; i < si->master_fields_count; i++)\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            /* We are now pointing the zero term of the master entry. If\n             * we are iterating in reverse order, we need to seek the\n             * end of the listpack. */\n            if (si->rev) si->lp_ele = lpLast(si->lp);\n        } else if (si->rev) {\n            /* If we are itereating in the reverse order, and this is not\n             * the first entry emitted for this listpack, then we already\n             * emitted the current entry, and have to go back to the previous\n             * one. */\n            int lp_count = lpGetInteger(si->lp_ele);\n            while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            /* Seek lp-count of prev entry. */\n            si->lp_ele = lpPrev(si->lp,si->lp_ele);\n        }\n\n        /* For every radix tree node, iterate the corresponding listpack,\n         * returning elements when they are within range. */\n        while(1) {\n            if (!si->rev) {\n                /* If we are going forward, skip the previous entry\n                 * lp-count field (or in case of the master entry, the zero\n                 * term field) */\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n                if (si->lp_ele == NULL) break;\n            } else {\n                /* If we are going backward, read the number of elements this\n                 * entry is composed of, and jump backward N times to seek\n                 * its start. */\n                int lp_count = lpGetInteger(si->lp_ele);\n                if (lp_count == 0) { /* We reached the master entry. */\n                    si->lp = NULL;\n                    si->lp_ele = NULL;\n                    break;\n                }\n                while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n\n            /* Get the flags entry. */\n            si->lp_flags = si->lp_ele;\n            int flags = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek ID. */\n\n            /* Get the ID: it is encoded as difference between the master\n             * ID and this entry ID. */\n            *id = si->master_id;\n            id->ms += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            id->seq += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,id);\n\n            /* The number of entries is here or not depending on the\n             * flags. */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                *numfields = si->master_fields_count;\n            } else {\n                *numfields = lpGetInteger(si->lp_ele);\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            }\n\n            /* If current >= start, and the entry is not marked as\n             * deleted, emit it. */\n            if (!si->rev) {\n                if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&\n                    !(flags & STREAM_ITEM_FLAG_DELETED))\n                {\n                    if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            } else {\n                if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&\n                    !(flags & STREAM_ITEM_FLAG_DELETED))\n                {\n                    if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            }\n\n            /* If we do not emit, we have to discard if we are going\n             * forward, or seek the previous entry if we are going\n             * backward. */\n            if (!si->rev) {\n                int to_discard = (flags & STREAM_ITEM_FLAG_SAMEFIELDS) ?\n                                    *numfields : *numfields*2;\n                for (int64_t i = 0; i < to_discard; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                int prev_times = 4; /* flag + id ms/seq diff + numfields. */\n                while(prev_times--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n        }\n\n        /* End of listpack reached. Try the next/prev radix tree node. */\n    }\n}\n\n/* Get the field and value of the current item we are iterating. This should\n * be called immediately after streamIteratorGetID(), and for each field\n * according to the number of fields returned by streamIteratorGetID().\n * The function populates the field and value pointers and the corresponding\n * lengths by reference, that are valid until the next iterator call, assuming\n * no one touches the stream meanwhile. */\nvoid streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {\n    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);\n        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);\n    } else {\n        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);\n        si->lp_ele = lpNext(si->lp,si->lp_ele);\n    }\n    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);\n    si->lp_ele = lpNext(si->lp,si->lp_ele);\n}\n\n/* Remove the current entry from the stream: can be called after the\n * GetID() API or after any GetField() call, however we need to iterate\n * a valid entry while calling this function. Moreover the function\n * requires the entry ID we are currently iterating, that was previously\n * returned by GetID().\n *\n * Note that after calling this function, next calls to GetField() can't\n * be performed: the entry is now deleted. Instead the iterator will\n * automatically re-seek to the next entry, so the caller should continue\n * with GetID(). */\nvoid streamIteratorRemoveEntry(streamIterator *si, streamID *current) {\n    unsigned char *lp = si->lp;\n    int64_t aux;\n\n    /* We do not really delete the entry here. Instead we mark it as\n     * deleted flagging it, and also incrementing the count of the\n     * deleted entries in the listpack header.\n     *\n     * We start flagging: */\n    int flags = lpGetInteger(si->lp_flags);\n    flags |= STREAM_ITEM_FLAG_DELETED;\n    lp = lpReplaceInteger(lp,&si->lp_flags,flags);\n\n    /* Change the valid/deleted entries count in the master entry. */\n    unsigned char *p = lpFirst(lp);\n    aux = lpGetInteger(p);\n    lp = lpReplaceInteger(lp,&p,aux-1);\n    p = lpNext(lp,p); /* Seek deleted field. */\n    aux = lpGetInteger(p);\n    lp = lpReplaceInteger(lp,&p,aux+1);\n\n    /* Update the number of entries counter. */\n    si->stream->length--;\n\n    /* Re-seek the iterator to fix the now messed up state. */\n    streamID start, end;\n    if (si->rev) {\n        streamDecodeID(si->start_key,&start);\n        end = *current;\n    } else {\n        start = *current;\n        streamDecodeID(si->end_key,&end);\n    }\n    streamIteratorStop(si);\n    streamIteratorStart(si,si->stream,&start,&end,si->rev);\n\n    /* TODO: perform a garbage collection here if the ration between\n     * deleted and valid goes over a certain limit. */\n}\n\n/* Stop the stream iterator. The only cleanup we need is to free the rax\n * itereator, since the stream iterator itself is supposed to be stack\n * allocated. */\nvoid streamIteratorStop(streamIterator *si) {\n    raxStop(&si->ri);\n}\n\n/* Delete the specified item ID from the stream, returning 1 if the item\n * was deleted 0 otherwise (if it does not exist). */\nint streamDeleteItem(stream *s, streamID *id) {\n    int deleted = 0;\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    if (streamIteratorGetID(&si,&myid,&numfields)) {\n        streamIteratorRemoveEntry(&si,&myid);\n        deleted = 1;\n    }\n    return deleted;\n}\n\n/* Emit a reply in the client output buffer by formatting a Stream ID\n * in the standard <ms>-<seq> format, using the simple string protocol\n * of REPL. */\nvoid addReplyStreamID(client *c, streamID *id) {\n    sds replyid = sdscatfmt(sdsempty(),\"+%U-%U\\r\\n\",id->ms,id->seq);\n    addReplySds(c,replyid);\n}\n\n/* Similar to the above function, but just creates an object, usually useful\n * for replication purposes to create arguments. */\nrobj *createObjectFromStreamID(streamID *id) {\n    return createObject(OBJ_STRING, sdscatfmt(sdsempty(),\"%U-%U\",\n                        id->ms,id->seq));\n}\n\n/* As a result of an explicit XCLAIM or XREADGROUP command, new entries\n * are created in the pending list of the stream and consumers. We need\n * to propagate this changes in the form of XCLAIM commands. */\nvoid streamPropagateXCLAIM(client *c, robj *key, robj *group, robj *id, streamNACK *nack) {\n    /* We need to generate an XCLAIM that will work in a idempotent fashion:\n     *\n     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>\n     *        RETRYCOUNT <count> FORCE JUSTID.\n     *\n     * Note that JUSTID is useful in order to avoid that XCLAIM will do\n     * useless work in the slave side, trying to fetch the stream item. */\n    robj *argv[12];\n    argv[0] = createStringObject(\"XCLAIM\",6);\n    argv[1] = key;\n    argv[2] = group;\n    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));\n    argv[4] = createStringObjectFromLongLong(0);\n    argv[5] = id;\n    argv[6] = createStringObject(\"TIME\",4);\n    argv[7] = createStringObjectFromLongLong(nack->delivery_time);\n    argv[8] = createStringObject(\"RETRYCOUNT\",10);\n    argv[9] = createStringObjectFromLongLong(nack->delivery_count);\n    argv[10] = createStringObject(\"FORCE\",5);\n    argv[11] = createStringObject(\"JUSTID\",6);\n    propagate(server.xclaimCommand,c->db->id,argv,12,PROPAGATE_AOF|PROPAGATE_REPL);\n    decrRefCount(argv[0]);\n    decrRefCount(argv[3]);\n    decrRefCount(argv[4]);\n    decrRefCount(argv[6]);\n    decrRefCount(argv[7]);\n    decrRefCount(argv[8]);\n    decrRefCount(argv[9]);\n    decrRefCount(argv[10]);\n    decrRefCount(argv[11]);\n}\n\n/* Send the specified range to the client 'c'. The range the client will\n * receive is between start and end inclusive, if 'count' is non zero, no more\n * than 'count' elemnets are sent. The 'end' pointer can be NULL to mean that\n * we want all the elements from 'start' till the end of the stream. If 'rev'\n * is non zero, elements are produced in reversed order from end to start.\n *\n * If group and consumer are not NULL, the function performs additional work:\n * 1. It updates the last delivered ID in the group in case we are\n *    sending IDs greater than the current last ID.\n * 2. If the requested IDs are already assigned to some other consumer, the\n *    function will not return it to the client.\n * 3. An entry in the pending list will be created for every entry delivered\n *    for the first time to this consumer.\n *\n * The behavior may be modified passing non-zero flags:\n *\n * STREAM_RWR_NOACK: Do not craete PEL entries, that is, the point \"3\" above\n *                   is not performed.\n * STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,\n *                        and return the number of entries emitted as usually.\n *                        This is used when the function is just used in order\n *                        to emit data and there is some higher level logic.\n *\n * The final argument 'spi' (stream propagatino info pointer) is a structure\n * filled with information needed to propagte the command execution to AOF\n * and slaves, in the case a consumer group was passed: we need to generate\n * XCLAIM commands to create the pending list into AOF/slaves in that case.\n *\n * If 'spi' is set to NULL no propagation will happen even if the group was\n * given, but currently such a feature is never used by the code base that\n * will always pass 'spi' and propagate when a group is passed.\n *\n * Note that this function is recursive in certian cases. When it's called\n * with a non NULL group and consumer argument, it may call\n * streamReplyWithRangeFromConsumerPEL() in order to get entries from the\n * consumer pending entries list. However such a function will then call\n * streamReplyWithRange() in order to emit single entries (found in the\n * PEL by ID) to the client. This is the use case for the STREAM_RWR_RAWENTRIES\n * flag.\n */\n#define STREAM_RWR_NOACK (1<<0)         /* Do not create entries in the PEL. */\n#define STREAM_RWR_RAWENTRIES (1<<1)    /* Do not emit protocol for array\n                                           boundaries, just the entries. */\nsize_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {\n    void *arraylen_ptr = NULL;\n    size_t arraylen = 0;\n    streamIterator si;\n    int64_t numfields;\n    streamID id;\n\n    /* If a group was passed, we check if the request is about messages\n     * never delivered so far (normally this happens when \">\" ID is passed).\n     *\n     * If instead the client is asking for some history, we serve it\n     * using a different function, so that we return entries *solely*\n     * from its own PEL. This ensures each consumer will always and only\n     * see the history of messages delivered to it and not yet confirmed\n     * as delivered. */\n    if (group && streamCompareID(start,&group->last_id) <= 0) {\n        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,\n                                                   consumer);\n    }\n\n    if (!(flags & STREAM_RWR_RAWENTRIES))\n        arraylen_ptr = addDeferredMultiBulkLength(c);\n    streamIteratorStart(&si,s,start,end,rev);\n    while(streamIteratorGetID(&si,&id,&numfields)) {\n        /* Update the group last_id if needed. */\n        if (group && streamCompareID(&id,&group->last_id) > 0)\n            group->last_id = id;\n\n        /* Emit a two elements array for each item. The first is\n         * the ID, the second is an array of field-value pairs. */\n        addReplyMultiBulkLen(c,2);\n        addReplyStreamID(c,&id);\n        addReplyMultiBulkLen(c,numfields*2);\n\n        /* Emit the field-value pairs. */\n        while(numfields--) {\n            unsigned char *key, *value;\n            int64_t key_len, value_len;\n            streamIteratorGetField(&si,&key,&value,&key_len,&value_len);\n            addReplyBulkCBuffer(c,key,key_len);\n            addReplyBulkCBuffer(c,value,value_len);\n        }\n\n        /* If a group is passed, we need to create an entry in the\n         * PEL (pending entries list) of this group *and* this consumer.\n         *\n         * Note that we cannot be sure about the fact the message is not\n         * already owned by another consumer, because the admin is able\n         * to change the consumer group last delivered ID using the\n         * XGROUP SETID command. So if we find that there is already\n         * a NACK for the entry, we need to associate it to the new\n         * consumer. */\n        if (group && !(flags & STREAM_RWR_NOACK)) {\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,&id);\n\n            /* Try to add a new NACK. Most of the time this will work and\n             * will not require extra lookups. We'll fix the problem later\n             * if we find that there is already a entry for this ID. */\n            streamNACK *nack = streamCreateNACK(consumer);\n            int retval = 0;\n            retval += raxTryInsert(group->pel,buf,sizeof(buf),nack,NULL);\n            retval += raxTryInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n\n            /* Now we can check if the entry was already busy, and\n             * in that case reassign the entry to the new consumer. */\n            if (retval == 0) {\n                streamFreeNACK(nack);\n                nack = raxFind(group->pel,buf,sizeof(buf));\n                serverAssert(nack != raxNotFound);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                /* Update the consumer and idle time. */\n                nack->consumer = consumer;\n                nack->delivery_time = mstime();\n                nack->delivery_count++;\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            } else if (retval == 1) {\n                serverPanic(\"NACK half-created. Should not be possible.\");\n            }\n\n            /* Propagate as XCLAIM. */\n            if (spi) {\n                robj *idarg = createObjectFromStreamID(&id);\n                streamPropagateXCLAIM(c,spi->keyname,spi->groupname,idarg,nack);\n                decrRefCount(idarg);\n            }\n        }\n\n        arraylen++;\n        if (count && count == arraylen) break;\n    }\n    streamIteratorStop(&si);\n    if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* This is an helper function for streamReplyWithRange() when called with\n * group and consumer arguments, but with a range that is referring to already\n * delivered messages. In this case we just emit messages that are already\n * in the history of the conusmer, fetching the IDs from its PEL.\n *\n * Note that this function does not have a 'rev' argument because it's not\n * possible to iterate in reverse using a group. Basically this function\n * is only called as a result of the XREADGROUP command.\n *\n * This function is more expensive because it needs to inspect the PEL and then\n * seek into the radix tree of the messages in order to emit the full message\n * to the client. However clients only reach this code path when they are\n * fetching the history of already retrieved messages, which is rare. */\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {\n    raxIterator ri;\n    unsigned char startkey[sizeof(streamID)];\n    unsigned char endkey[sizeof(streamID)];\n    streamEncodeID(startkey,start);\n    if (end) streamEncodeID(endkey,end);\n\n    size_t arraylen = 0;\n    void *arraylen_ptr = addDeferredMultiBulkLength(c);\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    while(raxNext(&ri) && (!count || arraylen < count)) {\n        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;\n        streamID thisid;\n        streamDecodeID(ri.key,&thisid);\n        if (streamReplyWithRange(c,s,&thisid,NULL,1,0,NULL,NULL,\n                                 STREAM_RWR_RAWENTRIES,NULL) == 0)\n        {\n            /* Note that we may have a not acknowledged entry in the PEL\n             * about a message that's no longer here because was removed\n             * by the user by other means. In that case we signal it emitting\n             * the ID but then a NULL entry for the fields. */\n            addReplyMultiBulkLen(c,2);\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n            addReply(c,shared.nullmultibulk);\n        } else {\n            streamNACK *nack = ri.data;\n            nack->delivery_time = mstime();\n            nack->delivery_count++;\n        }\n        arraylen++;\n    }\n    raxStop(&ri);\n    setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* -----------------------------------------------------------------------\n * Stream commands implementation\n * ----------------------------------------------------------------------- */\n\n/* Look the stream at 'key' and return the corresponding stream object.\n * The function creates a key setting it to an empty stream if needed. */\nrobj *streamTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (o == NULL) {\n        o = createStreamObject();\n        dbAdd(c->db,key,o);\n    } else {\n        if (o->type != OBJ_STREAM) {\n            addReply(c,shared.wrongtypeerr);\n            return NULL;\n        }\n    }\n    return o;\n}\n\n/* Helper function to convert a string to an unsigned long long value.\n * The function attempts to use the faster string2ll() function inside\n * Redis: if it fails, strtoull() is used instead. The function returns\n * 1 if the conversion happened successfully or 0 if the number is\n * invalid or out of range. */\nint string2ull(const char *s, unsigned long long *value) {\n    long long ll;\n    if (string2ll(s,strlen(s),&ll)) {\n        if (ll < 0) return 0; /* Negative values are out of range. */\n        *value = ll;\n        return 1;\n    }\n    errno = 0;\n    char *endptr = NULL;\n    *value = strtoull(s,&endptr,10);\n    if (errno == EINVAL || errno == ERANGE || !(*s != '\\0' && *endptr == '\\0'))\n        return 0; /* strtoull() failed. */\n    return 1; /* Conversion done! */\n}\n\n/* Parse a stream ID in the format given by clients to Redis, that is\n * <ms>-<seq>, and converts it into a streamID structure. If\n * the specified ID is invalid C_ERR is returned and an error is reported\n * to the client, otherwise C_OK is returned. The ID may be in incomplete\n * form, just stating the milliseconds time part of the stream. In such a case\n * the missing part is set according to the value of 'missing_seq' parameter.\n * The IDs \"-\" and \"+\" specify respectively the minimum and maximum IDs\n * that can be represented.\n *\n * If 'c' is set to NULL, no reply is sent to the client. */\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {\n    char buf[128];\n    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;\n    memcpy(buf,o->ptr,sdslen(o->ptr)+1);\n\n    /* Handle the \"-\" and \"+\" special cases. */\n    if (buf[0] == '-' && buf[1] == '\\0') {\n        id->ms = 0;\n        id->seq = 0;\n        return C_OK;\n    } else if (buf[0] == '+' && buf[1] == '\\0') {\n        id->ms = UINT64_MAX;\n        id->seq = UINT64_MAX;\n        return C_OK;\n    }\n\n    /* Parse <ms>-<seq> form. */\n    char *dot = strchr(buf,'-');\n    if (dot) *dot = '\\0';\n    unsigned long long ms, seq;\n    if (string2ull(buf,&ms) == 0) goto invalid;\n    if (dot && string2ull(dot+1,&seq) == 0) goto invalid;\n    if (!dot) seq = missing_seq;\n    id->ms = ms;\n    id->seq = seq;\n    return C_OK;\n\ninvalid:\n    if (c) addReplyError(c,\"Invalid stream ID specified as stream \"\n                           \"command argument\");\n    return C_ERR;\n}\n\n/* XADD key [MAXLEN <count>] <ID or *> [field value] [field value] ... */\nvoid xaddCommand(client *c) {\n    streamID id;\n    int id_given = 0; /* Was an ID different than \"*\" specified? */\n    long long maxlen = 0;   /* 0 means no maximum length. */\n    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so\n                               the maxium length is not applied verbatim. */\n    int maxlen_arg_idx = 0; /* Index of the count in MAXLEN, for rewriting. */\n\n    /* Parse options. */\n    int i = 2; /* This is the first argument position where we could\n                  find an option, or the ID. */\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (opt[0] == '*' && opt[1] == '\\0') {\n            /* This is just a fast path for the common case of auto-ID\n             * creation. */\n            break;\n        } else if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                approx_maxlen = 1;\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)\n                != C_OK) return;\n            i++;\n            maxlen_arg_idx = i;\n        } else {\n            /* If we are here is a syntax error or a valid ID. */\n            if (streamParseIDOrReply(c,c->argv[i],&id,0) != C_OK) return;\n            id_given = 1;\n            break;\n        }\n    }\n    int field_pos = i+1;\n\n    /* Check arity. */\n    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {\n        addReplyError(c,\"wrong number of arguments for XADD\");\n        return;\n    }\n\n    /* Lookup the stream at key. */\n    robj *o;\n    stream *s;\n    if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    s = o->ptr;\n\n    /* Append using the low level function and return the ID. */\n    if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,\n        &id, id_given ? &id : NULL)\n        == C_ERR)\n    {\n        addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"\n                        \"target stream top item\");\n        return;\n    }\n    addReplyStreamID(c,&id);\n\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xadd\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Remove older elements if MAXLEN was specified. */\n    if (maxlen) {\n        if (!streamTrimByLength(s,maxlen,approx_maxlen)) {\n            /* If no trimming was performed, for instance because approximated\n             * trimming length was specified, rewrite the MAXLEN argument\n             * as zero, so that the command is propagated without trimming. */\n            robj *zeroobj = createStringObjectFromLongLong(0);\n            rewriteClientCommandArgument(c,maxlen_arg_idx,zeroobj);\n            decrRefCount(zeroobj);\n        } else {\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        }\n    }\n\n    /* Let's rewrite the ID argument with the one actually generated for\n     * AOF/replication propagation. */\n    robj *idarg = createObjectFromStreamID(&id);\n    rewriteClientCommandArgument(c,i,idarg);\n    decrRefCount(idarg);\n\n    /* We need to signal to blocked clients that there is new data on this\n     * stream. */\n    if (server.blocked_clients_by_type[BLOCKED_STREAM])\n        signalKeyAsReady(c->db, c->argv[1]);\n}\n\n/* XRANGE/XREVRANGE actual implementation. */\nvoid xrangeGenericCommand(client *c, int rev) {\n    robj *o;\n    stream *s;\n    streamID startid, endid;\n    long long count = 0;\n    robj *startarg = rev ? c->argv[3] : c->argv[2];\n    robj *endarg = rev ? c->argv[2] : c->argv[3];\n\n    if (streamParseIDOrReply(c,startarg,&startid,0) == C_ERR) return;\n    if (streamParseIDOrReply(c,endarg,&endid,UINT64_MAX) == C_ERR) return;\n\n    /* Parse the COUNT option if any. */\n    if (c->argc > 4) {\n        for (int j = 4; j < c->argc; j++) {\n            int additional = c->argc-j-1;\n            if (strcasecmp(c->argv[j]->ptr,\"COUNT\") == 0 && additional >= 1) {\n                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)\n                    != C_OK) return;\n                if (count < 0) count = 0;\n                j++; /* Consume additional arg. */\n            } else {\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Return the specified range to the user. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    s = o->ptr;\n    streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);\n}\n\n/* XRANGE key start end [COUNT <n>] */\nvoid xrangeCommand(client *c) {\n    xrangeGenericCommand(c,0);\n}\n\n/* XREVRANGE key end start [COUNT <n>] */\nvoid xrevrangeCommand(client *c) {\n    xrangeGenericCommand(c,1);\n}\n\n/* XLEN */\nvoid xlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n    addReplyLongLong(c,s->length);\n}\n\n/* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N\n *       ID_1 ID_2 ... ID_N\n *\n * This function also implements the XREAD-GROUP command, which is like XREAD\n * but accepting the [GROUP group-name consumer-name] additional option.\n * This is useful because while XREAD is a read command and can be called\n * on slaves, XREAD-GROUP is not. */\n#define XREAD_BLOCKED_DEFAULT_COUNT 1000\nvoid xreadCommand(client *c) {\n    long long timeout = -1; /* -1 means, no BLOCK argument given. */\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;          /* True if NOACK option was specified. */\n    #define STREAMID_STATIC_VECTOR_LEN 8\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    streamCG **groups = NULL;\n    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */\n    robj *groupname = NULL;\n    robj *consumername = NULL;\n\n    /* Parse arguments. */\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc-i-1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o,\"BLOCK\") && moreargs) {\n            i++;\n            if (getTimeoutFromObjectOrReply(c,c->argv[i],&timeout,\n                UNIT_MILLISECONDS) != C_OK) return;\n        } else if (!strcasecmp(o,\"COUNT\") && moreargs) {\n            i++;\n            if (getLongLongFromObjectOrReply(c,c->argv[i],&count,NULL) != C_OK)\n                return;\n            if (count < 0) count = 0;\n        } else if (!strcasecmp(o,\"STREAMS\") && moreargs) {\n            streams_arg = i+1;\n            streams_count = (c->argc-streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c,\"Unbalanced XREAD list of streams: \"\n                                \"for each stream key an ID or '$' must be \"\n                                \"specified.\");\n                return;\n            }\n            streams_count /= 2; /* We have two arguments for each stream. */\n            break;\n        } else if (!strcasecmp(o,\"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The GROUP option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i+1];\n            consumername = c->argv[i+2];\n            i += 2;\n        } else if (!strcasecmp(o,\"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The NOACK option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* STREAMS option is mandatory. */\n    if (streams_arg == 0) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* If the user specified XREADGROUP then it must also\n     * provide the GROUP option. */\n    if (xreadgroup && groupname == NULL) {\n        addReplyError(c,\"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n\n    /* Parse the IDs and resolve the group name. */\n    if (streams_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*streams_count);\n    if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);\n\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        /* Specifying \"$\" as last-known-id means that the client wants to be\n         * served with just the messages that will arrive into the stream\n         * starting from now. */\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i-streams_count];\n        robj *o;\n        streamCG *group = NULL;\n\n        /* If a group was specified, than we need to be sure that the\n         * key and group actually exist. */\n        if (groupname) {\n            o = lookupKeyRead(c->db,key);\n            if (o && checkType(c,o,OBJ_STREAM)) goto cleanup;\n            if (o == NULL ||\n                (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n            {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                                       \"group '%s' in XREADGROUP with GROUP \"\n                                       \"option\",\n                                    (char*)key->ptr,(char*)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n\n        if (strcmp(c->argv[i]->ptr,\"$\") == 0) {\n            o = lookupKeyRead(c->db,key);\n            if (o && checkType(c,o,OBJ_STREAM)) goto cleanup;\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = s->last_id;\n            } else {\n                ids[id_idx].ms = 0;\n                ids[id_idx].seq = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr,\">\") == 0) {\n            if (!xreadgroup || groupname == NULL) {\n                addReplyError(c,\"The > ID can be specified only when calling \"\n                                \"XREADGROUP using the GROUP <group> \"\n                                \"<consumer> option.\");\n                goto cleanup;\n            }\n            ids[id_idx] = group->last_id;\n            continue;\n        }\n        if (streamParseIDOrReply(c,c->argv[i],ids+id_idx,0) != C_OK)\n            goto cleanup;\n    }\n\n    /* Try to serve the client synchronously. */\n    size_t arraylen = 0;\n    void *arraylen_ptr = NULL;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db,c->argv[streams_arg+i]);\n        if (o == NULL) continue;\n        stream *s = o->ptr;\n        streamID *gt = ids+i; /* ID must be greater than this. */\n        if (s->last_id.ms > gt->ms ||\n            (s->last_id.ms == gt->ms && s->last_id.seq > gt->seq))\n        {\n            arraylen++;\n            if (arraylen == 1) arraylen_ptr = addDeferredMultiBulkLength(c);\n            /* streamReplyWithRange() handles the 'start' ID as inclusive,\n             * so start from the next ID, since we want only messages with\n             * IDs greater than start. */\n            streamID start = *gt;\n            start.seq++; /* uint64_t can't overflow in this context. */\n\n            /* Emit the two elements sub-array consisting of the name\n             * of the stream and the data we extracted from it. */\n            addReplyMultiBulkLen(c,2);\n            addReplyBulk(c,c->argv[i+streams_arg]);\n            streamConsumer *consumer = NULL;\n            if (groups) consumer = streamLookupConsumer(groups[i],\n                                                        consumername->ptr,1);\n            streamPropInfo spi = {c->argv[i+streams_arg],groupname};\n            streamReplyWithRange(c,s,&start,NULL,count,0,\n                                 groups ? groups[i] : NULL,\n                                 consumer, noack, &spi);\n            if (groups) server.dirty++;\n        }\n    }\n\n     /* We replied synchronously! Set the top array len and return to caller. */\n    if (arraylen) {\n        setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n        goto cleanup;\n    }\n\n    /* Block if needed. */\n    if (timeout != -1) {\n        /* If we are inside a MULTI/EXEC and the list is empty the only thing\n         * we can do is treating it as a timeout (even with timeout 0). */\n        if (c->flags & CLIENT_MULTI) {\n            addReply(c,shared.nullmultibulk);\n            goto cleanup;\n        }\n        blockForKeys(c, BLOCKED_STREAM, c->argv+streams_arg, streams_count,\n                     timeout, NULL, ids);\n        /* If no COUNT is given and we block, set a relatively small count:\n         * in case the ID provided is too low, we do not want the server to\n         * block just to serve this client a huge stream of messages. */\n        c->bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;\n\n        /* If this is a XREADGROUP + GROUP we need to remember for which\n         * group and consumer name we are blocking, so later when one of the\n         * keys receive more data, we can call streamReplyWithRange() passing\n         * the right arguments. */\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            c->bpop.xread_group = groupname;\n            c->bpop.xread_consumer = consumername;\n        } else {\n            c->bpop.xread_group = NULL;\n            c->bpop.xread_consumer = NULL;\n        }\n        goto cleanup;\n    }\n\n    /* No BLOCK option, nor any stream we can serve. Reply as with a\n     * timeout happened. */\n    addReply(c,shared.nullmultibulk);\n    /* Continue to cleanup... */\n\ncleanup: /* Cleanup. */\n\n    /* The command is propagated (in the READGROUP form) as a side effect\n     * of calling lower level APIs. So stop any implicit propagation. */\n    preventCommandPropagation(c);\n    if (ids != static_ids) zfree(ids);\n    zfree(groups);\n}\n\n/* -----------------------------------------------------------------------\n * Low level implementation of consumer groups\n * ----------------------------------------------------------------------- */\n\n/* Create a NACK entry setting the delivery count to 1 and the delivery\n * time to the current time. The NACK consumer will be set to the one\n * specified as argument of the function. */\nstreamNACK *streamCreateNACK(streamConsumer *consumer) {\n    streamNACK *nack = zmalloc(sizeof(*nack));\n    nack->delivery_time = mstime();\n    nack->delivery_count = 1;\n    nack->consumer = consumer;\n    return nack;\n}\n\n/* Free a NACK entry. */\nvoid streamFreeNACK(streamNACK *na) {\n    zfree(na);\n}\n\n/* Free a consumer and associated data structures. Note that this function\n * will not reassign the pending messages associated with this consumer\n * nor will delete them from the stream, so when this function is called\n * to delete a consumer, and not when the whole stream is destroyed, the caller\n * should do some work before. */\nvoid streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); /* No value free callback: the PEL entries are shared\n                         between the consumer and the main stream PEL. */\n    sdsfree(sc->name);\n    zfree(sc);\n}\n\n/* Create a new consumer group in the context of the stream 's', having the\n * specified name and last server ID. If a consumer group with the same name\n * already existed NULL is returned, otherwise the pointer to the consumer\n * group is returned. */\nstreamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n\n/* Free a consumer group and all its associated data. */\nvoid streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n\n/* Lookup the consumer group in the specified stream and returns its\n * pointer, otherwise if there is no such group, NULL is returned. */\nstreamCG *streamLookupCG(stream *s, sds groupname) {\n    if (s->cgroups == NULL) return NULL;\n    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,\n                           sdslen(groupname));\n    return (cg == raxNotFound) ? NULL : cg;\n}\n\n/* Lookup the consumer with the specified name in the group 'cg': if the\n * consumer does not exist it is automatically created as a side effect\n * of calling this function, otherwise its last seen time is updated and\n * the existing consumer reference returned. */\nstreamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                               sdslen(name));\n    if (consumer == raxNotFound) {\n        if (!create) return NULL;\n        consumer = zmalloc(sizeof(*consumer));\n        consumer->name = sdsdup(name);\n        consumer->pel = raxNew();\n        raxInsert(cg->consumers,(unsigned char*)name,sdslen(name),\n                  consumer,NULL);\n    }\n    consumer->seen_time = mstime();\n    return consumer;\n}\n\n/* Delete the consumer specified in the consumer group 'cg'. The consumer\n * may have pending messages: they are removed from the PEL, and the number\n * of pending messages \"lost\" is returned. */\nuint64_t streamDelConsumer(streamCG *cg, sds name) {\n    streamConsumer *consumer = streamLookupConsumer(cg,name,0);\n    if (consumer == NULL) return 0;\n\n    uint64_t retval = raxSize(consumer->pel);\n\n    /* Iterate all the consumer pending messages, deleting every corresponding\n     * entry from the global entry. */\n    raxIterator ri;\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n        raxRemove(cg->pel,ri.key,ri.key_len,NULL);\n        streamFreeNACK(nack);\n    }\n    raxStop(&ri);\n\n    /* Deallocate the consumer. */\n    raxRemove(cg->consumers,(unsigned char*)name,sdslen(name),NULL);\n    streamFreeConsumer(consumer);\n    return retval;\n}\n\n/* -----------------------------------------------------------------------\n * Consumer groups commands\n * ----------------------------------------------------------------------- */\n\n/* XGROUP CREATE <key> <groupname> <id or $>\n * XGROUP SETID <key> <id or $>\n * XGROUP DELGROUP <key> <groupname>\n * XGROUP DELCONSUMER <key> <groupname> <consumername> */\nvoid xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}\n\n/* XACK <key> <group> <id> <id> ... <id>\n *\n * Acknowledge a message as processed. In practical terms we just check the\n * pendine entries list (PEL) of the group, and delete the PEL entry both from\n * the group and the consumer (pending messages are referenced in both places).\n *\n * Return value of the command is the number of messages successfully\n * acknowledged, that is, the IDs we were actually able to resolve in the PEL.\n */\nvoid xackCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Nothing to ack. */\n    if (o == NULL || group == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        streamID id;\n        unsigned char buf[sizeof(streamID)];\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL: it will have a reference to the\n         * NACK structure that will have a reference to the consumer, so that\n         * we are able to remove the entry from both PELs. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n        if (nack != raxNotFound) {\n            raxRemove(group->pel,buf,sizeof(buf),NULL);\n            raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c,acknowledged);\n}\n\n/* XPENDING <key> <group> [<start> <stop> <count>] [<consumer>]\n *\n * If start and stop are omitted, the command just outputs information about\n * the amount of pending messages for the key/group pair, together with\n * the minimum and maxium ID of pending messages.\n *\n * If start and stop are provided instead, the pending messages are returned\n * with informations about the current owner, number of deliveries and last\n * delivery time and so forth. */\nvoid xpendingCommand(client *c) {\n    int justinfo = c->argc == 3; /* Without the range just outputs general\n                                    informations about the PEL. */\n    robj *key = c->argv[1];\n    robj *groupname = c->argv[2];\n    robj *consumername = (c->argc == 7) ? c->argv[6] : NULL;\n    streamID startid, endid;\n    long long count;\n\n    /* Start and stop, and the consumer, can be omitted. */\n    if (c->argc != 3 && c->argc != 6 && c->argc != 7) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Parse start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (c->argc >= 6) {\n        if (getLongLongFromObjectOrReply(c,c->argv[5],&count,NULL) == C_ERR)\n            return;\n        if (streamParseIDOrReply(c,c->argv[3],&startid,0) == C_ERR)\n            return;\n        if (streamParseIDOrReply(c,c->argv[4],&endid,UINT64_MAX) == C_ERR)\n            return;\n    }\n\n    /* Lookup the key and the group inside the stream. */\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    streamCG *group;\n\n    if (o && checkType(c,o,OBJ_STREAM)) return;\n    if (o == NULL ||\n        (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n    {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                               \"group '%s'\",\n                               (char*)key->ptr,(char*)groupname->ptr);\n        return;\n    }\n\n    /* XPENDING <key> <group> variant. */\n    if (justinfo) {\n        addReplyMultiBulkLen(c,4);\n        /* Total number of messages in the PEL. */\n        addReplyLongLong(c,raxSize(group->pel));\n        /* First and last IDs. */\n        if (raxSize(group->pel) == 0) {\n            addReply(c,shared.nullbulk); /* Start. */\n            addReply(c,shared.nullbulk); /* End. */\n            addReply(c,shared.nullmultibulk); /* Clients. */\n        } else {\n            /* Start. */\n            raxIterator ri;\n            raxStart(&ri,group->pel);\n            raxSeek(&ri,\"^\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&startid);\n            addReplyStreamID(c,&startid);\n\n            /* End. */\n            raxSeek(&ri,\"$\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&endid);\n            addReplyStreamID(c,&endid);\n            raxStop(&ri);\n\n            /* Consumers with pending messages. */\n            raxStart(&ri,group->consumers);\n            raxSeek(&ri,\"^\",NULL,0);\n            void *arraylen_ptr = addDeferredMultiBulkLength(c);\n            size_t arraylen = 0;\n            while(raxNext(&ri)) {\n                streamConsumer *consumer = ri.data;\n                if (raxSize(consumer->pel) == 0) continue;\n                addReplyMultiBulkLen(c,2);\n                addReplyBulkCBuffer(c,ri.key,ri.key_len);\n                addReplyBulkLongLong(c,raxSize(consumer->pel));\n                arraylen++;\n            }\n            setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n            raxStop(&ri);\n        }\n    }\n    /* XPENDING <key> <group> <start> <stop> <count> [<consumer>] variant. */\n    else {\n        streamConsumer *consumer = consumername ?\n                                streamLookupConsumer(group,consumername->ptr,0):\n                                NULL;\n\n        /* If a consumer name was mentioned but it does not exist, we can\n         * just return an empty array. */\n        if (consumername && consumer == NULL) {\n            addReplyMultiBulkLen(c,0);\n            return;\n        }\n\n        rax *pel = consumer ? consumer->pel : group->pel;\n        unsigned char startkey[sizeof(streamID)];\n        unsigned char endkey[sizeof(streamID)];\n        raxIterator ri;\n        mstime_t now = mstime();\n\n        streamEncodeID(startkey,&startid);\n        streamEncodeID(endkey,&endid);\n        raxStart(&ri,pel);\n        raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n        void *arraylen_ptr = addDeferredMultiBulkLength(c);\n        size_t arraylen = 0;\n\n        while(count && raxNext(&ri) && memcmp(ri.key,endkey,ri.key_len) <= 0) {\n            streamNACK *nack = ri.data;\n\n            arraylen++;\n            count--;\n            addReplyMultiBulkLen(c,4);\n\n            /* Entry ID. */\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n\n            /* Consumer name. */\n            addReplyBulkCBuffer(c,nack->consumer->name,\n                                sdslen(nack->consumer->name));\n\n            /* Milliseconds elapsed since last delivery. */\n            mstime_t elapsed = now - nack->delivery_time;\n            if (elapsed < 0) elapsed = 0;\n            addReplyLongLong(c,elapsed);\n\n            /* Number of deliveries. */\n            addReplyLongLong(c,nack->delivery_count);\n        }\n        raxStop(&ri);\n        setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);\n    }\n}\n\n/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>\n *        [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]\n *        [FORCE] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * If the message ID (among the specified ones) exists, and its idle\n * time greater or equal to <min-idle-time>, then the message new owner\n * becomes the specified <consumer>. If the minimum idle time specified\n * is zero, messages are claimed regardless of their idle time.\n *\n * All the messages that cannot be found inside the pending entries list\n * are ignored, but in case the FORCE option is used. In that case we\n * create the NACK (representing a not yet acknowledged message) entry in\n * the consumer group PEL.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0,\n * even if by using the IDLE or TIME options, the user can control the\n * new idle time.\n *\n * The options at the end can be used in order to specify more attributes\n * to set in the representation of the pending message:\n *\n * 1. IDLE <ms>:\n *      Set the idle time (last time it was delivered) of the message.\n *      If IDLE is not specified, an IDLE of 0 is assumed, that is,\n *      the time count is reset because the message has now a new\n *      owner trying to process it.\n *\n * 2. TIME <ms-unix-time>:\n *      This is the same as IDLE but instead of a relative amount of\n *      milliseconds, it sets the idle time to a specific unix time\n *      (in milliseconds). This is useful in order to rewrite the AOF\n *      file generating XCLAIM commands.\n *\n * 3. RETRYCOUNT <count>:\n *      Set the retry counter to the specified value. This counter is\n *      incremented every time a message is delivered again. Normally\n *      XCLAIM does not alter this counter, which is just served to clients\n *      when the XPENDING command is called: this way clients can detect\n *      anomalies, like messages that are never processed for some reason\n *      after a big number of delivery attempts.\n *\n * 4. FORCE:\n *      Creates the pending message entry in the PEL even if certain\n *      specified IDs are not already in the PEL assigned to a different\n *      client. However the message must be exist in the stream, otherwise\n *      the IDs of non existing messages are ignored.\n *\n * 5. JUSTID:\n *      Return just an array of IDs of messages successfully claimed,\n *      without returning the actual message.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument. */\n    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */\n    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */\n    int force = 0;\n    int justid = 0;\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or \"\n                              \"consumer group '%s'\", (char*)c->argv[1]->ptr,\n                              (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\n        \"Invalid min-idle-time argument for XCLAIM\")\n        != C_OK) return;\n    if (minidle < 0) minidle = 0;\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully claimed some message, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    int j;\n    for (j = 4; j < c->argc; j++) {\n        streamID id;\n        if (streamParseIDOrReply(NULL,c->argv[j],&id,0) != C_OK) break;\n    }\n    int last_id_arg = j-1; /* Next time we iterate the IDs we now the range. */\n\n    /* If we stopped because some IDs cannot be parsed, perhaps they\n     * are trailing options. */\n    time_t now = mstime();\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt,\"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt,\"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n        } else if (!strcasecmp(opt,\"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&retrycount,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) return;\n        } else {\n            addReplyErrorFormat(c,\"Unrecognized XCLAIM option '%s'\",opt);\n            return;\n        }\n    }\n\n    if (deliverytime != -1) {\n        /* If a delivery time was passed, either with IDLE or TIME, we\n         * do some sanity check on it, and set the deliverytime to now\n         * (which is a sane choice usually) if the value is bogus.\n         * To raise an error here is not wise because clients may compute\n         * the idle time doing some math startin from their local time,\n         * and this is not a good excuse to fail in case, for instance,\n         * the computed time is a bit in the future from our POV. */\n        if (deliverytime < 0 || deliverytime > now) deliverytime = now;\n    } else {\n        /* If no IDLE/TIME option was passed, we want the last delivery\n         * time to be now, so that the idle time of the message will be\n         * zero. */\n        deliverytime = now;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = streamLookupConsumer(group,c->argv[3]->ptr,1);\n    void *arraylenptr = addDeferredMultiBulkLength(c);\n    size_t arraylen = 0;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id;\n        unsigned char buf[sizeof(streamID)];\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n\n        /* If FORCE is passed, let's check if at least the entry\n         * exists in the Stream. In such case, we'll crate a new\n         * entry in the PEL from scratch, so that XCLAIM can also\n         * be used to create entries in the PEL. Useful for AOF\n         * and replication of consumer groups. */\n        if (force && nack == raxNotFound) {\n            streamIterator myiterator;\n            streamIteratorStart(&myiterator,o->ptr,&id,&id,0);\n            int64_t numfields;\n            int found = 0;\n            streamID item_id;\n            if (streamIteratorGetID(&myiterator,&item_id,&numfields)) found = 1;\n            streamIteratorStop(&myiterator);\n\n            /* Item must exist for us to create a NACK for it. */\n            if (!found) continue;\n\n            /* Create the NACK. */\n            nack = streamCreateNACK(NULL);\n            raxInsert(group->pel,buf,sizeof(buf),nack,NULL);\n        }\n\n        if (nack != raxNotFound) {\n            /* We need to check if the minimum idle time requested\n             * by the caller is satisfied by this entry. */\n            if (minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n            /* Remove the entry from the old consumer.\n             * Note that nack->consumer is NULL if we created the\n             * NACK above because of the FORCE option. */\n            if (nack->consumer)\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            /* Update the consumer and idle time. */\n            nack->consumer = consumer;\n            nack->delivery_time = deliverytime;\n            /* Set the delivery attempts counter if given. */\n            if (retrycount >= 0) nack->delivery_count = retrycount;\n            /* Add the entry in the new consumer local PEL. */\n            raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            /* Send the reply for this entry. */\n            if (justid) {\n                addReplyStreamID(c,&id);\n            } else {\n                streamReplyWithRange(c,o->ptr,&id,NULL,1,0,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n            }\n            arraylen++;\n\n            /* Propagate this change. */\n            streamPropagateXCLAIM(c,c->argv[1],c->argv[3],c->argv[j],nack);\n            server.dirty++;\n        }\n    }\n    setDeferredMultiBulkLength(c,arraylenptr,arraylen);\n    preventCommandPropagation(c);\n}\n\n\n/* XDEL <key> [<ID1> <ID2> ... <IDN>]\n *\n * Removes the specified entries from the stream. Returns the number\n * of items actaully deleted, that may be different from the number\n * of IDs passed in case certain IDs do not exist. */\nvoid xdelCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* We need to sanity check the IDs passed to start. Even if not\n     * a big issue, it is not great that the command is only partially\n     * executed becuase at some point an invalid ID is parsed. */\n    streamID id;\n    for (int j = 2; j < c->argc; j++) {\n        if (streamParseIDOrReply(c,c->argv[j],&id,0) != C_OK) return;\n    }\n\n    /* Actaully apply the command. */\n    int deleted = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamParseIDOrReply(c,c->argv[j],&id,0); /* Retval already checked. */\n        deleted += streamDeleteItem(s,&id);\n    }\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xdel\",c->argv[1],c->db->id);\n    server.dirty += deleted;\n    addReplyLongLong(c,deleted);\n}\n\n/* General form: XTRIM <key> [... options ...]\n *\n * List of options:\n *\n * MAXLEN [~] <count>       -- Trim so that the stream will be capped at\n *                             the specified length. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MAXLEN option).\n */\n\n#define TRIM_STRATEGY_NONE 0\n#define TRIM_STRATEGY_MAXLEN 1\nvoid xtrimCommand(client *c) {\n    robj *o;\n\n    /* If the key does not exist, we are ok returning zero, that is, the\n     * number of elements removed from the stream. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* Argument parsing. */\n    int trim_strategy = TRIM_STRATEGY_NONE;\n    long long maxlen = 0;   /* 0 means no maximum length. */\n    int approx_maxlen = 0;  /* If 1 only delete whole radix tree nodes, so\n                               the maxium length is not applied verbatim. */\n\n    /* Parse options. */\n    int i = 2; /* Start of options. */\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            trim_strategy = TRIM_STRATEGY_MAXLEN;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                approx_maxlen = 1;\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)\n                != C_OK) return;\n            i++;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* Perform the trimming. */\n    int64_t deleted = 0;\n    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n        deleted = streamTrimByLength(s,maxlen,approx_maxlen);\n    } else {\n        addReplyError(c,\"XTRIM called without an option to trim the stream\");\n        return;\n    }\n\n    /* Propagate the write if needed. */\n    if (deleted) {\n        signalModifiedKey(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\n/* XINFO CONSUMERS key group\n * XINFO GROUPS <key>\n * XINFO STREAM <key>\n * XINFO HELP. */\nvoid xinfoCommand(client *c) {\n    const char *help[] = {\n\"CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.\",\n\"GROUPS <key>                 -- Show the stream consumer groups.\",\n\"STREAM <key>                 -- Show information about the stream.\",\n\"HELP                         -- Print this help.\",\nNULL\n    };\n    stream *s = NULL;\n    char *opt;\n    robj *key;\n\n    /* HELP is special. Handle it ASAP. */\n    if (!strcasecmp(c->argv[1]->ptr,\"HELP\")) {\n        addReplyHelp(c, help);\n        return;\n    } else if (c->argc < 3) {\n        addReplyError(c,\"syntax error, try 'XINFO HELP'\");\n        return;\n    }\n\n    /* With the exception of HELP handled before any other sub commands, all\n     * the ones are in the form of \"<subcommand> <key>\". */\n    opt = c->argv[1]->ptr;\n    key = c->argv[2];\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    robj *o = lookupKeyWriteOrReply(c,key,shared.nokeyerr);\n    if (o == NULL) return;\n    s = o->ptr;\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CONSUMERS\") && c->argc == 4) {\n        /* XINFO CONSUMERS <key> <group>. */\n        streamCG *cg = streamLookupCG(s,c->argv[3]->ptr);\n        if (cg == NULL) {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)c->argv[3]->ptr, (char*)key->ptr);\n            return;\n        }\n\n        addReplyMultiBulkLen(c,raxSize(cg->consumers));\n        raxIterator ri;\n        raxStart(&ri,cg->consumers);\n        raxSeek(&ri,\"^\",NULL,0);\n        mstime_t now = mstime();\n        while(raxNext(&ri)) {\n            streamConsumer *consumer = ri.data;\n            mstime_t idle = now - consumer->seen_time;\n            if (idle < 0) idle = 0;\n\n            addReplyMultiBulkLen(c,6);\n            addReplyStatus(c,\"name\");\n            addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n            addReplyStatus(c,\"pending\");\n            addReplyLongLong(c,raxSize(consumer->pel));\n            addReplyStatus(c,\"idle\");\n            addReplyLongLong(c,idle);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"GROUPS\") && c->argc == 3) {\n        /* XINFO GROUPS <key>. */\n        if (s->cgroups == NULL) {\n            addReplyMultiBulkLen(c,0);\n            return;\n        }\n\n        addReplyMultiBulkLen(c,raxSize(s->cgroups));\n        raxIterator ri;\n        raxStart(&ri,s->cgroups);\n        raxSeek(&ri,\"^\",NULL,0);\n        while(raxNext(&ri)) {\n            streamCG *cg = ri.data;\n            addReplyMultiBulkLen(c,6);\n            addReplyStatus(c,\"name\");\n            addReplyBulkCBuffer(c,ri.key,ri.key_len);\n            addReplyStatus(c,\"consumers\");\n            addReplyLongLong(c,raxSize(cg->consumers));\n            addReplyStatus(c,\"pending\");\n            addReplyLongLong(c,raxSize(cg->pel));\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"STREAM\") && c->argc == 3) {\n        /* XINFO STREAM <key> (or the alias XINFO <key>). */\n        addReplyMultiBulkLen(c,12);\n        addReplyStatus(c,\"length\");\n        addReplyLongLong(c,s->length);\n        addReplyStatus(c,\"radix-tree-keys\");\n        addReplyLongLong(c,raxSize(s->rax));\n        addReplyStatus(c,\"radix-tree-nodes\");\n        addReplyLongLong(c,s->rax->numnodes);\n        addReplyStatus(c,\"groups\");\n        addReplyLongLong(c,s->cgroups ? raxSize(s->cgroups) : 0);\n\n        /* To emit the first/last entry we us the streamReplyWithRange()\n         * API. */\n        int count;\n        streamID start, end;\n        start.ms = start.seq = 0;\n        end.ms = end.seq = UINT64_MAX;\n        addReplyStatus(c,\"first-entry\");\n        count = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n        if (!count) addReply(c,shared.nullbulk);\n        addReplyStatus(c,\"last-entry\");\n        count = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,\n                                     STREAM_RWR_RAWENTRIES,NULL);\n        if (!count) addReply(c,shared.nullbulk);\n    } else {\n        addReplyError(c,\"syntax error, try 'XINFO HELP'\");\n    }\n}\n\n"], "filenames": ["src/t_stream.c"], "buggy_code_start_loc": [1579], "buggy_code_end_loc": [1580], "fixing_code_start_loc": [1579], "fixing_code_end_loc": [1580], "type": "CWE-704", "message": "Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.", "other": {"cve": {"id": "CVE-2018-12453", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-16T17:29:00.207", "lastModified": "2018-08-14T17:37:13.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream."}, {"lang": "es", "value": "Confusi\u00f3n de tipos en la funci\u00f3n xgroupCommand en t_stream.c en redis-server en Redis en versiones anteriores a la 5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (DoS) mediante un comando XGROUP en el que la clave no es una secuencia."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-704"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0", "matchCriteriaId": "C5695E3B-F320-419F-9CD5-C7F4B6C92C23"}]}]}], "references": [{"url": "https://gist.github.com/fakhrizulkifli/34a56d575030682f6c564553c53b82b5", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44908/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6"}}