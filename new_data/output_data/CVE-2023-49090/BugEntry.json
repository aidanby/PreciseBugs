{"buggy_code": ["module CarrierWave\n  module Uploader\n    module ContentTypeWhitelist\n      extend ActiveSupport::Concern\n\n      included do\n        before :cache, :check_content_type_whitelist!\n      end\n\n      ##\n      # Override this method in your uploader to provide an allowlist of files content types\n      # which are allowed to be uploaded.\n      # Not only strings but Regexp are allowed as well.\n      #\n      # === Returns\n      #\n      # [NilClass, String, Regexp, Array[String, Regexp]] an allowlist of content types which are allowed to be uploaded\n      #\n      # === Examples\n      #\n      #     def content_type_allowlist\n      #       %w(text/json application/json)\n      #     end\n      #\n      # Basically the same, but using a Regexp:\n      #\n      #     def content_type_allowlist\n      #       [/(text|application)\\/json/]\n      #     end\n      #\n      def content_type_allowlist\n        if respond_to?(:content_type_whitelist)\n          ActiveSupport::Deprecation.warn \"#content_type_whitelist is deprecated, use #content_type_allowlist instead.\" unless instance_variable_defined?(:@content_type_whitelist_warned)\n          @content_type_whitelist_warned = true\n          content_type_whitelist\n        end\n      end\n\n    private\n\n      def check_content_type_whitelist!(new_file)\n        return unless content_type_allowlist\n\n        content_type = new_file.content_type\n        if !whitelisted_content_type?(content_type)\n          raise CarrierWave::IntegrityError, I18n.translate(:\"errors.messages.content_type_whitelist_error\", content_type: content_type,\n                                                            allowed_types: Array(content_type_allowlist).join(\", \"), default: :\"errors.messages.content_type_allowlist_error\")\n        end\n      end\n\n      def whitelisted_content_type?(content_type)\n        Array(content_type_allowlist).any? do |item|\n          item = Regexp.quote(item) if item.class != Regexp\n          content_type =~ /#{item}/\n        end\n      end\n\n    end # ContentTypeWhitelist\n  end # Uploader\nend # CarrierWave\n", "require 'spec_helper'\n\ndescribe CarrierWave::Uploader do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:ruby_file) { File.open(file_path('ruby.gif')) }\n  let(:bork_file) { File.open(file_path('bork.txt')) }\n  let(:vector_file) { File.open(file_path('ruby.svg')) }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '#cache!' do\n    before do\n      allow(CarrierWave).to receive(:generate_cache_id).and_return('1369894322-345-1234-2255')\n    end\n\n    context \"when there is no allowlist\" do\n      it \"does not raise an integrity error\" do\n        allow(uploader).to receive(:content_type_allowlist).and_return(nil)\n\n        expect { uploader.cache!(ruby_file) }.not_to raise_error\n      end\n    end\n\n    context \"when there is an allowlist\" do\n      context \"when the allowlist is an array of values\" do\n        it \"does not raise an integrity error when the file has an allowlisted content type\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/png'])\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"accepts content types with a + symbol\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/svg+xml'])\n\n          expect { uploader.cache!(vector_file) }.not_to raise_error\n        end\n\n        it \"accepts a list of content types with mixed regular expressions and strings\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['application/pdf', %r{image/}])\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"raises an integrity error the file has not an allowlisted content type\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif'])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n\n        it \"accepts content types as regular expressions\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return([/image\\//])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n\n        it \"raises an integrity error which lists the allowed content types\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif', 'image/jpg'])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError, %r{(?:image/gif|image/jpg)})\n        end\n      end\n\n      context \"when the allowlist is a single value\" do\n        let(:test_file) { File.open(file_path('test.jpeg')) }\n\n        it \"accepts a single content type string value\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return('image/png')\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"accepts a single content type regular expression value\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(/image\\//)\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n      end\n    end\n\n    context \"when there is a whitelist\" do\n      it \"uses the whitelist but shows deprecation\" do\n        allow(uploader).to receive(:content_type_whitelist).and_return(['image/gif'])\n\n        expect(ActiveSupport::Deprecation).to receive(:warn).with('#content_type_whitelist is deprecated, use #content_type_allowlist instead.')\n        expect(running {\n          uploader.cache!(bork_file)\n        }).to raise_error(CarrierWave::IntegrityError)\n      end\n\n      it \"looks for content_type_whitelist first for I18n translation\" do\n        allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif'])\n\n        change_locale_and_store_translations(:nl, :errors => {\n          :messages => {\n            :content_type_allowlist_error => \"this will not be used\",\n            :content_type_whitelist_error => \"Het is niet toegestaan om %{content_type} bestanden te uploaden\"\n          }\n        }) do\n          expect(running {\n            uploader.cache!(bork_file)\n          }).to raise_error(CarrierWave::IntegrityError, 'Het is niet toegestaan om text/plain bestanden te uploaden')\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["module CarrierWave\n  module Uploader\n    module ContentTypeWhitelist\n      extend ActiveSupport::Concern\n\n      included do\n        before :cache, :check_content_type_whitelist!\n      end\n\n      ##\n      # Override this method in your uploader to provide an allowlist of files content types\n      # which are allowed to be uploaded.\n      # Not only strings but Regexp are allowed as well.\n      #\n      # === Returns\n      #\n      # [NilClass, String, Regexp, Array[String, Regexp]] an allowlist of content types which are allowed to be uploaded\n      #\n      # === Examples\n      #\n      #     def content_type_allowlist\n      #       %w(text/json application/json)\n      #     end\n      #\n      # Basically the same, but using a Regexp:\n      #\n      #     def content_type_allowlist\n      #       [/(text|application)\\/json/]\n      #     end\n      #\n      def content_type_allowlist\n        if respond_to?(:content_type_whitelist)\n          ActiveSupport::Deprecation.warn \"#content_type_whitelist is deprecated, use #content_type_allowlist instead.\" unless instance_variable_defined?(:@content_type_whitelist_warned)\n          @content_type_whitelist_warned = true\n          content_type_whitelist\n        end\n      end\n\n    private\n\n      def check_content_type_whitelist!(new_file)\n        return unless content_type_allowlist\n\n        content_type = new_file.content_type\n        if !whitelisted_content_type?(content_type)\n          raise CarrierWave::IntegrityError, I18n.translate(:\"errors.messages.content_type_whitelist_error\", content_type: content_type,\n                                                            allowed_types: Array(content_type_allowlist).join(\", \"), default: :\"errors.messages.content_type_allowlist_error\")\n        end\n      end\n\n      def whitelisted_content_type?(content_type)\n        Array(content_type_allowlist).any? do |item|\n          item = Regexp.quote(item) if item.class != Regexp\n          content_type =~ /\\A#{item}/\n        end\n      end\n\n    end # ContentTypeWhitelist\n  end # Uploader\nend # CarrierWave\n", "require 'spec_helper'\n\ndescribe CarrierWave::Uploader do\n  let(:uploader_class) { Class.new(CarrierWave::Uploader::Base) }\n  let(:uploader) { uploader_class.new }\n  let(:ruby_file) { File.open(file_path('ruby.gif')) }\n  let(:bork_file) { File.open(file_path('bork.txt')) }\n  let(:vector_file) { File.open(file_path('ruby.svg')) }\n\n  after { FileUtils.rm_rf(public_path) }\n\n  describe '#cache!' do\n    before do\n      allow(CarrierWave).to receive(:generate_cache_id).and_return('1369894322-345-1234-2255')\n    end\n\n    context \"when there is no allowlist\" do\n      it \"does not raise an integrity error\" do\n        allow(uploader).to receive(:content_type_allowlist).and_return(nil)\n\n        expect { uploader.cache!(ruby_file) }.not_to raise_error\n      end\n    end\n\n    context \"when there is an allowlist\" do\n      context \"when the allowlist is an array of values\" do\n        it \"does not raise an integrity error when the file has an allowlisted content type\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/png'])\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"accepts content types with a + symbol\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/svg+xml'])\n\n          expect { uploader.cache!(vector_file) }.not_to raise_error\n        end\n\n        it \"accepts a list of content types with mixed regular expressions and strings\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['application/pdf', %r{image/}])\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"raises an integrity error the file has not an allowlisted content type\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif'])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n\n        it \"accepts content types as regular expressions\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return([/image\\//])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n\n        it \"raises an integrity error which lists the allowed content types\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif', 'image/jpg'])\n\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError, %r{(?:image/gif|image/jpg)})\n        end\n      end\n\n      context \"when the allowlist is a single value\" do\n        let(:test_file) { File.open(file_path('test.jpeg')) }\n\n        it \"accepts a single content type string value\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return('image/png')\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n\n        it \"accepts a single content type regular expression value\" do\n          allow(uploader).to receive(:content_type_allowlist).and_return(/image\\//)\n\n          expect { uploader.cache!(ruby_file) }.not_to raise_error\n        end\n      end\n\n      context \"with a crafted content type\" do\n        before do\n          allow(bork_file).to receive(:content_type).and_return('text/plain; image/png')\n          allow(uploader).to receive(:content_type_allowlist).and_return('image/png')\n        end\n\n        it \"does not allow spoofing\" do\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n      end\n\n      context \"when the allowlist contains charset\" do\n        before do\n          allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})\n        end\n\n        it \"accepts the content with allowed charset\" do\n          allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')\n          expect { uploader.cache!(bork_file) }.not_to raise_error\n        end\n\n        it \"rejects the content without charset\" do\n          allow(bork_file).to receive(:content_type).and_return('text/plain')\n          expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)\n        end\n      end\n    end\n\n    context \"when there is a whitelist\" do\n      it \"uses the whitelist but shows deprecation\" do\n        allow(uploader).to receive(:content_type_whitelist).and_return(['image/gif'])\n\n        expect(ActiveSupport::Deprecation).to receive(:warn).with('#content_type_whitelist is deprecated, use #content_type_allowlist instead.')\n        expect(running {\n          uploader.cache!(bork_file)\n        }).to raise_error(CarrierWave::IntegrityError)\n      end\n\n      it \"looks for content_type_whitelist first for I18n translation\" do\n        allow(uploader).to receive(:content_type_allowlist).and_return(['image/gif'])\n\n        change_locale_and_store_translations(:nl, :errors => {\n          :messages => {\n            :content_type_allowlist_error => \"this will not be used\",\n            :content_type_whitelist_error => \"Het is niet toegestaan om %{content_type} bestanden te uploaden\"\n          }\n        }) do\n          expect(running {\n            uploader.cache!(bork_file)\n          }).to raise_error(CarrierWave::IntegrityError, 'Het is niet toegestaan om text/plain bestanden te uploaden')\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/carrierwave/uploader/content_type_whitelist.rb", "spec/uploader/content_type_whitelist_spec.rb"], "buggy_code_start_loc": [54, 78], "buggy_code_end_loc": [55, 78], "fixing_code_start_loc": [54, 79], "fixing_code_end_loc": [55, 106], "type": "CWE-79", "message": "CarrierWave is a solution for file uploads for Rails, Sinatra and other Ruby web frameworks. CarrierWave has a Content-Type allowlist bypass vulnerability, possibly leading to XSS. The validation in `allowlisted_content_type?` determines Content-Type permissions by performing a partial match. If the `content_type` argument of `allowlisted_content_type?` is passed a value crafted by the attacker, Content-Types not included in the `content_type_allowlist` will be allowed. This issue has been patched in versions 2.2.5 and 3.0.5.", "other": {"cve": {"id": "CVE-2023-49090", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-29T15:15:08.900", "lastModified": "2023-12-05T16:25:58.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CarrierWave is a solution for file uploads for Rails, Sinatra and other Ruby web frameworks. CarrierWave has a Content-Type allowlist bypass vulnerability, possibly leading to XSS. The validation in `allowlisted_content_type?` determines Content-Type permissions by performing a partial match. If the `content_type` argument of `allowlisted_content_type?` is passed a value crafted by the attacker, Content-Types not included in the `content_type_allowlist` will be allowed. This issue has been patched in versions 2.2.5 and 3.0.5."}, {"lang": "es", "value": "CarrierWave es una soluci\u00f3n para carga de archivos para Rails, Sinatra y otros frameworks web Ruby. CarrierWave tiene una vulnerabilidad de omisi\u00f3n de lista permitida de tipo de contenido, que posiblemente conduzca a XSS. La validaci\u00f3n en `allowlisted_content_type?` determina los permisos de tipo de contenido realizando una coincidencia parcial. Si al argumento `content_type` de `allowlisted_content_type?` se le pasa un valor creado por el atacante, se permitir\u00e1n los tipos de contenido no incluidos en `content_type_allowlist`. Este problema se solucion\u00f3 en las versiones 2.2.5 y 3.0.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.2.5", "matchCriteriaId": "24759284-5E91-43AE-80B4-ED77679DAE19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.5", "matchCriteriaId": "E3FB153B-EC7F-411D-89EF-99633A3D4784"}]}]}], "references": [{"url": "https://github.com/carrierwaveuploader/carrierwave/commit/39b282db5c1303899b3d3381ce8a837840f983b5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/commit/863d425c76eba12c3294227b39018f6b2dccbbf3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-gxhx-g4fq-49hj", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/39b282db5c1303899b3d3381ce8a837840f983b5"}}