{"buggy_code": ["#!/usr/local/bin/perl\n# A very simple perl web server used by Webmin\n\n# Require basic libraries\npackage miniserv;\nuse Socket;\nuse POSIX;\nuse Time::Local;\neval \"use Time::HiRes;\";\n\n@itoa64 = split(//, \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n\n# Find and read config file\nif ($ARGV[0] eq \"--nofork\") {\n\t$nofork_argv = 1;\n\tshift(@ARGV);\n\t}\nif (@ARGV != 1) {\n\tdie \"Usage: miniserv.pl <config file>\";\n\t}\nif ($ARGV[0] =~ /^([a-z]:)?\\//i) {\n\t$config_file = $ARGV[0];\n\t}\nelse {\n\tchop($pwd = `pwd`);\n\t$config_file = \"$pwd/$ARGV[0]\";\n\t}\n%config = &read_config_file($config_file);\nif ($config{'perllib'}) {\n\tpush(@INC, split(/:/, $config{'perllib'}));\n\t$ENV{'PERLLIB'} .= ':'.$config{'perllib'};\n\t}\n@startup_msg = ( );\n\n# Check if SSL is enabled and available\nif ($config{'ssl'}) {\n\teval \"use Net::SSLeay\";\n\tif (!$@) {\n\t\t$use_ssl = 1;\n\t\t# These functions only exist for SSLeay 1.0\n\t\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\t\teval \"Net::SSLeay::load_error_strings()\";\n\t\tif (defined(&Net::SSLeay::X509_STORE_CTX_get_current_cert) &&\n\t\t    defined(&Net::SSLeay::CTX_load_verify_locations) &&\n\t\t    (defined(&Net::SSLeay::CTX_set_verify) ||\n\t\t     defined(&Net::SSLeay::set_verify))) {\n\t\t\t$client_certs = 1;\n\t\t\t}\n\t\t}\n\t}\n\n# Check if IPv6 is enabled and available\neval \"use Socket6\";\n$socket6err = $@;\nif ($config{'ipv6'}) {\n\tif (!$socket6err) {\n\t\tpush(@startup_msg, \"IPv6 support enabled\");\n\t\t$use_ipv6 = 1;\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \"IPv6 support cannot be enabled without \".\n\t\t\t\t   \"the Socket6 perl module\");\n\t\t}\n\t}\n\n# Check if the syslog module is available to log hacking attempts\nif ($config{'syslog'} && !$config{'inetd'}) {\n\teval \"use Sys::Syslog qw(:DEFAULT setlogsock)\";\n\tif (!$@) {\n\t\t$use_syslog = 1;\n\t\t}\n\t}\n\n# check if the TCP-wrappers module is available\nif ($config{'libwrap'}) {\n\teval \"use Authen::Libwrap qw(hosts_ctl STRING_UNKNOWN)\";\n\tif (!$@) {\n\t\t$use_libwrap = 1;\n\t\t}\n\t}\n\n# Check if the MD5 perl module is available\neval \"use MD5; \\$dummy = new MD5; \\$dummy->add('foo');\";\nif (!$@) {\n\t$use_md5 = \"MD5\";\n\t}\nelse {\n\teval \"use Digest::MD5; \\$dummy = new Digest::MD5; \\$dummy->add('foo');\";\n\tif (!$@) {\n\t\t$use_md5 = \"Digest::MD5\";\n\t\t}\n\t}\nif ($use_md5) {\n\tpush(@startup_msg, \"Using MD5 module $use_md5\");\n\t}\n\n# Check if the SHA512 perl module is available\neval \"use Crypt::SHA\";\n$use_sha512 = $@ ? \"Crypt::SHA\" : undef;\nif ($use_sha512) {\n\tpush(@startup_msg, \"Using SHA512 module $use_sha512\");\n\t}\n\n# Get miniserv's perl path and location\n$miniserv_path = $0;\nopen(SOURCE, $miniserv_path);\n<SOURCE> =~ /^#!(\\S+)/;\n$perl_path = $1;\nclose(SOURCE);\nif (!-x $perl_path) {\n\t$perl_path = $^X;\n\t}\nif (-l $perl_path) {\n\t$linked_perl_path = readlink($perl_path);\n\t}\n@miniserv_argv = @ARGV;\n\n# Check vital config options\n&update_vital_config();\n\n# Check if already running via the PID file\nif (open(PIDFILE, $config{'pidfile'})) {\n\tmy $already = <PIDFILE>;\n\tclose(PIDFILE);\n\tchop($already);\n\tif ($already && $already != $$ && kill(0, $already)) {\n\t\tdie \"Webmin is already running with PID $already\\n\";\n\t\t}\n\t}\n\n$sidname = $config{'sidname'};\ndie \"Session authentication cannot be used in inetd mode\"\n\tif ($config{'inetd'} && $config{'session'});\n\n# check if the PAM module is available to authenticate\nif ($config{'assume_pam'}) {\n\t# Just assume that it will work. This can also be used to work around\n\t# a Solaris bug in which using PAM before forking caused it to fail\n\t# later!\n\t$use_pam = 1;\n\t}\nelsif (!$config{'no_pam'}) {\n\teval \"use Authen::PAM;\";\n\tif (!$@) {\n\t\t# check if the PAM authentication can be used by opening a\n\t\t# PAM handle\n\t\tlocal $pamh;\n\t\tif (ref($pamh = new Authen::PAM($config{'pam'},\n\t\t\t\t\t\t$config{'pam_test_user'},\n\t\t\t\t\t\t\\&pam_conv_func))) {\n\t\t\t# Now test a login to see if /etc/pam.d/webmin is set\n\t\t\t# up properly.\n\t\t\t$pam_conv_func_called = 0;\n\t\t\t$pam_username = \"test\";\n\t\t\t$pam_password = \"test\";\n\t\t\t$pamh->pam_authenticate();\n\t\t\tif ($pam_conv_func_called) {\n\t\t\t\tpush(@startup_msg,\n\t\t\t\t     \"PAM authentication enabled\");\n\t\t\t\t$use_pam = 1;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tpush(@startup_msg,\n\t\t\t\t    \"PAM test failed - maybe \".\n\t\t\t\t    \"/etc/pam.d/$config{'pam'} does not exist\");\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tpush(@startup_msg,\n\t\t\t     \"PAM initialization of Authen::PAM failed\");\n\t\t\t}\n\t\t}\n\t}\nif ($config{'pam_only'} && !$use_pam) {\n\tforeach $msg (@startup_msg) {\n\t\tprint STDERR $msg,\"\\n\";\n\t\t}\n\tprint STDERR \"PAM use is mandatory, but could not be enabled!\\n\";\n\tprint STDERR \"no_pam and pam_only both are set!\\n\" if ($config{no_pam});\n\texit(1);\n\t}\nelsif ($pam_msg && !$use_pam) {\n\tpush(@startup_msg,\n\t     \"Continuing without the Authen::PAM perl module\");\n\t}\n\n# Check if the User::Utmp perl module is installed\nif ($config{'utmp'}) {\n\teval \"use User::Utmp;\";\n\tif (!$@) {\n\t\t$write_utmp = 1;\n\t\tpush(@startup_msg, \"UTMP logging enabled\");\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \n\t\t     \"Perl module User::Utmp needed for Utmp logging is \".\n\t\t     \"not installed : $@\");\n\t\t}\n\t}\n\n# See if the crypt function fails\neval \"crypt('foo', 'xx')\";\nif ($@) {\n\teval \"use Crypt::UnixCrypt\";\n\tif (!$@) {\n\t\t$use_perl_crypt = 1;\n\t\tpush(@startup_msg, \n\t\t     \"Using Crypt::UnixCrypt for password encryption\");\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \n\t\t     \"crypt() function un-implemented, and Crypt::UnixCrypt \".\n\t\t     \"not installed - password authentication will fail\");\n\t\t}\n\t}\n\n# Check if /dev/urandom really generates random IDs, by calling it twice\nlocal $rand1 = &generate_random_id(1);\nlocal $rand2 = &generate_random_id(1);\nif ($rand1 eq $rand2) {\n\t$bad_urandom = 1;\n\tpush(@startup_msg,\n\t     \"Random number generator file /dev/urandom is not reliable\");\n\t}\n\n# Check if we can call sudo\nif ($config{'sudo'} && &has_command(\"sudo\")) {\n\teval \"use IO::Pty\";\n\tif (!$@) {\n\t\t$use_sudo = 1;\n\t\t}\n\telse {\n\t\tpush(@startup_msg,\n\t\t     \"Perl module IO::Pty needed for calling sudo is not \".\n\t\t     \"installed : $@\");\n\t\t}\n\t}\n\n# init days and months for http_date\n@weekday = ( \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" );\n@month = ( \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" );\n\n# Change dir to the server root\n@roots = ( $config{'root'} );\nfor($i=0; defined($config{\"extraroot_$i\"}); $i++) {\n\tpush(@roots, $config{\"extraroot_$i\"});\n\t}\nchdir($roots[0]);\neval { $user_homedir = (getpwuid($<))[7]; };\nif ($@) {\n\t# getpwuid doesn't work on windows\n\t$user_homedir = $ENV{\"HOME\"} || $ENV{\"USERPROFILE\"} || \"/\";\n\t$on_windows = 1;\n\t}\n\n# Read users file\n&read_users_file();\n\n# Setup SSL if possible and if requested\nif (!-r $config{'keyfile'}) {\n\t# Key file doesn't exist!\n\tif ($config{'keyfile'}) {\n\t\tprint STDERR \"SSL key file $config{'keyfile'} does not exist\\n\";\n\t\t}\n\t$use_ssl = 0;\n\t}\nelsif ($config{'certfile'} && !-r $config{'certfile'}) {\n\t# Cert file doesn't exist!\n\tprint STDERR \"SSL cert file $config{'certfile'} does not exist\\n\";\n\t$use_ssl = 0;\n\t}\n@ipkeys = &get_ipkeys(\\%config);\nif ($use_ssl) {\n\tif ($config{'ssl_version'}) {\n\t\t# Force an SSL version\n\t\t$Net::SSLeay::version = $config{'ssl_version'};\n\t\t$Net::SSLeay::ssl_version = $config{'ssl_version'};\n\t\t}\n\t$client_certs = 0 if (!-r $config{'ca'} || !%certs);\n\t$ctx = &create_ssl_context($config{'keyfile'},\n\t\t\t\t   $config{'certfile'},\n\t\t\t\t   $config{'extracas'});\n\t$ctx || die \"Failed to create default SSL context\";\n\t$ssl_contexts{\"*\"} = $ctx;\n\tforeach $ipkey (@ipkeys) {\n\t\t$ctx = &create_ssl_context($ipkey->{'key'}, $ipkey->{'cert'},\n\t\t\t\t   $ipkey->{'extracas'} || $config{'extracas'});\n\t\tif ($ctx) {\n\t\t\tforeach $ip (@{$ipkey->{'ips'}}) {\n\t\t\t\t$ssl_contexts{$ip} = $ctx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Setup per-hostname SSL contexts on the main IP\n\tif (defined(&Net::SSLeay::CTX_set_tlsext_servername_callback)) {\n\t\tNet::SSLeay::CTX_set_tlsext_servername_callback(\n\t\t    $ssl_contexts{\"*\"},\n\t\t    sub {\n\t\t\tmy $ssl = shift;\n\t\t\tmy $h = Net::SSLeay::get_servername($ssl);\n\t\t\tmy $c = $ssl_contexts{$h} ||\n\t\t\t\t$h =~ /^[^\\.]+\\.(.*)$/ && $ssl_contexts{\"*.$1\"};\n\t\t\tif ($c) {\n\t\t\t\tNet::SSLeay::set_SSL_CTX($ssl, $c);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n# Load gzip library if enabled\nif ($config{'gzip'} eq '1') {\n\teval \"use Compress::Zlib\";\n\tif (!$@) {\n\t\t$use_gzip = 1;\n\t\t}\n\t}\n\n# Setup syslog support if possible and if requested\nif ($use_syslog) {\n\topen(ERRDUP, \">&STDERR\");\n\topen(STDERR, \">/dev/null\");\n\t$log_socket = $config{\"logsock\"} || \"unix\";\n\teval 'openlog($config{\"pam\"}, \"cons,pid,ndelay\", \"authpriv\"); setlogsock($log_socket)';\n\tif ($@) {\n\t\t$use_syslog = 0;\n\t\t}\n\telse {\n\t\tlocal $msg = ucfirst($config{'pam'}).\" starting\";\n\t\teval { syslog(\"info\", \"%s\", $msg); };\n\t\tif ($@) {\n\t\t\teval {\n\t\t\t\tsetlogsock(\"inet\");\n\t\t\t\tsyslog(\"info\", \"%s\", $msg);\n\t\t\t\t};\n\t\t\tif ($@) {\n\t\t\t\t# All attempts to use syslog have failed..\n\t\t\t\t$use_syslog = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\topen(STDERR, \">&ERRDUP\");\n\tclose(ERRDUP);\n\t}\n\n# Read MIME types file and add extra types\n&read_mime_types();\n\n# get the time zone\nif ($config{'log'}) {\n\tlocal(@gmt, @lct, $days, $hours, $mins);\n\t@gmt = gmtime(time());\n\t@lct = localtime(time());\n\t$days = $lct[3] - $gmt[3];\n\t$hours = ($days < -1 ? 24 : 1 < $days ? -24 : $days * 24) +\n\t\t $lct[2] - $gmt[2];\n\t$mins = $hours * 60 + $lct[1] - $gmt[1];\n\t$timezone = ($mins < 0 ? \"-\" : \"+\"); $mins = abs($mins);\n\t$timezone .= sprintf \"%2.2d%2.2d\", $mins/60, $mins%60;\n\t}\n\n# Build various maps from the config files\n&build_config_mappings();\n\n# start up external authentication program, if needed\nif ($config{'extauth'}) {\n\tsocketpair(EXTAUTH, EXTAUTH2, AF_UNIX, SOCK_STREAM, PF_UNSPEC);\n\tif (!($extauth = fork())) {\n\t\tclose(EXTAUTH);\n\t\tclose(STDIN);\n\t\tclose(STDOUT);\n\t\topen(STDIN, \"<&EXTAUTH2\");\n\t\topen(STDOUT, \">&EXTAUTH2\");\n\t\texec($config{'extauth'}) or die \"exec failed : $!\\n\";\n\t\t}\n\tclose(EXTAUTH2);\n\tlocal $os = select(EXTAUTH);\n\t$| = 1; select($os);\n\t}\n\n# Pre-load any libraries\nif (!$config{'inetd'}) {\n\tforeach $pl (split(/\\s+/, $config{'preload'})) {\n\t\t($pkg, $lib) = split(/=/, $pl);\n\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\teval \"package $pkg; do '$config{'root'}/$lib'\";\n\t\tif ($@) {\n\t\t\tprint STDERR \"Failed to pre-load $lib in $pkg : $@\\n\";\n\t\t\t}\n\t\t}\n\tforeach $pl (split(/\\s+/, $config{'premodules'})) {\n\t\tif ($pl =~ /\\//) {\n\t\t\t($dir, $mod) = split(/\\//, $pl);\n\t\t\t}\n\t\telse {\n\t\t\t($dir, $mod) = (undef, $pl);\n\t\t\t}\n\t\tpush(@INC, \"$config{'root'}/$dir\");\n\t\teval \"package $mod; use $mod ()\";\n\t\tif ($@) {\n\t\t\tprint STDERR \"Failed to pre-load $mod : $@\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n# Open debug log if set\nif ($config{'debuglog'}) {\n\topen(DEBUG, \">>$config{'debuglog'}\");\n\tchmod(0700, $config{'debuglog'});\n\tselect(DEBUG); $| = 1; select(STDOUT);\n\tprint DEBUG \"miniserv.pl starting ..\\n\";\n\t}\n\n# Write out (empty) blocked hosts file\n&write_blocked_file();\n\n# Initially read webmin cron functions and last execution times\n&read_webmin_crons();\n%webmincron_last = ( );\n&read_file($config{'webmincron_last'}, \\%webmincron_last);\n\n# Pre-cache lang files\n&precache_files();\n\n# Clear any flag files to prevent restart loops\nunlink($config{'restartflag'}) if ($config{'restartflag'});\nunlink($config{'reloadflag'}) if ($config{'reloadflag'});\nunlink($config{'stopflag'}) if ($config{'stopflag'});\n\nif ($config{'inetd'}) {\n\t# We are being run from inetd - go direct to handling the request\n\t&redirect_stderr_to_log();\n\t$SIG{'HUP'} = 'IGNORE';\n\t$SIG{'TERM'} = 'DEFAULT';\n\t$SIG{'PIPE'} = 'DEFAULT';\n\topen(SOCK, \"+>&STDIN\");\n\n\t# Check if it is time for the logfile to be cleared\n\tif ($config{'logclear'}) {\n\t\tlocal $write_logtime = 0;\n\t\tlocal @st = stat(\"$config{'logfile'}.time\");\n\t\tif (@st) {\n\t\t\tif ($st[9]+$config{'logtime'}*60*60 < time()){\n\t\t\t\t# need to clear log\n\t\t\t\t$write_logtime = 1;\n\t\t\t\tunlink($config{'logfile'});\n\t\t\t\t}\n\t\t\t}\n\t\telse { $write_logtime = 1; }\n\t\tif ($write_logtime) {\n\t\t\topen(LOGTIME, \">$config{'logfile'}.time\");\n\t\t\tprint LOGTIME time(),\"\\n\";\n\t\t\tclose(LOGTIME);\n\t\t\t}\n\t\t}\n\n\t# Work out if IPv6 is being used locally\n\tlocal $sn = getsockname(SOCK);\n\tprint DEBUG \"sn=$sn\\n\";\n\tprint DEBUG \"length=\",length($sn),\"\\n\";\n\t$localipv6 = length($sn) > 16;\n\tprint DEBUG \"localipv6=$localipv6\\n\";\n\n\t# Initialize SSL for this connection\n\tif ($use_ssl) {\n\t\t$ssl_con = &ssl_connection_for_ip(SOCK, $localipv6);\n\t\t$ssl_con || exit;\n\t\t}\n\n\t# Work out the hostname for this web server\n\t$host = &get_socket_name(SOCK, $localipv6);\n\tprint DEBUG \"host=$host\\n\";\n\t$host || exit;\n\t$port = $config{'port'};\n\t$acptaddr = getpeername(SOCK);\n\tprint DEBUG \"acptaddr=$acptaddr\\n\";\n\tprint DEBUG \"length=\",length($acptaddr),\"\\n\";\n\t$acptaddr || exit;\n\n\t# Work out remote and local IPs\n\t$ipv6 = length($acptaddr) > 16;\n\tprint DEBUG \"ipv6=$ipv6\\n\";\n\t(undef, $locala) = &get_socket_ip(SOCK, $localipv6);\n\tprint DEBUG \"locala=$locala\\n\";\n\t(undef, $peera, undef) = &get_address_ip($acptaddr, $ipv6);\n\tprint DEBUG \"peera=$peera\\n\";\n\n\tprint DEBUG \"main: Starting handle_request loop pid=$$\\n\";\n\twhile(&handle_request($peera, $locala, $ipv6)) { }\n\tprint DEBUG \"main: Done handle_request loop pid=$$\\n\";\n\tclose(SOCK);\n\texit;\n\t}\n\n# Build list of sockets to listen on\n@listening_on_ports = ();\n$config{'bind'} = '' if ($config{'bind'} eq '*');\nif ($config{'bind'}) {\n\t# Listening on a specific IP\n\tif (&check_ip6address($config{'bind'})) {\n\t\t# IP is v6\n\t\t$use_ipv6 || die \"Cannot bind to $config{'bind'} without IPv6\";\n\t\tpush(@sockets, [ inet_pton(AF_INET6(),$config{'bind'}),\n\t\t\t\t $config{'port'},\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\telse {\n\t\t# IP is v4\n\t\tpush(@sockets, [ inet_aton($config{'bind'}),\n\t\t\t\t $config{'port'},\n\t\t\t\t PF_INET() ]);\n\t\t}\n\t}\nelse {\n\t# Listening on all IPs\n\tpush(@sockets, [ INADDR_ANY, $config{'port'}, PF_INET() ]);\n\tif ($use_ipv6) {\n\t\t# Also IPv6\n\t\tpush(@sockets, [ in6addr_any(), $config{'port'},\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\t}\nforeach $s (split(/\\s+/, $config{'sockets'})) {\n\tif ($s =~ /^(\\d+)$/) {\n\t\t# Just listen on another port on the main IP\n\t\tpush(@sockets, [ $sockets[0]->[0], $s, $sockets[0]->[2] ]);\n\t\tif ($use_ipv6 && !$config{'bind'}) {\n\t\t\t# Also listen on that port on the main IPv6 address\n\t\t\tpush(@sockets, [ $sockets[1]->[0], $s,\n\t\t\t\t\t $sockets[1]->[2] ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^\\*:(\\d+)$/) {\n\t\t# Listening on all IPs on some port\n\t\tpush(@sockets, [ INADDR_ANY, $1,\n\t\t\t\t PF_INET() ]);\n\t\tif ($use_ipv6) {\n\t\t\tpush(@sockets, [ in6addr_any(), $1,\n\t\t\t\t\t PF_INET6() ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^(\\S+):(\\d+)$/) {\n\t\t# Listen on a specific port and IP\n\t\tmy ($ip, $port) = ($1, $2);\n\t\tif (&check_ip6address($ip)) {\n\t\t\t$use_ipv6 || die \"Cannot bind to $ip without IPv6\";\n\t\t\tpush(@sockets, [ inet_pton(AF_INET6(),\n\t\t\t\t\t\t   $ip),\n\t\t\t\t\t $port, PF_INET6() ]);\n\t\t\t}\n\t\telse {\n\t\t\tpush(@sockets, [ inet_aton($ip), $port,\n\t\t\t\t\t PF_INET() ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^([0-9\\.]+):\\*$/ || $s =~ /^([0-9\\.]+)$/) {\n\t\t# Listen on the main port on another IPv4 address\n\t\tpush(@sockets, [ inet_aton($1), $sockets[0]->[1],\n\t\t\t\t PF_INET() ]);\n\t\t}\n\telsif (($s =~ /^([0-9a-f\\:]+):\\*$/ || $s =~ /^([0-9a-f\\:]+)$/) &&\n\t       $use_ipv6) {\n\t\t# Listen on the main port on another IPv6 address\n\t\tpush(@sockets, [ inet_pton(AF_INET6(), $1),\n\t\t\t\t $sockets[0]->[1],\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\t}\n\n# Open all the sockets\n$proto = getprotobyname('tcp');\n@sockerrs = ( );\n$tried_inaddr_any = 0;\nfor($i=0; $i<@sockets; $i++) {\n\t$fh = \"MAIN$i\";\n\tif (!socket($fh, $sockets[$i]->[2], SOCK_STREAM, $proto)) {\n\t\t# Protocol not supported\n\t\tpush(@sockerrs, \"Failed to open socket family $sockets[$i]->[2] : $!\");\n\t\tnext;\n\t\t}\n\tsetsockopt($fh, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\tif ($sockets[$i]->[2] eq PF_INET()) {\n\t\t$pack = pack_sockaddr_in($sockets[$i]->[1], $sockets[$i]->[0]);\n\t\t}\n\telse {\n\t\t$pack = pack_sockaddr_in6($sockets[$i]->[1], $sockets[$i]->[0]);\n\t\tsetsockopt($fh, 41, 26, pack(\"l\", 1));\t# IPv6 only\n\t\t}\n\tfor($j=0; $j<5; $j++) {\n\t\tlast if (bind($fh, $pack));\n\t\tsleep(1);\n\t\t}\n\tif ($j == 5) {\n\t\t# All attempts failed .. give up\n\t\tif ($sockets[$i]->[0] eq INADDR_ANY ||\n\t\t    $use_ipv6 && $sockets[$i]->[0] eq in6addr_any()) {\n\t\t\tpush(@sockerrs,\n\t\t\t     \"Failed to bind to port $sockets[$i]->[1] : $!\");\n\t\t\t$tried_inaddr_any = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$ip = &network_to_address($sockets[$i]->[0]);\n\t\t\tpush(@sockerrs,\n\t\t\t     \"Failed to bind to IP $ip port \".\n\t\t\t     \"$sockets[$i]->[1] : $!\");\n\t\t\t}\n\t\t}\n\telse {\n\t\tlisten($fh, &get_somaxconn());\n\t\tpush(@socketfhs, $fh);\n\t\tpush(@listening_on_ports, $sockets[$i]->[1]);\n\t\t$ipv6fhs{$fh} = $sockets[$i]->[2] eq PF_INET() ? 0 : 1;\n\t\t}\n\t}\nforeach $se (@sockerrs) {\n\tprint STDERR $se,\"\\n\";\n\t}\n\n# If all binds failed, try binding to any address\nif (!@socketfhs && !$tried_inaddr_any) {\n\tprint STDERR \"Falling back to listening on any address\\n\";\n\t$fh = \"MAIN\";\n\tsocket($fh, PF_INET(), SOCK_STREAM, $proto) ||\n\t\tdie \"Failed to open socket : $!\";\n\tsetsockopt($fh, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\tif (!bind($fh, pack_sockaddr_in($sockets[0]->[1], INADDR_ANY))) {\n\t\tprint STDERR \"Failed to bind to port $sockets[0]->[1] : $!\\n\";\n\t\texit(1);\n\t\t}\n\tlisten($fh, &get_somaxconn());\n\tpush(@socketfhs, $fh);\n\t}\nelsif (!@socketfhs && $tried_inaddr_any) {\n\tprint STDERR \"Could not listen on any ports\";\n\texit(1);\n\t}\n\nif ($config{'listen'}) {\n\t# Open the socket that allows other webmin servers to find this one\n\t$proto = getprotobyname('udp');\n\tif (socket(LISTEN, PF_INET(), SOCK_DGRAM, $proto)) {\n\t\tsetsockopt(LISTEN, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\t\tbind(LISTEN, pack_sockaddr_in($config{'listen'}, INADDR_ANY));\n\t\tlisten(LISTEN, &get_somaxconn());\n\t\t}\n\telse {\n\t\t$config{'listen'} = 0;\n\t\t}\n\t}\n\n# Split from the controlling terminal, unless configured not to\nif (!$config{'nofork'} && !$nofork_argv) {\n\tif (fork()) { exit; }\n\t}\neval { setsid(); };\t# may not work on Windows\n\n# Close standard file handles\nopen(STDIN, \"</dev/null\");\nopen(STDOUT, \">/dev/null\");\n&redirect_stderr_to_log();\n&log_error(\"miniserv.pl started\");\nforeach $msg (@startup_msg) {\n\t&log_error($msg);\n\t}\n\n# write out the PID file\n&write_pid_file();\n$miniserv_main_pid = $$;\n\n# Start the log-clearing process, if needed. This checks every minute\n# to see if the log has passed its reset time, and if so clears it\nif ($config{'logclear'}) {\n\tif (!($logclearer = fork())) {\n\t\t&close_all_sockets();\n\t\tclose(LISTEN);\n\t\twhile(1) {\n\t\t\tlocal $write_logtime = 0;\n\t\t\tlocal @st = stat(\"$config{'logfile'}.time\");\n\t\t\tif (@st) {\n\t\t\t\tif ($st[9]+$config{'logtime'}*60*60 < time()){\n\t\t\t\t\t# need to clear log\n\t\t\t\t\t$write_logtime = 1;\n\t\t\t\t\tunlink($config{'logfile'});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse { $write_logtime = 1; }\n\t\t\tif ($write_logtime) {\n\t\t\t\topen(LOGTIME, \">$config{'logfile'}.time\");\n\t\t\t\tprint LOGTIME time(),\"\\n\";\n\t\t\t\tclose(LOGTIME);\n\t\t\t\t}\n\t\t\tsleep(5*60);\n\t\t\t}\n\t\texit;\n\t\t}\n\tpush(@childpids, $logclearer);\n\t}\n\n# Setup the logout time dbm if needed\nif ($config{'session'}) {\n\teval \"use SDBM_File\";\n\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\teval \"\\$sessiondb{'1111111111'} = 'foo bar';\";\n\tif ($@) {\n\t\tdbmclose(%sessiondb);\n\t\teval \"use NDBM_File\";\n\t\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\t\t}\n\telse {\n\t\tdelete($sessiondb{'1111111111'});\n\t\t}\n\t}\n\n# Run the main loop\n$SIG{'HUP'} = 'miniserv::trigger_restart';\n$SIG{'TERM'} = 'miniserv::term_handler';\n$SIG{'USR1'} = 'miniserv::trigger_reload';\n$SIG{'PIPE'} = 'IGNORE';\nlocal $remove_session_count = 0;\n$need_pipes = $config{'passdelay'} || $config{'session'};\n$cron_runs = 0;\nwhile(1) {\n\t# Check if any webmin cron jobs are ready to run\n\t&execute_ready_webmin_crons($cron_runs++);\n\n\t# wait for a new connection, or a message from a child process\n\tlocal ($i, $rmask);\n\tif (@childpids <= $config{'maxconns'}) {\n\t\t# Only accept new main socket connects when ready\n\t\tlocal $s;\n\t\tforeach $s (@socketfhs) {\n\t\t\tvec($rmask, fileno($s), 1) = 1;\n\t\t\t}\n\t\t}\n\telse {\n\t\tprintf STDERR \"too many children (%d > %d)\\n\",\n\t\t\tscalar(@childpids), $config{'maxconns'};\n\t\t}\n\tif ($need_pipes) {\n\t\tfor($i=0; $i<@passin; $i++) {\n\t\t\tvec($rmask, fileno($passin[$i]), 1) = 1;\n\t\t\t}\n\t\t}\n\tvec($rmask, fileno(LISTEN), 1) = 1 if ($config{'listen'});\n\n\t# Wait for a connection\n\tlocal $sel = select($rmask, undef, undef, 2);\n\n\t# Check the flag files\n\tif ($config{'restartflag'} && -r $config{'restartflag'}) {\n\t\tunlink($config{'restartflag'});\n\t\t$need_restart = 1;\n\t\t}\n\tif ($config{'reloadflag'} && -r $config{'reloadflag'}) {\n\t\tunlink($config{'reloadflag'});\n\t\t$need_reload = 1;\n\t\t}\n\tif ($config{'stopflag'} && -r $config{'stopflag'}) {\n\t\tunlink($config{'stopflag'});\n\t\t$need_stop = 1;\n\t\t}\n\n\tif ($need_restart) {\n\t\t# Got a HUP signal while in select() .. restart now\n\t\t&restart_miniserv();\n\t\t}\n\tif ($need_reload) {\n\t\t# Got a USR1 signal while in select() .. re-read config\n\t\t$need_reload = 0;\n\t\t&reload_config_file();\n\t\t}\n\tif ($need_stop) {\n\t\t# Stop flag file created\n\t\t&term_handler();\n\t\t}\n\tlocal $time_now = time();\n\n\t# Clean up finished processes\n\tlocal $pid;\n\tdo {\t$pid = waitpid(-1, WNOHANG);\n\t\t@childpids = grep { $_ != $pid } @childpids;\n\t\t} while($pid != 0 && $pid != -1);\n\t@childpids = grep { kill(0, $_) } @childpids;\n\n\t# run the unblocking procedure to check if enough time has passed to\n\t# unblock hosts that never been blocked because of password failures\n\t$unblocked = 0;\n\tif ($config{'blockhost_failures'}) {\n\t\t$i = 0;\n\t\twhile ($i <= $#deny) {\n\t\t\tif ($blockhosttime{$deny[$i]} &&\n\t\t\t    $config{'blockhost_time'} != 0 &&\n\t\t\t    ($time_now - $blockhosttime{$deny[$i]}) >=\n\t\t\t     $config{'blockhost_time'}) {\n\t\t\t\t# the host can be unblocked now\n\t\t\t\t$hostfail{$deny[$i]} = 0;\n\t\t\t\tsplice(@deny, $i, 1);\n\t\t\t\t$unblocked = 1;\n\t\t\t\t}\n\t\t\t$i++;\n\t\t\t}\n\t\t}\n\n\t# Do the same for blocked users\n\tif ($config{'blockuser_failures'}) {\n\t\t$i = 0;\n\t\twhile ($i <= $#deny) {\n\t\t\tif ($blockusertime{$deny[$i]} &&\n\t\t\t    $config{'blockuser_time'} != 0 &&\n\t\t\t    ($time_now - $blockusertime{$deny[$i]}) >=\n\t\t\t     $config{'blockuser_time'}) {\n\t\t\t\t# the user can be unblocked now\n\t\t\t\t$userfail{$deny[$i]} = 0;\n\t\t\t\tsplice(@denyusers, $i, 1);\n\t\t\t\t$unblocked = 1;\n\t\t\t\t}\n\t\t\t$i++;\n\t\t\t}\n\t\t}\n\tif ($unblocked) {\n\t\t&write_blocked_file();\n\t\t}\n\n\tif ($config{'session'} && (++$remove_session_count%50) == 0) {\n\t\t# Remove sessions with more than 7 days of inactivity,\n\t\tlocal $s;\n\t\tforeach $s (keys %sessiondb) {\n\t\t\tlocal ($user, $ltime, $lip) =\n\t\t\t\tsplit(/\\s+/, $sessiondb{$s});\n\t\t\tif ($ltime && $time_now - $ltime > 7*24*60*60) {\n\t\t\t\t&run_logout_script($s, $user, undef, undef);\n\t\t\t\t&write_logout_utmp($user, $lip);\n\t\t\t\tif ($user =~ /^\\!/ || $sessiondb{$s} eq '') {\n\t\t\t\t\t# Don't log anything for logged out\n\t\t\t\t\t# sessions or those with no data\n\t\t\t\t\t}\n\t\t\t\telsif ($use_syslog && $user) {\n\t\t\t\t\tsyslog(\"info\", \"%s\",\n\t\t\t\t\t      \"Timeout of session for $user\");\n\t\t\t\t\t}\n\t\t\t\telsif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\",\n\t\t\t\t\t      \"Timeout of unknown session $s \".\n\t\t\t\t\t      \"with value $sessiondb{$s}\");\n\t\t\t\t\t}\n\t\t\t\tdelete($sessiondb{$s});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif ($use_pam && $config{'pam_conv'}) {\n\t\t# Remove PAM sessions with more than 5 minutes of inactivity\n\t\tlocal $c;\n\t\tforeach $c (values %conversations) {\n\t\t\tif ($time_now - $c->{'time'} > 5*60) {\n\t\t\t\t&end_pam_conversation($c);\n\t\t\t\tif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\", \"Timeout of PAM \".\n\t\t\t\t\t\t\"session for $c->{'user'}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Don't check any sockets if there is no activity\n\tnext if ($sel <= 0);\n\n\t# Check if any of the main sockets have received a new connection\n\tlocal $sn = 0;\n\tforeach $s (@socketfhs) {\n\t\tif (vec($rmask, fileno($s), 1)) {\n\t\t\t# got new connection\n\t\t\t$acptaddr = accept(SOCK, $s);\n\t\t\tprint DEBUG \"accept returned \",length($acptaddr),\"\\n\";\n\t\t\tif (!$acptaddr) { next; }\n\t\t\tbinmode(SOCK);\n\n\t\t\t# create pipes\n\t\t\tlocal ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\n\t\t\tif ($need_pipes) {\n\t\t\t\t($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw) =\n\t\t\t\t\t&allocate_pipes();\n\t\t\t\t}\n\n\t\t\t# Work out IP and port of client\n\t\t\tlocal ($peerb, $peera, $peerp) =\n\t\t\t\t&get_address_ip($acptaddr, $ipv6fhs{$s});\n\t\t\tprint DEBUG \"peera=$peera peerp=$peerp\\n\";\n\n\t\t\t# Work out the local IP\n\t\t\t(undef, $locala) = &get_socket_ip(SOCK, $ipv6fhs{$s});\n\t\t\tprint DEBUG \"locala=$locala\\n\";\n\n\t\t\t# Check username of connecting user\n\t\t\t$localauth_user = undef;\n\t\t\tif ($config{'localauth'} && $peera eq \"127.0.0.1\") {\n\t\t\t\tif (open(TCP, \"/proc/net/tcp\")) {\n\t\t\t\t\t# Get the info direct from the kernel\n\t\t\t\t\t$peerh = sprintf(\"%4.4X\", $peerp);\n\t\t\t\t\twhile(<TCP>) {\n\t\t\t\t\t\ts/^\\s+//;\n\t\t\t\t\t\tlocal @t = split(/[\\s:]+/, $_);\n\t\t\t\t\t\tif ($t[1] eq '0100007F' &&\n\t\t\t\t\t\t    $t[2] eq $peerh) {\n\t\t\t\t\t\t\t$localauth_user =\n\t\t\t\t\t\t\t    getpwuid($t[11]);\n\t\t\t\t\t\t\tlast;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tclose(TCP);\n\t\t\t\t\t}\n\t\t\t\tif (!$localauth_user) {\n\t\t\t\t\t# Call lsof for the info\n\t\t\t\t\tlocal $lsofpid = open(LSOF,\n\t\t\t\t\t\t\"$config{'localauth'} -i \".\n\t\t\t\t\t\t\"TCP\\@127.0.0.1:$peerp |\");\n\t\t\t\t\twhile(<LSOF>) {\n\t\t\t\t\t\tif (/^(\\S+)\\s+(\\d+)\\s+(\\S+)/ &&\n\t\t\t\t\t\t    $2 != $$ && $2 != $lsofpid){\n\t\t\t\t\t\t\t$localauth_user = $3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tclose(LSOF);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t# Work out the hostname for this web server\n\t\t\t$host = &get_socket_name(SOCK, $ipv6fhs{$s});\n\t\t\tif (!$host) {\n\t\t\t\tprint STDERR\n\t\t\t\t    \"Failed to get local socket name : $!\\n\";\n\t\t\t\tclose(SOCK);\n\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t$port = $sockets[$sn]->[1];\n\n\t\t\t# fork the subprocess\n\t\t\tlocal $handpid;\n\t\t\tif (!($handpid = fork())) {\n\t\t\t\t# setup signal handlers\n\t\t\t\tprint DEBUG \"in subprocess\\n\";\n\t\t\t\t$SIG{'TERM'} = 'DEFAULT';\n\t\t\t\t$SIG{'PIPE'} = 'DEFAULT';\n\t\t\t\t#$SIG{'CHLD'} = 'IGNORE';\n\t\t\t\t$SIG{'HUP'} = 'IGNORE';\n\t\t\t\t$SIG{'USR1'} = 'IGNORE';\n\n\t\t\t\t# Close the file handle for the session DBM\n\t\t\t\tdbmclose(%sessiondb);\n\n\t\t\t\t# close useless pipes\n\t\t\t\tif ($need_pipes) {\n\t\t\t\t\t&close_all_pipes();\n\t\t\t\t\tclose($PASSINr); close($PASSOUTw);\n\t\t\t\t\t}\n\t\t\t\t&close_all_sockets();\n\t\t\t\tclose(LISTEN);\n\n\t\t\t\t# Initialize SSL for this connection\n\t\t\t\tif ($use_ssl) {\n\t\t\t\t\t$ssl_con = &ssl_connection_for_ip(\n\t\t\t\t\t\t\tSOCK, $ipv6fhs{$s});\n\t\t\t\t\tprint DEBUG \"ssl_con returned $ssl_con\\n\";\n\t\t\t\t\t$ssl_con || exit;\n\t\t\t\t\t}\n\n\t\t\t\tprint DEBUG\n\t\t\t\t  \"main: Starting handle_request loop pid=$$\\n\";\n\t\t\t\twhile(&handle_request($peera, $locala,\n\t\t\t\t\t\t      $ipv6fhs{$s})) {\n\t\t\t\t\t# Loop until keepalive stops\n\t\t\t\t\t}\n\t\t\t\tprint DEBUG\n\t\t\t\t  \"main: Done handle_request loop pid=$$\\n\";\n\t\t\t\tshutdown(SOCK, 1);\n\t\t\t\tclose(SOCK);\n\t\t\t\tclose($PASSINw); close($PASSOUTw);\n\t\t\t\texit;\n\t\t\t\t}\n\t\t\tpush(@childpids, $handpid);\n\t\t\tif ($need_pipes) {\n\t\t\t\tclose($PASSINw); close($PASSOUTr);\n\t\t\t\tpush(@passin, $PASSINr);\n\t\t\t\tpush(@passout, $PASSOUTw);\n\t\t\t\t}\n\t\t\tclose(SOCK);\n\t\t\t}\n\t\t$sn++;\n\t\t}\n\n\tif ($config{'listen'} && vec($rmask, fileno(LISTEN), 1)) {\n\t\t# Got UDP packet from another webmin server\n\t\tlocal $rcvbuf;\n\t\tlocal $from = recv(LISTEN, $rcvbuf, 1024, 0);\n\t\tnext if (!$from);\n\t\tlocal $fromip = inet_ntoa((unpack_sockaddr_in($from))[1]);\n\t\tlocal $toip = inet_ntoa((unpack_sockaddr_in(\n\t\t\t\t\t getsockname(LISTEN)))[1]);\n\t\tif ((!@deny || !&ip_match($fromip, $toip, @deny)) &&\n\t\t    (!@allow || &ip_match($fromip, $toip, @allow))) {\n\t\t\tlocal $listenhost = &get_socket_name(LISTEN, 0);\n\t\t\tsend(LISTEN, \"$listenhost:$config{'port'}:\".\n\t\t\t\t ($use_ssl || $config{'inetd_ssl'} ? 1 : 0).\":\".\n\t\t\t\t ($config{'listenhost'} ?\n\t\t\t\t\t&get_system_hostname() : \"\"),\n\t\t\t\t 0, $from)\n\t\t\t\tif ($listenhost);\n\t\t\t}\n\t\t}\n\n\t# check for session, password-timeout and PAM messages from subprocesses\n\tfor($i=0; $i<@passin; $i++) {\n\t\tif (vec($rmask, fileno($passin[$i]), 1)) {\n\t\t\t# this sub-process is asking about a password\n\t\t\tlocal $infd = $passin[$i];\n\t\t\tlocal $outfd = $passout[$i];\n\t\t\tlocal $inline = &sysread_line($infd);\n\t\t\tif ($inline) {\n\t\t\t\tprint DEBUG \"main: inline $inline\";\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprint DEBUG \"main: inline EOF\\n\";\n\t\t\t\t}\n\n\t\t\t# Search for two-factor authentication flag\n\t\t\t# being passed, to mark the call as safe\n\t\t\t$inline =~ /^delay\\s+(\\S+)\\s+(\\S+)\\s+(\\d+)\\s+(nolog)/;\n\t\t\tlocal $nolog = $4;\n\n\t\t\tif ($inline =~ /^delay\\s+(\\S+)\\s+(\\S+)\\s+(\\d+)/) {\n\t\t\t\t# Got a delay request from a subprocess.. for\n\t\t\t\t# valid logins, there is no delay (to prevent\n\t\t\t\t# denial of service attacks), but for invalid\n\t\t\t\t# logins the delay increases with each failed\n\t\t\t\t# attempt.\n\t\t\t\tif ($3) {\n\t\t\t\t\t# login OK.. no delay\n\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t$wasblocked = $hostfail{$2} ||\n\t\t\t\t\t\t      $userfail{$1};\n\t\t\t\t\t$hostfail{$2} = 0;\n\t\t\t\t\t$userfail{$1} = 0;\n\t\t\t\t\tif ($wasblocked) {\n\t\t\t\t\t\t&write_blocked_file();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Login failed..\n\t\t\t\t\t$hostfail{$2}++ if(!$nolog);\n\t\t\t\t\t$userfail{$1}++ if(!$nolog);\n\t\t\t\t\t$blocked = 0;\n\n\t\t\t\t\t# Add the host to the block list,\n\t\t\t\t\t# if configured\n \t\t\t\t\tif ($config{'blockhost_failures'} &&\n\t\t\t\t\t    $hostfail{$2} >=\n\t\t\t\t\t      $config{'blockhost_failures'}) {\n\t\t\t\t\t\tpush(@deny, $2);\n\t\t\t\t\t\t$blockhosttime{$2} = $time_now;\n\t\t\t\t\t\t$blocked = 1;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = \"Security alert: Host $2 blocked after $config{'blockhost_failures'} failed logins for user $1\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Add the user to the user block list,\n\t\t\t\t\t# if configured\n \t\t\t\t\tif ($config{'blockuser_failures'} &&\n\t\t\t\t\t    $userfail{$1} >=\n\t\t\t\t\t      $config{'blockuser_failures'}) {\n\t\t\t\t\t\tpush(@denyusers, $1);\n\t\t\t\t\t\t$blockusertime{$1} = $time_now;\n\t\t\t\t\t\t$blocked = 2;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = \"Security alert: User $1 blocked after $config{'blockuser_failures'} failed logins\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Lock out the user's password, if enabled\n\t\t\t\t\tif ($config{'blocklock'} &&\n\t\t\t\t\t    $userfail{$1} >=\n\t\t\t\t\t      $config{'blockuser_failures'}) {\n\t\t\t\t\t\tmy $lk = &lock_user_password($1);\n\t\t\t\t\t\t$blocked = 2;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = $lk == 1 ? \"Security alert: User $1 locked after $config{'blockuser_failures'} failed logins\" : $lk < 0 ? \"Security alert: User could not be locked\" : \"Security alert: User is already locked\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Send back a delay\n\t\t\t\t\t$dl = $userdlay{$1} -\n\t\t\t\t           int(($time_now - $userlast{$1})/50);\n\t\t\t\t\t$dl = $dl < 0 ? 0 : $dl+1;\n\t\t\t\t\tprint $outfd \"$dl $blocked\\n\";\n\t\t\t\t\t$userdlay{$1} = $dl;\n\n\t\t\t\t\t# Write out blocked status file\n\t\t\t\t\tif ($blocked) {\n\t\t\t\t\t\t&write_blocked_file();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t$userlast{$1} = $time_now;\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^verify\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t\t# Verifying a session ID\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $notimeout = $2;\n\t\t\t\tlocal $vip = $3;\n\t\t\t\tlocal $skey = $sessiondb{$session_id} ?\n\t\t\t\t\t\t$session_id : \n\t\t\t\t\t\t&hash_session_id($session_id);\n\t\t\t\tif (!defined($sessiondb{$skey})) {\n\t\t\t\t\t# Session doesn't exist\n\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlocal ($user, $ltime, $ip) =\n\t\t\t\t\t  split(/\\s+/, $sessiondb{$skey});\n\t\t\t\t\tlocal $lot = &get_logout_time($user, $session_id);\n\t\t\t\t\tif ($lot &&\n\t\t\t\t\t    $time_now - $ltime > $lot*60 &&\n\t\t\t\t\t    !$notimeout) {\n\t\t\t\t\t\t# Session has timed out\n\t\t\t\t\t\tprint $outfd \"1 \",$time_now - $ltime,\"\\n\";\n\t\t\t\t\t\t#delete($sessiondb{$skey});\n\t\t\t\t\t\t}\n\t\t\t\t\telsif ($ip && $vip && $ip ne $vip &&\n\t\t\t\t\t       $config{'session_ip'}) {\n\t\t\t\t\t\t# Session was OK, but from the\n\t\t\t\t\t\t# wrong IP address\n\t\t\t\t\t\tprint $outfd \"3 $ip\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\telsif ($user =~ /^\\!/) {\n\t\t\t\t\t\t# Logged out session\n\t\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t# Session is OK\n\t\t\t\t\t\tprint $outfd \"2 $user\\n\";\n\t\t\t\t\t\t$sessiondb{$skey} = \"$user $time_now $ip\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^new\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t\t# Creating a new session\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $user = $2;\n\t\t\t\tlocal $ip = $3;\n\t\t\t\t$sessiondb{&hash_session_id($session_id)} =\n\t\t\t\t\t\"$user $time_now $ip\";\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^delete\\s+(\\S+)/) {\n\t\t\t\t# Logging out a session\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $skey = $sessiondb{$session_id} ?\n\t\t\t\t\t\t$session_id : \n\t\t\t\t\t\t&hash_session_id($session_id);\n\t\t\t\tlocal ($user, $ltime, $ip) =\n\t\t\t\t\tsplit(/\\s+/, $sessiondb{$skey});\n\t\t\t\t$user =~ s/^\\!//;\n\t\t\t\tprint $outfd $user,\"\\n\";\n\t\t\t\t$sessiondb{$skey} = \"!$user $ltime $ip\";\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^pamstart\\s+(\\S+)\\s+(\\S+)\\s+(.*)/) {\n\t\t\t\t# Starting a new PAM conversation\n\t\t\t\tlocal ($cid, $host, $user) = ($1, $2, $3);\n\n\t\t\t\t# Does this user even need PAM?\n\t\t\t\tlocal ($realuser, $canlogin) =\n\t\t\t\t\t&can_user_login($user, undef, $host);\n\t\t\t\tlocal $conv;\n\t\t\t\tif ($canlogin == 0) {\n\t\t\t\t\t# Cannot even login!\n\t\t\t\t\tprint $outfd \"0 Invalid username\\n\";\n\t\t\t\t\t}\n\t\t\t\telsif ($canlogin != 2) {\n\t\t\t\t\t# Not using PAM .. so just ask for\n\t\t\t\t\t# the password.\n\t\t\t\t\t$conv = { 'user' => $realuser,\n\t\t\t\t\t\t  'host' => $host,\n\t\t\t\t\t\t  'step' => 0,\n\t\t\t\t\t\t  'cid' => $cid,\n\t\t\t\t\t\t  'time' => time() };\n\t\t\t\t\tprint $outfd \"3 Password\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Start the PAM conversation\n\t\t\t\t\t# sub-process, and get a question\n\t\t\t\t\t$conv = { 'user' => $realuser,\n\t\t\t\t\t\t  'host' => $host,\n\t\t\t\t\t\t  'cid' => $cid,\n\t\t\t\t\t\t  'time' => time() };\n\t\t\t\t\tlocal ($PAMINr, $PAMINw, $PAMOUTr,\n\t\t\t\t\t\t$PAMOUTw) = &allocate_pipes();\n\t\t\t\t\tlocal $pampid = fork();\n\t\t\t\t\tif (!$pampid) {\n\t\t\t\t\t\tclose($PAMOUTr); close($PAMINw);\n\t\t\t\t\t\t&pam_conversation_process(\n\t\t\t\t\t\t\t$realuser,\n\t\t\t\t\t\t\t$PAMOUTw, $PAMINr);\n\t\t\t\t\t\t}\n\t\t\t\t\tclose($PAMOUTw); close($PAMINr);\n\t\t\t\t\t$conv->{'pid'} = $pampid;\n\t\t\t\t\t$conv->{'PAMOUTr'} = $PAMOUTr;\n\t\t\t\t\t$conv->{'PAMINw'} = $PAMINw;\n\t\t\t\t\tpush(@childpids, $pampid);\n\n\t\t\t\t\t# Get the first PAM question\n\t\t\t\t\tlocal $pok = &recv_pam_question(\n\t\t\t\t\t\t$conv, $outfd);\n\t\t\t\t\tif (!$pok) {\n\t\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t$conversations{$cid} = $conv if ($conv);\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^pamanswer\\s+(\\S+)\\s+(.*)/) {\n\t\t\t\t# A response to a PAM question\n\t\t\t\tlocal ($cid, $answer) = ($1, $2);\n\t\t\t\tlocal $conv = $conversations{$cid};\n\t\t\t\tif (!$conv) {\n\t\t\t\t\t# No such conversation?\n\t\t\t\t\tprint $outfd \"0 Bad login session\\n\";\n\t\t\t\t\t}\n\t\t\t\telsif ($conv->{'pid'}) {\n\t\t\t\t\t# Send the PAM response and get\n\t\t\t\t\t# the next question\n\t\t\t\t\t&send_pam_answer($conv, $answer);\n\t\t\t\t\tlocal $pok = &recv_pam_question($conv, $outfd);\n\t\t\t\t\tif (!$pok) {\n\t\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# This must be the password .. try it\n\t\t\t\t\t# and send back the results\n\t\t\t\t\tlocal ($vu, $expired, $nonexist) =\n\t\t\t\t\t\t&validate_user($conv->{'user'},\n\t\t\t\t\t\t\t       $answer,\n\t\t\t\t\t\t\t       $conf->{'host'});\n\t\t\t\t\tlocal $ok = $vu ? 1 : 0;\n\t\t\t\t\tprint $outfd \"2 $conv->{'user'} $ok $expired $notexist\\n\";\n\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^writesudo\\s+(\\S+)\\s+(\\d+)/) {\n\t\t\t\t# Store the fact that some user can sudo to root\n\t\t\t\tlocal ($user, $ok) = ($1, $2);\n\t\t\t\t$sudocache{$user} = $ok.\" \".time();\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^readsudo\\s+(\\S+)/) {\n\t\t\t\t# Query the user sudo cache (valid for 1 minute)\n\t\t\t\tlocal $user = $1;\n\t\t\t\tlocal ($ok, $last) =\n\t\t\t\t\tsplit(/\\s+/, $sudocache{$user});\n\t\t\t\tif ($last < time()-60) {\n\t\t\t\t\t# Cache too old\n\t\t\t\t\tprint $outfd \"2\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Tell client OK or not\n\t\t\t\t\tprint $outfd \"$ok\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /\\S/) {\n\t\t\t\t# Unknown line from pipe?\n\t\t\t\tprint DEBUG \"main: Unknown line from pipe $inline\\n\";\n\t\t\t\tprint STDERR \"Unknown line from pipe $inline\\n\";\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# close pipe\n\t\t\t\tclose($infd); close($outfd);\n\t\t\t\t$passin[$i] = $passout[$i] = undef;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t@passin = grep { defined($_) } @passin;\n\t@passout = grep { defined($_) } @passout;\n\t}\n\n# handle_request(remoteaddress, localaddress, ipv6-flag)\n# Where the real work is done\nsub handle_request\n{\nlocal ($acptip, $localip, $ipv6) = @_;\nprint DEBUG \"handle_request: from $acptip to $localip ipv6=$ipv6\\n\";\nif ($config{'loghost'}) {\n\t$acpthost = &to_hostname($acptip);\n\t$acpthost = $acptip if (!$acpthost);\n\t}\nelse {\n\t$acpthost = $acptip;\n\t}\n$loghost = $acpthost;\n$datestr = &http_date(time());\n$ok_code = 200;\n$ok_message = \"Document follows\";\n$logged_code = undef;\n$reqline = $request_uri = $page = undef;\n$authuser = undef;\n$validated = undef;\n\n# check address against access list\nif (@deny && &ip_match($acptip, $localip, @deny) ||\n    @allow && !&ip_match($acptip, $localip, @allow)) {\n\t&http_error(403, \"Access denied for \".&html_strip($acptip));\n\treturn 0;\n\t}\n\nif ($use_libwrap) {\n\t# Check address with TCP-wrappers\n\tif (!hosts_ctl($config{'pam'}, STRING_UNKNOWN,\n\t\t       $acptip, STRING_UNKNOWN)) {\n\t\t&http_error(403, \"Access denied for \".&html_strip($acptip).\n\t\t\t\t \" by TCP wrappers\");\n\t\treturn 0;\n\t\t}\n\t}\nprint DEBUG \"handle_request: passed IP checks\\n\";\n\n# Compute a timeout for the start of headers, based on the number of\n# child processes. As this increases, we use a shorter timeout to avoid\n# an attacker overloading the system.\nlocal $header_timeout = 60 + ($config{'maxconns'} - @childpids) * 10;\n\n# Wait at most 60 secs for start of headers for initial requests, or\n# 10 minutes for kept-alive connections\nlocal $rmask;\nvec($rmask, fileno(SOCK), 1) = 1;\nlocal $to = $checked_timeout ? 10*60 : $header_timeout;\nlocal $sel = select($rmask, undef, undef, $to);\nif (!$sel) {\n\tif ($checked_timeout) {\n\t\tprint DEBUG \"handle_request: exiting due to timeout of $to\\n\";\n\t\texit;\n\t\t}\n\telse {\n\t\t&http_error(400, \"Timeout\",\n\t\t\t    \"Waited for $to seconds for start of headers\");\n\t\t}\n\t}\n$checked_timeout++;\nprint DEBUG \"handle_request: passed timeout check\\n\";\n\n# Read the HTTP request and headers\nlocal $origreqline = &read_line();\n($reqline = $origreqline) =~ s/\\r|\\n//g;\n$method = $page = $request_uri = undef;\nprint DEBUG \"handle_request reqline=$reqline\\n\";\nif (!$reqline && (!$use_ssl || $checked_timeout > 1)) {\n\t# An empty request .. just close the connection\n\tprint DEBUG \"handle_request: rejecting empty request\\n\";\n\treturn 0;\n\t}\nelsif ($reqline !~ /^(\\S+)\\s+(.*)\\s+HTTP\\/1\\..$/) {\n\tprint DEBUG \"handle_request: invalid reqline=$reqline\\n\";\n\tif ($use_ssl) {\n\t\t# This could be an http request when it should be https\n\t\t$use_ssl = 0;\n\t\tlocal $urlhost = $config{'musthost'} || $host;\n\t\t$urlhost = \"[\".$urlhost.\"]\" if (&check_ip6address($urlhost));\n\t\tlocal $wantport = $port;\n\t\tif ($wantport == 80 &&\n\t\t    &indexof(443, @listening_on_ports) >= 0) {\n\t\t\t# Connection was to port 80, but since we are also\n\t\t\t# accepting on port 443, redirect to that\n\t\t\t$wantport = 443;\n\t\t\t}\n\t\tlocal $url = $wantport == 443 ? \"https://$urlhost/\"\n\t\t\t\t\t      : \"https://$urlhost:$wantport/\";\n\t\tif ($config{'ssl_redirect'}) {\n\t\t\t# Just re-direct to the correct URL\n\t\t\tsleep(1);\t# Give browser a change to finish\n\t\t\t\t\t# sending its request\n\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t&write_data(\"Location: $url\\r\\n\");\n\t\t\t&write_keep_alive(0);\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\treturn 0;\n\t\t} elsif ($config{'hide_admin_url'} != 1) {\n\t\t\t# Tell user the correct URL\n\t\t\t&http_error(200, \"Document follows\",\n\t\t\t\t\"This web server is running in SSL mode. \".\n\t\t\t\t\"Try the URL <a href='$url'>$url</a> \".\n\t\t\t\t\"instead.\", 0, 1);\n\t\t} else {\n\t\t\t# Throw an error\n\t\t\t&http_error(404, \"Page not found\",\n\t\t\t    \"The requested URL was not found on this server.\")\n\t\t}\n\t} elsif (ord(substr($reqline, 0, 1)) == 128 && !$use_ssl) {\n\t\t# This could be an https request when it should be http ..\n\t\t# need to fake a HTTP response\n\t\teval <<'EOF';\n\t\t\tuse Net::SSLeay;\n\t\t\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\t\t\teval \"Net::SSLeay::load_error_strings()\";\n\t\t\t$ssl_ctx = Net::SSLeay::CTX_new();\n\t\t\tNet::SSLeay::CTX_use_RSAPrivateKey_file(\n\t\t\t\t$ssl_ctx, $config{'keyfile'},\n\t\t\t\t&Net::SSLeay::FILETYPE_PEM);\n\t\t\tNet::SSLeay::CTX_use_certificate_file(\n\t\t\t\t$ssl_ctx,\n\t\t\t\t$config{'certfile'} || $config{'keyfile'},\n\t\t\t\t&Net::SSLeay::FILETYPE_PEM);\n\t\t\t$ssl_con = Net::SSLeay::new($ssl_ctx);\n\t\t\tpipe(SSLr, SSLw);\n\t\t\tif (!fork()) {\n\t\t\t\tclose(SSLr);\n\t\t\t\tselect(SSLw); $| = 1; select(STDOUT);\n\t\t\t\tprint SSLw $origreqline;\n\t\t\t\tlocal $buf;\n\t\t\t\twhile(sysread(SOCK, $buf, 1) > 0) {\n\t\t\t\t\tprint SSLw $buf;\n\t\t\t\t\t}\n\t\t\t\tclose(SOCK);\n\t\t\t\texit;\n\t\t\t\t}\n\t\t\tclose(SSLw);\n\t\t\tNet::SSLeay::set_wfd($ssl_con, fileno(SOCK));\n\t\t\tNet::SSLeay::set_rfd($ssl_con, fileno(SSLr));\n\t\t\tNet::SSLeay::accept($ssl_con) || die \"accept() failed\";\n\t\t\t$use_ssl = 1;\n\t\t\tlocal $url = $config{'musthost'} ?\n\t\t\t\t\t\"https://$config{'musthost'}:$port/\" :\n\t\t\t\t\t\"https://$host:$port/\";\n\t\t\tif ($config{'ssl_redirect'}) {\n\t\t\t\t# Just re-direct to the correct URL\n\t\t\t\tsleep(1);\t# Give browser a change to\n\t\t\t\t\t\t# finish sending its request\n\t\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_data(\"Location: $url\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t&write_data(\"\\r\\n\");\n\t\t\t\treturn 0;\n\t\t\t} elsif ($config{'hide_admin_url'} != 1) {\n\t\t\t\t# Tell user the correct URL\n\t\t\t\t&http_error(200, \"Bad Request\", \"This web server is not running in SSL mode. Try the URL <a href='$url'>$url</a> instead.\", 0, 1);\n\t\t\t} else {\n\t\t\t\t&http_error(404, \"Page not found\",\n\t\t\t\t    \"The requested URL was not found on this server.\");\n\t\t\t}\nEOF\n\t\tif ($@) {\n\t\t\t&http_error(400, \"Bad Request\");\n\t\t\t}\n\t\t}\n\telse {\n\t\t&http_error(400, \"Bad Request\");\n\t\t}\n\t}\n$method = $1;\n$request_uri = $page = $2;\n%header = ();\nlocal $lastheader;\nwhile(1) {\n\t($headline = &read_line()) =~ s/\\r|\\n//g;\n\tlast if ($headline eq \"\");\n\tprint DEBUG \"handle_request: got headline $headline\\n\";\n\tif ($headline =~ /^(\\S+):\\s*(.*)$/) {\n\t\t$header{$lastheader = lc($1)} = $2;\n\t\t}\n\telsif ($headline =~ /^\\s+(.*)$/) {\n\t\t$header{$lastheader} .= $headline;\n\t\t}\n\telse {\n\t\t&http_error(400, \"Bad Header \".&html_strip($headline));\n\t\t}\n\tif (&is_bad_header($header{$lastheader}, $lastheader)) {\n\t\tdelete($header{$lastheader});\n\t\t&http_error(400, \"Bad Header Contents \".\n\t\t\t\t &html_strip($lastheader));\n\t\t}\n\t}\n\n# If a remote IP is given in a header (such as via a proxy), only use it\n# for logging unless trust_real_ip is set\nlocal $headerhost = $header{'x-forwarded-for'} ||\n\t\t    $header{'x-real-ip'};\nif ($headerhost) {\n\t# Only real IPs are allowed\n\t$headerhost = undef if (!&check_ipaddress($headerhost) &&\n\t\t\t\t!&check_ip6address($headerhost));\n\t}\nif ($config{'trust_real_ip'}) {\n\t$acpthost = $headerhost || $acpthost;\n\tif (&check_ipaddress($headerhost) || &check_ip6address($headerhost)) {\n\t\t# If a remote IP was given, use it for all access control checks\n\t\t# from now on.\n\t\t$acptip = $headerhost;\n\t\t\n\t\t# re-check remote address against access list\n\t\tif (@deny && &ip_match($acptip, $localip, @deny) ||\n\t\t    @allow && !&ip_match($acptip, $localip, @allow)) {\n\t\t\t&http_error(403, \"Access denied for \".&html_strip($acptip));\n\t\t\treturn 0;\n\t\t\t}\n\t\t\n\t\tif ($use_libwrap) {\n\t\t\t# Check address with TCP-wrappers\n\t\t\tif (!hosts_ctl($config{'pam'}, STRING_UNKNOWN,\n\t\t\t\t       $acptip, STRING_UNKNOWN)) {\n\t\t\t\t&http_error(403, \"Access denied for \".&html_strip($acptip).\n\t\t\t\t\t\t \" by TCP wrappers\");\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\tprint DEBUG \"handle_request: passed Remote IP checks\\n\";\n\t\t}\n\t$loghost = $acpthost;\n\t}\nelse {\n\t$loghost = $headerhost || $loghost;\n\t}\n\nif (defined($header{'host'})) {\n\tif ($header{'host'} =~ /^\\[(.+)\\]:([0-9]+)$/) {\n\t\t($host, $port) = ($1, $2);\n\t\t}\n\telsif ($header{'host'} =~ /^([^:]+):([0-9]+)$/) {\n\t\t($host, $port) = ($1, $2);\n\t\t}\n\telse {\n\t\t$host = $header{'host'};\n\t\t}\n\tif ($config{'musthost'} && $host ne $config{'musthost'}) {\n\t\t# Disallowed hostname used\n\t\t&http_error(400, \"Invalid HTTP hostname\");\n\t\t}\n\t}\n\n# Create strings for use in redirects\n$ssl = $config{'redirect_ssl'} ne '' ? $config{'redirect_ssl'} :\n\t$use_ssl || $config{'inetd_ssl'};\n$redirport = $config{'redirect_port'} || $port;\n$portstr = $redirport == 80 && !$ssl ? \"\" :\n\t   $redirport == 443 && $ssl ? \"\" : \":\".$redirport;\n$redirhost = $config{'redirect_host'} || $host;\n$hostport = &check_ip6address($redirhost) ? \"[\".$redirhost.\"]\".$portstr\n\t\t\t\t          : $redirhost.$portstr;\n\n# If the redirect_prefix exists change redirect base to include the prefix #1271\nif ($config{'redirect_prefix'}) {\n\t$hostport .= $config{'redirect_prefix'}\n\t}\n$prot = $ssl ? \"https\" : \"http\";\n\nundef(%in);\nif ($page =~ /^([^\\?]+)\\?(.*)$/) {\n\t# There is some query string information\n\t$page = $1;\n\t$querystring = $2;\n\tprint DEBUG \"handle_request: querystring=$querystring\\n\";\n\tif ($querystring !~ /=/) {\n\t\t$queryargs = $querystring;\n\t\t$queryargs =~ s/\\+/ /g;\n    \t\t$queryargs =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$querystring = \"\";\n\t\t}\n\telse {\n\t\t# Parse query-string parameters\n\t\tlocal @in = split(/\\&/, $querystring);\n\t\tforeach $i (@in) {\n\t\t\tlocal ($k, $v) = split(/=/, $i, 2);\n\t\t\t$k =~ s/\\+/ /g; $k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t\t$v =~ s/\\+/ /g; $v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t\t$in{$k} = $v;\n\t\t\t}\n\t\t}\n\t}\n$posted_data = undef;\nif ($method eq 'POST' &&\n    $header{'content-type'} eq 'application/x-www-form-urlencoded') {\n\t# Read in posted query string information, up the configured maximum\n\t# post request length\n\t$clen = $header{\"content-length\"};\n\t$clen_read = $clen > $config{'max_post'} ? $config{'max_post'} : $clen;\n\twhile(length($posted_data) < $clen_read) {\n\t\talarm(60);\n\t\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\t\teval {\n\t\t\t$buf = &read_data($clen_read - length($posted_data));\n\t\t\t};\n\t\talarm(0);\n\t\tif ($@) {\n\t\t\t&http_error(500, \"Timeout reading POST request\");\n\t\t\t}\n\t\tif (!length($buf)) {\n\t\t\t&http_error(500, \"Failed to read POST request\");\n\t\t\t}\n\t\tchomp($posted_data);\n\t\t$posted_data =~ s/\\015$//mg;\n\t\t$posted_data .= $buf;\n\t\t}\n\tprint DEBUG \"clen_read=$clen_read clen=$clen posted_data=\",length($posted_data),\"\\n\";\n\tif ($clen_read != $clen && length($posted_data) > $clen) {\n\t\t# If the client sent more data than we asked for, chop the\n\t\t# rest off\n\t\t$posted_data = substr($posted_data, 0, $clen);\n\t\t}\n\tif (length($posted_data) > $clen) {\n\t\t# When the client sent too much, delay so that it gets headers\n\t\tsleep(3);\n\t\t}\n\tif ($header{'user-agent'} =~ /MSIE/ &&\n\t    $header{'user-agent'} !~ /Opera/i) {\n\t\t# MSIE includes an extra newline in the data\n\t\t$posted_data =~ s/\\r|\\n//g;\n\t\t}\n\tlocal @in = split(/\\&/, $posted_data);\n\tforeach $i (@in) {\n\t\tlocal ($k, $v) = split(/=/, $i, 2);\n\t\t#$v =~ s/\\r|\\n//g;\n\t\t$k =~ s/\\+/ /g; $k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$v =~ s/\\+/ /g; $v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$in{$k} = $v;\n\t\t}\n\tprint DEBUG \"handle_request: posted_data=$posted_data\\n\";\n\t}\n\n# Reject CONNECT request, which isn't supported\nif ($method eq \"CONNECT\" || $method eq \"TRACE\") {\n\t&http_error(405, \"Method \".&html_strip($method).\" is not supported\");\n\t}\n\n# work out accepted encodings\n%acceptenc = map { $_, 1 } split(/,/, $header{'accept-encoding'});\n\n# replace %XX sequences in page\n$page =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\n# Check if the browser's user agent indicates a mobile device\n$mobile_device = &is_mobile_useragent($header{'user-agent'});\n\n# Check if Host: header is for a mobile URL\nforeach my $m (@mobile_prefixes) {\n\tif ($header{'host'} =~ /^\\Q$m\\E/i) {\n\t\t$mobile_device = 1;\n\t\t}\n\t}\n\n# check for the logout flag file, and if existent deny authentication\nif ($config{'logout'} && -r $config{'logout'}.$in{'miniserv_logout_id'}) {\n\tprint DEBUG \"handle_request: logout flag set\\n\";\n\t$deny_authentication++;\n\topen(LOGOUT, $config{'logout'}.$in{'miniserv_logout_id'});\n\tchop($count = <LOGOUT>);\n\tclose(LOGOUT);\n\t$count--;\n\tif ($count > 0) {\n\t\topen(LOGOUT, \">$config{'logout'}$in{'miniserv_logout_id'}\");\n\t\tprint LOGOUT \"$count\\n\";\n\t\tclose(LOGOUT);\n\t\t}\n\telse {\n\t\tunlink($config{'logout'}.$in{'miniserv_logout_id'});\n\t\t}\n\t}\n\n# check for any redirect for the requested URL\nforeach my $pfx (@strip_prefix) {\n\tmy $l = length($pfx);\n\tif(length($page) >= $l &&\n\t   substr($page,0,$l) eq $pfx) {\n\t\t$page=substr($page,$l);\n\t\tlast;\n\t\t}\n\t}\n$simple = &simplify_path($page, $bogus);\n$rpath = $simple;\n$rpath .= \"&\".$querystring if (defined($querystring));\n$redir = $redirect{$rpath};\nif (defined($redir)) {\n\tprint DEBUG \"handle_request: redir=$redir\\n\";\n\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t&write_data(\"Date: $datestr\\r\\n\");\n\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t&write_data(\"Location: $prot://$hostport$redir\\r\\n\");\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\treturn 0;\n\t}\n\n# Check for a DAV request\n$davpath = undef;\nforeach my $d (@davpaths) {\n\tif ($simple eq $d || $simple =~ /^\\Q$d\\E\\//) {\n\t\t$davpath = $d;\n\t\tlast;\n\t\t}\n\t}\nif (!$davpath && ($method eq \"SEARCH\" || $method eq \"PUT\")) {\n\t&http_error(400, \"Bad Request method \".&html_strip($method));\n\t}\n\n# Check for password if needed\nif ($config{'userfile'}) {\n\tprint DEBUG \"handle_request: Need authentication\\n\";\n\t$validated = 0;\n\t$blocked = 0;\n\n\t# Session authentication is never used for connections by\n\t# another webmin server, or for specified pages, or for DAV, or XMLRPC,\n\t# or mobile browsers if requested.\n\tif ($header{'user-agent'} =~ /webmin/i ||\n\t    $header{'user-agent'} =~ /$config{'agents_nosession'}/i ||\n\t    $sessiononly{$simple} || $davpath ||\n\t    $simple eq \"/xmlrpc.cgi\" ||\n            $acptip eq $config{'host_nosession'} ||\n\t    $mobile_device && $config{'mobile_nosession'}) {\n\t\tprint DEBUG \"handle_request: Forcing HTTP authentication\\n\";\n\t\t$config{'session'} = 0;\n\t\t}\n\n\t# Check for SSL authentication\n\tif ($use_ssl && $verified_client) {\n\t\t$peername = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\tNet::SSLeay::X509_get_subject_name(\n\t\t\t\t\tNet::SSLeay::get_peer_certificate(\n\t\t\t\t\t\t$ssl_con)));\n\t\t$u = &find_user_by_cert($peername);\n\t\tif ($u) {\n\t\t\t$authuser = $u;\n\t\t\t$validated = 2;\n\t\t\t}\n\t\tif ($use_syslog && !$validated) {\n\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t       \"Unknown SSL certificate $peername\");\n\t\t\t}\n\t\t}\n\n\tif (!$validated && !$deny_authentication) {\n\t\t# check for IP-based authentication\n\t\tlocal $a;\n\t\tforeach $a (keys %ipaccess) {\n\t\t\tif ($acptip eq $a) {\n\t\t\t\t# It does! Auth as the user\n\t\t\t\t$validated = 3;\n\t\t\t\t$baseauthuser = $authuser =\n\t\t\t\t\t$ipaccess{$a};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check for normal HTTP authentication\n\tif (!$validated && !$deny_authentication && !$config{'session'} &&\n\t    $header{authorization} =~ /^basic\\s+(\\S+)$/i) {\n\t\t# authorization given..\n\t\t($authuser, $authpass) = split(/:/, &b64decode($1), 2);\n\t\tprint DEBUG \"handle_request: doing basic auth check authuser=$authuser authpass=$authpass\\n\";\n\t\tlocal ($vu, $expired, $nonexist, $wvu) =\n\t\t\t&validate_user($authuser, $authpass, $host,\n\t\t\t\t       $acptip, $port);\n\t\tprint DEBUG \"handle_request: vu=$vu expired=$expired nonexist=$nonexist\\n\";\n\t\tif ($vu && (!$expired || $config{'passwd_mode'} == 1)) {\n\t\t\t$authuser = $vu;\n\t\t\t$validated = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$validated = 0;\n\t\t\t}\n\t\tif ($use_syslog && !$validated) {\n\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t       ($nonexist ? \"Non-existent\" :\n\t\t\t\t$expired ? \"Expired\" : \"Invalid\").\n\t\t\t       \" login as $authuser from $acpthost\");\n\t\t\t}\n\t\tif ($authuser =~ /\\r|\\n|\\s/) {\n\t\t\t&http_error(500, \"Invalid username\",\n\t\t\t\t    \"Username contains invalid characters\");\n\t\t\t}\n\t\tif ($authpass =~ /\\r|\\n/) {\n\t\t\t&http_error(500, \"Invalid password\",\n\t\t\t\t    \"Password contains invalid characters\");\n\t\t\t}\n\n\t\tif ($config{'passdelay'} && !$config{'inetd'} && $authuser) {\n\t\t\t# check with main process for delay\n\t\t\tprint DEBUG \"handle_request: about to ask for password delay\\n\";\n\t\t\tprint $PASSINw \"delay $authuser $acptip $validated\\n\";\n\t\t\t<$PASSOUTr> =~ /(\\d+) (\\d+)/;\n\t\t\t$blocked = $2;\n\t\t\tprint DEBUG \"handle_request: password delay $1 $2\\n\";\n\t\t\tsleep($1);\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special session login page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $page eq $config{'session_login'}) {\n\t\tif ($in{'logout'} && $header{'cookie'} =~ /(^|\\s|;)$sidname=([a-f0-9]+)/) {\n\t\t\t# Logout clicked .. remove the session\n\t\t\tlocal $sid = $2;\n\t\t\tprint $PASSINw \"delete $sid\\n\";\n\t\t\tlocal $louser = <$PASSOUTr>;\n\t\t\tchop($louser);\n\t\t\t$logout = 1;\n\t\t\t$already_session_id = undef;\n\t\t\t$authuser = $baseauthuser = undef;\n\t\t\tif ($louser) {\n\t\t\t\tif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\", \"Logout by $louser from $acpthost\");\n\t\t\t\t\t}\n\t\t\t\t&run_logout_script($louser, $sid,\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&write_logout_utmp($louser, $actphost);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t# Trim username to remove leading and trailing spaces to \n\t\t\t# be able to login, if username copy/paste from somewhere\n\t\t\t$in{'user'} =~ s/^\\s+|\\s+$//g;\n\n\t\t\t# Validate the user\n\t\t\tif ($in{'user'} =~ /\\r|\\n|\\s/) {\n\t\t\t\t&run_failed_script($in{'user'}, 'baduser',\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&http_error(500, \"Invalid username\",\n\t\t\t\t    \"Username contains invalid characters\");\n\t\t\t\t}\n\t\t\tif ($in{'pass'} =~ /\\r|\\n/) {\n\t\t\t\t&run_failed_script($in{'user'}, 'badpass',\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&http_error(500, \"Invalid password\",\n\t\t\t\t    \"Password contains invalid characters\");\n\t\t\t\t}\n\n\t\t\tlocal ($vu, $expired, $nonexist, $wvu) =\n\t\t\t\t&validate_user($in{'user'}, $in{'pass'}, $host,\n\t\t\t\t\t       $acptip, $port);\n\t\t\tif ($vu && $wvu) {\n\t\t\t\tmy $uinfo = &get_user_details($wvu);\n\t\t\t\tif ($uinfo && $uinfo->{'twofactor_provider'}) {\n\t\t\t\t\t# Check two-factor token ID\n\t\t\t\t\t$err = &validate_twofactor(\n\t\t\t\t\t\t$wvu, $in{'twofactor'});\n\t\t\t\t\tif ($err) {\n\t\t\t\t\t\t&run_failed_script(\n\t\t\t\t\t\t\t$vu, 'twofactor',\n\t\t\t\t\t\t\t$loghost, $localip);\n\t\t\t\t\t\t$twofactor_msg = $err;\n\t\t\t\t\t\t$twofactor_nolog = 'nolog' if (!$in{'twofactor'});\n\t\t\t\t\t\t$vu = undef;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t\t$vu || $in{'user'}, $vu ? 1 : 0,\n\t\t\t\t      \t$expired, $nonexist, $in{'pass'},\n\t\t\t\t\t$in{'notestingcookie'}, $twofactor_nolog);\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special PAM login page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $use_pam && $config{'pam_conv'} && $page eq $config{'pam_login'} &&\n\t    !$in{'restart'}) {\n\t\t# A question has been entered .. submit it to the main process\n\t\tprint DEBUG \"handle_request: Got call to $page ($in{'cid'})\\n\";\n\t\tprint DEBUG \"handle_request: For PAM, authuser=$authuser\\n\";\n\t\tif ($in{'answer'} =~ /\\r|\\n/ || $in{'cid'} =~ /\\r|\\n|\\s/) {\n\t\t\t&http_error(500, \"Invalid response\",\n\t\t\t    \"Response contains invalid characters\");\n\t\t\t}\n\n\t\tif (!$in{'cid'}) {\n\t\t\t# Start of a new conversation - answer must be username\n\t\t\t$cid = &generate_random_id();\n\t\t\tprint $PASSINw \"pamstart $cid $host $in{'answer'}\\n\";\n\t\t\t}\n\t\telse {\n\t\t\t# A response to a previous question\n\t\t\t$cid = $in{'cid'};\n\t\t\tprint $PASSINw \"pamanswer $cid $in{'answer'}\\n\";\n\t\t\t}\n\n\t\t# Read back the response, and the next question (if any)\n\t\tlocal $line = <$PASSOUTr>;\n\t\t$line =~ s/\\r|\\n//g;\n\t\tlocal ($rv, $question) = split(/\\s+/, $line, 2);\n\t\tif ($rv == 0) {\n\t\t\t# Cannot login!\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t!$in{'cid'} && $in{'answer'} ? $in{'answer'}\n\t\t\t\t\t\t\t     : \"unknown\",\n\t\t\t\t0, 0, 1, undef);\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\telsif ($rv == 1 || $rv == 3) {\n\t\t\t# Another question .. force use of PAM CGI\n\t\t\t$validated = 1;\n\t\t\t$method = \"GET\";\n\t\t\t$querystring .= \"&cid=$cid&question=\".\n\t\t\t\t\t&urlize($question);\n\t\t\t$querystring .= \"&password=1\" if ($rv == 3);\n\t\t\t$queryargs = \"\";\n\t\t\t$page = $config{'pam_login'};\n\t\t\t$miniserv_internal = 1;\n\t\t\t$logged_code = 401;\n\t\t\t}\n\t\telsif ($rv == 2) {\n\t\t\t# Got back a final ok or failure\n\t\t\tlocal ($user, $ok, $expired, $nonexist) =\n\t\t\t\tsplit(/\\s+/, $question);\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t$user, $ok, $expired, $nonexist, undef,\n\t\t\t\t$in{'notestingcookie'});\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\telsif ($rv == 4) {\n\t\t\t# A message from PAM .. tell the user\n\t\t\t$validated = 1;\n\t\t\t$method = \"GET\";\n\t\t\t$querystring .= \"&cid=$cid&message=\".\n\t\t\t\t\t&urlize($question);\n\t\t\t$queryargs = \"\";\n\t\t\t$page = $config{'pam_login'};\n\t\t\t$miniserv_internal = 1;\n\t\t\t$logged_code = 401;\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special password change page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $page eq $config{'password_change'} && !$validated) {\n\t\t# Just let this slide ..\n\t\t$validated = 1;\n\t\t$miniserv_internal = 3;\n\t\t}\n\n\t# Check for an existing session\n\tif ($config{'session'} && !$validated) {\n\t\tif ($already_session_id) {\n\t\t\t$session_id = $already_session_id;\n\t\t\t$authuser = $already_authuser;\n\t\t\t$validated = 1;\n\t\t\t}\n\t\telsif (!$deny_authentication &&\n\t\t       $header{'cookie'} =~ /(^|\\s|;)$sidname=([a-f0-9]+)/) {\n\t\t\t# Try all session cookies\n\t\t\tlocal $cookie = $header{'cookie'};\n\t\t\twhile($cookie =~ s/(^|\\s|;)$sidname=([a-f0-9]+)//) {\n\t\t\t\t$session_id = $2;\n\t\t\t\tlocal $notimeout =\n\t\t\t\t\t$in{'webmin_notimeout'} ? 1 : 0;\n\t\t\t\tprint $PASSINw \"verify $session_id $notimeout $acptip\\n\";\n\t\t\t\t<$PASSOUTr> =~ /(\\d+)\\s+(\\S+)/;\n\t\t\t\tif ($1 == 2) {\n\t\t\t\t\t# Valid session continuation\n\t\t\t\t\t$validated = 1;\n\t\t\t\t\t$authuser = $2;\n\t\t\t\t\t$already_authuser = $authuser;\n\t\t\t\t\t$timed_out = undef;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 == 1) {\n\t\t\t\t\t# Session timed out\n\t\t\t\t\t$timed_out = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 == 3) {\n\t\t\t\t\t# Session is OK, but from the wrong IP\n\t\t\t\t\tprint STDERR \"Session $session_id was \",\n\t\t\t\t\t  \"used from $acptip instead of \",\n\t\t\t\t\t  \"original IP $2\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Invalid session ID .. don't set\n\t\t\t\t\t# verified flag\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check for local authentication\n\tif ($localauth_user && !$header{'x-forwarded-for'} && !$header{'via'}) {\n\t\tmy $luser = &get_user_details($localauth_user);\n\t\tif ($luser) {\n\t\t\t# Local user exists in webmin users file\n\t\t\t$validated = 1;\n\t\t\t$authuser = $localauth_user;\n\t\t\t}\n\t\telse {\n\t\t\t# Check if local user is allowed by unixauth\n\t\t\tlocal @can = &can_user_login($localauth_user,\n\t\t\t\t\t\t     undef, $host);\n\t\t\tif ($can[0]) {\n\t\t\t\t$validated = 2;\n\t\t\t\t$authuser = $localauth_user;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$localauth_user = undef;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\t# Check if this path allows anonymous access\n\t\tlocal $a;\n\t\tforeach $a (keys %anonymous) {\n\t\t\tif (substr($simple, 0, length($a)) eq $a) {\n\t\t\t\t# It does! Auth as the user, if IP access\n\t\t\t\t# control allows him.\n\t\t\t\tif (&check_user_ip($anonymous{$a}) &&\n\t\t\t\t    &check_user_time($anonymous{$a})) {\n\t\t\t\t\t$validated = 3;\n\t\t\t\t\t$baseauthuser = $authuser =\n\t\t\t\t\t\t$anonymous{$a};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\t# Check if this path allows unauthenticated access\n\t\tlocal ($u, $unauth);\n\t\tforeach $u (@unauth) {\n\t\t\t$unauth++ if ($simple =~ /$u/);\n\t\t\t}\n\t\tif (!$bogus && $unauth) {\n\t\t\t# Unauthenticated directory or file request - approve it\n\t\t\t$validated = 4;\n\t\t\t$baseauthuser = $authuser = undef;\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\tif ($blocked == 0) {\n\t\t\t# No password given.. ask\n\t\t\tif ($config{'pam_conv'} && $use_pam) {\n\t\t\t\t# Force CGI for PAM question, starting with\n\t\t\t\t# the username which is always needed\n\t\t\t\t$validated = 1;\n\t\t\t\t$method = \"GET\";\n\t\t\t\t$querystring .= \"&initial=1&question=\".\n\t\t\t\t\t\t&urlize(\"Username\");\n\t\t\t\t$querystring .= \"&failed=$failed_user\" if ($failed_user);\n\t\t\t\t$querystring .= \"&timed_out=$timed_out\" if ($timed_out);\n\t\t\t\t$queryargs = \"\";\n\t\t\t\t$page = $config{'pam_login'};\n\t\t\t\t$miniserv_internal = 1;\n\t\t\t\t$logged_code = 401;\n\t\t\t\t}\n\t\t\telsif ($config{'session'}) {\n\t\t\t\t# Force CGI for session login\n\t\t\t\t$validated = 1;\n\t\t\t\tif ($logout) {\n\t\t\t\t\t$querystring .= \"&logout=1&page=/\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Re-direct to current module only\n\t\t\t\t\tlocal $rpage = $request_uri;\n\t\t\t\t\tif (!$config{'loginkeeppage'}) {\n\t\t\t\t\t\t$rpage =~ s/\\?.*$//;\n\t\t\t\t\t\t$rpage =~ s/[^\\/]+$//\n\t\t\t\t\t\t}\n\t\t\t\t\t$querystring = \"page=\".&urlize($rpage);\n\t\t\t\t\t}\n\t\t\t\t$method = \"GET\";\n\t\t\t\t$querystring .= \"&failed=\".&urlize($failed_user)\n\t\t\t\t\tif ($failed_user);\n\t\t\t\tif ($twofactor_msg) {\n\t\t\t\t\t$querystring .= \"&failed_save=\".&urlize($failed_save);\n\t\t\t\t\t$querystring .= \"&failed_pass=\".&urlize($failed_pass);\n\t\t\t\t\t$querystring .= \"&failed_twofactor_attempt=\".&urlize($failed_twofactor_attempt);\n\t\t\t\t\t$querystring .= \"&twofactor_msg=\".&urlize($twofactor_msg);\n\t\t\t\t\t}\n\t\t\t\t$querystring .= \"&timed_out=$timed_out\"\n\t\t\t\t\tif ($timed_out);\n\t\t\t\t$queryargs = \"\";\n\t\t\t\t$page = $config{'session_login'};\n\t\t\t\t$miniserv_internal = 1;\n\t\t\t\t$logged_code = 401;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Ask for login with HTTP authentication\n\t\t\t\t&write_data(\"HTTP/1.0 401 Unauthorized\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_data(\"WWW-authenticate: Basic \".\n\t\t\t\t\t   \"realm=\\\"$config{'realm'}\\\"\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t&write_data(\"Content-type: text/html; Charset=utf-8\\r\\n\");\n\t\t\t\t&write_data(\"\\r\\n\");\n\t\t\t\t&reset_byte_count();\n\t\t\t\t&write_data(\"<html>\\n\");\n\t\t\t\t&write_data(\"<head><title>Unauthorized</title></head>\\n\");\n\t\t\t\t&write_data(\"<body><h2 style='color: #de0000; margin-bottom: -8px;'>Unauthorized</h2>\\n\");\n\t\t\t\t&write_data(\"A password is required to access this\\n\");\n\t\t\t\t&write_data(\"web server. Please try again. <p>\\n\");\n\t\t\t\t&write_data(\"</body></html>\\n\");\n\t\t\t\t&log_request($loghost, undef, $reqline, 401, &byte_count());\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($blocked == 1) {\n\t\t\t# when the host has been blocked, give it an error\n\t\t\t&http_error(403, \"Access denied for $acptip. The host \".\n\t\t\t\t\t \"has been blocked because of too \".\n\t\t\t\t\t \"many authentication failures.\");\n\t\t\t}\n\t\telsif ($blocked == 2) {\n\t\t\t# when the user has been blocked, give it an error\n\t\t\t&http_error(403, \"Access denied. The user \".\n\t\t\t\t\t \"has been blocked because of too \".\n\t\t\t\t\t \"many authentication failures.\");\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Get the real Webmin username\n\t\tlocal @can = &can_user_login($authuser, undef, $host);\n\t\t$baseauthuser = $can[3] || $authuser;\n\n\t\tif ($config{'remoteuser'} && !$< && $validated) {\n\t\t\t# Switch to the UID of the remote user (if he exists)\n\t\t\tlocal @u = getpwnam($authuser);\n\t\t\tif (@u && $< != $u[2]) {\n\t\t\t\t$( = $u[3]; $) = \"$u[3] $u[3]\";\n\t\t\t\t($>, $<) = ($u[2], $u[2]);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&http_error(500, \"Unix user \".\n\t\t\t\t  &html_strip($authuser).\" does not exist\");\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check per-user IP access control\n\tif (!&check_user_ip($baseauthuser)) {\n\t\t&http_error(403, \"Access denied for $acptip for \".\n\t\t\t\t &html_strip($baseauthuser));\n\t\treturn 0;\n\t\t}\n\n\t# Check per-user allowed times\n\tif (!&check_user_time($baseauthuser)) {\n\t\t&http_error(403, \"Access denied at the current time\");\n\t\treturn 0;\n\t\t}\n\t}\n$uinfo = &get_user_details($baseauthuser);\n\n# Validate the path, and convert to canonical form\nrerun:\n$simple = &simplify_path($page, $bogus);\nprint DEBUG \"handle_request: page=$page simple=$simple\\n\";\nif ($bogus) {\n\t&http_error(400, \"Invalid path\");\n\t}\n\n# Check for a DAV request\nif ($davpath) {\n\treturn &handle_dav_request($davpath);\n\t}\n\n# Work out the active theme(s)\nlocal $preroots = $mobile_device && defined($config{'mobile_preroot'}) ?\n\t\t\t$config{'mobile_preroot'} :\n\t\t $authuser && defined($config{'preroot_'.$authuser}) ?\n\t\t\t$config{'preroot_'.$authuser} :\n\t         $uinfo && defined($uinfo->{'preroot'}) ?\n\t\t\t$uinfo->{'preroot'} :\n\t\t\t$config{'preroot'};\nlocal @preroots = reverse(split(/\\s+/, $preroots));\n\n# Canonicalize the directories\nforeach my $preroot (@preroots) {\n\t# Always under the current webmin root\n\t$preroot =~ s/^.*\\///g;\n\t$preroot = $roots[0].'/'.$preroot;\n\t}\n\n# Look in the theme root directories first\nlocal ($full, @stfull);\n$foundroot = undef;\nforeach my $preroot (@preroots) {\n\t$is_directory = 1;\n\t$sofar = \"\";\n\t$full = $preroot.$sofar;\n\t$scriptname = $simple;\n\tforeach $b (split(/\\//, $simple)) {\n\t\tif ($b ne \"\") { $sofar .= \"/$b\"; }\n\t\t$full = $preroot.$sofar;\n\t\t@stfull = stat($full);\n\t\tif (!@stfull) { undef($full); last; }\n\n\t\t# Check if this is a directory\n\t\tif (-d _) {\n\t\t\t# It is.. go on parsing\n\t\t\t$is_directory = 1;\n\t\t\tnext;\n\t\t\t}\n\t\telse {\n\t\t\t$is_directory = 0;\n\t\t\t}\n\n\t\t# Check if this is a CGI program\n\t\tif (&get_type($full) eq \"internal/cgi\") {\n\t\t\t$pathinfo = substr($simple, length($sofar));\n\t\t\t$pathinfo .= \"/\" if ($page =~ /\\/$/);\n\t\t\t$scriptname = $sofar;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\n\t# Don't stop at a directory unless this is the last theme, which\n\t# is the 'real' one that provides the .cgi scripts\n\tif ($is_directory && $preroot ne $preroots[$#preroots]) {\n\t\tnext;\n\t\t}\n\n\tif ($full) {\n\t\t# Found it!\n\t\tif ($sofar eq '') {\n\t\t\t$cgi_pwd = $roots[0];\n\t\t\t}\n\t\telsif ($is_directory) {\n\t\t\t$cgi_pwd = \"$roots[0]$sofar\";\n\t\t\t}\n\t\telse {\n\t\t\t\"$roots[0]$sofar\" =~ /^(.*\\/)[^\\/]+$/;\n\t\t\t$cgi_pwd = $1;\n\t\t\t}\n\t\t$foundroot = $preroot;\n\t\tif ($is_directory) {\n\t\t\t# Check for index files in the directory\n\t\t\tlocal $foundidx;\n\t\t\tforeach $idx (split(/\\s+/, $config{\"index_docs\"})) {\n\t\t\t\t$idxfull = \"$full/$idx\";\n\t\t\t\tlocal @stidxfull = stat($idxfull);\n\t\t\t\tif (-r _ && !-d _) {\n\t\t\t\t\t$full = $idxfull;\n\t\t\t\t\t@stfull = @stidxfull;\n\t\t\t\t\t$is_directory = 0;\n\t\t\t\t\t$scriptname .= \"/\"\n\t\t\t\t\t\tif ($scriptname ne \"/\");\n\t\t\t\t\t$foundidx++;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t@stfull = stat($full) if (!$foundidx);\n\t\t\t}\n\t\t}\n\tlast if ($foundroot);\n\t}\nprint DEBUG \"handle_request: initial full=$full\\n\";\n\n# Look in the real root directories, stopping when we find a file or directory\nif (!$full || $is_directory) {\n\tROOT: foreach $root (@roots) {\n\t\t$sofar = \"\";\n\t\t$full = $root.$sofar;\n\t\t$scriptname = $simple;\n\t\tforeach $b ($simple eq \"/\" ? ( \"\" ) : split(/\\//, $simple)) {\n\t\t\tif ($b ne \"\") { $sofar .= \"/$b\"; }\n\t\t\t$full = $root.$sofar;\n\t\t\t@stfull = stat($full);\n\t\t\tif (!@stfull) {\n\t\t\t\tnext ROOT;\n\t\t\t\t}\n\n\t\t\t# Check if this is a directory\n\t\t\tif (-d _) {\n\t\t\t\t# It is.. go on parsing\n\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t# Check if this is a CGI program\n\t\t\tif (&get_type($full) eq \"internal/cgi\") {\n\t\t\t\t$pathinfo = substr($simple, length($sofar));\n\t\t\t\t$pathinfo .= \"/\" if ($page =~ /\\/$/);\n\t\t\t\t$scriptname = $sofar;\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Run CGI in the same directory as whatever file\n\t\t# was requested\n\t\t$full =~ /^(.*\\/)[^\\/]+$/; $cgi_pwd = $1;\n\n\t\tif (-e $full) {\n\t\t\t# Found something!\n\t\t\t$realroot = $root;\n\t\t\t$foundroot = $root;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif (!@stfull) { &http_error(404, \"File not found\"); }\n\t}\nprint DEBUG \"handle_request: full=$full\\n\";\n@stfull = stat($full) if (!@stfull);\n\n# check filename against denyfile regexp\nlocal $denyfile = $config{'denyfile'};\nif ($denyfile && $full =~ /$denyfile/) {\n\t&http_error(403, \"Access denied to \".&html_strip($page));\n\treturn 0;\n\t}\n\n# Reached the end of the path OK.. see what we've got\nif (-d _) {\n\t# See if the URL ends with a / as it should\n\tprint DEBUG \"handle_request: found a directory\\n\";\n\tif ($page !~ /\\/$/) {\n\t\t# It doesn't.. redirect\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t&write_data(\"Location: $prot://$hostport$page/\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\treturn 0;\n\t\t}\n\t# A directory.. check for index files\n\tlocal $foundidx;\n\tforeach $idx (split(/\\s+/, $config{\"index_docs\"})) {\n\t\t$idxfull = \"$full/$idx\";\n\t\t@stidxfull = stat($idxfull);\n\t\tif (-r _ && !-d _) {\n\t\t\t$cgi_pwd = $full;\n\t\t\t$full = $idxfull;\n\t\t\t@stfull = @stidxfull;\n\t\t\t$scriptname .= \"/\" if ($scriptname ne \"/\");\n\t\t\t$foundidx++;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t@stfull = stat($full) if (!$foundidx);\n\t}\nif (-d _) {\n\t# This is definitely a directory.. list it\n\tif ($config{'nolistdir'}) {\n\t\t&http_error(500, \"Directory is missing an index file\");\n\t\t}\n\tprint DEBUG \"handle_request: listing directory\\n\";\n\tlocal $resp = \"HTTP/1.0 $ok_code $ok_message\\r\\n\".\n\t\t      \"Date: $datestr\\r\\n\".\n\t\t      \"Server: $config{server}\\r\\n\".\n\t\t      \"Content-type: text/html; Charset=utf-8\\r\\n\";\n\t&write_data($resp);\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\t&reset_byte_count();\n\t&write_data(\"<h2 style='color: #de0000; margin-bottom: -8px;'>Index of $simple</h2>\\n\");\n\t&write_data(\"<pre>\\n\");\n\t&write_data(sprintf \"%-35.35s %-20.20s %-10.10s\\n\",\n\t\t\t\"Name\", \"Last Modified\", \"Size\");\n\t&write_data(\"<hr>\\n\");\n\topendir(DIR, $full);\n\twhile($df = readdir(DIR)) {\n\t\tif ($df =~ /^\\./) { next; }\n\t\t$fulldf = $full eq \"/\" ? $full.$df : $full.\"/\".$df;\n\t\t(@stbuf = stat($fulldf)) || next;\n\t\tif (-d _) { $df .= \"/\"; }\n\t\t@tm = localtime($stbuf[9]);\n\t\t$fdate = sprintf \"%2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d\",\n\t\t\t\t$tm[3],$tm[4]+1,$tm[5]+1900,\n\t\t\t\t$tm[0],$tm[1],$tm[2];\n\t\t$len = length($df); $rest = \" \"x(35-$len);\n\t\t&write_data(sprintf \n\t\t \"<a href=\\\"%s\\\">%-${len}.${len}s</a>$rest %-20.20s %-10.10s\\n\",\n\t\t &urlize($df), &html_strip($df), $fdate, $stbuf[7]);\n\t\t}\n\tclosedir(DIR);\n\t&log_request($loghost, $authuser, $reqline, $ok_code, &byte_count());\n\treturn 0;\n\t}\n\n# CGI or normal file\nlocal $rv;\nif (&get_type($full) eq \"internal/cgi\" && $validated != 4) {\n\t# A CGI program to execute\n\tprint DEBUG \"handle_request: executing CGI\\n\";\n\t$envtz = $ENV{\"TZ\"};\n\t$envuser = $ENV{\"USER\"};\n\t$envpath = $ENV{\"PATH\"};\n\t$envlang = $ENV{\"LANG\"};\n\t$envroot = $ENV{\"SystemRoot\"};\n\t$envperllib = $ENV{'PERLLIB'};\n\tforeach my $k (keys %ENV) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t$ENV{\"PATH\"} = $envpath if ($envpath);\n\t$ENV{\"TZ\"} = $envtz if ($envtz);\n\t$ENV{\"USER\"} = $envuser if ($envuser);\n\t$ENV{\"OLD_LANG\"} = $envlang if ($envlang);\n\t$ENV{\"SystemRoot\"} = $envroot if ($envroot);\n\t$ENV{'PERLLIB'} = $envperllib if ($envperllib);\n\t$ENV{\"HOME\"} = $user_homedir;\n\t$ENV{\"SERVER_SOFTWARE\"} = $config{\"server\"};\n\t$ENV{\"SERVER_NAME\"} = $host;\n\t$ENV{\"SERVER_ADMIN\"} = $config{\"email\"};\n\t$ENV{\"SERVER_ROOT\"} = $roots[0];\n\t$ENV{\"SERVER_REALROOT\"} = $realroot;\n\t$ENV{\"SERVER_PORT\"} = $port;\n\t$ENV{\"REMOTE_HOST\"} = $acpthost;\n\t$ENV{\"REMOTE_ADDR\"} = $acptip;\n\t$ENV{\"REMOTE_ADDR_PROTOCOL\"} = $ipv6 ? 6 : 4;\n\t$ENV{\"REMOTE_USER\"} = $authuser;\n\t$ENV{\"BASE_REMOTE_USER\"} = $authuser ne $baseauthuser ?\n\t\t\t\t\t$baseauthuser : undef;\n\t$ENV{\"REMOTE_PASS\"} = $authpass if (defined($authpass) &&\n\t\t\t\t\t    $config{'pass_password'});\n\tif ($uinfo && $uinfo->{'proto'}) {\n\t\t$ENV{\"REMOTE_USER_PROTO\"} = $uinfo->{'proto'};\n\t\t$ENV{\"REMOTE_USER_ID\"} = $uinfo->{'id'};\n\t\t}\n\tprint DEBUG \"REMOTE_USER = \",$ENV{\"REMOTE_USER\"},\"\\n\";\n\tprint DEBUG \"BASE_REMOTE_USER = \",$ENV{\"BASE_REMOTE_USER\"},\"\\n\";\n\tprint DEBUG \"proto=$uinfo->{'proto'} id=$uinfo->{'id'}\\n\" if ($uinfo);\n\t$ENV{\"SSL_USER\"} = $peername if ($validated == 2);\n\t$ENV{\"ANONYMOUS_USER\"} = \"1\" if ($validated == 3 || $validated == 4);\n\t$ENV{\"DOCUMENT_ROOT\"} = $roots[0];\n\t$ENV{\"THEME_ROOT\"} = \"$roots[0]/\" .\n\t                     ($config{\"preroot_$authuser\"} ||\n\t                      $config{\"preroot\"});\n\t$ENV{\"DOCUMENT_REALROOT\"} = $realroot;\n\t$ENV{\"GATEWAY_INTERFACE\"} = \"CGI/1.1\";\n\t$ENV{\"SERVER_PROTOCOL\"} = \"HTTP/1.0\";\n\t$ENV{\"REQUEST_METHOD\"} = $method;\n\t$ENV{\"SCRIPT_NAME\"} = $scriptname;\n\t$ENV{\"SCRIPT_FILENAME\"} = $full;\n\t$ENV{\"REQUEST_URI\"} = $request_uri;\n\t$ENV{\"PATH_INFO\"} = $pathinfo;\n\tif ($pathinfo) {\n\t\t$ENV{\"PATH_TRANSLATED\"} = \"$roots[0]$pathinfo\";\n\t\t$ENV{\"PATH_REALTRANSLATED\"} = \"$realroot$pathinfo\";\n\t\t}\n\t$ENV{\"QUERY_STRING\"} = $querystring;\n\t$ENV{\"MINISERV_CONFIG\"} = $config_file;\n\t$ENV{\"HTTPS\"} = $use_ssl || $config{'inetd_ssl'} ? \"ON\" : \"\";\n\t$ENV{\"MINISERV_PID\"} = $miniserv_main_pid;\n\t$ENV{\"SESSION_ID\"} = $session_id if ($session_id);\n\t$ENV{\"LOCAL_USER\"} = $localauth_user if ($localauth_user);\n\t$ENV{\"MINISERV_INTERNAL\"} = $miniserv_internal if ($miniserv_internal);\n\tif (defined($header{\"content-length\"})) {\n\t\t$ENV{\"CONTENT_LENGTH\"} = $header{\"content-length\"};\n\t\t}\n\tif (defined($header{\"content-type\"})) {\n\t\t$ENV{\"CONTENT_TYPE\"} = $header{\"content-type\"};\n\t\t}\n\tforeach $h (keys %header) {\n\t\t($hname = $h) =~ tr/a-z/A-Z/;\n\t\t$hname =~ s/\\-/_/g;\n\t\t$ENV{\"HTTP_$hname\"} = $header{$h};\n\t\t}\n\t$ENV{\"PWD\"} = $cgi_pwd;\n\tforeach $k (keys %config) {\n\t\tif ($k =~ /^env_(\\S+)$/) {\n\t\t\t$ENV{$1} = $config{$k};\n\t\t\t}\n\t\t}\n\tdelete($ENV{'HTTP_AUTHORIZATION'});\n\t$ENV{'HTTP_COOKIE'} =~ s/;?\\s*$sidname=([a-f0-9]+)//;\n\t$ENV{'MOBILE_DEVICE'} = 1 if ($mobile_device);\n\n\t# Check if the CGI can be handled internally\n\topen(CGI, $full);\n\tlocal $first = <CGI>;\n\tclose(CGI);\n\t$first =~ s/[#!\\r\\n]//g;\n\t$nph_script = ($full =~ /\\/nph-([^\\/]+)$/);\n\tseek(STDERR, 0, 2);\n\tif (!$config{'forkcgis'} &&\n\t    ($first eq $perl_path || $first eq $linked_perl_path ||\n\t     $first =~ /\\/perl$/ || $first =~ /^\\/\\S+\\/env\\s+perl$/) &&\n\t      $] >= 5.004 ||\n            $config{'internalcgis'}) {\n\t\t# setup environment for eval\n\t\tchdir($ENV{\"PWD\"});\n\t\t@ARGV = split(/\\s+/, $queryargs);\n\t\t$0 = $full;\n\t\tif ($posted_data) {\n\t\t\t# Already read the post input\n\t\t\t$postinput = $posted_data;\n\t\t\t}\n\t\t$clen = $header{\"content-length\"};\n\t\t$SIG{'CHLD'} = 'DEFAULT';\n\t\teval {\n\t\t\t# Have SOCK closed if the perl exec's something\n\t\t\tuse Fcntl;\n\t\t\tfcntl(SOCK, F_SETFD, FD_CLOEXEC);\n\t\t\t};\n\t\t#shutdown(SOCK, 0);\n\n\t\tif ($config{'log'}) {\n\t\t\topen(MINISERVLOG, \">>$config{'logfile'}\");\n\t\t\tif ($config{'logperms'}) {\n\t\t\t\tchmod(oct($config{'logperms'}),\n\t\t\t\t      $config{'logfile'});\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tchmod(0600, $config{'logfile'});\n\t\t\t\t}\n\t\t\t}\n\t\t$doing_cgi_eval = 1;\n\t\t$main_process_id = $$;\n\t\t$pkg = \"main\";\n\t\tif ($full =~ /^\\Q$foundroot\\E\\/([^\\/]+)\\//) {\n\t\t\t# Eval in package from Webmin module name\n\t\t\t$pkg = $1;\n\t\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\t\t}\n\t\teval \"\n\t\t\t\\%pkg::ENV = \\%ENV;\n\t\t\tpackage $pkg;\n\t\t\ttie(*STDOUT, 'miniserv');\n\t\t\ttie(*STDIN, 'miniserv');\n\t\t\tdo \\$miniserv::full;\n\t\t\tdie \\$@ if (\\$@);\n\t\t\t\";\n\t\t$doing_cgi_eval = 0;\n\t\tif ($@) {\n\t\t\t# Error in perl!\n\t\t\t&http_error(500, \"Perl execution failed\",\n\t\t\t\t    $config{'noshowstderr'} ? undef : \"$@\");\n\t\t\t}\n\t\telsif (!$doneheaders && !$nph_script) {\n\t\t\t&http_error(500, \"Missing Headers\");\n\t\t\t}\n\t\t$rv = 0;\n\t\t}\n\telse {\n\t\t$infile = undef;\n\t\tif (!$on_windows) {\n\t\t\t# fork the process that actually executes the CGI\n\t\t\tpipe(CGIINr, CGIINw);\n\t\t\tpipe(CGIOUTr, CGIOUTw);\n\t\t\tpipe(CGIERRr, CGIERRw);\n\t\t\tif (!($cgipid = fork())) {\n\t\t\t\t@execargs = ( $full, split(/\\s+/, $queryargs) );\n\t\t\t\tchdir($ENV{\"PWD\"});\n\t\t\t\tclose(SOCK);\n\t\t\t\topen(STDIN, \"<&CGIINr\");\n\t\t\t\topen(STDOUT, \">&CGIOUTw\");\n\t\t\t\topen(STDERR, \">&CGIERRw\");\n\t\t\t\tclose(CGIINw); close(CGIOUTr); close(CGIERRr);\n\t\t\t\texec(@execargs) ||\n\t\t\t\t\tdie \"Failed to exec $full : $!\\n\";\n\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\tclose(CGIINr); close(CGIOUTw); close(CGIERRw);\n\t\t\t}\n\t\telse {\n\t\t\t# write CGI input to a temp file\n\t\t\t$infile = \"$config{'tempbase'}.$$\";\n\t\t\topen(CGIINw, \">$infile\");\n\t\t\t# NOT binary mode, as CGIs don't read in it!\n\t\t\t}\n\n\t\t# send post data\n\t\tif ($posted_data) {\n\t\t\t# already read the posted data\n\t\t\tprint CGIINw $posted_data;\n\t\t\t}\n\t\t$clen = $header{\"content-length\"};\n\t\tif ($method eq \"POST\" && $clen_read < $clen) {\n\t\t\t$SIG{'PIPE'} = 'IGNORE';\n\t\t\t$got = $clen_read;\n\t\t\twhile($got < $clen) {\n\t\t\t\t$buf = &read_data($clen-$got);\n\t\t\t\tif (!length($buf)) {\n\t\t\t\t\tkill('TERM', $cgipid);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Failed to read \".\n\t\t\t\t\t\t\t \"POST request\");\n\t\t\t\t\t}\n\t\t\t\t$got += length($buf);\n\t\t\t\tlocal ($wrote) = (print CGIINw $buf);\n\t\t\t\tlast if (!$wrote);\n\t\t\t\t}\n\t\t\t# If the CGI terminated early, we still need to read\n\t\t\t# from the browser and throw away\n\t\t\twhile($got < $clen) {\n\t\t\t\t$buf = &read_data($clen-$got);\n\t\t\t\tif (!length($buf)) {\n\t\t\t\t\tkill('TERM', $cgipid);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Failed to read \".\n\t\t\t\t\t\t\t \"POST request\");\n\t\t\t\t\t}\n\t\t\t\t$got += length($buf);\n\t\t\t\t}\n\t\t\t$SIG{'PIPE'} = 'DEFAULT';\n\t\t\t}\n\t\tclose(CGIINw);\n\t\tshutdown(SOCK, 0);\n\n\t\tif ($on_windows) {\n\t\t\t# Run the CGI program, and feed it input\n\t\t\tchdir($ENV{\"PWD\"});\n\t\t\tlocal $qqueryargs = join(\" \", map { \"\\\"$_\\\"\" }\n\t\t\t\t\t\t split(/\\s+/, $queryargs));\n\t\t\tif ($first =~ /(perl|perl.exe)$/i) {\n\t\t\t\t# On Windows, run with Perl\n\t\t\t\topen(CGIOUTr, \"$perl_path \\\"$full\\\" $qqueryargs <$infile |\");\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\topen(CGIOUTr, \"\\\"$full\\\" $qqueryargs <$infile |\");\n\t\t\t\t}\n\t\t\tbinmode(CGIOUTr);\n\t\t\t}\n\n\t\tif (!$nph_script) {\n\t\t\t# read back cgi headers\n\t\t\tselect(CGIOUTr); $|=1; select(STDOUT);\n\t\t\t$got_blank = 0;\n\t\t\twhile(1) {\n\t\t\t\t$line = <CGIOUTr>;\n\t\t\t\t$line =~ s/\\r|\\n//g;\n\t\t\t\tif ($line eq \"\") {\n\t\t\t\t\tif ($got_blank || %cgiheader) { last; }\n\t\t\t\t\t$got_blank++;\n\t\t\t\t\tnext;\n\t\t\t\t\t}\n\t\t\t\tif ($line !~ /^(\\S+):\\s+(.*)$/) {\n\t\t\t\t\t$errs = &read_errors(CGIERRr);\n\t\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Bad Header\", $errs);\n\t\t\t\t\t}\n\t\t\t\t$cgiheader{lc($1)} = $2;\n\t\t\t\tpush(@cgiheader, [ $1, $2 ]);\n\t\t\t\t}\n\t\t\tif ($cgiheader{\"location\"}) {\n\t\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t# ignore the rest of the output. This is a hack,\n\t\t\t\t# but is necessary for IE in some cases :(\n\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\t}\n\t\t\telsif ($cgiheader{\"content-type\"} eq \"\") {\n\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t$errs = &read_errors(CGIERRr);\n\t\t\t\t&http_error(500, \"Missing Content-Type Header\",\n\t\t\t\t    $config{'noshowstderr'} ? undef : $errs);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&write_data(\"HTTP/1.0 $ok_code $ok_message\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\tforeach $h (@cgiheader) {\n\t\t\t\t&write_data(\"$h->[0]: $h->[1]\\r\\n\");\n\t\t\t\t}\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\t}\n\t\t&reset_byte_count();\n\t\twhile($line = <CGIOUTr>) {\n\t\t\t&write_data($line);\n\t\t\t}\n\t\tclose(CGIOUTr);\n\t\tclose(CGIERRr);\n\t\tunlink($infile) if ($infile);\n\t\t$rv = 0;\n\t\t}\n\t}\nelse {\n\t# A file to output\n\tprint DEBUG \"handle_request: outputting file $full\\n\";\n\t$gzfile = $full.\".gz\";\n\t$gzipped = 0;\n\tif ($config{'gzip'} ne '0' && -r $gzfile && $acceptenc{'gzip'}) {\n\t\t# Using gzipped version\n\t\t@stopen = stat($gzfile);\n\t\tif ($stopen[9] >= $stfull[9] && open(FILE, $gzfile)) {\n\t\t\tprint DEBUG \"handle_request: using gzipped $gzfile\\n\";\n\t\t\t$gzipped = 1;\n\t\t\t}\n\t\t}\n\tif (!$gzipped) {\n\t\t# Using original file\n\t\t@stopen = @stfull;\n\t\topen(FILE, $full) || &http_error(404, \"Failed to open file\");\n\t\t}\n\tbinmode(FILE);\n\n\t# Build common headers\n\tlocal $etime = &get_expires_time($simple);\n\tlocal $resp = \"HTTP/1.0 $ok_code $ok_message\\r\\n\".\n\t\t      \"Date: $datestr\\r\\n\".\n\t\t      \"Server: $config{server}\\r\\n\".\n\t\t      \"Content-type: \".&get_type($full).\"\\r\\n\".\n\t\t      \"Last-Modified: \".&http_date($stopen[9]).\"\\r\\n\".\n\t\t      \"Expires: \".&http_date(time()+$etime).\"\\r\\n\".\n\t\t      \"Cache-Control: public; max-age=\".$etime.\"\\r\\n\";\n\n\tif (!$gzipped && $use_gzip && $acceptenc{'gzip'} &&\n\t    &should_gzip_file($full)) {\n\t\t# Load and compress file, then output\n\t\tprint DEBUG \"handle_request: outputting gzipped file $full\\n\";\n\t\topen(FILE, $full) || &http_error(404, \"Failed to open file\");\n\t\t{\n\t\t\tlocal $/ = undef;\n\t\t\t$data = <FILE>;\n\t\t}\n\t\tclose(FILE);\n\t\t@stopen = stat($file);\n\t\t$data = Compress::Zlib::memGzip($data);\n\t\t$resp .= \"Content-length: \".length($data).\"\\r\\n\".\n\t\t\t \"Content-Encoding: gzip\\r\\n\";\n\t\t&write_data($resp);\n\t\t$rv = &write_keep_alive();\n\t\t&write_data(\"\\r\\n\");\n\t\t&reset_byte_count();\n\t\t&write_data($data);\n\t\t}\n\telse {\n\t\t# Stream file output\n\t\t$resp .= \"Content-length: $stopen[7]\\r\\n\";\n\t\t$resp .= \"Content-Encoding: gzip\\r\\n\" if ($gzipped);\n\t\t&write_data($resp);\n\t\t$rv = &write_keep_alive();\n\t\t&write_data(\"\\r\\n\");\n\t\t&reset_byte_count();\n\t\tmy $bufsize = $config{'bufsize'} || 32768;\n\t\twhile(read(FILE, $buf, $bufsize) > 0) {\n\t\t\t&write_data($buf);\n\t\t\t}\n\t\tclose(FILE);\n\t\t}\n\t}\n\n# log the request\n&log_request($loghost, $authuser, $reqline,\n\t     $logged_code ? $logged_code :\n\t     $cgiheader{\"location\"} ? \"302\" : $ok_code, &byte_count());\nreturn $rv;\n}\n\n# http_error(code, message, body, [dontexit], [dontstderr])\n# Output an error message to the browser, and log it to the error log\nsub http_error\n{\nmy ($code, $msg, $body, $noexit, $noerr) = @_;\nlocal $eh = $error_handler_recurse ? undef :\n\t    $config{\"error_handler_\".$code} ? $config{\"error_handler_\".$code} :\n\t    $config{'error_handler'} ? $config{'error_handler'} : undef;\nprint DEBUG \"http_error code=$code message=$msg body=$body\\n\";\nif ($eh) {\n\t# Call a CGI program for the error\n\t$page = \"/$eh\";\n\t$querystring = \"code=$_[0]&message=\".&urlize($msg).\n\t\t       \"&body=\".&urlize($body);\n\t$error_handler_recurse++;\n\t$ok_code = $code;\n\t$ok_message = $msg;\n\tgoto rerun;\n\t}\nelse {\n\t# Use the standard error message display\n\t&write_data(\"HTTP/1.0 $code $msg\\r\\n\");\n\t&write_data(\"Server: $config{server}\\r\\n\");\n\t&write_data(\"Date: $datestr\\r\\n\");\n\t&write_data(\"Content-type: text/html; Charset=utf-8\\r\\n\");\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\t&reset_byte_count();\n\t&write_data(\"<h2 style='color: #de0000; margin-bottom: -8px;'>Error - $msg</h2>\\n\");\n\tif ($body) {\n\t\t&write_data(\"<p>$body</p>\\n\");\n\t\t}\n\t}\n&log_request($loghost, $authuser, $reqline, $code, &byte_count())\n\tif ($reqline);\n&log_error($msg, $body ? \" : $body\" : \"\") if (!$noerr);\nshutdown(SOCK, 1);\nexit if (!$noexit);\n}\n\nsub get_type\n{\nif ($_[0] =~ /\\.([A-z0-9]+)$/) {\n\t$t = $mime{$1};\n\tif ($t ne \"\") {\n\t\treturn $t;\n\t\t}\n\t}\nreturn \"text/plain\";\n}\n\n# simplify_path(path, bogus)\n# Given a path, maybe containing stuff like \"..\" and \".\" convert it to a\n# clean, absolute form.\nsub simplify_path\n{\nlocal($dir, @bits, @fixedbits, $b);\n$dir = $_[0];\n$dir =~ s/\\\\/\\//g;\t# fix windows \\ in path\n$dir =~ s/^\\/+//g;\n$dir =~ s/\\/+$//g;\n$dir =~ s/\\0//g;\t# remove null bytes\n@bits = split(/\\/+/, $dir);\n@fixedbits = ();\n$_[1] = 0;\nforeach $b (@bits) {\n        if ($b eq \".\") {\n                # Do nothing..\n                }\n        elsif ($b eq \"..\" || $b eq \"...\") {\n                # Remove last dir\n                if (scalar(@fixedbits) == 0) {\n                        $_[1] = 1;\n                        return \"/\";\n                        }\n                pop(@fixedbits);\n                }\n        else {\n                # Add dir to list\n                push(@fixedbits, $b);\n                }\n        }\nreturn \"/\" . join('/', @fixedbits);\n}\n\n# b64decode(string)\n# Converts a string from base64 format to normal\nsub b64decode\n{\n    local($str) = $_[0];\n    local($res);\n    $str =~ tr|A-Za-z0-9+=/||cd;\n    $str =~ s/=+$//;\n    $str =~ tr|A-Za-z0-9+/| -_|;\n    while ($str =~ /(.{1,60})/gs) {\n        my $len = chr(32 + length($1)*3/4);\n        $res .= unpack(\"u\", $len . $1 );\n    }\n    return $res;\n}\n\n# ip_match(remoteip, localip, [match]+)\n# Checks an IP address against a list of IPs, networks and networks/masks\nsub ip_match\n{\nlocal(@io, @mo, @ms, $i, $j, $hn, $needhn);\n@io = &check_ip6address($_[0]) ? split(/:/, $_[0])\n\t\t\t       : split(/\\./, $_[0]);\nfor($i=2; $i<@_; $i++) {\n\t$needhn++ if ($_[$i] =~ /^\\*(\\S+)$/);\n\t}\nif ($needhn && !defined($hn = $ip_match_cache{$_[0]})) {\n\t# Reverse-lookup hostname if any rules match based on it\n\t$hn = &to_hostname($_[0]);\n\tif (&check_ip6address($_[0])) {\n\t\t$hn = \"\" if (&to_ip6address($hn) ne $_[0]);\n\t\t}\n\telse {\n\t\t$hn = \"\" if (&to_ipaddress($hn) ne $_[0]);\n\t\t}\n\t$ip_match_cache{$_[0]} = $hn;\n\t}\nfor($i=2; $i<@_; $i++) {\n\tlocal $mismatch = 0;\n\tif ($_[$i] =~ /^([0-9\\.]+)\\/(\\d+)$/) {\n\t\t# Convert CIDR to netmask format\n\t\t$_[$i] = $1.\"/\".&prefix_to_mask($2);\n\t\t}\n\tif ($_[$i] =~ /^([0-9\\.]+)\\/([0-9\\.]+)$/) {\n\t\t# Compare with IPv4 network/mask\n\t\t@mo = split(/\\./, $1);\n\t\t@ms = split(/\\./, $2);\n\t\tfor($j=0; $j<4; $j++) {\n\t\t\tif ((int($io[$j]) & int($ms[$j])) != (int($mo[$j]) & int($ms[$j]))) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^([0-9\\.]+)-([0-9\\.]+)$/) {\n\t\t# Compare with an IPv4 range (separated by a hyphen -)\n\t\tlocal ($remote, $min, $max);\n\t\tlocal @low = split(/\\./, $1);\n\t\tlocal @high = split(/\\./, $2);\n\t\tfor($j=0; $j<4; $j++) {\n\t\t\t$remote += $io[$j] << ((3-$j)*8);\n\t\t\t$min += $low[$j] << ((3-$j)*8);\n\t\t\t$max += $high[$j] << ((3-$j)*8);\n\t\t\t}\n\t\tif ($remote < $min || $remote > $max) {\n\t\t\t$mismatch = 1;\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^\\*(\\S+)$/) {\n\t\t# Compare with hostname regexp\n\t\t$mismatch = 1 if ($hn !~ /^.*\\Q$1\\E$/i);\n\t\t}\n\telsif ($_[$i] eq 'LOCAL' && &check_ipaddress($_[1])) {\n\t\t# Compare with local IPv4 network\n\t\tlocal @lo = split(/\\./, $_[1]);\n\t\tif ($lo[0] < 128) {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0]);\n\t\t\t}\n\t\telsif ($lo[0] < 192) {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0] ||\n\t\t\t\t\t  $lo[1] != $io[1]);\n\t\t\t}\n\t\telse {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0] ||\n\t\t\t\t\t  $lo[1] != $io[1] ||\n\t\t\t\t\t  $lo[2] != $io[2]);\n\t\t\t}\n\t\t}\n\telsif ($_[$i] eq 'LOCAL' && &check_ip6address($_[1])) {\n\t\t# Compare with local IPv6 network, which is always first 4 words\n\t\tlocal @lo = split(/:/, $_[1]);\n\t\tfor(my $i=0; $i<4; $i++) {\n\t\t\t$mismatch = 1 if ($lo[$i] ne $io[$i]);\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^[0-9\\.]+$/) {\n\t\t# Compare with a full or partial IPv4 address\n\t\t@mo = split(/\\./, $_[$i]);\n\t\twhile(@mo && !$mo[$#mo]) { pop(@mo); }\n\t\tfor($j=0; $j<@mo; $j++) {\n\t\t\tif ($mo[$j] != $io[$j]) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^[a-f0-9:]+$/) {\n\t\t# Compare with a full IPv6 address\n\t\tif (&canonicalize_ip6($_[$i]) ne canonicalize_ip6($_[0])) {\n\t\t\t$mismatch = 1;\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^([a-f0-9:]+)\\/(\\d+)$/) {\n\t\t# Compare with an IPv6 network\n\t\tlocal $v6size = $2;\n\t\tlocal $v6addr = &canonicalize_ip6($1);\n\t\tlocal $bytes = $v6size / 8;\n\t\t@mo = &expand_ipv6_bytes($v6addr);\n\t\tlocal @io6 = &expand_ipv6_bytes(&canonicalize_ip6($_[0]));\n\t\tfor($j=0; $j<$bytes; $j++) {\n\t\t\tif ($mo[$j] ne $io6[$j]) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] !~ /^[0-9\\.]+$/) {\n\t\t# Compare with hostname\n\t\t$mismatch = 1 if ($_[0] ne &to_ipaddress($_[$i]));\n\t\t}\n\treturn 1 if (!$mismatch);\n\t}\nreturn 0;\n}\n\n# users_match(&uinfo, user, ...)\n# Returns 1 if a user is in a list of users and groups\nsub users_match\n{\nlocal $uinfo = shift(@_);\nlocal $u;\nlocal @ginfo = getgrgid($uinfo->[3]);\nforeach $u (@_) {\n\tif ($u =~ /^\\@(\\S+)$/) {\n\t\treturn 1 if (&is_group_member($uinfo, $1));\n\t\t}\n\telsif ($u =~ /^(\\d*)-(\\d*)$/ && ($1 || $2)) {\n\t\treturn (!$1 || $uinfo[2] >= $1) &&\n\t\t       (!$2 || $uinfo[2] <= $2);\n\t\t}\n\telse {\n\t\treturn 1 if ($u eq $uinfo->[0]);\n\t\t}\n\t}\nreturn 0;\n}\n\n# restart_miniserv()\n# Called when a SIGHUP is received to restart the web server. This is done\n# by exec()ing perl with the same command line as was originally used\nsub restart_miniserv\n{\n&log_error(\"Restarting\");\nclose(SOCK);\n&close_all_sockets();\n&close_all_pipes();\ndbmclose(%sessiondb);\nkill('KILL', $logclearer) if ($logclearer);\nkill('KILL', $extauth) if ($extauth);\nexec($perl_path, $miniserv_path, @miniserv_argv);\ndie \"Failed to restart miniserv with $perl_path $miniserv_path\";\n}\n\nsub trigger_restart\n{\n$need_restart = 1;\n}\n\nsub trigger_reload\n{\n$need_reload = 1;\n}\n\n# to_ip46address(address, ...)\n# Convert hostnames to v4 and v6 addresses, if possible\nsub to_ip46address\n{\nlocal @rv;\nforeach my $i (@_) {\n\tif (&check_ipaddress($i) || &check_ip6address($i)) {\n\t\tpush(@rv, $i);\n\t\t}\n\telse {\n\t\tmy $addr = &to_ipaddress($i);\n\t\t$addr ||= &to_ip6address($i);\n\t\tpush(@rv, $addr) if ($addr);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# to_ipaddress(address, ...)\nsub to_ipaddress\n{\nlocal (@rv, $i);\nforeach $i (@_) {\n\tif ($i =~ /(\\S+)\\/(\\S+)/ || $i =~ /^\\*\\S+$/ ||\n\t    $i eq 'LOCAL' || $i =~ /^[0-9\\.]+$/ || $i =~ /^[a-f0-9:]+$/) {\n\t\t# A pattern or IP, not a hostname, so don't change\n\t\tpush(@rv, $i);\n\t\t}\n\telse {\n\t\t# Lookup IP address\n\t\tpush(@rv, join('.', unpack(\"CCCC\", inet_aton($i))));\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n# to_ip6address(address, ...)\nsub to_ip6address\n{\nlocal (@rv, $i);\nforeach $i (@_) {\n\tif ($i =~ /(\\S+)\\/(\\S+)/ || $i =~ /^\\*\\S+$/ ||\n\t    $i eq 'LOCAL' || $i =~ /^[0-9\\.]+$/ || $i =~ /^[a-f0-9:]+$/) {\n\t\t# A pattern, not a hostname, so don't change\n\t\tpush(@rv, $i);\n\t\t}\n\telsif ($config{'ipv6'}) {\n\t\t# Lookup IPv6 address\n\t\tlocal ($inaddr, $addr);\n\t\teval {\n\t\t\t(undef, undef, undef, $inaddr) =\n\t\t\t    getaddrinfo($i, undef, AF_INET6(), SOCK_STREAM);\n\t\t\t};\n\t\tif ($inaddr) {\n\t\t\tpush(@rv, undef);\n\t\t\t}\n\t\telse {\n\t\t\t(undef, $addr) = unpack_sockaddr_in6($inaddr);\n\t\t\tpush(@rv, inet_ntop(AF_INET6(), $addr));\n\t\t\t}\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n# to_hostname(ipv4|ipv6-address)\n# Reverse-resolves an IPv4 or 6 address to a hostname\nsub to_hostname\n{\nlocal ($addr) = @_;\nif (&check_ip6address($_[0])) {\n\treturn gethostbyaddr(inet_pton(AF_INET6(), $addr),\n\t\t\t     AF_INET6());\n\t}\nelse {\n\treturn gethostbyaddr(inet_aton($addr), AF_INET);\n\t}\n}\n\n# read_line(no-wait, no-limit)\n# Reads one line from SOCK or SSL\nsub read_line\n{\nlocal ($nowait, $nolimit) = @_;\nlocal($idx, $more, $rv);\nwhile(($idx = index($main::read_buffer, \"\\n\")) < 0) {\n\tif (length($main::read_buffer) > 100000 && !$nolimit) {\n\t\t&http_error(414, \"Request too long\",\n\t\t    \"Received excessive line <pre>\".&html_strip($main::read_buffer).\"</pre>\");\n\t\t}\n\n\t# need to read more..\n\t&wait_for_data_error() if (!$nowait);\n\tif ($use_ssl) {\n\t\t$more = Net::SSLeay::read($ssl_con);\n\t\t}\n\telse {\n\t\tmy $bufsize = $config{'bufsize'} || 32768;\n                local $ok = sysread(SOCK, $more, $bufsize);\n\t\t$more = undef if ($ok <= 0);\n\t\t}\n\tif ($more eq '') {\n\t\t# end of the data\n\t\t$rv = $main::read_buffer;\n\t\tundef($main::read_buffer);\n\t\treturn $rv;\n\t\t}\n\t$main::read_buffer .= $more;\n\t}\n$rv = substr($main::read_buffer, 0, $idx+1);\n$main::read_buffer = substr($main::read_buffer, $idx+1);\nreturn $rv;\n}\n\n# read_data(length)\n# Reads up to some amount of data from SOCK or the SSL connection\nsub read_data\n{\nlocal ($rv);\nif (length($main::read_buffer)) {\n\tif (length($main::read_buffer) > $_[0]) {\n\t\t# Return the first part of the buffer\n\t\t$rv = substr($main::read_buffer, 0, $_[0]);\n\t\t$main::read_buffer = substr($main::read_buffer, $_[0]);\n\t\treturn $rv;\n\t\t}\n\telse {\n\t\t# Return the whole buffer\n\t\t$rv = $main::read_buffer;\n\t\tundef($main::read_buffer);\n\t\treturn $rv;\n\t\t}\n\t}\nelsif ($use_ssl) {\n\t# Call SSL read function\n\treturn Net::SSLeay::read($ssl_con, $_[0]);\n\t}\nelse {\n\t# Just do a normal read\n\tlocal $buf;\n\tsysread(SOCK, $buf, $_[0]) || return undef;\n\treturn $buf;\n\t}\n}\n\n# wait_for_data(secs)\n# Waits at most the given amount of time for some data on SOCK, returning\n# 0 if not found, 1 if some arrived.\nsub wait_for_data\n{\nlocal $rmask;\nvec($rmask, fileno(SOCK), 1) = 1;\nlocal $got = select($rmask, undef, undef, $_[0]);\nreturn $got == 0 ? 0 : 1;\n}\n\n# wait_for_data_error()\n# Waits 60 seconds for data on SOCK, and fails if none arrives\nsub wait_for_data_error\n{\nlocal $got = &wait_for_data(60);\nif (!$got) {\n\t&http_error(400, \"Timeout\",\n\t\t    \"Waited more than 60 seconds for request data\");\n\t}\n}\n\n# write_data(data, ...)\n# Writes a string to SOCK or the SSL connection\nsub write_data\n{\nlocal $str = join(\"\", @_);\nif ($use_ssl) {\n\tNet::SSLeay::write($ssl_con, $str);\n\t}\nelse {\n\teval { syswrite(SOCK, $str, length($str)); };\n\tif ($@ =~ /wide\\s+character/i) {\n\t\teval { utf8::encode($str);\n\t\t       syswrite(SOCK, $str, length($str)); };\n\t\t}\n\tif ($@) {\n\t\t# Somehow a string come through that contains invalid chars\n\t\tprint STDERR $@,\"\\n\";\n\t\tfor(my $i=0; my @stack = caller($i); $i++) {\n\t\t\tprint STDERR join(\" \", @stack),\"\\n\";\n\t\t\t}\n\t\t}\n\t}\n$write_data_count += length($str);\n}\n\n# reset_byte_count()\nsub reset_byte_count { $write_data_count = 0; }\n\n# byte_count()\nsub byte_count { return $write_data_count; }\n\n# log_request(hostname, user, request, code, bytes)\n# Write an HTTP request to the log file\nsub log_request\n{\nlocal ($host, $user, $request, $code, $bytes) = @_;\nlocal $headers;\nmy $request_nolog = $request;\n\n# Process full request string like `POST /index.cgi?param=1 HTTP/1.1` as well\nif ($request =~ /^(POST|GET)\\s+/) {\n\t$request_nolog =~ s/(.*?)(\\/.*?)\\s+(.*)/$2/g;\n\t}\nif ($config{'nolog'}) {\n\tforeach my $nolog (split(/\\s+/, $config{'nolog'})) {\n\t\treturn if ($request_nolog =~ /^$nolog$/);\n\t\t}\n\t}\nif ($config{'log'}) {\n\tlocal $ident = \"-\";\n\t$user ||= \"-\";\n\tlocal $dstr = &make_datestr();\n\tif (fileno(MINISERVLOG)) {\n\t\tseek(MINISERVLOG, 0, 2);\n\t\t}\n\telse {\n\t\topen(MINISERVLOG, \">>$config{'logfile'}\");\n\t\tchmod(0600, $config{'logfile'});\n\t\t}\n\tif (defined($config{'logheaders'})) {\n\t\tforeach $h (split(/\\s+/, $config{'logheaders'})) {\n\t\t\t$headers .= \" $h=\\\"$header{$h}\\\"\";\n\t\t\t}\n\t\t}\n\telsif ($config{'logclf'}) {\n\t\t$headers = \" \\\"$header{'referer'}\\\" \\\"$header{'user-agent'}\\\"\";\n\t\t}\n\telse {\n\t\t$headers = \"\";\n\t\t}\n\tprint MINISERVLOG \"$host $ident $user [$dstr] \\\"$request\\\" \",\n\t\t\t  \"$code $bytes$headers\\n\";\n\tclose(MINISERVLOG);\n\t}\n}\n\n# make_datestr()\nsub make_datestr\n{\nlocal @tm = localtime(time());\nreturn sprintf \"%2.2d/%s/%4.4d:%2.2d:%2.2d:%2.2d %s\",\n\t\t$tm[3], $month[$tm[4]], $tm[5]+1900,\n\t        $tm[2], $tm[1], $tm[0], $timezone;\n}\n\n# log_error(message)\nsub log_error\n{\nseek(STDERR, 0, 2);\nprint STDERR \"[\",&make_datestr(),\"] \",\n\t$acpthost ? ( \"[\",$acpthost,\"] \" ) : ( ),\n\t$page ? ( $page,\" : \" ) : ( ),\n\t@_,\"\\n\";\n}\n\n# read_errors(handle)\n# Read and return all input from some filehandle\nsub read_errors\n{\nlocal($fh, $_, $rv);\n$fh = $_[0];\nwhile(<$fh>) { $rv .= $_; }\nreturn $rv;\n}\n\nsub write_keep_alive\n{\nlocal $mode;\nif ($config{'nokeepalive'}) {\n\t# Keep alives have been disabled in config\n\t$mode = 0;\n\t}\nelsif (@childpids > $config{'maxconns'}*.8) {\n\t# Disable because nearing process limit\n\t$mode = 0;\n\t}\nelsif (@_) {\n\t# Keep alive specified by caller\n\t$mode = $_[0];\n\t}\nelse {\n\t# Keep alive determined by browser\n\t$mode = $header{'connection'} =~ /keep-alive/i;\n\t}\n&write_data(\"Connection: \".($mode ? \"Keep-Alive\" : \"close\").\"\\r\\n\");\nreturn $mode;\n}\n\nsub term_handler\n{\nkill('TERM', @childpids) if (@childpids);\nkill('KILL', $logclearer) if ($logclearer);\nkill('KILL', $extauth) if ($extauth);\nexit(1);\n}\n\nsub http_date\n{\nlocal @tm = gmtime($_[0]);\nreturn sprintf \"%s, %d %s %d %2.2d:%2.2d:%2.2d GMT\",\n\t\t$weekday[$tm[6]], $tm[3], $month[$tm[4]], $tm[5]+1900,\n\t\t$tm[2], $tm[1], $tm[0];\n}\n\nsub TIEHANDLE\n{\nmy $i; bless \\$i, shift;\n}\n \nsub WRITE\n{\n$r = shift;\nmy($buf,$len,$offset) = @_;\n&write_to_sock(substr($buf, $offset, $len));\n$miniserv::page_capture_out .= substr($buf, $offset, $len)\n\tif ($miniserv::page_capture);\n}\n \nsub PRINT\n{\n$r = shift;\n$$r++;\nmy $buf = join(defined($,) ? $, : \"\", @_);\n$buf .= $\\ if defined($\\);\n&write_to_sock($buf);\n$miniserv::page_capture_out .= $buf\n\tif ($miniserv::page_capture);\n}\n \nsub PRINTF\n{\nshift;\nmy $fmt = shift;\nmy $buf = sprintf $fmt, @_;\n&write_to_sock($buf);\n$miniserv::page_capture_out .= $buf\n\tif ($miniserv::page_capture);\n}\n \n# Send back already read data while we have it, then read from SOCK\nsub READ\n{\nmy $r = shift;\nmy $bufref = \\$_[0];\nmy $len = $_[1];\nmy $offset = $_[2];\nif ($postpos < length($postinput)) {\n\t# Reading from already fetched array\n\tmy $left = length($postinput) - $postpos;\n\tmy $canread = $len > $left ? $left : $len;\n\tsubstr($$bufref, $offset, $canread) =\n\t\tsubstr($postinput, $postpos, $canread);\n\t$postpos += $canread;\n\treturn $canread;\n\t}\nelse {\n\t# Read from network socket\n\tlocal $data = &read_data($len);\n\tif ($data eq '' && $len) {\n\t\t# End of socket\n\t\tshutdown(SOCK, 0);\n\t\t}\n\tsubstr($$bufref, $offset, length($data)) = $data;\n\treturn length($data);\n\t}\n}\n\nsub OPEN\n{\n#print STDERR \"open() called - should never happen!\\n\";\n}\n \n# Read a line of input\nsub READLINE\n{\nmy $r = shift;\nif ($postpos < length($postinput) &&\n    ($idx = index($postinput, \"\\n\", $postpos)) >= 0) {\n\t# A line exists in the memory buffer .. use it\n\tmy $line = substr($postinput, $postpos, $idx-$postpos+1);\n\t$postpos = $idx+1;\n\treturn $line;\n\t}\nelse {\n\t# Need to read from the socket\n\tmy $line;\n\tif ($postpos < length($postinput)) {\n\t\t# Start with in-memory data\n\t\t$line = substr($postinput, $postpos);\n\t\t$postpos = length($postinput);\n\t\t}\n\tmy $nl = &read_line(0, 1);\n\tif ($nl eq '') {\n\t\t# End of socket\n\t\tshutdown(SOCK, 0);\n\t\t}\n\t$line .= $nl if (defined($nl));\n\treturn $line;\n\t}\n}\n \n# Read one character of input\nsub GETC\n{\nmy $r = shift;\nmy $buf;\nmy $got = READ($r, \\$buf, 1, 0);\nreturn $got > 0 ? $buf : undef;\n}\n\nsub FILENO\n{\nreturn fileno(SOCK);\n}\n \nsub CLOSE { }\n \nsub DESTROY { }\n\n# write_to_sock(data, ...)\nsub write_to_sock\n{\nlocal $d;\nforeach $d (@_) {\n\tif ($doneheaders || $miniserv::nph_script) {\n\t\t&write_data($d);\n\t\t}\n\telse {\n\t\t$headers .= $d;\n\t\twhile(!$doneheaders && $headers =~ s/^([^\\r\\n]*)(\\r)?\\n//) {\n\t\t\tif ($1 =~ /^(\\S+):\\s+(.*)$/) {\n\t\t\t\t$cgiheader{lc($1)} = $2;\n\t\t\t\tpush(@cgiheader, [ $1, $2 ]);\n\t\t\t\t}\n\t\t\telsif ($1 !~ /\\S/) {\n\t\t\t\t$doneheaders++;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&http_error(500, \"Bad Header\");\n\t\t\t\t}\n\t\t\t}\n\t\tif ($doneheaders) {\n\t\t\tif ($cgiheader{\"location\"}) {\n\t\t\t\t&write_data(\n\t\t\t\t\t\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\telsif ($cgiheader{\"content-type\"} eq \"\") {\n\t\t\t\t&http_error(500, \"Missing Content-Type Header\");\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&write_data(\"HTTP/1.0 $ok_code $ok_message\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\tforeach $h (@cgiheader) {\n\t\t\t\t&write_data(\"$h->[0]: $h->[1]\\r\\n\");\n\t\t\t\t}\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\t&reset_byte_count();\n\t\t\t&write_data($headers);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsub verify_client\n{\nlocal $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($_[1]);\nif ($cert) {\n\tlocal $errnum = Net::SSLeay::X509_STORE_CTX_get_error($_[1]);\n\t$verified_client = 1 if (!$errnum);\n\t}\nreturn 1;\n}\n\nsub END\n{\nif ($doing_cgi_eval && $$ == $main_process_id) {\n\t# A CGI program called exit! This is a horrible hack to \n\t# finish up before really exiting\n\tshutdown(SOCK, 1);\n\tclose(SOCK);\n\tclose($PASSINw); close($PASSOUTw);\n\t&log_request($loghost, $authuser, $reqline,\n\t\t     $cgiheader{\"location\"} ? \"302\" : $ok_code, &byte_count());\n\t}\n}\n\n# urlize\n# Convert a string to a form ok for putting in a URL\nsub urlize {\n  local($tmp, $tmp2, $c);\n  $tmp = $_[0];\n  $tmp2 = \"\";\n  while(($c = chop($tmp)) ne \"\") {\n\tif ($c !~ /[A-z0-9]/) {\n\t\t$c = sprintf(\"%%%2.2X\", ord($c));\n\t\t}\n\t$tmp2 = $c . $tmp2;\n\t}\n  return $tmp2;\n}\n\n# validate_user(username, password, host, remote-ip, webmin-port)\n# Checks if some username and password are valid. Returns the modified username,\n# the expired / temp pass flag, the non-existence flag, and the underlying\n# Webmin username.\nsub validate_user\n{\nlocal ($user, $pass, $host, $actpip, $port) = @_;\nreturn ( ) if (!$user);\nprint DEBUG \"validate_user: user=$user pass=$pass host=$host\\n\";\nlocal ($canuser, $canmode, $notexist, $webminuser, $sudo) =\n\t&can_user_login($user, undef, $host);\nprint DEBUG \"validate_user: canuser=$canuser canmode=$canmode notexist=$notexist webminuser=$webminuser sudo=$sudo\\n\";\nif ($notexist) {\n\t# User doesn't even exist, so go no further\n\treturn ( undef, 0, 1, $webminuser );\n\t}\nelsif ($canmode == 0) {\n\t# User does exist but cannot login\n\treturn ( $canuser, 0, 0, $webminuser );\n\t}\nelsif ($canmode == 1) {\n\t# Attempt Webmin authentication\n\tmy $uinfo = &get_user_details($webminuser);\n\tif ($uinfo &&\n\t    &password_crypt($pass, $uinfo->{'pass'}) eq $uinfo->{'pass'}) {\n\t\t# Password is valid .. but check for expiry\n\t\tlocal $lc = $uinfo->{'lastchanges'};\n\t\tprint DEBUG \"validate_user: Password is valid lc=$lc pass_maxdays=$config{'pass_maxdays'}\\n\";\n\t\tif ($config{'pass_maxdays'} && $lc && !$uinfo->{'nochange'}) {\n\t\t\tlocal $daysold = (time() - $lc)/(24*60*60);\n\t\t\tprint DEBUG \"maxdays=$config{'pass_maxdays'} daysold=$daysold temppass=$uinfo->{'temppass'}\\n\";\n\t\t\tif ($config{'pass_lockdays'} &&\n\t\t\t    $daysold > $config{'pass_lockdays'}) {\n\t\t\t\t# So old that the account is locked\n\t\t\t\treturn ( undef, 0, 0, $webminuser );\n\t\t\t\t}\n\t\t\telsif ($daysold > $config{'pass_maxdays'}) {\n\t\t\t\t# Password has expired\n\t\t\t\treturn ( $user, 1, 0, $webminuser );\n\t\t\t\t}\n\t\t\t}\n\t\tif ($uinfo->{'temppass'}) {\n\t\t\t# Temporary password - force change now\n\t\t\treturn ( $user, 2, 0, $webminuser );\n\t\t\t}\n\t\treturn ( $user, 0, 0, $webminuser );\n\t\t}\n\telsif (!$uinfo) {\n\t\tprint DEBUG \"validate_user: User $webminuser not found\\n\";\n\t\treturn ( undef, 0, 0, $webminuser );\n\t\t}\n\telse {\n\t\tprint DEBUG \"validate_user: User $webminuser password mismatch $pass != $uinfo->{'pass'}\\n\";\n\t\treturn ( undef, 0, 0, $webminuser );\n\t\t}\n\t}\nelsif ($canmode == 2 || $canmode == 3) {\n\t# Attempt PAM or passwd file authentication\n\tlocal $val = &validate_unix_user($canuser, $pass, $acptip, $port);\n\tprint DEBUG \"validate_user: unix val=$val\\n\";\n\tif ($val && $sudo) {\n\t\t# Need to check if this Unix user can sudo\n\t\tif (!&check_sudo_permissions($canuser, $pass)) {\n\t\t\tprint DEBUG \"validate_user: sudo failed\\n\";\n\t\t\t$val = 0;\n\t\t\t}\n\t\telse {\n\t\t\tprint DEBUG \"validate_user: sudo passed\\n\";\n\t\t\t}\n\t\t}\n\treturn $val == 2 ? ( $canuser, 1, 0, $webminuser ) :\n\t       $val == 1 ? ( $canuser, 0, 0, $webminuser ) :\n\t\t\t   ( undef, 0, 0, $webminuser );\n\t}\nelsif ($canmode == 4) {\n\t# Attempt external authentication\n\treturn &validate_external_user($canuser, $pass) ?\n\t\t( $canuser, 0, 0, $webminuser ) :\n\t\t( undef, 0, 0, $webminuser );\n\t}\nelse {\n\t# Can't happen!\n\treturn ( );\n\t}\n}\n\n# validate_unix_user(user, password, remote-ip, local-port)\n# Returns 1 if a username and password are valid under unix, 0 if not,\n# or 2 if the account has expired.\n# Checks PAM if available, and falls back to reading the system password\n# file otherwise.\nsub validate_unix_user\n{\nif ($use_pam) {\n\t# Check with PAM\n\t$pam_username = $_[0];\n\t$pam_password = $_[1];\n\teval \"use Authen::PAM;\";\n\tlocal $pamh = new Authen::PAM($config{'pam'}, $pam_username,\n\t\t\t\t      \\&pam_conv_func);\n\tif (ref($pamh)) {\n\t\t$pamh->pam_set_item(PAM_RHOST(), $_[2]) if ($_[2]);\n\t\t$pamh->pam_set_item(PAM_TTY(), $_[3]) if ($_[3]);\n\t\tlocal $rcode = 0;\n\t\tlocal $pam_ret = $pamh->pam_authenticate();\n\t\tif ($pam_ret == PAM_SUCCESS()) {\n\t\t\t# Logged in OK .. make sure password hasn't expired\n\t\t\tlocal $acct_ret = $pamh->pam_acct_mgmt();\n\t\t\t$pam_ret = $acct_ret;\n\t\t\tif ($acct_ret == PAM_SUCCESS()) {\n\t\t\t\t$pamh->pam_open_session();\n\t\t\t\t$rcode = 1;\n\t\t\t\t}\n\t\t\telsif ($acct_ret == PAM_NEW_AUTHTOK_REQD() ||\n\t\t\t       $acct_ret == PAM_ACCT_EXPIRED()) {\n\t\t\t\t$rcode = 2;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprint STDERR \"Unknown pam_acct_mgmt return value : $acct_ret\\n\";\n\t\t\t\t$rcode = 0;\n\t\t\t\t}\n\t\t\t}\n\t\tif ($config{'pam_end'}) {\n\t\t\t$pamh->pam_end($pam_ret);\n\t\t\t}\n\t\treturn $rcode;\n\t\t}\n\t}\nelsif ($config{'pam_only'}) {\n\t# Pam is not available, but configuration forces it's use!\n\treturn 0;\n\t}\nelsif ($config{'passwd_file'}) {\n\t# Check in a password file\n\tlocal $rv = 0;\n\topen(FILE, $config{'passwd_file'});\n\tif ($config{'passwd_file'} eq '/etc/security/passwd') {\n\t\t# Assume in AIX format\n\t\twhile(<FILE>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/ && $1 eq $_[0]) {\n\t\t\t\t$_ = <FILE>;\n\t\t\t\tif (/^\\s*password\\s*=\\s*(\\S+)\\s*$/) {\n\t\t\t\t\t$rv = $1 eq &password_crypt($_[1], $1) ?\n\t\t\t\t\t\t1 : 0;\n\t\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Read the system password or shadow file\n\t\twhile(<FILE>) {\n\t\t\tlocal @l = split(/:/, $_, -1);\n\t\t\tlocal $u = $l[$config{'passwd_uindex'}];\n\t\t\tlocal $p = $l[$config{'passwd_pindex'}];\n\t\t\tif ($u eq $_[0]) {\n\t\t\t\t$rv = $p eq &password_crypt($_[1], $p) ? 1 : 0;\n\t\t\t\tif ($config{'passwd_cindex'} ne '' && $rv) {\n\t\t\t\t\t# Password may have expired!\n\t\t\t\t\tlocal $c = $l[$config{'passwd_cindex'}];\n\t\t\t\t\tlocal $m = $l[$config{'passwd_mindex'}];\n\t\t\t\t\tlocal $day = time()/(24*60*60);\n\t\t\t\t\tif ($c =~ /^\\d+/ && $m =~ /^\\d+/ &&\n\t\t\t\t\t    $day - $c > $m) {\n\t\t\t\t\t\t# Yep, it has ..\n\t\t\t\t\t\t$rv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ($p eq \"\" && $config{'passwd_blank'}) {\n\t\t\t\t\t# Force password change\n\t\t\t\t\t$rv = 2;\n\t\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(FILE);\n\treturn $rv if ($rv);\n\t}\n\n# Fallback option - check password returned by getpw*\nlocal @uinfo = getpwnam($_[0]);\nif ($uinfo[1] ne '' && &password_crypt($_[1], $uinfo[1]) eq $uinfo[1]) {\n\treturn 1;\n\t}\n\nreturn 0;\t# Totally failed\n}\n\n# validate_external_user(user, pass)\n# Validate a user by passing the username and password to an external\n# squid-style authentication program\nsub validate_external_user\n{\nreturn 0 if (!$config{'extauth'});\nflock(EXTAUTH, 2);\nlocal $str = \"$_[0] $_[1]\\n\";\nsyswrite(EXTAUTH, $str, length($str));\nlocal $resp = <EXTAUTH>;\nflock(EXTAUTH, 8);\nreturn $resp =~ /^OK/i ? 1 : 0;\n}\n\n# can_user_login(username, no-append, host)\n# Checks if a user can login or not.\n# First return value is the username.\n# Second is 0 if cannot login, 1 if using Webmin pass, 2 if PAM, 3 if password\n# file, 4 if external.\n# Third is 1 if the user does not exist at all, 0 if he does.\n# Fourth is the Webmin username whose permissions apply, based on unixauth.\n# Fifth is a flag indicating if a sudo check is needed.\nsub can_user_login\n{\nlocal $uinfo = &get_user_details($_[0]);\nif (!$uinfo) {\n\t# See if this user exists in Unix and can be validated by the same\n\t# method as the unixauth webmin user\n\tlocal $realuser = $unixauth{$_[0]};\n\tlocal @uinfo;\n\tlocal $sudo = 0;\n\tlocal $pamany = 0;\n\teval { @uinfo = getpwnam($_[0]); };\t# may fail on windows\n\tif (!$realuser && @uinfo) {\n\t\t# No unixauth entry for the username .. try his groups \n\t\tforeach my $ua (keys %unixauth) {\n\t\t\tif ($ua =~ /^\\@(.*)$/) {\n\t\t\t\tif (&is_group_member(\\@uinfo, $1)) {\n\t\t\t\t\t$realuser = $unixauth{$ua};\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (!$realuser && @uinfo) {\n\t\t# Fall back to unix auth for all Unix users\n\t\t$realuser = $unixauth{\"*\"};\n\t\t}\n\tif (!$realuser && $use_sudo && @uinfo) {\n\t\t# Allow login effectively as root, if sudo permits it\n\t\t$sudo = 1;\n\t\t$realuser = \"root\";\n\t\t}\n\tif (!$realuser && !@uinfo && $config{'pamany'}) {\n\t\t# If the user completely doesn't exist, we can still allow\n\t\t# him to authenticate via PAM\n\t\t$realuser = $config{'pamany'};\n\t\t$pamany = 1;\n\t\t}\n\tif (!$realuser) {\n\t\t# For Usermin, always fall back to unix auth for any user,\n\t\t# so that later checks with domain added / removed are done.\n\t\t$realuser = $unixauth{\"*\"};\n\t\t}\n\treturn (undef, 0, 1, undef) if (!$realuser);\n\tlocal $uinfo = &get_user_details($realuser);\n\treturn (undef, 0, 1, undef) if (!$uinfo);\n\tlocal $up = $uinfo->{'pass'};\n\n\t# Work out possible domain names from the hostname\n\tlocal @doms = ( $_[2] );\n\tif ($_[2] =~ /^([^\\.]+)\\.(\\S+)$/) {\n\t\tpush(@doms, $2);\n\t\t}\n\n\tif ($config{'user_mapping'} && !%user_mapping) {\n\t\t# Read the user mapping file\n\t\t%user_mapping = ();\n\t\topen(MAPPING, $config{'user_mapping'});\n\t\twhile(<MAPPING>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\ts/#.*$//;\n\t\t\tif (/^(\\S+)\\s+(\\S+)/) {\n\t\t\t\tif ($config{'user_mapping_reverse'}) {\n\t\t\t\t\t$user_mapping{$1} = $2;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$user_mapping{$2} = $1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(MAPPING);\n\t\t}\n\n\t# Check the user mapping file to see if there is an entry for the\n\t# user login in which specifies a new effective user\n\tlocal $um;\n\tforeach my $d (@doms) {\n\t\t$um ||= $user_mapping{\"$_[0]\\@$d\"};\n\t\t}\n\t$um ||= $user_mapping{$_[0]};\n\tif (defined($um) && ($_[1]&4) == 0) {\n\t\t# A mapping exists - use it!\n\t\treturn &can_user_login($um, $_[1]+4, $_[2]);\n\t\t}\n\n\t# Check if a user with the entered login and the domains appended\n\t# or prepended exists, and if so take it to be the effective user\n\tif (!@uinfo && $config{'domainuser'}) {\n\t\t# Try again with name.domain and name.firstpart\n\t\tlocal @firsts = map { /^([^\\.]+)/; $1 } @doms;\n\t\tif (($_[1]&1) == 0) {\n\t\t\tlocal ($a, $p);\n\t\t\tforeach $a (@firsts, @doms) {\n\t\t\t\tforeach $p (\"$_[0].${a}\", \"$_[0]-${a}\",\n\t\t\t\t\t    \"${a}.$_[0]\", \"${a}-$_[0]\",\n\t\t\t\t\t    \"$_[0]_${a}\", \"${a}_$_[0]\") {\n\t\t\t\t\tlocal @vu = &can_user_login(\n\t\t\t\t\t\t\t$p, $_[1]+1, $_[2]);\n\t\t\t\t\treturn @vu if ($vu[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check if the user entered a domain at the end of his username when\n\t# he really shouldn't have, and if so try without it\n\tif (!@uinfo && $config{'domainstrip'} &&\n\t    $_[0] =~ /^(\\S+)\\@(\\S+)$/ && ($_[1]&2) == 0) {\n\t\tlocal ($stripped, $dom) = ($1, $2);\n\t\tlocal @vu = &can_user_login($stripped, $_[1] + 2, $_[2]);\n\t\treturn @vu if ($vu[1]);\n\t\tlocal @vu = &can_user_login($stripped, $_[1] + 2, $dom);\n\t\treturn @vu if ($vu[1]);\n\t\t}\n\n\treturn ( undef, 0, 1, undef ) if (!@uinfo && !$pamany);\n\n\tif (@uinfo) {\n\t\tif (scalar(@allowusers)) {\n\t\t\t# Only allow people on the allow list\n\t\t\treturn ( undef, 0, 0, undef )\n\t\t\t\tif (!&users_match(\\@uinfo, @allowusers));\n\t\t\t}\n\t\telsif (scalar(@denyusers)) {\n\t\t\t# Disallow people on the deny list\n\t\t\treturn ( undef, 0, 0, undef )\n\t\t\t\tif (&users_match(\\@uinfo, @denyusers));\n\t\t\t}\n\t\tif ($config{'shells_deny'}) {\n\t\t\tlocal $found = 0;\n\t\t\topen(SHELLS, $config{'shells_deny'});\n\t\t\twhile(<SHELLS>) {\n\t\t\t\ts/\\r|\\n//g;\n\t\t\t\ts/#.*$//;\n\t\t\t\t$found++ if ($_ eq $uinfo[8]);\n\t\t\t\t}\n\t\t\tclose(SHELLS);\n\t\t\treturn ( undef, 0, 0, undef ) if (!$found);\n\t\t\t}\n\t\t}\n\n\tif ($up eq 'x') {\n\t\t# PAM or passwd file authentication\n\t\tprint DEBUG \"can_user_login: Validate with PAM\\n\";\n\t\treturn ( $_[0], $use_pam ? 2 : 3, 0, $realuser, $sudo );\n\t\t}\n\telsif ($up eq 'e') {\n\t\t# External authentication\n\t\tprint DEBUG \"can_user_login: Validate externally\\n\";\n\t\treturn ( $_[0], 4, 0, $realuser, $sudo );\n\t\t}\n\telse {\n\t\t# Fixed Webmin password\n\t\tprint DEBUG \"can_user_login: Validate by Webmin\\n\";\n\t\treturn ( $_[0], 1, 0, $realuser, $sudo );\n\t\t}\n\t}\nelsif ($uinfo->{'pass'} eq 'x') {\n\t# Webmin user authenticated via PAM or password file\n\treturn ( $_[0], $use_pam ? 2 : 3, 0, $_[0] );\n\t}\nelsif ($uinfo->{'pass'} eq 'e') {\n\t# Webmin user authenticated externally\n\treturn ( $_[0], 4, 0, $_[0] );\n\t}\nelse {\n\t# Normal Webmin user\n\treturn ( $_[0], 1, 0, $_[0] );\n\t}\n}\n\n# the PAM conversation function for interactive logins\nsub pam_conv_func\n{\n$pam_conv_func_called++;\nmy @res;\nwhile ( @_ ) {\n\tmy $code = shift;\n\tmy $msg = shift;\n\tmy $ans = \"\";\n\n\t$ans = $pam_username if ($code == PAM_PROMPT_ECHO_ON() );\n\t$ans = $pam_password if ($code == PAM_PROMPT_ECHO_OFF() );\n\n\tpush @res, PAM_SUCCESS();\n\tpush @res, $ans;\n\t}\npush @res, PAM_SUCCESS();\nreturn @res;\n}\n\nsub urandom_timeout\n{\nclose(RANDOM);\n}\n\n# get_socket_ip(handle, ipv6-flag)\n# Returns the local IP address of some connection, as both a string and in\n# binary format\nsub get_socket_ip\n{\nlocal ($fh, $ipv6) = @_;\nlocal $sn = getsockname($fh);\nreturn undef if (!$sn);\nreturn &get_address_ip($sn, $ipv6);\n}\n\n# get_address_ip(address, ipv6-flag)\n# Given a sockaddr object in binary format, return the binary address, text\n# address and port number\nsub get_address_ip\n{\nlocal ($sn, $ipv6) = @_;\nif ($ipv6) {\n\tlocal ($p, $b) = unpack_sockaddr_in6($sn);\n\treturn ($b, inet_ntop(AF_INET6(), $b), $p);\n\t}\nelse {\n\tlocal ($p, $b) = unpack_sockaddr_in($sn);\n\treturn ($b, inet_ntoa($b), $p);\n\t}\n}\n\n# get_socket_name(handle, ipv6-flag)\n# Returns the local hostname or IP address of some connection\nsub get_socket_name\n{\nlocal ($fh, $ipv6) = @_;\nreturn $config{'host'} if ($config{'host'});\nlocal ($mybin, $myaddr) = &get_socket_ip($fh, $ipv6);\nif (!$get_socket_name_cache{$myaddr}) {\n\tlocal $myname;\n\tif (!$config{'no_resolv_myname'}) {\n\t\t$myname = gethostbyaddr($mybin,\n\t\t\t\t\t$ipv6 ? AF_INET6() : AF_INET);\n\t\t}\n\t$myname ||= $myaddr;\n\t$get_socket_name_cache{$myaddr} = $myname;\n\t}\nreturn $get_socket_name_cache{$myaddr};\n}\n\n# run_login_script(username, sid, remoteip, localip)\nsub run_login_script\n{\nif ($config{'login_script'}) {\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'login_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# run_logout_script(username, sid, remoteip, localip)\nsub run_logout_script\n{\nif ($config{'logout_script'}) {\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'logout_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# run_failed_script(username, reason-code, remoteip, localip)\nsub run_failed_script\n{\nif ($config{'failed_script'}) {\n\t$_[0] =~ s/\\r|\\n/ /g;\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'failed_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# close_all_sockets()\n# Closes all the main listening sockets\nsub close_all_sockets\n{\nlocal $s;\nforeach $s (@socketfhs) {\n\tclose($s);\n\t}\n}\n\n# close_all_pipes()\n# Close all pipes for talking to sub-processes\nsub close_all_pipes\n{\nlocal $p;\nforeach $p (@passin) { close($p); }\nforeach $p (@passout) { close($p); }\nforeach $p (values %conversations) {\n\tif ($p->{'PAMOUTr'}) {\n\t\tclose($p->{'PAMOUTr'});\n\t\tclose($p->{'PAMINw'});\n\t\t}\n\t}\n}\n\n# check_user_ip(user)\n# Returns 1 if some user is allowed to login from the accepting IP, 0 if not\nsub check_user_ip\n{\nlocal ($username) = @_;\nlocal $uinfo = &get_user_details($username);\nreturn 1 if (!$uinfo);\nif ($uinfo->{'deny'} &&\n    &ip_match($acptip, $localip, @{$uinfo->{'deny'}}) ||\n    $uinfo->{'allow'} &&\n    !&ip_match($acptip, $localip, @{$uinfo->{'allow'}})) {\n\treturn 0;\n\t}\nreturn 1;\n}\n\n# check_user_time(user)\n# Returns 1 if some user is allowed to login at the current date and time\nsub check_user_time\n{\nlocal ($username) = @_;\nlocal $uinfo = &get_user_details($username);\nreturn 1 if (!$uinfo || !$uinfo->{'allowdays'} && !$uinfo->{'allowhours'});\nlocal @tm = localtime(time());\nif ($uinfo->{'allowdays'}) {\n\t# Make sure day is allowed\n\treturn 0 if (&indexof($tm[6], @{$uinfo->{'allowdays'}}) < 0);\n\t}\nif ($uinfo->{'allowhours'}) {\n\t# Make sure time is allowed\n\tlocal $m = $tm[2]*60+$tm[1];\n\treturn 0 if ($m < $uinfo->{'allowhours'}->[0] ||\n\t\t     $m > $uinfo->{'allowhours'}->[1]);\n\t}\nreturn 1;\n}\n\n# generate_random_id(password, [force-urandom])\n# Returns a random session ID number\nsub generate_random_id\n{\nmy ($force_urandom) = @_;\nlocal $sid;\nif (!$bad_urandom) {\n\t# First try /dev/urandom, unless we have marked it as bad\n\t$SIG{ALRM} = \"miniserv::urandom_timeout\";\n\talarm(5);\n\tif (open(RANDOM, \"/dev/urandom\")) {\n\t\tmy $tmpsid;\n\t\tif (read(RANDOM, $tmpsid, 16) == 16) {\n\t\t\t$sid = lc(unpack('h*',$tmpsid));\n\t\t\tif ($sid !~ /^[0-9a-fA-F]{32}$/) {\n\t\t\t\t$sid = 'bad';\n\t\t\t\t}\n\t\t\t}\n\t\tclose(RANDOM);\n\t\t}\n\talarm(0);\n\t}\nif (!$sid && !$force_urandom) {\n\tmy $offset = int(rand(2048));\n\tmy @charset = ('0' ..'9', 'a' .. 'f');\n\t$sid = join('', map { $charset[rand(@charset)] } 1 .. 4096);\n\t$sid = substr($sid, $offset, 32);\n\t}\nreturn $sid;\n}\n\n# handle_login(username, ok, expired, not-exists, password, [no-test-cookie], [no-log])\n# Called from handle_session to either mark a user as logged in, or not\nsub handle_login\n{\nlocal ($vu, $ok, $expired, $nonexist, $pass, $notest, $nolog) = @_;\n$authuser = $vu if ($ok);\n\n# check if the test cookie is set\nif ($header{'cookie'} !~ /testing=1/ && $vu &&\n    !$config{'no_testing_cookie'} && !$notest) {\n\t&http_error(500, \"No cookies\",\n\t   \"Your browser does not support cookies, \".\n\t   \"which are required for this web server to \".\n\t   \"work in session authentication mode\");\n\t}\n\n# check with main process for delay\nif ($config{'passdelay'} && $vu) {\n\tprint DEBUG \"handle_login: requesting delay vu=$vu acptip=$acptip ok=$ok\\n\";\n\tprint $PASSINw \"delay $vu $acptip $ok $nolog\\n\";\n\t<$PASSOUTr> =~ /(\\d+) (\\d+)/;\n\t$blocked = $2;\n\tsleep($1);\n\tprint DEBUG \"handle_login: delay=$1 blocked=$2\\n\";\n\t}\n\nif ($ok && (!$expired ||\n\t    $config{'passwd_mode'} == 1)) {\n\t# Logged in OK! Tell the main process about\n\t# the new SID\n\tlocal $sid = &generate_random_id();\n\tprint DEBUG \"handle_login: sid=$sid\\n\";\n\tprint $PASSINw \"new $sid $authuser $acptip\\n\";\n\n\t# Run the post-login script, if any\n\t&run_login_script($authuser, $sid,\n\t\t\t  $loghost, $localip);\n\n\t# Check for a redirect URL for the user\n\tlocal $rurl = &login_redirect($authuser, $pass, $host);\n\tprint DEBUG \"handle_login: redirect URL rurl=$rurl\\n\";\n\tif ($rurl) {\n\t\t# Got one .. go to it\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t&write_data(\"Location: $rurl\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\t}\n\telse {\n\t\t# Set cookie and redirect to originally requested page\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\tlocal $sec = $ssl ? \"; secure\" : \"\";\n\t\tif (!$config{'no_httponly'}) {\n\t\t\t$sec .= \"; httpOnly\";\n\t\t\t}\n\t\tif ($in{'page'} !~ /^\\/[A-Za-z0-9\\/\\.\\-\\_:]+$/) {\n\t\t\t# Make redirect URL safe\n\t\t\t$in{'page'} = \"/\";\n\t\t\t}\n\t\tlocal $cpath = $config{'cookiepath'};\n\t\tif ($in{'save'}) {\n\t\t\t&write_data(\"Set-Cookie: $sidname=$sid; path=$cpath; \".\n\t\t\t    \"expires=\\\"Thu, 31-Dec-2037 00:00:00\\\"$sec\\r\\n\");\n\t\t\t}\n\t\telse {\n\t\t\t&write_data(\"Set-Cookie: $sidname=$sid; path=$cpath\".\n\t\t\t\t    \"$sec\\r\\n\");\n\t\t\t}\n\t\t&write_data(\"Location: $prot://$hostport$in{'page'}\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\tsyslog(\"info\", \"%s\", \"Successful login as $authuser from $loghost\") if ($use_syslog);\n\t\t&write_login_utmp($authuser, $acpthost);\n\t\t}\n\treturn 0;\n\t}\nelsif ($ok && $expired &&\n       ($config{'passwd_mode'} == 2 || $expired == 2)) {\n\t# Login was ok, but password has expired or was temporary. Need\n\t# to force display of password change form.\n\t&run_failed_script($authuser, 'expiredpass',\n\t\t\t   $loghost, $localip);\n\t$validated = 1;\n\t$authuser = undef;\n\t$querystring = \"&user=\".&urlize($vu).\n\t\t       \"&pam=\".$use_pam.\n\t\t       \"&expired=\".$expired;\n\t$method = \"GET\";\n\t$queryargs = \"\";\n\t$page = $config{'password_form'};\n\t$logged_code = 401;\n\t$miniserv_internal = 2;\n\tsyslog(\"crit\", \"%s\",\n\t\t\"Expired login as $vu \".\n\t\t\"from $loghost\") if ($use_syslog);\n\t}\nelse {\n\t# Login failed, or password has expired. The login form will be\n\t# displayed again by later code\n\t&run_failed_script($vu, $handle_login ? 'wronguser' :\n\t\t\t\t$expired ? 'expiredpass' : 'wrongpass',\n\t\t\t   $loghost, $localip);\n\t$failed_user = $vu;\n\t$failed_pass = $pass;\n\t$failed_save = $in{'save'};\n\t$failed_twofactor_attempt = $in{'failed_twofactor_attempt'} || 0;\n\t$failed_twofactor_attempt++;\n\t$request_uri = $in{'page'};\n\t$already_session_id = undef;\n\t$method = \"GET\";\n\t$authuser = $baseauthuser = undef;\n\t\n\t# If login page is simply reloaded, with `session_login.cgi` in URL,\n\t# without having any parameters sent (user set to empty), don't log \n\t# false positive attempt with `Invalid login as  from IP` to syslog\n\t$nolog = 1 if (!$vu);\n\n\t# Send to log if allowed\n\tsyslog(\"crit\", \"%s\",\n\t\t($nonexist ? \"Non-existent\" :\n\t\t $expired ? \"Expired\" : \"Invalid\").\n\t\t\" login as $vu from $loghost\")\n\t\tif ($use_syslog && !$nolog);\n\t}\nreturn undef;\n}\n\n# write_login_utmp(user, host)\n# Record the login by some user in utmp\nsub write_login_utmp\n{\nif ($write_utmp) {\n\t# Write utmp record for login\n\t%utmp = ( 'ut_host' => $_[1],\n\t\t  'ut_time' => time(),\n\t\t  'ut_user' => $_[0],\n\t\t  'ut_type' => 7,\t# user process\n\t\t  'ut_pid' => $miniserv_main_pid,\n\t\t  'ut_line' => $config{'pam'},\n\t\t  'ut_id' => '' );\n\tif (defined(&User::Utmp::putut)) {\n\t\tUser::Utmp::putut(\\%utmp);\n\t\t}\n\telse {\n\t\tUser::Utmp::pututline(\\%utmp);\n\t\t}\n\t}\n}\n\n# write_logout_utmp(user, host)\n# Record the logout by some user in utmp\nsub write_logout_utmp\n{\nif ($write_utmp) {\n\t# Write utmp record for logout\n\t%utmp = ( 'ut_host' => $_[1],\n\t\t  'ut_time' => time(),\n\t\t  'ut_user' => $_[0],\n\t\t  'ut_type' => 8,\t# dead process\n\t\t  'ut_pid' => $miniserv_main_pid,\n\t\t  'ut_line' => $config{'pam'},\n\t\t  'ut_id' => '' );\n\tif (defined(&User::Utmp::putut)) {\n\t\tUser::Utmp::putut(\\%utmp);\n\t\t}\n\telse {\n\t\tUser::Utmp::pututline(\\%utmp);\n\t\t}\n\t}\n}\n\n# pam_conversation_process(username, write-pipe, read-pipe)\n# This function is called inside a sub-process to communicate with PAM. It sends\n# questions down one pipe, and reads responses from another\nsub pam_conversation_process\n{\nlocal ($user, $writer, $reader) = @_;\n$miniserv::pam_conversation_process_writer = $writer;\n$miniserv::pam_conversation_process_reader = $reader;\neval \"use Authen::PAM;\";\nlocal $convh = new Authen::PAM(\n\t$config{'pam'}, $user, \\&miniserv::pam_conversation_process_func);\nlocal $pam_ret = $convh->pam_authenticate();\nif ($pam_ret == PAM_SUCCESS()) {\n\tlocal $acct_ret = $convh->pam_acct_mgmt();\n\tif ($acct_ret == PAM_SUCCESS()) {\n\t\t$convh->pam_open_session();\n\t\tprint $writer \"x2 $user 1 0 0\\n\";\n\t\t}\n\telsif ($acct_ret == PAM_NEW_AUTHTOK_REQD() ||\n\t       $acct_ret == PAM_ACCT_EXPIRED()) {\n\t\tprint $writer \"x2 $user 1 1 0\\n\";\n\t\t}\n\telse {\n\t\tprint $writer \"x0 Unknown PAM account status $acct_ret\\n\";\n\t\t}\n\t}\nelse {\n\tprint $writer \"x2 $user 0 0 0\\n\";\n\t}\nexit(0);\n}\n\n# pam_conversation_process_func(type, message, [type, message, ...])\n# A pipe that talks to both PAM and the master process\nsub pam_conversation_process_func\n{\nlocal @rv;\nselect($miniserv::pam_conversation_process_writer); $| = 1; select(STDOUT);\nwhile(@_) {\n\tlocal ($type, $msg) = (shift, shift);\n\t$msg =~ s/\\r|\\n//g;\n\tlocal $ok = (print $miniserv::pam_conversation_process_writer \"$type $msg\\n\");\n\tprint $miniserv::pam_conversation_process_writer \"\\n\";\n\tlocal $answer = <$miniserv::pam_conversation_process_reader>;\n\t$answer =~ s/\\r|\\n//g;\n\tpush(@rv, PAM_SUCCESS(), $answer);\n\t}\npush(@rv, PAM_SUCCESS());\nreturn @rv;\n}\n\n# allocate_pipes()\n# Returns 4 new pipe file handles\nsub allocate_pipes\n{\nlocal ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\nlocal $p;\nlocal %taken = ( (map { $_, 1 } @passin),\n\t         (map { $_->{'PASSINr'} } values %conversations) );\nfor($p=0; $taken{\"PASSINr$p\"}; $p++) { }\n$PASSINr = \"PASSINr$p\";\n$PASSINw = \"PASSINw$p\";\n$PASSOUTr = \"PASSOUTr$p\";\n$PASSOUTw = \"PASSOUTw$p\";\npipe($PASSINr, $PASSINw);\npipe($PASSOUTr, $PASSOUTw);\nselect($PASSINw); $| = 1;\nselect($PASSINr); $| = 1;\nselect($PASSOUTw); $| = 1;\nselect($PASSOUTw); $| = 1;\nselect(STDOUT);\nreturn ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\n}\n\n# recv_pam_question(&conv, fd)\n# Reads one PAM question from the sub-process, and sends it to the HTTP handler.\n# Returns 0 if the conversation is over, 1 if not.\nsub recv_pam_question\n{\nlocal ($conf, $fh) = @_;\nlocal $pr = $conf->{'PAMOUTr'};\nselect($pr); $| = 1; select(STDOUT);\nlocal $line = <$pr>;\n$line =~ s/\\r|\\n//g;\nif (!$line) {\n\t$line = <$pr>;\n\t$line =~ s/\\r|\\n//g;\n\t}\n$conf->{'last'} = time();\nif (!$line) {\n\t# Failed!\n\tprint $fh \"0 PAM conversation error\\n\";\n\treturn 0;\n\t}\nelse {\n\tlocal ($type, $msg) = split(/\\s+/, $line, 2);\n\tif ($type =~ /^x(\\d+)/) {\n\t\t# Pass this status code through\n\t\tprint $fh \"$1 $msg\\n\";\n\t\treturn $1 == 2 || $1 == 0 ? 0 : 1;\n\t\t}\n\telsif ($type == PAM_PROMPT_ECHO_ON()) {\n\t\t# A normal question\n\t\tprint $fh \"1 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telsif ($type == PAM_PROMPT_ECHO_OFF()) {\n\t\t# A password\n\t\tprint $fh \"3 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telsif ($type == PAM_ERROR_MSG() || $type == PAM_TEXT_INFO()) {\n\t\t# A message that does not require a response\n\t\tprint $fh \"4 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telse {\n\t\t# Unknown type!\n\t\tprint $fh \"0 Unknown PAM message type $type\\n\";\n\t\treturn 0;\n\t\t}\n\t}\n}\n\n# send_pam_answer(&conv, answer)\n# Sends a response from the user to the PAM sub-process\nsub send_pam_answer\n{\nlocal ($conf, $answer) = @_;\nlocal $pw = $conf->{'PAMINw'};\n$conf->{'last'} = time();\nprint $pw \"$answer\\n\";\n}\n\n# end_pam_conversation(&conv)\n# Clean up PAM conversation pipes and processes\nsub end_pam_conversation\n{\nlocal ($conv) = @_;\nkill('KILL', $conv->{'pid'}) if ($conv->{'pid'});\nif ($conv->{'PAMINr'}) {\n\tclose($conv->{'PAMINr'});\n\tclose($conv->{'PAMOUTr'});\n\tclose($conv->{'PAMINw'});\n\tclose($conv->{'PAMOUTw'});\n\t}\ndelete($conversations{$conv->{'cid'}});\n}\n\n# get_ipkeys(&miniserv)\n# Returns a list of IP address to key file mappings from a miniserv.conf entry\nsub get_ipkeys\n{\nlocal (@rv, $k);\nforeach $k (keys %{$_[0]}) {\n\tif ($k =~ /^ipkey_(\\S+)/) {\n\t\tlocal $ipkey = { 'ips' => [ split(/,/, $1) ],\n\t\t\t\t 'key' => $_[0]->{$k},\n\t\t\t\t 'index' => scalar(@rv) };\n\t\t$ipkey->{'cert'} = $_[0]->{'ipcert_'.$1};\n\t\t$ipkey->{'extracas'} = $_[0]->{'ipextracas_'.$1};\n\t\tpush(@rv, $ipkey);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# create_ssl_context(keyfile, [certfile], [extracas])\nsub create_ssl_context\n{\nlocal ($keyfile, $certfile, $extracas) = @_;\nlocal $ssl_ctx;\neval { $ssl_ctx = Net::SSLeay::new_x_ctx() };\n$ssl_ctx ||= Net::SSLeay::CTX_new();\n$ssl_ctx || die \"Failed to create SSL context : $!\";\nmy @extracas = $extracas && $extracas ne \"none\" ? split(/\\s+/, $extracas) : ();\n\n# Validate cert files\nif (!-r $keyfile) {\n\tprint STDERR \"SSL key file $keyfile does not exist\\n\";\n\treturn undef;\n\t}\nif ($certfile && !-r $certfile) {\n\tprint STDERR \"SSL cert file $certfile does not exist\\n\";\n\treturn undef;\n\t}\nforeach my $p (@extracas) {\n\tif (!-r $p) {\n\t\tprint STDERR \"SSL CA file $p does not exist\\n\";\n\t\treturn undef;\n\t\t}\n\t}\n\n# Setup PFS, if ciphers are in use\nif (-r $config{'dhparams_file'}) {\n\teval {\n\t\tmy $bio = Net::SSLeay::BIO_new_file(\n\t\t\t\t$config{'dhparams_file'}, 'r');\n\t\tmy $DHP = Net::SSLeay::PEM_read_bio_DHparams($bio);\n\t\tNet::SSLeay::CTX_set_tmp_dh($ssl_ctx, $DHP);\n\t\tmy $nid = Net::SSLeay::OBJ_sn2nid(\"secp384r1\");\n\t\tmy $curve = Net::SSLeay::EC_KEY_new_by_curve_name($nid);\n\t\tNet::SSLeay::CTX_set_tmp_ecdh($ssl_ctx, $curve);\n\t\tNet::SSLeay::BIO_free($bio);\n\t\t};\n\t}\nif ($@) {\n\tprint STDERR \"Failed to load $config{'dhparams_file'} : $@\\n\";\n\t}\n\nif ($client_certs) {\n\tNet::SSLeay::CTX_load_verify_locations(\n\t\t$ssl_ctx, $config{'ca'}, \"\");\n\teval {\n\t\tNet::SSLeay::set_verify(\n\t\t\t$ssl_ctx, &Net::SSLeay::VERIFY_PEER, \\&verify_client);\n\t\t};\n\tif ($@) {\n\t\tNet::SSLeay::CTX_set_verify(\n\t\t\t$ssl_ctx, &Net::SSLeay::VERIFY_PEER, \\&verify_client);\n\t\t}\n\t}\nforeach my $p (@extracas) {\n\tNet::SSLeay::CTX_load_verify_locations($ssl_ctx, $p, \"\");\n\t}\n\nif (!Net::SSLeay::CTX_use_PrivateKey_file($ssl_ctx, $keyfile,\n\t\t\t\t\t  &Net::SSLeay::FILETYPE_PEM)) {\n\tprint STDERR \"Failed to open SSL key $keyfile\\n\";\n\treturn undef;\n\t}\nif (!Net::SSLeay::CTX_use_certificate_file($ssl_ctx, $certfile || $keyfile,\n\t\t\t\t\t   &Net::SSLeay::FILETYPE_PEM)) {\n\tprint STDERR \"Failed to open SSL cert \".($certfile || $keyfile).\"\\n\";\n\treturn undef;\n\t}\n\nif ($config{'no_ssl2'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_SSLv2)';\n\t}\nif ($config{'no_ssl3'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_SSLv3)';\n\t}\nif ($config{'no_tls1'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1)';\n\t}\nif ($config{'no_tls1_1'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1_1)';\n\t}\nif ($config{'no_tls1_2'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1_2)';\n\t}\nif ($config{'no_sslcompression'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_COMPRESSION)';\n\t}\nif ($config{'ssl_honorcipherorder'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_CIPHER_SERVER_PREFERENCE)';\n\t}\n\nreturn $ssl_ctx;\n}\n\n# ssl_connection_for_ip(socket, ipv6-flag)\n# Returns a new SSL connection object for some socket, or undef if failed\nsub ssl_connection_for_ip\n{\nlocal ($sock, $ipv6) = @_;\nlocal $sn = getsockname($sock);\nif (!$sn) {\n\tprint STDERR \"Failed to get address for socket $sock\\n\";\n\treturn undef;\n\t}\nlocal (undef, $myip, undef) = &get_address_ip($sn, $ipv6);\nlocal $ssl_ctx = $ssl_contexts{$myip} || $ssl_contexts{\"*\"};\nlocal $ssl_con = Net::SSLeay::new($ssl_ctx);\nif ($config{'ssl_cipher_list'}) {\n\t# Force use of ciphers\n\teval \"Net::SSLeay::set_cipher_list(\n\t\t\t\\$ssl_con, \\$config{'ssl_cipher_list'})\";\n\tif ($@) {\n\t\tprint STDERR \"SSL cipher $config{'ssl_cipher_list'} failed : \",\n\t\t\t     \"$@\\n\";\n\t\t}\n\t}\nNet::SSLeay::set_fd($ssl_con, fileno($sock));\nif (!Net::SSLeay::accept($ssl_con)) {\n\treturn undef;\n\t}\nreturn $ssl_con;\n}\n\n# login_redirect(username, password, host)\n# Calls the login redirect script (if configured), which may output a URL to\n# re-direct a user to after logging in.\nsub login_redirect\n{\nreturn undef if (!$config{'login_redirect'});\nlocal $quser = quotemeta($_[0]);\nlocal $qpass = quotemeta($_[1]);\nlocal $qhost = quotemeta($_[2]);\nlocal $url = `$config{'login_redirect'} $quser $qpass $qhost`;\nchop($url);\nreturn $url;\n}\n\n# reload_config_file()\n# Re-read %config, and call post-config actions\nsub reload_config_file\n{\n&log_error(\"Reloading configuration\");\n%config = &read_config_file($config_file);\n&update_vital_config();\n&read_users_file();\n&read_mime_types();\n&build_config_mappings();\n&read_webmin_crons();\n&precache_files();\nif ($config{'session'}) {\n\tdbmclose(%sessiondb);\n\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\t}\n}\n\n# read_config_file(file)\n# Reads the given config file, and returns a hash of values\nsub read_config_file\n{\nlocal %rv;\nopen(CONF, $_[0]) || die \"Failed to open config file $_[0] : $!\";\nwhile(<CONF>) {\n\ts/\\r|\\n//g;\n\tif (/^#/ || !/\\S/) { next; }\n\t/^([^=]+)=(.*)$/;\n\t$name = $1; $val = $2;\n\t$name =~ s/^\\s+//g; $name =~ s/\\s+$//g;\n\t$val =~ s/^\\s+//g; $val =~ s/\\s+$//g;\n\t$rv{$name} = $val;\n\t}\nclose(CONF);\nreturn %rv;\n}\n\n# update_vital_config()\n# Updates %config with defaults, and dies if something vital is missing\nsub update_vital_config\n{\nmy %vital = (\"port\", 80,\n\t  \"root\", \"./\",\n\t  \"server\", \"MiniServ/0.01\",\n\t  \"index_docs\", \"index.html index.htm index.cgi index.php\",\n\t  \"addtype_html\", \"text/html\",\n\t  \"addtype_txt\", \"text/plain\",\n\t  \"addtype_gif\", \"image/gif\",\n\t  \"addtype_jpg\", \"image/jpeg\",\n\t  \"addtype_jpeg\", \"image/jpeg\",\n\t  \"realm\", \"MiniServ\",\n\t  \"session_login\", \"/session_login.cgi\",\n\t  \"pam_login\", \"/pam_login.cgi\",\n\t  \"password_form\", \"/password_form.cgi\",\n\t  \"password_change\", \"/password_change.cgi\",\n\t  \"maxconns\", 50,\n\t  \"pam\", \"webmin\",\n\t  \"sidname\", \"sid\",\n\t  \"unauth\", \"^/unauthenticated/ ^/robots.txt\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.jar\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.class\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.gif\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.png\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.conf\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.ico\\$ ^/robots.txt\\$\",\n\t  \"max_post\", 10000,\n\t  \"expires\", 7*24*60*60,\n\t  \"pam_test_user\", \"root\",\n\t  \"precache\", \"lang/en */lang/en\",\n\t  \"cookiepath\", \"/\",\n\t );\nforeach my $v (keys %vital) {\n\tif (!$config{$v}) {\n\t\tif ($vital{$v} eq \"\") {\n\t\t\tdie \"Missing config option $v\";\n\t\t\t}\n\t\t$config{$v} = $vital{$v};\n\t\t}\n\t}\n$config_file =~ /^(.*)\\/[^\\/]+$/;\nmy $config_dir = $1;\n$config{'pidfile'} =~ /^(.*)\\/[^\\/]+$/;\nmy $var_dir = $1;\nif (!$config{'sessiondb'}) {\n\t$config{'sessiondb'} = \"$var_dir/sessiondb\";\n\t}\nif (!$config{'errorlog'}) {\n\t$config{'logfile'} =~ /^(.*)\\/[^\\/]+$/;\n\t$config{'errorlog'} = \"$1/miniserv.error\";\n\t}\nif (!$config{'tempbase'}) {\n\t$config{'tempbase'} = \"$var_dir/cgitemp\";\n\t}\nif (!$config{'blockedfile'}) {\n\t$config{'blockedfile'} = \"$var_dir/blocked\";\n\t}\nif (!$config{'webmincron_dir'}) {\n\t$config{'webmincron_dir'} = \"$config_dir/webmincron/crons\";\n\t}\nif (!$config{'webmincron_last'}) {\n\t$config{'logfile'} =~ /^(.*)\\/[^\\/]+$/;\n\t$config{'webmincron_last'} = \"$1/miniserv.lastcrons\";\n\t}\nif (!$config{'webmincron_wrapper'}) {\n\t$config{'webmincron_wrapper'} = $config{'root'}.\n\t\t\t\t\t\"/webmincron/webmincron.pl\";\n\t}\nif (!$config{'twofactor_wrapper'}) {\n\t$config{'twofactor_wrapper'} = $config{'root'}.\"/acl/twofactor.pl\";\n\t}\n$config{'restartflag'} ||= $var_dir.\"/restart-flag\";\n$config{'reloadflag'} ||= $var_dir.\"/reload-flag\";\n$config{'stopflag'} ||= $var_dir.\"/stop-flag\";\n}\n\n# read_users_file()\n# Fills the %users and %certs hashes from the users file in %config\nsub read_users_file\n{\nundef(%users);\nundef(%certs);\nundef(%allow);\nundef(%deny);\nundef(%allowdays);\nundef(%allowhours);\nundef(%lastchanges);\nundef(%nochange);\nundef(%temppass);\nundef(%twofactor);\nif ($config{'userfile'}) {\n\topen(USERS, $config{'userfile'});\n\twhile(<USERS>) {\n\t\ts/\\r|\\n//g;\n\t\tlocal @user = split(/:/, $_, -1);\n\t\t$users{$user[0]} = $user[1];\n\t\t$certs{$user[0]} = $user[3] if ($user[3]);\n\t\tif ($user[4] =~ /^allow\\s+(.*)/) {\n\t\t\tmy $allow = $1;\n\t\t\t$allow =~ s/;/:/g;\n\t\t\t$allow{$user[0]} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $allow) ] :\n\t\t\t\t[ &to_ip46address(split(/\\s+/, $allow)) ];\n\t\t\t}\n\t\telsif ($user[4] =~ /^deny\\s+(.*)/) {\n\t\t\tmy $deny = $1;\n\t\t\t$deny =~ s/;/:/g;\n\t\t\t$deny{$user[0]} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $deny) ] :\n\t\t\t\t[ &to_ip46address(split(/\\s+/, $deny)) ];\n\t\t\t}\n\t\tif ($user[5] =~ /days\\s+(\\S+)/) {\n\t\t\t$allowdays{$user[0]} = [ split(/,/, $1) ];\n\t\t\t}\n\t\tif ($user[5] =~ /hours\\s+(\\d+)\\.(\\d+)-(\\d+).(\\d+)/) {\n\t\t\t$allowhours{$user[0]} = [ $1*60+$2, $3*60+$4 ];\n\t\t\t}\n\t\t$lastchanges{$user[0]} = $user[6];\n\t\t$nochange{$user[0]} = $user[9];\n\t\t$temppass{$user[0]} = $user[10];\n\t\tif ($user[11] && $user[12]) {\n\t\t\t$twofactor{$user[0]} = { 'provider' => $user[11],\n\t\t\t\t\t\t 'id' => $user[12],\n\t\t\t\t\t\t 'apikey' => $user[13] };\n\t\t\t}\n\t\t}\n\tclose(USERS);\n\t}\n\n# Test user DB, if configured\nif ($config{'userdb'}) {\n\tmy $dbh = &connect_userdb($config{'userdb'});\n\tif (!ref($dbh)) {\n\t\tprint STDERR \"Failed to open users database : $dbh\\n\"\n\t\t}\n\telse {\n\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t\t}\n\t}\n}\n\n# get_user_details(username)\n# Returns a hash ref of user details, either from config files or the user DB\nsub get_user_details\n{\nmy ($username) = @_;\nif (exists($users{$username})) {\n\t# In local files\n\treturn { 'name' => $username,\n\t\t 'pass' => $users{$username},\n\t\t 'certs' => $certs{$username},\n\t\t 'allow' => $allow{$username},\n\t\t 'deny' => $deny{$username},\n\t\t 'allowdays' => $allowdays{$username},\n\t\t 'allowhours' => $allowhours{$username},\n\t\t 'lastchanges' => $lastchanges{$username},\n\t\t 'nochange' => $nochange{$username},\n\t\t 'temppass' => $temppass{$username},\n\t\t 'preroot' => $config{'preroot_'.$username},\n\t\t 'twofactor_provider' => $twofactor{$username}->{'provider'},\n\t\t 'twofactor_id' => $twofactor{$username}->{'id'},\n\t\t 'twofactor_apikey' => $twofactor{$username}->{'apikey'},\n\t       };\n\t}\nif ($config{'userdb'}) {\n\t# Try querying user database\n\tif (exists($get_user_details_cache{$username})) {\n\t\t# Cached already\n\t\treturn $get_user_details_cache{$username};\n\t\t}\n\tprint DEBUG \"get_user_details: Connecting to user database\\n\";\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($config{'userdb'});\n\tmy $user;\n\tmy %attrs;\n\tif (!ref($dbh)) {\n\t\tprint DEBUG \"get_user_details: Failed : $dbh\\n\";\n\t\tprint STDERR \"Failed to connect to user database : $dbh\\n\";\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Fetch user ID and password with SQL\n\t\tprint DEBUG \"get_user_details: Looking for $username in SQL\\n\";\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id,pass from webmin_user where name = ?\");\n\t\tif (!$cmd || !$cmd->execute($username)) {\n\t\t\tprint STDERR \"Failed to lookup user : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tmy ($id, $pass) = $cmd->fetchrow();\n\t\t$cmd->finish();\n\t\tif (!$id) {\n\t\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t\t\t$get_user_details_cache{$username} = undef;\n\t\t\tprint DEBUG \"get_user_details: User not found\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tprint DEBUG \"get_user_details: id=$id pass=$pass\\n\";\n\n\t\t# Fetch attributes and add to user object\n\t\tprint DEBUG \"get_user_details: finding user attributes\\n\";\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select attr,value from webmin_user_attr where id = ?\");\n\t\tif (!$cmd || !$cmd->execute($id)) {\n\t\t\tprint STDERR \"Failed to lookup user attrs : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\t$user = { 'name' => $username,\n\t\t\t  'id' => $id,\n\t\t\t  'pass' => $pass,\n\t\t\t  'proto' => $proto };\n\t\twhile(my ($attr, $value) = $cmd->fetchrow()) {\n\t\t\t$attrs{$attr} = $value;\n\t\t\t}\n\t\t$cmd->finish();\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Fetch user DN with LDAP\n\t\tprint DEBUG \"get_user_details: Looking for $username in LDAP\\n\";\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$username.')(objectClass='.\n                                  $args->{'userclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\tprint STDERR \"Failed to lookup user : \",\n\t\t\t\t     ($rv ? $rv->error : \"Unknown error\"),\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tmy ($u) = $rv->all_entries();\n\t\tif (!$u || $u->get_value('cn') ne $username) {\n\t\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n                        $get_user_details_cache{$username} = undef;\n\t\t\tprint DEBUG \"get_user_details: User not found\\n\";\n                        return undef;\n\t\t\t}\n\n\t\t# Extract attributes\n\t\tmy $pass = $u->get_value('webminPass');\n\t\t$user = { 'name' => $username,\n\t\t\t  'id' => $u->dn(),\n\t\t\t  'pass' => $pass,\n\t\t\t  'proto' => $proto };\n\t\tforeach my $la ($u->get_value('webminAttr')) {\n\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t$attrs{$attr} = $value;\n\t\t\t}\n\t\t}\n\n\t# Convert DB attributes into user object fields\n\tif ($user) {\n\t\tprint DEBUG \"get_user_details: got \",scalar(keys %attrs),\n\t\t\t    \" attributes\\n\";\n\t\t$user->{'certs'} = $attrs{'cert'};\n\t\tif ($attrs{'allow'}) {\n\t\t\t$user->{'allow'} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $attrs{'allow'}) ] :\n\t\t\t\t[ &to_ipaddress(split(/\\s+/,$attrs{'allow'})) ];\n\t\t\t}\n\t\tif ($attrs{'deny'}) {\n\t\t\t$user->{'deny'} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $attrs{'deny'}) ] :\n\t\t\t\t[ &to_ipaddress(split(/\\s+/,$attrs{'deny'})) ];\n\t\t\t}\n\t\tif ($attrs{'days'}) {\n\t\t\t$user->{'allowdays'} = [ split(/,/, $attrs{'days'}) ];\n\t\t\t}\n\t\tif ($attrs{'hoursfrom'} && $attrs{'hoursto'}) {\n\t\t\tmy ($hf, $mf) = split(/\\./, $attrs{'hoursfrom'});\n\t\t\tmy ($ht, $mt) = split(/\\./, $attrs{'hoursto'});\n\t\t\t$user->{'allowhours'} = [ $hf*60+$ht, $ht*60+$mt ];\n\t\t\t}\n\t\t$user->{'lastchanges'} = $attrs{'lastchange'};\n\t\t$user->{'nochange'} = $attrs{'nochange'};\n\t\t$user->{'temppass'} = $attrs{'temppass'};\n\t\t$user->{'preroot'} = $attrs{'theme'};\n\t\t$user->{'twofactor_provider'} = $attrs{'twofactor_provider'};\n\t\t$user->{'twofactor_id'} = $attrs{'twofactor_id'};\n\t\t$user->{'twofactor_apikey'} = $attrs{'twofactor_apikey'};\n\t\t}\n\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t$get_user_details_cache{$user->{'name'}} = $user;\n\treturn $user;\n\t}\nreturn undef;\n}\n\n# find_user_by_cert(cert)\n# Returns a username looked up by certificate\nsub find_user_by_cert\n{\nmy ($peername) = @_;\nmy $peername2 = $peername;\n$peername2 =~ s/Email=/emailAddress=/ || $peername2 =~ s/emailAddress=/Email=/;\n\n# First check users in local files\nforeach my $username (keys %certs) {\n\tif ($certs{$username} eq $peername ||\n\t    $certs{$username} eq $peername2) {\n\t\treturn $username;\n\t\t}\n\t}\n\n# Check user DB\nif ($config{'userdb'}) {\n\tmy ($dbh, $proto) = &connect_userdb($config{'userdb'});\n\tif (!ref($dbh)) {\n\t\treturn undef;\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Query with SQL\n\t\tmy $cmd = $dbh->prepare(\"select webmin_user.name from webmin_user,webmin_user_attr where webmin_user.id = webmin_user_attr.id and webmin_user_attr.attr = 'cert' and webmin_user_attr.value = ?\");\n\t\treturn undef if (!$cmd);\n\t\tforeach my $p ($peername, $peername2) {\n\t\t\tmy $username;\n\t\t\tif ($cmd->execute($p)) {\n\t\t\t\t($username) = $cmd->fetchrow();\n\t\t\t\t}\n\t\t\t$cmd->finish();\n\t\t\treturn $username if ($username);\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Lookup in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(objectClass='.\n\t\t\t\t  $args->{'userclass'}.')',\n\t\t\tscope => 'sub',\n\t\t\tattrs => [ 'cn', 'webminAttr' ]);\n\t\tif ($rv && !$rv->code) {\n\t\t\tforeach my $u ($rv->all_entries) {\n\t\t\t\tmy @attrs = $u->get_value('webminAttr');\n\t\t\t\tforeach my $la (@attrs) {\n\t\t\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t\t\tif ($attr eq \"cert\" &&\n\t\t\t\t\t    ($value eq $peername ||\n\t\t\t\t\t     $value eq $peername2)) {\n\t\t\t\t\t\treturn $u->get_value('cn');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn undef;\n}\n\n# connect_userdb(string)\n# Returns a handle for talking to a user database - may be a DBI or LDAP handle.\n# On failure returns an error message string. In an array context, returns the\n# protocol type too.\nsub connect_userdb\n{\nmy ($str) = @_;\nmy ($proto, $user, $pass, $host, $prefix, $args) = &split_userdb_string($str);\nif ($proto eq \"mysql\") {\n\t# Connect to MySQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('mysql');\";\n\t$drh || return $text{'sql_emysqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"database=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tprint DEBUG \"connect_userdb: Connecting to MySQL $cstr as $user\\n\";\n\tmy $dbh = $drh->connect($cstr, $user, $pass, { });\n\t$dbh || return \"Failed to connect to MySQL : \".$drh->errstr;\n\tprint DEBUG \"connect_userdb: Connected OK\\n\";\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"postgresql\") {\n\t# Connect to PostgreSQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('Pg');\";\n\t$drh || return $text{'sql_epostgresqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"dbname=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tprint DEBUG \"connect_userdb: Connecting to PostgreSQL $cstr as $user\\n\";\n\tmy $dbh = $drh->connect($cstr, $user, $pass);\n\t$dbh || return \"Failed to connect to PostgreSQL : \".$drh->errstr;\n\tprint DEBUG \"connect_userdb: Connected OK\\n\";\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"ldap\") {\n\t# Connect with perl LDAP module\n\teval \"use Net::LDAP\";\n\t$@ && return $text{'sql_eldapdriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $scheme = $args->{'scheme'} || 'ldap';\n\tif (!$port) {\n\t\t$port = $scheme eq 'ldaps' ? 636 : 389;\n\t\t}\n\tmy $ldap = Net::LDAP->new($host,\n\t\t\t\t  port => $port,\n\t\t\t\t  'scheme' => $scheme);\n\t$ldap || return \"Failed to connect to LDAP : \".$host;\n\tmy $mesg;\n\tif ($args->{'tls'}) {\n\t\t# Switch to TLS mode\n\t\teval { $mesg = $ldap->start_tls(); };\n\t\tif ($@ || !$mesg || $mesg->code) {\n\t\t\treturn \"Failed to switch to LDAP TLS mode : \".\n\t\t\t    ($@ ? $@ : $mesg ? $mesg->error : \"Unknown error\");\n\t\t\t}\n\t\t}\n\t# Login to the server\n\tif ($pass) {\n\t\t$mesg = $ldap->bind(dn => $user, password => $pass);\n\t\t}\n\telse {\n\t\t$mesg = $ldap->bind(dn => $user, anonymous => 1);\n\t\t}\n\tif (!$mesg || $mesg->code) {\n\t\treturn \"Failed to login to LDAP as \".$user.\" : \".\n\t\t       ($mesg ? $mesg->error : \"Unknown error\");\n\t\t}\n\treturn wantarray ? ($ldap, $proto, $prefix, $args) : $ldap;\n\t}\nelse {\n\treturn \"Unknown protocol $proto\";\n\t}\n}\n\n# split_userdb_string(string)\n# Converts a string like mysql://user:pass@host/db into separate parts\nsub split_userdb_string\n{\nmy ($str) = @_;\nif ($str =~ /^([a-z]+):\\/\\/([^:]*):([^\\@]*)\\@([a-z0-9\\.\\-\\_]+)\\/([^\\?]+)(\\?(.*))?$/) {\n\tmy ($proto, $user, $pass, $host, $prefix, $argstr) =\n\t\t($1, $2, $3, $4, $5, $7);\n\tmy %args = map { split(/=/, $_, 2) } split(/\\&/, $argstr);\n\treturn ($proto, $user, $pass, $host, $prefix, \\%args);\n\t}\nreturn ( );\n}\n\n# disconnect_userdb(string, &handle)\n# Closes a handle opened by connect_userdb\nsub disconnect_userdb\n{\nmy ($str, $h) = @_;\nif ($str =~ /^(mysql|postgresql):/) {\n\t# DBI disconnnect\n\t$h->disconnect();\n\t}\nelsif ($str =~ /^ldap:/) {\n\t# LDAP disconnect\n\t$h->disconnect();\n\t}\n}\n\n# read_mime_types()\n# Fills %mime with entries from file in %config and extra settings in %config\nsub read_mime_types\n{\nundef(%mime);\nif ($config{\"mimetypes\"} ne \"\") {\n\topen(MIME, $config{\"mimetypes\"});\n\twhile(<MIME>) {\n\t\tchop; s/#.*$//;\n\t\tif (/^(\\S+)\\s+(.*)$/) {\n\t\t\tmy $type = $1;\n\t\t\tmy @exts = split(/\\s+/, $2);\n\t\t\tforeach my $ext (@exts) {\n\t\t\t\t$mime{$ext} = $type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(MIME);\n\t}\nforeach my $k (keys %config) {\n\tif ($k !~ /^addtype_(.*)$/) { next; }\n\t$mime{$1} = $config{$k};\n\t}\n}\n\n# build_config_mappings()\n# Build the anonymous access list, IP access list, unauthenticated URLs list,\n# redirect mapping and allow and deny lists from %config\nsub build_config_mappings\n{\n# build anonymous access list\nundef(%anonymous);\nforeach my $a (split(/\\s+/, $config{'anonymous'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\t$anonymous{$1} = $2;\n\t\t}\n\t}\n\n# build IP access list\nundef(%ipaccess);\nforeach my $a (split(/\\s+/, $config{'ipaccess'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\t$ipaccess{$1} = $2;\n\t\t}\n\t}\n\n# build unauthenticated URLs list\n@unauth = split(/\\s+/, $config{'unauth'});\n\n# build redirect mapping\nundef(%redirect);\nforeach my $r (split(/\\s+/, $config{'redirect'})) {\n\tif ($r =~ /^([^=]+)=(\\S+)$/) {\n\t\t$redirect{$1} = $2;\n\t\t}\n\t}\n\n# build prefixes to be stripped\nundef(@strip_prefix);\nforeach my $r (split(/\\s+/, $config{'strip_prefix'})) {\n\tpush(@strip_prefix, $r);\n\t}\n\n# Init allow and deny lists\n@deny = split(/\\s+/, $config{\"deny\"});\n@deny = &to_ipaddress(@deny) if (!$config{'alwaysresolve'});\n@allow = split(/\\s+/, $config{\"allow\"});\n@allow = &to_ipaddress(@allow) if (!$config{'alwaysresolve'});\nundef(@allowusers);\nundef(@denyusers);\nif ($config{'allowusers'}) {\n\t@allowusers = split(/\\s+/, $config{'allowusers'});\n\t}\nelsif ($config{'denyusers'}) {\n\t@denyusers = split(/\\s+/, $config{'denyusers'});\n\t}\n\n# Build list of unixauth mappings\nundef(%unixauth);\nforeach my $ua (split(/\\s+/, $config{'unixauth'})) {\n\tif ($ua =~ /^(\\S+)=(\\S+)$/) {\n\t\t$unixauth{$1} = $2;\n\t\t}\n\telse {\n\t\t$unixauth{\"*\"} = $ua;\n\t\t}\n\t}\n\n# Build list of non-session-auth pages\nundef(%sessiononly);\nforeach my $sp (split(/\\s+/, $config{'sessiononly'})) {\n\t$sessiononly{$sp} = 1;\n\t}\n\n# Build list of logout times\nundef(@logouttimes);\nforeach my $a (split(/\\s+/, $config{'logouttimes'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\tpush(@logouttimes, [ $1, $2 ]);\n\t\t}\n\t}\npush(@logouttimes, [ undef, $config{'logouttime'} ]);\n\n# Build list of DAV pathss\nundef(@davpaths);\nforeach my $d (split(/\\s+/, $config{'davpaths'})) {\n\tpush(@davpaths, $d);\n\t}\n@davusers = split(/\\s+/, $config{'dav_users'});\n\n# Mobile agent substrings and hostname prefixes\n@mobile_agents = split(/\\t+/, $config{'mobile_agents'});\n@mobile_prefixes = split(/\\s+/, $config{'mobile_prefixes'});\n\n# Expires time list\n@expires_paths = ( );\nforeach my $pe (split(/\\t+/, $config{'expires_paths'})) {\n\tmy ($p, $e) = split(/=/, $pe);\n\tif ($p && $e ne '') {\n\t\tpush(@expires_paths, [ $p, $e ]);\n\t\t}\n\t}\n\n# Open debug log\nclose(DEBUG);\nif ($config{'debug'}) {\n\topen(DEBUG, \">>$config{'debug'}\");\n\t}\nelse {\n\topen(DEBUG, \">/dev/null\");\n\t}\n\n# Reset cache of sudo checks\nundef(%sudocache);\n}\n\n# is_group_member(&uinfo, groupname)\n# Returns 1 if some user is a primary or secondary member of a group\nsub is_group_member\n{\nlocal ($uinfo, $group) = @_;\nlocal @ginfo = getgrnam($group);\nreturn 0 if (!@ginfo);\nreturn 1 if ($ginfo[2] == $uinfo->[3]);\t# primary member\nforeach my $m (split(/\\s+/, $ginfo[3])) {\n\treturn 1 if ($m eq $uinfo->[0]);\n\t}\nreturn 0;\n}\n\n# prefix_to_mask(prefix)\n# Converts a number like 24 to a mask like 255.255.255.0\nsub prefix_to_mask\n{\nreturn $_[0] >= 24 ? \"255.255.255.\".(256-(2 ** (32-$_[0]))) :\n       $_[0] >= 16 ? \"255.255.\".(256-(2 ** (24-$_[0]))).\".0\" :\n       $_[0] >= 8 ? \"255.\".(256-(2 ** (16-$_[0]))).\".0.0\" :\n                     (256-(2 ** (8-$_[0]))).\".0.0.0\";\n}\n\n# get_logout_time(user, session-id)\n# Given a username, returns the idle time before he will be logged out\nsub get_logout_time\n{\nlocal ($user, $sid) = @_;\nif (!defined($logout_time_cache{$user,$sid})) {\n\tlocal $time;\n\tforeach my $l (@logouttimes) {\n\t\tif ($l->[0] =~ /^\\@(.*)$/) {\n\t\t\t# Check group membership\n\t\t\tlocal @uinfo = getpwnam($user);\n\t\t\tif (@uinfo && &is_group_member(\\@uinfo, $1)) {\n\t\t\t\t$time = $l->[1];\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($l->[0] =~ /^\\//) {\n\t\t\t# Check file contents\n\t\t\topen(FILE, $l->[0]);\n\t\t\twhile(<FILE>) {\n\t\t\t\ts/\\r|\\n//g;\n\t\t\t\ts/^\\s*#.*$//;\n\t\t\t\tif ($user eq $_) {\n\t\t\t\t\t$time = $l->[1];\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tclose(FILE);\n\t\t\t}\n\t\telsif (!$l->[0]) {\n\t\t\t# Always match\n\t\t\t$time = $l->[1];\n\t\t\t}\n\t\telse {\n\t\t\t# Check username\n\t\t\tif ($l->[0] eq $user) {\n\t\t\t\t$time = $l->[1];\n\t\t\t\t}\n\t\t\t}\n\t\tlast if (defined($time));\n\t\t}\n\t$logout_time_cache{$user,$sid} = $time;\n\t}\nreturn $logout_time_cache{$user,$sid};\n}\n\n# password_crypt(password, salt)\n# If the salt looks like MD5 and we have a library for it, perform MD5 hashing\n# of a password. Otherwise, do Unix crypt.\nsub password_crypt\n{\nlocal ($pass, $salt) = @_;\nlocal $rval;\nif ($salt =~ /^\\$1\\$/ && $use_md5) {\n\t$rval = &encrypt_md5($pass, $salt);\n\t}\nelsif ($salt =~ /^\\$6\\$/ && $use_sha512) {\n\t$rval = &encrypt_sha512($pass, $salt);\n\t}\nif (!defined($rval) || $salt ne $rval) {\n\t$rval = &unix_crypt($pass, $salt);\n\t}\nreturn $rval;\n}\n\n# unix_crypt(password, salt)\n# Performs standard Unix hashing for a password\nsub unix_crypt\n{\nlocal ($pass, $salt) = @_;\nif ($use_perl_crypt) {\n\treturn Crypt::UnixCrypt::crypt($pass, $salt);\n\t}\nelse {\n\treturn crypt($pass, $salt);\n\t}\n}\n\n# handle_dav_request(davpath)\n# Pass a request on to the Net::DAV::Server module\nsub handle_dav_request\n{\nlocal ($path) = @_;\neval \"use Filesys::Virtual::Plain\";\neval \"use Net::DAV::Server\";\neval \"use HTTP::Request\";\neval \"use HTTP::Headers\";\n\nif ($Net::DAV::Server::VERSION eq '1.28' && $config{'dav_nolock'}) {\n\tdelete $Net::DAV::Server::implemented{lock};\n\tdelete $Net::DAV::Server::implemented{unlock};\n\t}\n\n# Read in request data\nif (!$posted_data) {\n\tlocal $clen = $header{\"content-length\"};\n\twhile(length($posted_data) < $clen) {\n\t\t$buf = &read_data($clen - length($posted_data));\n\t\tif (!length($buf)) {\n\t\t\t&http_error(500, \"Failed to read POST request\");\n\t\t\t}\n\t\t$posted_data .= $buf;\n\t\t}\n\t}\n\n# For subsequent logging\nopen(MINISERVLOG, \">>$config{'logfile'}\");\n\n# Switch to user\nlocal $root;\nlocal @u = getpwnam($authuser);\nif ($config{'dav_remoteuser'} && !$< && $validated) {\n\tif (@u) {\n\t\tif ($u[2] != 0) {\n\t\t\t$( = $u[3]; $) = \"$u[3] $u[3]\";\n\t\t\t($>, $<) = ($u[2], $u[2]);\n\t\t\t}\n\t\tif ($config{'dav_root'} eq '*') {\n\t\t\t$root = $u[7];\n\t\t\t}\n\t\t}\n\telse {\n\t\t&http_error(500, \"Unix user \".&html_strip($authuser).\n\t\t\t\t \" does not exist\");\n\t\treturn 0;\n\t\t}\n\t}\n$root ||= $config{'dav_root'};\n$root ||= \"/\";\n\n# Check if this user can use DAV\nif (@davusers) {\n\t&users_match(\\@u, @davusers) ||\n\t\t&http_error(500, \"You are not allowed to access DAV\");\n\t}\n\n# Create DAV server\nmy $filesys = Filesys::Virtual::Plain->new({root_path => $root});\nmy $webdav = Net::DAV::Server->new();\n$webdav->filesys($filesys);\n\n# Make up a request object, and feed to DAV\nlocal $ho = HTTP::Headers->new;\nforeach my $h (keys %header) {\n\tnext if (lc($h) eq \"connection\");\n\t$ho->header($h => $header{$h});\n\t}\nif ($path ne \"/\") {\n\t$request_uri =~ s/^\\Q$path\\E//;\n\t$request_uri = \"/\" if ($request_uri eq \"\");\n\t}\nmy $request = HTTP::Request->new($method, $request_uri, $ho,\n\t\t\t\t $posted_data);\nif ($config{'dav_debug'}) {\n\tprint STDERR \"DAV request :\\n\";\n\tprint STDERR \"---------------------------------------------\\n\";\n\tprint STDERR $request->as_string();\n\tprint STDERR \"---------------------------------------------\\n\";\n\t}\nmy $response = $webdav->run($request);\n\n# Send back the reply\n&write_data(\"HTTP/1.1 \",$response->code(),\" \",$response->message(),\"\\r\\n\");\nlocal $content = $response->content();\nif ($path ne \"/\") {\n\t$content =~ s|href>/(.+)<|href>$path/$1<|g;\n\t$content =~ s|href>/<|href>$path<|g;\n\t}\nforeach my $h ($response->header_field_names) {\n\tnext if (lc($h) eq \"connection\" || lc($h) eq \"content-length\");\n\t&write_data(\"$h: \",$response->header($h),\"\\r\\n\");\n\t}\n&write_data(\"Content-length: \",length($content),\"\\r\\n\");\nlocal $rv = &write_keep_alive(0);\n&write_data(\"\\r\\n\");\n&write_data($content);\n\nif ($config{'dav_debug'}) {\n\tprint STDERR \"DAV reply :\\n\";\n\tprint STDERR \"---------------------------------------------\\n\";\n\tprint STDERR \"HTTP/1.1 \",$response->code(),\" \",$response->message(),\"\\r\\n\";\n\tforeach my $h ($response->header_field_names) {\n\t\tnext if (lc($h) eq \"connection\" || lc($h) eq \"content-length\");\n\t\tprint STDERR \"$h: \",$response->header($h),\"\\r\\n\";\n\t\t}\n\tprint STDERR \"Content-length: \",length($content),\"\\r\\n\";\n\tprint STDERR \"\\r\\n\";\n\tprint STDERR $content;\n\tprint STDERR \"---------------------------------------------\\n\";\n\t}\n\n# Log it\n&log_request($loghost, $authuser, $reqline, $response->code(), \n\t     length($response->content()));\n}\n\n# get_system_hostname()\n# Returns the hostname of this system, for reporting to listeners\nsub get_system_hostname\n{\n# On Windows, try computername environment variable\nreturn $ENV{'computername'} if ($ENV{'computername'});\nreturn $ENV{'COMPUTERNAME'} if ($ENV{'COMPUTERNAME'});\n\n# If a specific command is set, use it first\nif ($config{'hostname_command'}) {\n\tlocal $out = `($config{'hostname_command'}) 2>&1`;\n\tif (!$?) {\n\t\t$out =~ s/\\r|\\n//g;\n\t\treturn $out;\n\t\t}\n\t}\n\n# First try the hostname command\nlocal $out = `hostname 2>&1`;\nif (!$? && $out =~ /\\S/) {\n\t$out =~ s/\\r|\\n//g;\n\treturn $out;\n\t}\n\n# Try the Sys::Hostname module\neval \"use Sys::Hostname\";\nif (!$@) {\n\tlocal $rv = eval \"hostname()\";\n\tif (!$@ && $rv) {\n\t\treturn $rv;\n\t\t}\n\t}\n\n# Must use net name on Windows\nlocal $out = `net name 2>&1`;\nif ($out =~ /\\-+\\r?\\n(\\S+)/) {\n\treturn $1;\n\t}\n\nreturn undef;\n}\n\n# indexof(string, array)\n# Returns the index of some value in an array, or -1\nsub indexof {\n  local($i);\n  for($i=1; $i <= $#_; $i++) {\n    if ($_[$i] eq $_[0]) { return $i - 1; }\n  }\n  return -1;\n}\n\n\n# has_command(command)\n# Returns the full path if some command is in the path, undef if not\nsub has_command\n{\nlocal($d);\nif (!$_[0]) { return undef; }\nif (exists($has_command_cache{$_[0]})) {\n\treturn $has_command_cache{$_[0]};\n\t}\nlocal $rv = undef;\nif ($_[0] =~ /^\\//) {\n\t$rv = -x $_[0] ? $_[0] : undef;\n\t}\nelse {\n\tlocal $sp = $on_windows ? ';' : ':';\n\tforeach $d (split($sp, $ENV{PATH})) {\n\t\tif (-x \"$d/$_[0]\") {\n\t\t\t$rv = \"$d/$_[0]\";\n\t\t\tlast;\n\t\t\t}\n\t\tif ($on_windows) {\n\t\t\tforeach my $sfx (\".exe\", \".com\", \".bat\") {\n\t\t\t\tif (-r \"$d/$_[0]\".$sfx) {\n\t\t\t\t\t$rv = \"$d/$_[0]\".$sfx;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n$has_command_cache{$_[0]} = $rv;\nreturn $rv;\n}\n\n# check_sudo_permissions(user, pass)\n# Returns 1 if some user can run any command via sudo\nsub check_sudo_permissions\n{\nlocal ($user, $pass) = @_;\n\n# First try the pipes\nif ($PASSINw) {\n\tprint DEBUG \"check_sudo_permissions: querying cache for $user\\n\";\n\tprint $PASSINw \"readsudo $user\\n\";\n\tlocal $can = <$PASSOUTr>;\n\tchop($can);\n\tprint DEBUG \"check_sudo_permissions: cache said $can\\n\";\n\tif ($can =~ /^\\d+$/ && $can != 2) {\n\t\treturn int($can);\n\t\t}\n\t}\n\nlocal $ptyfh = new IO::Pty;\nprint DEBUG \"check_sudo_permissions: ptyfh=$ptyfh\\n\";\nif (!$ptyfh) {\n\tprint STDERR \"Failed to create new PTY with IO::Pty\\n\";\n\treturn 0;\n\t}\nlocal @uinfo = getpwnam($user);\nif (!@uinfo) {\n\tprint STDERR \"Unix user $user does not exist for sudo\\n\";\n\treturn 0;\n\t}\n\n# Execute sudo in a sub-process, via a pty\nlocal $ttyfh = $ptyfh->slave();\nprint DEBUG \"check_sudo_permissions: ttyfh=$ttyfh\\n\";\nlocal $tty = $ptyfh->ttyname();\nprint DEBUG \"check_sudo_permissions: tty=$tty\\n\";\nchown($uinfo[2], $uinfo[3], $tty);\npipe(SUDOr, SUDOw);\nprint DEBUG \"check_sudo_permissions: about to fork..\\n\";\nlocal $pid = fork();\nprint DEBUG \"check_sudo_permissions: fork=$pid pid=$$\\n\";\nif ($pid < 0) {\n\tprint STDERR \"fork for sudo failed : $!\\n\";\n\treturn 0;\n\t}\nif (!$pid) {\n\tsetsid();\n\t($(, $)) = ( $uinfo[3],\n                     \"$uinfo[3] \".join(\" \", $uinfo[3],\n                                            &other_groups($uinfo[0])) );\n\t($>, $<) = ($uinfo[2], $uinfo[2]);\n\t$ENV{'USER'} = $ENV{'LOGNAME'} = $user;\n\t$ENV{'HOME'} = $uinfo[7];\n\n\t$ptyfh->make_slave_controlling_terminal();\n\tclose(STDIN); close(STDOUT); close(STDERR);\n\tuntie(*STDIN); untie(*STDOUT); untie(*STDERR);\n\tclose($PASSINw); close($PASSOUTr);\n\tclose(SUDOw);\n\tclose(SOCK);\n\tclose(MAIN);\n\topen(STDIN, \"<&SUDOr\");\n\topen(STDOUT, \">$tty\");\n\topen(STDERR, \">&STDOUT\");\n\tclose($ptyfh);\n\texec(\"sudo -l -S\");\n\tprint \"Exec failed : $!\\n\";\n\texit 1;\n\t}\nprint DEBUG \"check_sudo_permissions: pid=$pid\\n\";\nclose(SUDOr);\n$ptyfh->close_slave();\n\n# Send password, and get back response\nlocal $oldfh = select(SUDOw);\n$| = 1;\nselect($oldfh);\nprint DEBUG \"check_sudo_permissions: about to send pass\\n\";\nlocal $SIG{'PIPE'} = 'ignore';\t# Sometimes sudo doesn't ask for a password\nprint SUDOw $pass,\"\\n\";\nprint DEBUG \"check_sudo_permissions: sent pass=$pass\\n\";\nclose(SUDOw);\nlocal $out;\nwhile(<$ptyfh>) {\n\tprint DEBUG \"check_sudo_permissions: got $_\";\n\t$out .= $_;\n\t}\nclose($ptyfh);\nkill('KILL', $pid);\nwaitpid($pid, 0);\nlocal ($ok) = ($out =~ /\\(ALL\\)\\s+ALL|\\(ALL\\)\\s+NOPASSWD:\\s+ALL|\\(ALL\\s*:\\s*ALL\\)\\s+ALL|\\(ALL\\s*:\\s*ALL\\)\\s+NOPASSWD:\\s+ALL/ ? 1 : 0);\n\n# Update cache\nif ($PASSINw) {\n\tprint $PASSINw \"writesudo $user $ok\\n\";\n\t}\n\nreturn $ok;\n}\n\nsub other_groups\n{\nmy ($user) = @_;\nmy @rv;\nsetgrent();\nwhile(my @g = getgrent()) {\n        my @m = split(/\\s+/, $g[3]);\n        push(@rv, $g[2]) if (&indexof($user, @m) >= 0);\n        }\nendgrent();\nreturn @rv;\n}\n\n# is_mobile_useragent(agent)\n# Returns 1 if some user agent looks like a cellphone or other mobile device,\n# such as a treo.\nsub is_mobile_useragent\n{\nlocal ($agent) = @_;\nlocal @prefixes = ( \n    \"UP.Link\",    # Openwave\n    \"Nokia\",      # All Nokias start with Nokia\n    \"MOT-\",       # All Motorola phones start with MOT-\n    \"SAMSUNG\",    # Samsung browsers\n    \"Samsung\",    # Samsung browsers\n    \"SEC-\",       # Samsung browsers\n    \"AU-MIC\",     # Samsung browsers\n    \"AUDIOVOX\",   # Audiovox\n    \"BlackBerry\", # BlackBerry\n    \"hiptop\",     # Danger hiptop Sidekick\n    \"SonyEricsson\", # Sony Ericsson\n    \"Ericsson\",     # Old Ericsson browsers , mostly WAP\n    \"Mitsu/1.1.A\",  # Mitsubishi phones\n    \"Panasonic WAP\", # Panasonic old WAP phones\n    \"DoCoMo\",     # DoCoMo phones\n    \"Lynx\",\t  # Lynx text-mode linux browser\n    \"Links\",\t  # Another text-mode linux browser\n    \"Dalvik\",\t  # Android browser\n    );\nlocal @substrings = (\n    \"UP.Browser\",         # Openwave\n    \"MobilePhone\",        # NetFront\n    \"AU-MIC-A700\",        # Samsung A700 Obigo browsers\n    \"Danger hiptop\",      # Danger Sidekick hiptop\n    \"Windows CE\",         # Windows CE Pocket PC\n    \"IEMobile\",           # Windows mobile browser\n    \"Blazer\",             # Palm Treo Blazer\n    \"BlackBerry\",         # BlackBerries can emulate other browsers, but\n                          # they still keep this string in the UserAgent\n    \"SymbianOS\",          # New Series60 browser has safari in it and\n                          # SymbianOS is the only distinguishing string\n    \"iPhone\",\t\t  # Apple iPhone KHTML browser\n    \"iPod\",\t\t  # iPod touch browser\n    \"MobileSafari\",\t  # HTTP client in iPhone\n    \"Mobile Safari\",\t  # Samsung Galaxy S6 browser\n    \"Opera Mini\",\t  # Opera Mini\n    \"HTC_P3700\",\t  # HTC mobile device\n    \"Pre/\",\t\t  # Palm Pre\n    \"webOS/\",\t\t  # Palm WebOS\n    \"Nintendo DS\",\t  # DSi / DSi-XL\n    );\nlocal @regexps = (\n    \"Android.*Mobile\",\t  # Android phone\n    );\nforeach my $p (@prefixes) {\n\treturn 1 if ($agent =~ /^\\Q$p\\E/);\n\t}\nforeach my $s (@substrings, @mobile_agents) {\n\treturn 1 if ($agent =~ /\\Q$s\\E/);\n\t}\nforeach my $s (@regexps) {\n\treturn 1 if ($agent =~ /$s/);\n\t}\nreturn 0;\n}\n\n# write_blocked_file()\n# Writes out a text file of blocked hosts and users\nsub write_blocked_file\n{\nopen(BLOCKED, \">$config{'blockedfile'}\");\nforeach my $d (grep { $hostfail{$_} } @deny) {\n\tprint BLOCKED \"host $d $hostfail{$d} $blockhosttime{$d}\\n\";\n\t}\nforeach my $d (grep { $userfail{$_} } @denyusers) {\n\tprint BLOCKED \"user $d $userfail{$d} $blockusertime{$d}\\n\";\n\t}\nclose(BLOCKED);\nchmod(0700, $config{'blockedfile'});\n}\n\nsub write_pid_file\n{\nopen(PIDFILE, \">$config{'pidfile'}\");\nprintf PIDFILE \"%d\\n\", getpid();\nclose(PIDFILE);\n$miniserv_main_pid = getpid();\n}\n\n# lock_user_password(user)\n# Updates a user's password file entry to lock it, both in memory and on disk.\n# Returns 1 if done, -1 if no such user, 0 if already locked\nsub lock_user_password\n{\nlocal ($user) = @_;\nlocal $uinfo = &get_user_details($user);\nif (!$uinfo) {\n\t# No such user!\n\treturn -1;\n\t}\nif ($uinfo->{'pass'} =~ /^\\!/) {\n\t# Already locked\n\treturn 0;\n\t}\nif (!$uinfo->{'proto'}) {\n\t# Write to users file\n\t$users{$user} = \"!\".$users{$user};\n\topen(USERS, $config{'userfile'});\n\tlocal @ufile = <USERS>;\n\tclose(USERS);\n\tforeach my $u (@ufile) {\n\t\tlocal @uinfo = split(/:/, $u);\n\t\tif ($uinfo[0] eq $user) {\n\t\t\t$uinfo[1] = $users{$user};\n\t\t\t}\n\t\t$u = join(\":\", @uinfo);\n\t\t}\n\topen(USERS, \">$config{'userfile'}\");\n\tprint USERS @ufile;\n\tclose(USERS);\n\treturn 0;\n\t}\n\nif ($config{'userdb'}) {\n\t# Update user DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($config{'userdb'});\n\tif (!$dbh) {\n\t\treturn -1;\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Update user attribute\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"update webmin_user set pass = ? where id = ?\");\n\t\tif (!$cmd || !$cmd->execute(\"!\".$uinfo->{'pass'},\n\t\t\t\t\t    $uinfo->{'id'})) {\n\t\t\t# Update failed\n\t\t\tprint STDERR \"Failed to lock password : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn -1;\n\t\t\t}\n\t\t$cmd->finish() if ($cmd);\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Update LDAP object\n\t\tmy $rv = $dbh->modify($uinfo->{'id'},\n\t\t      replace => { 'webminPass' => '!'.$uinfo->{'pass'} });\n\t\tif (!$rv || $rv->code) {\n\t\t\tprint STDERR \"Failed to lock password : \",\n\t\t\t\t     ($rv ? $rv->error : \"Unknown error\"),\"\\n\";\n\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($config{'userdb'}, $dbh);\n\treturn 0;\n\t}\n\nreturn -1;\t# This should never be reached\n}\n\n# hash_session_id(sid)\n# Returns an MD5 or Unix-crypted session ID\nsub hash_session_id\n{\nlocal ($sid) = @_;\nif (!$hash_session_id_cache{$sid}) {\n\tif ($use_md5) {\n\t\t# Take MD5 hash\n\t\t$hash_session_id_cache{$sid} = &encrypt_md5($sid);\n\t\t}\n\telse {\n\t\t# Unix crypt\n\t\t$hash_session_id_cache{$sid} = &unix_crypt($sid, \"XX\");\n\t\t}\n\t}\nreturn $hash_session_id_cache{$sid};\n}\n\n# encrypt_md5(string, [salt])\n# Returns a string encrypted in MD5 format\nsub encrypt_md5\n{\nlocal ($passwd, $salt) = @_;\nlocal $magic = '$1$';\nif ($salt =~ /^\\$1\\$([^\\$]+)/) {\n\t# Extract actual salt from already encrypted password\n\t$salt = $1;\n\t}\n\n# Add the password\nlocal $ctx = eval \"new $use_md5\";\n$ctx->add($passwd);\nif ($salt) {\n\t$ctx->add($magic);\n\t$ctx->add($salt);\n\t}\n\n# Add some more stuff from the hash of the password and salt\nlocal $ctx1 = eval \"new $use_md5\";\n$ctx1->add($passwd);\nif ($salt) {\n\t$ctx1->add($salt);\n\t}\n$ctx1->add($passwd);\nlocal $final = $ctx1->digest();\nfor($pl=length($passwd); $pl>0; $pl-=16) {\n\t$ctx->add($pl > 16 ? $final : substr($final, 0, $pl));\n\t}\n\n# This piece of code seems rather pointless, but it's in the C code that\n# does MD5 in PAM so it has to go in!\nlocal $j = 0;\nlocal ($i, $l);\nfor($i=length($passwd); $i; $i >>= 1) {\n\tif ($i & 1) {\n\t\t$ctx->add(\"\\0\");\n\t\t}\n\telse {\n\t\t$ctx->add(substr($passwd, $j, 1));\n\t\t}\n\t}\n$final = $ctx->digest();\n\nif ($salt) {\n\t# This loop exists only to waste time\n\tfor($i=0; $i<1000; $i++) {\n\t\t$ctx1 = eval \"new $use_md5\";\n\t\t$ctx1->add($i & 1 ? $passwd : $final);\n\t\t$ctx1->add($salt) if ($i % 3);\n\t\t$ctx1->add($passwd) if ($i % 7);\n\t\t$ctx1->add($i & 1 ? $final : $passwd);\n\t\t$final = $ctx1->digest();\n\t\t}\n\t}\n\n# Convert the 16-byte final string into a readable form\nlocal $rv;\nlocal @final = map { ord($_) } split(//, $final);\n$l = ($final[ 0]<<16) + ($final[ 6]<<8) + $final[12];\n$rv .= &to64($l, 4);\n$l = ($final[ 1]<<16) + ($final[ 7]<<8) + $final[13];\n$rv .= &to64($l, 4);\n$l = ($final[ 2]<<16) + ($final[ 8]<<8) + $final[14];\n$rv .= &to64($l, 4);\n$l = ($final[ 3]<<16) + ($final[ 9]<<8) + $final[15];\n$rv .= &to64($l, 4);\n$l = ($final[ 4]<<16) + ($final[10]<<8) + $final[ 5];\n$rv .= &to64($l, 4);\n$l = $final[11];\n$rv .= &to64($l, 2);\n\n# Add salt if needed\nif ($salt) {\n\treturn $magic.$salt.'$'.$rv;\n\t}\nelse {\n\treturn $rv;\n\t}\n}\n\n# encrypt_sha512(password, [salt])\n# Hashes a password, possibly with the given salt, with SHA512\nsub encrypt_sha512\n{\nmy ($passwd, $salt) = @_;\nif ($salt =~ /^\\$6\\$([^\\$]+)/) {\n\t# Extract actual salt from already encrypted password\n\t$salt = $1;\n\t}\n$salt ||= '$6$'.substr(time(), -8).'$';\nreturn crypt($passwd, $salt);\n}\n\nsub to64\n{\nlocal ($v, $n) = @_;\nlocal $r;\nwhile(--$n >= 0) {\n        $r .= $itoa64[$v & 0x3f];\n        $v >>= 6;\n        }\nreturn $r;\n}\n\n# read_file(file, &assoc, [&order], [lowercase])\n# Fill an associative array with name=value pairs from a file\nsub read_file\n{\nopen(ARFILE, $_[0]) || return 0;\nwhile(<ARFILE>) {\n\ts/\\r|\\n//g;\n        if (!/^#/ && /^([^=]*)=(.*)$/) {\n\t\t$_[1]->{$_[3] ? lc($1) : $1} = $2;\n\t\tpush(@{$_[2]}, $1) if ($_[2]);\n        \t}\n        }\nclose(ARFILE);\nreturn 1;\n}\n \n# write_file(file, array)\n# Write out the contents of an associative array as name=value lines\nsub write_file\n{\nlocal(%old, @order);\n&read_file($_[0], \\%old, \\@order);\nopen(ARFILE, \">$_[0]\");\nforeach $k (@order) {\n        print ARFILE $k,\"=\",$_[1]->{$k},\"\\n\" if (exists($_[1]->{$k}));\n\t}\nforeach $k (keys %{$_[1]}) {\n        print ARFILE $k,\"=\",$_[1]->{$k},\"\\n\" if (!exists($old{$k}));\n        }\nclose(ARFILE);\n}\n\n# execute_ready_webmin_crons(run-count)\n# Find and run any cron jobs that are due, based on their last run time and\n# execution interval\nsub execute_ready_webmin_crons\n{\nmy ($runs) = @_;\nmy $now = time();\nmy $changed = 0;\nforeach my $cron (@webmincrons) {\n\tmy $run = 0;\n\tif ($runs == 0 && $cron->{'boot'}) {\n\t\t# If cron job wants to be run at startup, run it now\n\t\t$run = 1;\n\t\t}\n\telsif ($cron->{'disabled'}) {\n\t\t# Explicitly disabled\n\t\t$run = 0;\n\t\t}\n\telsif (!$webmincron_last{$cron->{'id'}}) {\n\t\t# If not ever run before, don't run right away\n\t\t$webmincron_last{$cron->{'id'}} = $now;\n\t\t$changed = 1;\n\t\t}\n\telsif ($cron->{'interval'} &&\n\t       $now - $webmincron_last{$cron->{'id'}} > $cron->{'interval'}) {\n\t\t# Older than interval .. time to run\n\t\t$run = 1;\n\t\t}\n\telsif ($cron->{'mins'} ne '') {\n\t\t# Check if current time matches spec, and we haven't run in the\n\t\t# last minute\n\t\tmy @tm = localtime($now);\n\t\tif (&matches_cron($cron->{'mins'}, $tm[1], 0) &&\n\t\t    &matches_cron($cron->{'hours'}, $tm[2], 0) &&\n\t\t    &matches_cron($cron->{'days'}, $tm[3], 1) &&\n\t\t    &matches_cron($cron->{'months'}, $tm[4]+1, 1) &&\n\t\t    &matches_cron($cron->{'weekdays'}, $tm[6], 0) &&\n\t\t    $now - $webmincron_last{$cron->{'id'}} > 60) {\n\t\t\t$run = 1;\n\t\t\t}\n\t\t}\n\n\tif ($run) {\n\t\tprint DEBUG \"Running cron id=$cron->{'id'} \".\n\t\t\t    \"module=$cron->{'module'} func=$cron->{'func'} \".\n\t\t\t    \"arg0=$cron->{'arg0'}\\n\";\n\t\t$webmincron_last{$cron->{'id'}} = $now;\n\t\t$changed = 1;\n\t\tmy $pid = &execute_webmin_command($config{'webmincron_wrapper'},\n\t\t\t\t\t\t  [ $cron ]);\n\t\tpush(@childpids, $pid);\n\t\t}\n\t}\nif ($changed) {\n\t# Write out file containing last run times\n\t&write_file($config{'webmincron_last'}, \\%webmincron_last);\n\t}\n}\n\n# matches_cron(cron-spec, time, first-value)\n# Checks if some minute or hour matches some cron spec, which can be * or a list\n# of numbers.\nsub matches_cron\n{\nmy ($spec, $tm, $first) = @_;\nif ($spec eq '*') {\n\treturn 1;\n\t}\nelse {\n\tforeach my $s (split(/,/, $spec)) {\n\t\tif ($s == $tm ||\n\t\t    $s =~ /^(\\d+)\\-(\\d+)$/ &&\n\t\t      $tm >= $1 && $tm <= $2 ||\n\t\t    $s =~ /^\\*\\/(\\d+)$/ &&\n\t\t      $tm % $1 == $first ||\n\t\t    $s =~ /^(\\d+)\\-(\\d+)\\/(\\d+)$/ &&\n\t\t      $tm >= $1 && $tm <= $2 && $tm % $3 == $first) {\n\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n}\n\n# read_webmin_crons()\n# Read all scheduled webmin cron functions and store them in the @webmincrons\n# global list\nsub read_webmin_crons\n{\n@webmincrons = ( );\nopendir(CRONS, $config{'webmincron_dir'});\nprint DEBUG \"Reading crons from $config{'webmincron_dir'}\\n\";\nforeach my $f (readdir(CRONS)) {\n\tif ($f =~ /^(\\d+)\\.cron$/) {\n\t\tmy %cron;\n\t\t&read_file(\"$config{'webmincron_dir'}/$f\", \\%cron);\n\t\t$cron{'id'} = $1;\n\t\tmy $broken = 0;\n\t\tforeach my $n ('module', 'func') {\n\t\t\tif (!$cron{$n}) {\n\t\t\t\tprint STDERR \"Cron $1 missing $n\\n\";\n\t\t\t\t$broken = 1;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!$cron{'interval'} && $cron{'mins'} eq '' &&\n\t\t    $cron{'special'} eq '' && !$cron{'boot'}) {\n\t\t\tprint STDERR \"Cron $1 missing any time spec\\n\";\n\t\t\t$broken = 1;\n\t\t\t}\n\t\tif ($cron{'special'} eq 'hourly') {\n\t\t\t# Run every hour on the hour\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '*';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'daily') {\n\t\t\t# Run every day at midnight\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'monthly') {\n\t\t\t# Run every month on the 1st\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '1';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'weekly') {\n\t\t\t# Run every month on the 1st\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '0';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'yearly' ||\n\t\t       $cron{'special'} eq 'annually') {\n\t\t\t# Run every year on 1st january\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '1';\n\t\t\t$cron{'months'} = '1';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'}) {\n\t\t\tprint STDERR \"Cron $1 invalid special time $cron{'special'}\\n\";\n\t\t\t$broken = 1;\n\t\t\t}\n\t\tif ($cron{'special'}) {\n\t\t\tdelete($cron{'special'});\n\t\t\t}\n\t\tif (!$broken) {\n\t\t\tprint DEBUG \"Adding cron id=$cron{'id'} module=$cron{'module'} func=$cron{'func'} arg0=$cron{'arg0'}\\n\";\n\t\t\tpush(@webmincrons, \\%cron);\n\t\t\t}\n\t\t}\n\t}\nclosedir(CRONS);\n}\n\n# precache_files()\n# Read into the Webmin cache all files marked for pre-caching\nsub precache_files\n{\nundef(%main::read_file_cache);\nforeach my $g (split(/\\s+/, $config{'precache'})) {\n\tnext if ($g eq \"none\");\n\tforeach my $f (glob(\"$config{'root'}/$g\")) {\n\t\tmy @st = stat($f);\n\t\tnext if (!@st);\n\t\t$main::read_file_cache{$f} = { };\n\t\t&read_file($f, $main::read_file_cache{$f});\n\t\t$main::read_file_cache_time{$f} = $st[9];\n\t\t}\n\t}\n}\n\n# Check if some address is valid IPv4, returns 1 if so.\nsub check_ipaddress\n{\nreturn $_[0] =~ /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/ &&\n\t$1 >= 0 && $1 <= 255 &&\n\t$2 >= 0 && $2 <= 255 &&\n\t$3 >= 0 && $3 <= 255 &&\n\t$4 >= 0 && $4 <= 255;\n}\n\n# Check if some IPv6 address is properly formatted, and returns 1 if so.\nsub check_ip6address\n{\n  my @blocks = split(/:/, $_[0]);\n  return 0 if (@blocks == 0 || @blocks > 8);\n  my $ib = $#blocks;\n  my $where = index($blocks[$ib],\"/\");\n  my $m = 0;\n  if ($where != -1) {\n    my $b = substr($blocks[$ib],0,$where);\n    $m = substr($blocks[$ib],$where+1,length($blocks[$ib])-($where+1));\n    $blocks[$ib]=$b;\n  }\n  return 0 if ($m <0 || $m >128); \n  my $b;\n  my $empty = 0;\n  foreach $b (@blocks) {\n\t  return 0 if ($b ne \"\" && $b !~ /^[0-9a-f]{1,4}$/i);\n\t  $empty++ if ($b eq \"\");\n\t  }\n  return 0 if ($empty > 1 && !($_[0] =~ /^::/ && $empty == 2));\n  return 1;\n}\n\n# network_to_address(binary)\n# Given a network address in binary IPv4 or v4 format, return the string form\nsub network_to_address\n{\nlocal ($addr) = @_;\nif (length($addr) == 4 || !$use_ipv6) {\n\treturn inet_ntoa($addr);\n\t}\nelse {\n\treturn inet_ntop(AF_INET6(), $addr);\n\t}\n}\n\n# redirect_stderr_to_log()\n# Re-direct STDERR to error log file\nsub redirect_stderr_to_log\n{\nif ($config{'errorlog'} ne '-') {\n\topen(STDERR, \">>$config{'errorlog'}\") ||\n\t\tdie \"failed to open $config{'errorlog'} : $!\";\n\tif ($config{'logperms'}) {\n\t\tchmod(oct($config{'logperms'}), $config{'errorlog'});\n\t\t}\n\t}\nselect(STDERR); $| = 1; select(STDOUT);\n}\n\n# should_gzip_file(filename)\n# Returns 1 if some path should be gzipped\nsub should_gzip_file\n{\nmy ($path) = @_;\nreturn $path !~ /\\.(gif|png|jpg|jpeg|tif|tiff)$/i;\n}\n\n# get_expires_time(path)\n# Given a URL path, return the client-side expiry time in seconds\nsub get_expires_time\n{\nmy ($path) = @_;\nforeach my $pe (@expires_paths) {\n\tif ($path =~ /$pe->[0]/i) {\n\t\treturn $pe->[1];\n\t\t}\n\t}\nreturn $config{'expires'};\n}\n\nsub html_escape\n{\nmy ($tmp) = @_;\n$tmp =~ s/&/&amp;/g;\n$tmp =~ s/</&lt;/g;\n$tmp =~ s/>/&gt;/g;\n$tmp =~ s/\\\"/&quot;/g;\n$tmp =~ s/\\'/&#39;/g;\n$tmp =~ s/=/&#61;/g;\nreturn $tmp;\n}\n\nsub html_strip\n{\nmy ($tmp) = @_;\n$tmp =~ s/<[^>]*>//g;\nreturn $tmp;\n}\n\n# validate_twofactor(username, token)\n# Checks if a user's two-factor token is valid or not. Returns undef on success\n# or the error message on failure.\nsub validate_twofactor\n{\nmy ($user, $token) = @_;\nlocal $uinfo = &get_user_details($user);\n$token =~ s/^\\s+//;\n$token =~ s/\\s+$//;\n$token || return \"No two-factor token entered\";\n$uinfo->{'twofactor_provider'} || return undef;\npipe(TOKENr, TOKENw);\nmy $pid = &execute_webmin_command($config{'twofactor_wrapper'},\n\t[ $user, $uinfo->{'twofactor_provider'}, $uinfo->{'twofactor_id'},\n\t  $token, $uinfo->{'twofactor_apikey'} ],\n\tTOKENw);\nclose(TOKENw);\nwaitpid($pid, 0);\nmy $ex = $?;\nmy $out = <TOKENr>;\nclose(TOKENr);\nif ($ex) {\n\treturn $out || \"Unknown two-factor authentication failure\";\n\t}\nreturn undef;\n}\n\n# execute_webmin_command(command, &argv, [stdout-fd])\n# Run some Webmin script in a sub-process, like webmincron.pl\n# Returns the PID of the new process.\nsub execute_webmin_command\n{\nmy ($cmd, $argv, $fd) = @_;\nmy $pid = fork();\nif (!$pid) {\n\t# Run via a wrapper command, which we run like a CGI\n\tdbmclose(%sessiondb);\n\tif ($fd) {\n\t\topen(STDOUT, \">&$fd\");\n\t\t}\n\telse {\n\t\topen(STDOUT, \">&STDERR\");\n\t\t}\n\t&close_all_sockets();\n\t&close_all_pipes();\n\tclose(LISTEN);\n\n\t# Setup CGI-like environment\n\t$envtz = $ENV{\"TZ\"};\n\t$envuser = $ENV{\"USER\"};\n\t$envpath = $ENV{\"PATH\"};\n\t$envlang = $ENV{\"LANG\"};\n\t$envroot = $ENV{\"SystemRoot\"};\n\t$envperllib = $ENV{'PERLLIB'};\n\tforeach my $k (keys %ENV) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t$ENV{\"PATH\"} = $envpath if ($envpath);\n\t$ENV{\"TZ\"} = $envtz if ($envtz);\n\t$ENV{\"USER\"} = $envuser if ($envuser);\n\t$ENV{\"OLD_LANG\"} = $envlang if ($envlang);\n\t$ENV{\"SystemRoot\"} = $envroot if ($envroot);\n\t$ENV{'PERLLIB'} = $envperllib if ($envperllib);\n\t$ENV{\"HOME\"} = $user_homedir;\n\t$ENV{\"SERVER_SOFTWARE\"} = $config{\"server\"};\n\t$ENV{\"SERVER_ADMIN\"} = $config{\"email\"};\n\t$root0 = $roots[0];\n\t$ENV{\"SERVER_ROOT\"} = $root0;\n\t$ENV{\"SERVER_REALROOT\"} = $root0;\n\t$ENV{\"SERVER_PORT\"} = $config{'port'};\n\t$ENV{\"WEBMIN_CRON\"} = 1;\n\t$ENV{\"DOCUMENT_ROOT\"} = $root0;\n\t$ENV{\"THEME_ROOT\"} = \"$root0/\" .\n\t                     ($config{\"preroot_$ENV{'REMOTE_USER'}\"} ||\n\t                      $config{\"preroot\"});\n\t$ENV{\"DOCUMENT_REALROOT\"} = $root0;\n\t$ENV{\"MINISERV_CONFIG\"} = $config_file;\n\t$ENV{\"HTTPS\"} = \"ON\" if ($use_ssl);\n\t$ENV{\"MINISERV_PID\"} = $miniserv_main_pid;\n\t$ENV{\"SCRIPT_FILENAME\"} = $cmd;\n\tif ($ENV{\"SCRIPT_FILENAME\"} =~ /^\\Q$root0\\E(\\/.*)$/) {\n\t\t$ENV{\"SCRIPT_NAME\"} = $1;\n\t\t}\n\t$cmd =~ /^(.*)\\//;\n\t$ENV{\"PWD\"} = $1;\n\tforeach $k (keys %config) {\n\t\tif ($k =~ /^env_(\\S+)$/) {\n\t\t\t$ENV{$1} = $config{$k};\n\t\t\t}\n\t\t}\n\tchdir($ENV{\"PWD\"});\n\t$SIG{'CHLD'} = 'DEFAULT';\n\teval {\n\t\t# Have SOCK closed if the perl exec's something\n\t\tuse Fcntl;\n\t\tfcntl(SOCK, F_SETFD, FD_CLOEXEC);\n\t\t};\n\n\t# Run the wrapper script by evaling it\n\tif ($cmd =~ /\\/([^\\/]+)\\/([^\\/]+)$/) {\n\t\t$pkg = $1;\n\t\t}\n\t$0 = $cmd;\n\t@ARGV = @$argv;\n\t$main_process_id = $$;\n\teval \"\n\t\t\\%pkg::ENV = \\%ENV;\n\t\tpackage $pkg;\n\t\tdo \\\"$cmd\\\";\n\t\tdie \\$@ if (\\$@);\n\t\t\";\n\tif ($@) {\n\t\tprint STDERR \"Perl failure : $@\\n\";\n\t\t}\n\texit(0);\n\t}\nreturn $pid;\n}\n\n# canonicalize_ip6(address)\n# Converts an address to its full long form. Ie. 2001:db8:0:f101::20 to\n# 2001:0db8:0000:f101:0000:0000:0000:0020\nsub canonicalize_ip6\n{\nmy ($addr) = @_;\nreturn $addr if (!&check_ip6address($addr));\nmy @w = split(/:/, $addr);\nmy $idx = &indexof(\"\", @w);\nif ($idx >= 0) {\n\t# Expand ::\n\tmy $mis = 8 - scalar(@w);\n\tmy @nw = @w[0..$idx];\n\tfor(my $i=0; $i<$mis; $i++) {\n\t\tpush(@nw, 0);\n\t\t}\n\tpush(@nw, @w[$idx+1 .. $#w]);\n\t@w = @nw;\n\t}\nforeach my $w (@w) {\n\twhile(length($w) < 4) {\n\t\t$w = \"0\".$w;\n\t\t}\n\t}\nreturn lc(join(\":\", @w));\n}\n\n# expand_ipv6_bytes(address)\n# Given a canonical IPv6 address, split it into an array of bytes\nsub expand_ipv6_bytes\n{\nmy ($addr) = @_;\nmy @rv;\nforeach my $w (split(/:/, $addr)) {\n\t$w =~ /^(..)(..)$/ || return ( );\n\tpush(@rv, hex($1), hex($2));\n\t}\nreturn @rv;\n}\n\nsub get_somaxconn\n{\nreturn defined(&SOMAXCONN) ? SOMAXCONN : 128;\n}\n\nsub is_bad_header\n{\nmy ($value, $name) = @_;\nreturn $value =~ /^\\s*\\(\\s*\\)\\s*\\{/ ? 1 : 0;\n}\n\n# sysread_line(fh)\n# Read a line from a file handle, using sysread to get a byte at a time\nsub sysread_line\n{\nlocal ($fh) = @_;\nlocal $line;\nwhile(1) {\n\tlocal ($buf, $got);\n\t$got = sysread($fh, $buf, 1);\n\tlast if ($got <= 0);\n\t$line .= $buf;\n\tlast if ($buf eq \"\\n\");\n\t}\nreturn $line;\n}\n\nsub getenv\n{\n    my ($key) = @_;\n    return $ENV{ uc($key) } || $ENV{ lc($key) };\n}\n", "# ping-monitor.pl\n# Ping some host\n# Contains code ripped from Net::Ping by Russell Mosemann\n\nuse Socket;\n\nsub get_ping_status\n{\nlocal $wait = defined($_[0]->{'wait'}) ? $_[0]->{'wait'} : 5;\nlocal $ip = &to_ipaddress($_[0]->{'host'}) ||\n\t    &to_ip6address($_[0]->{'host'});\nreturn { 'up' => 0 } if (!$ip);\nlocal $ipv6 = &to_ip6address($_[0]->{'host'}) &&\n\t      !&to_ipaddress($_[0]->{'host'});\nif ($config{'pinger'} || $ipv6) {\n\t# Call a ping command if configured, or if using IPv6 since the built-\n\t# in code doesn't support it yet\n\tlocal $cmd;\n\tlocal $auto_pinger = $config{'pinger'} eq \"linux\" || !$config{'pinger'};\n\tif ($auto_pinger && $gconfig{'os_type'} =~ /-linux$/) {\n\t\t# Use linux command\n\t\t$cmd = ($ipv6 ? \"ping6\" : \"ping\").\" -c 1 -w $wait\";\n\t\t}\n\telsif ($auto_pinger && $gconfig{'os_type'} eq 'freebsd') {\n\t\t# Use FreeBSD command\n\t\t$cmd = ($ipv6 ? \"ping6\" : \"ping\").\" -c 1 -W \".($wait * 1000);\n\t\t}\n\telsif ($auto_pinger) {\n\t\t# Don't know command for this OS\n\t\treturn { 'up' => - 1 };\n\t\t}\n\telse {\n\t\t$cmd = $config{'pinger'};\n\t\t}\n\tlocal $rv;\n\teval {\n\t\tlocal $sig{'ALRM'} = sub { die \"timeout\" };\n\t\talarm($wait + 1);\n\t\t$rv = system(\"$cmd \".quotemeta($_[0]->{'host'}).\n\t\t\t     \" >/dev/null 2>&1 </dev/null\");\n\t\talarm(0);\n\t\t};\n\tif ($@) {\n\t\treturn { 'up' => 0 };\n\t\t}\n\telse {\n\t\treturn { 'up' => $rv ? 0 : 1 };\n\t\t}\n\t}\nelse {\n\t# Use builtin code\n\tlocal $rv = &ping_icmp(inet_aton($ip), $wait);\n\treturn { 'up' => $rv ? 1 : 0 };\n\t}\n}\n\nsub show_ping_dialog\n{\nprint &ui_table_row($text{'ping_host'},\n\t&ui_textbox(\"host\", $_[0]->{'host'}, 50), 3);\n\nprint &ui_table_row($text{'ping_wait'},\n\t&ui_textbox(\"wait\", defined($_[0]->{'wait'}) ? $_[0]->{'wait'} : 5, 6).\n\t\" \".$text{'oldfile_secs'});\n}\n\nsub parse_ping_dialog\n{\n#$config{'ping_cmd'} || &error($text{'ping_econfig'});\n&to_ipaddress($in{'host'}) || &to_ip6address($in{'host'}) ||\n\t&error($text{'ping_ehost'});\n$in{'wait'} =~ /^(\\d*\\.)?\\d+$/ || &error($text{'ping_ewait'});\n$_[0]->{'host'} = $in{'host'};\n$_[0]->{'wait'} = $in{'wait'};\n}\n\nsub ping_icmp\n{\n    my ($ip,                # Packed IP number of the host\n        $timeout            # Seconds after which ping times out\n        ) = @_;\n\n    my $ICMP_ECHOREPLY = 0; # ICMP packet types\n    my $ICMP_ECHO = 8;\n    my $icmp_struct = \"C2 S3 A\";  # Structure of a minimal ICMP packet\n    my $subcode = 0;        # No ICMP subcode for ECHO and ECHOREPLY\n    my $flags = 0;          # No special flags when opening a socket\n    my $port = 0;           # No port with ICMP\n\n    my ($saddr,             # sockaddr_in with port and ip\n        $checksum,          # Checksum of ICMP packet\n        $msg,               # ICMP packet to send\n        $len_msg,           # Length of $msg\n        $rbits,             # Read bits, filehandles for reading\n        $nfound,            # Number of ready filehandles found\n        $finish_time,       # Time ping should be finished\n        $done,              # set to 1 when we are done\n        $ret,               # Return value\n        $recv_msg,          # Received message including IP header\n        $from_saddr,        # sockaddr_in of sender\n        $from_port,         # Port packet was sent from\n        $from_ip,           # Packed IP of sender\n        $from_type,         # ICMP type\n        $from_subcode,      # ICMP subcode\n        $from_chk,          # ICMP packet checksum\n        $from_pid,          # ICMP packet id\n        $from_seq,          # ICMP packet sequence\n        $from_msg,           # ICMP message\n\t$data,\n\t$cnt,\n\t$data_size\n        );\n\n    # Construct packet data string\n    $data_size = 0;\n    for ($cnt = 0; $cnt < $data_size; $cnt++)\n    {\n        $data .= chr($cnt % 256);\n    }\n\n    my $proto_num = (getprotobyname('icmp'))[2];\n    socket(PSOCK, PF_INET, SOCK_RAW, $proto_num);\n\n    $ping_seq = ($ping_seq + 1) % 65536; # Increment sequence\n    $checksum = 0;                          # No checksum for starters\n    $msg = pack($icmp_struct . $data_size, $ICMP_ECHO, $subcode,\n                $checksum, $$, $ping_seq, $data);\n    $checksum = checksum($msg);\n    $msg = pack($icmp_struct . $data_size, $ICMP_ECHO, $subcode,\n                $checksum, $$, $ping_seq, $data);\n    $len_msg = length($msg);\n    $saddr = pack_sockaddr_in($port, $ip);\n    send(PSOCK, $msg, $flags, $saddr); # Send the message\n\n    $rbits = \"\";\n    vec($rbits, fileno(PSOCK), 1) = 1;\n    $ret = 0;\n    $done = 0;\n    $finish_time = time() + $timeout;       # Must be done by this time\n    while (!$done && $timeout > 0)          # Keep trying if we have time\n    {\n        $nfound = select($rbits, undef, undef, $timeout); # Wait for packet\n        $timeout = $finish_time - time();   # Get remaining time\n        if (!defined($nfound))              # Hmm, a strange error\n        {\n\t    # Probably an interrupted system call, so try again\n            $ret = undef;\n            #$done = 1;\n        }\n        elsif ($nfound)                     # Got a packet from somewhere\n        {\n            $recv_msg = \"\";\n            $from_saddr = recv(PSOCK, $recv_msg, 1500, $flags);\n\t    if ($from_saddr) {\n\t\t    ($from_port, $from_ip) = unpack_sockaddr_in($from_saddr);\n\t\t    ($from_type, $from_subcode, $from_chk,\n\t\t     $from_pid, $from_seq, $from_msg) =\n\t\t\tunpack($icmp_struct . $data_size,\n\t\t\t       substr($recv_msg, length($recv_msg) - $len_msg,\n\t\t\t\t      $len_msg));\n\t\t    if (($from_type == $ICMP_ECHOREPLY) &&\n\t\t\t($from_ip eq $ip) &&\n\t\t\t($from_pid == $$) && # Does the packet check out?\n\t\t\t($from_seq == $ping_seq))\n\t\t    {\n\t\t\t$ret = 1;                   # It's a winner\n\t\t\t$done = 1;\n\t\t    }\n\t     } else {\n\t\t    # Packet not actually received\n\t\t    $ret = undef;\n\t     }\n        }\n        else                                # Oops, timed out\n        {\n            $done = 1;\n        }\n    }\n    close(PSOCK);\n    return($ret)\n}\n\n# Description:  Do a checksum on the message.  Basically sum all of\n# the short words and fold the high order bits into the low order bits.\n\nsub checksum\n{\n    my ($msg            # The message to checksum\n        ) = @_;\n    my ($len_msg,       # Length of the message\n        $num_short,     # The number of short words in the message\n        $short,         # One short word\n        $chk            # The checksum\n        );\n\n    $len_msg = length($msg);\n    $num_short = $len_msg / 2;\n    $chk = 0;\n    foreach $short (unpack(\"S$num_short\", $msg))\n    {\n        $chk += $short;\n    }                                           # Add the odd byte in\n    $chk += unpack(\"C\", substr($msg, $len_msg - 1, 1)) if $len_msg % 2;\n    $chk = ($chk >> 16) + ($chk & 0xffff);      # Fold high into low\n    return(~(($chk >> 16) + $chk) & 0xffff);    # Again and complement\n}\n\n\n"], "fixing_code": ["#!/usr/local/bin/perl\n# A very simple perl web server used by Webmin\n\n# Require basic libraries\npackage miniserv;\nuse Socket;\nuse POSIX;\nuse Time::Local;\neval \"use Time::HiRes;\";\n\n@itoa64 = split(//, \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n\n# Find and read config file\nif ($ARGV[0] eq \"--nofork\") {\n\t$nofork_argv = 1;\n\tshift(@ARGV);\n\t}\nif (@ARGV != 1) {\n\tdie \"Usage: miniserv.pl <config file>\";\n\t}\nif ($ARGV[0] =~ /^([a-z]:)?\\//i) {\n\t$config_file = $ARGV[0];\n\t}\nelse {\n\tchop($pwd = `pwd`);\n\t$config_file = \"$pwd/$ARGV[0]\";\n\t}\n%config = &read_config_file($config_file);\nif ($config{'perllib'}) {\n\tpush(@INC, split(/:/, $config{'perllib'}));\n\t$ENV{'PERLLIB'} .= ':'.$config{'perllib'};\n\t}\n@startup_msg = ( );\n\n# Check if SSL is enabled and available\nif ($config{'ssl'}) {\n\teval \"use Net::SSLeay\";\n\tif (!$@) {\n\t\t$use_ssl = 1;\n\t\t# These functions only exist for SSLeay 1.0\n\t\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\t\teval \"Net::SSLeay::load_error_strings()\";\n\t\tif (defined(&Net::SSLeay::X509_STORE_CTX_get_current_cert) &&\n\t\t    defined(&Net::SSLeay::CTX_load_verify_locations) &&\n\t\t    (defined(&Net::SSLeay::CTX_set_verify) ||\n\t\t     defined(&Net::SSLeay::set_verify))) {\n\t\t\t$client_certs = 1;\n\t\t\t}\n\t\t}\n\t}\n\n# Check if IPv6 is enabled and available\neval \"use Socket6\";\n$socket6err = $@;\nif ($config{'ipv6'}) {\n\tif (!$socket6err) {\n\t\tpush(@startup_msg, \"IPv6 support enabled\");\n\t\t$use_ipv6 = 1;\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \"IPv6 support cannot be enabled without \".\n\t\t\t\t   \"the Socket6 perl module\");\n\t\t}\n\t}\n\n# Check if the syslog module is available to log hacking attempts\nif ($config{'syslog'} && !$config{'inetd'}) {\n\teval \"use Sys::Syslog qw(:DEFAULT setlogsock)\";\n\tif (!$@) {\n\t\t$use_syslog = 1;\n\t\t}\n\t}\n\n# check if the TCP-wrappers module is available\nif ($config{'libwrap'}) {\n\teval \"use Authen::Libwrap qw(hosts_ctl STRING_UNKNOWN)\";\n\tif (!$@) {\n\t\t$use_libwrap = 1;\n\t\t}\n\t}\n\n# Check if the MD5 perl module is available\neval \"use MD5; \\$dummy = new MD5; \\$dummy->add('foo');\";\nif (!$@) {\n\t$use_md5 = \"MD5\";\n\t}\nelse {\n\teval \"use Digest::MD5; \\$dummy = new Digest::MD5; \\$dummy->add('foo');\";\n\tif (!$@) {\n\t\t$use_md5 = \"Digest::MD5\";\n\t\t}\n\t}\nif ($use_md5) {\n\tpush(@startup_msg, \"Using MD5 module $use_md5\");\n\t}\n\n# Check if the SHA512 perl module is available\neval \"use Crypt::SHA\";\n$use_sha512 = $@ ? \"Crypt::SHA\" : undef;\nif ($use_sha512) {\n\tpush(@startup_msg, \"Using SHA512 module $use_sha512\");\n\t}\n\n# Get miniserv's perl path and location\n$miniserv_path = $0;\nopen(SOURCE, $miniserv_path);\n<SOURCE> =~ /^#!(\\S+)/;\n$perl_path = $1;\nclose(SOURCE);\nif (!-x $perl_path) {\n\t$perl_path = $^X;\n\t}\nif (-l $perl_path) {\n\t$linked_perl_path = readlink($perl_path);\n\t}\n@miniserv_argv = @ARGV;\n\n# Check vital config options\n&update_vital_config();\n\n# Check if already running via the PID file\nif (open(PIDFILE, $config{'pidfile'})) {\n\tmy $already = <PIDFILE>;\n\tclose(PIDFILE);\n\tchop($already);\n\tif ($already && $already != $$ && kill(0, $already)) {\n\t\tdie \"Webmin is already running with PID $already\\n\";\n\t\t}\n\t}\n\n$sidname = $config{'sidname'};\ndie \"Session authentication cannot be used in inetd mode\"\n\tif ($config{'inetd'} && $config{'session'});\n\n# check if the PAM module is available to authenticate\nif ($config{'assume_pam'}) {\n\t# Just assume that it will work. This can also be used to work around\n\t# a Solaris bug in which using PAM before forking caused it to fail\n\t# later!\n\t$use_pam = 1;\n\t}\nelsif (!$config{'no_pam'}) {\n\teval \"use Authen::PAM;\";\n\tif (!$@) {\n\t\t# check if the PAM authentication can be used by opening a\n\t\t# PAM handle\n\t\tlocal $pamh;\n\t\tif (ref($pamh = new Authen::PAM($config{'pam'},\n\t\t\t\t\t\t$config{'pam_test_user'},\n\t\t\t\t\t\t\\&pam_conv_func))) {\n\t\t\t# Now test a login to see if /etc/pam.d/webmin is set\n\t\t\t# up properly.\n\t\t\t$pam_conv_func_called = 0;\n\t\t\t$pam_username = \"test\";\n\t\t\t$pam_password = \"test\";\n\t\t\t$pamh->pam_authenticate();\n\t\t\tif ($pam_conv_func_called) {\n\t\t\t\tpush(@startup_msg,\n\t\t\t\t     \"PAM authentication enabled\");\n\t\t\t\t$use_pam = 1;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tpush(@startup_msg,\n\t\t\t\t    \"PAM test failed - maybe \".\n\t\t\t\t    \"/etc/pam.d/$config{'pam'} does not exist\");\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tpush(@startup_msg,\n\t\t\t     \"PAM initialization of Authen::PAM failed\");\n\t\t\t}\n\t\t}\n\t}\nif ($config{'pam_only'} && !$use_pam) {\n\tforeach $msg (@startup_msg) {\n\t\tprint STDERR $msg,\"\\n\";\n\t\t}\n\tprint STDERR \"PAM use is mandatory, but could not be enabled!\\n\";\n\tprint STDERR \"no_pam and pam_only both are set!\\n\" if ($config{no_pam});\n\texit(1);\n\t}\nelsif ($pam_msg && !$use_pam) {\n\tpush(@startup_msg,\n\t     \"Continuing without the Authen::PAM perl module\");\n\t}\n\n# Check if the User::Utmp perl module is installed\nif ($config{'utmp'}) {\n\teval \"use User::Utmp;\";\n\tif (!$@) {\n\t\t$write_utmp = 1;\n\t\tpush(@startup_msg, \"UTMP logging enabled\");\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \n\t\t     \"Perl module User::Utmp needed for Utmp logging is \".\n\t\t     \"not installed : $@\");\n\t\t}\n\t}\n\n# See if the crypt function fails\neval \"crypt('foo', 'xx')\";\nif ($@) {\n\teval \"use Crypt::UnixCrypt\";\n\tif (!$@) {\n\t\t$use_perl_crypt = 1;\n\t\tpush(@startup_msg, \n\t\t     \"Using Crypt::UnixCrypt for password encryption\");\n\t\t}\n\telse {\n\t\tpush(@startup_msg, \n\t\t     \"crypt() function un-implemented, and Crypt::UnixCrypt \".\n\t\t     \"not installed - password authentication will fail\");\n\t\t}\n\t}\n\n# Check if /dev/urandom really generates random IDs, by calling it twice\nlocal $rand1 = &generate_random_id(1);\nlocal $rand2 = &generate_random_id(1);\nif ($rand1 eq $rand2) {\n\t$bad_urandom = 1;\n\tpush(@startup_msg,\n\t     \"Random number generator file /dev/urandom is not reliable\");\n\t}\n\n# Check if we can call sudo\nif ($config{'sudo'} && &has_command(\"sudo\")) {\n\teval \"use IO::Pty\";\n\tif (!$@) {\n\t\t$use_sudo = 1;\n\t\t}\n\telse {\n\t\tpush(@startup_msg,\n\t\t     \"Perl module IO::Pty needed for calling sudo is not \".\n\t\t     \"installed : $@\");\n\t\t}\n\t}\n\n# init days and months for http_date\n@weekday = ( \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" );\n@month = ( \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" );\n\n# Change dir to the server root\n@roots = ( $config{'root'} );\nfor($i=0; defined($config{\"extraroot_$i\"}); $i++) {\n\tpush(@roots, $config{\"extraroot_$i\"});\n\t}\nchdir($roots[0]);\neval { $user_homedir = (getpwuid($<))[7]; };\nif ($@) {\n\t# getpwuid doesn't work on windows\n\t$user_homedir = $ENV{\"HOME\"} || $ENV{\"USERPROFILE\"} || \"/\";\n\t$on_windows = 1;\n\t}\n\n# Read users file\n&read_users_file();\n\n# Setup SSL if possible and if requested\nif (!-r $config{'keyfile'}) {\n\t# Key file doesn't exist!\n\tif ($config{'keyfile'}) {\n\t\tprint STDERR \"SSL key file $config{'keyfile'} does not exist\\n\";\n\t\t}\n\t$use_ssl = 0;\n\t}\nelsif ($config{'certfile'} && !-r $config{'certfile'}) {\n\t# Cert file doesn't exist!\n\tprint STDERR \"SSL cert file $config{'certfile'} does not exist\\n\";\n\t$use_ssl = 0;\n\t}\n@ipkeys = &get_ipkeys(\\%config);\nif ($use_ssl) {\n\tif ($config{'ssl_version'}) {\n\t\t# Force an SSL version\n\t\t$Net::SSLeay::version = $config{'ssl_version'};\n\t\t$Net::SSLeay::ssl_version = $config{'ssl_version'};\n\t\t}\n\t$client_certs = 0 if (!-r $config{'ca'} || !%certs);\n\t$ctx = &create_ssl_context($config{'keyfile'},\n\t\t\t\t   $config{'certfile'},\n\t\t\t\t   $config{'extracas'});\n\t$ctx || die \"Failed to create default SSL context\";\n\t$ssl_contexts{\"*\"} = $ctx;\n\tforeach $ipkey (@ipkeys) {\n\t\t$ctx = &create_ssl_context($ipkey->{'key'}, $ipkey->{'cert'},\n\t\t\t\t   $ipkey->{'extracas'} || $config{'extracas'});\n\t\tif ($ctx) {\n\t\t\tforeach $ip (@{$ipkey->{'ips'}}) {\n\t\t\t\t$ssl_contexts{$ip} = $ctx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Setup per-hostname SSL contexts on the main IP\n\tif (defined(&Net::SSLeay::CTX_set_tlsext_servername_callback)) {\n\t\tNet::SSLeay::CTX_set_tlsext_servername_callback(\n\t\t    $ssl_contexts{\"*\"},\n\t\t    sub {\n\t\t\tmy $ssl = shift;\n\t\t\tmy $h = Net::SSLeay::get_servername($ssl);\n\t\t\tmy $c = $ssl_contexts{$h} ||\n\t\t\t\t$h =~ /^[^\\.]+\\.(.*)$/ && $ssl_contexts{\"*.$1\"};\n\t\t\tif ($c) {\n\t\t\t\tNet::SSLeay::set_SSL_CTX($ssl, $c);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n# Load gzip library if enabled\nif ($config{'gzip'} eq '1') {\n\teval \"use Compress::Zlib\";\n\tif (!$@) {\n\t\t$use_gzip = 1;\n\t\t}\n\t}\n\n# Setup syslog support if possible and if requested\nif ($use_syslog) {\n\topen(ERRDUP, \">&STDERR\");\n\topen(STDERR, \">/dev/null\");\n\t$log_socket = $config{\"logsock\"} || \"unix\";\n\teval 'openlog($config{\"pam\"}, \"cons,pid,ndelay\", \"authpriv\"); setlogsock($log_socket)';\n\tif ($@) {\n\t\t$use_syslog = 0;\n\t\t}\n\telse {\n\t\tlocal $msg = ucfirst($config{'pam'}).\" starting\";\n\t\teval { syslog(\"info\", \"%s\", $msg); };\n\t\tif ($@) {\n\t\t\teval {\n\t\t\t\tsetlogsock(\"inet\");\n\t\t\t\tsyslog(\"info\", \"%s\", $msg);\n\t\t\t\t};\n\t\t\tif ($@) {\n\t\t\t\t# All attempts to use syslog have failed..\n\t\t\t\t$use_syslog = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\topen(STDERR, \">&ERRDUP\");\n\tclose(ERRDUP);\n\t}\n\n# Read MIME types file and add extra types\n&read_mime_types();\n\n# get the time zone\nif ($config{'log'}) {\n\tlocal(@gmt, @lct, $days, $hours, $mins);\n\t@gmt = gmtime(time());\n\t@lct = localtime(time());\n\t$days = $lct[3] - $gmt[3];\n\t$hours = ($days < -1 ? 24 : 1 < $days ? -24 : $days * 24) +\n\t\t $lct[2] - $gmt[2];\n\t$mins = $hours * 60 + $lct[1] - $gmt[1];\n\t$timezone = ($mins < 0 ? \"-\" : \"+\"); $mins = abs($mins);\n\t$timezone .= sprintf \"%2.2d%2.2d\", $mins/60, $mins%60;\n\t}\n\n# Build various maps from the config files\n&build_config_mappings();\n\n# start up external authentication program, if needed\nif ($config{'extauth'}) {\n\tsocketpair(EXTAUTH, EXTAUTH2, AF_UNIX, SOCK_STREAM, PF_UNSPEC);\n\tif (!($extauth = fork())) {\n\t\tclose(EXTAUTH);\n\t\tclose(STDIN);\n\t\tclose(STDOUT);\n\t\topen(STDIN, \"<&EXTAUTH2\");\n\t\topen(STDOUT, \">&EXTAUTH2\");\n\t\texec($config{'extauth'}) or die \"exec failed : $!\\n\";\n\t\t}\n\tclose(EXTAUTH2);\n\tlocal $os = select(EXTAUTH);\n\t$| = 1; select($os);\n\t}\n\n# Pre-load any libraries\nif (!$config{'inetd'}) {\n\tforeach $pl (split(/\\s+/, $config{'preload'})) {\n\t\t($pkg, $lib) = split(/=/, $pl);\n\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\teval \"package $pkg; do '$config{'root'}/$lib'\";\n\t\tif ($@) {\n\t\t\tprint STDERR \"Failed to pre-load $lib in $pkg : $@\\n\";\n\t\t\t}\n\t\t}\n\tforeach $pl (split(/\\s+/, $config{'premodules'})) {\n\t\tif ($pl =~ /\\//) {\n\t\t\t($dir, $mod) = split(/\\//, $pl);\n\t\t\t}\n\t\telse {\n\t\t\t($dir, $mod) = (undef, $pl);\n\t\t\t}\n\t\tpush(@INC, \"$config{'root'}/$dir\");\n\t\teval \"package $mod; use $mod ()\";\n\t\tif ($@) {\n\t\t\tprint STDERR \"Failed to pre-load $mod : $@\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n# Open debug log if set\nif ($config{'debuglog'}) {\n\topen(DEBUG, \">>$config{'debuglog'}\");\n\tchmod(0700, $config{'debuglog'});\n\tselect(DEBUG); $| = 1; select(STDOUT);\n\tprint DEBUG \"miniserv.pl starting ..\\n\";\n\t}\n\n# Write out (empty) blocked hosts file\n&write_blocked_file();\n\n# Initially read webmin cron functions and last execution times\n&read_webmin_crons();\n%webmincron_last = ( );\n&read_file($config{'webmincron_last'}, \\%webmincron_last);\n\n# Pre-cache lang files\n&precache_files();\n\n# Clear any flag files to prevent restart loops\nunlink($config{'restartflag'}) if ($config{'restartflag'});\nunlink($config{'reloadflag'}) if ($config{'reloadflag'});\nunlink($config{'stopflag'}) if ($config{'stopflag'});\n\nif ($config{'inetd'}) {\n\t# We are being run from inetd - go direct to handling the request\n\t&redirect_stderr_to_log();\n\t$SIG{'HUP'} = 'IGNORE';\n\t$SIG{'TERM'} = 'DEFAULT';\n\t$SIG{'PIPE'} = 'DEFAULT';\n\topen(SOCK, \"+>&STDIN\");\n\n\t# Check if it is time for the logfile to be cleared\n\tif ($config{'logclear'}) {\n\t\tlocal $write_logtime = 0;\n\t\tlocal @st = stat(\"$config{'logfile'}.time\");\n\t\tif (@st) {\n\t\t\tif ($st[9]+$config{'logtime'}*60*60 < time()){\n\t\t\t\t# need to clear log\n\t\t\t\t$write_logtime = 1;\n\t\t\t\tunlink($config{'logfile'});\n\t\t\t\t}\n\t\t\t}\n\t\telse { $write_logtime = 1; }\n\t\tif ($write_logtime) {\n\t\t\topen(LOGTIME, \">$config{'logfile'}.time\");\n\t\t\tprint LOGTIME time(),\"\\n\";\n\t\t\tclose(LOGTIME);\n\t\t\t}\n\t\t}\n\n\t# Work out if IPv6 is being used locally\n\tlocal $sn = getsockname(SOCK);\n\tprint DEBUG \"sn=$sn\\n\";\n\tprint DEBUG \"length=\",length($sn),\"\\n\";\n\t$localipv6 = length($sn) > 16;\n\tprint DEBUG \"localipv6=$localipv6\\n\";\n\n\t# Initialize SSL for this connection\n\tif ($use_ssl) {\n\t\t$ssl_con = &ssl_connection_for_ip(SOCK, $localipv6);\n\t\t$ssl_con || exit;\n\t\t}\n\n\t# Work out the hostname for this web server\n\t$host = &get_socket_name(SOCK, $localipv6);\n\tprint DEBUG \"host=$host\\n\";\n\t$host || exit;\n\t$port = $config{'port'};\n\t$acptaddr = getpeername(SOCK);\n\tprint DEBUG \"acptaddr=$acptaddr\\n\";\n\tprint DEBUG \"length=\",length($acptaddr),\"\\n\";\n\t$acptaddr || exit;\n\n\t# Work out remote and local IPs\n\t$ipv6 = length($acptaddr) > 16;\n\tprint DEBUG \"ipv6=$ipv6\\n\";\n\t(undef, $locala) = &get_socket_ip(SOCK, $localipv6);\n\tprint DEBUG \"locala=$locala\\n\";\n\t(undef, $peera, undef) = &get_address_ip($acptaddr, $ipv6);\n\tprint DEBUG \"peera=$peera\\n\";\n\n\tprint DEBUG \"main: Starting handle_request loop pid=$$\\n\";\n\twhile(&handle_request($peera, $locala, $ipv6)) { }\n\tprint DEBUG \"main: Done handle_request loop pid=$$\\n\";\n\tclose(SOCK);\n\texit;\n\t}\n\n# Build list of sockets to listen on\n@listening_on_ports = ();\n$config{'bind'} = '' if ($config{'bind'} eq '*');\nif ($config{'bind'}) {\n\t# Listening on a specific IP\n\tif (&check_ip6address($config{'bind'})) {\n\t\t# IP is v6\n\t\t$use_ipv6 || die \"Cannot bind to $config{'bind'} without IPv6\";\n\t\tpush(@sockets, [ inet_pton(AF_INET6(),$config{'bind'}),\n\t\t\t\t $config{'port'},\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\telse {\n\t\t# IP is v4\n\t\tpush(@sockets, [ inet_aton($config{'bind'}),\n\t\t\t\t $config{'port'},\n\t\t\t\t PF_INET() ]);\n\t\t}\n\t}\nelse {\n\t# Listening on all IPs\n\tpush(@sockets, [ INADDR_ANY, $config{'port'}, PF_INET() ]);\n\tif ($use_ipv6) {\n\t\t# Also IPv6\n\t\tpush(@sockets, [ in6addr_any(), $config{'port'},\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\t}\nforeach $s (split(/\\s+/, $config{'sockets'})) {\n\tif ($s =~ /^(\\d+)$/) {\n\t\t# Just listen on another port on the main IP\n\t\tpush(@sockets, [ $sockets[0]->[0], $s, $sockets[0]->[2] ]);\n\t\tif ($use_ipv6 && !$config{'bind'}) {\n\t\t\t# Also listen on that port on the main IPv6 address\n\t\t\tpush(@sockets, [ $sockets[1]->[0], $s,\n\t\t\t\t\t $sockets[1]->[2] ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^\\*:(\\d+)$/) {\n\t\t# Listening on all IPs on some port\n\t\tpush(@sockets, [ INADDR_ANY, $1,\n\t\t\t\t PF_INET() ]);\n\t\tif ($use_ipv6) {\n\t\t\tpush(@sockets, [ in6addr_any(), $1,\n\t\t\t\t\t PF_INET6() ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^(\\S+):(\\d+)$/) {\n\t\t# Listen on a specific port and IP\n\t\tmy ($ip, $port) = ($1, $2);\n\t\tif (&check_ip6address($ip)) {\n\t\t\t$use_ipv6 || die \"Cannot bind to $ip without IPv6\";\n\t\t\tpush(@sockets, [ inet_pton(AF_INET6(),\n\t\t\t\t\t\t   $ip),\n\t\t\t\t\t $port, PF_INET6() ]);\n\t\t\t}\n\t\telse {\n\t\t\tpush(@sockets, [ inet_aton($ip), $port,\n\t\t\t\t\t PF_INET() ]);\n\t\t\t}\n\t\t}\n\telsif ($s =~ /^([0-9\\.]+):\\*$/ || $s =~ /^([0-9\\.]+)$/) {\n\t\t# Listen on the main port on another IPv4 address\n\t\tpush(@sockets, [ inet_aton($1), $sockets[0]->[1],\n\t\t\t\t PF_INET() ]);\n\t\t}\n\telsif (($s =~ /^([0-9a-f\\:]+):\\*$/ || $s =~ /^([0-9a-f\\:]+)$/) &&\n\t       $use_ipv6) {\n\t\t# Listen on the main port on another IPv6 address\n\t\tpush(@sockets, [ inet_pton(AF_INET6(), $1),\n\t\t\t\t $sockets[0]->[1],\n\t\t\t\t PF_INET6() ]);\n\t\t}\n\t}\n\n# Open all the sockets\n$proto = getprotobyname('tcp');\n@sockerrs = ( );\n$tried_inaddr_any = 0;\nfor($i=0; $i<@sockets; $i++) {\n\t$fh = \"MAIN$i\";\n\tif (!socket($fh, $sockets[$i]->[2], SOCK_STREAM, $proto)) {\n\t\t# Protocol not supported\n\t\tpush(@sockerrs, \"Failed to open socket family $sockets[$i]->[2] : $!\");\n\t\tnext;\n\t\t}\n\tsetsockopt($fh, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\tif ($sockets[$i]->[2] eq PF_INET()) {\n\t\t$pack = pack_sockaddr_in($sockets[$i]->[1], $sockets[$i]->[0]);\n\t\t}\n\telse {\n\t\t$pack = pack_sockaddr_in6($sockets[$i]->[1], $sockets[$i]->[0]);\n\t\tsetsockopt($fh, 41, 26, pack(\"l\", 1));\t# IPv6 only\n\t\t}\n\tfor($j=0; $j<5; $j++) {\n\t\tlast if (bind($fh, $pack));\n\t\tsleep(1);\n\t\t}\n\tif ($j == 5) {\n\t\t# All attempts failed .. give up\n\t\tif ($sockets[$i]->[0] eq INADDR_ANY ||\n\t\t    $use_ipv6 && $sockets[$i]->[0] eq in6addr_any()) {\n\t\t\tpush(@sockerrs,\n\t\t\t     \"Failed to bind to port $sockets[$i]->[1] : $!\");\n\t\t\t$tried_inaddr_any = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$ip = &network_to_address($sockets[$i]->[0]);\n\t\t\tpush(@sockerrs,\n\t\t\t     \"Failed to bind to IP $ip port \".\n\t\t\t     \"$sockets[$i]->[1] : $!\");\n\t\t\t}\n\t\t}\n\telse {\n\t\tlisten($fh, &get_somaxconn());\n\t\tpush(@socketfhs, $fh);\n\t\tpush(@listening_on_ports, $sockets[$i]->[1]);\n\t\t$ipv6fhs{$fh} = $sockets[$i]->[2] eq PF_INET() ? 0 : 1;\n\t\t}\n\t}\nforeach $se (@sockerrs) {\n\tprint STDERR $se,\"\\n\";\n\t}\n\n# If all binds failed, try binding to any address\nif (!@socketfhs && !$tried_inaddr_any) {\n\tprint STDERR \"Falling back to listening on any address\\n\";\n\t$fh = \"MAIN\";\n\tsocket($fh, PF_INET(), SOCK_STREAM, $proto) ||\n\t\tdie \"Failed to open socket : $!\";\n\tsetsockopt($fh, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\tif (!bind($fh, pack_sockaddr_in($sockets[0]->[1], INADDR_ANY))) {\n\t\tprint STDERR \"Failed to bind to port $sockets[0]->[1] : $!\\n\";\n\t\texit(1);\n\t\t}\n\tlisten($fh, &get_somaxconn());\n\tpush(@socketfhs, $fh);\n\t}\nelsif (!@socketfhs && $tried_inaddr_any) {\n\tprint STDERR \"Could not listen on any ports\";\n\texit(1);\n\t}\n\nif ($config{'listen'}) {\n\t# Open the socket that allows other webmin servers to find this one\n\t$proto = getprotobyname('udp');\n\tif (socket(LISTEN, PF_INET(), SOCK_DGRAM, $proto)) {\n\t\tsetsockopt(LISTEN, SOL_SOCKET, SO_REUSEADDR, pack(\"l\", 1));\n\t\tbind(LISTEN, pack_sockaddr_in($config{'listen'}, INADDR_ANY));\n\t\tlisten(LISTEN, &get_somaxconn());\n\t\t}\n\telse {\n\t\t$config{'listen'} = 0;\n\t\t}\n\t}\n\n# Split from the controlling terminal, unless configured not to\nif (!$config{'nofork'} && !$nofork_argv) {\n\tif (fork()) { exit; }\n\t}\neval { setsid(); };\t# may not work on Windows\n\n# Close standard file handles\nopen(STDIN, \"</dev/null\");\nopen(STDOUT, \">/dev/null\");\n&redirect_stderr_to_log();\n&log_error(\"miniserv.pl started\");\nforeach $msg (@startup_msg) {\n\t&log_error($msg);\n\t}\n\n# write out the PID file\n&write_pid_file();\n$miniserv_main_pid = $$;\n\n# Start the log-clearing process, if needed. This checks every minute\n# to see if the log has passed its reset time, and if so clears it\nif ($config{'logclear'}) {\n\tif (!($logclearer = fork())) {\n\t\t&close_all_sockets();\n\t\tclose(LISTEN);\n\t\twhile(1) {\n\t\t\tlocal $write_logtime = 0;\n\t\t\tlocal @st = stat(\"$config{'logfile'}.time\");\n\t\t\tif (@st) {\n\t\t\t\tif ($st[9]+$config{'logtime'}*60*60 < time()){\n\t\t\t\t\t# need to clear log\n\t\t\t\t\t$write_logtime = 1;\n\t\t\t\t\tunlink($config{'logfile'});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse { $write_logtime = 1; }\n\t\t\tif ($write_logtime) {\n\t\t\t\topen(LOGTIME, \">$config{'logfile'}.time\");\n\t\t\t\tprint LOGTIME time(),\"\\n\";\n\t\t\t\tclose(LOGTIME);\n\t\t\t\t}\n\t\t\tsleep(5*60);\n\t\t\t}\n\t\texit;\n\t\t}\n\tpush(@childpids, $logclearer);\n\t}\n\n# Setup the logout time dbm if needed\nif ($config{'session'}) {\n\teval \"use SDBM_File\";\n\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\teval \"\\$sessiondb{'1111111111'} = 'foo bar';\";\n\tif ($@) {\n\t\tdbmclose(%sessiondb);\n\t\teval \"use NDBM_File\";\n\t\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\t\t}\n\telse {\n\t\tdelete($sessiondb{'1111111111'});\n\t\t}\n\t}\n\n# Run the main loop\n$SIG{'HUP'} = 'miniserv::trigger_restart';\n$SIG{'TERM'} = 'miniserv::term_handler';\n$SIG{'USR1'} = 'miniserv::trigger_reload';\n$SIG{'PIPE'} = 'IGNORE';\nlocal $remove_session_count = 0;\n$need_pipes = $config{'passdelay'} || $config{'session'};\n$cron_runs = 0;\nwhile(1) {\n\t# Check if any webmin cron jobs are ready to run\n\t&execute_ready_webmin_crons($cron_runs++);\n\n\t# wait for a new connection, or a message from a child process\n\tlocal ($i, $rmask);\n\tif (@childpids <= $config{'maxconns'}) {\n\t\t# Only accept new main socket connects when ready\n\t\tlocal $s;\n\t\tforeach $s (@socketfhs) {\n\t\t\tvec($rmask, fileno($s), 1) = 1;\n\t\t\t}\n\t\t}\n\telse {\n\t\tprintf STDERR \"too many children (%d > %d)\\n\",\n\t\t\tscalar(@childpids), $config{'maxconns'};\n\t\t}\n\tif ($need_pipes) {\n\t\tfor($i=0; $i<@passin; $i++) {\n\t\t\tvec($rmask, fileno($passin[$i]), 1) = 1;\n\t\t\t}\n\t\t}\n\tvec($rmask, fileno(LISTEN), 1) = 1 if ($config{'listen'});\n\n\t# Wait for a connection\n\tlocal $sel = select($rmask, undef, undef, 2);\n\n\t# Check the flag files\n\tif ($config{'restartflag'} && -r $config{'restartflag'}) {\n\t\tunlink($config{'restartflag'});\n\t\t$need_restart = 1;\n\t\t}\n\tif ($config{'reloadflag'} && -r $config{'reloadflag'}) {\n\t\tunlink($config{'reloadflag'});\n\t\t$need_reload = 1;\n\t\t}\n\tif ($config{'stopflag'} && -r $config{'stopflag'}) {\n\t\tunlink($config{'stopflag'});\n\t\t$need_stop = 1;\n\t\t}\n\n\tif ($need_restart) {\n\t\t# Got a HUP signal while in select() .. restart now\n\t\t&restart_miniserv();\n\t\t}\n\tif ($need_reload) {\n\t\t# Got a USR1 signal while in select() .. re-read config\n\t\t$need_reload = 0;\n\t\t&reload_config_file();\n\t\t}\n\tif ($need_stop) {\n\t\t# Stop flag file created\n\t\t&term_handler();\n\t\t}\n\tlocal $time_now = time();\n\n\t# Clean up finished processes\n\tlocal $pid;\n\tdo {\t$pid = waitpid(-1, WNOHANG);\n\t\t@childpids = grep { $_ != $pid } @childpids;\n\t\t} while($pid != 0 && $pid != -1);\n\t@childpids = grep { kill(0, $_) } @childpids;\n\n\t# run the unblocking procedure to check if enough time has passed to\n\t# unblock hosts that never been blocked because of password failures\n\t$unblocked = 0;\n\tif ($config{'blockhost_failures'}) {\n\t\t$i = 0;\n\t\twhile ($i <= $#deny) {\n\t\t\tif ($blockhosttime{$deny[$i]} &&\n\t\t\t    $config{'blockhost_time'} != 0 &&\n\t\t\t    ($time_now - $blockhosttime{$deny[$i]}) >=\n\t\t\t     $config{'blockhost_time'}) {\n\t\t\t\t# the host can be unblocked now\n\t\t\t\t$hostfail{$deny[$i]} = 0;\n\t\t\t\tsplice(@deny, $i, 1);\n\t\t\t\t$unblocked = 1;\n\t\t\t\t}\n\t\t\t$i++;\n\t\t\t}\n\t\t}\n\n\t# Do the same for blocked users\n\tif ($config{'blockuser_failures'}) {\n\t\t$i = 0;\n\t\twhile ($i <= $#deny) {\n\t\t\tif ($blockusertime{$deny[$i]} &&\n\t\t\t    $config{'blockuser_time'} != 0 &&\n\t\t\t    ($time_now - $blockusertime{$deny[$i]}) >=\n\t\t\t     $config{'blockuser_time'}) {\n\t\t\t\t# the user can be unblocked now\n\t\t\t\t$userfail{$deny[$i]} = 0;\n\t\t\t\tsplice(@denyusers, $i, 1);\n\t\t\t\t$unblocked = 1;\n\t\t\t\t}\n\t\t\t$i++;\n\t\t\t}\n\t\t}\n\tif ($unblocked) {\n\t\t&write_blocked_file();\n\t\t}\n\n\tif ($config{'session'} && (++$remove_session_count%50) == 0) {\n\t\t# Remove sessions with more than 7 days of inactivity,\n\t\tlocal $s;\n\t\tforeach $s (keys %sessiondb) {\n\t\t\tlocal ($user, $ltime, $lip) =\n\t\t\t\tsplit(/\\s+/, $sessiondb{$s});\n\t\t\tif ($ltime && $time_now - $ltime > 7*24*60*60) {\n\t\t\t\t&run_logout_script($s, $user, undef, undef);\n\t\t\t\t&write_logout_utmp($user, $lip);\n\t\t\t\tif ($user =~ /^\\!/ || $sessiondb{$s} eq '') {\n\t\t\t\t\t# Don't log anything for logged out\n\t\t\t\t\t# sessions or those with no data\n\t\t\t\t\t}\n\t\t\t\telsif ($use_syslog && $user) {\n\t\t\t\t\tsyslog(\"info\", \"%s\",\n\t\t\t\t\t      \"Timeout of session for $user\");\n\t\t\t\t\t}\n\t\t\t\telsif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\",\n\t\t\t\t\t      \"Timeout of unknown session $s \".\n\t\t\t\t\t      \"with value $sessiondb{$s}\");\n\t\t\t\t\t}\n\t\t\t\tdelete($sessiondb{$s});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif ($use_pam && $config{'pam_conv'}) {\n\t\t# Remove PAM sessions with more than 5 minutes of inactivity\n\t\tlocal $c;\n\t\tforeach $c (values %conversations) {\n\t\t\tif ($time_now - $c->{'time'} > 5*60) {\n\t\t\t\t&end_pam_conversation($c);\n\t\t\t\tif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\", \"Timeout of PAM \".\n\t\t\t\t\t\t\"session for $c->{'user'}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Don't check any sockets if there is no activity\n\tnext if ($sel <= 0);\n\n\t# Check if any of the main sockets have received a new connection\n\tlocal $sn = 0;\n\tforeach $s (@socketfhs) {\n\t\tif (vec($rmask, fileno($s), 1)) {\n\t\t\t# got new connection\n\t\t\t$acptaddr = accept(SOCK, $s);\n\t\t\tprint DEBUG \"accept returned \",length($acptaddr),\"\\n\";\n\t\t\tif (!$acptaddr) { next; }\n\t\t\tbinmode(SOCK);\n\n\t\t\t# create pipes\n\t\t\tlocal ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\n\t\t\tif ($need_pipes) {\n\t\t\t\t($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw) =\n\t\t\t\t\t&allocate_pipes();\n\t\t\t\t}\n\n\t\t\t# Work out IP and port of client\n\t\t\tlocal ($peerb, $peera, $peerp) =\n\t\t\t\t&get_address_ip($acptaddr, $ipv6fhs{$s});\n\t\t\tprint DEBUG \"peera=$peera peerp=$peerp\\n\";\n\n\t\t\t# Work out the local IP\n\t\t\t(undef, $locala) = &get_socket_ip(SOCK, $ipv6fhs{$s});\n\t\t\tprint DEBUG \"locala=$locala\\n\";\n\n\t\t\t# Check username of connecting user\n\t\t\t$localauth_user = undef;\n\t\t\tif ($config{'localauth'} && $peera eq \"127.0.0.1\") {\n\t\t\t\tif (open(TCP, \"/proc/net/tcp\")) {\n\t\t\t\t\t# Get the info direct from the kernel\n\t\t\t\t\t$peerh = sprintf(\"%4.4X\", $peerp);\n\t\t\t\t\twhile(<TCP>) {\n\t\t\t\t\t\ts/^\\s+//;\n\t\t\t\t\t\tlocal @t = split(/[\\s:]+/, $_);\n\t\t\t\t\t\tif ($t[1] eq '0100007F' &&\n\t\t\t\t\t\t    $t[2] eq $peerh) {\n\t\t\t\t\t\t\t$localauth_user =\n\t\t\t\t\t\t\t    getpwuid($t[11]);\n\t\t\t\t\t\t\tlast;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tclose(TCP);\n\t\t\t\t\t}\n\t\t\t\tif (!$localauth_user) {\n\t\t\t\t\t# Call lsof for the info\n\t\t\t\t\tlocal $lsofpid = open(LSOF,\n\t\t\t\t\t\t\"$config{'localauth'} -i \".\n\t\t\t\t\t\t\"TCP\\@127.0.0.1:$peerp |\");\n\t\t\t\t\twhile(<LSOF>) {\n\t\t\t\t\t\tif (/^(\\S+)\\s+(\\d+)\\s+(\\S+)/ &&\n\t\t\t\t\t\t    $2 != $$ && $2 != $lsofpid){\n\t\t\t\t\t\t\t$localauth_user = $3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tclose(LSOF);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t# Work out the hostname for this web server\n\t\t\t$host = &get_socket_name(SOCK, $ipv6fhs{$s});\n\t\t\tif (!$host) {\n\t\t\t\tprint STDERR\n\t\t\t\t    \"Failed to get local socket name : $!\\n\";\n\t\t\t\tclose(SOCK);\n\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t$port = $sockets[$sn]->[1];\n\n\t\t\t# fork the subprocess\n\t\t\tlocal $handpid;\n\t\t\tif (!($handpid = fork())) {\n\t\t\t\t# setup signal handlers\n\t\t\t\tprint DEBUG \"in subprocess\\n\";\n\t\t\t\t$SIG{'TERM'} = 'DEFAULT';\n\t\t\t\t$SIG{'PIPE'} = 'DEFAULT';\n\t\t\t\t#$SIG{'CHLD'} = 'IGNORE';\n\t\t\t\t$SIG{'HUP'} = 'IGNORE';\n\t\t\t\t$SIG{'USR1'} = 'IGNORE';\n\n\t\t\t\t# Close the file handle for the session DBM\n\t\t\t\tdbmclose(%sessiondb);\n\n\t\t\t\t# close useless pipes\n\t\t\t\tif ($need_pipes) {\n\t\t\t\t\t&close_all_pipes();\n\t\t\t\t\tclose($PASSINr); close($PASSOUTw);\n\t\t\t\t\t}\n\t\t\t\t&close_all_sockets();\n\t\t\t\tclose(LISTEN);\n\n\t\t\t\t# Initialize SSL for this connection\n\t\t\t\tif ($use_ssl) {\n\t\t\t\t\t$ssl_con = &ssl_connection_for_ip(\n\t\t\t\t\t\t\tSOCK, $ipv6fhs{$s});\n\t\t\t\t\tprint DEBUG \"ssl_con returned $ssl_con\\n\";\n\t\t\t\t\t$ssl_con || exit;\n\t\t\t\t\t}\n\n\t\t\t\tprint DEBUG\n\t\t\t\t  \"main: Starting handle_request loop pid=$$\\n\";\n\t\t\t\twhile(&handle_request($peera, $locala,\n\t\t\t\t\t\t      $ipv6fhs{$s})) {\n\t\t\t\t\t# Loop until keepalive stops\n\t\t\t\t\t}\n\t\t\t\tprint DEBUG\n\t\t\t\t  \"main: Done handle_request loop pid=$$\\n\";\n\t\t\t\tshutdown(SOCK, 1);\n\t\t\t\tclose(SOCK);\n\t\t\t\tclose($PASSINw); close($PASSOUTw);\n\t\t\t\texit;\n\t\t\t\t}\n\t\t\tpush(@childpids, $handpid);\n\t\t\tif ($need_pipes) {\n\t\t\t\tclose($PASSINw); close($PASSOUTr);\n\t\t\t\tpush(@passin, $PASSINr);\n\t\t\t\tpush(@passout, $PASSOUTw);\n\t\t\t\t}\n\t\t\tclose(SOCK);\n\t\t\t}\n\t\t$sn++;\n\t\t}\n\n\tif ($config{'listen'} && vec($rmask, fileno(LISTEN), 1)) {\n\t\t# Got UDP packet from another webmin server\n\t\tlocal $rcvbuf;\n\t\tlocal $from = recv(LISTEN, $rcvbuf, 1024, 0);\n\t\tnext if (!$from);\n\t\tlocal $fromip = inet_ntoa((unpack_sockaddr_in($from))[1]);\n\t\tlocal $toip = inet_ntoa((unpack_sockaddr_in(\n\t\t\t\t\t getsockname(LISTEN)))[1]);\n\t\tif ((!@deny || !&ip_match($fromip, $toip, @deny)) &&\n\t\t    (!@allow || &ip_match($fromip, $toip, @allow))) {\n\t\t\tlocal $listenhost = &get_socket_name(LISTEN, 0);\n\t\t\tsend(LISTEN, \"$listenhost:$config{'port'}:\".\n\t\t\t\t ($use_ssl || $config{'inetd_ssl'} ? 1 : 0).\":\".\n\t\t\t\t ($config{'listenhost'} ?\n\t\t\t\t\t&get_system_hostname() : \"\"),\n\t\t\t\t 0, $from)\n\t\t\t\tif ($listenhost);\n\t\t\t}\n\t\t}\n\n\t# check for session, password-timeout and PAM messages from subprocesses\n\tfor($i=0; $i<@passin; $i++) {\n\t\tif (vec($rmask, fileno($passin[$i]), 1)) {\n\t\t\t# this sub-process is asking about a password\n\t\t\tlocal $infd = $passin[$i];\n\t\t\tlocal $outfd = $passout[$i];\n\t\t\tlocal $inline = &sysread_line($infd);\n\t\t\tif ($inline) {\n\t\t\t\tprint DEBUG \"main: inline $inline\";\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprint DEBUG \"main: inline EOF\\n\";\n\t\t\t\t}\n\n\t\t\t# Search for two-factor authentication flag\n\t\t\t# being passed, to mark the call as safe\n\t\t\t$inline =~ /^delay\\s+(\\S+)\\s+(\\S+)\\s+(\\d+)\\s+(nolog)/;\n\t\t\tlocal $nolog = $4;\n\n\t\t\tif ($inline =~ /^delay\\s+(\\S+)\\s+(\\S+)\\s+(\\d+)/) {\n\t\t\t\t# Got a delay request from a subprocess.. for\n\t\t\t\t# valid logins, there is no delay (to prevent\n\t\t\t\t# denial of service attacks), but for invalid\n\t\t\t\t# logins the delay increases with each failed\n\t\t\t\t# attempt.\n\t\t\t\tif ($3) {\n\t\t\t\t\t# login OK.. no delay\n\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t$wasblocked = $hostfail{$2} ||\n\t\t\t\t\t\t      $userfail{$1};\n\t\t\t\t\t$hostfail{$2} = 0;\n\t\t\t\t\t$userfail{$1} = 0;\n\t\t\t\t\tif ($wasblocked) {\n\t\t\t\t\t\t&write_blocked_file();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Login failed..\n\t\t\t\t\t$hostfail{$2}++ if(!$nolog);\n\t\t\t\t\t$userfail{$1}++ if(!$nolog);\n\t\t\t\t\t$blocked = 0;\n\n\t\t\t\t\t# Add the host to the block list,\n\t\t\t\t\t# if configured\n \t\t\t\t\tif ($config{'blockhost_failures'} &&\n\t\t\t\t\t    $hostfail{$2} >=\n\t\t\t\t\t      $config{'blockhost_failures'}) {\n\t\t\t\t\t\tpush(@deny, $2);\n\t\t\t\t\t\t$blockhosttime{$2} = $time_now;\n\t\t\t\t\t\t$blocked = 1;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = \"Security alert: Host $2 blocked after $config{'blockhost_failures'} failed logins for user $1\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Add the user to the user block list,\n\t\t\t\t\t# if configured\n \t\t\t\t\tif ($config{'blockuser_failures'} &&\n\t\t\t\t\t    $userfail{$1} >=\n\t\t\t\t\t      $config{'blockuser_failures'}) {\n\t\t\t\t\t\tpush(@denyusers, $1);\n\t\t\t\t\t\t$blockusertime{$1} = $time_now;\n\t\t\t\t\t\t$blocked = 2;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = \"Security alert: User $1 blocked after $config{'blockuser_failures'} failed logins\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Lock out the user's password, if enabled\n\t\t\t\t\tif ($config{'blocklock'} &&\n\t\t\t\t\t    $userfail{$1} >=\n\t\t\t\t\t      $config{'blockuser_failures'}) {\n\t\t\t\t\t\tmy $lk = &lock_user_password($1);\n\t\t\t\t\t\t$blocked = 2;\n\t\t\t\t\t\tif ($use_syslog) {\n\t\t\t\t\t\t\tlocal $logtext = $lk == 1 ? \"Security alert: User $1 locked after $config{'blockuser_failures'} failed logins\" : $lk < 0 ? \"Security alert: User could not be locked\" : \"Security alert: User is already locked\";\n\t\t\t\t\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t\t\t\t\t\t$logtext);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t# Send back a delay\n\t\t\t\t\t$dl = $userdlay{$1} -\n\t\t\t\t           int(($time_now - $userlast{$1})/50);\n\t\t\t\t\t$dl = $dl < 0 ? 0 : $dl+1;\n\t\t\t\t\tprint $outfd \"$dl $blocked\\n\";\n\t\t\t\t\t$userdlay{$1} = $dl;\n\n\t\t\t\t\t# Write out blocked status file\n\t\t\t\t\tif ($blocked) {\n\t\t\t\t\t\t&write_blocked_file();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t$userlast{$1} = $time_now;\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^verify\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t\t# Verifying a session ID\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $notimeout = $2;\n\t\t\t\tlocal $vip = $3;\n\t\t\t\tlocal $skey = $sessiondb{$session_id} ?\n\t\t\t\t\t\t$session_id : \n\t\t\t\t\t\t&hash_session_id($session_id);\n\t\t\t\tif (!defined($sessiondb{$skey})) {\n\t\t\t\t\t# Session doesn't exist\n\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlocal ($user, $ltime, $ip) =\n\t\t\t\t\t  split(/\\s+/, $sessiondb{$skey});\n\t\t\t\t\tlocal $lot = &get_logout_time($user, $session_id);\n\t\t\t\t\tif ($lot &&\n\t\t\t\t\t    $time_now - $ltime > $lot*60 &&\n\t\t\t\t\t    !$notimeout) {\n\t\t\t\t\t\t# Session has timed out\n\t\t\t\t\t\tprint $outfd \"1 \",$time_now - $ltime,\"\\n\";\n\t\t\t\t\t\t#delete($sessiondb{$skey});\n\t\t\t\t\t\t}\n\t\t\t\t\telsif ($ip && $vip && $ip ne $vip &&\n\t\t\t\t\t       $config{'session_ip'}) {\n\t\t\t\t\t\t# Session was OK, but from the\n\t\t\t\t\t\t# wrong IP address\n\t\t\t\t\t\tprint $outfd \"3 $ip\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\telsif ($user =~ /^\\!/) {\n\t\t\t\t\t\t# Logged out session\n\t\t\t\t\t\tprint $outfd \"0 0\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t# Session is OK\n\t\t\t\t\t\tprint $outfd \"2 $user\\n\";\n\t\t\t\t\t\t$sessiondb{$skey} = \"$user $time_now $ip\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^new\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t\t# Creating a new session\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $user = $2;\n\t\t\t\tlocal $ip = $3;\n\t\t\t\t$sessiondb{&hash_session_id($session_id)} =\n\t\t\t\t\t\"$user $time_now $ip\";\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^delete\\s+(\\S+)/) {\n\t\t\t\t# Logging out a session\n\t\t\t\tlocal $session_id = $1;\n\t\t\t\tlocal $skey = $sessiondb{$session_id} ?\n\t\t\t\t\t\t$session_id : \n\t\t\t\t\t\t&hash_session_id($session_id);\n\t\t\t\tlocal ($user, $ltime, $ip) =\n\t\t\t\t\tsplit(/\\s+/, $sessiondb{$skey});\n\t\t\t\t$user =~ s/^\\!//;\n\t\t\t\tprint $outfd $user,\"\\n\";\n\t\t\t\t$sessiondb{$skey} = \"!$user $ltime $ip\";\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^pamstart\\s+(\\S+)\\s+(\\S+)\\s+(.*)/) {\n\t\t\t\t# Starting a new PAM conversation\n\t\t\t\tlocal ($cid, $host, $user) = ($1, $2, $3);\n\n\t\t\t\t# Does this user even need PAM?\n\t\t\t\tlocal ($realuser, $canlogin) =\n\t\t\t\t\t&can_user_login($user, undef, $host);\n\t\t\t\tlocal $conv;\n\t\t\t\tif ($canlogin == 0) {\n\t\t\t\t\t# Cannot even login!\n\t\t\t\t\tprint $outfd \"0 Invalid username\\n\";\n\t\t\t\t\t}\n\t\t\t\telsif ($canlogin != 2) {\n\t\t\t\t\t# Not using PAM .. so just ask for\n\t\t\t\t\t# the password.\n\t\t\t\t\t$conv = { 'user' => $realuser,\n\t\t\t\t\t\t  'host' => $host,\n\t\t\t\t\t\t  'step' => 0,\n\t\t\t\t\t\t  'cid' => $cid,\n\t\t\t\t\t\t  'time' => time() };\n\t\t\t\t\tprint $outfd \"3 Password\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Start the PAM conversation\n\t\t\t\t\t# sub-process, and get a question\n\t\t\t\t\t$conv = { 'user' => $realuser,\n\t\t\t\t\t\t  'host' => $host,\n\t\t\t\t\t\t  'cid' => $cid,\n\t\t\t\t\t\t  'time' => time() };\n\t\t\t\t\tlocal ($PAMINr, $PAMINw, $PAMOUTr,\n\t\t\t\t\t\t$PAMOUTw) = &allocate_pipes();\n\t\t\t\t\tlocal $pampid = fork();\n\t\t\t\t\tif (!$pampid) {\n\t\t\t\t\t\tclose($PAMOUTr); close($PAMINw);\n\t\t\t\t\t\t&pam_conversation_process(\n\t\t\t\t\t\t\t$realuser,\n\t\t\t\t\t\t\t$PAMOUTw, $PAMINr);\n\t\t\t\t\t\t}\n\t\t\t\t\tclose($PAMOUTw); close($PAMINr);\n\t\t\t\t\t$conv->{'pid'} = $pampid;\n\t\t\t\t\t$conv->{'PAMOUTr'} = $PAMOUTr;\n\t\t\t\t\t$conv->{'PAMINw'} = $PAMINw;\n\t\t\t\t\tpush(@childpids, $pampid);\n\n\t\t\t\t\t# Get the first PAM question\n\t\t\t\t\tlocal $pok = &recv_pam_question(\n\t\t\t\t\t\t$conv, $outfd);\n\t\t\t\t\tif (!$pok) {\n\t\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t$conversations{$cid} = $conv if ($conv);\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^pamanswer\\s+(\\S+)\\s+(.*)/) {\n\t\t\t\t# A response to a PAM question\n\t\t\t\tlocal ($cid, $answer) = ($1, $2);\n\t\t\t\tlocal $conv = $conversations{$cid};\n\t\t\t\tif (!$conv) {\n\t\t\t\t\t# No such conversation?\n\t\t\t\t\tprint $outfd \"0 Bad login session\\n\";\n\t\t\t\t\t}\n\t\t\t\telsif ($conv->{'pid'}) {\n\t\t\t\t\t# Send the PAM response and get\n\t\t\t\t\t# the next question\n\t\t\t\t\t&send_pam_answer($conv, $answer);\n\t\t\t\t\tlocal $pok = &recv_pam_question($conv, $outfd);\n\t\t\t\t\tif (!$pok) {\n\t\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# This must be the password .. try it\n\t\t\t\t\t# and send back the results\n\t\t\t\t\tlocal ($vu, $expired, $nonexist) =\n\t\t\t\t\t\t&validate_user($conv->{'user'},\n\t\t\t\t\t\t\t       $answer,\n\t\t\t\t\t\t\t       $conf->{'host'});\n\t\t\t\t\tlocal $ok = $vu ? 1 : 0;\n\t\t\t\t\tprint $outfd \"2 $conv->{'user'} $ok $expired $notexist\\n\";\n\t\t\t\t\t&end_pam_conversation($conv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^writesudo\\s+(\\S+)\\s+(\\d+)/) {\n\t\t\t\t# Store the fact that some user can sudo to root\n\t\t\t\tlocal ($user, $ok) = ($1, $2);\n\t\t\t\t$sudocache{$user} = $ok.\" \".time();\n\t\t\t\t}\n\t\t\telsif ($inline =~ /^readsudo\\s+(\\S+)/) {\n\t\t\t\t# Query the user sudo cache (valid for 1 minute)\n\t\t\t\tlocal $user = $1;\n\t\t\t\tlocal ($ok, $last) =\n\t\t\t\t\tsplit(/\\s+/, $sudocache{$user});\n\t\t\t\tif ($last < time()-60) {\n\t\t\t\t\t# Cache too old\n\t\t\t\t\tprint $outfd \"2\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Tell client OK or not\n\t\t\t\t\tprint $outfd \"$ok\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telsif ($inline =~ /\\S/) {\n\t\t\t\t# Unknown line from pipe?\n\t\t\t\tprint DEBUG \"main: Unknown line from pipe $inline\\n\";\n\t\t\t\tprint STDERR \"Unknown line from pipe $inline\\n\";\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# close pipe\n\t\t\t\tclose($infd); close($outfd);\n\t\t\t\t$passin[$i] = $passout[$i] = undef;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t@passin = grep { defined($_) } @passin;\n\t@passout = grep { defined($_) } @passout;\n\t}\n\n# handle_request(remoteaddress, localaddress, ipv6-flag)\n# Where the real work is done\nsub handle_request\n{\nlocal ($acptip, $localip, $ipv6) = @_;\nprint DEBUG \"handle_request: from $acptip to $localip ipv6=$ipv6\\n\";\nif ($config{'loghost'}) {\n\t$acpthost = &to_hostname($acptip);\n\t$acpthost = $acptip if (!$acpthost);\n\t}\nelse {\n\t$acpthost = $acptip;\n\t}\n$loghost = $acpthost;\n$datestr = &http_date(time());\n$ok_code = 200;\n$ok_message = \"Document follows\";\n$logged_code = undef;\n$reqline = $request_uri = $page = undef;\n$authuser = undef;\n$validated = undef;\n\n# check address against access list\nif (@deny && &ip_match($acptip, $localip, @deny) ||\n    @allow && !&ip_match($acptip, $localip, @allow)) {\n\t&http_error(403, \"Access denied for \".&html_strip($acptip));\n\treturn 0;\n\t}\n\nif ($use_libwrap) {\n\t# Check address with TCP-wrappers\n\tif (!hosts_ctl($config{'pam'}, STRING_UNKNOWN,\n\t\t       $acptip, STRING_UNKNOWN)) {\n\t\t&http_error(403, \"Access denied for \".&html_strip($acptip).\n\t\t\t\t \" by TCP wrappers\");\n\t\treturn 0;\n\t\t}\n\t}\nprint DEBUG \"handle_request: passed IP checks\\n\";\n\n# Compute a timeout for the start of headers, based on the number of\n# child processes. As this increases, we use a shorter timeout to avoid\n# an attacker overloading the system.\nlocal $header_timeout = 60 + ($config{'maxconns'} - @childpids) * 10;\n\n# Wait at most 60 secs for start of headers for initial requests, or\n# 10 minutes for kept-alive connections\nlocal $rmask;\nvec($rmask, fileno(SOCK), 1) = 1;\nlocal $to = $checked_timeout ? 10*60 : $header_timeout;\nlocal $sel = select($rmask, undef, undef, $to);\nif (!$sel) {\n\tif ($checked_timeout) {\n\t\tprint DEBUG \"handle_request: exiting due to timeout of $to\\n\";\n\t\texit;\n\t\t}\n\telse {\n\t\t&http_error(400, \"Timeout\",\n\t\t\t    \"Waited for $to seconds for start of headers\");\n\t\t}\n\t}\n$checked_timeout++;\nprint DEBUG \"handle_request: passed timeout check\\n\";\n\n# Read the HTTP request and headers\nlocal $origreqline = &read_line();\n($reqline = $origreqline) =~ s/\\r|\\n//g;\n$method = $page = $request_uri = undef;\nprint DEBUG \"handle_request reqline=$reqline\\n\";\nif (!$reqline && (!$use_ssl || $checked_timeout > 1)) {\n\t# An empty request .. just close the connection\n\tprint DEBUG \"handle_request: rejecting empty request\\n\";\n\treturn 0;\n\t}\nelsif ($reqline !~ /^(\\S+)\\s+(.*)\\s+HTTP\\/1\\..$/) {\n\tprint DEBUG \"handle_request: invalid reqline=$reqline\\n\";\n\tif ($use_ssl) {\n\t\t# This could be an http request when it should be https\n\t\t$use_ssl = 0;\n\t\tlocal $urlhost = $config{'musthost'} || $host;\n\t\t$urlhost = \"[\".$urlhost.\"]\" if (&check_ip6address($urlhost));\n\t\tlocal $wantport = $port;\n\t\tif ($wantport == 80 &&\n\t\t    &indexof(443, @listening_on_ports) >= 0) {\n\t\t\t# Connection was to port 80, but since we are also\n\t\t\t# accepting on port 443, redirect to that\n\t\t\t$wantport = 443;\n\t\t\t}\n\t\tlocal $url = $wantport == 443 ? \"https://$urlhost/\"\n\t\t\t\t\t      : \"https://$urlhost:$wantport/\";\n\t\tif ($config{'ssl_redirect'}) {\n\t\t\t# Just re-direct to the correct URL\n\t\t\tsleep(1);\t# Give browser a change to finish\n\t\t\t\t\t# sending its request\n\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t&write_data(\"Location: $url\\r\\n\");\n\t\t\t&write_keep_alive(0);\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\treturn 0;\n\t\t} elsif ($config{'hide_admin_url'} != 1) {\n\t\t\t# Tell user the correct URL\n\t\t\t&http_error(200, \"Document follows\",\n\t\t\t\t\"This web server is running in SSL mode. \".\n\t\t\t\t\"Try the URL <a href='$url'>$url</a> \".\n\t\t\t\t\"instead.\", 0, 1);\n\t\t} else {\n\t\t\t# Throw an error\n\t\t\t&http_error(404, \"Page not found\",\n\t\t\t    \"The requested URL was not found on this server.\")\n\t\t}\n\t} elsif (ord(substr($reqline, 0, 1)) == 128 && !$use_ssl) {\n\t\t# This could be an https request when it should be http ..\n\t\t# need to fake a HTTP response\n\t\teval <<'EOF';\n\t\t\tuse Net::SSLeay;\n\t\t\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\t\t\teval \"Net::SSLeay::load_error_strings()\";\n\t\t\t$ssl_ctx = Net::SSLeay::CTX_new();\n\t\t\tNet::SSLeay::CTX_use_RSAPrivateKey_file(\n\t\t\t\t$ssl_ctx, $config{'keyfile'},\n\t\t\t\t&Net::SSLeay::FILETYPE_PEM);\n\t\t\tNet::SSLeay::CTX_use_certificate_file(\n\t\t\t\t$ssl_ctx,\n\t\t\t\t$config{'certfile'} || $config{'keyfile'},\n\t\t\t\t&Net::SSLeay::FILETYPE_PEM);\n\t\t\t$ssl_con = Net::SSLeay::new($ssl_ctx);\n\t\t\tpipe(SSLr, SSLw);\n\t\t\tif (!fork()) {\n\t\t\t\tclose(SSLr);\n\t\t\t\tselect(SSLw); $| = 1; select(STDOUT);\n\t\t\t\tprint SSLw $origreqline;\n\t\t\t\tlocal $buf;\n\t\t\t\twhile(sysread(SOCK, $buf, 1) > 0) {\n\t\t\t\t\tprint SSLw $buf;\n\t\t\t\t\t}\n\t\t\t\tclose(SOCK);\n\t\t\t\texit;\n\t\t\t\t}\n\t\t\tclose(SSLw);\n\t\t\tNet::SSLeay::set_wfd($ssl_con, fileno(SOCK));\n\t\t\tNet::SSLeay::set_rfd($ssl_con, fileno(SSLr));\n\t\t\tNet::SSLeay::accept($ssl_con) || die \"accept() failed\";\n\t\t\t$use_ssl = 1;\n\t\t\tlocal $url = $config{'musthost'} ?\n\t\t\t\t\t\"https://$config{'musthost'}:$port/\" :\n\t\t\t\t\t\"https://$host:$port/\";\n\t\t\tif ($config{'ssl_redirect'}) {\n\t\t\t\t# Just re-direct to the correct URL\n\t\t\t\tsleep(1);\t# Give browser a change to\n\t\t\t\t\t\t# finish sending its request\n\t\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_data(\"Location: $url\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t&write_data(\"\\r\\n\");\n\t\t\t\treturn 0;\n\t\t\t} elsif ($config{'hide_admin_url'} != 1) {\n\t\t\t\t# Tell user the correct URL\n\t\t\t\t&http_error(200, \"Bad Request\", \"This web server is not running in SSL mode. Try the URL <a href='$url'>$url</a> instead.\", 0, 1);\n\t\t\t} else {\n\t\t\t\t&http_error(404, \"Page not found\",\n\t\t\t\t    \"The requested URL was not found on this server.\");\n\t\t\t}\nEOF\n\t\tif ($@) {\n\t\t\t&http_error(400, \"Bad Request\");\n\t\t\t}\n\t\t}\n\telse {\n\t\t&http_error(400, \"Bad Request\");\n\t\t}\n\t}\n$method = $1;\n$request_uri = $page = $2;\n%header = ();\nlocal $lastheader;\nwhile(1) {\n\t($headline = &read_line()) =~ s/\\r|\\n//g;\n\tlast if ($headline eq \"\");\n\tprint DEBUG \"handle_request: got headline $headline\\n\";\n\tif ($headline =~ /^(\\S+):\\s*(.*)$/) {\n\t\t$header{$lastheader = lc($1)} = $2;\n\t\t}\n\telsif ($headline =~ /^\\s+(.*)$/) {\n\t\t$header{$lastheader} .= $headline;\n\t\t}\n\telse {\n\t\t&http_error(400, \"Bad Header \".&html_strip($headline));\n\t\t}\n\tif (&is_bad_header($header{$lastheader}, $lastheader)) {\n\t\tdelete($header{$lastheader});\n\t\t&http_error(400, \"Bad Header Contents \".\n\t\t\t\t &html_strip($lastheader));\n\t\t}\n\t}\n\n# If a remote IP is given in a header (such as via a proxy), only use it\n# for logging unless trust_real_ip is set\nlocal $headerhost = $header{'x-forwarded-for'} ||\n\t\t    $header{'x-real-ip'};\nif ($headerhost) {\n\t# Only real IPs are allowed\n\t$headerhost = undef if (!&check_ipaddress($headerhost) &&\n\t\t\t\t!&check_ip6address($headerhost));\n\t}\nif ($config{'trust_real_ip'}) {\n\t$acpthost = $headerhost || $acpthost;\n\tif (&check_ipaddress($headerhost) || &check_ip6address($headerhost)) {\n\t\t# If a remote IP was given, use it for all access control checks\n\t\t# from now on.\n\t\t$acptip = $headerhost;\n\t\t\n\t\t# re-check remote address against access list\n\t\tif (@deny && &ip_match($acptip, $localip, @deny) ||\n\t\t    @allow && !&ip_match($acptip, $localip, @allow)) {\n\t\t\t&http_error(403, \"Access denied for \".&html_strip($acptip));\n\t\t\treturn 0;\n\t\t\t}\n\t\t\n\t\tif ($use_libwrap) {\n\t\t\t# Check address with TCP-wrappers\n\t\t\tif (!hosts_ctl($config{'pam'}, STRING_UNKNOWN,\n\t\t\t\t       $acptip, STRING_UNKNOWN)) {\n\t\t\t\t&http_error(403, \"Access denied for \".&html_strip($acptip).\n\t\t\t\t\t\t \" by TCP wrappers\");\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\tprint DEBUG \"handle_request: passed Remote IP checks\\n\";\n\t\t}\n\t$loghost = $acpthost;\n\t}\nelse {\n\t$loghost = $headerhost || $loghost;\n\t}\n\nif (defined($header{'host'})) {\n\tif ($header{'host'} =~ /^\\[(.+)\\]:([0-9]+)$/) {\n\t\t($host, $port) = ($1, $2);\n\t\t}\n\telsif ($header{'host'} =~ /^([^:]+):([0-9]+)$/) {\n\t\t($host, $port) = ($1, $2);\n\t\t}\n\telse {\n\t\t$host = $header{'host'};\n\t\t}\n\tif ($config{'musthost'} && $host ne $config{'musthost'}) {\n\t\t# Disallowed hostname used\n\t\t&http_error(400, \"Invalid HTTP hostname\");\n\t\t}\n\t}\n\n# Create strings for use in redirects\n$ssl = $config{'redirect_ssl'} ne '' ? $config{'redirect_ssl'} :\n\t$use_ssl || $config{'inetd_ssl'};\n$redirport = $config{'redirect_port'} || $port;\n$portstr = $redirport == 80 && !$ssl ? \"\" :\n\t   $redirport == 443 && $ssl ? \"\" : \":\".$redirport;\n$redirhost = $config{'redirect_host'} || $host;\n$hostport = &check_ip6address($redirhost) ? \"[\".$redirhost.\"]\".$portstr\n\t\t\t\t          : $redirhost.$portstr;\n\n# If the redirect_prefix exists change redirect base to include the prefix #1271\nif ($config{'redirect_prefix'}) {\n\t$hostport .= $config{'redirect_prefix'}\n\t}\n$prot = $ssl ? \"https\" : \"http\";\n\nundef(%in);\nif ($page =~ /^([^\\?]+)\\?(.*)$/) {\n\t# There is some query string information\n\t$page = $1;\n\t$querystring = $2;\n\tprint DEBUG \"handle_request: querystring=$querystring\\n\";\n\tif ($querystring !~ /=/) {\n\t\t$queryargs = $querystring;\n\t\t$queryargs =~ s/\\+/ /g;\n    \t\t$queryargs =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$querystring = \"\";\n\t\t}\n\telse {\n\t\t# Parse query-string parameters\n\t\tlocal @in = split(/\\&/, $querystring);\n\t\tforeach $i (@in) {\n\t\t\tlocal ($k, $v) = split(/=/, $i, 2);\n\t\t\t$k =~ s/\\+/ /g; $k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t\t$v =~ s/\\+/ /g; $v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t\t$in{$k} = $v;\n\t\t\t}\n\t\t}\n\t}\n$posted_data = undef;\nif ($method eq 'POST' &&\n    $header{'content-type'} eq 'application/x-www-form-urlencoded') {\n\t# Read in posted query string information, up the configured maximum\n\t# post request length\n\t$clen = $header{\"content-length\"};\n\t$clen_read = $clen > $config{'max_post'} ? $config{'max_post'} : $clen;\n\twhile(length($posted_data) < $clen_read) {\n\t\talarm(60);\n\t\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\t\teval {\n\t\t\t$buf = &read_data($clen_read - length($posted_data));\n\t\t\t};\n\t\talarm(0);\n\t\tif ($@) {\n\t\t\t&http_error(500, \"Timeout reading POST request\");\n\t\t\t}\n\t\tif (!length($buf)) {\n\t\t\t&http_error(500, \"Failed to read POST request\");\n\t\t\t}\n\t\tchomp($posted_data);\n\t\t$posted_data =~ s/\\015$//mg;\n\t\t$posted_data .= $buf;\n\t\t}\n\tprint DEBUG \"clen_read=$clen_read clen=$clen posted_data=\",length($posted_data),\"\\n\";\n\tif ($clen_read != $clen && length($posted_data) > $clen) {\n\t\t# If the client sent more data than we asked for, chop the\n\t\t# rest off\n\t\t$posted_data = substr($posted_data, 0, $clen);\n\t\t}\n\tif (length($posted_data) > $clen) {\n\t\t# When the client sent too much, delay so that it gets headers\n\t\tsleep(3);\n\t\t}\n\tif ($header{'user-agent'} =~ /MSIE/ &&\n\t    $header{'user-agent'} !~ /Opera/i) {\n\t\t# MSIE includes an extra newline in the data\n\t\t$posted_data =~ s/\\r|\\n//g;\n\t\t}\n\tlocal @in = split(/\\&/, $posted_data);\n\tforeach $i (@in) {\n\t\tlocal ($k, $v) = split(/=/, $i, 2);\n\t\t#$v =~ s/\\r|\\n//g;\n\t\t$k =~ s/\\+/ /g; $k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$v =~ s/\\+/ /g; $v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t\t$in{$k} = $v;\n\t\t}\n\tprint DEBUG \"handle_request: posted_data=$posted_data\\n\";\n\t}\n\n# Reject CONNECT request, which isn't supported\nif ($method eq \"CONNECT\" || $method eq \"TRACE\") {\n\t&http_error(405, \"Method \".&html_strip($method).\" is not supported\");\n\t}\n\n# work out accepted encodings\n%acceptenc = map { $_, 1 } split(/,/, $header{'accept-encoding'});\n\n# replace %XX sequences in page\n$page =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\n# Check if the browser's user agent indicates a mobile device\n$mobile_device = &is_mobile_useragent($header{'user-agent'});\n\n# Check if Host: header is for a mobile URL\nforeach my $m (@mobile_prefixes) {\n\tif ($header{'host'} =~ /^\\Q$m\\E/i) {\n\t\t$mobile_device = 1;\n\t\t}\n\t}\n\n# check for the logout flag file, and if existent deny authentication\nif ($config{'logout'} && -r $config{'logout'}.$in{'miniserv_logout_id'}) {\n\tprint DEBUG \"handle_request: logout flag set\\n\";\n\t$deny_authentication++;\n\topen(LOGOUT, $config{'logout'}.$in{'miniserv_logout_id'});\n\tchop($count = <LOGOUT>);\n\tclose(LOGOUT);\n\t$count--;\n\tif ($count > 0) {\n\t\topen(LOGOUT, \">$config{'logout'}$in{'miniserv_logout_id'}\");\n\t\tprint LOGOUT \"$count\\n\";\n\t\tclose(LOGOUT);\n\t\t}\n\telse {\n\t\tunlink($config{'logout'}.$in{'miniserv_logout_id'});\n\t\t}\n\t}\n\n# check for any redirect for the requested URL\nforeach my $pfx (@strip_prefix) {\n\tmy $l = length($pfx);\n\tif(length($page) >= $l &&\n\t   substr($page,0,$l) eq $pfx) {\n\t\t$page=substr($page,$l);\n\t\tlast;\n\t\t}\n\t}\n$simple = &simplify_path($page, $bogus);\n$rpath = $simple;\n$rpath .= \"&\".$querystring if (defined($querystring));\n$redir = $redirect{$rpath};\nif (defined($redir)) {\n\tprint DEBUG \"handle_request: redir=$redir\\n\";\n\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t&write_data(\"Date: $datestr\\r\\n\");\n\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t&write_data(\"Location: $prot://$hostport$redir\\r\\n\");\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\treturn 0;\n\t}\n\n# Check for a DAV request\n$davpath = undef;\nforeach my $d (@davpaths) {\n\tif ($simple eq $d || $simple =~ /^\\Q$d\\E\\//) {\n\t\t$davpath = $d;\n\t\tlast;\n\t\t}\n\t}\nif (!$davpath && ($method eq \"SEARCH\" || $method eq \"PUT\")) {\n\t&http_error(400, \"Bad Request method \".&html_strip($method));\n\t}\n\n# Check for password if needed\nif ($config{'userfile'}) {\n\tprint DEBUG \"handle_request: Need authentication\\n\";\n\t$validated = 0;\n\t$blocked = 0;\n\n\t# Session authentication is never used for connections by\n\t# another webmin server, or for specified pages, or for DAV, or XMLRPC,\n\t# or mobile browsers if requested.\n\tif ($header{'user-agent'} =~ /webmin/i ||\n\t    $header{'user-agent'} =~ /$config{'agents_nosession'}/i ||\n\t    $sessiononly{$simple} || $davpath ||\n\t    $simple eq \"/xmlrpc.cgi\" ||\n            $acptip eq $config{'host_nosession'} ||\n\t    $mobile_device && $config{'mobile_nosession'}) {\n\t\tprint DEBUG \"handle_request: Forcing HTTP authentication\\n\";\n\t\t$config{'session'} = 0;\n\t\t}\n\n\t# Check for SSL authentication\n\tif ($use_ssl && $verified_client) {\n\t\t$peername = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\tNet::SSLeay::X509_get_subject_name(\n\t\t\t\t\tNet::SSLeay::get_peer_certificate(\n\t\t\t\t\t\t$ssl_con)));\n\t\t$u = &find_user_by_cert($peername);\n\t\tif ($u) {\n\t\t\t$authuser = $u;\n\t\t\t$validated = 2;\n\t\t\t}\n\t\tif ($use_syslog && !$validated) {\n\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t       \"Unknown SSL certificate $peername\");\n\t\t\t}\n\t\t}\n\n\tif (!$validated && !$deny_authentication) {\n\t\t# check for IP-based authentication\n\t\tlocal $a;\n\t\tforeach $a (keys %ipaccess) {\n\t\t\tif ($acptip eq $a) {\n\t\t\t\t# It does! Auth as the user\n\t\t\t\t$validated = 3;\n\t\t\t\t$baseauthuser = $authuser =\n\t\t\t\t\t$ipaccess{$a};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check for normal HTTP authentication\n\tif (!$validated && !$deny_authentication && !$config{'session'} &&\n\t    $header{authorization} =~ /^basic\\s+(\\S+)$/i) {\n\t\t# authorization given..\n\t\t($authuser, $authpass) = split(/:/, &b64decode($1), 2);\n\t\tprint DEBUG \"handle_request: doing basic auth check authuser=$authuser authpass=$authpass\\n\";\n\t\tlocal ($vu, $expired, $nonexist, $wvu) =\n\t\t\t&validate_user($authuser, $authpass, $host,\n\t\t\t\t       $acptip, $port);\n\t\tprint DEBUG \"handle_request: vu=$vu expired=$expired nonexist=$nonexist\\n\";\n\t\tif ($vu && (!$expired || $config{'passwd_mode'} == 1)) {\n\t\t\t$authuser = $vu;\n\t\t\t$validated = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$validated = 0;\n\t\t\t}\n\t\tif ($use_syslog && !$validated) {\n\t\t\tsyslog(\"crit\", \"%s\",\n\t\t\t       ($nonexist ? \"Non-existent\" :\n\t\t\t\t$expired ? \"Expired\" : \"Invalid\").\n\t\t\t       \" login as $authuser from $acpthost\");\n\t\t\t}\n\t\tif ($authuser =~ /\\r|\\n|\\s/) {\n\t\t\t&http_error(500, \"Invalid username\",\n\t\t\t\t    \"Username contains invalid characters\");\n\t\t\t}\n\t\tif ($authpass =~ /\\r|\\n/) {\n\t\t\t&http_error(500, \"Invalid password\",\n\t\t\t\t    \"Password contains invalid characters\");\n\t\t\t}\n\n\t\tif ($config{'passdelay'} && !$config{'inetd'} && $authuser) {\n\t\t\t# check with main process for delay\n\t\t\tprint DEBUG \"handle_request: about to ask for password delay\\n\";\n\t\t\tprint $PASSINw \"delay $authuser $acptip $validated\\n\";\n\t\t\t<$PASSOUTr> =~ /(\\d+) (\\d+)/;\n\t\t\t$blocked = $2;\n\t\t\tprint DEBUG \"handle_request: password delay $1 $2\\n\";\n\t\t\tsleep($1);\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special session login page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $page eq $config{'session_login'}) {\n\t\tif ($in{'logout'} && $header{'cookie'} =~ /(^|\\s|;)$sidname=([a-f0-9]+)/) {\n\t\t\t# Logout clicked .. remove the session\n\t\t\tlocal $sid = $2;\n\t\t\tprint $PASSINw \"delete $sid\\n\";\n\t\t\tlocal $louser = <$PASSOUTr>;\n\t\t\tchop($louser);\n\t\t\t$logout = 1;\n\t\t\t$already_session_id = undef;\n\t\t\t$authuser = $baseauthuser = undef;\n\t\t\tif ($louser) {\n\t\t\t\tif ($use_syslog) {\n\t\t\t\t\tsyslog(\"info\", \"%s\", \"Logout by $louser from $acpthost\");\n\t\t\t\t\t}\n\t\t\t\t&run_logout_script($louser, $sid,\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&write_logout_utmp($louser, $actphost);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t# Trim username to remove leading and trailing spaces to \n\t\t\t# be able to login, if username copy/paste from somewhere\n\t\t\t$in{'user'} =~ s/^\\s+|\\s+$//g;\n\n\t\t\t# Validate the user\n\t\t\tif ($in{'user'} =~ /\\r|\\n|\\s/) {\n\t\t\t\t&run_failed_script($in{'user'}, 'baduser',\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&http_error(500, \"Invalid username\",\n\t\t\t\t    \"Username contains invalid characters\");\n\t\t\t\t}\n\t\t\tif ($in{'pass'} =~ /\\r|\\n/) {\n\t\t\t\t&run_failed_script($in{'user'}, 'badpass',\n\t\t\t\t\t\t   $loghost, $localip);\n\t\t\t\t&http_error(500, \"Invalid password\",\n\t\t\t\t    \"Password contains invalid characters\");\n\t\t\t\t}\n\n\t\t\tlocal ($vu, $expired, $nonexist, $wvu) =\n\t\t\t\t&validate_user($in{'user'}, $in{'pass'}, $host,\n\t\t\t\t\t       $acptip, $port);\n\t\t\tif ($vu && $wvu) {\n\t\t\t\tmy $uinfo = &get_user_details($wvu);\n\t\t\t\tif ($uinfo && $uinfo->{'twofactor_provider'}) {\n\t\t\t\t\t# Check two-factor token ID\n\t\t\t\t\t$err = &validate_twofactor(\n\t\t\t\t\t\t$wvu, $in{'twofactor'});\n\t\t\t\t\tif ($err) {\n\t\t\t\t\t\t&run_failed_script(\n\t\t\t\t\t\t\t$vu, 'twofactor',\n\t\t\t\t\t\t\t$loghost, $localip);\n\t\t\t\t\t\t$twofactor_msg = $err;\n\t\t\t\t\t\t$twofactor_nolog = 'nolog' if (!$in{'twofactor'});\n\t\t\t\t\t\t$vu = undef;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t\t$vu || $in{'user'}, $vu ? 1 : 0,\n\t\t\t\t      \t$expired, $nonexist, $in{'pass'},\n\t\t\t\t\t$in{'notestingcookie'}, $twofactor_nolog);\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special PAM login page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $use_pam && $config{'pam_conv'} && $page eq $config{'pam_login'} &&\n\t    !$in{'restart'}) {\n\t\t# A question has been entered .. submit it to the main process\n\t\tprint DEBUG \"handle_request: Got call to $page ($in{'cid'})\\n\";\n\t\tprint DEBUG \"handle_request: For PAM, authuser=$authuser\\n\";\n\t\tif ($in{'answer'} =~ /\\r|\\n/ || $in{'cid'} =~ /\\r|\\n|\\s/) {\n\t\t\t&http_error(500, \"Invalid response\",\n\t\t\t    \"Response contains invalid characters\");\n\t\t\t}\n\n\t\tif (!$in{'cid'}) {\n\t\t\t# Start of a new conversation - answer must be username\n\t\t\t$cid = &generate_random_id();\n\t\t\tprint $PASSINw \"pamstart $cid $host $in{'answer'}\\n\";\n\t\t\t}\n\t\telse {\n\t\t\t# A response to a previous question\n\t\t\t$cid = $in{'cid'};\n\t\t\tprint $PASSINw \"pamanswer $cid $in{'answer'}\\n\";\n\t\t\t}\n\n\t\t# Read back the response, and the next question (if any)\n\t\tlocal $line = <$PASSOUTr>;\n\t\t$line =~ s/\\r|\\n//g;\n\t\tlocal ($rv, $question) = split(/\\s+/, $line, 2);\n\t\tif ($rv == 0) {\n\t\t\t# Cannot login!\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t!$in{'cid'} && $in{'answer'} ? $in{'answer'}\n\t\t\t\t\t\t\t     : \"unknown\",\n\t\t\t\t0, 0, 1, undef);\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\telsif ($rv == 1 || $rv == 3) {\n\t\t\t# Another question .. force use of PAM CGI\n\t\t\t$validated = 1;\n\t\t\t$method = \"GET\";\n\t\t\t$querystring .= \"&cid=$cid&question=\".\n\t\t\t\t\t&urlize($question);\n\t\t\t$querystring .= \"&password=1\" if ($rv == 3);\n\t\t\t$queryargs = \"\";\n\t\t\t$page = $config{'pam_login'};\n\t\t\t$miniserv_internal = 1;\n\t\t\t$logged_code = 401;\n\t\t\t}\n\t\telsif ($rv == 2) {\n\t\t\t# Got back a final ok or failure\n\t\t\tlocal ($user, $ok, $expired, $nonexist) =\n\t\t\t\tsplit(/\\s+/, $question);\n\t\t\tlocal $hrv = &handle_login(\n\t\t\t\t$user, $ok, $expired, $nonexist, undef,\n\t\t\t\t$in{'notestingcookie'});\n\t\t\treturn $hrv if (defined($hrv));\n\t\t\t}\n\t\telsif ($rv == 4) {\n\t\t\t# A message from PAM .. tell the user\n\t\t\t$validated = 1;\n\t\t\t$method = \"GET\";\n\t\t\t$querystring .= \"&cid=$cid&message=\".\n\t\t\t\t\t&urlize($question);\n\t\t\t$queryargs = \"\";\n\t\t\t$page = $config{'pam_login'};\n\t\t\t$miniserv_internal = 1;\n\t\t\t$logged_code = 401;\n\t\t\t}\n\t\t}\n\n\t# Check for a visit to the special password change page\n\tif ($config{'session'} && !$deny_authentication &&\n\t    $page eq $config{'password_change'} && !$validated) {\n\t\t# Just let this slide ..\n\t\t$validated = 1;\n\t\t$miniserv_internal = 3;\n\t\t}\n\n\t# Check for an existing session\n\tif ($config{'session'} && !$validated) {\n\t\tif ($already_session_id) {\n\t\t\t$session_id = $already_session_id;\n\t\t\t$authuser = $already_authuser;\n\t\t\t$validated = 1;\n\t\t\t}\n\t\telsif (!$deny_authentication &&\n\t\t       $header{'cookie'} =~ /(^|\\s|;)$sidname=([a-f0-9]+)/) {\n\t\t\t# Try all session cookies\n\t\t\tlocal $cookie = $header{'cookie'};\n\t\t\twhile($cookie =~ s/(^|\\s|;)$sidname=([a-f0-9]+)//) {\n\t\t\t\t$session_id = $2;\n\t\t\t\tlocal $notimeout =\n\t\t\t\t\t$in{'webmin_notimeout'} ? 1 : 0;\n\t\t\t\tprint $PASSINw \"verify $session_id $notimeout $acptip\\n\";\n\t\t\t\t<$PASSOUTr> =~ /(\\d+)\\s+(\\S+)/;\n\t\t\t\tif ($1 == 2) {\n\t\t\t\t\t# Valid session continuation\n\t\t\t\t\t$validated = 1;\n\t\t\t\t\t$authuser = $2;\n\t\t\t\t\t$already_authuser = $authuser;\n\t\t\t\t\t$timed_out = undef;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 == 1) {\n\t\t\t\t\t# Session timed out\n\t\t\t\t\t$timed_out = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 == 3) {\n\t\t\t\t\t# Session is OK, but from the wrong IP\n\t\t\t\t\tprint STDERR \"Session $session_id was \",\n\t\t\t\t\t  \"used from $acptip instead of \",\n\t\t\t\t\t  \"original IP $2\\n\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Invalid session ID .. don't set\n\t\t\t\t\t# verified flag\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check for local authentication\n\tif ($localauth_user && !$header{'x-forwarded-for'} && !$header{'via'}) {\n\t\tmy $luser = &get_user_details($localauth_user);\n\t\tif ($luser) {\n\t\t\t# Local user exists in webmin users file\n\t\t\t$validated = 1;\n\t\t\t$authuser = $localauth_user;\n\t\t\t}\n\t\telse {\n\t\t\t# Check if local user is allowed by unixauth\n\t\t\tlocal @can = &can_user_login($localauth_user,\n\t\t\t\t\t\t     undef, $host);\n\t\t\tif ($can[0]) {\n\t\t\t\t$validated = 2;\n\t\t\t\t$authuser = $localauth_user;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$localauth_user = undef;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\t# Check if this path allows anonymous access\n\t\tlocal $a;\n\t\tforeach $a (keys %anonymous) {\n\t\t\tif (substr($simple, 0, length($a)) eq $a) {\n\t\t\t\t# It does! Auth as the user, if IP access\n\t\t\t\t# control allows him.\n\t\t\t\tif (&check_user_ip($anonymous{$a}) &&\n\t\t\t\t    &check_user_time($anonymous{$a})) {\n\t\t\t\t\t$validated = 3;\n\t\t\t\t\t$baseauthuser = $authuser =\n\t\t\t\t\t\t$anonymous{$a};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\t# Check if this path allows unauthenticated access\n\t\tlocal ($u, $unauth);\n\t\tforeach $u (@unauth) {\n\t\t\t$unauth++ if ($simple =~ /$u/);\n\t\t\t}\n\t\tif (!$bogus && $unauth) {\n\t\t\t# Unauthenticated directory or file request - approve it\n\t\t\t$validated = 4;\n\t\t\t$baseauthuser = $authuser = undef;\n\t\t\t}\n\t\t}\n\n\tif (!$validated) {\n\t\tif ($blocked == 0) {\n\t\t\t# No password given.. ask\n\t\t\tif ($config{'pam_conv'} && $use_pam) {\n\t\t\t\t# Force CGI for PAM question, starting with\n\t\t\t\t# the username which is always needed\n\t\t\t\t$validated = 1;\n\t\t\t\t$method = \"GET\";\n\t\t\t\t$querystring .= \"&initial=1&question=\".\n\t\t\t\t\t\t&urlize(\"Username\");\n\t\t\t\t$querystring .= \"&failed=$failed_user\" if ($failed_user);\n\t\t\t\t$querystring .= \"&timed_out=$timed_out\" if ($timed_out);\n\t\t\t\t$queryargs = \"\";\n\t\t\t\t$page = $config{'pam_login'};\n\t\t\t\t$miniserv_internal = 1;\n\t\t\t\t$logged_code = 401;\n\t\t\t\t}\n\t\t\telsif ($config{'session'}) {\n\t\t\t\t# Force CGI for session login\n\t\t\t\t$validated = 1;\n\t\t\t\tif ($logout) {\n\t\t\t\t\t$querystring .= \"&logout=1&page=/\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# Re-direct to current module only\n\t\t\t\t\tlocal $rpage = $request_uri;\n\t\t\t\t\tif (!$config{'loginkeeppage'}) {\n\t\t\t\t\t\t$rpage =~ s/\\?.*$//;\n\t\t\t\t\t\t$rpage =~ s/[^\\/]+$//\n\t\t\t\t\t\t}\n\t\t\t\t\t$querystring = \"page=\".&urlize($rpage);\n\t\t\t\t\t}\n\t\t\t\t$method = \"GET\";\n\t\t\t\t$querystring .= \"&failed=\".&urlize($failed_user)\n\t\t\t\t\tif ($failed_user);\n\t\t\t\tif ($twofactor_msg) {\n\t\t\t\t\t$querystring .= \"&failed_save=\".&urlize($failed_save);\n\t\t\t\t\t$querystring .= \"&failed_pass=\".&urlize($failed_pass);\n\t\t\t\t\t$querystring .= \"&failed_twofactor_attempt=\".&urlize($failed_twofactor_attempt);\n\t\t\t\t\t$querystring .= \"&twofactor_msg=\".&urlize($twofactor_msg);\n\t\t\t\t\t}\n\t\t\t\t$querystring .= \"&timed_out=$timed_out\"\n\t\t\t\t\tif ($timed_out);\n\t\t\t\t$queryargs = \"\";\n\t\t\t\t$page = $config{'session_login'};\n\t\t\t\t$miniserv_internal = 1;\n\t\t\t\t$logged_code = 401;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Ask for login with HTTP authentication\n\t\t\t\t&write_data(\"HTTP/1.0 401 Unauthorized\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_data(\"WWW-authenticate: Basic \".\n\t\t\t\t\t   \"realm=\\\"$config{'realm'}\\\"\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t&write_data(\"Content-type: text/html; Charset=utf-8\\r\\n\");\n\t\t\t\t&write_data(\"\\r\\n\");\n\t\t\t\t&reset_byte_count();\n\t\t\t\t&write_data(\"<html>\\n\");\n\t\t\t\t&write_data(\"<head><title>Unauthorized</title></head>\\n\");\n\t\t\t\t&write_data(\"<body><h2 style='color: #de0000; margin-bottom: -8px;'>Unauthorized</h2>\\n\");\n\t\t\t\t&write_data(\"A password is required to access this\\n\");\n\t\t\t\t&write_data(\"web server. Please try again. <p>\\n\");\n\t\t\t\t&write_data(\"</body></html>\\n\");\n\t\t\t\t&log_request($loghost, undef, $reqline, 401, &byte_count());\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($blocked == 1) {\n\t\t\t# when the host has been blocked, give it an error\n\t\t\t&http_error(403, \"Access denied for $acptip. The host \".\n\t\t\t\t\t \"has been blocked because of too \".\n\t\t\t\t\t \"many authentication failures.\");\n\t\t\t}\n\t\telsif ($blocked == 2) {\n\t\t\t# when the user has been blocked, give it an error\n\t\t\t&http_error(403, \"Access denied. The user \".\n\t\t\t\t\t \"has been blocked because of too \".\n\t\t\t\t\t \"many authentication failures.\");\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Get the real Webmin username\n\t\tlocal @can = &can_user_login($authuser, undef, $host);\n\t\t$baseauthuser = $can[3] || $authuser;\n\n\t\tif ($config{'remoteuser'} && !$< && $validated) {\n\t\t\t# Switch to the UID of the remote user (if he exists)\n\t\t\tlocal @u = getpwnam($authuser);\n\t\t\tif (@u && $< != $u[2]) {\n\t\t\t\t$( = $u[3]; $) = \"$u[3] $u[3]\";\n\t\t\t\t($>, $<) = ($u[2], $u[2]);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&http_error(500, \"Unix user \".\n\t\t\t\t  &html_strip($authuser).\" does not exist\");\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check per-user IP access control\n\tif (!&check_user_ip($baseauthuser)) {\n\t\t&http_error(403, \"Access denied for $acptip for \".\n\t\t\t\t &html_strip($baseauthuser));\n\t\treturn 0;\n\t\t}\n\n\t# Check per-user allowed times\n\tif (!&check_user_time($baseauthuser)) {\n\t\t&http_error(403, \"Access denied at the current time\");\n\t\treturn 0;\n\t\t}\n\t}\n$uinfo = &get_user_details($baseauthuser);\n\n# Validate the path, and convert to canonical form\nrerun:\n$simple = &simplify_path($page, $bogus);\nprint DEBUG \"handle_request: page=$page simple=$simple\\n\";\nif ($bogus) {\n\t&http_error(400, \"Invalid path\");\n\t}\n\n# Check for a DAV request\nif ($davpath) {\n\treturn &handle_dav_request($davpath);\n\t}\n\n# Work out the active theme(s)\nlocal $preroots = $mobile_device && defined($config{'mobile_preroot'}) ?\n\t\t\t$config{'mobile_preroot'} :\n\t\t $authuser && defined($config{'preroot_'.$authuser}) ?\n\t\t\t$config{'preroot_'.$authuser} :\n\t         $uinfo && defined($uinfo->{'preroot'}) ?\n\t\t\t$uinfo->{'preroot'} :\n\t\t\t$config{'preroot'};\nlocal @preroots = reverse(split(/\\s+/, $preroots));\n\n# Canonicalize the directories\nforeach my $preroot (@preroots) {\n\t# Always under the current webmin root\n\t$preroot =~ s/^.*\\///g;\n\t$preroot = $roots[0].'/'.$preroot;\n\t}\n\n# Look in the theme root directories first\nlocal ($full, @stfull);\n$foundroot = undef;\nforeach my $preroot (@preroots) {\n\t$is_directory = 1;\n\t$sofar = \"\";\n\t$full = $preroot.$sofar;\n\t$scriptname = $simple;\n\tforeach $b (split(/\\//, $simple)) {\n\t\tif ($b ne \"\") { $sofar .= \"/$b\"; }\n\t\t$full = $preroot.$sofar;\n\t\t@stfull = stat($full);\n\t\tif (!@stfull) { undef($full); last; }\n\n\t\t# Check if this is a directory\n\t\tif (-d _) {\n\t\t\t# It is.. go on parsing\n\t\t\t$is_directory = 1;\n\t\t\tnext;\n\t\t\t}\n\t\telse {\n\t\t\t$is_directory = 0;\n\t\t\t}\n\n\t\t# Check if this is a CGI program\n\t\tif (&get_type($full) eq \"internal/cgi\") {\n\t\t\t$pathinfo = substr($simple, length($sofar));\n\t\t\t$pathinfo .= \"/\" if ($page =~ /\\/$/);\n\t\t\t$scriptname = $sofar;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\n\t# Don't stop at a directory unless this is the last theme, which\n\t# is the 'real' one that provides the .cgi scripts\n\tif ($is_directory && $preroot ne $preroots[$#preroots]) {\n\t\tnext;\n\t\t}\n\n\tif ($full) {\n\t\t# Found it!\n\t\tif ($sofar eq '') {\n\t\t\t$cgi_pwd = $roots[0];\n\t\t\t}\n\t\telsif ($is_directory) {\n\t\t\t$cgi_pwd = \"$roots[0]$sofar\";\n\t\t\t}\n\t\telse {\n\t\t\t\"$roots[0]$sofar\" =~ /^(.*\\/)[^\\/]+$/;\n\t\t\t$cgi_pwd = $1;\n\t\t\t}\n\t\t$foundroot = $preroot;\n\t\tif ($is_directory) {\n\t\t\t# Check for index files in the directory\n\t\t\tlocal $foundidx;\n\t\t\tforeach $idx (split(/\\s+/, $config{\"index_docs\"})) {\n\t\t\t\t$idxfull = \"$full/$idx\";\n\t\t\t\tlocal @stidxfull = stat($idxfull);\n\t\t\t\tif (-r _ && !-d _) {\n\t\t\t\t\t$full = $idxfull;\n\t\t\t\t\t@stfull = @stidxfull;\n\t\t\t\t\t$is_directory = 0;\n\t\t\t\t\t$scriptname .= \"/\"\n\t\t\t\t\t\tif ($scriptname ne \"/\");\n\t\t\t\t\t$foundidx++;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t@stfull = stat($full) if (!$foundidx);\n\t\t\t}\n\t\t}\n\tlast if ($foundroot);\n\t}\nprint DEBUG \"handle_request: initial full=$full\\n\";\n\n# Look in the real root directories, stopping when we find a file or directory\nif (!$full || $is_directory) {\n\tROOT: foreach $root (@roots) {\n\t\t$sofar = \"\";\n\t\t$full = $root.$sofar;\n\t\t$scriptname = $simple;\n\t\tforeach $b ($simple eq \"/\" ? ( \"\" ) : split(/\\//, $simple)) {\n\t\t\tif ($b ne \"\") { $sofar .= \"/$b\"; }\n\t\t\t$full = $root.$sofar;\n\t\t\t@stfull = stat($full);\n\t\t\tif (!@stfull) {\n\t\t\t\tnext ROOT;\n\t\t\t\t}\n\n\t\t\t# Check if this is a directory\n\t\t\tif (-d _) {\n\t\t\t\t# It is.. go on parsing\n\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t# Check if this is a CGI program\n\t\t\tif (&get_type($full) eq \"internal/cgi\") {\n\t\t\t\t$pathinfo = substr($simple, length($sofar));\n\t\t\t\t$pathinfo .= \"/\" if ($page =~ /\\/$/);\n\t\t\t\t$scriptname = $sofar;\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Run CGI in the same directory as whatever file\n\t\t# was requested\n\t\t$full =~ /^(.*\\/)[^\\/]+$/; $cgi_pwd = $1;\n\n\t\tif (-e $full) {\n\t\t\t# Found something!\n\t\t\t$realroot = $root;\n\t\t\t$foundroot = $root;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif (!@stfull) { &http_error(404, \"File not found\"); }\n\t}\nprint DEBUG \"handle_request: full=$full\\n\";\n@stfull = stat($full) if (!@stfull);\n\n# check filename against denyfile regexp\nlocal $denyfile = $config{'denyfile'};\nif ($denyfile && $full =~ /$denyfile/) {\n\t&http_error(403, \"Access denied to \".&html_strip($page));\n\treturn 0;\n\t}\n\n# Reached the end of the path OK.. see what we've got\nif (-d _) {\n\t# See if the URL ends with a / as it should\n\tprint DEBUG \"handle_request: found a directory\\n\";\n\tif ($page !~ /\\/$/) {\n\t\t# It doesn't.. redirect\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t&write_data(\"Location: $prot://$hostport$page/\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\treturn 0;\n\t\t}\n\t# A directory.. check for index files\n\tlocal $foundidx;\n\tforeach $idx (split(/\\s+/, $config{\"index_docs\"})) {\n\t\t$idxfull = \"$full/$idx\";\n\t\t@stidxfull = stat($idxfull);\n\t\tif (-r _ && !-d _) {\n\t\t\t$cgi_pwd = $full;\n\t\t\t$full = $idxfull;\n\t\t\t@stfull = @stidxfull;\n\t\t\t$scriptname .= \"/\" if ($scriptname ne \"/\");\n\t\t\t$foundidx++;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t@stfull = stat($full) if (!$foundidx);\n\t}\nif (-d _) {\n\t# This is definitely a directory.. list it\n\tif ($config{'nolistdir'}) {\n\t\t&http_error(500, \"Directory is missing an index file\");\n\t\t}\n\tprint DEBUG \"handle_request: listing directory\\n\";\n\tlocal $resp = \"HTTP/1.0 $ok_code $ok_message\\r\\n\".\n\t\t      \"Date: $datestr\\r\\n\".\n\t\t      \"Server: $config{server}\\r\\n\".\n\t\t      \"Content-type: text/html; Charset=utf-8\\r\\n\";\n\t&write_data($resp);\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\t&reset_byte_count();\n\t&write_data(\"<h2 style='color: #de0000; margin-bottom: -8px;'>Index of $simple</h2>\\n\");\n\t&write_data(\"<pre>\\n\");\n\t&write_data(sprintf \"%-35.35s %-20.20s %-10.10s\\n\",\n\t\t\t\"Name\", \"Last Modified\", \"Size\");\n\t&write_data(\"<hr>\\n\");\n\topendir(DIR, $full);\n\twhile($df = readdir(DIR)) {\n\t\tif ($df =~ /^\\./) { next; }\n\t\t$fulldf = $full eq \"/\" ? $full.$df : $full.\"/\".$df;\n\t\t(@stbuf = stat($fulldf)) || next;\n\t\tif (-d _) { $df .= \"/\"; }\n\t\t@tm = localtime($stbuf[9]);\n\t\t$fdate = sprintf \"%2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d\",\n\t\t\t\t$tm[3],$tm[4]+1,$tm[5]+1900,\n\t\t\t\t$tm[0],$tm[1],$tm[2];\n\t\t$len = length($df); $rest = \" \"x(35-$len);\n\t\t&write_data(sprintf \n\t\t \"<a href=\\\"%s\\\">%-${len}.${len}s</a>$rest %-20.20s %-10.10s\\n\",\n\t\t &urlize($df), &html_strip($df), $fdate, $stbuf[7]);\n\t\t}\n\tclosedir(DIR);\n\t&log_request($loghost, $authuser, $reqline, $ok_code, &byte_count());\n\treturn 0;\n\t}\n\n# CGI or normal file\nlocal $rv;\nif (&get_type($full) eq \"internal/cgi\" && $validated != 4) {\n\t# A CGI program to execute\n\tprint DEBUG \"handle_request: executing CGI\\n\";\n\t$envtz = $ENV{\"TZ\"};\n\t$envuser = $ENV{\"USER\"};\n\t$envpath = $ENV{\"PATH\"};\n\t$envlang = $ENV{\"LANG\"};\n\t$envroot = $ENV{\"SystemRoot\"};\n\t$envperllib = $ENV{'PERLLIB'};\n\tforeach my $k (keys %ENV) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t$ENV{\"PATH\"} = $envpath if ($envpath);\n\t$ENV{\"TZ\"} = $envtz if ($envtz);\n\t$ENV{\"USER\"} = $envuser if ($envuser);\n\t$ENV{\"OLD_LANG\"} = $envlang if ($envlang);\n\t$ENV{\"SystemRoot\"} = $envroot if ($envroot);\n\t$ENV{'PERLLIB'} = $envperllib if ($envperllib);\n\t$ENV{\"HOME\"} = $user_homedir;\n\t$ENV{\"SERVER_SOFTWARE\"} = $config{\"server\"};\n\t$ENV{\"SERVER_NAME\"} = $host;\n\t$ENV{\"SERVER_ADMIN\"} = $config{\"email\"};\n\t$ENV{\"SERVER_ROOT\"} = $roots[0];\n\t$ENV{\"SERVER_REALROOT\"} = $realroot;\n\t$ENV{\"SERVER_PORT\"} = $port;\n\t$ENV{\"REMOTE_HOST\"} = $acpthost;\n\t$ENV{\"REMOTE_ADDR\"} = $acptip;\n\t$ENV{\"REMOTE_ADDR_PROTOCOL\"} = $ipv6 ? 6 : 4;\n\t$ENV{\"REMOTE_USER\"} = $authuser;\n\t$ENV{\"BASE_REMOTE_USER\"} = $authuser ne $baseauthuser ?\n\t\t\t\t\t$baseauthuser : undef;\n\t$ENV{\"REMOTE_PASS\"} = $authpass if (defined($authpass) &&\n\t\t\t\t\t    $config{'pass_password'});\n\tif ($uinfo && $uinfo->{'proto'}) {\n\t\t$ENV{\"REMOTE_USER_PROTO\"} = $uinfo->{'proto'};\n\t\t$ENV{\"REMOTE_USER_ID\"} = $uinfo->{'id'};\n\t\t}\n\tprint DEBUG \"REMOTE_USER = \",$ENV{\"REMOTE_USER\"},\"\\n\";\n\tprint DEBUG \"BASE_REMOTE_USER = \",$ENV{\"BASE_REMOTE_USER\"},\"\\n\";\n\tprint DEBUG \"proto=$uinfo->{'proto'} id=$uinfo->{'id'}\\n\" if ($uinfo);\n\t$ENV{\"SSL_USER\"} = $peername if ($validated == 2);\n\t$ENV{\"ANONYMOUS_USER\"} = \"1\" if ($validated == 3 || $validated == 4);\n\t$ENV{\"DOCUMENT_ROOT\"} = $roots[0];\n\t$ENV{\"THEME_ROOT\"} = \"$roots[0]/\" .\n\t                     ($config{\"preroot_$authuser\"} ||\n\t                      $config{\"preroot\"});\n\t$ENV{\"DOCUMENT_REALROOT\"} = $realroot;\n\t$ENV{\"GATEWAY_INTERFACE\"} = \"CGI/1.1\";\n\t$ENV{\"SERVER_PROTOCOL\"} = \"HTTP/1.0\";\n\t$ENV{\"REQUEST_METHOD\"} = $method;\n\t$ENV{\"SCRIPT_NAME\"} = $scriptname;\n\t$ENV{\"SCRIPT_FILENAME\"} = $full;\n\t$ENV{\"REQUEST_URI\"} = $request_uri;\n\t$ENV{\"PATH_INFO\"} = $pathinfo;\n\tif ($pathinfo) {\n\t\t$ENV{\"PATH_TRANSLATED\"} = \"$roots[0]$pathinfo\";\n\t\t$ENV{\"PATH_REALTRANSLATED\"} = \"$realroot$pathinfo\";\n\t\t}\n\t$ENV{\"QUERY_STRING\"} = $querystring;\n\t$ENV{\"MINISERV_CONFIG\"} = $config_file;\n\t$ENV{\"HTTPS\"} = $use_ssl || $config{'inetd_ssl'} ? \"ON\" : \"\";\n\t$ENV{\"MINISERV_PID\"} = $miniserv_main_pid;\n\t$ENV{\"SESSION_ID\"} = $session_id if ($session_id);\n\t$ENV{\"LOCAL_USER\"} = $localauth_user if ($localauth_user);\n\t$ENV{\"MINISERV_INTERNAL\"} = $miniserv_internal if ($miniserv_internal);\n\tif (defined($header{\"content-length\"})) {\n\t\t$ENV{\"CONTENT_LENGTH\"} = $header{\"content-length\"};\n\t\t}\n\tif (defined($header{\"content-type\"})) {\n\t\t$ENV{\"CONTENT_TYPE\"} = $header{\"content-type\"};\n\t\t}\n\tforeach $h (keys %header) {\n\t\t($hname = $h) =~ tr/a-z/A-Z/;\n\t\t$hname =~ s/\\-/_/g;\n\t\t$ENV{\"HTTP_$hname\"} = $header{$h};\n\t\t}\n\t$ENV{\"PWD\"} = $cgi_pwd;\n\tforeach $k (keys %config) {\n\t\tif ($k =~ /^env_(\\S+)$/) {\n\t\t\t$ENV{$1} = $config{$k};\n\t\t\t}\n\t\t}\n\tdelete($ENV{'HTTP_AUTHORIZATION'});\n\t$ENV{'HTTP_COOKIE'} =~ s/;?\\s*$sidname=([a-f0-9]+)//;\n\t$ENV{'MOBILE_DEVICE'} = 1 if ($mobile_device);\n\n\t# Check if the CGI can be handled internally\n\topen(CGI, $full);\n\tlocal $first = <CGI>;\n\tclose(CGI);\n\t$first =~ s/[#!\\r\\n]//g;\n\t$nph_script = ($full =~ /\\/nph-([^\\/]+)$/);\n\tseek(STDERR, 0, 2);\n\tif (!$config{'forkcgis'} &&\n\t    ($first eq $perl_path || $first eq $linked_perl_path ||\n\t     $first =~ /\\/perl$/ || $first =~ /^\\/\\S+\\/env\\s+perl$/) &&\n\t      $] >= 5.004 ||\n            $config{'internalcgis'}) {\n\t\t# setup environment for eval\n\t\tchdir($ENV{\"PWD\"});\n\t\t@ARGV = split(/\\s+/, $queryargs);\n\t\t$0 = $full;\n\t\tif ($posted_data) {\n\t\t\t# Already read the post input\n\t\t\t$postinput = $posted_data;\n\t\t\t}\n\t\t$clen = $header{\"content-length\"};\n\t\t$SIG{'CHLD'} = 'DEFAULT';\n\t\teval {\n\t\t\t# Have SOCK closed if the perl exec's something\n\t\t\tuse Fcntl;\n\t\t\tfcntl(SOCK, F_SETFD, FD_CLOEXEC);\n\t\t\t};\n\t\t#shutdown(SOCK, 0);\n\n\t\tif ($config{'log'}) {\n\t\t\topen(MINISERVLOG, \">>$config{'logfile'}\");\n\t\t\tif ($config{'logperms'}) {\n\t\t\t\tchmod(oct($config{'logperms'}),\n\t\t\t\t      $config{'logfile'});\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tchmod(0600, $config{'logfile'});\n\t\t\t\t}\n\t\t\t}\n\t\t$doing_cgi_eval = 1;\n\t\t$main_process_id = $$;\n\t\t$pkg = \"main\";\n\t\tif ($full =~ /^\\Q$foundroot\\E\\/([^\\/]+)\\//) {\n\t\t\t# Eval in package from Webmin module name\n\t\t\t$pkg = $1;\n\t\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\t\t}\n\t\teval \"\n\t\t\t\\%pkg::ENV = \\%ENV;\n\t\t\tpackage $pkg;\n\t\t\ttie(*STDOUT, 'miniserv');\n\t\t\ttie(*STDIN, 'miniserv');\n\t\t\tdo \\$miniserv::full;\n\t\t\tdie \\$@ if (\\$@);\n\t\t\t\";\n\t\t$doing_cgi_eval = 0;\n\t\tif ($@) {\n\t\t\t# Error in perl!\n\t\t\t&http_error(500, \"Perl execution failed\",\n\t\t\t\t    $config{'noshowstderr'} ? undef : \"$@\");\n\t\t\t}\n\t\telsif (!$doneheaders && !$nph_script) {\n\t\t\t&http_error(500, \"Missing Headers\");\n\t\t\t}\n\t\t$rv = 0;\n\t\t}\n\telse {\n\t\t$infile = undef;\n\t\tif (!$on_windows) {\n\t\t\t# fork the process that actually executes the CGI\n\t\t\tpipe(CGIINr, CGIINw);\n\t\t\tpipe(CGIOUTr, CGIOUTw);\n\t\t\tpipe(CGIERRr, CGIERRw);\n\t\t\tif (!($cgipid = fork())) {\n\t\t\t\t@execargs = ( $full, split(/\\s+/, $queryargs) );\n\t\t\t\tchdir($ENV{\"PWD\"});\n\t\t\t\tclose(SOCK);\n\t\t\t\topen(STDIN, \"<&CGIINr\");\n\t\t\t\topen(STDOUT, \">&CGIOUTw\");\n\t\t\t\topen(STDERR, \">&CGIERRw\");\n\t\t\t\tclose(CGIINw); close(CGIOUTr); close(CGIERRr);\n\t\t\t\texec(@execargs) ||\n\t\t\t\t\tdie \"Failed to exec $full : $!\\n\";\n\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\tclose(CGIINr); close(CGIOUTw); close(CGIERRw);\n\t\t\t}\n\t\telse {\n\t\t\t# write CGI input to a temp file\n\t\t\t$infile = \"$config{'tempbase'}.$$\";\n\t\t\topen(CGIINw, \">$infile\");\n\t\t\t# NOT binary mode, as CGIs don't read in it!\n\t\t\t}\n\n\t\t# send post data\n\t\tif ($posted_data) {\n\t\t\t# already read the posted data\n\t\t\tprint CGIINw $posted_data;\n\t\t\t}\n\t\t$clen = $header{\"content-length\"};\n\t\tif ($method eq \"POST\" && $clen_read < $clen) {\n\t\t\t$SIG{'PIPE'} = 'IGNORE';\n\t\t\t$got = $clen_read;\n\t\t\twhile($got < $clen) {\n\t\t\t\t$buf = &read_data($clen-$got);\n\t\t\t\tif (!length($buf)) {\n\t\t\t\t\tkill('TERM', $cgipid);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Failed to read \".\n\t\t\t\t\t\t\t \"POST request\");\n\t\t\t\t\t}\n\t\t\t\t$got += length($buf);\n\t\t\t\tlocal ($wrote) = (print CGIINw $buf);\n\t\t\t\tlast if (!$wrote);\n\t\t\t\t}\n\t\t\t# If the CGI terminated early, we still need to read\n\t\t\t# from the browser and throw away\n\t\t\twhile($got < $clen) {\n\t\t\t\t$buf = &read_data($clen-$got);\n\t\t\t\tif (!length($buf)) {\n\t\t\t\t\tkill('TERM', $cgipid);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Failed to read \".\n\t\t\t\t\t\t\t \"POST request\");\n\t\t\t\t\t}\n\t\t\t\t$got += length($buf);\n\t\t\t\t}\n\t\t\t$SIG{'PIPE'} = 'DEFAULT';\n\t\t\t}\n\t\tclose(CGIINw);\n\t\tshutdown(SOCK, 0);\n\n\t\tif ($on_windows) {\n\t\t\t# Run the CGI program, and feed it input\n\t\t\tchdir($ENV{\"PWD\"});\n\t\t\tlocal $qqueryargs = join(\" \",\n\t\t\t\tmap { s/([<>|&\"^])/^$1/g; \"\\\"$_\\\"\" }\n\t\t\t\t    split(/\\s+/, $queryargs));\n\t\t\tif ($first =~ /(perl|perl.exe)$/i) {\n\t\t\t\t# On Windows, run with Perl\n\t\t\t\topen(CGIOUTr, \"$perl_path \\\"$full\\\" $qqueryargs <$infile |\");\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\topen(CGIOUTr, \"\\\"$full\\\" $qqueryargs <$infile |\");\n\t\t\t\t}\n\t\t\tbinmode(CGIOUTr);\n\t\t\t}\n\n\t\tif (!$nph_script) {\n\t\t\t# read back cgi headers\n\t\t\tselect(CGIOUTr); $|=1; select(STDOUT);\n\t\t\t$got_blank = 0;\n\t\t\twhile(1) {\n\t\t\t\t$line = <CGIOUTr>;\n\t\t\t\t$line =~ s/\\r|\\n//g;\n\t\t\t\tif ($line eq \"\") {\n\t\t\t\t\tif ($got_blank || %cgiheader) { last; }\n\t\t\t\t\t$got_blank++;\n\t\t\t\t\tnext;\n\t\t\t\t\t}\n\t\t\t\tif ($line !~ /^(\\S+):\\s+(.*)$/) {\n\t\t\t\t\t$errs = &read_errors(CGIERRr);\n\t\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t\t&http_error(500, \"Bad Header\", $errs);\n\t\t\t\t\t}\n\t\t\t\t$cgiheader{lc($1)} = $2;\n\t\t\t\tpush(@cgiheader, [ $1, $2 ]);\n\t\t\t\t}\n\t\t\tif ($cgiheader{\"location\"}) {\n\t\t\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t# ignore the rest of the output. This is a hack,\n\t\t\t\t# but is necessary for IE in some cases :(\n\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\t}\n\t\t\telsif ($cgiheader{\"content-type\"} eq \"\") {\n\t\t\t\tclose(CGIOUTr); close(CGIERRr);\n\t\t\t\tunlink($infile) if ($infile);\n\t\t\t\t$errs = &read_errors(CGIERRr);\n\t\t\t\t&http_error(500, \"Missing Content-Type Header\",\n\t\t\t\t    $config{'noshowstderr'} ? undef : $errs);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&write_data(\"HTTP/1.0 $ok_code $ok_message\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\tforeach $h (@cgiheader) {\n\t\t\t\t&write_data(\"$h->[0]: $h->[1]\\r\\n\");\n\t\t\t\t}\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\t}\n\t\t&reset_byte_count();\n\t\twhile($line = <CGIOUTr>) {\n\t\t\t&write_data($line);\n\t\t\t}\n\t\tclose(CGIOUTr);\n\t\tclose(CGIERRr);\n\t\tunlink($infile) if ($infile);\n\t\t$rv = 0;\n\t\t}\n\t}\nelse {\n\t# A file to output\n\tprint DEBUG \"handle_request: outputting file $full\\n\";\n\t$gzfile = $full.\".gz\";\n\t$gzipped = 0;\n\tif ($config{'gzip'} ne '0' && -r $gzfile && $acceptenc{'gzip'}) {\n\t\t# Using gzipped version\n\t\t@stopen = stat($gzfile);\n\t\tif ($stopen[9] >= $stfull[9] && open(FILE, $gzfile)) {\n\t\t\tprint DEBUG \"handle_request: using gzipped $gzfile\\n\";\n\t\t\t$gzipped = 1;\n\t\t\t}\n\t\t}\n\tif (!$gzipped) {\n\t\t# Using original file\n\t\t@stopen = @stfull;\n\t\topen(FILE, $full) || &http_error(404, \"Failed to open file\");\n\t\t}\n\tbinmode(FILE);\n\n\t# Build common headers\n\tlocal $etime = &get_expires_time($simple);\n\tlocal $resp = \"HTTP/1.0 $ok_code $ok_message\\r\\n\".\n\t\t      \"Date: $datestr\\r\\n\".\n\t\t      \"Server: $config{server}\\r\\n\".\n\t\t      \"Content-type: \".&get_type($full).\"\\r\\n\".\n\t\t      \"Last-Modified: \".&http_date($stopen[9]).\"\\r\\n\".\n\t\t      \"Expires: \".&http_date(time()+$etime).\"\\r\\n\".\n\t\t      \"Cache-Control: public; max-age=\".$etime.\"\\r\\n\";\n\n\tif (!$gzipped && $use_gzip && $acceptenc{'gzip'} &&\n\t    &should_gzip_file($full)) {\n\t\t# Load and compress file, then output\n\t\tprint DEBUG \"handle_request: outputting gzipped file $full\\n\";\n\t\topen(FILE, $full) || &http_error(404, \"Failed to open file\");\n\t\t{\n\t\t\tlocal $/ = undef;\n\t\t\t$data = <FILE>;\n\t\t}\n\t\tclose(FILE);\n\t\t@stopen = stat($file);\n\t\t$data = Compress::Zlib::memGzip($data);\n\t\t$resp .= \"Content-length: \".length($data).\"\\r\\n\".\n\t\t\t \"Content-Encoding: gzip\\r\\n\";\n\t\t&write_data($resp);\n\t\t$rv = &write_keep_alive();\n\t\t&write_data(\"\\r\\n\");\n\t\t&reset_byte_count();\n\t\t&write_data($data);\n\t\t}\n\telse {\n\t\t# Stream file output\n\t\t$resp .= \"Content-length: $stopen[7]\\r\\n\";\n\t\t$resp .= \"Content-Encoding: gzip\\r\\n\" if ($gzipped);\n\t\t&write_data($resp);\n\t\t$rv = &write_keep_alive();\n\t\t&write_data(\"\\r\\n\");\n\t\t&reset_byte_count();\n\t\tmy $bufsize = $config{'bufsize'} || 32768;\n\t\twhile(read(FILE, $buf, $bufsize) > 0) {\n\t\t\t&write_data($buf);\n\t\t\t}\n\t\tclose(FILE);\n\t\t}\n\t}\n\n# log the request\n&log_request($loghost, $authuser, $reqline,\n\t     $logged_code ? $logged_code :\n\t     $cgiheader{\"location\"} ? \"302\" : $ok_code, &byte_count());\nreturn $rv;\n}\n\n# http_error(code, message, body, [dontexit], [dontstderr])\n# Output an error message to the browser, and log it to the error log\nsub http_error\n{\nmy ($code, $msg, $body, $noexit, $noerr) = @_;\nlocal $eh = $error_handler_recurse ? undef :\n\t    $config{\"error_handler_\".$code} ? $config{\"error_handler_\".$code} :\n\t    $config{'error_handler'} ? $config{'error_handler'} : undef;\nprint DEBUG \"http_error code=$code message=$msg body=$body\\n\";\nif ($eh) {\n\t# Call a CGI program for the error\n\t$page = \"/$eh\";\n\t$querystring = \"code=$_[0]&message=\".&urlize($msg).\n\t\t       \"&body=\".&urlize($body);\n\t$error_handler_recurse++;\n\t$ok_code = $code;\n\t$ok_message = $msg;\n\tgoto rerun;\n\t}\nelse {\n\t# Use the standard error message display\n\t&write_data(\"HTTP/1.0 $code $msg\\r\\n\");\n\t&write_data(\"Server: $config{server}\\r\\n\");\n\t&write_data(\"Date: $datestr\\r\\n\");\n\t&write_data(\"Content-type: text/html; Charset=utf-8\\r\\n\");\n\t&write_keep_alive(0);\n\t&write_data(\"\\r\\n\");\n\t&reset_byte_count();\n\t&write_data(\"<h2 style='color: #de0000; margin-bottom: -8px;'>Error - $msg</h2>\\n\");\n\tif ($body) {\n\t\t&write_data(\"<p>$body</p>\\n\");\n\t\t}\n\t}\n&log_request($loghost, $authuser, $reqline, $code, &byte_count())\n\tif ($reqline);\n&log_error($msg, $body ? \" : $body\" : \"\") if (!$noerr);\nshutdown(SOCK, 1);\nexit if (!$noexit);\n}\n\nsub get_type\n{\nif ($_[0] =~ /\\.([A-z0-9]+)$/) {\n\t$t = $mime{$1};\n\tif ($t ne \"\") {\n\t\treturn $t;\n\t\t}\n\t}\nreturn \"text/plain\";\n}\n\n# simplify_path(path, bogus)\n# Given a path, maybe containing stuff like \"..\" and \".\" convert it to a\n# clean, absolute form.\nsub simplify_path\n{\nlocal($dir, @bits, @fixedbits, $b);\n$dir = $_[0];\n$dir =~ s/\\\\/\\//g;\t# fix windows \\ in path\n$dir =~ s/^\\/+//g;\n$dir =~ s/\\/+$//g;\n$dir =~ s/\\0//g;\t# remove null bytes\n@bits = split(/\\/+/, $dir);\n@fixedbits = ();\n$_[1] = 0;\nforeach $b (@bits) {\n        if ($b eq \".\") {\n                # Do nothing..\n                }\n        elsif ($b eq \"..\" || $b eq \"...\") {\n                # Remove last dir\n                if (scalar(@fixedbits) == 0) {\n                        $_[1] = 1;\n                        return \"/\";\n                        }\n                pop(@fixedbits);\n                }\n        else {\n                # Add dir to list\n                push(@fixedbits, $b);\n                }\n        }\nreturn \"/\" . join('/', @fixedbits);\n}\n\n# b64decode(string)\n# Converts a string from base64 format to normal\nsub b64decode\n{\n    local($str) = $_[0];\n    local($res);\n    $str =~ tr|A-Za-z0-9+=/||cd;\n    $str =~ s/=+$//;\n    $str =~ tr|A-Za-z0-9+/| -_|;\n    while ($str =~ /(.{1,60})/gs) {\n        my $len = chr(32 + length($1)*3/4);\n        $res .= unpack(\"u\", $len . $1 );\n    }\n    return $res;\n}\n\n# ip_match(remoteip, localip, [match]+)\n# Checks an IP address against a list of IPs, networks and networks/masks\nsub ip_match\n{\nlocal(@io, @mo, @ms, $i, $j, $hn, $needhn);\n@io = &check_ip6address($_[0]) ? split(/:/, $_[0])\n\t\t\t       : split(/\\./, $_[0]);\nfor($i=2; $i<@_; $i++) {\n\t$needhn++ if ($_[$i] =~ /^\\*(\\S+)$/);\n\t}\nif ($needhn && !defined($hn = $ip_match_cache{$_[0]})) {\n\t# Reverse-lookup hostname if any rules match based on it\n\t$hn = &to_hostname($_[0]);\n\tif (&check_ip6address($_[0])) {\n\t\t$hn = \"\" if (&to_ip6address($hn) ne $_[0]);\n\t\t}\n\telse {\n\t\t$hn = \"\" if (&to_ipaddress($hn) ne $_[0]);\n\t\t}\n\t$ip_match_cache{$_[0]} = $hn;\n\t}\nfor($i=2; $i<@_; $i++) {\n\tlocal $mismatch = 0;\n\tif ($_[$i] =~ /^([0-9\\.]+)\\/(\\d+)$/) {\n\t\t# Convert CIDR to netmask format\n\t\t$_[$i] = $1.\"/\".&prefix_to_mask($2);\n\t\t}\n\tif ($_[$i] =~ /^([0-9\\.]+)\\/([0-9\\.]+)$/) {\n\t\t# Compare with IPv4 network/mask\n\t\t@mo = split(/\\./, $1);\n\t\t@ms = split(/\\./, $2);\n\t\tfor($j=0; $j<4; $j++) {\n\t\t\tif ((int($io[$j]) & int($ms[$j])) != (int($mo[$j]) & int($ms[$j]))) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^([0-9\\.]+)-([0-9\\.]+)$/) {\n\t\t# Compare with an IPv4 range (separated by a hyphen -)\n\t\tlocal ($remote, $min, $max);\n\t\tlocal @low = split(/\\./, $1);\n\t\tlocal @high = split(/\\./, $2);\n\t\tfor($j=0; $j<4; $j++) {\n\t\t\t$remote += $io[$j] << ((3-$j)*8);\n\t\t\t$min += $low[$j] << ((3-$j)*8);\n\t\t\t$max += $high[$j] << ((3-$j)*8);\n\t\t\t}\n\t\tif ($remote < $min || $remote > $max) {\n\t\t\t$mismatch = 1;\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^\\*(\\S+)$/) {\n\t\t# Compare with hostname regexp\n\t\t$mismatch = 1 if ($hn !~ /^.*\\Q$1\\E$/i);\n\t\t}\n\telsif ($_[$i] eq 'LOCAL' && &check_ipaddress($_[1])) {\n\t\t# Compare with local IPv4 network\n\t\tlocal @lo = split(/\\./, $_[1]);\n\t\tif ($lo[0] < 128) {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0]);\n\t\t\t}\n\t\telsif ($lo[0] < 192) {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0] ||\n\t\t\t\t\t  $lo[1] != $io[1]);\n\t\t\t}\n\t\telse {\n\t\t\t$mismatch = 1 if ($lo[0] != $io[0] ||\n\t\t\t\t\t  $lo[1] != $io[1] ||\n\t\t\t\t\t  $lo[2] != $io[2]);\n\t\t\t}\n\t\t}\n\telsif ($_[$i] eq 'LOCAL' && &check_ip6address($_[1])) {\n\t\t# Compare with local IPv6 network, which is always first 4 words\n\t\tlocal @lo = split(/:/, $_[1]);\n\t\tfor(my $i=0; $i<4; $i++) {\n\t\t\t$mismatch = 1 if ($lo[$i] ne $io[$i]);\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^[0-9\\.]+$/) {\n\t\t# Compare with a full or partial IPv4 address\n\t\t@mo = split(/\\./, $_[$i]);\n\t\twhile(@mo && !$mo[$#mo]) { pop(@mo); }\n\t\tfor($j=0; $j<@mo; $j++) {\n\t\t\tif ($mo[$j] != $io[$j]) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^[a-f0-9:]+$/) {\n\t\t# Compare with a full IPv6 address\n\t\tif (&canonicalize_ip6($_[$i]) ne canonicalize_ip6($_[0])) {\n\t\t\t$mismatch = 1;\n\t\t\t}\n\t\t}\n\telsif ($_[$i] =~ /^([a-f0-9:]+)\\/(\\d+)$/) {\n\t\t# Compare with an IPv6 network\n\t\tlocal $v6size = $2;\n\t\tlocal $v6addr = &canonicalize_ip6($1);\n\t\tlocal $bytes = $v6size / 8;\n\t\t@mo = &expand_ipv6_bytes($v6addr);\n\t\tlocal @io6 = &expand_ipv6_bytes(&canonicalize_ip6($_[0]));\n\t\tfor($j=0; $j<$bytes; $j++) {\n\t\t\tif ($mo[$j] ne $io6[$j]) {\n\t\t\t\t$mismatch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($_[$i] !~ /^[0-9\\.]+$/) {\n\t\t# Compare with hostname\n\t\t$mismatch = 1 if ($_[0] ne &to_ipaddress($_[$i]));\n\t\t}\n\treturn 1 if (!$mismatch);\n\t}\nreturn 0;\n}\n\n# users_match(&uinfo, user, ...)\n# Returns 1 if a user is in a list of users and groups\nsub users_match\n{\nlocal $uinfo = shift(@_);\nlocal $u;\nlocal @ginfo = getgrgid($uinfo->[3]);\nforeach $u (@_) {\n\tif ($u =~ /^\\@(\\S+)$/) {\n\t\treturn 1 if (&is_group_member($uinfo, $1));\n\t\t}\n\telsif ($u =~ /^(\\d*)-(\\d*)$/ && ($1 || $2)) {\n\t\treturn (!$1 || $uinfo[2] >= $1) &&\n\t\t       (!$2 || $uinfo[2] <= $2);\n\t\t}\n\telse {\n\t\treturn 1 if ($u eq $uinfo->[0]);\n\t\t}\n\t}\nreturn 0;\n}\n\n# restart_miniserv()\n# Called when a SIGHUP is received to restart the web server. This is done\n# by exec()ing perl with the same command line as was originally used\nsub restart_miniserv\n{\n&log_error(\"Restarting\");\nclose(SOCK);\n&close_all_sockets();\n&close_all_pipes();\ndbmclose(%sessiondb);\nkill('KILL', $logclearer) if ($logclearer);\nkill('KILL', $extauth) if ($extauth);\nexec($perl_path, $miniserv_path, @miniserv_argv);\ndie \"Failed to restart miniserv with $perl_path $miniserv_path\";\n}\n\nsub trigger_restart\n{\n$need_restart = 1;\n}\n\nsub trigger_reload\n{\n$need_reload = 1;\n}\n\n# to_ip46address(address, ...)\n# Convert hostnames to v4 and v6 addresses, if possible\nsub to_ip46address\n{\nlocal @rv;\nforeach my $i (@_) {\n\tif (&check_ipaddress($i) || &check_ip6address($i)) {\n\t\tpush(@rv, $i);\n\t\t}\n\telse {\n\t\tmy $addr = &to_ipaddress($i);\n\t\t$addr ||= &to_ip6address($i);\n\t\tpush(@rv, $addr) if ($addr);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# to_ipaddress(address, ...)\nsub to_ipaddress\n{\nlocal (@rv, $i);\nforeach $i (@_) {\n\tif ($i =~ /(\\S+)\\/(\\S+)/ || $i =~ /^\\*\\S+$/ ||\n\t    $i eq 'LOCAL' || $i =~ /^[0-9\\.]+$/ || $i =~ /^[a-f0-9:]+$/) {\n\t\t# A pattern or IP, not a hostname, so don't change\n\t\tpush(@rv, $i);\n\t\t}\n\telse {\n\t\t# Lookup IP address\n\t\tpush(@rv, join('.', unpack(\"CCCC\", inet_aton($i))));\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n# to_ip6address(address, ...)\nsub to_ip6address\n{\nlocal (@rv, $i);\nforeach $i (@_) {\n\tif ($i =~ /(\\S+)\\/(\\S+)/ || $i =~ /^\\*\\S+$/ ||\n\t    $i eq 'LOCAL' || $i =~ /^[0-9\\.]+$/ || $i =~ /^[a-f0-9:]+$/) {\n\t\t# A pattern, not a hostname, so don't change\n\t\tpush(@rv, $i);\n\t\t}\n\telsif ($config{'ipv6'}) {\n\t\t# Lookup IPv6 address\n\t\tlocal ($inaddr, $addr);\n\t\teval {\n\t\t\t(undef, undef, undef, $inaddr) =\n\t\t\t    getaddrinfo($i, undef, AF_INET6(), SOCK_STREAM);\n\t\t\t};\n\t\tif ($inaddr) {\n\t\t\tpush(@rv, undef);\n\t\t\t}\n\t\telse {\n\t\t\t(undef, $addr) = unpack_sockaddr_in6($inaddr);\n\t\t\tpush(@rv, inet_ntop(AF_INET6(), $addr));\n\t\t\t}\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n# to_hostname(ipv4|ipv6-address)\n# Reverse-resolves an IPv4 or 6 address to a hostname\nsub to_hostname\n{\nlocal ($addr) = @_;\nif (&check_ip6address($_[0])) {\n\treturn gethostbyaddr(inet_pton(AF_INET6(), $addr),\n\t\t\t     AF_INET6());\n\t}\nelse {\n\treturn gethostbyaddr(inet_aton($addr), AF_INET);\n\t}\n}\n\n# read_line(no-wait, no-limit)\n# Reads one line from SOCK or SSL\nsub read_line\n{\nlocal ($nowait, $nolimit) = @_;\nlocal($idx, $more, $rv);\nwhile(($idx = index($main::read_buffer, \"\\n\")) < 0) {\n\tif (length($main::read_buffer) > 100000 && !$nolimit) {\n\t\t&http_error(414, \"Request too long\",\n\t\t    \"Received excessive line <pre>\".&html_strip($main::read_buffer).\"</pre>\");\n\t\t}\n\n\t# need to read more..\n\t&wait_for_data_error() if (!$nowait);\n\tif ($use_ssl) {\n\t\t$more = Net::SSLeay::read($ssl_con);\n\t\t}\n\telse {\n\t\tmy $bufsize = $config{'bufsize'} || 32768;\n                local $ok = sysread(SOCK, $more, $bufsize);\n\t\t$more = undef if ($ok <= 0);\n\t\t}\n\tif ($more eq '') {\n\t\t# end of the data\n\t\t$rv = $main::read_buffer;\n\t\tundef($main::read_buffer);\n\t\treturn $rv;\n\t\t}\n\t$main::read_buffer .= $more;\n\t}\n$rv = substr($main::read_buffer, 0, $idx+1);\n$main::read_buffer = substr($main::read_buffer, $idx+1);\nreturn $rv;\n}\n\n# read_data(length)\n# Reads up to some amount of data from SOCK or the SSL connection\nsub read_data\n{\nlocal ($rv);\nif (length($main::read_buffer)) {\n\tif (length($main::read_buffer) > $_[0]) {\n\t\t# Return the first part of the buffer\n\t\t$rv = substr($main::read_buffer, 0, $_[0]);\n\t\t$main::read_buffer = substr($main::read_buffer, $_[0]);\n\t\treturn $rv;\n\t\t}\n\telse {\n\t\t# Return the whole buffer\n\t\t$rv = $main::read_buffer;\n\t\tundef($main::read_buffer);\n\t\treturn $rv;\n\t\t}\n\t}\nelsif ($use_ssl) {\n\t# Call SSL read function\n\treturn Net::SSLeay::read($ssl_con, $_[0]);\n\t}\nelse {\n\t# Just do a normal read\n\tlocal $buf;\n\tsysread(SOCK, $buf, $_[0]) || return undef;\n\treturn $buf;\n\t}\n}\n\n# wait_for_data(secs)\n# Waits at most the given amount of time for some data on SOCK, returning\n# 0 if not found, 1 if some arrived.\nsub wait_for_data\n{\nlocal $rmask;\nvec($rmask, fileno(SOCK), 1) = 1;\nlocal $got = select($rmask, undef, undef, $_[0]);\nreturn $got == 0 ? 0 : 1;\n}\n\n# wait_for_data_error()\n# Waits 60 seconds for data on SOCK, and fails if none arrives\nsub wait_for_data_error\n{\nlocal $got = &wait_for_data(60);\nif (!$got) {\n\t&http_error(400, \"Timeout\",\n\t\t    \"Waited more than 60 seconds for request data\");\n\t}\n}\n\n# write_data(data, ...)\n# Writes a string to SOCK or the SSL connection\nsub write_data\n{\nlocal $str = join(\"\", @_);\nif ($use_ssl) {\n\tNet::SSLeay::write($ssl_con, $str);\n\t}\nelse {\n\teval { syswrite(SOCK, $str, length($str)); };\n\tif ($@ =~ /wide\\s+character/i) {\n\t\teval { utf8::encode($str);\n\t\t       syswrite(SOCK, $str, length($str)); };\n\t\t}\n\tif ($@) {\n\t\t# Somehow a string come through that contains invalid chars\n\t\tprint STDERR $@,\"\\n\";\n\t\tfor(my $i=0; my @stack = caller($i); $i++) {\n\t\t\tprint STDERR join(\" \", @stack),\"\\n\";\n\t\t\t}\n\t\t}\n\t}\n$write_data_count += length($str);\n}\n\n# reset_byte_count()\nsub reset_byte_count { $write_data_count = 0; }\n\n# byte_count()\nsub byte_count { return $write_data_count; }\n\n# log_request(hostname, user, request, code, bytes)\n# Write an HTTP request to the log file\nsub log_request\n{\nlocal ($host, $user, $request, $code, $bytes) = @_;\nlocal $headers;\nmy $request_nolog = $request;\n\n# Process full request string like `POST /index.cgi?param=1 HTTP/1.1` as well\nif ($request =~ /^(POST|GET)\\s+/) {\n\t$request_nolog =~ s/(.*?)(\\/.*?)\\s+(.*)/$2/g;\n\t}\nif ($config{'nolog'}) {\n\tforeach my $nolog (split(/\\s+/, $config{'nolog'})) {\n\t\treturn if ($request_nolog =~ /^$nolog$/);\n\t\t}\n\t}\nif ($config{'log'}) {\n\tlocal $ident = \"-\";\n\t$user ||= \"-\";\n\tlocal $dstr = &make_datestr();\n\tif (fileno(MINISERVLOG)) {\n\t\tseek(MINISERVLOG, 0, 2);\n\t\t}\n\telse {\n\t\topen(MINISERVLOG, \">>$config{'logfile'}\");\n\t\tchmod(0600, $config{'logfile'});\n\t\t}\n\tif (defined($config{'logheaders'})) {\n\t\tforeach $h (split(/\\s+/, $config{'logheaders'})) {\n\t\t\t$headers .= \" $h=\\\"$header{$h}\\\"\";\n\t\t\t}\n\t\t}\n\telsif ($config{'logclf'}) {\n\t\t$headers = \" \\\"$header{'referer'}\\\" \\\"$header{'user-agent'}\\\"\";\n\t\t}\n\telse {\n\t\t$headers = \"\";\n\t\t}\n\tprint MINISERVLOG \"$host $ident $user [$dstr] \\\"$request\\\" \",\n\t\t\t  \"$code $bytes$headers\\n\";\n\tclose(MINISERVLOG);\n\t}\n}\n\n# make_datestr()\nsub make_datestr\n{\nlocal @tm = localtime(time());\nreturn sprintf \"%2.2d/%s/%4.4d:%2.2d:%2.2d:%2.2d %s\",\n\t\t$tm[3], $month[$tm[4]], $tm[5]+1900,\n\t        $tm[2], $tm[1], $tm[0], $timezone;\n}\n\n# log_error(message)\nsub log_error\n{\nseek(STDERR, 0, 2);\nprint STDERR \"[\",&make_datestr(),\"] \",\n\t$acpthost ? ( \"[\",$acpthost,\"] \" ) : ( ),\n\t$page ? ( $page,\" : \" ) : ( ),\n\t@_,\"\\n\";\n}\n\n# read_errors(handle)\n# Read and return all input from some filehandle\nsub read_errors\n{\nlocal($fh, $_, $rv);\n$fh = $_[0];\nwhile(<$fh>) { $rv .= $_; }\nreturn $rv;\n}\n\nsub write_keep_alive\n{\nlocal $mode;\nif ($config{'nokeepalive'}) {\n\t# Keep alives have been disabled in config\n\t$mode = 0;\n\t}\nelsif (@childpids > $config{'maxconns'}*.8) {\n\t# Disable because nearing process limit\n\t$mode = 0;\n\t}\nelsif (@_) {\n\t# Keep alive specified by caller\n\t$mode = $_[0];\n\t}\nelse {\n\t# Keep alive determined by browser\n\t$mode = $header{'connection'} =~ /keep-alive/i;\n\t}\n&write_data(\"Connection: \".($mode ? \"Keep-Alive\" : \"close\").\"\\r\\n\");\nreturn $mode;\n}\n\nsub term_handler\n{\nkill('TERM', @childpids) if (@childpids);\nkill('KILL', $logclearer) if ($logclearer);\nkill('KILL', $extauth) if ($extauth);\nexit(1);\n}\n\nsub http_date\n{\nlocal @tm = gmtime($_[0]);\nreturn sprintf \"%s, %d %s %d %2.2d:%2.2d:%2.2d GMT\",\n\t\t$weekday[$tm[6]], $tm[3], $month[$tm[4]], $tm[5]+1900,\n\t\t$tm[2], $tm[1], $tm[0];\n}\n\nsub TIEHANDLE\n{\nmy $i; bless \\$i, shift;\n}\n \nsub WRITE\n{\n$r = shift;\nmy($buf,$len,$offset) = @_;\n&write_to_sock(substr($buf, $offset, $len));\n$miniserv::page_capture_out .= substr($buf, $offset, $len)\n\tif ($miniserv::page_capture);\n}\n \nsub PRINT\n{\n$r = shift;\n$$r++;\nmy $buf = join(defined($,) ? $, : \"\", @_);\n$buf .= $\\ if defined($\\);\n&write_to_sock($buf);\n$miniserv::page_capture_out .= $buf\n\tif ($miniserv::page_capture);\n}\n \nsub PRINTF\n{\nshift;\nmy $fmt = shift;\nmy $buf = sprintf $fmt, @_;\n&write_to_sock($buf);\n$miniserv::page_capture_out .= $buf\n\tif ($miniserv::page_capture);\n}\n \n# Send back already read data while we have it, then read from SOCK\nsub READ\n{\nmy $r = shift;\nmy $bufref = \\$_[0];\nmy $len = $_[1];\nmy $offset = $_[2];\nif ($postpos < length($postinput)) {\n\t# Reading from already fetched array\n\tmy $left = length($postinput) - $postpos;\n\tmy $canread = $len > $left ? $left : $len;\n\tsubstr($$bufref, $offset, $canread) =\n\t\tsubstr($postinput, $postpos, $canread);\n\t$postpos += $canread;\n\treturn $canread;\n\t}\nelse {\n\t# Read from network socket\n\tlocal $data = &read_data($len);\n\tif ($data eq '' && $len) {\n\t\t# End of socket\n\t\tshutdown(SOCK, 0);\n\t\t}\n\tsubstr($$bufref, $offset, length($data)) = $data;\n\treturn length($data);\n\t}\n}\n\nsub OPEN\n{\n#print STDERR \"open() called - should never happen!\\n\";\n}\n \n# Read a line of input\nsub READLINE\n{\nmy $r = shift;\nif ($postpos < length($postinput) &&\n    ($idx = index($postinput, \"\\n\", $postpos)) >= 0) {\n\t# A line exists in the memory buffer .. use it\n\tmy $line = substr($postinput, $postpos, $idx-$postpos+1);\n\t$postpos = $idx+1;\n\treturn $line;\n\t}\nelse {\n\t# Need to read from the socket\n\tmy $line;\n\tif ($postpos < length($postinput)) {\n\t\t# Start with in-memory data\n\t\t$line = substr($postinput, $postpos);\n\t\t$postpos = length($postinput);\n\t\t}\n\tmy $nl = &read_line(0, 1);\n\tif ($nl eq '') {\n\t\t# End of socket\n\t\tshutdown(SOCK, 0);\n\t\t}\n\t$line .= $nl if (defined($nl));\n\treturn $line;\n\t}\n}\n \n# Read one character of input\nsub GETC\n{\nmy $r = shift;\nmy $buf;\nmy $got = READ($r, \\$buf, 1, 0);\nreturn $got > 0 ? $buf : undef;\n}\n\nsub FILENO\n{\nreturn fileno(SOCK);\n}\n \nsub CLOSE { }\n \nsub DESTROY { }\n\n# write_to_sock(data, ...)\nsub write_to_sock\n{\nlocal $d;\nforeach $d (@_) {\n\tif ($doneheaders || $miniserv::nph_script) {\n\t\t&write_data($d);\n\t\t}\n\telse {\n\t\t$headers .= $d;\n\t\twhile(!$doneheaders && $headers =~ s/^([^\\r\\n]*)(\\r)?\\n//) {\n\t\t\tif ($1 =~ /^(\\S+):\\s+(.*)$/) {\n\t\t\t\t$cgiheader{lc($1)} = $2;\n\t\t\t\tpush(@cgiheader, [ $1, $2 ]);\n\t\t\t\t}\n\t\t\telsif ($1 !~ /\\S/) {\n\t\t\t\t$doneheaders++;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&http_error(500, \"Bad Header\");\n\t\t\t\t}\n\t\t\t}\n\t\tif ($doneheaders) {\n\t\t\tif ($cgiheader{\"location\"}) {\n\t\t\t\t&write_data(\n\t\t\t\t\t\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\telsif ($cgiheader{\"content-type\"} eq \"\") {\n\t\t\t\t&http_error(500, \"Missing Content-Type Header\");\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&write_data(\"HTTP/1.0 $ok_code $ok_message\\r\\n\");\n\t\t\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t\t\t&write_data(\"Server: $config{server}\\r\\n\");\n\t\t\t\t&write_keep_alive(0);\n\t\t\t\t}\n\t\t\tforeach $h (@cgiheader) {\n\t\t\t\t&write_data(\"$h->[0]: $h->[1]\\r\\n\");\n\t\t\t\t}\n\t\t\t&write_data(\"\\r\\n\");\n\t\t\t&reset_byte_count();\n\t\t\t&write_data($headers);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsub verify_client\n{\nlocal $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($_[1]);\nif ($cert) {\n\tlocal $errnum = Net::SSLeay::X509_STORE_CTX_get_error($_[1]);\n\t$verified_client = 1 if (!$errnum);\n\t}\nreturn 1;\n}\n\nsub END\n{\nif ($doing_cgi_eval && $$ == $main_process_id) {\n\t# A CGI program called exit! This is a horrible hack to \n\t# finish up before really exiting\n\tshutdown(SOCK, 1);\n\tclose(SOCK);\n\tclose($PASSINw); close($PASSOUTw);\n\t&log_request($loghost, $authuser, $reqline,\n\t\t     $cgiheader{\"location\"} ? \"302\" : $ok_code, &byte_count());\n\t}\n}\n\n# urlize\n# Convert a string to a form ok for putting in a URL\nsub urlize {\n  local($tmp, $tmp2, $c);\n  $tmp = $_[0];\n  $tmp2 = \"\";\n  while(($c = chop($tmp)) ne \"\") {\n\tif ($c !~ /[A-z0-9]/) {\n\t\t$c = sprintf(\"%%%2.2X\", ord($c));\n\t\t}\n\t$tmp2 = $c . $tmp2;\n\t}\n  return $tmp2;\n}\n\n# validate_user(username, password, host, remote-ip, webmin-port)\n# Checks if some username and password are valid. Returns the modified username,\n# the expired / temp pass flag, the non-existence flag, and the underlying\n# Webmin username.\nsub validate_user\n{\nlocal ($user, $pass, $host, $actpip, $port) = @_;\nreturn ( ) if (!$user);\nprint DEBUG \"validate_user: user=$user pass=$pass host=$host\\n\";\nlocal ($canuser, $canmode, $notexist, $webminuser, $sudo) =\n\t&can_user_login($user, undef, $host);\nprint DEBUG \"validate_user: canuser=$canuser canmode=$canmode notexist=$notexist webminuser=$webminuser sudo=$sudo\\n\";\nif ($notexist) {\n\t# User doesn't even exist, so go no further\n\treturn ( undef, 0, 1, $webminuser );\n\t}\nelsif ($canmode == 0) {\n\t# User does exist but cannot login\n\treturn ( $canuser, 0, 0, $webminuser );\n\t}\nelsif ($canmode == 1) {\n\t# Attempt Webmin authentication\n\tmy $uinfo = &get_user_details($webminuser);\n\tif ($uinfo &&\n\t    &password_crypt($pass, $uinfo->{'pass'}) eq $uinfo->{'pass'}) {\n\t\t# Password is valid .. but check for expiry\n\t\tlocal $lc = $uinfo->{'lastchanges'};\n\t\tprint DEBUG \"validate_user: Password is valid lc=$lc pass_maxdays=$config{'pass_maxdays'}\\n\";\n\t\tif ($config{'pass_maxdays'} && $lc && !$uinfo->{'nochange'}) {\n\t\t\tlocal $daysold = (time() - $lc)/(24*60*60);\n\t\t\tprint DEBUG \"maxdays=$config{'pass_maxdays'} daysold=$daysold temppass=$uinfo->{'temppass'}\\n\";\n\t\t\tif ($config{'pass_lockdays'} &&\n\t\t\t    $daysold > $config{'pass_lockdays'}) {\n\t\t\t\t# So old that the account is locked\n\t\t\t\treturn ( undef, 0, 0, $webminuser );\n\t\t\t\t}\n\t\t\telsif ($daysold > $config{'pass_maxdays'}) {\n\t\t\t\t# Password has expired\n\t\t\t\treturn ( $user, 1, 0, $webminuser );\n\t\t\t\t}\n\t\t\t}\n\t\tif ($uinfo->{'temppass'}) {\n\t\t\t# Temporary password - force change now\n\t\t\treturn ( $user, 2, 0, $webminuser );\n\t\t\t}\n\t\treturn ( $user, 0, 0, $webminuser );\n\t\t}\n\telsif (!$uinfo) {\n\t\tprint DEBUG \"validate_user: User $webminuser not found\\n\";\n\t\treturn ( undef, 0, 0, $webminuser );\n\t\t}\n\telse {\n\t\tprint DEBUG \"validate_user: User $webminuser password mismatch $pass != $uinfo->{'pass'}\\n\";\n\t\treturn ( undef, 0, 0, $webminuser );\n\t\t}\n\t}\nelsif ($canmode == 2 || $canmode == 3) {\n\t# Attempt PAM or passwd file authentication\n\tlocal $val = &validate_unix_user($canuser, $pass, $acptip, $port);\n\tprint DEBUG \"validate_user: unix val=$val\\n\";\n\tif ($val && $sudo) {\n\t\t# Need to check if this Unix user can sudo\n\t\tif (!&check_sudo_permissions($canuser, $pass)) {\n\t\t\tprint DEBUG \"validate_user: sudo failed\\n\";\n\t\t\t$val = 0;\n\t\t\t}\n\t\telse {\n\t\t\tprint DEBUG \"validate_user: sudo passed\\n\";\n\t\t\t}\n\t\t}\n\treturn $val == 2 ? ( $canuser, 1, 0, $webminuser ) :\n\t       $val == 1 ? ( $canuser, 0, 0, $webminuser ) :\n\t\t\t   ( undef, 0, 0, $webminuser );\n\t}\nelsif ($canmode == 4) {\n\t# Attempt external authentication\n\treturn &validate_external_user($canuser, $pass) ?\n\t\t( $canuser, 0, 0, $webminuser ) :\n\t\t( undef, 0, 0, $webminuser );\n\t}\nelse {\n\t# Can't happen!\n\treturn ( );\n\t}\n}\n\n# validate_unix_user(user, password, remote-ip, local-port)\n# Returns 1 if a username and password are valid under unix, 0 if not,\n# or 2 if the account has expired.\n# Checks PAM if available, and falls back to reading the system password\n# file otherwise.\nsub validate_unix_user\n{\nif ($use_pam) {\n\t# Check with PAM\n\t$pam_username = $_[0];\n\t$pam_password = $_[1];\n\teval \"use Authen::PAM;\";\n\tlocal $pamh = new Authen::PAM($config{'pam'}, $pam_username,\n\t\t\t\t      \\&pam_conv_func);\n\tif (ref($pamh)) {\n\t\t$pamh->pam_set_item(PAM_RHOST(), $_[2]) if ($_[2]);\n\t\t$pamh->pam_set_item(PAM_TTY(), $_[3]) if ($_[3]);\n\t\tlocal $rcode = 0;\n\t\tlocal $pam_ret = $pamh->pam_authenticate();\n\t\tif ($pam_ret == PAM_SUCCESS()) {\n\t\t\t# Logged in OK .. make sure password hasn't expired\n\t\t\tlocal $acct_ret = $pamh->pam_acct_mgmt();\n\t\t\t$pam_ret = $acct_ret;\n\t\t\tif ($acct_ret == PAM_SUCCESS()) {\n\t\t\t\t$pamh->pam_open_session();\n\t\t\t\t$rcode = 1;\n\t\t\t\t}\n\t\t\telsif ($acct_ret == PAM_NEW_AUTHTOK_REQD() ||\n\t\t\t       $acct_ret == PAM_ACCT_EXPIRED()) {\n\t\t\t\t$rcode = 2;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprint STDERR \"Unknown pam_acct_mgmt return value : $acct_ret\\n\";\n\t\t\t\t$rcode = 0;\n\t\t\t\t}\n\t\t\t}\n\t\tif ($config{'pam_end'}) {\n\t\t\t$pamh->pam_end($pam_ret);\n\t\t\t}\n\t\treturn $rcode;\n\t\t}\n\t}\nelsif ($config{'pam_only'}) {\n\t# Pam is not available, but configuration forces it's use!\n\treturn 0;\n\t}\nelsif ($config{'passwd_file'}) {\n\t# Check in a password file\n\tlocal $rv = 0;\n\topen(FILE, $config{'passwd_file'});\n\tif ($config{'passwd_file'} eq '/etc/security/passwd') {\n\t\t# Assume in AIX format\n\t\twhile(<FILE>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/ && $1 eq $_[0]) {\n\t\t\t\t$_ = <FILE>;\n\t\t\t\tif (/^\\s*password\\s*=\\s*(\\S+)\\s*$/) {\n\t\t\t\t\t$rv = $1 eq &password_crypt($_[1], $1) ?\n\t\t\t\t\t\t1 : 0;\n\t\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Read the system password or shadow file\n\t\twhile(<FILE>) {\n\t\t\tlocal @l = split(/:/, $_, -1);\n\t\t\tlocal $u = $l[$config{'passwd_uindex'}];\n\t\t\tlocal $p = $l[$config{'passwd_pindex'}];\n\t\t\tif ($u eq $_[0]) {\n\t\t\t\t$rv = $p eq &password_crypt($_[1], $p) ? 1 : 0;\n\t\t\t\tif ($config{'passwd_cindex'} ne '' && $rv) {\n\t\t\t\t\t# Password may have expired!\n\t\t\t\t\tlocal $c = $l[$config{'passwd_cindex'}];\n\t\t\t\t\tlocal $m = $l[$config{'passwd_mindex'}];\n\t\t\t\t\tlocal $day = time()/(24*60*60);\n\t\t\t\t\tif ($c =~ /^\\d+/ && $m =~ /^\\d+/ &&\n\t\t\t\t\t    $day - $c > $m) {\n\t\t\t\t\t\t# Yep, it has ..\n\t\t\t\t\t\t$rv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ($p eq \"\" && $config{'passwd_blank'}) {\n\t\t\t\t\t# Force password change\n\t\t\t\t\t$rv = 2;\n\t\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(FILE);\n\treturn $rv if ($rv);\n\t}\n\n# Fallback option - check password returned by getpw*\nlocal @uinfo = getpwnam($_[0]);\nif ($uinfo[1] ne '' && &password_crypt($_[1], $uinfo[1]) eq $uinfo[1]) {\n\treturn 1;\n\t}\n\nreturn 0;\t# Totally failed\n}\n\n# validate_external_user(user, pass)\n# Validate a user by passing the username and password to an external\n# squid-style authentication program\nsub validate_external_user\n{\nreturn 0 if (!$config{'extauth'});\nflock(EXTAUTH, 2);\nlocal $str = \"$_[0] $_[1]\\n\";\nsyswrite(EXTAUTH, $str, length($str));\nlocal $resp = <EXTAUTH>;\nflock(EXTAUTH, 8);\nreturn $resp =~ /^OK/i ? 1 : 0;\n}\n\n# can_user_login(username, no-append, host)\n# Checks if a user can login or not.\n# First return value is the username.\n# Second is 0 if cannot login, 1 if using Webmin pass, 2 if PAM, 3 if password\n# file, 4 if external.\n# Third is 1 if the user does not exist at all, 0 if he does.\n# Fourth is the Webmin username whose permissions apply, based on unixauth.\n# Fifth is a flag indicating if a sudo check is needed.\nsub can_user_login\n{\nlocal $uinfo = &get_user_details($_[0]);\nif (!$uinfo) {\n\t# See if this user exists in Unix and can be validated by the same\n\t# method as the unixauth webmin user\n\tlocal $realuser = $unixauth{$_[0]};\n\tlocal @uinfo;\n\tlocal $sudo = 0;\n\tlocal $pamany = 0;\n\teval { @uinfo = getpwnam($_[0]); };\t# may fail on windows\n\tif (!$realuser && @uinfo) {\n\t\t# No unixauth entry for the username .. try his groups \n\t\tforeach my $ua (keys %unixauth) {\n\t\t\tif ($ua =~ /^\\@(.*)$/) {\n\t\t\t\tif (&is_group_member(\\@uinfo, $1)) {\n\t\t\t\t\t$realuser = $unixauth{$ua};\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (!$realuser && @uinfo) {\n\t\t# Fall back to unix auth for all Unix users\n\t\t$realuser = $unixauth{\"*\"};\n\t\t}\n\tif (!$realuser && $use_sudo && @uinfo) {\n\t\t# Allow login effectively as root, if sudo permits it\n\t\t$sudo = 1;\n\t\t$realuser = \"root\";\n\t\t}\n\tif (!$realuser && !@uinfo && $config{'pamany'}) {\n\t\t# If the user completely doesn't exist, we can still allow\n\t\t# him to authenticate via PAM\n\t\t$realuser = $config{'pamany'};\n\t\t$pamany = 1;\n\t\t}\n\tif (!$realuser) {\n\t\t# For Usermin, always fall back to unix auth for any user,\n\t\t# so that later checks with domain added / removed are done.\n\t\t$realuser = $unixauth{\"*\"};\n\t\t}\n\treturn (undef, 0, 1, undef) if (!$realuser);\n\tlocal $uinfo = &get_user_details($realuser);\n\treturn (undef, 0, 1, undef) if (!$uinfo);\n\tlocal $up = $uinfo->{'pass'};\n\n\t# Work out possible domain names from the hostname\n\tlocal @doms = ( $_[2] );\n\tif ($_[2] =~ /^([^\\.]+)\\.(\\S+)$/) {\n\t\tpush(@doms, $2);\n\t\t}\n\n\tif ($config{'user_mapping'} && !%user_mapping) {\n\t\t# Read the user mapping file\n\t\t%user_mapping = ();\n\t\topen(MAPPING, $config{'user_mapping'});\n\t\twhile(<MAPPING>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\ts/#.*$//;\n\t\t\tif (/^(\\S+)\\s+(\\S+)/) {\n\t\t\t\tif ($config{'user_mapping_reverse'}) {\n\t\t\t\t\t$user_mapping{$1} = $2;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$user_mapping{$2} = $1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(MAPPING);\n\t\t}\n\n\t# Check the user mapping file to see if there is an entry for the\n\t# user login in which specifies a new effective user\n\tlocal $um;\n\tforeach my $d (@doms) {\n\t\t$um ||= $user_mapping{\"$_[0]\\@$d\"};\n\t\t}\n\t$um ||= $user_mapping{$_[0]};\n\tif (defined($um) && ($_[1]&4) == 0) {\n\t\t# A mapping exists - use it!\n\t\treturn &can_user_login($um, $_[1]+4, $_[2]);\n\t\t}\n\n\t# Check if a user with the entered login and the domains appended\n\t# or prepended exists, and if so take it to be the effective user\n\tif (!@uinfo && $config{'domainuser'}) {\n\t\t# Try again with name.domain and name.firstpart\n\t\tlocal @firsts = map { /^([^\\.]+)/; $1 } @doms;\n\t\tif (($_[1]&1) == 0) {\n\t\t\tlocal ($a, $p);\n\t\t\tforeach $a (@firsts, @doms) {\n\t\t\t\tforeach $p (\"$_[0].${a}\", \"$_[0]-${a}\",\n\t\t\t\t\t    \"${a}.$_[0]\", \"${a}-$_[0]\",\n\t\t\t\t\t    \"$_[0]_${a}\", \"${a}_$_[0]\") {\n\t\t\t\t\tlocal @vu = &can_user_login(\n\t\t\t\t\t\t\t$p, $_[1]+1, $_[2]);\n\t\t\t\t\treturn @vu if ($vu[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t# Check if the user entered a domain at the end of his username when\n\t# he really shouldn't have, and if so try without it\n\tif (!@uinfo && $config{'domainstrip'} &&\n\t    $_[0] =~ /^(\\S+)\\@(\\S+)$/ && ($_[1]&2) == 0) {\n\t\tlocal ($stripped, $dom) = ($1, $2);\n\t\tlocal @vu = &can_user_login($stripped, $_[1] + 2, $_[2]);\n\t\treturn @vu if ($vu[1]);\n\t\tlocal @vu = &can_user_login($stripped, $_[1] + 2, $dom);\n\t\treturn @vu if ($vu[1]);\n\t\t}\n\n\treturn ( undef, 0, 1, undef ) if (!@uinfo && !$pamany);\n\n\tif (@uinfo) {\n\t\tif (scalar(@allowusers)) {\n\t\t\t# Only allow people on the allow list\n\t\t\treturn ( undef, 0, 0, undef )\n\t\t\t\tif (!&users_match(\\@uinfo, @allowusers));\n\t\t\t}\n\t\telsif (scalar(@denyusers)) {\n\t\t\t# Disallow people on the deny list\n\t\t\treturn ( undef, 0, 0, undef )\n\t\t\t\tif (&users_match(\\@uinfo, @denyusers));\n\t\t\t}\n\t\tif ($config{'shells_deny'}) {\n\t\t\tlocal $found = 0;\n\t\t\topen(SHELLS, $config{'shells_deny'});\n\t\t\twhile(<SHELLS>) {\n\t\t\t\ts/\\r|\\n//g;\n\t\t\t\ts/#.*$//;\n\t\t\t\t$found++ if ($_ eq $uinfo[8]);\n\t\t\t\t}\n\t\t\tclose(SHELLS);\n\t\t\treturn ( undef, 0, 0, undef ) if (!$found);\n\t\t\t}\n\t\t}\n\n\tif ($up eq 'x') {\n\t\t# PAM or passwd file authentication\n\t\tprint DEBUG \"can_user_login: Validate with PAM\\n\";\n\t\treturn ( $_[0], $use_pam ? 2 : 3, 0, $realuser, $sudo );\n\t\t}\n\telsif ($up eq 'e') {\n\t\t# External authentication\n\t\tprint DEBUG \"can_user_login: Validate externally\\n\";\n\t\treturn ( $_[0], 4, 0, $realuser, $sudo );\n\t\t}\n\telse {\n\t\t# Fixed Webmin password\n\t\tprint DEBUG \"can_user_login: Validate by Webmin\\n\";\n\t\treturn ( $_[0], 1, 0, $realuser, $sudo );\n\t\t}\n\t}\nelsif ($uinfo->{'pass'} eq 'x') {\n\t# Webmin user authenticated via PAM or password file\n\treturn ( $_[0], $use_pam ? 2 : 3, 0, $_[0] );\n\t}\nelsif ($uinfo->{'pass'} eq 'e') {\n\t# Webmin user authenticated externally\n\treturn ( $_[0], 4, 0, $_[0] );\n\t}\nelse {\n\t# Normal Webmin user\n\treturn ( $_[0], 1, 0, $_[0] );\n\t}\n}\n\n# the PAM conversation function for interactive logins\nsub pam_conv_func\n{\n$pam_conv_func_called++;\nmy @res;\nwhile ( @_ ) {\n\tmy $code = shift;\n\tmy $msg = shift;\n\tmy $ans = \"\";\n\n\t$ans = $pam_username if ($code == PAM_PROMPT_ECHO_ON() );\n\t$ans = $pam_password if ($code == PAM_PROMPT_ECHO_OFF() );\n\n\tpush @res, PAM_SUCCESS();\n\tpush @res, $ans;\n\t}\npush @res, PAM_SUCCESS();\nreturn @res;\n}\n\nsub urandom_timeout\n{\nclose(RANDOM);\n}\n\n# get_socket_ip(handle, ipv6-flag)\n# Returns the local IP address of some connection, as both a string and in\n# binary format\nsub get_socket_ip\n{\nlocal ($fh, $ipv6) = @_;\nlocal $sn = getsockname($fh);\nreturn undef if (!$sn);\nreturn &get_address_ip($sn, $ipv6);\n}\n\n# get_address_ip(address, ipv6-flag)\n# Given a sockaddr object in binary format, return the binary address, text\n# address and port number\nsub get_address_ip\n{\nlocal ($sn, $ipv6) = @_;\nif ($ipv6) {\n\tlocal ($p, $b) = unpack_sockaddr_in6($sn);\n\treturn ($b, inet_ntop(AF_INET6(), $b), $p);\n\t}\nelse {\n\tlocal ($p, $b) = unpack_sockaddr_in($sn);\n\treturn ($b, inet_ntoa($b), $p);\n\t}\n}\n\n# get_socket_name(handle, ipv6-flag)\n# Returns the local hostname or IP address of some connection\nsub get_socket_name\n{\nlocal ($fh, $ipv6) = @_;\nreturn $config{'host'} if ($config{'host'});\nlocal ($mybin, $myaddr) = &get_socket_ip($fh, $ipv6);\nif (!$get_socket_name_cache{$myaddr}) {\n\tlocal $myname;\n\tif (!$config{'no_resolv_myname'}) {\n\t\t$myname = gethostbyaddr($mybin,\n\t\t\t\t\t$ipv6 ? AF_INET6() : AF_INET);\n\t\t}\n\t$myname ||= $myaddr;\n\t$get_socket_name_cache{$myaddr} = $myname;\n\t}\nreturn $get_socket_name_cache{$myaddr};\n}\n\n# run_login_script(username, sid, remoteip, localip)\nsub run_login_script\n{\nif ($config{'login_script'}) {\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'login_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# run_logout_script(username, sid, remoteip, localip)\nsub run_logout_script\n{\nif ($config{'logout_script'}) {\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'logout_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# run_failed_script(username, reason-code, remoteip, localip)\nsub run_failed_script\n{\nif ($config{'failed_script'}) {\n\t$_[0] =~ s/\\r|\\n/ /g;\n\talarm(5);\n\t$SIG{'ALRM'} = sub { die \"timeout\" };\n\teval {\n\t\tsystem($config{'failed_script'}.\n\t\t       \" \".join(\" \", map { quotemeta($_) || '\"\"' } @_).\n\t\t       \" >/dev/null 2>&1 </dev/null\");\n\t\t};\n\talarm(0);\n\t}\n}\n\n# close_all_sockets()\n# Closes all the main listening sockets\nsub close_all_sockets\n{\nlocal $s;\nforeach $s (@socketfhs) {\n\tclose($s);\n\t}\n}\n\n# close_all_pipes()\n# Close all pipes for talking to sub-processes\nsub close_all_pipes\n{\nlocal $p;\nforeach $p (@passin) { close($p); }\nforeach $p (@passout) { close($p); }\nforeach $p (values %conversations) {\n\tif ($p->{'PAMOUTr'}) {\n\t\tclose($p->{'PAMOUTr'});\n\t\tclose($p->{'PAMINw'});\n\t\t}\n\t}\n}\n\n# check_user_ip(user)\n# Returns 1 if some user is allowed to login from the accepting IP, 0 if not\nsub check_user_ip\n{\nlocal ($username) = @_;\nlocal $uinfo = &get_user_details($username);\nreturn 1 if (!$uinfo);\nif ($uinfo->{'deny'} &&\n    &ip_match($acptip, $localip, @{$uinfo->{'deny'}}) ||\n    $uinfo->{'allow'} &&\n    !&ip_match($acptip, $localip, @{$uinfo->{'allow'}})) {\n\treturn 0;\n\t}\nreturn 1;\n}\n\n# check_user_time(user)\n# Returns 1 if some user is allowed to login at the current date and time\nsub check_user_time\n{\nlocal ($username) = @_;\nlocal $uinfo = &get_user_details($username);\nreturn 1 if (!$uinfo || !$uinfo->{'allowdays'} && !$uinfo->{'allowhours'});\nlocal @tm = localtime(time());\nif ($uinfo->{'allowdays'}) {\n\t# Make sure day is allowed\n\treturn 0 if (&indexof($tm[6], @{$uinfo->{'allowdays'}}) < 0);\n\t}\nif ($uinfo->{'allowhours'}) {\n\t# Make sure time is allowed\n\tlocal $m = $tm[2]*60+$tm[1];\n\treturn 0 if ($m < $uinfo->{'allowhours'}->[0] ||\n\t\t     $m > $uinfo->{'allowhours'}->[1]);\n\t}\nreturn 1;\n}\n\n# generate_random_id(password, [force-urandom])\n# Returns a random session ID number\nsub generate_random_id\n{\nmy ($force_urandom) = @_;\nlocal $sid;\nif (!$bad_urandom) {\n\t# First try /dev/urandom, unless we have marked it as bad\n\t$SIG{ALRM} = \"miniserv::urandom_timeout\";\n\talarm(5);\n\tif (open(RANDOM, \"/dev/urandom\")) {\n\t\tmy $tmpsid;\n\t\tif (read(RANDOM, $tmpsid, 16) == 16) {\n\t\t\t$sid = lc(unpack('h*',$tmpsid));\n\t\t\tif ($sid !~ /^[0-9a-fA-F]{32}$/) {\n\t\t\t\t$sid = 'bad';\n\t\t\t\t}\n\t\t\t}\n\t\tclose(RANDOM);\n\t\t}\n\talarm(0);\n\t}\nif (!$sid && !$force_urandom) {\n\tmy $offset = int(rand(2048));\n\tmy @charset = ('0' ..'9', 'a' .. 'f');\n\t$sid = join('', map { $charset[rand(@charset)] } 1 .. 4096);\n\t$sid = substr($sid, $offset, 32);\n\t}\nreturn $sid;\n}\n\n# handle_login(username, ok, expired, not-exists, password, [no-test-cookie], [no-log])\n# Called from handle_session to either mark a user as logged in, or not\nsub handle_login\n{\nlocal ($vu, $ok, $expired, $nonexist, $pass, $notest, $nolog) = @_;\n$authuser = $vu if ($ok);\n\n# check if the test cookie is set\nif ($header{'cookie'} !~ /testing=1/ && $vu &&\n    !$config{'no_testing_cookie'} && !$notest) {\n\t&http_error(500, \"No cookies\",\n\t   \"Your browser does not support cookies, \".\n\t   \"which are required for this web server to \".\n\t   \"work in session authentication mode\");\n\t}\n\n# check with main process for delay\nif ($config{'passdelay'} && $vu) {\n\tprint DEBUG \"handle_login: requesting delay vu=$vu acptip=$acptip ok=$ok\\n\";\n\tprint $PASSINw \"delay $vu $acptip $ok $nolog\\n\";\n\t<$PASSOUTr> =~ /(\\d+) (\\d+)/;\n\t$blocked = $2;\n\tsleep($1);\n\tprint DEBUG \"handle_login: delay=$1 blocked=$2\\n\";\n\t}\n\nif ($ok && (!$expired ||\n\t    $config{'passwd_mode'} == 1)) {\n\t# Logged in OK! Tell the main process about\n\t# the new SID\n\tlocal $sid = &generate_random_id();\n\tprint DEBUG \"handle_login: sid=$sid\\n\";\n\tprint $PASSINw \"new $sid $authuser $acptip\\n\";\n\n\t# Run the post-login script, if any\n\t&run_login_script($authuser, $sid,\n\t\t\t  $loghost, $localip);\n\n\t# Check for a redirect URL for the user\n\tlocal $rurl = &login_redirect($authuser, $pass, $host);\n\tprint DEBUG \"handle_login: redirect URL rurl=$rurl\\n\";\n\tif ($rurl) {\n\t\t# Got one .. go to it\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\t&write_data(\"Location: $rurl\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\t}\n\telse {\n\t\t# Set cookie and redirect to originally requested page\n\t\t&write_data(\"HTTP/1.0 302 Moved Temporarily\\r\\n\");\n\t\t&write_data(\"Date: $datestr\\r\\n\");\n\t\t&write_data(\"Server: $config{'server'}\\r\\n\");\n\t\tlocal $sec = $ssl ? \"; secure\" : \"\";\n\t\tif (!$config{'no_httponly'}) {\n\t\t\t$sec .= \"; httpOnly\";\n\t\t\t}\n\t\tif ($in{'page'} !~ /^\\/[A-Za-z0-9\\/\\.\\-\\_:]+$/) {\n\t\t\t# Make redirect URL safe\n\t\t\t$in{'page'} = \"/\";\n\t\t\t}\n\t\tlocal $cpath = $config{'cookiepath'};\n\t\tif ($in{'save'}) {\n\t\t\t&write_data(\"Set-Cookie: $sidname=$sid; path=$cpath; \".\n\t\t\t    \"expires=\\\"Thu, 31-Dec-2037 00:00:00\\\"$sec\\r\\n\");\n\t\t\t}\n\t\telse {\n\t\t\t&write_data(\"Set-Cookie: $sidname=$sid; path=$cpath\".\n\t\t\t\t    \"$sec\\r\\n\");\n\t\t\t}\n\t\t&write_data(\"Location: $prot://$hostport$in{'page'}\\r\\n\");\n\t\t&write_keep_alive(0);\n\t\t&write_data(\"\\r\\n\");\n\t\t&log_request($loghost, $authuser, $reqline, 302, 0);\n\t\tsyslog(\"info\", \"%s\", \"Successful login as $authuser from $loghost\") if ($use_syslog);\n\t\t&write_login_utmp($authuser, $acpthost);\n\t\t}\n\treturn 0;\n\t}\nelsif ($ok && $expired &&\n       ($config{'passwd_mode'} == 2 || $expired == 2)) {\n\t# Login was ok, but password has expired or was temporary. Need\n\t# to force display of password change form.\n\t&run_failed_script($authuser, 'expiredpass',\n\t\t\t   $loghost, $localip);\n\t$validated = 1;\n\t$authuser = undef;\n\t$querystring = \"&user=\".&urlize($vu).\n\t\t       \"&pam=\".$use_pam.\n\t\t       \"&expired=\".$expired;\n\t$method = \"GET\";\n\t$queryargs = \"\";\n\t$page = $config{'password_form'};\n\t$logged_code = 401;\n\t$miniserv_internal = 2;\n\tsyslog(\"crit\", \"%s\",\n\t\t\"Expired login as $vu \".\n\t\t\"from $loghost\") if ($use_syslog);\n\t}\nelse {\n\t# Login failed, or password has expired. The login form will be\n\t# displayed again by later code\n\t&run_failed_script($vu, $handle_login ? 'wronguser' :\n\t\t\t\t$expired ? 'expiredpass' : 'wrongpass',\n\t\t\t   $loghost, $localip);\n\t$failed_user = $vu;\n\t$failed_pass = $pass;\n\t$failed_save = $in{'save'};\n\t$failed_twofactor_attempt = $in{'failed_twofactor_attempt'} || 0;\n\t$failed_twofactor_attempt++;\n\t$request_uri = $in{'page'};\n\t$already_session_id = undef;\n\t$method = \"GET\";\n\t$authuser = $baseauthuser = undef;\n\t\n\t# If login page is simply reloaded, with `session_login.cgi` in URL,\n\t# without having any parameters sent (user set to empty), don't log \n\t# false positive attempt with `Invalid login as  from IP` to syslog\n\t$nolog = 1 if (!$vu);\n\n\t# Send to log if allowed\n\tsyslog(\"crit\", \"%s\",\n\t\t($nonexist ? \"Non-existent\" :\n\t\t $expired ? \"Expired\" : \"Invalid\").\n\t\t\" login as $vu from $loghost\")\n\t\tif ($use_syslog && !$nolog);\n\t}\nreturn undef;\n}\n\n# write_login_utmp(user, host)\n# Record the login by some user in utmp\nsub write_login_utmp\n{\nif ($write_utmp) {\n\t# Write utmp record for login\n\t%utmp = ( 'ut_host' => $_[1],\n\t\t  'ut_time' => time(),\n\t\t  'ut_user' => $_[0],\n\t\t  'ut_type' => 7,\t# user process\n\t\t  'ut_pid' => $miniserv_main_pid,\n\t\t  'ut_line' => $config{'pam'},\n\t\t  'ut_id' => '' );\n\tif (defined(&User::Utmp::putut)) {\n\t\tUser::Utmp::putut(\\%utmp);\n\t\t}\n\telse {\n\t\tUser::Utmp::pututline(\\%utmp);\n\t\t}\n\t}\n}\n\n# write_logout_utmp(user, host)\n# Record the logout by some user in utmp\nsub write_logout_utmp\n{\nif ($write_utmp) {\n\t# Write utmp record for logout\n\t%utmp = ( 'ut_host' => $_[1],\n\t\t  'ut_time' => time(),\n\t\t  'ut_user' => $_[0],\n\t\t  'ut_type' => 8,\t# dead process\n\t\t  'ut_pid' => $miniserv_main_pid,\n\t\t  'ut_line' => $config{'pam'},\n\t\t  'ut_id' => '' );\n\tif (defined(&User::Utmp::putut)) {\n\t\tUser::Utmp::putut(\\%utmp);\n\t\t}\n\telse {\n\t\tUser::Utmp::pututline(\\%utmp);\n\t\t}\n\t}\n}\n\n# pam_conversation_process(username, write-pipe, read-pipe)\n# This function is called inside a sub-process to communicate with PAM. It sends\n# questions down one pipe, and reads responses from another\nsub pam_conversation_process\n{\nlocal ($user, $writer, $reader) = @_;\n$miniserv::pam_conversation_process_writer = $writer;\n$miniserv::pam_conversation_process_reader = $reader;\neval \"use Authen::PAM;\";\nlocal $convh = new Authen::PAM(\n\t$config{'pam'}, $user, \\&miniserv::pam_conversation_process_func);\nlocal $pam_ret = $convh->pam_authenticate();\nif ($pam_ret == PAM_SUCCESS()) {\n\tlocal $acct_ret = $convh->pam_acct_mgmt();\n\tif ($acct_ret == PAM_SUCCESS()) {\n\t\t$convh->pam_open_session();\n\t\tprint $writer \"x2 $user 1 0 0\\n\";\n\t\t}\n\telsif ($acct_ret == PAM_NEW_AUTHTOK_REQD() ||\n\t       $acct_ret == PAM_ACCT_EXPIRED()) {\n\t\tprint $writer \"x2 $user 1 1 0\\n\";\n\t\t}\n\telse {\n\t\tprint $writer \"x0 Unknown PAM account status $acct_ret\\n\";\n\t\t}\n\t}\nelse {\n\tprint $writer \"x2 $user 0 0 0\\n\";\n\t}\nexit(0);\n}\n\n# pam_conversation_process_func(type, message, [type, message, ...])\n# A pipe that talks to both PAM and the master process\nsub pam_conversation_process_func\n{\nlocal @rv;\nselect($miniserv::pam_conversation_process_writer); $| = 1; select(STDOUT);\nwhile(@_) {\n\tlocal ($type, $msg) = (shift, shift);\n\t$msg =~ s/\\r|\\n//g;\n\tlocal $ok = (print $miniserv::pam_conversation_process_writer \"$type $msg\\n\");\n\tprint $miniserv::pam_conversation_process_writer \"\\n\";\n\tlocal $answer = <$miniserv::pam_conversation_process_reader>;\n\t$answer =~ s/\\r|\\n//g;\n\tpush(@rv, PAM_SUCCESS(), $answer);\n\t}\npush(@rv, PAM_SUCCESS());\nreturn @rv;\n}\n\n# allocate_pipes()\n# Returns 4 new pipe file handles\nsub allocate_pipes\n{\nlocal ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\nlocal $p;\nlocal %taken = ( (map { $_, 1 } @passin),\n\t         (map { $_->{'PASSINr'} } values %conversations) );\nfor($p=0; $taken{\"PASSINr$p\"}; $p++) { }\n$PASSINr = \"PASSINr$p\";\n$PASSINw = \"PASSINw$p\";\n$PASSOUTr = \"PASSOUTr$p\";\n$PASSOUTw = \"PASSOUTw$p\";\npipe($PASSINr, $PASSINw);\npipe($PASSOUTr, $PASSOUTw);\nselect($PASSINw); $| = 1;\nselect($PASSINr); $| = 1;\nselect($PASSOUTw); $| = 1;\nselect($PASSOUTw); $| = 1;\nselect(STDOUT);\nreturn ($PASSINr, $PASSINw, $PASSOUTr, $PASSOUTw);\n}\n\n# recv_pam_question(&conv, fd)\n# Reads one PAM question from the sub-process, and sends it to the HTTP handler.\n# Returns 0 if the conversation is over, 1 if not.\nsub recv_pam_question\n{\nlocal ($conf, $fh) = @_;\nlocal $pr = $conf->{'PAMOUTr'};\nselect($pr); $| = 1; select(STDOUT);\nlocal $line = <$pr>;\n$line =~ s/\\r|\\n//g;\nif (!$line) {\n\t$line = <$pr>;\n\t$line =~ s/\\r|\\n//g;\n\t}\n$conf->{'last'} = time();\nif (!$line) {\n\t# Failed!\n\tprint $fh \"0 PAM conversation error\\n\";\n\treturn 0;\n\t}\nelse {\n\tlocal ($type, $msg) = split(/\\s+/, $line, 2);\n\tif ($type =~ /^x(\\d+)/) {\n\t\t# Pass this status code through\n\t\tprint $fh \"$1 $msg\\n\";\n\t\treturn $1 == 2 || $1 == 0 ? 0 : 1;\n\t\t}\n\telsif ($type == PAM_PROMPT_ECHO_ON()) {\n\t\t# A normal question\n\t\tprint $fh \"1 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telsif ($type == PAM_PROMPT_ECHO_OFF()) {\n\t\t# A password\n\t\tprint $fh \"3 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telsif ($type == PAM_ERROR_MSG() || $type == PAM_TEXT_INFO()) {\n\t\t# A message that does not require a response\n\t\tprint $fh \"4 $msg\\n\";\n\t\treturn 1;\n\t\t}\n\telse {\n\t\t# Unknown type!\n\t\tprint $fh \"0 Unknown PAM message type $type\\n\";\n\t\treturn 0;\n\t\t}\n\t}\n}\n\n# send_pam_answer(&conv, answer)\n# Sends a response from the user to the PAM sub-process\nsub send_pam_answer\n{\nlocal ($conf, $answer) = @_;\nlocal $pw = $conf->{'PAMINw'};\n$conf->{'last'} = time();\nprint $pw \"$answer\\n\";\n}\n\n# end_pam_conversation(&conv)\n# Clean up PAM conversation pipes and processes\nsub end_pam_conversation\n{\nlocal ($conv) = @_;\nkill('KILL', $conv->{'pid'}) if ($conv->{'pid'});\nif ($conv->{'PAMINr'}) {\n\tclose($conv->{'PAMINr'});\n\tclose($conv->{'PAMOUTr'});\n\tclose($conv->{'PAMINw'});\n\tclose($conv->{'PAMOUTw'});\n\t}\ndelete($conversations{$conv->{'cid'}});\n}\n\n# get_ipkeys(&miniserv)\n# Returns a list of IP address to key file mappings from a miniserv.conf entry\nsub get_ipkeys\n{\nlocal (@rv, $k);\nforeach $k (keys %{$_[0]}) {\n\tif ($k =~ /^ipkey_(\\S+)/) {\n\t\tlocal $ipkey = { 'ips' => [ split(/,/, $1) ],\n\t\t\t\t 'key' => $_[0]->{$k},\n\t\t\t\t 'index' => scalar(@rv) };\n\t\t$ipkey->{'cert'} = $_[0]->{'ipcert_'.$1};\n\t\t$ipkey->{'extracas'} = $_[0]->{'ipextracas_'.$1};\n\t\tpush(@rv, $ipkey);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# create_ssl_context(keyfile, [certfile], [extracas])\nsub create_ssl_context\n{\nlocal ($keyfile, $certfile, $extracas) = @_;\nlocal $ssl_ctx;\neval { $ssl_ctx = Net::SSLeay::new_x_ctx() };\n$ssl_ctx ||= Net::SSLeay::CTX_new();\n$ssl_ctx || die \"Failed to create SSL context : $!\";\nmy @extracas = $extracas && $extracas ne \"none\" ? split(/\\s+/, $extracas) : ();\n\n# Validate cert files\nif (!-r $keyfile) {\n\tprint STDERR \"SSL key file $keyfile does not exist\\n\";\n\treturn undef;\n\t}\nif ($certfile && !-r $certfile) {\n\tprint STDERR \"SSL cert file $certfile does not exist\\n\";\n\treturn undef;\n\t}\nforeach my $p (@extracas) {\n\tif (!-r $p) {\n\t\tprint STDERR \"SSL CA file $p does not exist\\n\";\n\t\treturn undef;\n\t\t}\n\t}\n\n# Setup PFS, if ciphers are in use\nif (-r $config{'dhparams_file'}) {\n\teval {\n\t\tmy $bio = Net::SSLeay::BIO_new_file(\n\t\t\t\t$config{'dhparams_file'}, 'r');\n\t\tmy $DHP = Net::SSLeay::PEM_read_bio_DHparams($bio);\n\t\tNet::SSLeay::CTX_set_tmp_dh($ssl_ctx, $DHP);\n\t\tmy $nid = Net::SSLeay::OBJ_sn2nid(\"secp384r1\");\n\t\tmy $curve = Net::SSLeay::EC_KEY_new_by_curve_name($nid);\n\t\tNet::SSLeay::CTX_set_tmp_ecdh($ssl_ctx, $curve);\n\t\tNet::SSLeay::BIO_free($bio);\n\t\t};\n\t}\nif ($@) {\n\tprint STDERR \"Failed to load $config{'dhparams_file'} : $@\\n\";\n\t}\n\nif ($client_certs) {\n\tNet::SSLeay::CTX_load_verify_locations(\n\t\t$ssl_ctx, $config{'ca'}, \"\");\n\teval {\n\t\tNet::SSLeay::set_verify(\n\t\t\t$ssl_ctx, &Net::SSLeay::VERIFY_PEER, \\&verify_client);\n\t\t};\n\tif ($@) {\n\t\tNet::SSLeay::CTX_set_verify(\n\t\t\t$ssl_ctx, &Net::SSLeay::VERIFY_PEER, \\&verify_client);\n\t\t}\n\t}\nforeach my $p (@extracas) {\n\tNet::SSLeay::CTX_load_verify_locations($ssl_ctx, $p, \"\");\n\t}\n\nif (!Net::SSLeay::CTX_use_PrivateKey_file($ssl_ctx, $keyfile,\n\t\t\t\t\t  &Net::SSLeay::FILETYPE_PEM)) {\n\tprint STDERR \"Failed to open SSL key $keyfile\\n\";\n\treturn undef;\n\t}\nif (!Net::SSLeay::CTX_use_certificate_file($ssl_ctx, $certfile || $keyfile,\n\t\t\t\t\t   &Net::SSLeay::FILETYPE_PEM)) {\n\tprint STDERR \"Failed to open SSL cert \".($certfile || $keyfile).\"\\n\";\n\treturn undef;\n\t}\n\nif ($config{'no_ssl2'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_SSLv2)';\n\t}\nif ($config{'no_ssl3'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_SSLv3)';\n\t}\nif ($config{'no_tls1'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1)';\n\t}\nif ($config{'no_tls1_1'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1_1)';\n\t}\nif ($config{'no_tls1_2'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_TLSv1_2)';\n\t}\nif ($config{'no_sslcompression'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_NO_COMPRESSION)';\n\t}\nif ($config{'ssl_honorcipherorder'}) {\n\teval 'Net::SSLeay::CTX_set_options($ssl_ctx,\n\t\t&Net::SSLeay::OP_CIPHER_SERVER_PREFERENCE)';\n\t}\n\nreturn $ssl_ctx;\n}\n\n# ssl_connection_for_ip(socket, ipv6-flag)\n# Returns a new SSL connection object for some socket, or undef if failed\nsub ssl_connection_for_ip\n{\nlocal ($sock, $ipv6) = @_;\nlocal $sn = getsockname($sock);\nif (!$sn) {\n\tprint STDERR \"Failed to get address for socket $sock\\n\";\n\treturn undef;\n\t}\nlocal (undef, $myip, undef) = &get_address_ip($sn, $ipv6);\nlocal $ssl_ctx = $ssl_contexts{$myip} || $ssl_contexts{\"*\"};\nlocal $ssl_con = Net::SSLeay::new($ssl_ctx);\nif ($config{'ssl_cipher_list'}) {\n\t# Force use of ciphers\n\teval \"Net::SSLeay::set_cipher_list(\n\t\t\t\\$ssl_con, \\$config{'ssl_cipher_list'})\";\n\tif ($@) {\n\t\tprint STDERR \"SSL cipher $config{'ssl_cipher_list'} failed : \",\n\t\t\t     \"$@\\n\";\n\t\t}\n\t}\nNet::SSLeay::set_fd($ssl_con, fileno($sock));\nif (!Net::SSLeay::accept($ssl_con)) {\n\treturn undef;\n\t}\nreturn $ssl_con;\n}\n\n# login_redirect(username, password, host)\n# Calls the login redirect script (if configured), which may output a URL to\n# re-direct a user to after logging in.\nsub login_redirect\n{\nreturn undef if (!$config{'login_redirect'});\nlocal $quser = quotemeta($_[0]);\nlocal $qpass = quotemeta($_[1]);\nlocal $qhost = quotemeta($_[2]);\nlocal $url = `$config{'login_redirect'} $quser $qpass $qhost`;\nchop($url);\nreturn $url;\n}\n\n# reload_config_file()\n# Re-read %config, and call post-config actions\nsub reload_config_file\n{\n&log_error(\"Reloading configuration\");\n%config = &read_config_file($config_file);\n&update_vital_config();\n&read_users_file();\n&read_mime_types();\n&build_config_mappings();\n&read_webmin_crons();\n&precache_files();\nif ($config{'session'}) {\n\tdbmclose(%sessiondb);\n\tdbmopen(%sessiondb, $config{'sessiondb'}, 0700);\n\t}\n}\n\n# read_config_file(file)\n# Reads the given config file, and returns a hash of values\nsub read_config_file\n{\nlocal %rv;\nopen(CONF, $_[0]) || die \"Failed to open config file $_[0] : $!\";\nwhile(<CONF>) {\n\ts/\\r|\\n//g;\n\tif (/^#/ || !/\\S/) { next; }\n\t/^([^=]+)=(.*)$/;\n\t$name = $1; $val = $2;\n\t$name =~ s/^\\s+//g; $name =~ s/\\s+$//g;\n\t$val =~ s/^\\s+//g; $val =~ s/\\s+$//g;\n\t$rv{$name} = $val;\n\t}\nclose(CONF);\nreturn %rv;\n}\n\n# update_vital_config()\n# Updates %config with defaults, and dies if something vital is missing\nsub update_vital_config\n{\nmy %vital = (\"port\", 80,\n\t  \"root\", \"./\",\n\t  \"server\", \"MiniServ/0.01\",\n\t  \"index_docs\", \"index.html index.htm index.cgi index.php\",\n\t  \"addtype_html\", \"text/html\",\n\t  \"addtype_txt\", \"text/plain\",\n\t  \"addtype_gif\", \"image/gif\",\n\t  \"addtype_jpg\", \"image/jpeg\",\n\t  \"addtype_jpeg\", \"image/jpeg\",\n\t  \"realm\", \"MiniServ\",\n\t  \"session_login\", \"/session_login.cgi\",\n\t  \"pam_login\", \"/pam_login.cgi\",\n\t  \"password_form\", \"/password_form.cgi\",\n\t  \"password_change\", \"/password_change.cgi\",\n\t  \"maxconns\", 50,\n\t  \"pam\", \"webmin\",\n\t  \"sidname\", \"sid\",\n\t  \"unauth\", \"^/unauthenticated/ ^/robots.txt\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.jar\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.class\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.gif\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.png\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.conf\\$ ^[A-Za-z0-9\\\\-/_]+\\\\.ico\\$ ^/robots.txt\\$\",\n\t  \"max_post\", 10000,\n\t  \"expires\", 7*24*60*60,\n\t  \"pam_test_user\", \"root\",\n\t  \"precache\", \"lang/en */lang/en\",\n\t  \"cookiepath\", \"/\",\n\t );\nforeach my $v (keys %vital) {\n\tif (!$config{$v}) {\n\t\tif ($vital{$v} eq \"\") {\n\t\t\tdie \"Missing config option $v\";\n\t\t\t}\n\t\t$config{$v} = $vital{$v};\n\t\t}\n\t}\n$config_file =~ /^(.*)\\/[^\\/]+$/;\nmy $config_dir = $1;\n$config{'pidfile'} =~ /^(.*)\\/[^\\/]+$/;\nmy $var_dir = $1;\nif (!$config{'sessiondb'}) {\n\t$config{'sessiondb'} = \"$var_dir/sessiondb\";\n\t}\nif (!$config{'errorlog'}) {\n\t$config{'logfile'} =~ /^(.*)\\/[^\\/]+$/;\n\t$config{'errorlog'} = \"$1/miniserv.error\";\n\t}\nif (!$config{'tempbase'}) {\n\t$config{'tempbase'} = \"$var_dir/cgitemp\";\n\t}\nif (!$config{'blockedfile'}) {\n\t$config{'blockedfile'} = \"$var_dir/blocked\";\n\t}\nif (!$config{'webmincron_dir'}) {\n\t$config{'webmincron_dir'} = \"$config_dir/webmincron/crons\";\n\t}\nif (!$config{'webmincron_last'}) {\n\t$config{'logfile'} =~ /^(.*)\\/[^\\/]+$/;\n\t$config{'webmincron_last'} = \"$1/miniserv.lastcrons\";\n\t}\nif (!$config{'webmincron_wrapper'}) {\n\t$config{'webmincron_wrapper'} = $config{'root'}.\n\t\t\t\t\t\"/webmincron/webmincron.pl\";\n\t}\nif (!$config{'twofactor_wrapper'}) {\n\t$config{'twofactor_wrapper'} = $config{'root'}.\"/acl/twofactor.pl\";\n\t}\n$config{'restartflag'} ||= $var_dir.\"/restart-flag\";\n$config{'reloadflag'} ||= $var_dir.\"/reload-flag\";\n$config{'stopflag'} ||= $var_dir.\"/stop-flag\";\n}\n\n# read_users_file()\n# Fills the %users and %certs hashes from the users file in %config\nsub read_users_file\n{\nundef(%users);\nundef(%certs);\nundef(%allow);\nundef(%deny);\nundef(%allowdays);\nundef(%allowhours);\nundef(%lastchanges);\nundef(%nochange);\nundef(%temppass);\nundef(%twofactor);\nif ($config{'userfile'}) {\n\topen(USERS, $config{'userfile'});\n\twhile(<USERS>) {\n\t\ts/\\r|\\n//g;\n\t\tlocal @user = split(/:/, $_, -1);\n\t\t$users{$user[0]} = $user[1];\n\t\t$certs{$user[0]} = $user[3] if ($user[3]);\n\t\tif ($user[4] =~ /^allow\\s+(.*)/) {\n\t\t\tmy $allow = $1;\n\t\t\t$allow =~ s/;/:/g;\n\t\t\t$allow{$user[0]} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $allow) ] :\n\t\t\t\t[ &to_ip46address(split(/\\s+/, $allow)) ];\n\t\t\t}\n\t\telsif ($user[4] =~ /^deny\\s+(.*)/) {\n\t\t\tmy $deny = $1;\n\t\t\t$deny =~ s/;/:/g;\n\t\t\t$deny{$user[0]} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $deny) ] :\n\t\t\t\t[ &to_ip46address(split(/\\s+/, $deny)) ];\n\t\t\t}\n\t\tif ($user[5] =~ /days\\s+(\\S+)/) {\n\t\t\t$allowdays{$user[0]} = [ split(/,/, $1) ];\n\t\t\t}\n\t\tif ($user[5] =~ /hours\\s+(\\d+)\\.(\\d+)-(\\d+).(\\d+)/) {\n\t\t\t$allowhours{$user[0]} = [ $1*60+$2, $3*60+$4 ];\n\t\t\t}\n\t\t$lastchanges{$user[0]} = $user[6];\n\t\t$nochange{$user[0]} = $user[9];\n\t\t$temppass{$user[0]} = $user[10];\n\t\tif ($user[11] && $user[12]) {\n\t\t\t$twofactor{$user[0]} = { 'provider' => $user[11],\n\t\t\t\t\t\t 'id' => $user[12],\n\t\t\t\t\t\t 'apikey' => $user[13] };\n\t\t\t}\n\t\t}\n\tclose(USERS);\n\t}\n\n# Test user DB, if configured\nif ($config{'userdb'}) {\n\tmy $dbh = &connect_userdb($config{'userdb'});\n\tif (!ref($dbh)) {\n\t\tprint STDERR \"Failed to open users database : $dbh\\n\"\n\t\t}\n\telse {\n\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t\t}\n\t}\n}\n\n# get_user_details(username)\n# Returns a hash ref of user details, either from config files or the user DB\nsub get_user_details\n{\nmy ($username) = @_;\nif (exists($users{$username})) {\n\t# In local files\n\treturn { 'name' => $username,\n\t\t 'pass' => $users{$username},\n\t\t 'certs' => $certs{$username},\n\t\t 'allow' => $allow{$username},\n\t\t 'deny' => $deny{$username},\n\t\t 'allowdays' => $allowdays{$username},\n\t\t 'allowhours' => $allowhours{$username},\n\t\t 'lastchanges' => $lastchanges{$username},\n\t\t 'nochange' => $nochange{$username},\n\t\t 'temppass' => $temppass{$username},\n\t\t 'preroot' => $config{'preroot_'.$username},\n\t\t 'twofactor_provider' => $twofactor{$username}->{'provider'},\n\t\t 'twofactor_id' => $twofactor{$username}->{'id'},\n\t\t 'twofactor_apikey' => $twofactor{$username}->{'apikey'},\n\t       };\n\t}\nif ($config{'userdb'}) {\n\t# Try querying user database\n\tif (exists($get_user_details_cache{$username})) {\n\t\t# Cached already\n\t\treturn $get_user_details_cache{$username};\n\t\t}\n\tprint DEBUG \"get_user_details: Connecting to user database\\n\";\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($config{'userdb'});\n\tmy $user;\n\tmy %attrs;\n\tif (!ref($dbh)) {\n\t\tprint DEBUG \"get_user_details: Failed : $dbh\\n\";\n\t\tprint STDERR \"Failed to connect to user database : $dbh\\n\";\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Fetch user ID and password with SQL\n\t\tprint DEBUG \"get_user_details: Looking for $username in SQL\\n\";\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id,pass from webmin_user where name = ?\");\n\t\tif (!$cmd || !$cmd->execute($username)) {\n\t\t\tprint STDERR \"Failed to lookup user : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tmy ($id, $pass) = $cmd->fetchrow();\n\t\t$cmd->finish();\n\t\tif (!$id) {\n\t\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t\t\t$get_user_details_cache{$username} = undef;\n\t\t\tprint DEBUG \"get_user_details: User not found\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tprint DEBUG \"get_user_details: id=$id pass=$pass\\n\";\n\n\t\t# Fetch attributes and add to user object\n\t\tprint DEBUG \"get_user_details: finding user attributes\\n\";\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select attr,value from webmin_user_attr where id = ?\");\n\t\tif (!$cmd || !$cmd->execute($id)) {\n\t\t\tprint STDERR \"Failed to lookup user attrs : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\t$user = { 'name' => $username,\n\t\t\t  'id' => $id,\n\t\t\t  'pass' => $pass,\n\t\t\t  'proto' => $proto };\n\t\twhile(my ($attr, $value) = $cmd->fetchrow()) {\n\t\t\t$attrs{$attr} = $value;\n\t\t\t}\n\t\t$cmd->finish();\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Fetch user DN with LDAP\n\t\tprint DEBUG \"get_user_details: Looking for $username in LDAP\\n\";\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$username.')(objectClass='.\n                                  $args->{'userclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\tprint STDERR \"Failed to lookup user : \",\n\t\t\t\t     ($rv ? $rv->error : \"Unknown error\"),\"\\n\";\n\t\t\treturn undef;\n\t\t\t}\n\t\tmy ($u) = $rv->all_entries();\n\t\tif (!$u || $u->get_value('cn') ne $username) {\n\t\t\t&disconnect_userdb($config{'userdb'}, $dbh);\n                        $get_user_details_cache{$username} = undef;\n\t\t\tprint DEBUG \"get_user_details: User not found\\n\";\n                        return undef;\n\t\t\t}\n\n\t\t# Extract attributes\n\t\tmy $pass = $u->get_value('webminPass');\n\t\t$user = { 'name' => $username,\n\t\t\t  'id' => $u->dn(),\n\t\t\t  'pass' => $pass,\n\t\t\t  'proto' => $proto };\n\t\tforeach my $la ($u->get_value('webminAttr')) {\n\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t$attrs{$attr} = $value;\n\t\t\t}\n\t\t}\n\n\t# Convert DB attributes into user object fields\n\tif ($user) {\n\t\tprint DEBUG \"get_user_details: got \",scalar(keys %attrs),\n\t\t\t    \" attributes\\n\";\n\t\t$user->{'certs'} = $attrs{'cert'};\n\t\tif ($attrs{'allow'}) {\n\t\t\t$user->{'allow'} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $attrs{'allow'}) ] :\n\t\t\t\t[ &to_ipaddress(split(/\\s+/,$attrs{'allow'})) ];\n\t\t\t}\n\t\tif ($attrs{'deny'}) {\n\t\t\t$user->{'deny'} = $config{'alwaysresolve'} ?\n\t\t\t\t[ split(/\\s+/, $attrs{'deny'}) ] :\n\t\t\t\t[ &to_ipaddress(split(/\\s+/,$attrs{'deny'})) ];\n\t\t\t}\n\t\tif ($attrs{'days'}) {\n\t\t\t$user->{'allowdays'} = [ split(/,/, $attrs{'days'}) ];\n\t\t\t}\n\t\tif ($attrs{'hoursfrom'} && $attrs{'hoursto'}) {\n\t\t\tmy ($hf, $mf) = split(/\\./, $attrs{'hoursfrom'});\n\t\t\tmy ($ht, $mt) = split(/\\./, $attrs{'hoursto'});\n\t\t\t$user->{'allowhours'} = [ $hf*60+$ht, $ht*60+$mt ];\n\t\t\t}\n\t\t$user->{'lastchanges'} = $attrs{'lastchange'};\n\t\t$user->{'nochange'} = $attrs{'nochange'};\n\t\t$user->{'temppass'} = $attrs{'temppass'};\n\t\t$user->{'preroot'} = $attrs{'theme'};\n\t\t$user->{'twofactor_provider'} = $attrs{'twofactor_provider'};\n\t\t$user->{'twofactor_id'} = $attrs{'twofactor_id'};\n\t\t$user->{'twofactor_apikey'} = $attrs{'twofactor_apikey'};\n\t\t}\n\t&disconnect_userdb($config{'userdb'}, $dbh);\n\t$get_user_details_cache{$user->{'name'}} = $user;\n\treturn $user;\n\t}\nreturn undef;\n}\n\n# find_user_by_cert(cert)\n# Returns a username looked up by certificate\nsub find_user_by_cert\n{\nmy ($peername) = @_;\nmy $peername2 = $peername;\n$peername2 =~ s/Email=/emailAddress=/ || $peername2 =~ s/emailAddress=/Email=/;\n\n# First check users in local files\nforeach my $username (keys %certs) {\n\tif ($certs{$username} eq $peername ||\n\t    $certs{$username} eq $peername2) {\n\t\treturn $username;\n\t\t}\n\t}\n\n# Check user DB\nif ($config{'userdb'}) {\n\tmy ($dbh, $proto) = &connect_userdb($config{'userdb'});\n\tif (!ref($dbh)) {\n\t\treturn undef;\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Query with SQL\n\t\tmy $cmd = $dbh->prepare(\"select webmin_user.name from webmin_user,webmin_user_attr where webmin_user.id = webmin_user_attr.id and webmin_user_attr.attr = 'cert' and webmin_user_attr.value = ?\");\n\t\treturn undef if (!$cmd);\n\t\tforeach my $p ($peername, $peername2) {\n\t\t\tmy $username;\n\t\t\tif ($cmd->execute($p)) {\n\t\t\t\t($username) = $cmd->fetchrow();\n\t\t\t\t}\n\t\t\t$cmd->finish();\n\t\t\treturn $username if ($username);\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Lookup in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(objectClass='.\n\t\t\t\t  $args->{'userclass'}.')',\n\t\t\tscope => 'sub',\n\t\t\tattrs => [ 'cn', 'webminAttr' ]);\n\t\tif ($rv && !$rv->code) {\n\t\t\tforeach my $u ($rv->all_entries) {\n\t\t\t\tmy @attrs = $u->get_value('webminAttr');\n\t\t\t\tforeach my $la (@attrs) {\n\t\t\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t\t\tif ($attr eq \"cert\" &&\n\t\t\t\t\t    ($value eq $peername ||\n\t\t\t\t\t     $value eq $peername2)) {\n\t\t\t\t\t\treturn $u->get_value('cn');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn undef;\n}\n\n# connect_userdb(string)\n# Returns a handle for talking to a user database - may be a DBI or LDAP handle.\n# On failure returns an error message string. In an array context, returns the\n# protocol type too.\nsub connect_userdb\n{\nmy ($str) = @_;\nmy ($proto, $user, $pass, $host, $prefix, $args) = &split_userdb_string($str);\nif ($proto eq \"mysql\") {\n\t# Connect to MySQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('mysql');\";\n\t$drh || return $text{'sql_emysqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"database=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tprint DEBUG \"connect_userdb: Connecting to MySQL $cstr as $user\\n\";\n\tmy $dbh = $drh->connect($cstr, $user, $pass, { });\n\t$dbh || return \"Failed to connect to MySQL : \".$drh->errstr;\n\tprint DEBUG \"connect_userdb: Connected OK\\n\";\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"postgresql\") {\n\t# Connect to PostgreSQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('Pg');\";\n\t$drh || return $text{'sql_epostgresqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"dbname=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tprint DEBUG \"connect_userdb: Connecting to PostgreSQL $cstr as $user\\n\";\n\tmy $dbh = $drh->connect($cstr, $user, $pass);\n\t$dbh || return \"Failed to connect to PostgreSQL : \".$drh->errstr;\n\tprint DEBUG \"connect_userdb: Connected OK\\n\";\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"ldap\") {\n\t# Connect with perl LDAP module\n\teval \"use Net::LDAP\";\n\t$@ && return $text{'sql_eldapdriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $scheme = $args->{'scheme'} || 'ldap';\n\tif (!$port) {\n\t\t$port = $scheme eq 'ldaps' ? 636 : 389;\n\t\t}\n\tmy $ldap = Net::LDAP->new($host,\n\t\t\t\t  port => $port,\n\t\t\t\t  'scheme' => $scheme);\n\t$ldap || return \"Failed to connect to LDAP : \".$host;\n\tmy $mesg;\n\tif ($args->{'tls'}) {\n\t\t# Switch to TLS mode\n\t\teval { $mesg = $ldap->start_tls(); };\n\t\tif ($@ || !$mesg || $mesg->code) {\n\t\t\treturn \"Failed to switch to LDAP TLS mode : \".\n\t\t\t    ($@ ? $@ : $mesg ? $mesg->error : \"Unknown error\");\n\t\t\t}\n\t\t}\n\t# Login to the server\n\tif ($pass) {\n\t\t$mesg = $ldap->bind(dn => $user, password => $pass);\n\t\t}\n\telse {\n\t\t$mesg = $ldap->bind(dn => $user, anonymous => 1);\n\t\t}\n\tif (!$mesg || $mesg->code) {\n\t\treturn \"Failed to login to LDAP as \".$user.\" : \".\n\t\t       ($mesg ? $mesg->error : \"Unknown error\");\n\t\t}\n\treturn wantarray ? ($ldap, $proto, $prefix, $args) : $ldap;\n\t}\nelse {\n\treturn \"Unknown protocol $proto\";\n\t}\n}\n\n# split_userdb_string(string)\n# Converts a string like mysql://user:pass@host/db into separate parts\nsub split_userdb_string\n{\nmy ($str) = @_;\nif ($str =~ /^([a-z]+):\\/\\/([^:]*):([^\\@]*)\\@([a-z0-9\\.\\-\\_]+)\\/([^\\?]+)(\\?(.*))?$/) {\n\tmy ($proto, $user, $pass, $host, $prefix, $argstr) =\n\t\t($1, $2, $3, $4, $5, $7);\n\tmy %args = map { split(/=/, $_, 2) } split(/\\&/, $argstr);\n\treturn ($proto, $user, $pass, $host, $prefix, \\%args);\n\t}\nreturn ( );\n}\n\n# disconnect_userdb(string, &handle)\n# Closes a handle opened by connect_userdb\nsub disconnect_userdb\n{\nmy ($str, $h) = @_;\nif ($str =~ /^(mysql|postgresql):/) {\n\t# DBI disconnnect\n\t$h->disconnect();\n\t}\nelsif ($str =~ /^ldap:/) {\n\t# LDAP disconnect\n\t$h->disconnect();\n\t}\n}\n\n# read_mime_types()\n# Fills %mime with entries from file in %config and extra settings in %config\nsub read_mime_types\n{\nundef(%mime);\nif ($config{\"mimetypes\"} ne \"\") {\n\topen(MIME, $config{\"mimetypes\"});\n\twhile(<MIME>) {\n\t\tchop; s/#.*$//;\n\t\tif (/^(\\S+)\\s+(.*)$/) {\n\t\t\tmy $type = $1;\n\t\t\tmy @exts = split(/\\s+/, $2);\n\t\t\tforeach my $ext (@exts) {\n\t\t\t\t$mime{$ext} = $type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(MIME);\n\t}\nforeach my $k (keys %config) {\n\tif ($k !~ /^addtype_(.*)$/) { next; }\n\t$mime{$1} = $config{$k};\n\t}\n}\n\n# build_config_mappings()\n# Build the anonymous access list, IP access list, unauthenticated URLs list,\n# redirect mapping and allow and deny lists from %config\nsub build_config_mappings\n{\n# build anonymous access list\nundef(%anonymous);\nforeach my $a (split(/\\s+/, $config{'anonymous'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\t$anonymous{$1} = $2;\n\t\t}\n\t}\n\n# build IP access list\nundef(%ipaccess);\nforeach my $a (split(/\\s+/, $config{'ipaccess'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\t$ipaccess{$1} = $2;\n\t\t}\n\t}\n\n# build unauthenticated URLs list\n@unauth = split(/\\s+/, $config{'unauth'});\n\n# build redirect mapping\nundef(%redirect);\nforeach my $r (split(/\\s+/, $config{'redirect'})) {\n\tif ($r =~ /^([^=]+)=(\\S+)$/) {\n\t\t$redirect{$1} = $2;\n\t\t}\n\t}\n\n# build prefixes to be stripped\nundef(@strip_prefix);\nforeach my $r (split(/\\s+/, $config{'strip_prefix'})) {\n\tpush(@strip_prefix, $r);\n\t}\n\n# Init allow and deny lists\n@deny = split(/\\s+/, $config{\"deny\"});\n@deny = &to_ipaddress(@deny) if (!$config{'alwaysresolve'});\n@allow = split(/\\s+/, $config{\"allow\"});\n@allow = &to_ipaddress(@allow) if (!$config{'alwaysresolve'});\nundef(@allowusers);\nundef(@denyusers);\nif ($config{'allowusers'}) {\n\t@allowusers = split(/\\s+/, $config{'allowusers'});\n\t}\nelsif ($config{'denyusers'}) {\n\t@denyusers = split(/\\s+/, $config{'denyusers'});\n\t}\n\n# Build list of unixauth mappings\nundef(%unixauth);\nforeach my $ua (split(/\\s+/, $config{'unixauth'})) {\n\tif ($ua =~ /^(\\S+)=(\\S+)$/) {\n\t\t$unixauth{$1} = $2;\n\t\t}\n\telse {\n\t\t$unixauth{\"*\"} = $ua;\n\t\t}\n\t}\n\n# Build list of non-session-auth pages\nundef(%sessiononly);\nforeach my $sp (split(/\\s+/, $config{'sessiononly'})) {\n\t$sessiononly{$sp} = 1;\n\t}\n\n# Build list of logout times\nundef(@logouttimes);\nforeach my $a (split(/\\s+/, $config{'logouttimes'})) {\n\tif ($a =~ /^([^=]+)=(\\S+)$/) {\n\t\tpush(@logouttimes, [ $1, $2 ]);\n\t\t}\n\t}\npush(@logouttimes, [ undef, $config{'logouttime'} ]);\n\n# Build list of DAV pathss\nundef(@davpaths);\nforeach my $d (split(/\\s+/, $config{'davpaths'})) {\n\tpush(@davpaths, $d);\n\t}\n@davusers = split(/\\s+/, $config{'dav_users'});\n\n# Mobile agent substrings and hostname prefixes\n@mobile_agents = split(/\\t+/, $config{'mobile_agents'});\n@mobile_prefixes = split(/\\s+/, $config{'mobile_prefixes'});\n\n# Expires time list\n@expires_paths = ( );\nforeach my $pe (split(/\\t+/, $config{'expires_paths'})) {\n\tmy ($p, $e) = split(/=/, $pe);\n\tif ($p && $e ne '') {\n\t\tpush(@expires_paths, [ $p, $e ]);\n\t\t}\n\t}\n\n# Open debug log\nclose(DEBUG);\nif ($config{'debug'}) {\n\topen(DEBUG, \">>$config{'debug'}\");\n\t}\nelse {\n\topen(DEBUG, \">/dev/null\");\n\t}\n\n# Reset cache of sudo checks\nundef(%sudocache);\n}\n\n# is_group_member(&uinfo, groupname)\n# Returns 1 if some user is a primary or secondary member of a group\nsub is_group_member\n{\nlocal ($uinfo, $group) = @_;\nlocal @ginfo = getgrnam($group);\nreturn 0 if (!@ginfo);\nreturn 1 if ($ginfo[2] == $uinfo->[3]);\t# primary member\nforeach my $m (split(/\\s+/, $ginfo[3])) {\n\treturn 1 if ($m eq $uinfo->[0]);\n\t}\nreturn 0;\n}\n\n# prefix_to_mask(prefix)\n# Converts a number like 24 to a mask like 255.255.255.0\nsub prefix_to_mask\n{\nreturn $_[0] >= 24 ? \"255.255.255.\".(256-(2 ** (32-$_[0]))) :\n       $_[0] >= 16 ? \"255.255.\".(256-(2 ** (24-$_[0]))).\".0\" :\n       $_[0] >= 8 ? \"255.\".(256-(2 ** (16-$_[0]))).\".0.0\" :\n                     (256-(2 ** (8-$_[0]))).\".0.0.0\";\n}\n\n# get_logout_time(user, session-id)\n# Given a username, returns the idle time before he will be logged out\nsub get_logout_time\n{\nlocal ($user, $sid) = @_;\nif (!defined($logout_time_cache{$user,$sid})) {\n\tlocal $time;\n\tforeach my $l (@logouttimes) {\n\t\tif ($l->[0] =~ /^\\@(.*)$/) {\n\t\t\t# Check group membership\n\t\t\tlocal @uinfo = getpwnam($user);\n\t\t\tif (@uinfo && &is_group_member(\\@uinfo, $1)) {\n\t\t\t\t$time = $l->[1];\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($l->[0] =~ /^\\//) {\n\t\t\t# Check file contents\n\t\t\topen(FILE, $l->[0]);\n\t\t\twhile(<FILE>) {\n\t\t\t\ts/\\r|\\n//g;\n\t\t\t\ts/^\\s*#.*$//;\n\t\t\t\tif ($user eq $_) {\n\t\t\t\t\t$time = $l->[1];\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tclose(FILE);\n\t\t\t}\n\t\telsif (!$l->[0]) {\n\t\t\t# Always match\n\t\t\t$time = $l->[1];\n\t\t\t}\n\t\telse {\n\t\t\t# Check username\n\t\t\tif ($l->[0] eq $user) {\n\t\t\t\t$time = $l->[1];\n\t\t\t\t}\n\t\t\t}\n\t\tlast if (defined($time));\n\t\t}\n\t$logout_time_cache{$user,$sid} = $time;\n\t}\nreturn $logout_time_cache{$user,$sid};\n}\n\n# password_crypt(password, salt)\n# If the salt looks like MD5 and we have a library for it, perform MD5 hashing\n# of a password. Otherwise, do Unix crypt.\nsub password_crypt\n{\nlocal ($pass, $salt) = @_;\nlocal $rval;\nif ($salt =~ /^\\$1\\$/ && $use_md5) {\n\t$rval = &encrypt_md5($pass, $salt);\n\t}\nelsif ($salt =~ /^\\$6\\$/ && $use_sha512) {\n\t$rval = &encrypt_sha512($pass, $salt);\n\t}\nif (!defined($rval) || $salt ne $rval) {\n\t$rval = &unix_crypt($pass, $salt);\n\t}\nreturn $rval;\n}\n\n# unix_crypt(password, salt)\n# Performs standard Unix hashing for a password\nsub unix_crypt\n{\nlocal ($pass, $salt) = @_;\nif ($use_perl_crypt) {\n\treturn Crypt::UnixCrypt::crypt($pass, $salt);\n\t}\nelse {\n\treturn crypt($pass, $salt);\n\t}\n}\n\n# handle_dav_request(davpath)\n# Pass a request on to the Net::DAV::Server module\nsub handle_dav_request\n{\nlocal ($path) = @_;\neval \"use Filesys::Virtual::Plain\";\neval \"use Net::DAV::Server\";\neval \"use HTTP::Request\";\neval \"use HTTP::Headers\";\n\nif ($Net::DAV::Server::VERSION eq '1.28' && $config{'dav_nolock'}) {\n\tdelete $Net::DAV::Server::implemented{lock};\n\tdelete $Net::DAV::Server::implemented{unlock};\n\t}\n\n# Read in request data\nif (!$posted_data) {\n\tlocal $clen = $header{\"content-length\"};\n\twhile(length($posted_data) < $clen) {\n\t\t$buf = &read_data($clen - length($posted_data));\n\t\tif (!length($buf)) {\n\t\t\t&http_error(500, \"Failed to read POST request\");\n\t\t\t}\n\t\t$posted_data .= $buf;\n\t\t}\n\t}\n\n# For subsequent logging\nopen(MINISERVLOG, \">>$config{'logfile'}\");\n\n# Switch to user\nlocal $root;\nlocal @u = getpwnam($authuser);\nif ($config{'dav_remoteuser'} && !$< && $validated) {\n\tif (@u) {\n\t\tif ($u[2] != 0) {\n\t\t\t$( = $u[3]; $) = \"$u[3] $u[3]\";\n\t\t\t($>, $<) = ($u[2], $u[2]);\n\t\t\t}\n\t\tif ($config{'dav_root'} eq '*') {\n\t\t\t$root = $u[7];\n\t\t\t}\n\t\t}\n\telse {\n\t\t&http_error(500, \"Unix user \".&html_strip($authuser).\n\t\t\t\t \" does not exist\");\n\t\treturn 0;\n\t\t}\n\t}\n$root ||= $config{'dav_root'};\n$root ||= \"/\";\n\n# Check if this user can use DAV\nif (@davusers) {\n\t&users_match(\\@u, @davusers) ||\n\t\t&http_error(500, \"You are not allowed to access DAV\");\n\t}\n\n# Create DAV server\nmy $filesys = Filesys::Virtual::Plain->new({root_path => $root});\nmy $webdav = Net::DAV::Server->new();\n$webdav->filesys($filesys);\n\n# Make up a request object, and feed to DAV\nlocal $ho = HTTP::Headers->new;\nforeach my $h (keys %header) {\n\tnext if (lc($h) eq \"connection\");\n\t$ho->header($h => $header{$h});\n\t}\nif ($path ne \"/\") {\n\t$request_uri =~ s/^\\Q$path\\E//;\n\t$request_uri = \"/\" if ($request_uri eq \"\");\n\t}\nmy $request = HTTP::Request->new($method, $request_uri, $ho,\n\t\t\t\t $posted_data);\nif ($config{'dav_debug'}) {\n\tprint STDERR \"DAV request :\\n\";\n\tprint STDERR \"---------------------------------------------\\n\";\n\tprint STDERR $request->as_string();\n\tprint STDERR \"---------------------------------------------\\n\";\n\t}\nmy $response = $webdav->run($request);\n\n# Send back the reply\n&write_data(\"HTTP/1.1 \",$response->code(),\" \",$response->message(),\"\\r\\n\");\nlocal $content = $response->content();\nif ($path ne \"/\") {\n\t$content =~ s|href>/(.+)<|href>$path/$1<|g;\n\t$content =~ s|href>/<|href>$path<|g;\n\t}\nforeach my $h ($response->header_field_names) {\n\tnext if (lc($h) eq \"connection\" || lc($h) eq \"content-length\");\n\t&write_data(\"$h: \",$response->header($h),\"\\r\\n\");\n\t}\n&write_data(\"Content-length: \",length($content),\"\\r\\n\");\nlocal $rv = &write_keep_alive(0);\n&write_data(\"\\r\\n\");\n&write_data($content);\n\nif ($config{'dav_debug'}) {\n\tprint STDERR \"DAV reply :\\n\";\n\tprint STDERR \"---------------------------------------------\\n\";\n\tprint STDERR \"HTTP/1.1 \",$response->code(),\" \",$response->message(),\"\\r\\n\";\n\tforeach my $h ($response->header_field_names) {\n\t\tnext if (lc($h) eq \"connection\" || lc($h) eq \"content-length\");\n\t\tprint STDERR \"$h: \",$response->header($h),\"\\r\\n\";\n\t\t}\n\tprint STDERR \"Content-length: \",length($content),\"\\r\\n\";\n\tprint STDERR \"\\r\\n\";\n\tprint STDERR $content;\n\tprint STDERR \"---------------------------------------------\\n\";\n\t}\n\n# Log it\n&log_request($loghost, $authuser, $reqline, $response->code(), \n\t     length($response->content()));\n}\n\n# get_system_hostname()\n# Returns the hostname of this system, for reporting to listeners\nsub get_system_hostname\n{\n# On Windows, try computername environment variable\nreturn $ENV{'computername'} if ($ENV{'computername'});\nreturn $ENV{'COMPUTERNAME'} if ($ENV{'COMPUTERNAME'});\n\n# If a specific command is set, use it first\nif ($config{'hostname_command'}) {\n\tlocal $out = `($config{'hostname_command'}) 2>&1`;\n\tif (!$?) {\n\t\t$out =~ s/\\r|\\n//g;\n\t\treturn $out;\n\t\t}\n\t}\n\n# First try the hostname command\nlocal $out = `hostname 2>&1`;\nif (!$? && $out =~ /\\S/) {\n\t$out =~ s/\\r|\\n//g;\n\treturn $out;\n\t}\n\n# Try the Sys::Hostname module\neval \"use Sys::Hostname\";\nif (!$@) {\n\tlocal $rv = eval \"hostname()\";\n\tif (!$@ && $rv) {\n\t\treturn $rv;\n\t\t}\n\t}\n\n# Must use net name on Windows\nlocal $out = `net name 2>&1`;\nif ($out =~ /\\-+\\r?\\n(\\S+)/) {\n\treturn $1;\n\t}\n\nreturn undef;\n}\n\n# indexof(string, array)\n# Returns the index of some value in an array, or -1\nsub indexof {\n  local($i);\n  for($i=1; $i <= $#_; $i++) {\n    if ($_[$i] eq $_[0]) { return $i - 1; }\n  }\n  return -1;\n}\n\n\n# has_command(command)\n# Returns the full path if some command is in the path, undef if not\nsub has_command\n{\nlocal($d);\nif (!$_[0]) { return undef; }\nif (exists($has_command_cache{$_[0]})) {\n\treturn $has_command_cache{$_[0]};\n\t}\nlocal $rv = undef;\nif ($_[0] =~ /^\\//) {\n\t$rv = -x $_[0] ? $_[0] : undef;\n\t}\nelse {\n\tlocal $sp = $on_windows ? ';' : ':';\n\tforeach $d (split($sp, $ENV{PATH})) {\n\t\tif (-x \"$d/$_[0]\") {\n\t\t\t$rv = \"$d/$_[0]\";\n\t\t\tlast;\n\t\t\t}\n\t\tif ($on_windows) {\n\t\t\tforeach my $sfx (\".exe\", \".com\", \".bat\") {\n\t\t\t\tif (-r \"$d/$_[0]\".$sfx) {\n\t\t\t\t\t$rv = \"$d/$_[0]\".$sfx;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n$has_command_cache{$_[0]} = $rv;\nreturn $rv;\n}\n\n# check_sudo_permissions(user, pass)\n# Returns 1 if some user can run any command via sudo\nsub check_sudo_permissions\n{\nlocal ($user, $pass) = @_;\n\n# First try the pipes\nif ($PASSINw) {\n\tprint DEBUG \"check_sudo_permissions: querying cache for $user\\n\";\n\tprint $PASSINw \"readsudo $user\\n\";\n\tlocal $can = <$PASSOUTr>;\n\tchop($can);\n\tprint DEBUG \"check_sudo_permissions: cache said $can\\n\";\n\tif ($can =~ /^\\d+$/ && $can != 2) {\n\t\treturn int($can);\n\t\t}\n\t}\n\nlocal $ptyfh = new IO::Pty;\nprint DEBUG \"check_sudo_permissions: ptyfh=$ptyfh\\n\";\nif (!$ptyfh) {\n\tprint STDERR \"Failed to create new PTY with IO::Pty\\n\";\n\treturn 0;\n\t}\nlocal @uinfo = getpwnam($user);\nif (!@uinfo) {\n\tprint STDERR \"Unix user $user does not exist for sudo\\n\";\n\treturn 0;\n\t}\n\n# Execute sudo in a sub-process, via a pty\nlocal $ttyfh = $ptyfh->slave();\nprint DEBUG \"check_sudo_permissions: ttyfh=$ttyfh\\n\";\nlocal $tty = $ptyfh->ttyname();\nprint DEBUG \"check_sudo_permissions: tty=$tty\\n\";\nchown($uinfo[2], $uinfo[3], $tty);\npipe(SUDOr, SUDOw);\nprint DEBUG \"check_sudo_permissions: about to fork..\\n\";\nlocal $pid = fork();\nprint DEBUG \"check_sudo_permissions: fork=$pid pid=$$\\n\";\nif ($pid < 0) {\n\tprint STDERR \"fork for sudo failed : $!\\n\";\n\treturn 0;\n\t}\nif (!$pid) {\n\tsetsid();\n\t($(, $)) = ( $uinfo[3],\n                     \"$uinfo[3] \".join(\" \", $uinfo[3],\n                                            &other_groups($uinfo[0])) );\n\t($>, $<) = ($uinfo[2], $uinfo[2]);\n\t$ENV{'USER'} = $ENV{'LOGNAME'} = $user;\n\t$ENV{'HOME'} = $uinfo[7];\n\n\t$ptyfh->make_slave_controlling_terminal();\n\tclose(STDIN); close(STDOUT); close(STDERR);\n\tuntie(*STDIN); untie(*STDOUT); untie(*STDERR);\n\tclose($PASSINw); close($PASSOUTr);\n\tclose(SUDOw);\n\tclose(SOCK);\n\tclose(MAIN);\n\topen(STDIN, \"<&SUDOr\");\n\topen(STDOUT, \">$tty\");\n\topen(STDERR, \">&STDOUT\");\n\tclose($ptyfh);\n\texec(\"sudo -l -S\");\n\tprint \"Exec failed : $!\\n\";\n\texit 1;\n\t}\nprint DEBUG \"check_sudo_permissions: pid=$pid\\n\";\nclose(SUDOr);\n$ptyfh->close_slave();\n\n# Send password, and get back response\nlocal $oldfh = select(SUDOw);\n$| = 1;\nselect($oldfh);\nprint DEBUG \"check_sudo_permissions: about to send pass\\n\";\nlocal $SIG{'PIPE'} = 'ignore';\t# Sometimes sudo doesn't ask for a password\nprint SUDOw $pass,\"\\n\";\nprint DEBUG \"check_sudo_permissions: sent pass=$pass\\n\";\nclose(SUDOw);\nlocal $out;\nwhile(<$ptyfh>) {\n\tprint DEBUG \"check_sudo_permissions: got $_\";\n\t$out .= $_;\n\t}\nclose($ptyfh);\nkill('KILL', $pid);\nwaitpid($pid, 0);\nlocal ($ok) = ($out =~ /\\(ALL\\)\\s+ALL|\\(ALL\\)\\s+NOPASSWD:\\s+ALL|\\(ALL\\s*:\\s*ALL\\)\\s+ALL|\\(ALL\\s*:\\s*ALL\\)\\s+NOPASSWD:\\s+ALL/ ? 1 : 0);\n\n# Update cache\nif ($PASSINw) {\n\tprint $PASSINw \"writesudo $user $ok\\n\";\n\t}\n\nreturn $ok;\n}\n\nsub other_groups\n{\nmy ($user) = @_;\nmy @rv;\nsetgrent();\nwhile(my @g = getgrent()) {\n        my @m = split(/\\s+/, $g[3]);\n        push(@rv, $g[2]) if (&indexof($user, @m) >= 0);\n        }\nendgrent();\nreturn @rv;\n}\n\n# is_mobile_useragent(agent)\n# Returns 1 if some user agent looks like a cellphone or other mobile device,\n# such as a treo.\nsub is_mobile_useragent\n{\nlocal ($agent) = @_;\nlocal @prefixes = ( \n    \"UP.Link\",    # Openwave\n    \"Nokia\",      # All Nokias start with Nokia\n    \"MOT-\",       # All Motorola phones start with MOT-\n    \"SAMSUNG\",    # Samsung browsers\n    \"Samsung\",    # Samsung browsers\n    \"SEC-\",       # Samsung browsers\n    \"AU-MIC\",     # Samsung browsers\n    \"AUDIOVOX\",   # Audiovox\n    \"BlackBerry\", # BlackBerry\n    \"hiptop\",     # Danger hiptop Sidekick\n    \"SonyEricsson\", # Sony Ericsson\n    \"Ericsson\",     # Old Ericsson browsers , mostly WAP\n    \"Mitsu/1.1.A\",  # Mitsubishi phones\n    \"Panasonic WAP\", # Panasonic old WAP phones\n    \"DoCoMo\",     # DoCoMo phones\n    \"Lynx\",\t  # Lynx text-mode linux browser\n    \"Links\",\t  # Another text-mode linux browser\n    \"Dalvik\",\t  # Android browser\n    );\nlocal @substrings = (\n    \"UP.Browser\",         # Openwave\n    \"MobilePhone\",        # NetFront\n    \"AU-MIC-A700\",        # Samsung A700 Obigo browsers\n    \"Danger hiptop\",      # Danger Sidekick hiptop\n    \"Windows CE\",         # Windows CE Pocket PC\n    \"IEMobile\",           # Windows mobile browser\n    \"Blazer\",             # Palm Treo Blazer\n    \"BlackBerry\",         # BlackBerries can emulate other browsers, but\n                          # they still keep this string in the UserAgent\n    \"SymbianOS\",          # New Series60 browser has safari in it and\n                          # SymbianOS is the only distinguishing string\n    \"iPhone\",\t\t  # Apple iPhone KHTML browser\n    \"iPod\",\t\t  # iPod touch browser\n    \"MobileSafari\",\t  # HTTP client in iPhone\n    \"Mobile Safari\",\t  # Samsung Galaxy S6 browser\n    \"Opera Mini\",\t  # Opera Mini\n    \"HTC_P3700\",\t  # HTC mobile device\n    \"Pre/\",\t\t  # Palm Pre\n    \"webOS/\",\t\t  # Palm WebOS\n    \"Nintendo DS\",\t  # DSi / DSi-XL\n    );\nlocal @regexps = (\n    \"Android.*Mobile\",\t  # Android phone\n    );\nforeach my $p (@prefixes) {\n\treturn 1 if ($agent =~ /^\\Q$p\\E/);\n\t}\nforeach my $s (@substrings, @mobile_agents) {\n\treturn 1 if ($agent =~ /\\Q$s\\E/);\n\t}\nforeach my $s (@regexps) {\n\treturn 1 if ($agent =~ /$s/);\n\t}\nreturn 0;\n}\n\n# write_blocked_file()\n# Writes out a text file of blocked hosts and users\nsub write_blocked_file\n{\nopen(BLOCKED, \">$config{'blockedfile'}\");\nforeach my $d (grep { $hostfail{$_} } @deny) {\n\tprint BLOCKED \"host $d $hostfail{$d} $blockhosttime{$d}\\n\";\n\t}\nforeach my $d (grep { $userfail{$_} } @denyusers) {\n\tprint BLOCKED \"user $d $userfail{$d} $blockusertime{$d}\\n\";\n\t}\nclose(BLOCKED);\nchmod(0700, $config{'blockedfile'});\n}\n\nsub write_pid_file\n{\nopen(PIDFILE, \">$config{'pidfile'}\");\nprintf PIDFILE \"%d\\n\", getpid();\nclose(PIDFILE);\n$miniserv_main_pid = getpid();\n}\n\n# lock_user_password(user)\n# Updates a user's password file entry to lock it, both in memory and on disk.\n# Returns 1 if done, -1 if no such user, 0 if already locked\nsub lock_user_password\n{\nlocal ($user) = @_;\nlocal $uinfo = &get_user_details($user);\nif (!$uinfo) {\n\t# No such user!\n\treturn -1;\n\t}\nif ($uinfo->{'pass'} =~ /^\\!/) {\n\t# Already locked\n\treturn 0;\n\t}\nif (!$uinfo->{'proto'}) {\n\t# Write to users file\n\t$users{$user} = \"!\".$users{$user};\n\topen(USERS, $config{'userfile'});\n\tlocal @ufile = <USERS>;\n\tclose(USERS);\n\tforeach my $u (@ufile) {\n\t\tlocal @uinfo = split(/:/, $u);\n\t\tif ($uinfo[0] eq $user) {\n\t\t\t$uinfo[1] = $users{$user};\n\t\t\t}\n\t\t$u = join(\":\", @uinfo);\n\t\t}\n\topen(USERS, \">$config{'userfile'}\");\n\tprint USERS @ufile;\n\tclose(USERS);\n\treturn 0;\n\t}\n\nif ($config{'userdb'}) {\n\t# Update user DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($config{'userdb'});\n\tif (!$dbh) {\n\t\treturn -1;\n\t\t}\n\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Update user attribute\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"update webmin_user set pass = ? where id = ?\");\n\t\tif (!$cmd || !$cmd->execute(\"!\".$uinfo->{'pass'},\n\t\t\t\t\t    $uinfo->{'id'})) {\n\t\t\t# Update failed\n\t\t\tprint STDERR \"Failed to lock password : \",\n\t\t\t\t     $dbh->errstr,\"\\n\";\n\t\t\treturn -1;\n\t\t\t}\n\t\t$cmd->finish() if ($cmd);\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Update LDAP object\n\t\tmy $rv = $dbh->modify($uinfo->{'id'},\n\t\t      replace => { 'webminPass' => '!'.$uinfo->{'pass'} });\n\t\tif (!$rv || $rv->code) {\n\t\t\tprint STDERR \"Failed to lock password : \",\n\t\t\t\t     ($rv ? $rv->error : \"Unknown error\"),\"\\n\";\n\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($config{'userdb'}, $dbh);\n\treturn 0;\n\t}\n\nreturn -1;\t# This should never be reached\n}\n\n# hash_session_id(sid)\n# Returns an MD5 or Unix-crypted session ID\nsub hash_session_id\n{\nlocal ($sid) = @_;\nif (!$hash_session_id_cache{$sid}) {\n\tif ($use_md5) {\n\t\t# Take MD5 hash\n\t\t$hash_session_id_cache{$sid} = &encrypt_md5($sid);\n\t\t}\n\telse {\n\t\t# Unix crypt\n\t\t$hash_session_id_cache{$sid} = &unix_crypt($sid, \"XX\");\n\t\t}\n\t}\nreturn $hash_session_id_cache{$sid};\n}\n\n# encrypt_md5(string, [salt])\n# Returns a string encrypted in MD5 format\nsub encrypt_md5\n{\nlocal ($passwd, $salt) = @_;\nlocal $magic = '$1$';\nif ($salt =~ /^\\$1\\$([^\\$]+)/) {\n\t# Extract actual salt from already encrypted password\n\t$salt = $1;\n\t}\n\n# Add the password\nlocal $ctx = eval \"new $use_md5\";\n$ctx->add($passwd);\nif ($salt) {\n\t$ctx->add($magic);\n\t$ctx->add($salt);\n\t}\n\n# Add some more stuff from the hash of the password and salt\nlocal $ctx1 = eval \"new $use_md5\";\n$ctx1->add($passwd);\nif ($salt) {\n\t$ctx1->add($salt);\n\t}\n$ctx1->add($passwd);\nlocal $final = $ctx1->digest();\nfor($pl=length($passwd); $pl>0; $pl-=16) {\n\t$ctx->add($pl > 16 ? $final : substr($final, 0, $pl));\n\t}\n\n# This piece of code seems rather pointless, but it's in the C code that\n# does MD5 in PAM so it has to go in!\nlocal $j = 0;\nlocal ($i, $l);\nfor($i=length($passwd); $i; $i >>= 1) {\n\tif ($i & 1) {\n\t\t$ctx->add(\"\\0\");\n\t\t}\n\telse {\n\t\t$ctx->add(substr($passwd, $j, 1));\n\t\t}\n\t}\n$final = $ctx->digest();\n\nif ($salt) {\n\t# This loop exists only to waste time\n\tfor($i=0; $i<1000; $i++) {\n\t\t$ctx1 = eval \"new $use_md5\";\n\t\t$ctx1->add($i & 1 ? $passwd : $final);\n\t\t$ctx1->add($salt) if ($i % 3);\n\t\t$ctx1->add($passwd) if ($i % 7);\n\t\t$ctx1->add($i & 1 ? $final : $passwd);\n\t\t$final = $ctx1->digest();\n\t\t}\n\t}\n\n# Convert the 16-byte final string into a readable form\nlocal $rv;\nlocal @final = map { ord($_) } split(//, $final);\n$l = ($final[ 0]<<16) + ($final[ 6]<<8) + $final[12];\n$rv .= &to64($l, 4);\n$l = ($final[ 1]<<16) + ($final[ 7]<<8) + $final[13];\n$rv .= &to64($l, 4);\n$l = ($final[ 2]<<16) + ($final[ 8]<<8) + $final[14];\n$rv .= &to64($l, 4);\n$l = ($final[ 3]<<16) + ($final[ 9]<<8) + $final[15];\n$rv .= &to64($l, 4);\n$l = ($final[ 4]<<16) + ($final[10]<<8) + $final[ 5];\n$rv .= &to64($l, 4);\n$l = $final[11];\n$rv .= &to64($l, 2);\n\n# Add salt if needed\nif ($salt) {\n\treturn $magic.$salt.'$'.$rv;\n\t}\nelse {\n\treturn $rv;\n\t}\n}\n\n# encrypt_sha512(password, [salt])\n# Hashes a password, possibly with the given salt, with SHA512\nsub encrypt_sha512\n{\nmy ($passwd, $salt) = @_;\nif ($salt =~ /^\\$6\\$([^\\$]+)/) {\n\t# Extract actual salt from already encrypted password\n\t$salt = $1;\n\t}\n$salt ||= '$6$'.substr(time(), -8).'$';\nreturn crypt($passwd, $salt);\n}\n\nsub to64\n{\nlocal ($v, $n) = @_;\nlocal $r;\nwhile(--$n >= 0) {\n        $r .= $itoa64[$v & 0x3f];\n        $v >>= 6;\n        }\nreturn $r;\n}\n\n# read_file(file, &assoc, [&order], [lowercase])\n# Fill an associative array with name=value pairs from a file\nsub read_file\n{\nopen(ARFILE, $_[0]) || return 0;\nwhile(<ARFILE>) {\n\ts/\\r|\\n//g;\n        if (!/^#/ && /^([^=]*)=(.*)$/) {\n\t\t$_[1]->{$_[3] ? lc($1) : $1} = $2;\n\t\tpush(@{$_[2]}, $1) if ($_[2]);\n        \t}\n        }\nclose(ARFILE);\nreturn 1;\n}\n \n# write_file(file, array)\n# Write out the contents of an associative array as name=value lines\nsub write_file\n{\nlocal(%old, @order);\n&read_file($_[0], \\%old, \\@order);\nopen(ARFILE, \">$_[0]\");\nforeach $k (@order) {\n        print ARFILE $k,\"=\",$_[1]->{$k},\"\\n\" if (exists($_[1]->{$k}));\n\t}\nforeach $k (keys %{$_[1]}) {\n        print ARFILE $k,\"=\",$_[1]->{$k},\"\\n\" if (!exists($old{$k}));\n        }\nclose(ARFILE);\n}\n\n# execute_ready_webmin_crons(run-count)\n# Find and run any cron jobs that are due, based on their last run time and\n# execution interval\nsub execute_ready_webmin_crons\n{\nmy ($runs) = @_;\nmy $now = time();\nmy $changed = 0;\nforeach my $cron (@webmincrons) {\n\tmy $run = 0;\n\tif ($runs == 0 && $cron->{'boot'}) {\n\t\t# If cron job wants to be run at startup, run it now\n\t\t$run = 1;\n\t\t}\n\telsif ($cron->{'disabled'}) {\n\t\t# Explicitly disabled\n\t\t$run = 0;\n\t\t}\n\telsif (!$webmincron_last{$cron->{'id'}}) {\n\t\t# If not ever run before, don't run right away\n\t\t$webmincron_last{$cron->{'id'}} = $now;\n\t\t$changed = 1;\n\t\t}\n\telsif ($cron->{'interval'} &&\n\t       $now - $webmincron_last{$cron->{'id'}} > $cron->{'interval'}) {\n\t\t# Older than interval .. time to run\n\t\t$run = 1;\n\t\t}\n\telsif ($cron->{'mins'} ne '') {\n\t\t# Check if current time matches spec, and we haven't run in the\n\t\t# last minute\n\t\tmy @tm = localtime($now);\n\t\tif (&matches_cron($cron->{'mins'}, $tm[1], 0) &&\n\t\t    &matches_cron($cron->{'hours'}, $tm[2], 0) &&\n\t\t    &matches_cron($cron->{'days'}, $tm[3], 1) &&\n\t\t    &matches_cron($cron->{'months'}, $tm[4]+1, 1) &&\n\t\t    &matches_cron($cron->{'weekdays'}, $tm[6], 0) &&\n\t\t    $now - $webmincron_last{$cron->{'id'}} > 60) {\n\t\t\t$run = 1;\n\t\t\t}\n\t\t}\n\n\tif ($run) {\n\t\tprint DEBUG \"Running cron id=$cron->{'id'} \".\n\t\t\t    \"module=$cron->{'module'} func=$cron->{'func'} \".\n\t\t\t    \"arg0=$cron->{'arg0'}\\n\";\n\t\t$webmincron_last{$cron->{'id'}} = $now;\n\t\t$changed = 1;\n\t\tmy $pid = &execute_webmin_command($config{'webmincron_wrapper'},\n\t\t\t\t\t\t  [ $cron ]);\n\t\tpush(@childpids, $pid);\n\t\t}\n\t}\nif ($changed) {\n\t# Write out file containing last run times\n\t&write_file($config{'webmincron_last'}, \\%webmincron_last);\n\t}\n}\n\n# matches_cron(cron-spec, time, first-value)\n# Checks if some minute or hour matches some cron spec, which can be * or a list\n# of numbers.\nsub matches_cron\n{\nmy ($spec, $tm, $first) = @_;\nif ($spec eq '*') {\n\treturn 1;\n\t}\nelse {\n\tforeach my $s (split(/,/, $spec)) {\n\t\tif ($s == $tm ||\n\t\t    $s =~ /^(\\d+)\\-(\\d+)$/ &&\n\t\t      $tm >= $1 && $tm <= $2 ||\n\t\t    $s =~ /^\\*\\/(\\d+)$/ &&\n\t\t      $tm % $1 == $first ||\n\t\t    $s =~ /^(\\d+)\\-(\\d+)\\/(\\d+)$/ &&\n\t\t      $tm >= $1 && $tm <= $2 && $tm % $3 == $first) {\n\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n}\n\n# read_webmin_crons()\n# Read all scheduled webmin cron functions and store them in the @webmincrons\n# global list\nsub read_webmin_crons\n{\n@webmincrons = ( );\nopendir(CRONS, $config{'webmincron_dir'});\nprint DEBUG \"Reading crons from $config{'webmincron_dir'}\\n\";\nforeach my $f (readdir(CRONS)) {\n\tif ($f =~ /^(\\d+)\\.cron$/) {\n\t\tmy %cron;\n\t\t&read_file(\"$config{'webmincron_dir'}/$f\", \\%cron);\n\t\t$cron{'id'} = $1;\n\t\tmy $broken = 0;\n\t\tforeach my $n ('module', 'func') {\n\t\t\tif (!$cron{$n}) {\n\t\t\t\tprint STDERR \"Cron $1 missing $n\\n\";\n\t\t\t\t$broken = 1;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!$cron{'interval'} && $cron{'mins'} eq '' &&\n\t\t    $cron{'special'} eq '' && !$cron{'boot'}) {\n\t\t\tprint STDERR \"Cron $1 missing any time spec\\n\";\n\t\t\t$broken = 1;\n\t\t\t}\n\t\tif ($cron{'special'} eq 'hourly') {\n\t\t\t# Run every hour on the hour\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '*';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'daily') {\n\t\t\t# Run every day at midnight\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'monthly') {\n\t\t\t# Run every month on the 1st\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '1';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'weekly') {\n\t\t\t# Run every month on the 1st\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '*';\n\t\t\t$cron{'months'} = '*';\n\t\t\t$cron{'weekdays'} = '0';\n\t\t\t}\n\t\telsif ($cron{'special'} eq 'yearly' ||\n\t\t       $cron{'special'} eq 'annually') {\n\t\t\t# Run every year on 1st january\n\t\t\t$cron{'mins'} = 0;\n\t\t\t$cron{'hours'} = '0';\n\t\t\t$cron{'days'} = '1';\n\t\t\t$cron{'months'} = '1';\n\t\t\t$cron{'weekdays'} = '*';\n\t\t\t}\n\t\telsif ($cron{'special'}) {\n\t\t\tprint STDERR \"Cron $1 invalid special time $cron{'special'}\\n\";\n\t\t\t$broken = 1;\n\t\t\t}\n\t\tif ($cron{'special'}) {\n\t\t\tdelete($cron{'special'});\n\t\t\t}\n\t\tif (!$broken) {\n\t\t\tprint DEBUG \"Adding cron id=$cron{'id'} module=$cron{'module'} func=$cron{'func'} arg0=$cron{'arg0'}\\n\";\n\t\t\tpush(@webmincrons, \\%cron);\n\t\t\t}\n\t\t}\n\t}\nclosedir(CRONS);\n}\n\n# precache_files()\n# Read into the Webmin cache all files marked for pre-caching\nsub precache_files\n{\nundef(%main::read_file_cache);\nforeach my $g (split(/\\s+/, $config{'precache'})) {\n\tnext if ($g eq \"none\");\n\tforeach my $f (glob(\"$config{'root'}/$g\")) {\n\t\tmy @st = stat($f);\n\t\tnext if (!@st);\n\t\t$main::read_file_cache{$f} = { };\n\t\t&read_file($f, $main::read_file_cache{$f});\n\t\t$main::read_file_cache_time{$f} = $st[9];\n\t\t}\n\t}\n}\n\n# Check if some address is valid IPv4, returns 1 if so.\nsub check_ipaddress\n{\nreturn $_[0] =~ /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/ &&\n\t$1 >= 0 && $1 <= 255 &&\n\t$2 >= 0 && $2 <= 255 &&\n\t$3 >= 0 && $3 <= 255 &&\n\t$4 >= 0 && $4 <= 255;\n}\n\n# Check if some IPv6 address is properly formatted, and returns 1 if so.\nsub check_ip6address\n{\n  my @blocks = split(/:/, $_[0]);\n  return 0 if (@blocks == 0 || @blocks > 8);\n  my $ib = $#blocks;\n  my $where = index($blocks[$ib],\"/\");\n  my $m = 0;\n  if ($where != -1) {\n    my $b = substr($blocks[$ib],0,$where);\n    $m = substr($blocks[$ib],$where+1,length($blocks[$ib])-($where+1));\n    $blocks[$ib]=$b;\n  }\n  return 0 if ($m <0 || $m >128); \n  my $b;\n  my $empty = 0;\n  foreach $b (@blocks) {\n\t  return 0 if ($b ne \"\" && $b !~ /^[0-9a-f]{1,4}$/i);\n\t  $empty++ if ($b eq \"\");\n\t  }\n  return 0 if ($empty > 1 && !($_[0] =~ /^::/ && $empty == 2));\n  return 1;\n}\n\n# network_to_address(binary)\n# Given a network address in binary IPv4 or v4 format, return the string form\nsub network_to_address\n{\nlocal ($addr) = @_;\nif (length($addr) == 4 || !$use_ipv6) {\n\treturn inet_ntoa($addr);\n\t}\nelse {\n\treturn inet_ntop(AF_INET6(), $addr);\n\t}\n}\n\n# redirect_stderr_to_log()\n# Re-direct STDERR to error log file\nsub redirect_stderr_to_log\n{\nif ($config{'errorlog'} ne '-') {\n\topen(STDERR, \">>$config{'errorlog'}\") ||\n\t\tdie \"failed to open $config{'errorlog'} : $!\";\n\tif ($config{'logperms'}) {\n\t\tchmod(oct($config{'logperms'}), $config{'errorlog'});\n\t\t}\n\t}\nselect(STDERR); $| = 1; select(STDOUT);\n}\n\n# should_gzip_file(filename)\n# Returns 1 if some path should be gzipped\nsub should_gzip_file\n{\nmy ($path) = @_;\nreturn $path !~ /\\.(gif|png|jpg|jpeg|tif|tiff)$/i;\n}\n\n# get_expires_time(path)\n# Given a URL path, return the client-side expiry time in seconds\nsub get_expires_time\n{\nmy ($path) = @_;\nforeach my $pe (@expires_paths) {\n\tif ($path =~ /$pe->[0]/i) {\n\t\treturn $pe->[1];\n\t\t}\n\t}\nreturn $config{'expires'};\n}\n\nsub html_escape\n{\nmy ($tmp) = @_;\n$tmp =~ s/&/&amp;/g;\n$tmp =~ s/</&lt;/g;\n$tmp =~ s/>/&gt;/g;\n$tmp =~ s/\\\"/&quot;/g;\n$tmp =~ s/\\'/&#39;/g;\n$tmp =~ s/=/&#61;/g;\nreturn $tmp;\n}\n\nsub html_strip\n{\nmy ($tmp) = @_;\n$tmp =~ s/<[^>]*>//g;\nreturn $tmp;\n}\n\n# validate_twofactor(username, token)\n# Checks if a user's two-factor token is valid or not. Returns undef on success\n# or the error message on failure.\nsub validate_twofactor\n{\nmy ($user, $token) = @_;\nlocal $uinfo = &get_user_details($user);\n$token =~ s/^\\s+//;\n$token =~ s/\\s+$//;\n$token || return \"No two-factor token entered\";\n$uinfo->{'twofactor_provider'} || return undef;\npipe(TOKENr, TOKENw);\nmy $pid = &execute_webmin_command($config{'twofactor_wrapper'},\n\t[ $user, $uinfo->{'twofactor_provider'}, $uinfo->{'twofactor_id'},\n\t  $token, $uinfo->{'twofactor_apikey'} ],\n\tTOKENw);\nclose(TOKENw);\nwaitpid($pid, 0);\nmy $ex = $?;\nmy $out = <TOKENr>;\nclose(TOKENr);\nif ($ex) {\n\treturn $out || \"Unknown two-factor authentication failure\";\n\t}\nreturn undef;\n}\n\n# execute_webmin_command(command, &argv, [stdout-fd])\n# Run some Webmin script in a sub-process, like webmincron.pl\n# Returns the PID of the new process.\nsub execute_webmin_command\n{\nmy ($cmd, $argv, $fd) = @_;\nmy $pid = fork();\nif (!$pid) {\n\t# Run via a wrapper command, which we run like a CGI\n\tdbmclose(%sessiondb);\n\tif ($fd) {\n\t\topen(STDOUT, \">&$fd\");\n\t\t}\n\telse {\n\t\topen(STDOUT, \">&STDERR\");\n\t\t}\n\t&close_all_sockets();\n\t&close_all_pipes();\n\tclose(LISTEN);\n\n\t# Setup CGI-like environment\n\t$envtz = $ENV{\"TZ\"};\n\t$envuser = $ENV{\"USER\"};\n\t$envpath = $ENV{\"PATH\"};\n\t$envlang = $ENV{\"LANG\"};\n\t$envroot = $ENV{\"SystemRoot\"};\n\t$envperllib = $ENV{'PERLLIB'};\n\tforeach my $k (keys %ENV) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t$ENV{\"PATH\"} = $envpath if ($envpath);\n\t$ENV{\"TZ\"} = $envtz if ($envtz);\n\t$ENV{\"USER\"} = $envuser if ($envuser);\n\t$ENV{\"OLD_LANG\"} = $envlang if ($envlang);\n\t$ENV{\"SystemRoot\"} = $envroot if ($envroot);\n\t$ENV{'PERLLIB'} = $envperllib if ($envperllib);\n\t$ENV{\"HOME\"} = $user_homedir;\n\t$ENV{\"SERVER_SOFTWARE\"} = $config{\"server\"};\n\t$ENV{\"SERVER_ADMIN\"} = $config{\"email\"};\n\t$root0 = $roots[0];\n\t$ENV{\"SERVER_ROOT\"} = $root0;\n\t$ENV{\"SERVER_REALROOT\"} = $root0;\n\t$ENV{\"SERVER_PORT\"} = $config{'port'};\n\t$ENV{\"WEBMIN_CRON\"} = 1;\n\t$ENV{\"DOCUMENT_ROOT\"} = $root0;\n\t$ENV{\"THEME_ROOT\"} = \"$root0/\" .\n\t                     ($config{\"preroot_$ENV{'REMOTE_USER'}\"} ||\n\t                      $config{\"preroot\"});\n\t$ENV{\"DOCUMENT_REALROOT\"} = $root0;\n\t$ENV{\"MINISERV_CONFIG\"} = $config_file;\n\t$ENV{\"HTTPS\"} = \"ON\" if ($use_ssl);\n\t$ENV{\"MINISERV_PID\"} = $miniserv_main_pid;\n\t$ENV{\"SCRIPT_FILENAME\"} = $cmd;\n\tif ($ENV{\"SCRIPT_FILENAME\"} =~ /^\\Q$root0\\E(\\/.*)$/) {\n\t\t$ENV{\"SCRIPT_NAME\"} = $1;\n\t\t}\n\t$cmd =~ /^(.*)\\//;\n\t$ENV{\"PWD\"} = $1;\n\tforeach $k (keys %config) {\n\t\tif ($k =~ /^env_(\\S+)$/) {\n\t\t\t$ENV{$1} = $config{$k};\n\t\t\t}\n\t\t}\n\tchdir($ENV{\"PWD\"});\n\t$SIG{'CHLD'} = 'DEFAULT';\n\teval {\n\t\t# Have SOCK closed if the perl exec's something\n\t\tuse Fcntl;\n\t\tfcntl(SOCK, F_SETFD, FD_CLOEXEC);\n\t\t};\n\n\t# Run the wrapper script by evaling it\n\tif ($cmd =~ /\\/([^\\/]+)\\/([^\\/]+)$/) {\n\t\t$pkg = $1;\n\t\t}\n\t$0 = $cmd;\n\t@ARGV = @$argv;\n\t$main_process_id = $$;\n\teval \"\n\t\t\\%pkg::ENV = \\%ENV;\n\t\tpackage $pkg;\n\t\tdo \\\"$cmd\\\";\n\t\tdie \\$@ if (\\$@);\n\t\t\";\n\tif ($@) {\n\t\tprint STDERR \"Perl failure : $@\\n\";\n\t\t}\n\texit(0);\n\t}\nreturn $pid;\n}\n\n# canonicalize_ip6(address)\n# Converts an address to its full long form. Ie. 2001:db8:0:f101::20 to\n# 2001:0db8:0000:f101:0000:0000:0000:0020\nsub canonicalize_ip6\n{\nmy ($addr) = @_;\nreturn $addr if (!&check_ip6address($addr));\nmy @w = split(/:/, $addr);\nmy $idx = &indexof(\"\", @w);\nif ($idx >= 0) {\n\t# Expand ::\n\tmy $mis = 8 - scalar(@w);\n\tmy @nw = @w[0..$idx];\n\tfor(my $i=0; $i<$mis; $i++) {\n\t\tpush(@nw, 0);\n\t\t}\n\tpush(@nw, @w[$idx+1 .. $#w]);\n\t@w = @nw;\n\t}\nforeach my $w (@w) {\n\twhile(length($w) < 4) {\n\t\t$w = \"0\".$w;\n\t\t}\n\t}\nreturn lc(join(\":\", @w));\n}\n\n# expand_ipv6_bytes(address)\n# Given a canonical IPv6 address, split it into an array of bytes\nsub expand_ipv6_bytes\n{\nmy ($addr) = @_;\nmy @rv;\nforeach my $w (split(/:/, $addr)) {\n\t$w =~ /^(..)(..)$/ || return ( );\n\tpush(@rv, hex($1), hex($2));\n\t}\nreturn @rv;\n}\n\nsub get_somaxconn\n{\nreturn defined(&SOMAXCONN) ? SOMAXCONN : 128;\n}\n\nsub is_bad_header\n{\nmy ($value, $name) = @_;\nreturn $value =~ /^\\s*\\(\\s*\\)\\s*\\{/ ? 1 : 0;\n}\n\n# sysread_line(fh)\n# Read a line from a file handle, using sysread to get a byte at a time\nsub sysread_line\n{\nlocal ($fh) = @_;\nlocal $line;\nwhile(1) {\n\tlocal ($buf, $got);\n\t$got = sysread($fh, $buf, 1);\n\tlast if ($got <= 0);\n\t$line .= $buf;\n\tlast if ($buf eq \"\\n\");\n\t}\nreturn $line;\n}\n\nsub getenv\n{\n    my ($key) = @_;\n    return $ENV{ uc($key) } || $ENV{ lc($key) };\n}\n", "# ping-monitor.pl\n# Ping some host\n# Contains code ripped from Net::Ping by Russell Mosemann\n\nuse Socket;\n\nsub get_ping_status\n{\nlocal $wait = defined($_[0]->{'wait'}) ? $_[0]->{'wait'} : 5;\nlocal $ip = &to_ipaddress($_[0]->{'host'}) ||\n\t    &to_ip6address($_[0]->{'host'});\nreturn { 'up' => 0 } if (!$ip);\nlocal $ipv6 = &check_ip6address($_[0]->{'host'}) ||\n\t      &to_ip6address($_[0]->{'host'}) &&\n\t      !&to_ipaddress($_[0]->{'host'});\nif ($config{'pinger'} || $ipv6) {\n\t# Call a ping command if configured, or if using IPv6 since the built-\n\t# in code doesn't support it yet\n\tlocal $cmd;\n\tlocal $auto_pinger = $config{'pinger'} eq \"linux\" || !$config{'pinger'};\n\tif ($auto_pinger && $gconfig{'os_type'} =~ /-linux$/) {\n\t\t# Use linux command\n\t\t$cmd = ($ipv6 ? \"ping6\" : \"ping\").\" -c 1 -w $wait\";\n\t\t}\n\telsif ($auto_pinger && $gconfig{'os_type'} eq 'freebsd') {\n\t\t# Use FreeBSD command\n\t\t$cmd = ($ipv6 ? \"ping6\" : \"ping\").\" -c 1 -W \".($wait * 1000);\n\t\t}\n\telsif ($auto_pinger) {\n\t\t# Don't know command for this OS\n\t\treturn { 'up' => - 1 };\n\t\t}\n\telse {\n\t\t$cmd = $config{'pinger'};\n\t\t}\n\tlocal $rv;\n\teval {\n\t\tlocal $sig{'ALRM'} = sub { die \"timeout\" };\n\t\talarm($wait + 1);\n\t\t$rv = system(\"$cmd \".quotemeta($_[0]->{'host'}).\n\t\t\t     \" >/dev/null 2>&1 </dev/null\");\n\t\talarm(0);\n\t\t};\n\tif ($@) {\n\t\treturn { 'up' => 0 };\n\t\t}\n\telse {\n\t\treturn { 'up' => $rv ? 0 : 1 };\n\t\t}\n\t}\nelse {\n\t# Use builtin code\n\tlocal $rv = &ping_icmp(inet_aton($ip), $wait);\n\treturn { 'up' => $rv ? 1 : 0 };\n\t}\n}\n\nsub show_ping_dialog\n{\nprint &ui_table_row($text{'ping_host'},\n\t&ui_textbox(\"host\", $_[0]->{'host'}, 50), 3);\n\nprint &ui_table_row($text{'ping_wait'},\n\t&ui_textbox(\"wait\", defined($_[0]->{'wait'}) ? $_[0]->{'wait'} : 5, 6).\n\t\" \".$text{'oldfile_secs'});\n}\n\nsub parse_ping_dialog\n{\n#$config{'ping_cmd'} || &error($text{'ping_econfig'});\n&to_ipaddress($in{'host'}) || &to_ip6address($in{'host'}) ||\n\t&error($text{'ping_ehost'});\n$in{'wait'} =~ /^(\\d*\\.)?\\d+$/ || &error($text{'ping_ewait'});\n$_[0]->{'host'} = $in{'host'};\n$_[0]->{'wait'} = $in{'wait'};\n}\n\nsub ping_icmp\n{\n    my ($ip,                # Packed IP number of the host\n        $timeout            # Seconds after which ping times out\n        ) = @_;\n\n    my $ICMP_ECHOREPLY = 0; # ICMP packet types\n    my $ICMP_ECHO = 8;\n    my $icmp_struct = \"C2 S3 A\";  # Structure of a minimal ICMP packet\n    my $subcode = 0;        # No ICMP subcode for ECHO and ECHOREPLY\n    my $flags = 0;          # No special flags when opening a socket\n    my $port = 0;           # No port with ICMP\n\n    my ($saddr,             # sockaddr_in with port and ip\n        $checksum,          # Checksum of ICMP packet\n        $msg,               # ICMP packet to send\n        $len_msg,           # Length of $msg\n        $rbits,             # Read bits, filehandles for reading\n        $nfound,            # Number of ready filehandles found\n        $finish_time,       # Time ping should be finished\n        $done,              # set to 1 when we are done\n        $ret,               # Return value\n        $recv_msg,          # Received message including IP header\n        $from_saddr,        # sockaddr_in of sender\n        $from_port,         # Port packet was sent from\n        $from_ip,           # Packed IP of sender\n        $from_type,         # ICMP type\n        $from_subcode,      # ICMP subcode\n        $from_chk,          # ICMP packet checksum\n        $from_pid,          # ICMP packet id\n        $from_seq,          # ICMP packet sequence\n        $from_msg,           # ICMP message\n\t$data,\n\t$cnt,\n\t$data_size\n        );\n\n    # Construct packet data string\n    $data_size = 0;\n    for ($cnt = 0; $cnt < $data_size; $cnt++)\n    {\n        $data .= chr($cnt % 256);\n    }\n\n    my $proto_num = (getprotobyname('icmp'))[2];\n    socket(PSOCK, PF_INET, SOCK_RAW, $proto_num);\n\n    $ping_seq = ($ping_seq + 1) % 65536; # Increment sequence\n    $checksum = 0;                          # No checksum for starters\n    $msg = pack($icmp_struct . $data_size, $ICMP_ECHO, $subcode,\n                $checksum, $$, $ping_seq, $data);\n    $checksum = checksum($msg);\n    $msg = pack($icmp_struct . $data_size, $ICMP_ECHO, $subcode,\n                $checksum, $$, $ping_seq, $data);\n    $len_msg = length($msg);\n    $saddr = pack_sockaddr_in($port, $ip);\n    send(PSOCK, $msg, $flags, $saddr); # Send the message\n\n    $rbits = \"\";\n    vec($rbits, fileno(PSOCK), 1) = 1;\n    $ret = 0;\n    $done = 0;\n    $finish_time = time() + $timeout;       # Must be done by this time\n    while (!$done && $timeout > 0)          # Keep trying if we have time\n    {\n        $nfound = select($rbits, undef, undef, $timeout); # Wait for packet\n        $timeout = $finish_time - time();   # Get remaining time\n        if (!defined($nfound))              # Hmm, a strange error\n        {\n\t    # Probably an interrupted system call, so try again\n            $ret = undef;\n            #$done = 1;\n        }\n        elsif ($nfound)                     # Got a packet from somewhere\n        {\n            $recv_msg = \"\";\n            $from_saddr = recv(PSOCK, $recv_msg, 1500, $flags);\n\t    if ($from_saddr) {\n\t\t    ($from_port, $from_ip) = unpack_sockaddr_in($from_saddr);\n\t\t    ($from_type, $from_subcode, $from_chk,\n\t\t     $from_pid, $from_seq, $from_msg) =\n\t\t\tunpack($icmp_struct . $data_size,\n\t\t\t       substr($recv_msg, length($recv_msg) - $len_msg,\n\t\t\t\t      $len_msg));\n\t\t    if (($from_type == $ICMP_ECHOREPLY) &&\n\t\t\t($from_ip eq $ip) &&\n\t\t\t($from_pid == $$) && # Does the packet check out?\n\t\t\t($from_seq == $ping_seq))\n\t\t    {\n\t\t\t$ret = 1;                   # It's a winner\n\t\t\t$done = 1;\n\t\t    }\n\t     } else {\n\t\t    # Packet not actually received\n\t\t    $ret = undef;\n\t     }\n        }\n        else                                # Oops, timed out\n        {\n            $done = 1;\n        }\n    }\n    close(PSOCK);\n    return($ret)\n}\n\n# Description:  Do a checksum on the message.  Basically sum all of\n# the short words and fold the high order bits into the low order bits.\n\nsub checksum\n{\n    my ($msg            # The message to checksum\n        ) = @_;\n    my ($len_msg,       # Length of the message\n        $num_short,     # The number of short words in the message\n        $short,         # One short word\n        $chk            # The checksum\n        );\n\n    $len_msg = length($msg);\n    $num_short = $len_msg / 2;\n    $chk = 0;\n    foreach $short (unpack(\"S$num_short\", $msg))\n    {\n        $chk += $short;\n    }                                           # Add the odd byte in\n    $chk += unpack(\"C\", substr($msg, $len_msg - 1, 1)) if $len_msg % 2;\n    $chk = ($chk >> 16) + ($chk & 0xffff);      # Fold high into low\n    return(~(($chk >> 16) + $chk) & 0xffff);    # Again and complement\n}\n\n\n"], "filenames": ["miniserv.pl", "status/ping-monitor.pl"], "buggy_code_start_loc": [2606, 13], "buggy_code_end_loc": [2608, 14], "fixing_code_start_loc": [2606, 13], "fixing_code_end_loc": [2609, 15], "type": "NVD-CWE-noinfo", "message": "miniserv.pl in Webmin 1.962 on Windows mishandles special characters in query arguments to the CGI program.", "other": {"cve": {"id": "CVE-2020-35769", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-29T06:15:13.773", "lastModified": "2022-07-17T12:47:53.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "miniserv.pl in Webmin 1.962 on Windows mishandles special characters in query arguments to the CGI program."}, {"lang": "es", "value": "El archivo miniserv.pl en Webmin versi\u00f3n 1.962 en Windows, maneja inapropiadamente unos caracteres especiales en los argumentos de consulta para el programa CGI"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.962:*:*:*:*:*:*:*", "matchCriteriaId": "89E73E98-9324-4DC9-8A7E-4A06D8C3A686"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/webmin/webmin/commit/1163f3a7f418f249af64890f4636575e687e9de7#diff-9b33fd8f5603d4f0d1428689bc36f24af4770608a22c0d92b7a8bcc522450dc6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vigilance.fr/vulnerability/Webmin-code-execution-via-miniserv-pl-handle-request-34220", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webmin/webmin/commit/1163f3a7f418f249af64890f4636575e687e9de7#diff-9b33fd8f5603d4f0d1428689bc36f24af4770608a22c0d92b7a8bcc522450dc6"}}