{"buggy_code": ["#pragma once\n\n#include \"IR/Module.h\"\n#include \"IR/Validate.h\"\n#include \"Inline/BasicTypes.h\"\n#include \"Inline/Floats.h\"\n#include \"Inline/Timing.h\"\n#include \"Platform/File.h\"\n#include \"Runtime/Runtime.h\"\n#include \"WASM/WASM.h\"\n#include \"WASTParse/WASTParse.h\"\n\n#include <vector>\n\ninline bool loadFile(const char* filename, std::vector<U8>& outFileContents)\n{\n\tPlatform::File* file = Platform::openFile(\n\t\tfilename, Platform::FileAccessMode::readOnly, Platform::FileCreateMode::openExisting);\n\tif(!file)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't read %s: couldn't open file.\\n\", filename);\n\t\treturn false;\n\t}\n\n\tU64 numFileBytes = 0;\n\terrorUnless(Platform::seekFile(file, 0, Platform::FileSeekOrigin::end, &numFileBytes));\n\tif(numFileBytes > UINTPTR_MAX)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't read %s: file is too large.\\n\", filename);\n\t\terrorUnless(Platform::closeFile(file));\n\t\treturn false;\n\t}\n\n\tstd::vector<U8> fileContents;\n\toutFileContents.resize(numFileBytes);\n\terrorUnless(Platform::seekFile(file, 0, Platform::FileSeekOrigin::begin));\n\terrorUnless(Platform::readFile(file, const_cast<U8*>(outFileContents.data()), numFileBytes));\n\terrorUnless(Platform::closeFile(file));\n\n\treturn true;\n}\n\ninline bool saveFile(const char* filename, const void* fileBytes, Uptr numFileBytes)\n{\n\tPlatform::File* file = Platform::openFile(\n\t\tfilename, Platform::FileAccessMode::writeOnly, Platform::FileCreateMode::createAlways);\n\tif(!file)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't write %s: couldn't open file.\\n\", filename);\n\t\treturn false;\n\t}\n\n\terrorUnless(Platform::writeFile(file, fileBytes, numFileBytes));\n\terrorUnless(Platform::closeFile(file));\n\n\treturn true;\n}\n\ninline void reportParseErrors(const char* filename, const std::vector<WAST::Error>& parseErrors)\n{\n\t// Print any parse errors.\n\tfor(auto& error : parseErrors)\n\t{\n\t\tLog::printf(Log::error,\n\t\t\t\t\t\"%s:%s: %s\\n%s\\n%*s\\n\",\n\t\t\t\t\tfilename,\n\t\t\t\t\terror.locus.describe().c_str(),\n\t\t\t\t\terror.message.c_str(),\n\t\t\t\t\terror.locus.sourceLine.c_str(),\n\t\t\t\t\terror.locus.column(8),\n\t\t\t\t\t\"^\");\n\t}\n}\n\ninline bool loadTextModuleFromFile(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> wastBytes;\n\tif(!loadFile(filename, wastBytes)) { return false; }\n\n\t// Make sure the WAST is null terminated.\n\twastBytes.push_back(0);\n\n\tstd::vector<WAST::Error> parseErrors;\n\tif(WAST::parseModule((const char*)wastBytes.data(), wastBytes.size(), outModule, parseErrors))\n\t{ return true; }\n\telse\n\t{\n\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\treportParseErrors(filename, parseErrors);\n\t\treturn false;\n\t}\n}\n\ninline bool loadBinaryModule(const void* wasmBytes,\n\t\t\t\t\t\t\t Uptr numBytes,\n\t\t\t\t\t\t\t IR::Module& outModule,\n\t\t\t\t\t\t\t Log::Category errorCategory = Log::error)\n{\n\t// Load the module from a binary WebAssembly file.\n\ttry\n\t{\n\t\tTiming::Timer loadTimer;\n\n\t\tSerialization::MemoryInputStream stream((const U8*)wasmBytes, numBytes);\n\t\tWASM::serialize(stream, outModule);\n\n\t\tTiming::logRatePerSecond(\"Loaded WASM\", loadTimer, numBytes / 1024.0 / 1024.0, \"MB\");\n\t\treturn true;\n\t}\n\tcatch(Serialization::FatalSerializationException exception)\n\t{\n\t\tLog::printf(errorCategory,\n\t\t\t\t\t\"Error deserializing WebAssembly binary file:\\n%s\\n\",\n\t\t\t\t\texception.message.c_str());\n\t\treturn false;\n\t}\n\tcatch(IR::ValidationException exception)\n\t{\n\t\tLog::printf(errorCategory,\n\t\t\t\t\t\"Error validating WebAssembly binary file:\\n%s\\n\",\n\t\t\t\t\texception.message.c_str());\n\t\treturn false;\n\t}\n\tcatch(std::bad_alloc)\n\t{\n\t\tLog::printf(errorCategory, \"Memory allocation failed: input is likely malformed\\n\");\n\t\treturn false;\n\t}\n}\n\ninline bool loadBinaryModuleFromFile(const char* filename,\n\t\t\t\t\t\t\t\t\t IR::Module& outModule,\n\t\t\t\t\t\t\t\t\t Log::Category errorCategory = Log::error)\n{\n\tstd::vector<U8> wasmBytes;\n\tif(!loadFile(filename, wasmBytes)) { return false; }\n\treturn loadBinaryModule(wasmBytes.data(), wasmBytes.size(), outModule);\n}\n\ninline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\t// Read the specified file into an array.\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\n\t// If the file starts with the WASM binary magic number, load it as a binary irModule.\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\t// Make sure the WAST file is null terminated.\n\t\tfileBytes.push_back(0);\n\n\t\t// Load it as a text irModule.\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"], "fixing_code": ["#pragma once\n\n#include \"IR/Module.h\"\n#include \"IR/Validate.h\"\n#include \"Inline/BasicTypes.h\"\n#include \"Inline/Floats.h\"\n#include \"Inline/Timing.h\"\n#include \"Platform/File.h\"\n#include \"Runtime/Runtime.h\"\n#include \"WASM/WASM.h\"\n#include \"WASTParse/WASTParse.h\"\n\n#include <vector>\n\ninline bool loadFile(const char* filename, std::vector<U8>& outFileContents)\n{\n\tPlatform::File* file = Platform::openFile(\n\t\tfilename, Platform::FileAccessMode::readOnly, Platform::FileCreateMode::openExisting);\n\tif(!file)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't read %s: couldn't open file.\\n\", filename);\n\t\treturn false;\n\t}\n\n\tU64 numFileBytes = 0;\n\terrorUnless(Platform::seekFile(file, 0, Platform::FileSeekOrigin::end, &numFileBytes));\n\tif(numFileBytes > UINTPTR_MAX)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't read %s: file is too large.\\n\", filename);\n\t\terrorUnless(Platform::closeFile(file));\n\t\treturn false;\n\t}\n\n\tstd::vector<U8> fileContents;\n\toutFileContents.resize(numFileBytes);\n\terrorUnless(Platform::seekFile(file, 0, Platform::FileSeekOrigin::begin));\n\terrorUnless(Platform::readFile(file, const_cast<U8*>(outFileContents.data()), numFileBytes));\n\terrorUnless(Platform::closeFile(file));\n\n\treturn true;\n}\n\ninline bool saveFile(const char* filename, const void* fileBytes, Uptr numFileBytes)\n{\n\tPlatform::File* file = Platform::openFile(\n\t\tfilename, Platform::FileAccessMode::writeOnly, Platform::FileCreateMode::createAlways);\n\tif(!file)\n\t{\n\t\tLog::printf(Log::error, \"Couldn't write %s: couldn't open file.\\n\", filename);\n\t\treturn false;\n\t}\n\n\terrorUnless(Platform::writeFile(file, fileBytes, numFileBytes));\n\terrorUnless(Platform::closeFile(file));\n\n\treturn true;\n}\n\ninline void reportParseErrors(const char* filename, const std::vector<WAST::Error>& parseErrors)\n{\n\t// Print any parse errors.\n\tfor(auto& error : parseErrors)\n\t{\n\t\tLog::printf(Log::error,\n\t\t\t\t\t\"%s:%s: %s\\n%s\\n%*s\\n\",\n\t\t\t\t\tfilename,\n\t\t\t\t\terror.locus.describe().c_str(),\n\t\t\t\t\terror.message.c_str(),\n\t\t\t\t\terror.locus.sourceLine.c_str(),\n\t\t\t\t\terror.locus.column(8),\n\t\t\t\t\t\"^\");\n\t}\n}\n\ninline bool loadTextModuleFromFile(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> wastBytes;\n\tif(!loadFile(filename, wastBytes)) { return false; }\n\n\t// Make sure the WAST is null terminated.\n\twastBytes.push_back(0);\n\n\tstd::vector<WAST::Error> parseErrors;\n\tif(WAST::parseModule((const char*)wastBytes.data(), wastBytes.size(), outModule, parseErrors))\n\t{ return true; }\n\telse\n\t{\n\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\treportParseErrors(filename, parseErrors);\n\t\treturn false;\n\t}\n}\n\ninline bool loadBinaryModule(const void* wasmBytes,\n\t\t\t\t\t\t\t Uptr numBytes,\n\t\t\t\t\t\t\t IR::Module& outModule,\n\t\t\t\t\t\t\t Log::Category errorCategory = Log::error)\n{\n\t// Load the module from a binary WebAssembly file.\n\ttry\n\t{\n\t\tTiming::Timer loadTimer;\n\n\t\tSerialization::MemoryInputStream stream((const U8*)wasmBytes, numBytes);\n\t\tWASM::serialize(stream, outModule);\n\n\t\tTiming::logRatePerSecond(\"Loaded WASM\", loadTimer, numBytes / 1024.0 / 1024.0, \"MB\");\n\t\treturn true;\n\t}\n\tcatch(Serialization::FatalSerializationException exception)\n\t{\n\t\tLog::printf(errorCategory,\n\t\t\t\t\t\"Error deserializing WebAssembly binary file:\\n%s\\n\",\n\t\t\t\t\texception.message.c_str());\n\t\treturn false;\n\t}\n\tcatch(IR::ValidationException exception)\n\t{\n\t\tLog::printf(errorCategory,\n\t\t\t\t\t\"Error validating WebAssembly binary file:\\n%s\\n\",\n\t\t\t\t\texception.message.c_str());\n\t\treturn false;\n\t}\n\tcatch(std::bad_alloc)\n\t{\n\t\tLog::printf(errorCategory, \"Memory allocation failed: input is likely malformed\\n\");\n\t\treturn false;\n\t}\n}\n\ninline bool loadBinaryModuleFromFile(const char* filename,\n\t\t\t\t\t\t\t\t\t IR::Module& outModule,\n\t\t\t\t\t\t\t\t\t Log::Category errorCategory = Log::error)\n{\n\tstd::vector<U8> wasmBytes;\n\tif(!loadFile(filename, wasmBytes)) { return false; }\n\treturn loadBinaryModule(wasmBytes.data(), wasmBytes.size(), outModule);\n}\n\ninline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\t// Read the specified file into an array.\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\n\t// If the file starts with the WASM binary magic number, load it as a binary irModule.\n\tif(fileBytes.size() >= 4 && *(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\t// Make sure the WAST file is null terminated.\n\t\tfileBytes.push_back(0);\n\n\t\t// Load it as a text irModule.\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"], "filenames": ["Include/Inline/CLI.h"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [148], "fixing_code_start_loc": [147], "fixing_code_end_loc": [148], "type": "CWE-125", "message": "An issue was discovered in WAVM before 2018-09-16. The loadModule function in Include/Inline/CLI.h lacks checking of the file length before a file magic comparison, allowing attackers to cause a Denial of Service (application crash caused by out-of-bounds read) by crafting a file that has fewer than 4 bytes.", "other": {"cve": {"id": "CVE-2018-17292", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-21T07:29:00.287", "lastModified": "2018-11-21T18:24:25.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in WAVM before 2018-09-16. The loadModule function in Include/Inline/CLI.h lacks checking of the file length before a file magic comparison, allowing attackers to cause a Denial of Service (application crash caused by out-of-bounds read) by crafting a file that has fewer than 4 bytes."}, {"lang": "es", "value": "Se ha descubierto un problema en WAVM en versiones anteriores al 16/09/2018. La funci\u00f3n loadModule en Include/Inline/CLI.h carece de comprobaciones de la longitud de los archivos antes de que se haga una comparaci\u00f3n m\u00e1gica de archivos, permitiendo que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n causado por una lectura fuera de l\u00edmites) creando un archivo que ocupe menos de 4 bytes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webassembly_virtual_machine_project:webassembly_virtual_machine:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-09-16", "matchCriteriaId": "F8DB01B9-1E08-4736-B665-9DD40423C024"}]}]}], "references": [{"url": "https://github.com/WAVM/WAVM/commit/2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/WAVM/WAVM/issues/109", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WAVM/WAVM/commit/2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1"}}