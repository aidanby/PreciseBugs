{"buggy_code": ["import nl.zolotko.sbt.jfr.{JfrRecording, JfrRecorderOptions}\nimport scala.concurrent.duration.DurationInt\n\nval catsVersion            = \"2.10.0\"\nval catsParseVersion       = \"1.0.0\"\nval catsEffectVersion      = \"3.5.2\"\nval circeVersion           = \"0.14.6\"\nval disciplineMunitVersion = \"2.0.0-M3\"\nval doobieVersion          = \"1.0.0-RC5\"\nval flywayVersion          = \"10.3.0\"\nval fs2Version             = \"3.9.3\"\nval http4sVersion          = \"0.23.24\"\nval jnrUnixsocketVersion   = \"0.38.21\"\nval kindProjectorVersion   = \"0.13.2\"\nval literallyVersion       = \"1.1.0\"\nval logbackVersion         = \"1.4.14\"\nval log4catsVersion        = \"2.6.0\"\nval munitVersion           = \"1.0.0-M10\"\nval munitCatsEffectVersion = \"2.0.0-M4\"\nval skunkVersion           = \"0.6.2\"\nval shapeless2Version      = \"2.3.10\"\nval shapeless3Version      = \"3.1.0\"\nval sourcePosVersion       = \"1.1.0\"\nval typenameVersion        = \"1.1.0\"\nval whaleTailVersion       = \"0.0.10\"\n\nval Scala2 = \"2.13.12\"\nval Scala3 = \"3.3.1\"\nThisBuild / scalaVersion        := Scala2\nThisBuild / crossScalaVersions  := Seq(Scala2, Scala3)\nThisBuild / tlJdkRelease        := Some(11)\n\nThisBuild / tlBaseVersion    := \"0.17\"\nThisBuild / startYear        := Some(2019)\nThisBuild / licenses         := Seq(License.Apache2)\nThisBuild / developers       := List(\n  Developer(\"milessabin\", \"Miles Sabin\", \"miles@milessabin.com\", url(\"http://milessabin.com/blog\")),\n  Developer(\"tpolecat\",   \"Rob Norris\",  \"rnorris@gemini.edu\",   url(\"http://www.tpolecat.org\")),\n)\n\nThisBuild / tlCiScalafmtCheck       := false\nThisBuild / tlCiReleaseBranches     := Seq(\"main\")\nThisBuild / tlSonatypeUseLegacyHost := false\nThisBuild / githubWorkflowBuild     ~= { steps =>\n  WorkflowStep.Sbt(\n    commands = List(\"headerCheckAll\"),\n    name = Some(\"Check Headers\"),\n  ) +: steps\n}\nThisBuild / githubWorkflowJavaVersions := Seq(JavaSpec.temurin(\"11\"))\nThisBuild / tlBspCrossProjectPlatforms := Set(JVMPlatform)\n\nThisBuild / githubWorkflowAddedJobs +=\n  WorkflowJob(\n    id = \"coverage\",\n    name = s\"Generate coverage report (2.13 JVM only)\",\n    scalas = Nil,\n    sbtStepPreamble = Nil,\n    steps = githubWorkflowJobSetup.value.toList ++\n      List(\n        WorkflowStep.Sbt(List(\"coverage\", \"rootJVM/test\", \"coverageReport\")),\n        WorkflowStep.Use(UseRef.Public(\"codecov\", \"codecov-action\", \"v3\"))\n      )\n  )\n\n\nThisBuild / tlSitePublishBranch := Some(\"main\")\n\nlazy val commonSettings = Seq(\n  //scalacOptions --= Seq(\"-Wunused:params\", \"-Wunused:imports\", \"-Wunused:patvars\", \"-Wdead-code\", \"-Wunused:locals\", \"-Wunused:privates\", \"-Wunused:implicits\"),\n  libraryDependencies ++= Seq(\n    \"org.scalameta\" %%% \"munit\"             % munitVersion % \"test\",\n    \"org.scalameta\" %%% \"munit-scalacheck\"  % munitVersion % \"test\",\n    \"org.typelevel\" %%% \"cats-laws\"         % catsVersion % \"test\",\n    \"org.typelevel\" %%% \"discipline-munit\"  % disciplineMunitVersion % \"test\",\n    \"org.typelevel\" %%% \"munit-cats-effect\" % munitCatsEffectVersion % \"test\",\n    \"io.circe\"      %%% \"circe-literal\"     % circeVersion % \"test\",\n    \"io.circe\"      %%% \"circe-jawn\"        % circeVersion % \"test\",\n  ) ++ Seq(\n    compilerPlugin(\"org.typelevel\" %% \"kind-projector\" % kindProjectorVersion cross CrossVersion.full),\n  ).filterNot(_ => tlIsScala3.value),\n  headerMappings := headerMappings.value + (HeaderFileType.scala -> HeaderCommentStyle.cppStyleLineComment),\n  headerLicense  := Some(HeaderLicense.Custom(\n    \"\"\"|Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n       |Copyright (c) 2016-2023 Grackle Contributors\n       |\n       |Licensed under the Apache License, Version 2.0 (the \"License\");\n       |you may not use this file except in compliance with the License.\n       |You may obtain a copy of the License at\n       |\n       |  http://www.apache.org/licenses/LICENSE-2.0\n       |\n       |Unless required by applicable law or agreed to in writing, software\n       |distributed under the License is distributed on an \"AS IS\" BASIS,\n       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n       |See the License for the specific language governing permissions and\n       |limitations under the License.\n       |\"\"\".stripMargin\n  ))\n)\n\nlazy val modules: List[CompositeProject] = List(\n  core,\n  circe,\n  sql,\n  doobie,\n  skunk,\n  generic,\n  docs,\n  unidocs,\n  demo,\n  benchmarks,\n  profile\n)\n\nlazy val root = tlCrossRootProject\n  .aggregate(modules:_*)\n  .disablePlugins(RevolverPlugin)\n\nlazy val core = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/core\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-core\",\n    libraryDependencies ++=\n      Seq(\n        \"org.typelevel\" %%% \"cats-parse\"   % catsParseVersion,\n        \"org.typelevel\" %%% \"cats-core\"    % catsVersion,\n        \"org.typelevel\" %%% \"literally\"    % literallyVersion,\n        \"io.circe\"      %%% \"circe-core\"   % circeVersion,\n        \"org.tpolecat\"  %%% \"typename\"     % typenameVersion,\n        \"org.tpolecat\"  %%% \"sourcepos\"    % sourcePosVersion,\n        \"co.fs2\"        %%% \"fs2-core\"     % fs2Version,\n      )\n  )\n  .jsSettings(\n    libraryDependencies += \"io.github.cquiroz\" %%% \"scala-java-time\" % \"2.5.0\",\n    scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.CommonJSModule))\n  )\n\nlazy val circe = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/circe\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-circe\",\n  )\n\nlazy val buildInfo = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/build-info\"))\n  .enablePlugins(BuildInfoPlugin, NoPublishPlugin)\n  .settings(commonSettings)\n  .settings(\n    buildInfoKeys += \"baseDirectory\" -> (LocalRootProject / baseDirectory).value.toString\n  )\n\nlazy val sql = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Full)\n  .in(file(\"modules/sql\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core % \"test->test;compile->compile\", circe, buildInfo % Test)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-sql\",\n    libraryDependencies ++= Seq(\n      \"io.circe\"          %%% \"circe-generic\"      % circeVersion % \"test\",\n      \"co.fs2\"            %%% \"fs2-io\"             % fs2Version % \"test\",\n    )\n  )\n  .platformsSettings(JVMPlatform, JSPlatform)(\n    libraryDependencies ++= Seq(\n      \"io.chrisdavenport\" %%% \"whale-tail-manager\" % whaleTailVersion % \"test\",\n    )\n  )\n  .jvmSettings(\n    libraryDependencies ++= Seq(\n      \"com.github.jnr\"    % \"jnr-unixsocket\"      % jnrUnixsocketVersion % \"test\"\n    )\n  )\n\nlazy val doobie = project\n  .in(file(\"modules/doobie-pg\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(sql.jvm % \"test->test;compile->compile\", circe.jvm)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-doobie-pg\",\n    Test / fork := true,\n    Test / parallelExecution := false,\n    libraryDependencies ++= Seq(\n      \"org.tpolecat\"   %% \"doobie-core\"           % doobieVersion,\n      \"org.tpolecat\"   %% \"doobie-postgres-circe\" % doobieVersion,\n      \"org.typelevel\"  %% \"log4cats-core\"         % log4catsVersion,\n      \"ch.qos.logback\" %  \"logback-classic\"       % logbackVersion % \"test\"\n    )\n  )\n\nlazy val skunk = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Full)\n  .in(file(\"modules/skunk\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(sql % \"test->test;compile->compile\", circe)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-skunk\",\n    Test / parallelExecution := false,\n    libraryDependencies ++= Seq(\n      \"org.tpolecat\" %%% \"skunk-core\"  % skunkVersion,\n      \"org.tpolecat\" %%% \"skunk-circe\" % skunkVersion,\n    )\n  )\n  .jvmSettings(\n    Test / fork := true\n  )\n  .jsSettings(\n    scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.CommonJSModule))\n  )\n\nlazy val generic = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/generic\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-generic\",\n    libraryDependencies += (\n      scalaVersion.value match {\n        case Scala3 => \"org.typelevel\" %%% \"shapeless3-deriving\" % shapeless3Version\n        case Scala2 => \"com.chuusai\"   %%% \"shapeless\"           % shapeless2Version\n      })\n  )\n\nlazy val demo = project\n  .in(file(\"demo\"))\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin)\n  .dependsOn(core.jvm, generic.jvm, doobie)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-demo\",\n    coverageEnabled := false,\n    libraryDependencies ++= Seq(\n      \"org.typelevel\"     %% \"log4cats-slf4j\"             % log4catsVersion,\n      \"ch.qos.logback\"    %  \"logback-classic\"            % logbackVersion,\n      \"org.tpolecat\"      %% \"doobie-core\"                % doobieVersion,\n      \"org.tpolecat\"      %% \"doobie-postgres\"            % doobieVersion,\n      \"org.tpolecat\"      %% \"doobie-hikari\"              % doobieVersion,\n      \"org.http4s\"        %% \"http4s-ember-server\"        % http4sVersion,\n      \"org.http4s\"        %% \"http4s-ember-client\"        % http4sVersion,\n      \"org.http4s\"        %% \"http4s-circe\"               % http4sVersion,\n      \"org.http4s\"        %% \"http4s-dsl\"                 % http4sVersion,\n      \"org.flywaydb\"      %  \"flyway-database-postgresql\" % flywayVersion,\n      \"io.chrisdavenport\" %% \"whale-tail-manager\"         % whaleTailVersion,\n      \"com.github.jnr\"    % \"jnr-unixsocket\"              % jnrUnixsocketVersion\n    )\n  )\n\nlazy val benchmarks = project\n  .in(file(\"benchmarks\"))\n  .dependsOn(core.jvm)\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin, JmhPlugin)\n  .settings(commonSettings)\n  .settings(    \n    coverageEnabled := false,\n)\n\nlazy val profile = project\n  .in(file(\"profile\"))\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin)\n  .dependsOn(core.jvm)\n  .dependsOn(doobie)\n  .settings(commonSettings)\n  .settings(\n    jfrRecordings := Seq(\n      JfrRecording(\n        fileName = file(\"profile.jfr\").toPath.some,\n        name = \"profile\".some,\n        delay = 5.seconds.some,\n        disk = true.some,\n        dumpOnExit = true.some,\n        duration = 30.seconds.some,\n        pathToGcRoots = true.some,\n      )\n    ),\n    fork := true,\n    coverageEnabled := false,\n  )\n\nlazy val docs = project\n  .in(file(\"modules/docs\"))\n  .enablePlugins(TypelevelSitePlugin, AutomateHeaderPlugin)\n  .settings(commonSettings)\n  .settings(\n    mdocVariables ++= Map(\"headerVariant\" -> \"tutorial\"),\n    libraryDependencies ++= Seq(\n      \"org.typelevel\" %% \"cats-effect\" % catsEffectVersion\n    ),\n    coverageEnabled := false,\n  )\n\n// Run repoDocs / mdoc manually to generated README.md from docs/index.md and header.md\nlazy val repoDocs = project\n  .in(file(\"repo-docs\"))\n  .dependsOn(core.jvm, docs)\n  .enablePlugins(MdocPlugin, NoPublishPlugin)\n  .settings(\n    mdocVariables :=\n      Map(\n        \"VERSION\"       -> tlLatestVersion.value.getOrElse(version.value),\n        \"headerVariant\" -> \"repo\"\n        ),\n    mdocIn  := file(\"docs/index.md\"),\n    mdocOut := file(\"README.md\"),\n    coverageEnabled := false,\n  )\n\nlazy val unidocs = project\n  .in(file(\"unidocs\"))\n  .enablePlugins(TypelevelUnidocPlugin)\n  .settings(\n    name := \"grackle-docs\",\n    coverageEnabled := false,\n    ScalaUnidoc / unidoc / unidocProjectFilter := inProjects(\n      core.jvm,\n      circe.jvm,\n      sql.jvm,\n      doobie,\n      skunk.jvm,\n      generic.jvm,\n    )\n  )\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.data.NonEmptyChain\nimport cats.syntax.all._\nimport org.typelevel.literally.Literally\nimport grackle.Ast.Document\nimport grackle.GraphQLParser.Document.parseAll\nimport grackle.Schema\n\ntrait VersionSpecificSyntax {\n  implicit def toStringContextOps(sc: StringContext): StringContextOps =\n    new StringContextOps(sc)\n}\n\nclass StringContextOps(val sc: StringContext) extends AnyVal {\n  def schema(args: Any*): Schema = macro SchemaLiteral.make\n  def doc(args: Any*): Document = macro DocumentLiteral.make\n}\n\nobject SchemaLiteral extends Literally[Schema] {\n  def validate(c: Context)(s: String): Either[String,c.Expr[Schema]] = {\n    import c.universe._\n    def mkError(err: Either[Throwable, NonEmptyChain[Problem]]) =\n      err.fold(\n        t  => s\"Internal error: ${t.getMessage}\",\n        ps => s\"Invalid schema: ${ps.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n      )\n    Schema(s).toEither.bimap(mkError, _ => c.Expr(q\"_root_.grackle.Schema($s).toOption.get\"))\n  }\n  def make(c: Context)(args: c.Expr[Any]*): c.Expr[Schema] = apply(c)(args: _*)\n}\n\nobject DocumentLiteral extends Literally[Document] {\n  def validate(c: Context)(s: String): Either[String,c.Expr[Document]] = {\n    import c.universe._\n    parseAll(s).bimap(\n      pf => show\"Invalid document: $pf\",\n      _  => c.Expr(q\"_root_.grackle.GraphQLParser.Document.parseAll($s).toOption.get\"),\n    )\n  }\n  def make(c: Context)(args: c.Expr[Any]*): c.Expr[Document] = apply(c)(args: _*)\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.syntax.all._\nimport org.typelevel.literally.Literally\nimport grackle.Ast.Document\nimport grackle.GraphQLParser.Document.parseAll\n\ntrait VersionSpecificSyntax:\n\n  extension (inline ctx: StringContext)\n    inline def schema(inline args: Any*): Schema = ${SchemaLiteral('ctx, 'args)}\n    inline def doc(inline args: Any*): Document = ${ DocumentLiteral('ctx, 'args) }\n\nobject SchemaLiteral extends Literally[Schema]:\n  def validate(s: String)(using Quotes) =\n    Schema(s).toEither.bimap(\n      nec => s\"Invalid schema:${nec.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n      _   => '{Schema(${Expr(s)}).toOption.get}\n    )\n\nobject DocumentLiteral extends Literally[Document]:\n  def validate(s: String)(using Quotes) =\n    parseAll(s).bimap(\n      pf => show\"Invalid document: $pf\",\n      _ => '{parseAll(${Expr(s)}).toOption.get}\n    )\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport scala.annotation.tailrec\nimport scala.reflect.ClassTag\n\nimport cats.data.StateT\nimport cats.implicits._\nimport io.circe.Json\nimport org.tpolecat.typename.{ TypeName, typeName }\n\nimport syntax._\nimport Query._, Predicate._, Value._, UntypedOperation._\nimport QueryCompiler._\nimport ScalarType._\n\n/**\n * GraphQL query parser\n */\nobject QueryParser {\n  import Ast.{ Directive => _, Type => _, Value => _, _ }, OperationDefinition._, Selection._\n\n  /**\n   *  Parse a String to query algebra operations and fragments.\n   *\n   *  GraphQL errors and warnings are accumulated in the result.\n   */\n  def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])] =\n    for {\n      doc <- GraphQLParser.toResult(text, GraphQLParser.Document.parseAll(text))\n      res <- parseDocument(doc)\n      _   <- Result.failure(\"At least one operation required\").whenA(res._1.isEmpty)\n    } yield res\n\n  /**\n   *  Parse a document AST to query algebra operations and fragments.\n   *\n   *  GraphQL errors and warnings are accumulated in the result.\n   */\n  def parseDocument(doc: Document): Result[(List[UntypedOperation], List[UntypedFragment])] = {\n    val ops0 = doc.collect { case op: OperationDefinition => op }\n    val fragments0 = doc.collect { case frag: FragmentDefinition => frag }\n\n    for {\n      ops    <- ops0.traverse {\n                  case op: Operation => parseOperation(op)\n                  case qs: QueryShorthand => parseQueryShorthand(qs)\n                }\n      frags  <- fragments0.traverse { frag =>\n                  val tpnme = frag.typeCondition.name\n                  for {\n                    sels <- parseSelections(frag.selectionSet)\n                    dirs <- parseDirectives(frag.directives)\n                  } yield UntypedFragment(frag.name.value, tpnme, dirs, sels)\n                }\n    } yield (ops, frags)\n  }\n\n  /**\n   *  Parse an operation AST to a query algebra operation.\n   *\n   *  GraphQL errors and warnings are accumulated in the result.\n   */\n  def parseOperation(op: Operation): Result[UntypedOperation] = {\n    val Operation(opType, name, vds, dirs0, sels) = op\n    for {\n      vs   <- parseVariableDefinitions(vds)\n      q    <- parseSelections(sels)\n      dirs <- parseDirectives(dirs0)\n    } yield {\n      val name0 = name.map(_.value)\n      opType match {\n        case OperationType.Query => UntypedQuery(name0, q, vs, dirs)\n        case OperationType.Mutation => UntypedMutation(name0, q, vs, dirs)\n        case OperationType.Subscription => UntypedSubscription(name0, q, vs, dirs)\n      }\n    }\n  }\n\n  /**\n    * Parse variable definition ASTs to query algebra variable definitions.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseVariableDefinitions(vds: List[VariableDefinition]): Result[List[UntypedVarDef]] =\n    vds.traverse {\n      case VariableDefinition(Name(nme), tpe, dv0, dirs0) =>\n        for {\n          dv   <- dv0.traverse(SchemaParser.parseValue)\n          dirs <- parseDirectives(dirs0)\n        } yield UntypedVarDef(nme, tpe, dv, dirs)\n    }\n\n  /**\n    * Parse a query shorthand AST to query algebra operation.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseQueryShorthand(qs: QueryShorthand): Result[UntypedOperation] =\n    parseSelections(qs.selectionSet).map(q => UntypedQuery(None, q, Nil, Nil))\n\n  /**\n    * Parse selection ASTs to query algebra terms.\n    *\n    * GraphQL errors and warnings are accumulated in the result\n    */\n  def parseSelections(sels: List[Selection]): Result[Query] =\n    sels.traverse(parseSelection).map { sels0 =>\n      if (sels0.sizeCompare(1) == 0) sels0.head else Group(sels0)\n    }\n\n  /**\n    * Parse a selection AST to a query algebra term.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseSelection(sel: Selection): Result[Query] = sel match {\n    case Field(alias, name, args, directives, sels) =>\n      for {\n        args0 <- parseArgs(args)\n        sels0 <- parseSelections(sels)\n        dirs  <- parseDirectives(directives)\n      } yield {\n        val nme = name.value\n        val alias0 = alias.map(_.value).flatMap(n => if (n == nme) None else Some(n))\n        if (sels.isEmpty) UntypedSelect(nme, alias0, args0, dirs, Empty)\n        else UntypedSelect(nme, alias0, args0, dirs, sels0)\n      }\n\n    case FragmentSpread(Name(name), directives) =>\n      for {\n        dirs <- parseDirectives(directives)\n      } yield UntypedFragmentSpread(name, dirs)\n\n    case InlineFragment(typeCondition, directives, sels) =>\n      for {\n        dirs  <- parseDirectives(directives)\n        sels0 <- parseSelections(sels)\n      } yield UntypedInlineFragment(typeCondition.map(_.name), dirs, sels0)\n  }\n\n  /**\n    * Parse directive ASTs to query algebra directives.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseDirectives(directives: List[Ast.Directive]): Result[List[Directive]] =\n    directives.traverse(SchemaParser.mkDirective)\n\n  /**\n    * Parse argument ASTs to query algebra bindings.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseArgs(args: List[(Name, Ast.Value)]): Result[List[Binding]] =\n    args.traverse((parseArg _).tupled)\n\n  /**\n    * Parse an argument AST to a query algebra binding.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def parseArg(name: Name, value: Ast.Value): Result[Binding] =\n    SchemaParser.parseValue(value).map(v => Binding(name.value, v))\n}\n\n/**\n * GraphQL query compiler.\n *\n * A QueryCompiler parses GraphQL queries to query algebra terms, then\n * applies a collection of transformation phases in sequence, yielding a\n * query algebra term which can be directly interpreted.\n */\nclass QueryCompiler(schema: Schema, phases: List[Phase]) {\n  import IntrospectionLevel._\n\n  /**\n   * Compiles the GraphQL query `text` to a query algebra term which\n   * can be directly executed.\n   *\n   * GraphQL errors and warnings are accumulated in the result.\n   */\n  def compile(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Result[Operation] =\n    QueryParser.parseText(text).flatMap { case (ops, frags) =>\n      (ops, name) match {\n        case (Nil, _) =>\n          Result.failure(\"At least one operation required\")\n        case (List(op), None) =>\n          compileOperation(op, untypedVars, frags, introspectionLevel, env)\n        case (_, None) =>\n          Result.failure(\"Operation name required to select unique operation\")\n        case (ops, _) if ops.exists(_.name.isEmpty) =>\n          Result.failure(\"Query shorthand cannot be combined with multiple operations\")\n        case (ops, name) =>\n          ops.filter(_.name == name) match {\n            case List(op) =>\n              compileOperation(op, untypedVars, frags, introspectionLevel, env)\n            case Nil =>\n              Result.failure(s\"No operation named '$name'\")\n            case _ =>\n              Result.failure(s\"Multiple operations named '$name'\")\n          }\n      }\n    }\n\n  /**\n    * Compiles the provided operation AST to a query algebra term\n    * which can be directly executed.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileOperation(op: UntypedOperation, untypedVars: Option[Json], frags: List[UntypedFragment], introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Result[Operation] = {\n    val allPhases =\n      IntrospectionElaborator(introspectionLevel).toList ++ (VariablesSkipAndFragmentElaborator :: phases)\n\n    for {\n      varDefs <- compileVarDefs(op.variables)\n      vars    <- compileVars(varDefs, untypedVars)\n      _       <- Directive.validateDirectivesForQuery(schema, op, frags, vars)\n      rootTpe <- op.rootTpe(schema)\n      res     <- (\n                   for {\n                     query <- allPhases.foldLeftM(op.query) { (acc, phase) => phase.transformFragments *> phase.transform(acc) }\n                   } yield Operation(query, rootTpe, op.directives)\n                 ).runA(\n                   ElabState(\n                     None,\n                     schema,\n                     Context(rootTpe),\n                     vars,\n                     frags.map(f => (f.name, f)).toMap,\n                     op.query,\n                     env,\n                     List.empty,\n                     Elab.pure\n                   )\n                 )\n    } yield res\n  }\n\n  /**\n    * Compiles variable definition ASTs to variable definitions for the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileVarDefs(untypedVarDefs: UntypedVarDefs): Result[VarDefs] =\n    untypedVarDefs.traverse {\n      case UntypedVarDef(name, untypedTpe, default, dirs) =>\n        compileType(untypedTpe).map(tpe => InputValue(name, None, tpe, default, dirs))\n    }\n\n  /**\n    * Compiles raw query variables to variables for the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileVars(varDefs: VarDefs, untypedVars: Option[Json]): Result[Vars] =\n    untypedVars match {\n      case None => Map.empty.success\n      case Some(untypedVars) =>\n        untypedVars.asObject match {\n          case None =>\n            Result.failure(s\"Variables must be represented as a Json object\")\n          case Some(obj) =>\n            varDefs.traverse(iv => checkVarValue(iv, obj(iv.name), \"variable values\").map(v => (iv.name, (iv.tpe, v)))).map(_.toMap)\n        }\n    }\n\n  /**\n    * Compiles a type AST to a type in the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileType(tpe: Ast.Type): Result[Type] = {\n    def loop(tpe: Ast.Type, nonNull: Boolean): Result[Type] = tpe match {\n      case Ast.Type.NonNull(Left(named)) => loop(named, true)\n      case Ast.Type.NonNull(Right(list)) => loop(list, true)\n      case Ast.Type.List(elem) => loop(elem, false).map(e => if (nonNull) ListType(e) else NullableType(ListType(e)))\n      case Ast.Type.Named(name) => schema.definition(name.value) match {\n        case None => Result.failure(s\"Undefined type '${name.value}'\")\n        case Some(tpe) => (if (nonNull) tpe else NullableType(tpe)).success\n      }\n    }\n    loop(tpe, false)\n  }\n}\n\nobject QueryCompiler {\n  sealed trait IntrospectionLevel\n  object IntrospectionLevel {\n    case object Full extends IntrospectionLevel\n    case object TypenameOnly extends IntrospectionLevel\n    case object Disabled extends IntrospectionLevel\n  }\n\n  import IntrospectionLevel._\n\n  /**\n    * Elaboration monad.\n    *\n    * Supports threading of state through the elaboration of a query. Provides,\n    * + access to the schema, context, variables and fragments of a query.\n    * + ability to transform the children of Selects to supply semantics for field arguments.\n    * + ability to add contextual data to the resulting query both to support propagation of\n    *   context to the elaboration of children, and to to drive run time behaviour.\n    * + ability to add selects for additional attributes to the resulting query.\n    * + ability to test existence and properties of neighbour nodes of the node being\n    *   elaborated.\n    * + ability to report errors and warnings during elaboration.\n    */\n  type Elab[T] = StateT[Result, ElabState, T]\n  object Elab {\n    def unit: Elab[Unit] = StateT.pure(())\n    def pure[T](t: T): Elab[T] = StateT.pure(t)\n    def liftR[T](rt: Result[T]): Elab[T] = StateT.liftF(rt)\n\n    /** The scheam of the query being elaborated */\n    def schema: Elab[Schema] = StateT.inspect(_.schema)\n    /** The context of the node currently being elaborated */\n    def context: Elab[Context] = StateT.inspect(_.context)\n    /** The variables of the query being elaborated */\n    def vars: Elab[Vars] = StateT.inspect(_.vars)\n    /** The fragments of the query being elaborated */\n    def fragments: Elab[Map[String, UntypedFragment]] = StateT.inspect(_.fragments)\n    /** The fragment with the supplied name, if defined, failing otherwise */\n    def fragment(nme: String): Elab[UntypedFragment] =\n      StateT.inspectF(_.fragments.get(nme).toResult(s\"Fragment '$nme' is not defined\"))\n    def transformFragments(f: Map[String, UntypedFragment] => Elab[Map[String, UntypedFragment]]): Elab[Unit] =\n      for {\n        fs  <- fragments\n        fs0 <- f(fs)\n        _   <- StateT.modify(_.copy(fragments = fs0)): Elab[Unit]\n      } yield ()\n    /** `true` if the node currently being elaborated has a child with the supplied name */\n    def hasField(name: String): Elab[Boolean] = StateT.inspect(_.hasField(name))\n    /** The alias, if any, of the child with the supplied name */\n    def fieldAlias(name: String): Elab[Option[String]] = StateT.inspect(_.fieldAlias(name))\n    /** `true` if the node currently being elaborated has a sibling with the supplied name */\n    def hasSibling(name: String): Elab[Boolean] = StateT.inspect(_.hasSibling(name))\n    /** The result name of the node currently being elaborated */\n    def resultName: Elab[Option[String]] = StateT.inspect(_.resultName)\n\n    /** Binds the supplied value to the supplied name in the elaboration environment */\n    def env(nme: String, value: Any): Elab[Unit] = env(List(nme -> value))\n    /** Binds the supplied names and values in the elaboration environment */\n    def env(kv: (String, Any), kvs: (String, Any)*): Elab[Unit] = env(kv +: kvs.toSeq)\n    /** Binds the supplied names and values in the elaboration environment */\n    def env(kvs: Seq[(String, Any)]): Elab[Unit] = StateT.modify(_.env(kvs))\n    /** Adds all the bindings of the supplied environment to the elaboration environment */\n    def env(other: Env): Elab[Unit] = StateT.modify(_.env(other))\n    /** The value bound to the supplied name in the elaboration environment, if any */\n    def env[T: ClassTag](nme: String): Elab[Option[T]] = StateT.inspect(_.env[T](nme))\n    /** The value bound to the supplied name in the elaboration environment, if any, failing otherwise */\n    def envE[T: ClassTag: TypeName](nme: String): Elab[T] =\n      env(nme).flatMap(v => Elab.liftR(v.toResultOrError(s\"Key '$nme' of type ${typeName[T]} was not found in $this\")))\n    /** The subset of the elaboration environment defined directly at this node */\n    def localEnv: Elab[Env] = StateT.inspect(_.localEnv)\n\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Elab[Query]): Elab[Unit] = StateT.modify(_.addChildTransform(f))\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Query)(implicit dummy: DummyImplicit): Elab[Unit] = transformChild(q => Elab.pure(f(q)))\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Result[Query])(implicit dummy1: DummyImplicit, dummy2: DummyImplicit): Elab[Unit] = transformChild(q => Elab.liftR(f(q)))\n    /** The transformation to be applied to the child of the node currently being elaborated */\n    def transform: Elab[Query => Elab[Query]] = StateT.inspect(_.childTransform)\n    /** Add the supplied attributed and corresponding query, if any, to the query being elaborated */\n    def addAttribute(name: String, query: Query = Empty): Elab[Unit] = StateT.modify(_.addAttribute(name, query))\n    /** The attributes which have been added to the query being elaborated */\n    def attributes: Elab[List[(String, Query)]] = StateT.inspect(_.attributes)\n\n    /** Report the supplied GraphQL warning during elaboration */\n    def warning(msg: String): Elab[Unit] = StateT(s => Result.warning[(ElabState, Unit)](msg, (s, ())))\n    /** Report the supplied GraphQL warning during elaboration */\n    def warning(err: Problem): Elab[Unit] = StateT(s => Result.warning[(ElabState, Unit)](err, (s, ())))\n    /** Report the supplied GraphQL error during elaboration */\n    def failure[T](msg: String): Elab[T] = StateT(_ => Result.failure[(ElabState, T)](msg))\n    /** Report the supplied GraphQL error during elaboration */\n    def failure[T](err: Problem): Elab[T] = StateT(_ => Result.failure[(ElabState, T)](err))\n    /** Report the supplied internal error during elaboration */\n    def internalError[T](msg: String): Elab[T] = StateT(_ => Result.internalError[(ElabState, T)](msg))\n    /** Report the supplied internal error during elaboration */\n    def internalError[T](err: Throwable): Elab[T] = StateT(_ => Result.internalError[(ElabState, T)](err))\n\n    /** Save the current elaboration state */\n    def push: Elab[Unit] = StateT.modify(_.push)\n    /** Save the current elaboration state and switch to the supplied context and query */\n    def push(context: Context, query: Query): Elab[Unit] = StateT.modify(_.push(context, query))\n    /** Save the current elaboration state and switch to the supplied schema, context and query */\n    def push(schema: Schema, context: Context, query: Query): Elab[Unit] = StateT.modify(_.push(schema, context, query))\n    /** Restore the previous elaboration state */\n    def pop: Elab[Unit] = StateT.modifyF(s => s.parent.toResultOrError(\"Cannot pop root state\"))\n  }\n\n  /**\n    * The state managed by the elaboration monad.\n    */\n  case class ElabState(\n    parent: Option[ElabState],\n    schema: Schema,\n    context: Context,\n    vars: Vars,\n    fragments: Map[String, UntypedFragment],\n    query: Query,\n    localEnv: Env,\n    attributes: List[(String, Query)],\n    childTransform: Query => Elab[Query]\n  ) {\n    def hasField(fieldName: String): Boolean = Query.hasField(query, fieldName)\n    def fieldAlias(fieldName: String): Option[String] = Query.fieldAlias(query, fieldName)\n    def hasSibling(fieldName: String): Boolean = parent.exists(s => Query.hasField(s.query, fieldName))\n    def resultName: Option[String] = Query.ungroup(query).headOption.flatMap(Query.resultName)\n    def env(kvs: Seq[(String, Any)]): ElabState = copy(localEnv = localEnv.add(kvs: _*))\n    def env(other: Env): ElabState = copy(localEnv = localEnv.add(other))\n    def env[T: ClassTag](nme: String): Option[T] = localEnv.get(nme).orElse(parent.flatMap(_.env(nme)))\n    def addAttribute(name: String, query: Query = Empty): ElabState = copy(attributes = (name, query) :: attributes)\n    def addChildTransform(f: Query => Elab[Query]): ElabState = copy(childTransform = childTransform.andThen(_.flatMap(f)))\n    def push: ElabState = copy(parent = Some(this), localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n    def push(context: Context, query: Query): ElabState =\n      copy(parent = Some(this), context = context, query = query, localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n    def push(schema: Schema, context: Context, query: Query): ElabState =\n      copy(parent = Some(this), schema = schema, context = context, query = query, localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n  }\n\n  /** A QueryCompiler phase. */\n  trait Phase {\n    def transformFragments: Elab[Unit] = Elab.unit\n\n    /**\n     * Transform the supplied query algebra term `query`.\n     */\n    def transform(query: Query): Elab[Query] =\n      query match {\n        case s@UntypedSelect(fieldName, alias, _, _, child) =>\n          transformSelect(fieldName, alias, child).map(ec => s.copy(child = ec))\n\n        case s@Select(fieldName, alias, child) =>\n          transformSelect(fieldName, alias, child).map(ec => s.copy(child = ec))\n\n        case n@Narrow(subtpe, child)  =>\n          for {\n            c  <- Elab.context\n            _  <- Elab.push(c.asType(subtpe), child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield n.copy(child = ec)\n\n        case f@UntypedFragmentSpread(_, _) => Elab.pure(f)\n        case i@UntypedInlineFragment(None, _, child) =>\n          transform(child).map(ec => i.copy(child = ec))\n        case i@UntypedInlineFragment(Some(tpnme), _, child) =>\n          for {\n            s      <- Elab.schema\n            c      <- Elab.context\n            subtpe <- Elab.liftR(Result.fromOption(s.definition(tpnme), s\"Unknown type '$tpnme' in type condition\"))\n            _      <- Elab.push(c.asType(subtpe), child)\n            ec     <- transform(child)\n            _      <- Elab.pop\n          } yield i.copy(child = ec)\n\n        case i@Introspect(_, child) =>\n          for {\n            s    <- Elab.schema\n            c    <- Elab.context\n            iTpe =  if(c.tpe =:= s.queryType) Introspection.schema.queryType else TypenameType\n            _    <- Elab.push(Introspection.schema, c.asType(iTpe), child)\n            ec   <- transform(child)\n            _    <- Elab.pop\n          } yield i.copy(child = ec)\n\n        case u@Unique(child) =>\n          for {\n            c  <- Elab.context\n            _  <- Elab.push(c.asType(c.tpe.nonNull.list), child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield u.copy(child = ec)\n\n        case f@Filter(_, child) =>\n          for {\n            c    <- Elab.context\n            item <- Elab.liftR(c.tpe.item.toResultOrError(s\"Filter of non-List type ${c.tpe}\"))\n            _    <- Elab.push(c.asType(item), child)\n            ec   <- transform(child)\n            _    <- Elab.pop\n          } yield f.copy(child = ec)\n\n        case n@Count(child) =>\n          for {\n            c  <- Elab.context\n            pc <- Elab.liftR(c.parent.toResultOrError(s\"Count node has no parent\"))\n            _  <- Elab.push(pc, child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield n.copy(child = ec)\n\n        case g@Group(children) =>\n          children.traverse { c =>\n            for {\n              _  <- Elab.push\n              tc <- transform(c)\n              _  <- Elab.pop\n            } yield tc\n          }.map(eqs => g.copy(queries = eqs))\n\n        case c@Component(_, _, child) => transform(child).map(ec => c.copy(child = ec))\n        case e@Effect(_, child)       => transform(child).map(ec => e.copy(child = ec))\n        case l@Limit(_, child)        => transform(child).map(ec => l.copy(child = ec))\n        case o@Offset(_, child)       => transform(child).map(ec => o.copy(child = ec))\n        case o@OrderBy(_, child)      => transform(child).map(ec => o.copy(child = ec))\n        case e@Environment(_, child)  => transform(child).map(ec => e.copy(child = ec))\n        case t@TransformCursor(_, child) => transform(child).map(ec => t.copy(child = ec))\n        case Empty                    => Elab.pure(Empty)\n      }\n\n    def transformSelect(fieldName: String, alias: Option[String], child: Query): Elab[Query] =\n      for {\n        c        <- Elab.context\n        _        <- validateSubselection(fieldName, child)\n        childCtx <- Elab.liftR(c.forField(fieldName, alias))\n        _        <- Elab.push(childCtx, child)\n        ec       <- transform(child)\n        _        <- Elab.pop\n      } yield ec\n\n    def validateSubselection(fieldName: String, child: Query): Elab[Unit] =\n      for {\n        c        <- Elab.context\n        obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n        childCtx <- Elab.liftR(c.forField(fieldName, None))\n        tpe      =  childCtx.tpe\n        _        <- {\n                      val isLeaf = tpe.isUnderlyingLeaf\n                      if (isLeaf && child != Empty)\n                        Elab.failure(s\"Leaf field '$fieldName' of $obj must have an empty subselection set\")\n                      else if (!isLeaf && child == Empty)\n                        Elab.failure(s\"Non-leaf field '$fieldName' of $obj must have a non-empty subselection set\")\n                      else\n                        Elab.pure(())\n                    }\n      } yield ()\n\n    val TypenameType = ObjectType(s\"__Typename\", None, List(Field(\"__typename\", None, Nil, StringType, Nil)), Nil, Nil)\n  }\n\n  /**\n   * A phase which elaborates GraphQL introspection queries into the query algrebra.\n   */\n  class IntrospectionElaborator(level: IntrospectionLevel) extends Phase {\n    override def transformFragments: Elab[Unit] =\n      Elab.transformFragments { fs =>\n        fs.toList.traverse {\n          case (nme, f@UntypedFragment(_, tpnme, _, child)) =>\n            for {\n              s   <- Elab.schema\n              c   <- Elab.context\n              tpe <- Elab.liftR(Result.fromOption(s.definition(tpnme).orElse(Introspection.schema.definition(tpnme)), s\"Unknown type '$tpnme' in fragment definition\"))\n              _   <- Elab.push(c.asType(tpe), child)\n              ec  <- transform(child)\n              _   <- Elab.pop\n           } yield (nme, f.copy(child = ec))\n        }.map(_.toMap)\n      }\n\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@UntypedSelect(fieldName @ (\"__typename\" | \"__schema\" | \"__type\"), _, _, _, _) =>\n          (fieldName, level) match {\n            case (\"__typename\", Disabled) =>\n              Elab.failure(\"Introspection is disabled\")\n            case (\"__schema\" | \"__type\", TypenameOnly | Disabled) =>\n              Elab.failure(\"Introspection is disabled\")\n            case _ =>\n              for {\n                schema <- Elab.schema\n              } yield Introspect(schema, s)\n          }\n        case _ => super.transform(query)\n      }\n  }\n\n  object IntrospectionElaborator {\n    def apply(level: IntrospectionLevel): Option[IntrospectionElaborator] =\n      level match {\n        case Disabled => None\n        case other => Some(new IntrospectionElaborator(other))\n      }\n  }\n\n  /**\n   * A phase which elaborates variables, directives, fragment spreads\n   * and inline fragments.\n   *\n   * 1. Query variable values are substituted for all variable\n   *    references.\n   *\n   * 2. `skip` and `include` directives are handled during this phase\n   *    and the guarded subqueries are retained or removed as\n   *    appropriate.\n   *\n   * 3. Fragment spread and inline fragments are expanded.\n   *\n   * 4. types narrowing coercions by resolving the target type\n   *    against the schema.\n   *\n   * 5. verifies that leaves have an empty subselection set and that\n   *    structured types have a non-empty subselection set.\n   */\n  object VariablesSkipAndFragmentElaborator extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case Group(children) =>\n          children.traverse(q => transform(q)).map { eqs =>\n            eqs.filterNot(_ == Empty) match {\n              case Nil => Empty\n              case eq :: Nil => eq\n              case eqs => Group(eqs)\n            }\n          }\n        case sel@UntypedSelect(fieldName, alias, args, dirs, child) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              _        <- validateSubselection(fieldName, child)\n              s        <- Elab.schema\n              c        <- Elab.context\n              childCtx <- Elab.liftR(c.forField(fieldName, alias))\n              vars     <- Elab.vars\n              eArgs    <- args.traverse(elaborateBinding(_, vars))\n              eDirs    <- Elab.liftR(Directive.elaborateDirectives(s, dirs, vars))\n              _        <- Elab.push(childCtx, child)\n              ec       <- transform(child)\n              _        <- Elab.pop\n            } yield sel.copy(args = eArgs, directives = eDirs, child = ec)\n          )\n\n        case UntypedFragmentSpread(nme, dirs) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              s      <- Elab.schema\n              c      <- Elab.context\n              f      <- Elab.fragment(nme)\n              ctpe   <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n              subtpe <- Elab.liftR(s.definition(f.tpnme).toResult(s\"Unknown type '${f.tpnme}' in type condition of fragment '$nme'\"))\n              _      <- Elab.failure(s\"Fragment '$nme' is not compatible with type '${c.tpe}'\").whenA(!(subtpe <:< ctpe) && !(ctpe <:< subtpe))\n              _      <- Elab.push(c.asType(subtpe), f.child)\n              ec     <- transform(f.child)\n              _      <- Elab.pop\n            } yield\n              if (ctpe <:< subtpe) ec\n              else Narrow(s.ref(subtpe.name), ec)\n          )\n\n        case UntypedInlineFragment(tpnme0, dirs, child) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              s      <- Elab.schema\n              c      <- Elab.context\n              ctpe   <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n              subtpe <- tpnme0 match {\n                          case None =>\n                            Elab.pure(ctpe)\n                          case Some(tpnme) =>\n                            Elab.liftR(s.definition(tpnme).toResult(s\"Unknown type '$tpnme' in type condition inline fragment\"))\n                        }\n              _      <- Elab.failure(s\"Inline fragment with type condition '$subtpe' is not compatible with type '$ctpe'\").whenA(!(subtpe <:< ctpe) && !(ctpe <:< subtpe))\n              _      <- Elab.push(c.asType(subtpe), child)\n              ec     <- transform(child)\n              _      <- Elab.pop\n            } yield\n              if (ctpe <:< subtpe) ec\n              else Narrow(s.ref(subtpe.name), ec)\n          )\n\n        case _ => super.transform(query)\n      }\n\n    def elaborateBinding(b: Binding, vars: Vars): Elab[Binding] =\n      Elab.liftR(Value.elaborateValue(b.value, vars).map(ev => b.copy(value = ev)))\n\n    def isSkipped(dirs: List[Directive]): Elab[Boolean] =\n      dirs.filter(d => d.name == \"skip\" || d.name == \"include\") match {\n        case Nil => Elab.pure(false)\n        case List(Directive(nme, List(Binding(\"if\", value)))) =>\n          for {\n            c <- extractCond(value)\n          } yield (nme == \"skip\" && c) || (nme == \"include\" && !c)\n        case List(Directive(nme, _)) => Elab.failure(s\"Directive '$nme' must have a single Boolean 'if' argument\")\n        case _ => Elab.failure(\"skip/include directives must be unique\")\n      }\n\n    def extractCond(value: Value): Elab[Boolean] =\n      value match {\n        case VariableRef(varName) =>\n          for {\n            v  <- Elab.vars\n            tv <- Elab.liftR(Result.fromOption(v.get(varName), s\"Undefined variable '$varName'\"))\n            b  <- tv match {\n                    case (tpe, BooleanValue(value)) if tpe.nonNull =:= BooleanType => Elab.pure(value)\n                    case _ => Elab.failure(s\"Argument of skip/include must be boolean\")\n                  }\n          } yield b\n        case BooleanValue(value) => Elab.pure(value)\n        case _ => Elab.failure(s\"Argument of skip/include must be boolean\")\n      }\n  }\n\n  /**\n   * A compiler phase which translates `Select` nodes to be directly\n   * interpretable.\n   *\n   * This phase,\n   *\n   * 1. types bindings according to the schema:\n   *    i)   untyped enums are validated and typed according to their\n   *         declared type.\n   *    ii)  String and Int bindings are translated to ID bindings\n   *         where appropriate.\n   *    iii) default values are supplied for missing arguments.\n   *    iv)  arguments are permuted into the order declared in the\n   *         schema.\n   *\n   * 2. eliminates Select arguments by delegating to a model-specific\n   *    `PartialFunction` which is responsible for translating `Select`\n   *    nodes into a form which is directly interpretable, for example,\n   *    replacing them with a `Filter` or `Unique` node with a\n   *    `Predicate` which is parameterized by the arguments, ie.,\n   *\n   *    ```\n   *    UntypedSelect(\"character\", None, List(IDBinding(\"id\", \"1000\")), Nil, child)\n   *    ```\n   *    might be translated to,\n   *    ```\n   *    Select(\"character, None, Filter(FieldEquals(\"id\", \"1000\"), child))\n   *    ```\n   * 3. GraphQL introspection query field arguments are elaborated.\n   */\n  trait SelectElaborator extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case sel@UntypedSelect(fieldName, resultName, args, dirs, child) =>\n          for {\n            c        <- Elab.context\n            s        <- Elab.schema\n            childCtx <- Elab.liftR(c.forField(fieldName, resultName))\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n            field    <- obj match {\n                          case twf: TypeWithFields =>\n                            Elab.liftR(twf.fieldInfo(fieldName).toResult(s\"No field '$fieldName' for type ${obj.underlying}\"))\n                          case _ => Elab.failure(s\"Type $obj is not an object or interface type\")\n                        }\n            eArgs    <- Elab.liftR(elaborateFieldArgs(obj, field, args))\n            ref      <- Elab.liftR(s.ref(obj).orElse(introspectionRef(obj)).toResultOrError(s\"Type $obj not found in schema\"))\n            _        <- if (s eq Introspection.schema) elaborateIntrospection(ref, fieldName, eArgs)\n                        else select(ref, fieldName, eArgs, dirs)\n            elab     <- Elab.transform\n            env      <- Elab.localEnv\n            attrs    <- Elab.attributes\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            e2       <- elab(ec)\n          } yield {\n            val e1 = Select(sel.name, sel.alias, e2)\n            val e0 =\n              if(attrs.isEmpty) e1\n              else Group((e1 :: attrs.map { case (nme, child) => Select(nme, child) }).flatMap(Query.ungroup))\n\n            if (env.isEmpty) e0\n            else Environment(env, e0)\n          }\n\n        case _ => super.transform(query)\n      }\n\n    def select(ref: TypeRef, name: String, args: List[Binding], directives: List[Directive]): Elab[Unit]\n\n    val QueryTypeRef = Introspection.schema.ref(\"Query\")\n    val TypeTypeRef = Introspection.schema.ref(\"__Type\")\n    val FieldTypeRef = Introspection.schema.ref(\"__Field\")\n    val EnumValueTypeRef = Introspection.schema.ref(\"__EnumValue\")\n\n    def introspectionRef(tpe: Type): Option[TypeRef] =\n      Introspection.schema.ref(tpe).orElse(tpe.asNamed.flatMap(\n        _.name match {\n          case \"__Typename\" => Some(Introspection.schema.ref(\"__Typename\"))\n          case _ => None\n        }\n      ))\n\n    def elaborateIntrospection(ref: TypeRef, name: String, args: List[Binding]): Elab[Unit] =\n      (ref, name, args) match {\n        case (QueryTypeRef, \"__type\", List(Binding(\"name\", StringValue(name)))) =>\n          Elab.transformChild(child => Unique(Filter(Eql(TypeTypeRef / \"name\", Const(Option(name))), child)))\n\n        case (TypeTypeRef, \"fields\", List(Binding(\"includeDeprecated\", BooleanValue(include)))) =>\n          Elab.transformChild(child => if (include) child else Filter(Eql(FieldTypeRef / \"isDeprecated\", Const(false)), child))\n        case (TypeTypeRef, \"enumValues\", List(Binding(\"includeDeprecated\", BooleanValue(include)))) =>\n          Elab.transformChild(child => if (include) child else Filter(Eql(EnumValueTypeRef / \"isDeprecated\", Const(false)), child))\n\n        case _ =>\n          Elab.unit\n      }\n\n    def elaborateFieldArgs(tpe: NamedType, field: Field, args: List[Binding]): Result[List[Binding]] = {\n      val infos = field.args\n      val unknownArgs = args.filterNot(arg => infos.exists(_.name == arg.name))\n      if (unknownArgs.nonEmpty)\n        Result.failure(s\"Unknown argument(s) ${unknownArgs.map(s => s\"'${s.name}'\").mkString(\"\", \", \", \"\")} in field ${field.name} of type ${tpe.name}\")\n      else {\n        val argMap = args.groupMapReduce(_.name)(_.value)((x, _) => x)\n        infos.traverse(info => checkValue(info, argMap.get(info.name), s\"field '${field.name}' of type '$tpe'\").map(v => Binding(info.name, v)))\n      }\n    }\n  }\n\n  object SelectElaborator {\n    /**\n     * Construct a `SelectElaborator` given a partial function which is called for each\n     * Select` node in the query.\n     */\n    def apply(sel: PartialFunction[(TypeRef, String, List[Binding]), Elab[Unit]]): SelectElaborator =\n      new SelectElaborator {\n        def select(ref: TypeRef, name: String, args: List[Binding], directives: List[Directive]): Elab[Unit] =\n          if(sel.isDefinedAt((ref, name, args))) sel((ref, name, args))\n          else Elab.unit\n      }\n\n    /** A select elaborator which discards all field arguments */\n    def identity: SelectElaborator = SelectElaborator(_ => Elab.unit)\n  }\n\n  /**\n   * A compiler phase which partitions a query for execution by multiple\n   * composed mappings.\n   *\n   * This phase transforms the input query by assigning subtrees to component\n   * mappings as specified by the supplied `cmapping`.\n   *\n   * The mapping has `Type` and field name pairs as keys and mapping and\n   * join function pairs as values. When the traversal of the input query\n   * visits a `Select` node with type `Type.field name` it will replace the\n   * `Select` with a `Component` node comprising,\n   *\n   * 1. the mapping which will be responsible for evaluating the subquery.\n   * 2. A join function which will be called during interpretation with,\n   *\n   *    i) The deferred subquery.\n   *    ii)  the cursor at that point in evaluation.\n   *\n   *    This join function is responsible for computing the continuation\n   *    query which will be evaluated by the responsible interpreter.\n   *\n   *    Because the join is provided with the cursor of the parent\n   *    interpreter the subquery can be parameterised with values derived\n   *    from the parent query.\n   */\n  class ComponentElaborator[F[_]] private (cmapping: Map[(Type, String), (Mapping[F], (Query, Cursor) => Result[Query])]) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@Select(fieldName, resultName, child) =>\n          for {\n            c        <- Elab.context\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Type ${c.tpe} is not an object or interface type\"))\n            childCtx =  c.forFieldOrAttribute(fieldName, resultName)\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            schema   <- Elab.schema\n            ref      =  schema.ref(obj.name)\n          } yield\n            cmapping.get((ref, fieldName)) match {\n              case Some((component, join)) =>\n                Component(component, join, s.copy(child = ec))\n              case None =>\n                s.copy(child = ec)\n            }\n\n        case _ => super.transform(query)\n      }\n  }\n\n  object ComponentElaborator {\n    val TrivialJoin = (q: Query, _: Cursor) => q.success\n\n    case class ComponentMapping[F[_]](tpe: TypeRef, fieldName: String, mapping: Mapping[F], join: (Query, Cursor) => Result[Query] = TrivialJoin)\n\n    def apply[F[_]](mappings: List[ComponentMapping[F]]): ComponentElaborator[F] =\n      new ComponentElaborator(mappings.map(m => ((m.tpe, m.fieldName), (m.mapping, m.join))).toMap)\n  }\n\n  /**\n   * A compiler phase which partitions a query for execution which may invoke\n   * multiple effect handlers.\n   *\n   * This phase transforms the input query by assigning subtrees to effect\n   * handlers as specified by the supplied `emapping`.\n   *\n   * The mapping has `Type` and field name pairs as keys and effect handlers\n   * as values. When the traversal of the input query visits a `Select` node\n   * with type `Type.field name` it will replace the\n   * `Select` with an `Effect` node comprising,\n   *\n   * 1. the effect handler which will be responsible for running the effect\n   *    and evaluating the subquery against its result.\n   * 2. the subquery which will be evaluated by the effect handler.\n   */\n  class EffectElaborator[F[_]] private (emapping: Map[(Type, String), EffectHandler[F]]) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@Select(fieldName, resultName, child) =>\n          for {\n            c        <- Elab.context\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Type ${c.tpe} is not an object or interface type\"))\n            childCtx =  c.forFieldOrAttribute(fieldName, resultName)\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            schema   <- Elab.schema\n            ref      =  schema.ref(obj.name)\n          } yield\n            emapping.get((ref, fieldName)) match {\n              case Some(handler) =>\n                Select(fieldName, resultName, Effect(handler, s.copy(child = ec)))\n              case None =>\n                s.copy(child = ec)\n            }\n\n        case _ => super.transform(query)\n      }\n  }\n\n  object EffectElaborator {\n    case class EffectMapping[F[_]](tpe: TypeRef, fieldName: String, handler: EffectHandler[F])\n\n    def apply[F[_]](mappings: List[EffectMapping[F]]): EffectElaborator[F] =\n      new EffectElaborator(mappings.map(m => ((m.tpe, m.fieldName), m.handler)).toMap)\n  }\n\n  /**\n    * A compiler phase which estimates the size of a query and applies width\n    * and depth limits.\n    */\n  class QuerySizeValidator(maxDepth: Int, maxWidth: Int) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      Elab.fragments.flatMap { frags =>\n        querySize(query, frags) match {\n          case (depth, _) if depth > maxDepth => Elab.failure(s\"Query is too deep: depth is $depth levels, maximum is $maxDepth\")\n          case (_, width) if width > maxWidth => Elab.failure(s\"Query is too wide: width is $width leaves, maximum is $maxWidth\")\n          case (depth, width) if depth > maxDepth && width > maxWidth => Elab.failure(s\"Query is too complex: width/depth is $width/$depth leaves/levels, maximum is $maxWidth/$maxDepth\")\n          case (_, _) => Elab.pure(query)\n        }\n      }\n\n    def querySize(query: Query, frags: Map[String, UntypedFragment]): (Int, Int) = {\n      def handleGroup(g: Group, depth: Int, width: Int): (Int, Int) = {\n        val dws = Query.ungroup(g).map(loop(_, depth, width))\n        val (depths, widths) = dws.unzip\n        (depths.max, widths.sum)\n      }\n\n      @tailrec\n      def loop(q: Query, depth: Int, width: Int): (Int, Int) =\n        q match {\n          case UntypedSelect(_, _, _, _, Empty) => (depth + 1, width + 1)\n          case Select(_, _, Empty) => (depth + 1, width + 1)\n          case Count(_) => (depth + 1, width + 1)\n          case UntypedSelect(_, _, _, _, child) => loop(child, depth + 1, width)\n          case Select(_, _, child) => loop(child, depth + 1, width)\n          case g: Group => handleGroup(g, depth, width)\n          case Component(_, _, child) => loop(child, depth, width)\n          case Effect(_, child) => loop(child, depth, width)\n          case Environment(_, child) => loop(child, depth, width)\n          case Empty => (depth, width)\n          case Filter(_, child) => loop(child, depth, width)\n          case Introspect(_, _) => (depth, width)\n          case Limit(_, child) => loop(child, depth, width)\n          case Offset(_, child) => loop(child, depth, width)\n          case Narrow(_, child) => loop(child, depth, width)\n          case OrderBy(_, child) => loop(child, depth, width)\n          case TransformCursor(_, child) => loop(child, depth, width)\n          case Unique(child) => loop(child, depth, width)\n          case UntypedFragmentSpread(nme, _) =>\n            frags.get(nme) match {\n              case Some(frag) => loop(frag.child, depth, width)\n              case None => (depth, width)\n            }\n          case UntypedInlineFragment(_, _, child) => loop(child, depth, width)\n        }\n\n      loop(query, 0, 0)\n    }\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport scala.collection.Factory\nimport scala.reflect.ClassTag\n\nimport cats.MonadThrow\nimport cats.data.Chain\nimport cats.implicits._\nimport fs2.{ Stream, Compiler }\nimport io.circe.{Encoder, Json}\nimport io.circe.syntax._\nimport org.tpolecat.sourcepos.SourcePos\nimport org.tpolecat.typename._\n\nimport syntax._\nimport Cursor.{AbstractCursor, ProxyCursor}\nimport Query.EffectHandler\nimport QueryCompiler.{ComponentElaborator, EffectElaborator, IntrospectionLevel, SelectElaborator}\nimport QueryInterpreter.ProtoJson\nimport IntrospectionLevel._\n\n/**\n * Represents a mapping between a GraphQL schema and an underlying abstract data source.\n */\nabstract class Mapping[F[_]] {\n  implicit val M: MonadThrow[F]\n  val schema: Schema\n  val typeMappings: List[TypeMapping]\n\n  /**\n    * Compile and run a single GraphQL query or mutation.\n    *\n    * Yields a JSON response containing the result of the query or mutation.\n    */\n  def compileAndRun(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty)(\n    implicit sc: Compiler[F,F]\n  ): F[Json] =\n    compileAndRunSubscription(text, name, untypedVars, introspectionLevel, env).compile.toList.flatMap {\n      case List(j) => j.pure[F]\n      case Nil     => M.raiseError(new IllegalStateException(\"Result stream was empty.\"))\n      case js      => M.raiseError(new IllegalStateException(s\"Result stream contained ${js.length} results; expected exactly one.\"))\n    }\n\n  /**\n   * Compile and run a GraphQL subscription.\n   *\n   * Yields a stream of JSON responses containing the results of the subscription.\n   */\n  def compileAndRunSubscription(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Stream[F,Json] = {\n    val compiled = compiler.compile(text, name, untypedVars, introspectionLevel, env)\n    Stream.eval(compiled.pure[F]).flatMap(_.flatTraverse(op => interpreter.run(op.query, op.rootTpe, env))).evalMap(mkResponse)\n  }\n\n  /** Combine and execute multiple queries.\n   *\n   *  Each query is interpreted in the context of the Cursor it is\n   *  paired with. The result list is aligned with the argument\n   *  query list. For each query at most one stage will be run and the\n   *  corresponding result may contain deferred components.\n   *\n   *  Errors are aggregated across all the argument queries and are\n   *  accumulated on the `Left` of the result.\n   *\n   *  This method is typically called at the end of a stage to evaluate\n   *  deferred subqueries in the result of that stage. These will be\n   *  grouped by and passed jointly to the responsible mapping in\n   *  the next stage using this method. Maappongs which are able\n   *  to benefit from combining queries may do so by overriding this\n   *  method to implement their specific combinging logic.\n   */\n  def combineAndRun(queries: List[(Query, Cursor)]): F[Result[List[ProtoJson]]] =\n    queries.map { case (q, c) => (q, schema.queryType, c) }.traverse((interpreter.runOneShot _).tupled).map(ProtoJson.combineResults)\n\n  /** Yields a `Cursor` focused on the top level operation type of the query */\n  def defaultRootCursor(query: Query, tpe: Type, parentCursor: Option[Cursor]): F[Result[(Query, Cursor)]] =\n    Result((query, RootCursor(Context(tpe), parentCursor, Env.empty))).pure[F].widen\n\n  /**\n   * Root `Cursor` focussed on the top level operation of a query\n   *\n   * Construction of mapping-specific cursors is handled by delegation to\n   * `mkCursorForField which is typically overridden in `Mapping` subtypes.\n   */\n  case class RootCursor(context: Context, parent: Option[Cursor], env: Env) extends AbstractCursor {\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    def focus: Any = ()\n\n    override def hasField(fieldName: String): Boolean =\n      fieldMapping(context, fieldName).isDefined\n\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      mkCursorForField(this, fieldName, resultName)\n  }\n\n  /**\n    * Yields a `Cursor` suitable for traversing the query result corresponding to\n    * the `fieldName` child of `parent`.\n    *\n    * This method is typically overridden in and delegated to by `Mapping` subtypes.\n    */\n  def mkCursorForField(parent: Cursor, fieldName: String, resultName: Option[String]): Result[Cursor] = {\n    val context = parent.context\n    val fieldContext = context.forFieldOrAttribute(fieldName, resultName)\n\n    def mkLeafCursor(focus: Any): Result[Cursor] =\n      LeafCursor(fieldContext, focus, Some(parent), parent.env).success\n\n    fieldMapping(context, fieldName) match {\n      case Some(_ : EffectMapping) =>\n        mkLeafCursor(parent.focus)\n      case Some(CursorField(_, f, _, _, _)) =>\n        f(parent).flatMap(res => mkLeafCursor(res))\n      case _ =>\n        Result.failure(s\"No field '$fieldName' for type ${parent.tpe}\")\n    }\n  }\n\n  /** Yields the `TypeMapping` associated with the provided type, if any. */\n  def typeMapping(tpe: NamedType): Option[TypeMapping] =\n    typeMappingIndex.get(tpe.name)\n\n  private lazy val typeMappingIndex =\n    typeMappings.flatMap(tm => tm.tpe.asNamed.map(tpe => (tpe.name, tm)).toList).toMap\n\n  val validator: MappingValidator =\n    MappingValidator(this)\n\n  /** Yields the `ObjectMapping` associated with the provided context, if any. */\n  def objectMapping(context: Context): Option[ObjectMapping] =\n    context.tpe.underlyingObject.flatMap { obj =>\n      obj.asNamed.flatMap(typeMapping) match {\n        case Some(om: ObjectMapping) => Some(om)\n        case Some(pm: PrefixedMapping) =>\n          val revPath = context.path.reverse\n          pm.mappings.filter(m => revPath.endsWith(m._1)).maxByOption(_._1.length).map(_._2)\n        case _ => None\n      }\n    }\n\n  /** Yields the `FieldMapping` associated with `fieldName` in `context`, if any. */\n  def fieldMapping(context: Context, fieldName: String): Option[FieldMapping] =\n    objectMapping(context).flatMap(_.fieldMapping(fieldName)).orElse {\n      context.tpe.underlyingObject match {\n        case Some(ot: ObjectType) =>\n          ot.interfaces.collectFirstSome(nt => fieldMapping(context.asType(nt), fieldName))\n        case _ => None\n      }\n    }\n\n  /** Yields the `RootEffect`, if any, associated with `fieldName`. */\n  def rootEffect(context: Context, fieldName: String): Option[RootEffect] =\n    fieldMapping(context, fieldName).collect {\n      case re: RootEffect => re\n    }\n\n  /** Yields the `RootStream`, if any, associated with `fieldName`. */\n  def rootStream(context: Context, fieldName: String): Option[RootStream] =\n    fieldMapping(context, fieldName).collect {\n      case rs: RootStream => rs\n    }\n\n  /** Yields the `LeafMapping` associated with the provided type, if any. */\n  def leafMapping[T](tpe: Type): Option[LeafMapping[T]] =\n    typeMappings.collectFirst {\n      case lm@LeafMapping(tpe0, _) if tpe0 =:= tpe => lm.asInstanceOf[LeafMapping[T]]\n    }\n\n  /**\n   * True if the supplied type is a leaf with respect to the GraphQL schema\n   * or mapping, false otherwise.\n   */\n  def isLeaf(tpe: Type): Boolean = tpe.underlying match {\n    case (_: ScalarType)|(_: EnumType) => true\n    case tpe => leafMapping(tpe).isDefined\n  }\n\n  /** Yields the `Encoder` associated with the provided type, if any. */\n  def encoderForLeaf(tpe: Type): Option[Encoder[Any]] =\n    encoderMemo.get(tpe.dealias)\n\n  private lazy val encoderMemo: scala.collection.immutable.Map[Type, Encoder[Any]] = {\n    val intTypeEncoder: Encoder[Any] =\n      new Encoder[Any] {\n        def apply(i: Any): Json = (i: @unchecked) match {\n          case i: Int => Json.fromInt(i)\n          case l: Long => Json.fromLong(l)\n        }\n      }\n\n    val floatTypeEncoder: Encoder[Any] =\n      new Encoder[Any] {\n        def apply(f: Any): Json = (f: @unchecked) match {\n          case f: Float => Json.fromFloatOrString(f)\n          case d: Double => Json.fromDoubleOrString(d)\n          case d: BigDecimal => Json.fromBigDecimal(d)\n        }\n      }\n\n    val definedEncoders: List[(Type, Encoder[Any])] =\n      typeMappings.collect { case lm: LeafMapping[_] => (lm.tpe.dealias -> lm.encoder.asInstanceOf[Encoder[Any]]) }\n\n    val defaultEncoders: List[(Type, Encoder[Any])] =\n      List(\n        ScalarType.StringType -> Encoder[String].asInstanceOf[Encoder[Any]],\n        ScalarType.IntType -> intTypeEncoder,\n        ScalarType.FloatType -> floatTypeEncoder,\n        ScalarType.BooleanType -> Encoder[Boolean].asInstanceOf[Encoder[Any]],\n        ScalarType.IDType -> Encoder[String].asInstanceOf[Encoder[Any]]\n      )\n\n    (definedEncoders ++ defaultEncoders).toMap\n  }\n\n  trait TypeMapping extends Product with Serializable {\n    def tpe: Type\n    def pos: SourcePos\n  }\n\n  case class PrimitiveMapping(tpe: Type)(implicit val pos: SourcePos) extends TypeMapping\n\n  abstract class ObjectMapping extends TypeMapping {\n    private lazy val fieldMappingIndex = fieldMappings.map(fm => (fm.fieldName, fm)).toMap\n\n    def fieldMappings: List[FieldMapping]\n    def fieldMapping(fieldName: String): Option[FieldMapping] = fieldMappingIndex.get(fieldName)\n  }\n\n  object ObjectMapping {\n\n    case class DefaultObjectMapping(tpe: Type, fieldMappings: List[FieldMapping])(\n      implicit val pos: SourcePos\n    ) extends ObjectMapping\n\n    def apply(tpe: Type, fieldMappings: List[FieldMapping])(\n      implicit pos: SourcePos\n    ): ObjectMapping =\n      DefaultObjectMapping(tpe, fieldMappings.map(_.withParent(tpe)))\n  }\n\n  case class PrefixedMapping(tpe: Type, mappings: List[(List[String], ObjectMapping)])(\n    implicit val pos: SourcePos\n  ) extends TypeMapping\n\n  trait FieldMapping extends Product with Serializable {\n    def fieldName: String\n    def hidden: Boolean\n    def withParent(tpe: Type): FieldMapping\n    def pos: SourcePos\n  }\n\n  case class PrimitiveField(fieldName: String, hidden: Boolean = false)(implicit val pos: SourcePos) extends FieldMapping {\n    def withParent(tpe: Type): PrimitiveField = this\n  }\n\n  /**\n    * Abstract type of field mappings with effects.\n    */\n  trait EffectMapping extends FieldMapping\n\n  case class EffectField(fieldName: String, handler: EffectHandler[F], required: List[String] = Nil, hidden: Boolean = false)(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def withParent(tpe: Type): EffectField = this\n  }\n\n  /**\n   * Root effects can perform an intial effect prior to computing the resulting\n   * `Cursor` and effective `Query`.\n   *\n   * These effects are used to perform initial effectful setup for a query or to\n   * perform the effect associated with a GraphQL mutation. Convenience methods\n   * are provided to cover the cases where only one of the query or the cursor\n   * are computed.\n   *\n   * If only the query is computed the default root cursor for the mapping will\n   * be used. If only the cursor is computed the client query (after elaboration)\n   * is used unmodified ... in this case results of the performed effect can only\n   * be passed to the result construction stage via the environment associated\n   * with the returned cursor.\n   */\n  case class RootEffect private (fieldName: String, effect: (Query, Path, Env) => F[Result[(Query, Cursor)]])(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def hidden = false\n    def withParent(tpe: Type): RootEffect = this\n    def toRootStream: RootStream = RootStream(fieldName)((q, p, e) => Stream.eval(effect(q, p, e)))\n  }\n\n  object RootEffect {\n    /**\n     * Yields a `RootEffect` which performs both an initial effect and yields an effect-specific query and\n     * corresponding root cursor.\n     */\n    def apply(fieldName: String)(effect: (Query, Path, Env) => F[Result[(Query, Cursor)]])(implicit pos: SourcePos, di: DummyImplicit): RootEffect =\n      new RootEffect(fieldName, effect)\n\n    /**\n     * Yields a `RootEffect` which performs an initial effect which leaves the query and default root cursor\n     * unchanged.\n     */\n    def computeUnit(fieldName: String)(effect: Env => F[Result[Unit]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) =>\n          (for {\n            _  <- ResultT(effect(env))\n            qc <- ResultT(defaultRootCursor(query, path.rootTpe, None))\n          } yield qc.map(_.withEnv(env))).value\n      )\n\n    /**\n      * Yields a `RootEffect` which performs an initial effect and yields an effect-specific root cursor.\n      */\n    def computeCursor(fieldName: String)(effect: (Path, Env) => F[Result[Cursor]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) => effect(path, env).map(_.map(c => (query, c)))\n      )\n\n    /**\n      * Yields a `RootEffect` which performs an initial effect and yields an effect-specific query\n      * which is executed with respect to the default root cursor for the corresponding `Mapping`.\n      */\n    def computeChild(fieldName: String)(effect: (Query, Path, Env) => F[Result[Query]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) =>\n          (for {\n            child <- ResultT(Query.extractChild(query).toResultOrError(\"Root query has unexpected shape\").pure[F])\n            q     <- ResultT(effect(child, path, env).map(_.flatMap(Query.substChild(query, _).toResultOrError(\"Root query has unexpected shape\"))))\n            qc    <- ResultT(defaultRootCursor(q, path.rootTpe, None))\n          } yield qc.map(_.withEnv(env))).value\n      )\n  }\n\n  /**\n   * Root streams can perform an intial effect prior to emitting the resulting\n   * cursors and effective queries.\n   *\n   * Stream effects are used for GraphQL subscriptions. Convenience methods are\n   * provided to cover the cases where only one of the query or the cursor are\n   * computed\n   *\n   * If only the query is computed the default root cursor for the mapping will\n   * be used. If only the cursor is computed the client query (after elaboration)\n   * is used unmodified ... in this case results of the performed effect can only\n   * be passed to the result construction stage via the environment associated\n   * with the returned cursor.\n   */\n  case class RootStream private (fieldName: String, effect: (Query, Path, Env) => Stream[F, Result[(Query, Cursor)]])(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def hidden = false\n    def withParent(tpe: Type): RootStream = this\n  }\n\n  object RootStream {\n    /**\n     * Yields a `RootStream` which performs both an initial effect and yields an effect-specific query and\n     * corresponding root cursor.\n     */\n    def apply(fieldName: String)(effect: (Query, Path, Env) => Stream[F, Result[(Query, Cursor)]])(implicit pos: SourcePos, di: DummyImplicit): RootStream =\n      new RootStream(fieldName, effect)\n\n    /**\n      * Yields a `RootStream` which yields a stream of effect-specific root cursors.\n      *\n      * This form of effect is typically used to implement GraphQL subscriptions.\n      */\n    def computeCursor(fieldName: String)(effect: (Path, Env) => Stream[F, Result[Cursor]])(implicit pos: SourcePos): RootStream =\n      new RootStream(\n        fieldName,\n        (query, path, env) => effect(path, env).map(_.map(c => (query, c)))\n      )\n\n    /**\n      * Yields a `RootStream` which yields a stream of effect-specific queries\n      * which are executed with respect to the default root cursor for the\n      * corresponding `Mapping`.\n      *\n      * This form of effect is typically used to implement GraphQL subscriptions.\n      */\n    def computeChild(fieldName: String)(effect: (Query, Path, Env) => Stream[F, Result[Query]])(implicit pos: SourcePos): RootStream =\n      new RootStream(\n        fieldName,\n        (query, path, env) =>\n          Query.extractChild(query).fold(Stream.emit[F, Result[(Query, Cursor)]](Result.internalError(\"Root query has unexpected shape\"))) { child =>\n            effect(child, path, env).flatMap(child0 =>\n              Stream.eval(\n                (for {\n                  q  <- ResultT(child0.flatMap(Query.substChild(query, _).toResultOrError(\"Root query has unexpected shape\")).pure[F])\n                  qc <- ResultT(defaultRootCursor(q, path.rootTpe, None))\n                } yield qc.map(_.withEnv(env))).value\n              )\n            )\n          }\n      )\n  }\n\n  trait LeafMapping[T] extends TypeMapping {\n    def tpe: Type\n    def encoder: Encoder[T]\n    def scalaTypeName: String\n    def pos: SourcePos\n  }\n  object LeafMapping {\n\n    case class DefaultLeafMapping[T](tpe: Type, encoder: Encoder[T], scalaTypeName: String)(\n      implicit val pos: SourcePos\n    ) extends LeafMapping[T]\n\n    def apply[T: TypeName](tpe: Type)(implicit encoder: Encoder[T], pos: SourcePos): LeafMapping[T] =\n      DefaultLeafMapping(tpe, encoder, typeName)\n\n    def unapply[T](lm: LeafMapping[T]): Option[(Type, Encoder[T])] =\n      Some((lm.tpe, lm.encoder))\n  }\n\n  case class CursorField[T](fieldName: String, f: Cursor => Result[T], encoder: Encoder[T], required: List[String], hidden: Boolean)(\n    implicit val pos: SourcePos\n  ) extends FieldMapping {\n    def withParent(tpe: Type): CursorField[T] = this\n  }\n  object CursorField {\n    def apply[T](fieldName: String, f: Cursor => Result[T], required: List[String] = Nil, hidden: Boolean = false)(implicit encoder: Encoder[T], di: DummyImplicit): CursorField[T] =\n      new CursorField(fieldName, f, encoder, required, hidden)\n  }\n\n  case class Delegate(\n    fieldName: String,\n    mapping: Mapping[F],\n    join: (Query, Cursor) => Result[Query] = ComponentElaborator.TrivialJoin\n  )(implicit val pos: SourcePos) extends FieldMapping {\n    def hidden = false\n    def withParent(tpe: Type): Delegate = this\n  }\n\n  val selectElaborator: SelectElaborator = SelectElaborator.identity\n\n  lazy val componentElaborator = {\n    val componentMappings =\n      typeMappings.flatMap {\n        case om: ObjectMapping =>\n          om.fieldMappings.collect {\n            case Delegate(fieldName, mapping, join) =>\n              ComponentElaborator.ComponentMapping(schema.ref(om.tpe.toString), fieldName, mapping, join)\n          }\n        case _ => Nil\n      }\n\n    ComponentElaborator(componentMappings)\n  }\n\n  lazy val effectElaborator = {\n    val effectMappings =\n      typeMappings.flatMap {\n        case om: ObjectMapping =>\n          om.fieldMappings.collect {\n            case EffectField(fieldName, handler, _, _) =>\n              EffectElaborator.EffectMapping(schema.ref(om.tpe.toString), fieldName, handler)\n          }\n        case _ => Nil\n      }\n\n    EffectElaborator(effectMappings)\n  }\n\n  def compilerPhases: List[QueryCompiler.Phase] = List(selectElaborator, componentElaborator, effectElaborator)\n\n  lazy val compiler = new QueryCompiler(schema, compilerPhases)\n\n  val interpreter: QueryInterpreter[F] = new QueryInterpreter(this)\n\n  /** Cursor positioned at a GraphQL result leaf */\n  case class LeafCursor(context: Context, focus: Any, parent: Option[Cursor], env: Env) extends Cursor {\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    def mkChild(context: Context = context, focus: Any = focus): LeafCursor =\n      LeafCursor(context, focus, Some(this), Env.empty)\n\n    def isLeaf: Boolean = tpe.isLeaf\n\n    def asLeaf: Result[Json] =\n      encoderForLeaf(tpe).map(enc => enc(focus).success).getOrElse(Result.internalError(\n        s\"Cannot encode value $focus at ${context.path.reverse.mkString(\"/\")} (of GraphQL type ${context.tpe}). Did you forget a LeafMapping?\".stripMargin.trim\n      ))\n\n    def preunique: Result[Cursor] = {\n      val listTpe = tpe.nonNull.list\n      focus match {\n        case _: List[_] => mkChild(context.asType(listTpe), focus).success\n        case _ =>\n          Result.internalError(s\"Expected List type, found $focus for ${listTpe}\")\n      }\n    }\n\n    def isList: Boolean =\n      tpe match {\n        case ListType(_) => true\n        case _ => false\n      }\n\n    def asList[C](factory: Factory[Cursor, C]): Result[C] = (tpe, focus) match {\n      case (ListType(tpe), it: List[_]) => it.view.map(f => mkChild(context.asType(tpe), focus = f)).to(factory).success\n      case _ => Result.internalError(s\"Expected List type, found $tpe\")\n    }\n\n    def listSize: Result[Int] = (tpe, focus) match {\n      case (ListType(_), it: List[_]) => it.size.success\n      case _ => Result.internalError(s\"Expected List type, found $tpe\")\n    }\n\n    def isNullable: Boolean =\n      tpe match {\n        case NullableType(_) => true\n        case _ => false\n      }\n\n    def asNullable: Result[Option[Cursor]] =\n      (tpe, focus) match {\n        case (NullableType(_), None) => None.success\n        case (NullableType(tpe), Some(v)) => Some(mkChild(context.asType(tpe), focus = v)).success\n        case _ => Result.internalError(s\"Not nullable at ${context.path}\")\n      }\n\n    def isDefined: Result[Boolean] =\n      (tpe, focus) match {\n        case (NullableType(_), opt: Option[_]) => opt.isDefined.success\n        case _ => Result.internalError(s\"Not nullable at ${context.path}\")\n      }\n\n    def narrowsTo(subtpe: TypeRef): Boolean = false\n    def narrow(subtpe: TypeRef): Result[Cursor] =\n      Result.failure(s\"Cannot narrow $tpe to $subtpe\")\n\n    def hasField(fieldName: String): Boolean = false\n    def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      Result.failure(s\"Cannot select field '$fieldName' from leaf type $tpe\")\n  }\n\n  /**\n   * Proxy `Cursor` which applies a function to the focus of an underlying `LeafCursor`.\n   */\n  case class FieldTransformCursor[T : ClassTag : TypeName](underlying: Cursor, f: T => Result[T]) extends ProxyCursor(underlying) {\n    override def withEnv(env: Env): Cursor = new FieldTransformCursor(underlying.withEnv(env), f)\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      underlying.field(fieldName, resultName).flatMap {\n        case l: LeafCursor =>\n          for {\n            focus  <- l.as[T]\n            ffocus <- f(focus)\n          } yield l.copy(focus = ffocus)\n        case _ =>\n          Result.internalError(s\"Expected leaf cursor for field $fieldName\")\n      }\n  }\n\n  /**\n   * Construct a GraphQL response from the possibly absent result `data`\n   * and a collection of errors.\n   */\n  def mkResponse(data: Option[Json], errors: Chain[Problem]): Json = {\n    val dataField = data.map { value => (\"data\", value) }.toList\n    val fields =\n      (dataField, errors.toList) match {\n        case (Nil, Nil)   => List((\"errors\", Json.fromValues(List(Problem(\"Invalid query\").asJson))))\n        case (data, Nil)  => data\n        case (data, errs) => (\"errors\", errs.asJson) :: data\n      }\n    Json.fromFields(fields)\n  }\n\n  /** Construct a GraphQL response from a `Result`. */\n  def mkResponse(result: Result[Json]): F[Json] =\n    result match {\n      case Result.InternalError(err) => M.raiseError(err)\n      case _ => mkResponse(result.toOption, result.toProblems).pure[F]\n    }\n}\n\nabstract class ComposedMapping[F[_]](implicit val M: MonadThrow[F]) extends Mapping[F] {\n  override def mkCursorForField(parent: Cursor, fieldName: String, resultName: Option[String]): Result[Cursor] = {\n    val context = parent.context\n    val fieldContext = context.forFieldOrAttribute(fieldName, resultName)\n    fieldMapping(context, fieldName) match {\n      case Some(_) =>\n        ComposedCursor(fieldContext, parent.env).success\n      case _ =>\n        super.mkCursorForField(parent, fieldName, resultName)\n    }\n  }\n\n  case class ComposedCursor(context: Context, env: Env) extends AbstractCursor {\n    val focus = null\n    val parent = None\n\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    override def hasField(fieldName: String): Boolean =\n      fieldMapping(context, fieldName).isDefined\n\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      mkCursorForField(this, fieldName, resultName)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.implicits._\n\nobject QueryMinimizer {\n  import Ast._\n\n  def minimizeText(text: String): Either[String, String] = {\n    for {\n      doc <- GraphQLParser.Document.parseAll(text).leftMap(_.expected.toList.mkString(\",\"))\n    } yield minimizeDocument(doc)\n  }\n\n  def minimizeDocument(doc: Document): String = {\n    import OperationDefinition._\n    import OperationType._\n    import Selection._\n    import Value._\n\n    def renderDefinition(defn: Definition): String =\n      defn match {\n        case e: ExecutableDefinition => renderExecutableDefinition(e)\n        case _ => \"\"\n      }\n\n    def renderExecutableDefinition(ex: ExecutableDefinition): String =\n      ex match {\n        case op: OperationDefinition => renderOperationDefinition(op)\n        case frag: FragmentDefinition => renderFragmentDefinition(frag)\n      }\n\n    def renderOperationDefinition(op: OperationDefinition): String =\n      op match {\n        case qs: QueryShorthand => renderSelectionSet(qs.selectionSet)\n        case op: Operation => renderOperation(op)\n      }\n\n    def renderOperation(op: Operation): String =\n      renderOperationType(op.operationType) +\n      op.name.map(nme => s\" ${nme.value}\").getOrElse(\"\") +\n      renderVariableDefns(op.variables)+\n      renderDirectives(op.directives)+\n      renderSelectionSet(op.selectionSet)\n\n    def renderOperationType(op: OperationType): String =\n      op match {\n        case Query => \"query\"\n        case Mutation => \"mutation\"\n        case Subscription => \"subscription\"\n      }\n\n    def renderDirectives(dirs: List[Directive]): String =\n      dirs.map { case Directive(name, args) => s\"@${name.value}${renderArguments(args)}\" }.mkString(\"\")\n\n    def renderVariableDefns(vars: List[VariableDefinition]): String =\n      vars match {\n        case Nil => \"\"\n        case _ =>\n          vars.map {\n            case VariableDefinition(name, tpe, default, dirs) =>\n              s\"$$${name.value}:${tpe.name}${default.map(v => s\"=${renderValue(v)}\").getOrElse(\"\")}${renderDirectives(dirs)}\"\n          }.mkString(\"(\", \",\", \")\")\n      }\n\n    def renderSelectionSet(sels: List[Selection]): String =\n      sels match {\n        case Nil => \"\"\n        case _ => sels.map(renderSelection).mkString(\"{\", \",\", \"}\")\n      }\n\n    def renderSelection(sel: Selection): String =\n      sel match {\n        case f: Field => renderField(f)\n        case s: FragmentSpread => renderFragmentSpread(s)\n        case i: InlineFragment => renderInlineFragment(i)\n      }\n\n    def renderField(f: Field) = {\n      f.alias.map(a => s\"${a.value}:\").getOrElse(\"\")+\n      f.name.value+\n      renderArguments(f.arguments)+\n      renderDirectives(f.directives)+\n      renderSelectionSet(f.selectionSet)\n    }\n\n    def renderArguments(args: List[(Name, Value)]): String =\n      args match {\n        case Nil => \"\"\n        case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"(\", \",\", \")\")\n      }\n\n    def renderInputObject(args: List[(Name, Value)]): String =\n      args match {\n        case Nil => \"\"\n        case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"{\", \",\", \"}\")\n      }\n\n    def renderTypeCondition(tpe: Type): String =\n      s\"on ${tpe.name}\"\n\n    def renderFragmentDefinition(frag: FragmentDefinition): String =\n      s\"fragment ${frag.name.value} ${renderTypeCondition(frag.typeCondition)}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n\n    def renderFragmentSpread(spread: FragmentSpread): String =\n      s\"...${spread.name.value}${renderDirectives(spread.directives)}\"\n\n    def renderInlineFragment(frag: InlineFragment): String =\n      s\"...${frag.typeCondition.map(renderTypeCondition).getOrElse(\"\")}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n\n    def renderValue(v: Value): String =\n      v match {\n        case Variable(name) => s\"$$${name.value}\"\n        case IntValue(value) => value.toString\n        case FloatValue(value) => value.toString\n        case StringValue(value) => s\"\"\"\"$value\"\"\"\"\n        case BooleanValue(value) => value.toString\n        case NullValue => \"null\"\n        case EnumValue(name) => name.value\n        case ListValue(values) => values.map(renderValue).mkString(\"[\", \",\", \"]\")\n        case ObjectValue(fields) => renderInputObject(fields)\n      }\n\n    doc.map(renderDefinition).mkString(\",\")\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.parse.{LocationMap, Parser, Parser0}\nimport cats.parse.Parser._\nimport cats.parse.Numbers._\nimport cats.parse.Rfc5234.{cr, crlf, digit, hexdig, lf}\nimport cats.implicits._\nimport CommentedText._\nimport Literals._\nimport scala.util.matching.Regex\n\nobject GraphQLParser {\n\n  val nameInitial    = ('A' to 'Z') ++ ('a' to 'z') ++ Seq('_')\n  val nameSubsequent = nameInitial ++ ('0' to '9')\n\n  def keyword(s: String) = token(string(s) <* not(charIn(nameSubsequent)))\n\n  def punctuation(s: String) = token(string(s))\n\n  lazy val Document: Parser0[Ast.Document] =\n    (whitespace.void | comment).rep0 *> Definition.rep0 <* Parser.end\n\n  lazy val Definition: Parser[Ast.Definition] =\n    ExecutableDefinition | TypeSystemDefinition | TypeSystemExtension\n\n  lazy val TypeSystemDefinition: Parser[Ast.TypeSystemDefinition] = {\n    val SchemaDefinition: Parser[Ast.SchemaDefinition] =\n      ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0)).map {\n        case (dirs, rootdefs) => Ast.SchemaDefinition(rootdefs, dirs.getOrElse(Nil))\n      }\n\n    def typeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.TypeDefinition] = {\n\n      def scalarTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ScalarTypeDefinition] =\n        ((keyword(\"scalar\") *> Name) ~ Directives.?).map {\n          case (name, dirs) => Ast.ScalarTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n        }\n\n      def objectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ObjectTypeDefinition] =\n        ((keyword(\"type\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n          case (((name, ifs), dirs), fields) => Ast.ObjectTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n        }\n\n      def interfaceTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InterfaceTypeDefinition] =\n        ((keyword(\"interface\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n          case (((name, ifs), dirs), fields) => Ast.InterfaceTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n        }\n\n      def unionTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.UnionTypeDefinition] =\n        ((keyword(\"union\") *> Name) ~ Directives.? ~ UnionMemberTypes).map {\n          case ((name, dirs), members) => Ast.UnionTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), members)\n        }\n\n      def enumTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.EnumTypeDefinition] =\n        ((keyword(\"enum\") *> Name) ~ Directives.? ~ EnumValuesDefinition).map {\n          case ((name, dirs), values) => Ast.EnumTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), values)\n        }\n\n      def inputObjectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InputObjectTypeDefinition] =\n        ((keyword(\"input\") *> Name) ~ Directives.? ~ InputFieldsDefinition).map {\n          case ((name, dirs), fields) => Ast.InputObjectTypeDefinition(name, desc.map(_.value), fields, dirs.getOrElse(Nil))\n        }\n\n      scalarTypeDefinition(desc)|\n        objectTypeDefinition(desc) |\n        interfaceTypeDefinition(desc) |\n        unionTypeDefinition(desc) |\n        enumTypeDefinition(desc) |\n        inputObjectTypeDefinition(desc)\n    }\n\n    def directiveDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.DirectiveDefinition] =\n      ((keyword(\"directive\") *> punctuation(\"@\") *> Name) ~\n         ArgumentsDefinition.? ~ (keyword(\"repeatable\").? <* keyword(\"on\")) ~ DirectiveLocations).map {\n        case (((name, args), rpt), locs) => Ast.DirectiveDefinition(name, desc.map(_.value), args.getOrElse(Nil), rpt.isDefined, locs)\n      }\n\n    SchemaDefinition |\n      Description.?.with1.flatMap { desc =>\n        typeDefinition(desc) | directiveDefinition(desc)\n      }\n  }\n\n  lazy val TypeSystemExtension: Parser[Ast.TypeSystemExtension] = {\n\n    val SchemaExtension: Parser[Ast.SchemaExtension] =\n      ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0).?).map {\n        case (dirs, rootdefs) => Ast.SchemaExtension(rootdefs.getOrElse(Nil), dirs.getOrElse(Nil))\n      }\n\n    val TypeExtension: Parser[Ast.TypeExtension] = {\n\n      val ScalarTypeExtension: Parser[Ast.ScalarTypeExtension] =\n        ((keyword(\"scalar\") *> NamedType) ~ Directives.?).map {\n          case (((name), dirs)) => Ast.ScalarTypeExtension(name, dirs.getOrElse(Nil))\n        }\n\n      val ObjectTypeExtension: Parser[Ast.ObjectTypeExtension] =\n        ((keyword(\"type\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n          case (((name, ifs), dirs), fields) => Ast.ObjectTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n        }\n\n      val InterfaceTypeExtension: Parser[Ast.InterfaceTypeExtension] =\n        ((keyword(\"interface\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n          case (((name, ifs), dirs), fields) => Ast.InterfaceTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n        }\n\n      val UnionTypeExtension: Parser[Ast.UnionTypeExtension] =\n        ((keyword(\"union\") *> NamedType) ~ Directives.? ~ UnionMemberTypes.?).map {\n          case (((name), dirs), members) => Ast.UnionTypeExtension(name, dirs.getOrElse(Nil), members.getOrElse(Nil))\n        }\n\n      val EnumTypeExtension: Parser[Ast.EnumTypeExtension] =\n        ((keyword(\"enum\") *> NamedType) ~ Directives.? ~ EnumValuesDefinition.?).map {\n          case (((name), dirs), values) => Ast.EnumTypeExtension(name, dirs.getOrElse(Nil), values.getOrElse(Nil))\n        }\n\n      val InputObjectTypeExtension: Parser[Ast.InputObjectTypeExtension] =\n        ((keyword(\"input\") *> NamedType) ~ Directives.? ~ InputFieldsDefinition.?).map {\n          case (((name), dirs), fields) => Ast.InputObjectTypeExtension(name, dirs.getOrElse(Nil), fields.getOrElse(Nil))\n        }\n\n      ScalarTypeExtension|\n      ObjectTypeExtension|\n      InterfaceTypeExtension|\n      UnionTypeExtension|\n      EnumTypeExtension|\n      InputObjectTypeExtension\n    }\n\n    keyword(\"extend\") *> (SchemaExtension | TypeExtension)\n  }\n\n  lazy val RootOperationTypeDefinition: Parser[Ast.RootOperationTypeDefinition] =\n    (OperationType ~ punctuation(\":\") ~ NamedType ~ Directives).map {\n      case (((optpe, _), tpe), dirs) => Ast.RootOperationTypeDefinition(optpe, tpe, dirs)\n    }\n\n\n  lazy val Description = StringValue\n\n  lazy val ImplementsInterfaces =\n    (keyword(\"implements\") ~ punctuation(\"&\").?) *> NamedType.repSep0(punctuation(\"&\"))\n\n  lazy val FieldsDefinition: Parser[List[Ast.FieldDefinition]] =\n    braces(FieldDefinition.rep0)\n\n  lazy val FieldDefinition: Parser[Ast.FieldDefinition] =\n    (Description.?.with1 ~ Name ~ ArgumentsDefinition.? ~ punctuation(\":\") ~ Type ~ Directives.?).map {\n      case (((((desc, name), args), _), tpe), dirs) => Ast.FieldDefinition(name, desc.map(_.value), args.getOrElse(Nil), tpe, dirs.getOrElse(Nil))\n    }\n\n  lazy val ArgumentsDefinition: Parser[List[Ast.InputValueDefinition]] =\n    parens(InputValueDefinition.rep0)\n\n  lazy val InputFieldsDefinition: Parser[List[Ast.InputValueDefinition]] =\n    braces(InputValueDefinition.rep0)\n\n  lazy val InputValueDefinition: Parser[Ast.InputValueDefinition] =\n    (Description.?.with1 ~ (Name <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n      case ((((desc, name), tpe), dv), dirs) => Ast.InputValueDefinition(name, desc.map(_.value), tpe, dv, dirs.getOrElse(Nil))\n    }\n\n  lazy val UnionMemberTypes: Parser[List[Ast.Type.Named]] =\n    (punctuation(\"=\") *> punctuation(\"|\").?) *> NamedType.repSep0(punctuation(\"|\"))\n\n  lazy val EnumValuesDefinition: Parser[List[Ast.EnumValueDefinition]] =\n    braces(EnumValueDefinition.rep0)\n\n  lazy val EnumValueDefinition: Parser[Ast.EnumValueDefinition] =\n    (Description.?.with1 ~ Name ~ Directives.?).map {\n      case ((desc, name), dirs) => Ast.EnumValueDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n    }\n\n  lazy val DirectiveLocations: Parser0[List[Ast.DirectiveLocation]] =\n    punctuation(\"|\").? *> DirectiveLocation.repSep0(punctuation(\"|\"))\n\n  lazy val DirectiveLocation: Parser[Ast.DirectiveLocation] =\n    keyword(\"QUERY\")       .as(Ast.DirectiveLocation.QUERY) |\n    keyword(\"MUTATION\")    .as(Ast.DirectiveLocation.MUTATION) |\n    keyword(\"SUBSCRIPTION\").as(Ast.DirectiveLocation.SUBSCRIPTION) |\n    keyword(\"FIELD_DEFINITION\").as(Ast.DirectiveLocation.FIELD_DEFINITION) |\n    keyword(\"FIELD\").as(Ast.DirectiveLocation.FIELD) |\n    keyword(\"FRAGMENT_DEFINITION\").as(Ast.DirectiveLocation.FRAGMENT_DEFINITION) |\n    keyword(\"FRAGMENT_SPREAD\").as(Ast.DirectiveLocation.FRAGMENT_SPREAD) |\n    keyword(\"INLINE_FRAGMENT\").as(Ast.DirectiveLocation.INLINE_FRAGMENT) |\n    keyword(\"VARIABLE_DEFINITION\").as(Ast.DirectiveLocation.VARIABLE_DEFINITION) |\n    keyword(\"SCHEMA\").as(Ast.DirectiveLocation.SCHEMA) |\n    keyword(\"SCALAR\").as(Ast.DirectiveLocation.SCALAR) |\n    keyword(\"OBJECT\").as(Ast.DirectiveLocation.OBJECT) |\n    keyword(\"ARGUMENT_DEFINITION\").as(Ast.DirectiveLocation.ARGUMENT_DEFINITION) |\n    keyword(\"INTERFACE\").as(Ast.DirectiveLocation.INTERFACE) |\n    keyword(\"UNION\").as(Ast.DirectiveLocation.UNION) |\n    keyword(\"ENUM_VALUE\").as(Ast.DirectiveLocation.ENUM_VALUE) |\n    keyword(\"ENUM\").as(Ast.DirectiveLocation.ENUM) |\n    keyword(\"INPUT_OBJECT\").as(Ast.DirectiveLocation.INPUT_OBJECT) |\n    keyword(\"INPUT_FIELD_DEFINITION\").as(Ast.DirectiveLocation.INPUT_FIELD_DEFINITION)\n\n  lazy val ExecutableDefinition: Parser[Ast.ExecutableDefinition] =\n    OperationDefinition | FragmentDefinition\n\n  lazy val OperationDefinition: Parser[Ast.OperationDefinition] =\n    QueryShorthand | Operation\n\n  lazy val QueryShorthand: Parser[Ast.OperationDefinition.QueryShorthand] =\n    SelectionSet.map(Ast.OperationDefinition.QueryShorthand.apply)\n\n  lazy val Operation: Parser[Ast.OperationDefinition.Operation] =\n    (OperationType ~ Name.? ~ VariableDefinitions.? ~ Directives ~ SelectionSet).map {\n      case ((((op, name), vars), dirs), sels) => Ast.OperationDefinition.Operation(op, name, vars.orEmpty, dirs, sels)\n    }\n\n  lazy val OperationType: Parser[Ast.OperationType] =\n    keyword(\"query\")       .as(Ast.OperationType.Query) |\n    keyword(\"mutation\")    .as(Ast.OperationType.Mutation) |\n    keyword(\"subscription\").as(Ast.OperationType.Subscription)\n\n  lazy val SelectionSet: Parser[List[Ast.Selection]] = recursive[List[Ast.Selection]] { rec =>\n\n    val Alias: Parser[Ast.Name] =\n      Name <* punctuation(\":\")\n\n    val Field: Parser[Ast.Selection.Field] =\n      (Alias.backtrack.?.with1 ~ Name ~ Arguments.? ~ Directives ~ rec.?).map {\n        case ((((alias, name), args), dirs), sel) => Ast.Selection.Field(alias, name, args.orEmpty, dirs, sel.orEmpty)\n      }\n\n    val FragmentSpread: Parser[Ast.Selection.FragmentSpread] =\n      (FragmentName ~ Directives).map{ case (name, dirs) => Ast.Selection.FragmentSpread.apply(name, dirs)}\n\n    val InlineFragment: Parser[Ast.Selection.InlineFragment] =\n      ((TypeCondition.? ~ Directives).with1 ~ rec).map {\n        case ((cond, dirs), sel) => Ast.Selection.InlineFragment(cond, dirs, sel)\n      }\n\n    val Selection: Parser[Ast.Selection] =\n      Field |\n      (punctuation(\"...\") *> (InlineFragment | FragmentSpread))\n\n    braces(Selection.rep0)\n  }\n\n  lazy val Arguments: Parser[List[(Ast.Name, Ast.Value)]] =\n    parens(Argument.rep0)\n\n  lazy val Argument: Parser[(Ast.Name, Ast.Value)] =\n    (Name <* punctuation(\":\")) ~ Value\n\n  lazy val FragmentName: Parser[Ast.Name] =\n    not(string(\"on\")).with1 *> Name\n\n  lazy val FragmentDefinition: Parser[Ast.FragmentDefinition] =\n    ((keyword(\"fragment\") *> FragmentName) ~ TypeCondition ~ Directives ~ SelectionSet).map {\n      case (((name, cond), dirs), sel) => Ast.FragmentDefinition(name, cond, dirs, sel)\n    }\n\n  lazy val TypeCondition: Parser[Ast.Type.Named] =\n    keyword(\"on\") *> NamedType\n\n  lazy val Value: Parser[Ast.Value] = recursive[Ast.Value] { rec =>\n\n    val NullValue: Parser[Ast.Value.NullValue.type] =\n      keyword(\"null\").as(Ast.Value.NullValue)\n\n    lazy val EnumValue: Parser[Ast.Value.EnumValue] =\n      (not(string(\"true\") | string(\"false\") | string(\"null\")).with1 *> Name)\n        .map(Ast.Value.EnumValue.apply)\n\n    val ListValue: Parser[Ast.Value.ListValue] =\n      token(squareBrackets(rec.rep0).map(Ast.Value.ListValue.apply))\n\n    val NumericLiteral: Parser[Ast.Value] = {\n\n      def narrow(d: BigDecimal): Ast.Value.FloatValue =\n        Ast.Value.FloatValue(d.toDouble)\n\n      token(\n        (intLiteral ~ (char('.') *> digit.rep.string).? ~ ((char('e') | char('E')) *> intLiteral.string).?)\n          .map {\n            case ((a, Some(b)), None) => narrow(BigDecimal(s\"$a.$b\"))\n            case ((a, None), Some(c)) => narrow(BigDecimal(s\"${a}E$c\"))\n            case ((a, Some(b)), Some(c)) => narrow(BigDecimal(s\"$a.${b}E$c\"))\n            case ((a, None), None) => Ast.Value.IntValue(a)\n          }\n      )\n    }\n\n    val BooleanValue: Parser[Ast.Value.BooleanValue] =\n      token(booleanLiteral).map(Ast.Value.BooleanValue.apply)\n\n    val ObjectField: Parser[(Ast.Name, Ast.Value)] =\n      (Name <* punctuation(\":\")) ~ rec\n\n    val ObjectValue: Parser[Ast.Value.ObjectValue] =\n      braces(ObjectField.rep0).map(Ast.Value.ObjectValue.apply)\n\n    Variable |\n      NumericLiteral |\n      StringValue |\n      BooleanValue |\n      NullValue |\n      EnumValue |\n      ListValue |\n      ObjectValue\n  }\n\n  lazy val StringValue: Parser[Ast.Value.StringValue] =\n    token(stringLiteral).map(Ast.Value.StringValue.apply)\n\n  lazy val VariableDefinitions: Parser[List[Ast.VariableDefinition]] =\n    parens(VariableDefinition.rep0)\n\n  lazy val VariableDefinition: Parser[Ast.VariableDefinition] =\n    ((Variable <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n      case (((v, tpe), dv), dirs) => Ast.VariableDefinition(v.name, tpe, dv, dirs.getOrElse(Nil))\n    }\n\n  lazy val Variable: Parser[Ast.Value.Variable] =\n    punctuation(\"$\") *> Name.map(Ast.Value.Variable.apply)\n\n  lazy val DefaultValue: Parser[Ast.Value] =\n    punctuation(\"=\") *> Value\n\n  lazy val Type: Parser[Ast.Type] = recursive[Ast.Type] { rec =>\n\n    lazy val ListType: Parser[Ast.Type.List] =\n      squareBrackets(rec).map(Ast.Type.List.apply)\n\n    val namedMaybeNull: Parser[Ast.Type] = (NamedType ~ punctuation(\"!\").?).map {\n      case (t, None) => t\n      case (t, _) => Ast.Type.NonNull(Left(t))\n    }\n\n    val listMaybeNull: Parser[Ast.Type] = (ListType ~ punctuation(\"!\").?).map {\n      case (t, None) => t\n      case (t, _) => Ast.Type.NonNull(Right(t))\n    }\n\n    namedMaybeNull | listMaybeNull\n  }\n\n  lazy val NamedType: Parser[Ast.Type.Named] =\n    Name.map(Ast.Type.Named.apply)\n\n  lazy val Directives: Parser0[List[Ast.Directive]] =\n    Directive.rep0\n\n  lazy val Directive: Parser[Ast.Directive] =\n    punctuation(\"@\") *> (Name ~ Arguments.?).map { case (n, ods) => Ast.Directive(n, ods.orEmpty)}\n\n  lazy val Name: Parser[Ast.Name] =\n    token(charIn(nameInitial) ~ charIn(nameSubsequent).rep0).map {\n      case (h, t) => Ast.Name((h :: t).mkString)\n    }\n\n  def toResult[T](text: String, pr: Either[Parser.Error, T]): Result[T] =\n    Result.fromEither(pr.leftMap { e =>\n      val lm = LocationMap(text)\n      lm.toLineCol(e.failedAtOffset) match {\n        case Some((row, col)) =>\n          lm.getLine(row) match {\n            case Some(line) =>\n              s\"\"\"Parse error at line $row column $col\n                  |$line\n                  |${List.fill(col)(\" \").mkString}^\"\"\".stripMargin\n            case None => \"Malformed query\" //This is probably a bug in Cats Parse as it has given us the (row, col) index\n          }\n        case None => \"Truncated query\"\n      }\n    })\n}\n\nobject CommentedText {\n\n  val whitespace: Parser[Char] = charWhere(_.isWhitespace)\n\n  val skipWhitespace: Parser0[Unit] =\n    charsWhile0(c => c.isWhitespace || c == ',').void.withContext(\"whitespace\")\n\n  /** Parser that consumes a comment */\n  val comment: Parser[Unit] =\n    (char('#') *> (charWhere(c => c != '\\n' && c != '\\r')).rep0 <* charIn('\\n', '\\r') <* skipWhitespace).void.withContext(\"comment\")\n\n  /** Turns a parser into one that skips trailing whitespace and comments */\n  def token[A](p: Parser[A]): Parser[A] =\n    p <* skipWhitespace <* comment.rep0\n\n  def token0[A](p: Parser0[A]): Parser0[A] =\n    p <* skipWhitespace <* comment.rep0\n\n  /**\n   * Consumes `left` and `right`, including the trailing and preceding whitespace,\n   * respectively, and returns the value of `p`.\n   */\n  private def _bracket[A,B,C](left: Parser[B], p: Parser0[A], right: Parser[C]): Parser[A] =\n    token(left) *> token0(p) <* token(right)\n\n  /** Turns a parser into one that consumes surrounding parentheses `()` */\n  def parens[A](p: Parser0[A]): Parser[A] =\n    _bracket(char('('), p, char(')')).withContext(s\"parens(${p.toString})\")\n\n  /** Turns a parser into one that consumes surrounding curly braces `{}` */\n  def braces[A](p: Parser0[A]): Parser[A] =\n    _bracket(char('{'), p, char('}')).withContext(s\"braces(${p.toString})\")\n\n  /** Turns a parser into one that consumes surrounding square brackets `[]` */\n  def squareBrackets[A](p: Parser0[A]): Parser[A] =\n    _bracket(char('['), p, char(']')).withContext(s\"squareBrackets(${p.toString})\")\n}\n\nobject Literals {\n\n  val stringLiteral: Parser[String] = {\n\n    val lineTerminator: Parser[String] = (lf | cr | crlf).string\n\n    val sourceCharacter: Parser[String] = (charIn(0x0009.toChar, 0x000A.toChar, 0x000D.toChar) | charIn(0x0020.toChar to 0xFFFF.toChar)).string\n\n    val escapedUnicode: Parser[String] = string(\"\\\\u\") *>\n      hexdig\n        .repExactlyAs[String](4)\n        .map(hex => Integer.parseInt(hex, 16).toChar.toString)\n\n    val escapedCharacter: Parser[String] = char('\\\\') *>\n      (\n        char('\"').as(\"\\\"\") |\n          char('\\\\').as(\"\\\\\") |\n          char('/').as(\"/\") |\n          char('b').as(\"\\b\") |\n          char('f').as(\"\\f\") |\n          char('n').as(\"\\n\") |\n          char('r').as(\"\\r\") |\n          char('t').as(\"\\t\")\n      )\n\n    val stringCharacter: Parser[String] = (\n      (not(charIn('\"', '\\\\') | lineTerminator).with1 *> sourceCharacter) |\n        escapedUnicode |\n       escapedCharacter\n    )\n\n    val blockStringCharacter: Parser[String] = string(\"\\\\\\\"\\\"\\\"\").as(\"\\\"\\\"\\\"\") |\n      (not(string(\"\\\"\\\"\\\"\")).with1 *> sourceCharacter)\n\n    //https://spec.graphql.org/June2018/#BlockStringValue()\n    //TODO this traverses over lines a hideous number of times(but matching the\n    //algorithm in the spec). Can it be optimized?\n    val blockQuotesInner: Parser0[String] = blockStringCharacter.repAs0[String].map { str =>\n      val isWhitespace: Regex = \"[ \\t]*\".r\n      var commonIndent: Int = -1\n      var lineNum: Int = 0\n      for (line <- str.linesIterator) {\n        if (lineNum != 0) {\n          val len = line.length()\n          val indent = line.takeWhile(c => c == ' ' || c == '\\t').length()\n          if (indent < len) {\n            if (commonIndent < 0 || indent < commonIndent) {\n              commonIndent = indent\n            }\n          }\n        }\n        lineNum = lineNum + 1\n      }\n      val formattedReversed: List[String] = if ( commonIndent >= 0) {\n        str.linesIterator.foldLeft[List[String]](Nil) {\n          (acc, l) => if (acc == Nil) l :: acc else l.drop(commonIndent) :: acc\n        }\n      } else {\n        str.linesIterator.toList\n      }\n      val noTrailingEmpty = formattedReversed.dropWhile(isWhitespace.matches(_)).reverse\n      noTrailingEmpty.dropWhile(isWhitespace.matches(_)).mkString(\"\\n\")\n    }\n\n\n    (not(string(\"\\\"\\\"\\\"\")).with1 *> stringCharacter.repAs0[String].with1.surroundedBy(char('\"'))) | blockQuotesInner.with1.surroundedBy(string(\"\\\"\\\"\\\"\"))\n\n  }\n\n  val intLiteral: Parser[Int] =\n    bigInt.flatMap {\n      case v if v.isValidInt => pure(v.toInt)\n      case v => failWith(s\"$v is larger than max int\")\n    }\n\n  val booleanLiteral: Parser[Boolean] = string(\"true\").as(true) | string(\"false\").as(false)\n\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.implicits._\nimport io.circe.Json\nimport org.tpolecat.sourcepos.SourcePos\n\nimport syntax._\nimport Ast.{DirectiveLocation, InterfaceTypeDefinition, ObjectTypeDefinition, TypeDefinition, UnionTypeDefinition}\nimport Query._\nimport ScalarType._\nimport UntypedOperation._\nimport Value._\n\n/**\n * Representation of a GraphQL schema\n *\n * A `Schema` is a collection of type and directive declarations.\n */\ntrait Schema {\n\n  def pos: SourcePos\n\n  /** The types defined by this `Schema` prior to any extensions. */\n  def baseTypes: List[NamedType]\n\n  /** The types defined by this `Schema` with any extensions applied. */\n  lazy val types: List[NamedType] =\n    if (typeExtensions.isEmpty) baseTypes\n    else baseTypes.map(extendType(typeExtensions))\n\n  /** The directives defined by this `Schema`. */\n  def directives: List[DirectiveDef]\n\n  /** The schema extensions defined by this `Schema` */\n  def schemaExtensions: List[SchemaExtension]\n\n  /** The type extensions defined by this `Schema` */\n  def typeExtensions: List[TypeExtension]\n\n  /** A reference by name to a type defined by this `Schema`.\n   *\n   * `TypeRef`s refer to types defined in this schema by name and hence\n   * can be used as part of mutually recursive type definitions.\n   */\n  def ref(tpnme: String): TypeRef = new TypeRef(this, tpnme)\n\n  /**\n   * Alias for `ref` for use within constructors of concrete\n   * `Schema` values.\n   */\n  protected def TypeRef(tpnme: String): TypeRef = ref(tpnme)\n\n  /**\n   * The default type of a GraphQL schema\n   *\n   * Unless a type named `\"Schema\"` is explicitly defined as part of\n   * this `Schema` a definition of the form,\n   *\n   * ```\n   * type Schema {\n   *   query: Query!\n   *   mutation: Mutation\n   *   subscription: Subscription\n   * }\n   * ```\n   *\n   * is used.\n   */\n  def defaultSchemaType: NamedType = {\n    def mkRootDef(fieldName: String)(tpe: NamedType): Field =\n      Field(fieldName, None, Nil, tpe, Nil)\n\n    ObjectType(\n      name = \"Schema\",\n      description = None,\n      fields =\n        List(\n          definition(\"Query\").map(mkRootDef(\"query\")),\n          definition(\"Mutation\").map(mkRootDef(\"mutation\")),\n          definition(\"Subscription\").map(mkRootDef(\"subscription\"))\n        ).flatten,\n      interfaces = Nil,\n      directives = Nil\n    )\n  }\n\n  /**\n   * Look up by name a type defined in this `Schema`.\n   *\n   * Yields the type, if defined, `None` otherwise.\n   */\n  def definition(name: String): Option[NamedType] =\n    typeIndex.get(name).orElse(ScalarType.builtIn(name)).map(_.dealias)\n\n  private lazy val typeIndex = types.map(tpe => (tpe.name, tpe)).toMap\n\n  def ref(tp: Type): Option[TypeRef] = tp match {\n    case nt: NamedType if types.exists(_.name == nt.name) => Some(ref(nt.name))\n    case _ => None\n  }\n\n  def baseSchemaType: NamedType = definition(\"Schema\").getOrElse(defaultSchemaType)\n\n  /**\n   * The schema type.\n   *\n   * Either the explicitly defined type named `\"Schema\"` or the default\n   * schema type if not defined.\n   */\n  lazy val schemaType: NamedType =\n    if (schemaExtensions.isEmpty) baseSchemaType\n    else extendSchemaType(schemaExtensions, baseSchemaType)\n\n  /** The type of queries defined by this `Schema`*/\n  def queryType: NamedType = schemaType.field(\"query\").flatMap(_.nonNull.asNamed).get\n\n  /** The type of mutations defined by this `Schema`*/\n  def mutationType: Option[NamedType] = schemaType.field(\"mutation\").flatMap(_.nonNull.asNamed)\n\n  /** The type of subscriptions defined by this `Schema`*/\n  def subscriptionType: Option[NamedType] = schemaType.field(\"subscription\").flatMap(_.nonNull.asNamed)\n\n  /** True if the supplied type is one of the Query, Mutation or Subscription root types, false otherwise */\n  def isRootType(tpe: Type): Boolean =\n    tpe =:= queryType || mutationType.exists(_ =:= tpe) || subscriptionType.exists(_ =:= tpe)\n\n  /** Are the supplied alternatives exhaustive for `tp` */\n  def exhaustive(tp: Type, branches: List[Type]): Boolean = {\n    types.forall {\n      case o: ObjectType => !(o <:< tp) || branches.exists(b => o <:< b)\n      case _ => true\n    }\n  }\n\n  override def toString = SchemaRenderer.renderSchema(this)\n\n  private def extendType(extns: List[TypeExtension])(baseType: NamedType): NamedType = {\n    baseType match {\n      case ScalarType(name, description, directives) =>\n        val exts = extns.collect { case se@ScalarExtension(`name`, _) => se }\n        if (exts.isEmpty) baseType\n        else {\n          val newDirectives = exts.flatMap(_.directives)\n          ScalarType(name, description, directives ++ newDirectives)\n        }\n\n      case InterfaceType(name, description, fields, interfaces, directives) =>\n        val exts = extns.collect { case ie@InterfaceExtension(`name`, _, _, _) => ie }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.fields)\n          val newInterfaces = exts.flatMap(_.interfaces)\n          val newDirectives = exts.flatMap(_.directives)\n          InterfaceType(name, description, fields ++ newFields, interfaces ++ newInterfaces, directives ++ newDirectives)\n        }\n\n      case ObjectType(name, description, fields, interfaces, directives) =>\n        val exts = extns.collect { case oe@ObjectExtension(`name`, _, _, _) => oe }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.fields)\n          val newInterfaces = exts.flatMap(_.interfaces)\n          val newDirectives = exts.flatMap(_.directives)\n          ObjectType(name, description, fields ++ newFields, interfaces ++ newInterfaces, directives ++ newDirectives)\n        }\n\n      case UnionType(name, description, members, directives) =>\n        val exts = extns.collect { case ue@UnionExtension(`name`, _, _) => ue }\n        if (exts.isEmpty) baseType\n        else {\n          val newMembers = exts.flatMap(_.members)\n          val newDirectives = exts.flatMap(_.directives)\n          UnionType(name, description, members ++ newMembers, directives ++ newDirectives)\n        }\n\n      case EnumType(name, description, enumValues, directives) =>\n        val exts = extns.collect { case ee@EnumExtension(`name`, _, _) => ee }\n        if (exts.isEmpty) baseType\n        else {\n          val newValues = exts.flatMap(_.enumValues)\n          val newDirectives = exts.flatMap(_.directives)\n          EnumType(name, description, enumValues ++ newValues, directives ++ newDirectives)\n        }\n\n      case InputObjectType(name, description, inputFields, directives) =>\n        val exts = extns.collect { case ioe@InputObjectExtension(`name`, _, _) => ioe }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.inputFields)\n          val newDirectives = exts.flatMap(_.directives)\n          InputObjectType(name, description, inputFields ++ newFields, directives ++ newDirectives)\n        }\n\n      case tr: TypeRef =>\n        // This case should never be hit, however, it is the correct behaviour to return\n        // the ref as is. If the underlying type is present it will be extended, if not\n        // there will be an error reported elsewhere.\n        tr\n    }\n  }\n\n  private def extendSchemaType(extns: List[SchemaExtension], schemaType: NamedType): NamedType = {\n    schemaType match {\n      case ObjectType(name, description, fields, interfaces, directives) =>\n        val newFields = extns.flatMap(_.rootOperations)\n        val newDirectives = extns.flatMap(_.directives)\n        ObjectType(name, description, fields ++ newFields, interfaces, directives ++ newDirectives)\n\n      case _ => schemaType\n    }\n  }\n}\n\nobject Schema {\n  def apply(schemaText: String)(implicit pos: SourcePos): Result[Schema] =\n    SchemaParser.parseText(schemaText)\n}\n\ncase class SchemaExtension(\n  rootOperations: List[Field],\n  directives: List[Directive]\n)\n\n/**\n * A GraphQL type definition.\n */\nsealed trait Type extends Product {\n  /**\n   * Is this type equivalent to `other`.\n   *\n   * Note that plain `==` will distinguish types from type aliases,\n   * which is typically not desirable, so `=:=` is usually the\n   * most appropriate comparison operator.\n   */\n  def =:=(other: Type): Boolean = (this eq other) || (dealias == other.dealias)\n\n  /** `true` if this type is a subtype of `other`. */\n  def <:<(other: Type): Boolean =\n    (this.dealias, other.dealias) match {\n      case (tp1, tp2) if tp1 == tp2 => true\n      case (tp1, UnionType(_, _, members, _)) => members.exists(tp1 <:< _.dealias)\n      case (ObjectType(_, _, _, interfaces, _), tp2) => interfaces.exists(_ <:< tp2)\n      case (InterfaceType(_, _, _, interfaces, _), tp2) => interfaces.exists(_ <:< tp2)\n      case (NullableType(tp1), NullableType(tp2)) => tp1 <:< tp2\n      case (tp1, NullableType(tp2)) => tp1 <:< tp2\n      case (ListType(tp1), ListType(tp2)) => tp1 <:< tp2\n      case _ => false\n    }\n\n  def nominal_=:=(other: Type): Boolean =\n    this =:= other ||\n      ((this.dealias, other.dealias) match {\n        case (nt1: NamedType, nt2: NamedType) => nt1.name == nt2.name\n        case _ => false\n      })\n\n  /**\n   * Yield the type of the field of this type named `fieldName` or\n   * `None` if there is no such field.\n   */\n  def field(fieldName: String): Option[Type] = this match {\n    case NullableType(tpe) => tpe.field(fieldName)\n    case TypeRef(_, _) if exists => dealias.field(fieldName)\n    case ObjectType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case InterfaceType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case _ => None\n  }\n\n  /** `true` if this type has a field named `fieldName`, false otherwise. */\n  def hasField(fieldName: String): Boolean =\n    field(fieldName).isDefined\n\n  /** Yields the definition of `fieldName` in this type if it exists, `None` otherwise. */\n  def fieldInfo(fieldName: String): Option[Field] = this match {\n    case NullableType(tpe) => tpe.fieldInfo(fieldName)\n    case ListType(tpe) => tpe.fieldInfo(fieldName)\n    case _: TypeRef => dealias.fieldInfo(fieldName)\n    case _ => None\n  }\n\n  /**\n   * `true` if this type has a field named `fieldName` which is undefined in\n   * some interface it implements\n   */\n  def variantField(fieldName: String): Boolean =\n    underlyingObject match {\n      case Some(ObjectType(_, _, _, interfaces, _)) =>\n        hasField(fieldName) && interfaces.exists(!_.hasField(fieldName))\n      case _ => false\n    }\n\n  /**\n   * Yield the type of the field at the end of the path `fns` starting\n   * from this type, or `None` if there is no such field.\n   */\n  def path(fns: List[String]): Option[Type] = (fns, this) match {\n    case (Nil, _) => Some(this)\n    case (_, ListType(tpe)) => tpe.path(fns)\n    case (_, NullableType(tpe)) => tpe.path(fns)\n    case (_, TypeRef(_, _)) => dealias.path(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).flatMap(_.tpe.path(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).flatMap(_.tpe.path(rest))\n    case _ => None\n  }\n\n  /**\n   * Does the path `fns` from this type specify multiple values.\n   *\n   * `true` if navigating through the path `fns` from this type\n   * might specify 0 or more values. This will be the case if the\n   * path passes through at least one field of a List type.\n   */\n  def pathIsList(fns: List[String]): Boolean = (fns, this) match {\n    case (Nil, _) => this.isList\n    case (_, _: ListType) => true\n    case (_, NullableType(tpe)) => tpe.pathIsList(fns)\n    case (_, TypeRef(_, _)) => dealias.pathIsList(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsList(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsList(rest))\n    case _ => false\n  }\n\n  /**\n   * Does the path `fns` from this type specify a nullable type.\n   *\n   * `true` if navigating through the path `fns` from this type\n   * might specify an optional value. This will be the case if the\n   * path passes through at least one field of a nullable type.\n   */\n  def pathIsNullable(fns: List[String]): Boolean = (fns, this) match {\n    case (Nil, _) => false\n    case (_, ListType(tpe)) => tpe.pathIsNullable(fns)\n    case (_, _: NullableType) => true\n    case (_, TypeRef(_, _)) => dealias.pathIsNullable(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsNullable(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsNullable(rest))\n    case _ => false\n  }\n\n  /** Strip off aliases */\n  def dealias: Type = this\n\n  /** true if a non-TypeRef or a TypeRef to a defined type */\n  def exists: Boolean = true\n\n  /** Is this type nullable? */\n  def isNullable: Boolean = this match {\n    case NullableType(_) => true\n    case _ => false\n  }\n\n  /** This type if it is nullable, `Nullable(this)` otherwise. */\n  def nullable: Type = this match {\n    case t: NullableType => t\n    case t => NullableType(t)\n  }\n\n  /**\n   * A non-nullable version of this type.\n   *\n   * If this type is nullable, yield the non-nullable underlying\n   * type. Otherwise yield this type.\n   */\n  def nonNull: Type = this match {\n    case NullableType(tpe) => tpe.nonNull\n    case _ => this\n  }\n\n  /** Is this type a list. */\n  def isList: Boolean = this match {\n    case ListType(_) => true\n    case _ => false\n  }\n\n  /**\n   * The element type of this type.\n   *\n   * If this type is is a list, yield the non-list underlying type.\n   * Otherwise yield `None`.\n   */\n  def item: Option[Type] = this match {\n    case NullableType(tpe) => tpe.item\n    case ListType(tpe) => Some(tpe)\n    case _ => None\n  }\n\n  /** This type if it is a (nullable) list, `ListType(this)` otherwise. */\n  def list: Type = this match {\n    case l: ListType => l\n    case NullableType(tpe) => NullableType(tpe.list)\n    case tpe => ListType(tpe)\n  }\n\n  def underlying: Type = this match {\n    case NullableType(tpe) => tpe.underlying\n    case ListType(tpe) => tpe.underlying\n    case _: TypeRef => dealias.underlying\n    case _ => this\n  }\n\n  /**\n   * Yield the object type underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying object type is reached, in which case yield it, or a\n   * non-object type which isn't further reducible is reached, in which\n   * case yield `None`.\n   */\n  def underlyingObject: Option[NamedType] = this match {\n    case NullableType(tpe) => tpe.underlyingObject\n    case ListType(tpe) => tpe.underlyingObject\n    case _: TypeRef => dealias.underlyingObject\n    case o: ObjectType => Some(o)\n    case i: InterfaceType => Some(i)\n    case u: UnionType => Some(u)\n    case _ => None\n  }\n\n  /**\n   * Yield the type of the field named `fieldName` of the object type\n   * underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying object type is reached which has a field named\n   * `fieldName`, in which case yield the type of that field; if there\n   * is no such field, yields `None`.\n   */\n  def underlyingField(fieldName: String): Option[Type] = this match {\n    case NullableType(tpe) => tpe.underlyingField(fieldName)\n    case ListType(tpe) => tpe.underlyingField(fieldName)\n    case TypeRef(_, _) => dealias.underlyingField(fieldName)\n    case ObjectType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case InterfaceType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case _ => None\n  }\n\n  /** Is this type a leaf type?\n   *\n   * `true` if after stripping of aliases the underlying type a scalar or an\n   * enum, `false` otherwise.\n   */\n  def isLeaf: Boolean = this match {\n    case TypeRef(_, _) => dealias.isLeaf\n    case _: ScalarType => true\n    case _: EnumType => true\n    case _ => false\n  }\n\n  /**\n   * If the underlying type of this type is a scalar or an enum then yield it\n   * otherwise yield `None`.\n   */\n  def asLeaf: Option[Type] = this match {\n    case TypeRef(_, _) => dealias.asLeaf\n    case _: ScalarType => Some(this)\n    case _: EnumType => Some(this)\n    case _ => None\n  }\n\n\n  /**\n   * Is the underlying of this type a leaf type?\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying leaf type is reached, in which case yield true, or an\n   * a object, interface or union type which is reached, in which case\n   * yield false.\n   */\n  def isUnderlyingLeaf: Boolean = this match {\n    case NullableType(tpe) => tpe.isUnderlyingLeaf\n    case ListType(tpe) => tpe.isUnderlyingLeaf\n    case _: TypeRef => dealias.isUnderlyingLeaf\n    case (_: ObjectType)|(_: InterfaceType)|(_: UnionType) => false\n    case _ => true\n  }\n\n  /**\n   * Yield the leaf type underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying leaf type is reached, in which case yield it, or an\n   * a object, interface or union type which is reached, in which case\n   * yield `None`.\n   */\n  def underlyingLeaf: Option[Type] = this match {\n    case NullableType(tpe) => tpe.underlyingLeaf\n    case ListType(tpe) => tpe.underlyingLeaf\n    case _: TypeRef => dealias.underlyingLeaf\n    case (_: ObjectType)|(_: InterfaceType)|(_: UnionType) => None\n    case tpe => Some(tpe)\n  }\n\n  def withModifiersOf(tpe: Type): Type = {\n    def loop(rtpe: Type, tpe: Type): Type = tpe match {\n      case NullableType(tpe) => loop(NullableType(rtpe), tpe)\n      case ListType(tpe) => loop(ListType(rtpe), tpe)\n      case _ => rtpe\n    }\n    loop(this, tpe)\n  }\n\n  def isNamed: Boolean = false\n\n  def asNamed: Option[NamedType] = None\n\n  def isInterface: Boolean = false\n\n  def isUnion: Boolean = false\n\n  def /(pathElement: String): Path =\n    Path.from(this) / pathElement\n\n  def directives: List[Directive]\n}\n\n// Move all below into object Type?\n\n/** A type with a schema-defined name.\n *\n * This includes object types, inferface types and enums.\n */\nsealed trait NamedType extends Type {\n  /** The name of this type */\n  def name: String\n\n  override def dealias: NamedType = this\n\n  override def isNamed: Boolean = true\n\n  override def asNamed: Option[NamedType] = Some(this)\n\n  def description: Option[String]\n\n  def directives: List[Directive]\n\n  override def toString: String = name\n}\n\n/**\n * A GraphQL type extension\n */\nsealed trait TypeExtension {\n  def baseType: String\n}\n\n/**\n * A by name reference to a type defined in `schema`.\n */\ncase class TypeRef(schema: Schema, name: String) extends NamedType {\n  override lazy val dealias: NamedType = schema.definition(name).getOrElse(this)\n\n  override lazy val exists: Boolean = schema.definition(name).isDefined\n\n  def description: Option[String] = dealias.description\n\n  def directives: List[Directive] = dealias.directives\n}\n\n/**\n * Represents scalar types such as Int, String, and Boolean. Scalars cannot have fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Scalar\n */\ncase class ScalarType(\n  name: String,\n  description: Option[String],\n  directives: List[Directive]\n) extends Type with NamedType {\n  import ScalarType._\n\n  /** True if this is one of the five built-in Scalar types defined in the GraphQL Specification. */\n  def isBuiltIn: Boolean =\n    this match {\n      case IntType     |\n           FloatType   |\n           StringType  |\n           BooleanType |\n           IDType      => true\n      case _           => false\n    }\n\n}\n\nobject ScalarType {\n  def builtIn(tpnme: String): Option[ScalarType] = tpnme match {\n    case \"Int\" => Some(IntType)\n    case \"Float\" => Some(FloatType)\n    case \"String\" => Some(StringType)\n    case \"Boolean\" => Some(BooleanType)\n    case \"ID\" => Some(IDType)\n    case _ => None\n  }\n\n  val IntType = ScalarType(\n    name = \"Int\",\n    description =\n      Some(\n        \"\"\"|The Int scalar type represents a signed 32\u2010bit numeric non\u2010fractional value.\n           |Response formats that support a 32\u2010bit integer or a number type should use that\n           |type to represent this scalar.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val FloatType = ScalarType(\n    name = \"Float\",\n    description =\n      Some(\n        \"\"\"|The Float scalar type represents signed double\u2010precision fractional values as\n           |specified by IEEE 754. Response formats that support an appropriate\n           |double\u2010precision number type should use that type to represent this scalar.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val StringType = ScalarType(\n    name = \"String\",\n    description =\n      Some(\n        \"\"\"|The String scalar type represents textual data, represented as UTF\u20108 character\n           |sequences. The String type is most often used by GraphQL to represent free\u2010form\n           |human\u2010readable text.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val BooleanType = ScalarType(\n    name = \"Boolean\",\n    description =\n      Some(\n        \"\"\"|The Boolean scalar type represents true or false. Response formats should use a\n           |built\u2010in boolean type if supported; otherwise, they should use their\n           |representation of the integers 1 and 0.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n\n  val IDType = ScalarType(\n    name = \"ID\",\n    description =\n      Some(\n        \"\"\"|The ID scalar type represents a unique identifier, often used to refetch an\n           |object or as the key for a cache. The ID type is serialized in the same way as a\n           |String; however, it is not intended to be human\u2010readable.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n\n  val AttributeType = ScalarType(\n    name = \"InternalAttribute\",\n    description = None,\n    directives = Nil\n  )\n}\n\n/**\n * A type with fields.\n *\n * This includes object types and inferface types.\n */\nsealed trait TypeWithFields extends NamedType {\n  def fields: List[Field]\n  def interfaces: List[NamedType]\n\n  override def fieldInfo(name: String): Option[Field] = fields.find(_.name == name)\n}\n\n/**\n  * Scalar extensions allow additional directives to be applied to a pre-existing Scalar type\n  *\n  * @see https://spec.graphql.org/draft/#sec-Scalar-Extensions\n  */\ncase class ScalarExtension(\n  baseType: String,\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Interfaces are an abstract type where there are common fields declared. Any type that\n * implements an interface must define all the fields with names and types exactly matching.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Interface\n */\ncase class InterfaceType(\n  name: String,\n  description: Option[String],\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeWithFields {\n  override def isInterface: Boolean = true\n}\n\n/**\n * Interface extensions allow additional fields to be added to a pre-existing interface type\n *\n * @see https://spec.graphql.org/draft/#sec-Interface-Extensions\n **/\ncase class InterfaceExtension(\n  baseType: String,\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Object types represent concrete instantiations of sets of fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Object\n */\ncase class ObjectType(\n  name: String,\n  description: Option[String],\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeWithFields\n\n/**\n * Object extensions allow additional fields to be added to a pre-existing object type\n *\n * @see https://spec.graphql.org/draft/#sec-Object-Extensions\n **/\ncase class ObjectExtension(\n  baseType: String,\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Unions are an abstract type where no common fields are declared. The possible types of a union\n * are explicitly listed out in elements. Types can be made parts of unions without\n * modification of that type.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Union\n */\ncase class UnionType(\n  name: String,\n  description: Option[String],\n  members: List[NamedType],\n  directives: List[Directive]\n) extends Type with NamedType {\n  override def isUnion: Boolean = true\n  override def toString: String = members.mkString(\"|\")\n}\n\n/**\n * Union extensions allow additional members to be added to a pre-existing union type\n *\n * @see https://spec.graphql.org/draft/#sec-Union-Extensions\n **/\ncase class UnionExtension(\n  baseType: String,\n  members: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Enums are special scalars that can only have a defined set of values.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Enum\n */\ncase class EnumType(\n  name: String,\n  description: Option[String],\n  enumValues: List[EnumValueDefinition],\n  directives: List[Directive]\n) extends Type with NamedType {\n  def hasValue(name: String): Boolean = enumValues.exists(_.name == name)\n\n  def value(name: String): Option[EnumValue] = valueDefinition(name).map(_ => EnumValue(name))\n  def valueDefinition(name: String): Option[EnumValueDefinition] = enumValues.find(_.name == name)\n}\n\n/**\n * Enum extensions allow additional values to be added to a pre-existing enum type\n *\n * @see https://spec.graphql.org/draft/#sec-Enum-Extensions\n **/\ncase class EnumExtension(\n  baseType: String,\n  enumValues: List[EnumValueDefinition],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * The `EnumValue` type represents one of possible values of an enum.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__EnumValue-Type\n */\ncase class EnumValueDefinition(\n  name: String,\n  description: Option[String],\n  directives: List[Directive]\n) {\n  def deprecatedDirective: Option[Directive] =\n    directives.find(_.name == \"deprecated\")\n  def isDeprecated: Boolean = deprecatedDirective.isDefined\n  def deprecationReason: Option[String] =\n    for {\n      dir    <- deprecatedDirective\n      reason <- dir.args.collectFirst { case Binding(\"reason\", StringValue(reason)) => reason }\n    } yield reason\n}\n\n/**\n * Input objects are composite types used as inputs into queries defined as a list of named input\n * values.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Input-Object\n */\ncase class InputObjectType(\n  name: String,\n  description: Option[String],\n  inputFields: List[InputValue],\n  directives: List[Directive]\n) extends Type with NamedType {\n  def inputFieldInfo(name: String): Option[InputValue] = inputFields.find(_.name == name)\n}\n\n/**\n * Input Object extensions allow additional fields to be added to a pre-existing Input Object type\n *\n * @see https://spec.graphql.org/draft/#sec-Input-Object-Extensions\n **/\ncase class InputObjectExtension(\n  baseType: String,\n  inputFields: List[InputValue],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Lists represent sequences of values in GraphQL. A List type is a type modifier: it wraps\n * another type instance in the ofType field, which defines the type of each item in the list.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Type-Kinds.List\n */\ncase class ListType(\n  ofType: Type\n) extends Type {\n  def directives: List[Directive] = Nil\n  override def toString: String = s\"[$ofType]\"\n}\n\n/**\n * A Non\u2010null type is a type modifier: it wraps another type instance in the `ofType` field.\n * Non\u2010null types do not allow null as a response, and indicate required inputs for arguments\n * and input object fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Type-Kinds.Non-Null\n */\ncase class NullableType(\n  ofType: Type\n) extends Type {\n  def directives: List[Directive] = Nil\n  override def toString: String = s\"$ofType?\"\n}\n\n/**\n * The `Field` type represents each field in an Object or Interface type.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__Field-Type\n */\ncase class Field(\n  name: String,\n  description: Option[String],\n  args: List[InputValue],\n  tpe: Type,\n  directives: List[Directive]\n) {\n  def deprecatedDirective: Option[Directive] =\n    directives.find(_.name == \"deprecated\")\n  def isDeprecated: Boolean = deprecatedDirective.isDefined\n  def deprecationReason: Option[String] =\n    for {\n      dir    <- deprecatedDirective\n      reason <- dir.args.collectFirst { case Binding(\"reason\", StringValue(reason)) => reason }\n    } yield reason\n}\n\n/**\n * @param defaultValue a String encoding (using the GraphQL language) of the default value used by\n *                     this input value in the condition a value is not provided at runtime.\n */\ncase class InputValue(\n  name: String,\n  description: Option[String],\n  tpe: Type,\n  defaultValue: Option[Value],\n  directives: List[Directive]\n)\n\nsealed trait Value\n\nobject Value {\n\n  case class IntValue(value: Int) extends Value\n\n  case class FloatValue(value: Double) extends Value\n\n  case class StringValue(value: String) extends Value\n\n  case class BooleanValue(value: Boolean) extends Value\n\n  case class IDValue(value: String) extends Value\n\n  case class EnumValue(name: String) extends Value\n\n  case class ListValue(elems: List[Value]) extends Value\n\n  case class ObjectValue(fields: List[(String, Value)]) extends Value\n\n  case class VariableRef(name: String) extends Value\n\n  case object NullValue extends Value\n\n  case object AbsentValue extends Value\n\n  object StringListValue {\n    def apply(ss: List[String]): Value =\n      ListValue(ss.map(StringValue(_)))\n\n    def unapply(value: Value): Option[List[String]] =\n      value match {\n        case ListValue(l) => l.traverse {\n          case StringValue(s) => Some(s)\n          case _ => None\n        }\n        case _ => None\n      }\n  }\n\n  /**\n   * Elaborate a value by replacing variable references with their values.\n   */\n  def elaborateValue(value: Value, vars: Vars): Result[Value] = {\n    def loop(value: Value): Result[Value] =\n      value match {\n        case VariableRef(varName) =>\n          Result.fromOption(vars.get(varName).map(_._2), s\"Undefined variable '$varName'\")\n        case ObjectValue(fields) =>\n          val (keys, values) = fields.unzip\n          values.traverse(loop).map(evs => ObjectValue(keys.zip(evs)))\n        case ListValue(elems) => elems.traverse(loop).map(ListValue.apply)\n        case other => Result(other)\n      }\n    loop(value)\n  }\n\n  /**\n   * Resolve a value against its definition.\n   *\n   * + Absent and null values are defaulted if the InputValue provides a default.\n   * + Absent and null values are checked against the nullability of the InputValue.\n   * + Enum values are checked against the possible values of the EnumType.\n   * + Primitive values are converted to custom Scalars or IDs where appropriate.\n   * + The elements of list values are checked against their element type.\n   * + The fields of input object values are checked against their field definitions.\n   */\n  def checkValue(iv: InputValue, value: Option[Value], location: String): Result[Value] =\n    (iv.tpe.dealias, value) match {\n      case (_, None) if iv.defaultValue.isDefined =>\n        iv.defaultValue.get.success\n      case (_: NullableType, None) =>\n        AbsentValue.success\n      case (_: NullableType, Some(AbsentValue)) =>\n        AbsentValue.success\n      case (_: NullableType, Some(NullValue)) =>\n        NullValue.success\n      case (NullableType(tpe), Some(_)) =>\n        checkValue(iv.copy(tpe = tpe), value, location)\n      case (IntType, Some(value: IntValue)) =>\n        value.success\n      case (FloatType, Some(value: FloatValue)) =>\n        value.success\n      case (StringType, Some(value: StringValue)) =>\n        value.success\n      case (BooleanType, Some(value: BooleanValue)) =>\n        value.success\n\n      // Custom Scalars\n      case (s: ScalarType, Some(value: IntValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: FloatValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: StringValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: BooleanValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(enumValue: EnumValue)) if !s.isBuiltIn =>\n        StringValue(enumValue.name).success\n\n      case (IDType, Some(value: IDValue)) =>\n        value.success\n      case (IDType, Some(StringValue(s))) =>\n        IDValue(s).success\n      case (IDType, Some(IntValue(i))) =>\n        IDValue(i.toString).success\n      case (e: EnumType, Some(value@EnumValue(name))) if e.hasValue(name) =>\n        value.success\n      case (ListType(tpe), Some(ListValue(arr))) =>\n        arr.traverse { elem =>\n          checkValue(iv.copy(tpe = tpe, defaultValue = None), Some(elem), location)\n        }.map(ListValue.apply)\n      case (InputObjectType(nme, _, ivs, _), Some(ObjectValue(fs))) =>\n        val obj = fs.toMap\n        val unknownFields = fs.map(_._1).filterNot(f => ivs.exists(_.name == f))\n        if (unknownFields.nonEmpty)\n          Result.failure(s\"Unknown field(s) ${unknownFields.map(s => s\"'$s'\").mkString(\"\", \", \", \"\")} for input object value of type ${nme} in $location\")\n        else\n          ivs.traverse(iv => checkValue(iv, obj.get(iv.name), location).map(v => (iv.name, v))).map(ObjectValue.apply)\n      case (tpe, Some(value)) => Result.failure(s\"Expected $tpe found '${SchemaRenderer.renderValue(value)}' for '${iv.name}' in $location\")\n      case (tpe, None) => Result.failure(s\"Value of type $tpe required for '${iv.name}' in $location\")\n    }\n\n  /**\n   * Resolve a Json variable value against its definition.\n   *\n   * + Absent and null values are defaulted if the InputValue provides a default.\n   * + Absent and null values are checked against the nullability of the InputValue.\n   * + Enum values are checked against the possible values of the EnumType.\n   * + Primitive values are converted to custom Scalars or IDs where appropriate.\n   * + The elements of list values are checked against their element type.\n   * + The fields of input object values are checked against their field definitions.\n   */\n  def checkVarValue(iv: InputValue, value: Option[Json], location: String): Result[Value] = {\n    import JsonExtractor._\n\n    (iv.tpe.dealias, value) match {\n      case (_, None) if iv.defaultValue.isDefined =>\n        iv.defaultValue.get.success\n      case (_: NullableType, None) =>\n        AbsentValue.success\n      case (_: NullableType, Some(jsonNull(_))) =>\n        NullValue.success\n      case (NullableType(tpe), Some(_)) =>\n        checkVarValue(iv.copy(tpe = tpe), value, location)\n      case (IntType, Some(jsonInt(value))) =>\n        IntValue(value).success\n      case (FloatType, Some(jsonDouble(value))) =>\n        FloatValue(value).success\n      case (StringType, Some(jsonString(value))) =>\n        StringValue(value).success\n      case (BooleanType, Some(jsonBoolean(value))) =>\n        BooleanValue(value).success\n      case (IDType, Some(jsonInt(value))) =>\n        IDValue(value.toString).success\n\n      // Custom scalars\n      case (s: ScalarType, Some(jsonInt(value))) if !s.isBuiltIn =>\n        IntValue(value).success\n      case (s: ScalarType, Some(jsonDouble(value))) if !s.isBuiltIn =>\n        FloatValue(value).success\n      case (s: ScalarType, Some(jsonString(value))) if !s.isBuiltIn =>\n        StringValue(value).success\n      case (s: ScalarType, Some(jsonBoolean(value))) if !s.isBuiltIn =>\n        BooleanValue(value).success\n\n      case (IDType, Some(jsonString(value))) =>\n        IDValue(value).success\n      case (e: EnumType, Some(jsonString(name))) if e.hasValue(name) =>\n        EnumValue(name).success\n      case (ListType(tpe), Some(jsonArray(arr))) =>\n        arr.traverse { elem =>\n          checkVarValue(iv.copy(tpe = tpe, defaultValue = None), Some(elem), location)\n        }.map(vs => ListValue(vs.toList))\n      case (InputObjectType(nme, _, ivs, _), Some(jsonObject(obj))) =>\n        val unknownFields = obj.keys.filterNot(f => ivs.exists(_.name == f))\n        if (unknownFields.nonEmpty)\n          Result.failure(s\"Unknown field(s) ${unknownFields.map(s => s\"'$s'\").mkString(\"\", \", \", \"\")} in input object value of type ${nme} in $location\")\n        else\n          ivs.traverse(iv => checkVarValue(iv, obj(iv.name), location).map(v => (iv.name, v))).map(ObjectValue.apply)\n      case (tpe, Some(value)) => Result.failure(s\"Expected $tpe found '$value' for '${iv.name}' in $location\")\n      case (tpe, None) => Result.failure(s\"Value of type $tpe required for '${iv.name}' in $location\")\n    }\n  }\n}\n\n/**\n * The `Directive` type represents a Directive that a server supports.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__Directive-Type\n */\ncase class DirectiveDef(\n  name: String,\n  description: Option[String],\n  args: List[InputValue],\n  isRepeatable: Boolean,\n  locations: List[DirectiveLocation]\n)\n\nobject DirectiveDef {\n  val Skip: DirectiveDef =\n    DirectiveDef(\n      \"skip\",\n      Some(\n        \"\"\"|The @skip directive may be provided for fields, fragment spreads, and inline\n           |fragments, and allows for conditional exclusion during execution as described\n           |by the if argument.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"if\", Some(\"Skipped with true.\"), BooleanType, None, Nil)),\n      false,\n      List(DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT)\n    )\n\n  val Include: DirectiveDef =\n    DirectiveDef(\n      \"include\",\n      Some(\n        \"\"\"|The @include directive may be provided for fields, fragment spreads, and inline\n           |fragments, and allows for conditional inclusion during execution as described\n           |by the if argument.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"if\", Some(\"Included when true.\"), BooleanType, None, Nil)),\n      false,\n      List(DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT)\n    )\n\n  val Deprecated: DirectiveDef =\n    DirectiveDef(\n      \"deprecated\",\n      Some(\n        \"\"\"|The @deprecated directive is used within the type system definition language\n           |to indicate deprecated portions of a GraphQL service\u2019s schema, such as deprecated\n           |fields on a type or deprecated enum values.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"reason\", Some(\"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).\"), NullableType(StringType), Some(StringValue(\"No longer supported\")), Nil)),\n      false,\n      List(DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE)\n    )\n\n  val builtIns: List[DirectiveDef] =\n    List(Skip, Include, Deprecated)\n}\n\ncase class Directive(\n  name: String,\n  args: List[Binding]\n)\n\nobject Directive {\n  def validateDirectivesForSchema(schema: Schema): List[Problem] = {\n    def validateTypeDirectives(tpe: NamedType): List[Problem] =\n      tpe match {\n        case o: ObjectType =>\n          validateDirectives(schema, Ast.DirectiveLocation.OBJECT, o.directives, Map.empty) ++\n          o.fields.flatMap(validateFieldDirectives)\n        case i: InterfaceType =>\n          validateDirectives(schema, Ast.DirectiveLocation.INTERFACE, i.directives, Map.empty) ++\n          i.fields.flatMap(validateFieldDirectives)\n        case u: UnionType =>\n          validateDirectives(schema, Ast.DirectiveLocation.UNION, u.directives, Map.empty)\n        case e: EnumType =>\n          validateDirectives(schema, Ast.DirectiveLocation.ENUM, e.directives, Map.empty) ++\n          e.enumValues.flatMap(v => validateDirectives(schema, Ast.DirectiveLocation.ENUM_VALUE, v.directives, Map.empty))\n        case s: ScalarType =>\n          validateDirectives(schema, Ast.DirectiveLocation.SCALAR, s.directives, Map.empty)\n        case i: InputObjectType =>\n          validateDirectives(schema, Ast.DirectiveLocation.INPUT_OBJECT, i.directives, Map.empty) ++\n          i.inputFields.flatMap(f => validateDirectives(schema, Ast.DirectiveLocation.INPUT_FIELD_DEFINITION, f.directives, Map.empty))\n        case _ => Nil\n      }\n\n    def validateFieldDirectives(field: Field): List[Problem] =\n      validateDirectives(schema, Ast.DirectiveLocation.FIELD_DEFINITION, field.directives, Map.empty) ++\n      field.args.flatMap(a => validateDirectives(schema, Ast.DirectiveLocation.ARGUMENT_DEFINITION, a.directives, Map.empty))\n\n    validateDirectives(schema, Ast.DirectiveLocation.SCHEMA, schema.schemaType.directives, Map.empty) ++\n    (schema.schemaType match {\n      case twf: TypeWithFields => twf.fields.flatMap(validateFieldDirectives)\n      case _ => Nil\n    }) ++\n    schema.types.flatMap(validateTypeDirectives)\n  }\n\n  def validateDirectivesForQuery(schema: Schema, op: UntypedOperation, frags: List[UntypedFragment], vars: Vars): Result[Unit] = {\n    def queryWarnings(query: Query): List[Problem] = {\n      def loop(query: Query): List[Problem] =\n        query match {\n          case UntypedSelect(_, _, _, dirs, child) =>\n            validateDirectives(schema, Ast.DirectiveLocation.FIELD, dirs, vars) ++ loop(child)\n          case UntypedFragmentSpread(_, dirs) =>\n            validateDirectives(schema, Ast.DirectiveLocation.FRAGMENT_SPREAD, dirs, vars)\n          case UntypedInlineFragment(_, dirs, child) =>\n            validateDirectives(schema, Ast.DirectiveLocation.INLINE_FRAGMENT, dirs, vars) ++ loop(child)\n          case Select(_, _, child)       => loop(child)\n          case Group(children)           => children.flatMap(loop)\n          case Narrow(_, child)          => loop(child)\n          case Unique(child)             => loop(child)\n          case Filter(_, child)          => loop(child)\n          case Limit(_, child)           => loop(child)\n          case Offset(_, child)          => loop(child)\n          case OrderBy(_, child)         => loop(child)\n          case Introspect(_, child)      => loop(child)\n          case Environment(_, child)     => loop(child)\n          case Component(_, _, child)    => loop(child)\n          case Effect(_, child)          => loop(child)\n          case TransformCursor(_, child) => loop(child)\n          case Count(_)                  => Nil\n          case Empty                     => Nil\n      }\n\n      loop(query)\n    }\n\n    def operationWarnings(op: UntypedOperation): List[Problem] = {\n      lazy val opLocation = op match {\n        case _: UntypedQuery => Ast.DirectiveLocation.QUERY\n        case _: UntypedMutation => Ast.DirectiveLocation.MUTATION\n        case _: UntypedSubscription => Ast.DirectiveLocation.SUBSCRIPTION\n      }\n\n      val varWarnings = op.variables.flatMap(v => validateDirectives(schema, Ast.DirectiveLocation.VARIABLE_DEFINITION, v.directives, vars))\n      val opWarnings = validateDirectives(schema, opLocation, op.directives, vars)\n      val childWarnings = queryWarnings(op.query)\n      varWarnings ++ opWarnings ++ childWarnings\n    }\n\n    def fragmentWarnings(frag: UntypedFragment): List[Problem] = {\n      val defnWarnings = validateDirectives(schema, Ast.DirectiveLocation.FRAGMENT_DEFINITION, frag.directives, vars)\n      val childWarnings = queryWarnings(frag.child)\n      defnWarnings ++ childWarnings\n    }\n\n    val opWarnings = operationWarnings(op)\n    val fragWarnings = frags.flatMap(fragmentWarnings)\n\n    Result.fromProblems(opWarnings ++ fragWarnings)\n  }\n\n  def validateDirectiveOccurrences(schema: Schema, location: Ast.DirectiveLocation, directives: List[Directive]): List[Problem] = {\n    val (locationProblems, repetitionProblems) =\n      directives.foldLeft((List.empty[Problem], List.empty[Problem])) { case ((locs, reps), directive) =>\n        val nme = directive.name\n        schema.directives.find(_.name == nme) match {\n          case None => (Problem(s\"Undefined directive '$nme'\") :: locs, reps)\n          case Some(defn) =>\n            val locs0 =\n              if (defn.locations.contains(location)) locs\n              else Problem(s\"Directive '$nme' is not allowed on $location\") :: locs\n\n            val reps0 =\n              if (!defn.isRepeatable && directives.count(_.name == nme) > 1)\n                Problem(s\"Directive '$nme' may not occur more than once\") :: reps\n              else reps\n\n            (locs0, reps0)\n        }\n      }\n\n    locationProblems.reverse ++ repetitionProblems.reverse.distinct\n  }\n\n  def validateDirectives(schema: Schema, location: Ast.DirectiveLocation, directives: List[Directive], vars: Vars): List[Problem] = {\n    val occurrenceProblems = validateDirectiveOccurrences(schema, location, directives)\n    val argProblems =\n      directives.flatMap { directive =>\n        val nme = directive.name\n        schema.directives.find(_.name == nme) match {\n          case None => List(Problem(s\"Undefined directive '$nme'\"))\n          case Some(defn) =>\n            val infos = defn.args\n            val unknownArgs = directive.args.filterNot(arg => infos.exists(_.name == arg.name))\n            if (unknownArgs.nonEmpty)\n              List(Problem(s\"Unknown argument(s) ${unknownArgs.map(s => s\"'${s.name}'\").mkString(\"\", \", \", \"\")} in directive $nme\"))\n            else {\n              val argMap = directive.args.groupMapReduce(_.name)(_.value)((x, _) => x)\n              infos.traverse { info =>\n                for {\n                  value <- argMap.get(info.name).traverse(Value.elaborateValue(_, vars))\n                  _     <- checkValue(info, value, s\"directive ${defn.name}\")\n                } yield ()\n              }.toProblems.toList\n            }\n        }\n      }\n\n    occurrenceProblems ++ argProblems\n  }\n\n  def elaborateDirectives(schema: Schema, directives: List[Directive], vars: Vars): Result[List[Directive]] =\n    directives.traverse { directive =>\n      val nme = directive.name\n      schema.directives.find(_.name == nme) match {\n        case None => Result.failure(s\"Undefined directive '$nme'\")\n        case Some(defn) =>\n          val argMap = directive.args.groupMapReduce(_.name)(_.value)((x, _) => x)\n          defn.args.traverse { info =>\n            for {\n              value0 <- argMap.get(info.name).traverse(Value.elaborateValue(_, vars))\n              value1 <- checkValue(info, value0, s\"directive ${defn.name}\")\n            } yield Binding(info.name, value1)\n          }.map(eArgs => directive.copy(args = eArgs))\n      }\n    }\n}\n\n/**\n * GraphQL schema parser\n */\nobject SchemaParser {\n\n  import Ast.{Directive => _, EnumValueDefinition => _, SchemaExtension => _, Type => _, TypeExtension => _, Value => _, _}\n\n  /**\n   * Parse a query String to a query algebra term.\n   *\n   * Yields a Query value on the right and accumulates errors on the left.\n   */\n  def parseText(text: String)(implicit pos: SourcePos): Result[Schema] =\n    for {\n      doc <- GraphQLParser.toResult(text, GraphQLParser.Document.parseAll(text))\n      query <- parseDocument(doc)\n    } yield query\n\n  def parseDocument(doc: Document)(implicit sourcePos: SourcePos): Result[Schema] = {\n    object schema extends Schema {\n      var baseTypes: List[NamedType] = Nil\n      var baseSchemaType1: Option[NamedType] = null\n      var pos: SourcePos = sourcePos\n\n      override def baseSchemaType: NamedType = baseSchemaType1.getOrElse(super.baseSchemaType)\n\n      var directives: List[DirectiveDef] = Nil\n      var schemaExtensions: List[SchemaExtension] = Nil\n      var typeExtensions: List[TypeExtension] = Nil\n\n      def complete(types0: List[NamedType], baseSchemaType0: Option[NamedType], directives0: List[DirectiveDef], schemaExtensions0: List[SchemaExtension], typeExtensions0: List[TypeExtension]): Unit = {\n        baseTypes = types0\n        baseSchemaType1 = baseSchemaType0\n        directives = directives0 ++ DirectiveDef.builtIns\n        schemaExtensions = schemaExtensions0\n        typeExtensions = typeExtensions0\n      }\n    }\n\n    val schemaExtnDefns: List[Ast.SchemaExtension] = doc.collect { case tpe: Ast.SchemaExtension => tpe }\n    val typeDefns: List[TypeDefinition] = doc.collect { case tpe: TypeDefinition => tpe }\n    val dirDefns: List[DirectiveDefinition] = doc.collect { case dir: DirectiveDefinition => dir }\n    val extnDefns: List[Ast.TypeExtension] = doc.collect { case tpe: Ast.TypeExtension => tpe }\n\n    for {\n      baseTypes   <- mkTypeDefs(schema, typeDefns)\n      schemaExtns <- mkSchemaExtensions(schema, schemaExtnDefns)\n      typeExtns   <- mkExtensions(schema, extnDefns)\n      directives  <- mkDirectiveDefs(schema, dirDefns)\n      schemaType  <- mkSchemaType(schema, doc)\n      _           =  schema.complete(baseTypes, schemaType, directives, schemaExtns, typeExtns)\n      _           <- Result.fromProblems(SchemaValidator.validateSchema(schema, typeDefns, extnDefns))\n    } yield schema\n  }\n\n  // explicit Schema type, if any\n  def mkSchemaType(schema: Schema, doc: Document): Result[Option[NamedType]] = {\n    def build(dirs: List[Directive], ops: List[Field]): NamedType = {\n      val query = ops.find(_.name == \"query\").getOrElse(Field(\"query\", None, Nil, defaultQueryType, Nil))\n      ObjectType(\n        name = \"Schema\",\n        description = None,\n        fields = query :: List(ops.find(_.name == \"mutation\"), ops.find(_.name == \"subscription\")).flatten,\n        interfaces = Nil,\n        directives = dirs\n      )\n    }\n\n    def defaultQueryType = schema.ref(\"Query\")\n\n    val defns = doc.collect { case schema: SchemaDefinition => schema }\n    defns match {\n      case Nil => None.success\n      case SchemaDefinition(rootOpTpes, dirs0) :: Nil =>\n        for {\n          ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n          dirs <- dirs0.traverse(mkDirective)\n        } yield Some(build(dirs, ops))\n\n      case _ => Result.failure(\"At most one schema definition permitted\")\n    }\n  }\n\n  def mkSchemaExtensions(schema: Schema, extnDefns: List[Ast.SchemaExtension]): Result[List[SchemaExtension]] =\n    extnDefns.traverse(mkSchemaExtension(schema))\n\n  def mkSchemaExtension(schema: Schema)(se: Ast.SchemaExtension): Result[SchemaExtension] = {\n    val Ast.SchemaExtension(rootOpTpes, dirs0) = se\n    for {\n      ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n      dirs <- dirs0.traverse(mkDirective)\n    } yield SchemaExtension(ops, dirs)\n  }\n\n  def mkRootOperation(schema: Schema)(rootTpe: RootOperationTypeDefinition): Result[Field] = {\n    val RootOperationTypeDefinition(optype, tpe, dirs0) = rootTpe\n    for {\n      dirs <- dirs0.traverse(mkDirective)\n      tpe  <- mkType(schema)(tpe)\n      _    <- Result.failure(s\"Root operation types must be named types, found '$tpe'\").whenA(!tpe.nonNull.isNamed)\n    } yield Field(optype.name, None, Nil, tpe, dirs)\n  }\n\n  def mkExtensions(schema: Schema, extnDefns: List[Ast.TypeExtension]): Result[List[TypeExtension]] =\n    extnDefns.traverse(mkExtension(schema))\n\n  def mkExtension(schema: Schema)(ed: Ast.TypeExtension): Result[TypeExtension] =\n    ed match {\n      case ScalarTypeExtension(Ast.Type.Named(Name(name)), dirs0) =>\n        for {\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield ScalarExtension(name, dirs)\n      case InterfaceTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n        for {\n          fields <- fields0.traverse(mkField(schema))\n          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield InterfaceExtension(name, fields, ifs, dirs)\n      case ObjectTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n        for {\n          fields <- fields0.traverse(mkField(schema))\n          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield ObjectExtension(name, fields, ifs, dirs)\n      case UnionTypeExtension(Ast.Type.Named(Name(name)), dirs0, members0) =>\n        for {\n          dirs    <- dirs0.traverse(mkDirective)\n          members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n        } yield UnionExtension(name, members, dirs)\n      case EnumTypeExtension(Ast.Type.Named(Name(name)), dirs0, values0) =>\n        for {\n          values  <- values0.traverse(mkEnumValue)\n          dirs    <- dirs0.traverse(mkDirective)\n        } yield EnumExtension(name, values, dirs)\n      case InputObjectTypeExtension(Ast.Type.Named(Name(name)), dirs0, fields0) =>\n        for {\n          fields <- fields0.traverse(mkInputValue(schema))\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield InputObjectExtension(name, fields, dirs)\n    }\n\n  def mkTypeDefs(schema: Schema, defns: List[TypeDefinition]): Result[List[NamedType]] =\n    defns.traverse(mkTypeDef(schema))\n\n  def mkTypeDef(schema: Schema)(td: TypeDefinition): Result[NamedType] = td match {\n    case ScalarTypeDefinition(Name(\"Int\"), _, _) => IntType.success\n    case ScalarTypeDefinition(Name(\"Float\"), _, _) => FloatType.success\n    case ScalarTypeDefinition(Name(\"String\"), _, _) => StringType.success\n    case ScalarTypeDefinition(Name(\"Boolean\"), _, _) => BooleanType.success\n    case ScalarTypeDefinition(Name(\"ID\"), _, _) => IDType.success\n    case ScalarTypeDefinition(Name(nme), desc, dirs0) =>\n      for {\n        dirs <- dirs0.traverse(mkDirective)\n      } yield ScalarType(nme, desc, dirs)\n    case ObjectTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n      if (fields0.isEmpty) Result.failure(s\"object type $nme must define at least one field\")\n      else\n        for {\n          fields <- fields0.traverse(mkField(schema))\n          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield ObjectType(nme, desc, fields, ifs, dirs)\n    case InterfaceTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n      if (fields0.isEmpty) Result.failure(s\"interface type $nme must define at least one field\")\n      else\n        for {\n          fields <- fields0.traverse(mkField(schema))\n          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield InterfaceType(nme, desc, fields, ifs, dirs)\n    case UnionTypeDefinition(Name(nme), desc, dirs0, members0) =>\n      if (members0.isEmpty) Result.failure(s\"union type $nme must define at least one member\")\n      else {\n        for {\n          dirs    <- dirs0.traverse(mkDirective)\n          members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n        } yield UnionType(nme, desc, members, dirs)\n      }\n    case EnumTypeDefinition(Name(nme), desc, dirs0, values0) =>\n      if (values0.isEmpty) Result.failure(s\"enum type $nme must define at least one enum value\")\n      else\n        for {\n          values <- values0.traverse(mkEnumValue)\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield EnumType(nme, desc, values, dirs)\n    case InputObjectTypeDefinition(Name(nme), desc, fields0, dirs0) =>\n      if (fields0.isEmpty) Result.failure(s\"input object type $nme must define at least one input field\")\n      else\n        for {\n          fields <- fields0.traverse(mkInputValue(schema))\n          dirs   <- dirs0.traverse(mkDirective)\n        } yield InputObjectType(nme, desc, fields, dirs)\n  }\n\n  def mkDirective(d: Ast.Directive): Result[Directive] = {\n    val Ast.Directive(Name(nme), args) = d\n    args.traverse {\n      case (Name(nme), value) => parseValue(value).map(Binding(nme, _))\n    }.map(Directive(nme, _))\n  }\n\n  def mkField(schema: Schema)(f: FieldDefinition): Result[Field] = {\n    val FieldDefinition(Name(nme), desc, args0, tpe0, dirs0) = f\n    for {\n      args <- args0.traverse(mkInputValue(schema))\n      tpe  <- mkType(schema)(tpe0)\n      dirs <- dirs0.traverse(mkDirective)\n    } yield Field(nme, desc, args, tpe, dirs)\n  }\n\n  def mkType(schema: Schema)(tpe: Ast.Type): Result[Type] = {\n    def loop(tpe: Ast.Type, nullable: Boolean): Result[Type] = {\n      def wrap(tpe: Type): Type = if (nullable) NullableType(tpe) else tpe\n\n      tpe match {\n        case Ast.Type.List(tpe) => loop(tpe, true).map(tpe => wrap(ListType(tpe)))\n        case Ast.Type.NonNull(Left(tpe)) => loop(tpe, false)\n        case Ast.Type.NonNull(Right(tpe)) => loop(tpe, false)\n        case Ast.Type.Named(Name(nme)) => wrap(ScalarType.builtIn(nme).getOrElse(schema.ref(nme))).success\n      }\n    }\n\n    loop(tpe, true)\n  }\n\n  def mkDirectiveDefs(schema: Schema, defns: List[DirectiveDefinition]): Result[List[DirectiveDef]] =\n    defns.traverse(mkDirectiveDef(schema))\n\n  def mkDirectiveDef(schema: Schema)(dd: DirectiveDefinition): Result[DirectiveDef] = {\n    val DirectiveDefinition(Name(nme), desc, args0, repeatable, locations) = dd\n    for {\n      args <- args0.traverse(mkInputValue(schema))\n    } yield DirectiveDef(nme, desc, args, repeatable, locations)\n  }\n\n  def mkInputValue(schema: Schema)(f: InputValueDefinition): Result[InputValue] = {\n    val InputValueDefinition(Name(nme), desc, tpe0, default0, dirs0) = f\n    for {\n      tpe <- mkType(schema)(tpe0)\n      dflt <- default0.traverse(parseValue)\n      dirs <- dirs0.traverse(mkDirective)\n    } yield InputValue(nme, desc, tpe, dflt, dirs)\n  }\n\n  def mkEnumValue(e: Ast.EnumValueDefinition): Result[EnumValueDefinition] = {\n    val Ast.EnumValueDefinition(Name(nme), desc, dirs0) = e\n    for {\n      dirs <- dirs0.traverse(mkDirective)\n    } yield EnumValueDefinition(nme, desc, dirs)\n  }\n\n  def parseValue(value: Ast.Value): Result[Value] = {\n    value match {\n      case Ast.Value.IntValue(i) => IntValue(i).success\n      case Ast.Value.FloatValue(d) => FloatValue(d).success\n      case Ast.Value.StringValue(s) => StringValue(s).success\n      case Ast.Value.BooleanValue(b) => BooleanValue(b).success\n      case Ast.Value.EnumValue(e) => EnumValue(e.value).success\n      case Ast.Value.Variable(v) => VariableRef(v.value).success\n      case Ast.Value.NullValue => NullValue.success\n      case Ast.Value.ListValue(vs) => vs.traverse(parseValue).map(ListValue(_))\n      case Ast.Value.ObjectValue(fs) =>\n        fs.traverse { case (name, value) =>\n          parseValue(value).map(v => (name.value, v))\n        }.map(ObjectValue(_))\n    }\n  }\n}\n\nobject SchemaValidator {\n  import SchemaRenderer.renderType\n\n  def validateSchema(schema: Schema, defns: List[TypeDefinition], typeExtnDefns: List[Ast.TypeExtension]): List[Problem] =\n    validateReferences(schema, defns) ++\n    validateUniqueDefns(schema) ++\n    validateUniqueFields(schema) ++\n    validateUnionMembers(schema) ++\n    validateUniqueEnumValues(schema) ++\n    validateImplementations(schema) ++\n    validateTypeExtensions(defns, typeExtnDefns) ++\n    Directive.validateDirectivesForSchema(schema)\n\n  def validateReferences(schema: Schema, defns: List[TypeDefinition]): List[Problem] = {\n    def underlyingName(tpe: Ast.Type): String =\n      tpe match {\n        case Ast.Type.List(tpe) => underlyingName(tpe)\n        case Ast.Type.NonNull(Left(tpe)) => underlyingName(tpe)\n        case Ast.Type.NonNull(Right(tpe)) => underlyingName(tpe)\n        case Ast.Type.Named(Ast.Name(nme)) => nme\n      }\n\n    def referencedTypes(defns: List[TypeDefinition]): List[String] = {\n      defns.flatMap {\n        case ObjectTypeDefinition(_, _, fields, _, _) =>\n          (fields.flatMap(_.args.map(_.tpe)) ++ fields.map(_.tpe)).map(underlyingName)\n        case InterfaceTypeDefinition(_, _, fields, _, _) =>\n          (fields.flatMap(_.args.map(_.tpe)) ++ fields.map(_.tpe)).map(underlyingName)\n        case u: UnionTypeDefinition =>\n          u.members.map(underlyingName)\n        case _ => Nil\n      }\n    }\n\n    val defaultTypes = List(StringType, IntType, FloatType, BooleanType, IDType)\n    val typeNames = (defaultTypes ++ schema.types).map(_.name).toSet\n\n    referencedTypes(defns).collect {\n      case tpe if !typeNames.contains(tpe) => Problem(s\"Reference to undefined type '$tpe'\")\n    }\n  }\n\n  def validateUniqueDefns(schema: Schema): List[Problem] = {\n    val dupes = schema.types.groupBy(_.name).collect {\n      case (nme, tpes) if tpes.length > 1 => nme\n    }.toSet\n\n    schema.types.map(_.name).distinct.collect {\n      case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of type '$nme' found\")\n    }\n  }\n\n  def validateUniqueFields(schema: Schema): List[Problem] = {\n    val withFields = schema.types.collect {\n      case wf: TypeWithFields => wf\n    }\n\n    val inputObjs = schema.types.collect {\n      case io: InputObjectType => io\n    }\n\n    withFields.flatMap { tpe =>\n      val dupes = tpe.fields.groupBy(_.name).collect {\n        case (nme, fields) if fields.length > 1 => nme\n      }.toSet\n\n      tpe.fields.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of field '$nme' for type '${tpe.name}'\")\n      }\n    } ++\n    inputObjs.flatMap { tpe =>\n      val dupes = tpe.inputFields.groupBy(_.name).collect {\n        case (nme, fields) if fields.length > 1 => nme\n      }.toSet\n\n      tpe.inputFields.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of field '$nme' for type '${tpe.name}'\")\n      }\n    }\n  }\n\n  def validateUnionMembers(schema: Schema): List[Problem] = {\n    val unions = schema.types.collect {\n      case u: UnionType => u\n    }\n\n    unions.flatMap { tpe =>\n      val dupes = tpe.members.groupBy(_.name).collect {\n        case (nme, vs) if vs.length > 1 => nme\n      }.toSet\n\n      tpe.members.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate inclusion of union member '$nme' for type '${tpe.name}'\")\n      } ++\n      tpe.members.flatMap { member =>\n        schema.definition(member.name) match {\n          case None => List(Problem(s\"Undefined type '${member.name}' included in union '${tpe.name}'\"))\n          case Some(mtpe) =>\n            mtpe match {\n              case (_: ObjectType) | (_: InterfaceType) => Nil\n              case _ => List(Problem(s\"Non-object type '${member.name}' included in union '${tpe.name}'\"))\n            }\n        }\n      }\n    }\n  }\n\n  def validateUniqueEnumValues(schema: Schema): List[Problem] = {\n    val enums = schema.types.collect {\n      case e: EnumType => e\n    }\n\n    enums.flatMap { tpe =>\n      val dupes = tpe.enumValues.groupBy(_.name).collect {\n        case (nme, vs) if vs.length > 1 => nme\n      }.toSet\n\n      tpe.enumValues.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of enum value '$nme' for type '${tpe.name}'\")\n      }\n    }\n  }\n\n  def validateImplementations(schema: Schema): List[Problem] = {\n\n    def validateImplementor(impl: TypeWithFields): List[Problem] = {\n      import impl.{name, fields, interfaces}\n\n      interfaces.flatMap(_.dealias match {\n        case iface: InterfaceType =>\n          iface.fields.flatMap { ifField =>\n            fields.find(_.name == ifField.name).map { implField =>\n              val ifTpe = ifField.tpe\n              val implTpe = implField.tpe\n\n              val rp =\n                if (implTpe <:< ifTpe) Nil\n                else List(Problem(s\"Field '${implField.name}' of type '$name' has type '${renderType(implTpe)}', however implemented interface '${iface.name}' requires it to be a subtype of '${renderType(ifTpe)}'\"))\n\n              val argsMatch =\n                implField.args.corresponds(ifField.args) { case (arg0, arg1) =>\n                  arg0.name == arg1.name && arg0.tpe == arg1.tpe\n                }\n\n              val ap =\n                if (argsMatch) Nil\n                else List(Problem(s\"Field '${implField.name}' of type '$name' has has an argument list that does not conform to that specified by implemented interface '${iface.name}'\"))\n\n              rp ++ ap\n            }.getOrElse(List(Problem(s\"Field '${ifField.name}' from interface '${iface.name}' is not defined by implementing type '$name'\")))\n          }\n        case undefined: TypeRef =>\n          List(Problem(s\"Undefined type '${undefined.name}' declared as implemented by type '$name'\"))\n        case other =>\n          List(Problem(s\"Non-interface type '${other.name}' declared as implemented by type '$name'\"))\n      })\n    }\n\n    val impls = schema.types.collect { case impl: TypeWithFields => impl }\n    impls.flatMap(validateImplementor)\n  }\n\n  def validateTypeExtensions(defns: List[TypeDefinition], extnDefns: List[Ast.TypeExtension]): List[Problem] = {\n    extnDefns.mapFilter { extension =>\n      val notFound = Some(Problem(s\"Unable apply extension to non-existent ${extension.baseType.name}\"))\n      defns.find(_.name == extension.baseType.astName).fold[Option[Problem]](notFound) { baseType =>\n        def wrongTypeExtended(typ: String) = Problem(s\"Attempted to apply $typ extension to ${baseType.name.value} but it is not a $typ\").some\n\n        extension match {\n          case _: Ast.ScalarTypeExtension =>\n            baseType match {\n              case _: Ast.ScalarTypeDefinition => None\n              case _ => wrongTypeExtended(\"Scalar\")\n          }\n          case _: Ast.InterfaceTypeExtension =>\n            baseType match {\n              case _: Ast.InterfaceTypeDefinition => None\n              case _ => wrongTypeExtended(\"Interface\")\n            }\n          case _: Ast.ObjectTypeExtension =>\n            baseType match {\n              case _: Ast.ObjectTypeDefinition => None\n              case _ => wrongTypeExtended(\"Object\")\n            }\n          case _: Ast.UnionTypeExtension =>\n            baseType match {\n              case _: Ast.UnionTypeDefinition => None\n              case _ => wrongTypeExtended(\"Union\")\n            }\n          case _: Ast.EnumTypeExtension =>\n            baseType match {\n              case _: Ast.EnumTypeDefinition => None\n              case _ => wrongTypeExtended(\"Enum\")\n            }\n          case _: Ast.InputObjectTypeExtension =>\n            baseType match {\n              case _: Ast.InputObjectTypeDefinition => None\n              case _ => wrongTypeExtended(\"Input Object\")\n            }\n        }\n      }\n    }\n  }\n}\n\nobject SchemaRenderer {\n  def renderSchema(schema: Schema): String = {\n    val schemaDefn = {\n      val dirs0 = schema.baseSchemaType.directives\n      if (\n        schema.queryType.name == \"Query\" &&\n        schema.mutationType.forall(_.name == \"Mutation\") &&\n        schema.subscriptionType.forall(_.name == \"Subscription\") &&\n        dirs0.isEmpty\n      ) \"\"\n      else {\n        val fields =\n          schema.baseSchemaType match {\n            case twf: TypeWithFields => twf.fields.map(renderField)\n            case _ => Nil\n          }\n\n        val dirs = renderDirectives(dirs0)\n        fields.mkString(s\"schema$dirs {\\n  \", \"\\n  \", \"\\n}\\n\")\n      }\n    }\n\n    val schemaExtnDefns =\n      if(schema.schemaExtensions.isEmpty) \"\"\n      else \"\\n\"+schema.schemaExtensions.map(renderSchemaExtension).mkString(\"\\n\")\n\n    val typeExtnDefns =\n      if(schema.typeExtensions.isEmpty) \"\"\n      else \"\\n\"+schema.typeExtensions.map(renderTypeExtension).mkString(\"\\n\")\n\n    val dirDefns = {\n      val nonBuiltInDefns =\n        schema.directives.filter {\n          case DirectiveDef(\"skip\"|\"include\"|\"deprecated\", _, _, _, _) => false\n          case _ => true\n        }\n\n      if(nonBuiltInDefns.isEmpty) \"\"\n      else \"\\n\"+nonBuiltInDefns.map(renderDirectiveDefn).mkString(\"\\n\")+\"\\n\"\n    }\n\n    schemaDefn ++\n      schema.baseTypes.map(renderTypeDefn).mkString(\"\\n\") ++\n      schemaExtnDefns ++\n      typeExtnDefns ++\n      dirDefns\n  }\n\n  def renderDescription(desc: Option[String]): String =\n    desc match {\n      case None => \"\"\n      case Some(desc) => s\"\"\"\"$desc\"\\n\"\"\"\n    }\n\n  def renderDirectives(dirs: List[Directive]): String =\n    if (dirs.isEmpty) \"\" else dirs.map(renderDirective).mkString(\" \", \" \", \"\")\n\n  def renderDirective(d: Directive): String = {\n    val Directive(name, args0) = d\n    val args = if(args0.isEmpty) \"\" else args0.map { case Binding(nme, v) => s\"$nme: ${renderValue(v)}\" }.mkString(\"(\", \", \", \")\")\n    s\"@$name$args\"\n  }\n\n  def renderField(f: Field): String = {\n    val Field(nme, _, args, tpe, dirs0) = f\n    val dirs = renderDirectives(dirs0)\n    if (args.isEmpty)\n      s\"$nme: ${renderType(tpe)}$dirs\"\n    else\n      s\"$nme(${args.map(renderInputValue).mkString(\", \")}): ${renderType(tpe)}$dirs\"\n  }\n\n  def renderSchemaExtension(extension: SchemaExtension): String = {\n    val SchemaExtension(ops0, dirs0) = extension\n    val dirs = renderDirectives(dirs0)\n    val ops =\n      if (ops0.isEmpty) \"\"\n      else\n        s\"\"\"| {\n            |  ${ops0.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n    s\"extend schema$dirs$ops\"\n  }\n\n  def renderTypeExtension(extension: TypeExtension): String = {\n    extension match {\n      case ScalarExtension(nme, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"extend scalar $nme$dirs\"\n\n      case ObjectExtension(nme, fields0, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderField).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend type $nme$ifs$dirs$fields\"\n\n      case InterfaceExtension(nme, fields0, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderField).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend interface $nme$ifs$dirs$fields\"\n\n      case UnionExtension(nme, members0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val members =\n          if(members0.isEmpty) \"\"\n          else s\" = ${members0.map(_.name).mkString(\" | \")}\"\n\n        s\"extend union $nme$dirs$members\"\n\n      case EnumExtension(nme, values0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val values =\n          if(values0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${values0.map(renderEnumValueDefinition).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend enum $nme$dirs$values\"\n\n      case InputObjectExtension(nme, fields0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderInputValue).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend input $nme$dirs$fields\"\n    }\n  }\n\n  def renderTypeDefn(tpe: NamedType): String = {\n    tpe match {\n      case tr: TypeRef => renderTypeDefn(tr.dealias)\n\n      case ScalarType(nme, _, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"scalar $nme$dirs\"\"\"\n\n      case ObjectType(nme, _, fields, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n\n        s\"\"\"|type $nme$ifs$dirs {\n            |  ${fields.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case InterfaceType(nme, _, fields, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n\n        s\"\"\"|interface $nme$ifs$dirs {\n            |  ${fields.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case UnionType(nme, _, members, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"union $nme$dirs = ${members.map(_.name).mkString(\" | \")}\"\"\"\n\n      case EnumType(nme, _, values, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"|enum $nme$dirs {\n            |  ${values.map(renderEnumValueDefinition).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case InputObjectType(nme, _, fields, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"|input $nme$dirs {\n            |  ${fields.map(renderInputValue).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n    }\n  }\n\n  def renderType(tpe: Type): String = {\n    def loop(tpe: Type, nullable: Boolean): String = {\n      def wrap(tpe: String) = if (nullable) tpe else s\"$tpe!\"\n\n      tpe match {\n        case NullableType(tpe) => loop(tpe, true)\n        case ListType(tpe) => wrap(s\"[${loop(tpe, false)}]\")\n        case nt: NamedType => wrap(nt.name)\n      }\n    }\n\n    loop(tpe, false)\n  }\n\n  def renderDirectiveDefn(directive: DirectiveDef): String = {\n     val DirectiveDef(nme, desc, args, repeatable, locations) = directive\n     val rpt = if (repeatable) \" repeatable\" else \"\"\n     if (args.isEmpty)\n       s\"${renderDescription(desc)}directive @$nme$rpt on ${locations.mkString(\"|\")}\"\n     else\n       s\"${renderDescription(desc)}directive @$nme(${args.map(renderInputValue).mkString(\", \")})$rpt on ${locations.mkString(\"|\")}\"\n  }\n\n  def renderEnumValueDefinition(v: EnumValueDefinition): String = {\n    val EnumValueDefinition(nme, _, dirs0) = v\n    val dirs = renderDirectives(dirs0)\n    s\"$nme$dirs\"\n  }\n\n  def renderInputValue(iv: InputValue): String = {\n    val InputValue(nme, _, tpe, default, dirs0) = iv\n    val dirs = renderDirectives(dirs0)\n    val df = default.map(v => s\" = ${renderValue(v)}\").getOrElse(\"\")\n    s\"$nme: ${renderType(tpe)}$df$dirs\"\n  }\n\n  def renderValue(value: Value): String = value match {\n    case IntValue(i) => i.toString\n    case FloatValue(f) => f.toString\n    case StringValue(s) => s\"\"\"\"$s\"\"\"\"\n    case BooleanValue(b) => b.toString\n    case IDValue(i) => s\"\"\"\"$i\"\"\"\"\n    case EnumValue(e) => e\n    case ListValue(elems) => elems.map(renderValue).mkString(\"[\", \", \", \"]\")\n    case ObjectValue(fields) =>\n      fields.map {\n        case (name, value) => s\"$name : ${renderValue(value)}\"\n      }.mkString(\"{\", \", \", \"}\")\n    case _ => \"null\"\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.data.NonEmptyChain\nimport cats.implicits._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Predicate._, Value._, UntypedOperation._\nimport QueryCompiler._, ComponentElaborator.TrivialJoin\n\nfinal class CompilerSuite extends CatsEffectSuite {\n  test(\"simple query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple mutation\") {\n    val query = \"\"\"\n      mutation {\n        update_character(id: \"1000\", name: \"Luke\") {\n          character {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"update_character\", None, List(Binding(\"id\", StringValue(\"1000\")), Binding(\"name\", StringValue(\"Luke\"))), Nil,\n        UntypedSelect(\"character\", None, Nil, Nil,\n          UntypedSelect(\"name\", None, Nil, Nil, Empty)\n        )\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedMutation(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple subscription\") {\n    val query = \"\"\"\n      subscription {\n        character(id: \"1000\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedSubscription(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple nested query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n          friends {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n          UntypedSelect(\n            \"friends\", None, Nil, Nil,\n            UntypedSelect(\"name\", None, Nil, Nil, Empty)\n          )\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"hero\", None, List(Binding(\"episode\", EnumValue(\"NEWHOPE\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n        UntypedSelect(\"friends\", None, Nil, Nil,\n          UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n          UntypedSelect(\"friends\", None, Nil, Nil,\n            UntypedSelect(\"name\", None, Nil, Nil, Empty)\n          )\n        )\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"user\", None, List(Binding(\"id\", IntValue(4))), Nil,\n        Group(List(\n          UntypedSelect(\"id\", None, Nil, Nil, Empty),\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"profilePic\", Some(\"smallPic\"), List(Binding(\"size\", IntValue(64))), Nil, Empty),\n          UntypedSelect(\"profilePic\", Some(\"bigPic\"), List(Binding(\"size\", IntValue(1024))), Nil, Empty)\n        ))\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"__schema\", None, Nil, Nil,\n        UntypedSelect(\"queryType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty)) ~\n        UntypedSelect(\"mutationType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty)) ~\n        UntypedSelect(\"subscriptionType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty))\n      )\n\n    val res = QueryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(Some(\"IntrospectionQuery\"), expected, Nil, Nil))))\n  }\n\n  test(\"simple selector elaborated query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n          friends {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Select(\n        \"character\", None,\n        Unique(\n          Filter(Eql(AtomicMapping.CharacterType / \"id\", Const(\"1000\")),\n          Select(\"name\") ~\n              Select(\n                \"friends\",\n                Select(\"name\")\n              )\n          )\n        )\n    )\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res.map(_.query), Result.Success(expected))\n  }\n\n  test(\"invalid: object subselection set empty\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\")\n      }\n    \"\"\"\n\n    val expected = Problem(\"Non-leaf field 'character' of Query must have a non-empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: object subselection set invalid\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          foo\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"No field 'foo' for type Character\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: leaf subselection set not empty (1)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name {\n            __typename\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Leaf field 'name' of Character must have an empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: leaf subselection set not empty (2)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name {\n            foo\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Leaf field 'name' of Character must have an empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: bogus field argument\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\", quux: 23) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Unknown argument(s) 'quux' in field character of type Query\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"simple component elaborated query\") {\n    val query = \"\"\"\n      query {\n        componenta {\n          fielda1\n          fielda2 {\n            componentb {\n              fieldb1\n              fieldb2 {\n                componentc {\n                  fieldc1\n                }\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Component(ComponentA, TrivialJoin,\n        Select(\"componenta\",\n          Select(\"fielda1\") ~\n          Select(\"fielda2\",\n            Component(ComponentB, TrivialJoin,\n              Select(\"componentb\",\n                Select(\"fieldb1\") ~\n                Select(\"fieldb2\",\n                  Component(ComponentC, TrivialJoin,\n                    Select(\"componentc\",\n                      Select(\"fieldc1\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n\n    val res = ComposedMapping.compiler.compile(query)\n\n    assertEquals(res.map(_.query), Result.Success(expected))\n  }\n\n  test(\"malformed query (1)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\" {\n          name\n        }\n      }\n    \"\"\"\n\n    val res = QueryParser.parseText(query)\n\n    val error =\n      \"\"\"Parse error at line 2 column 29\n        |        character(id: \"1000\" {\n        |                             ^\"\"\".stripMargin\n\n    assertEquals(res, Result.failure(error))\n  }\n\n  test(\"malformed query (2)\") {\n    val query = \"\"\n\n    val res = QueryParser.parseText(query)\n\n    assertEquals(res, Result.failure(\"At least one operation required\"))\n  }\n\n  test(\"malformed query (3)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n        }\n    \"\"\"\n\n    val res = QueryParser.parseText(query)\n\n    val error =\n      \"Parse error at line 5 column 4\\n    \\n    ^\"\n\n    assertEquals(res, Result.failure(error))\n  }\n}\n\nobject AtomicMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        character(id: String!): Character\n      }\n      type Character {\n        id: String!\n        name: String\n        friends: [Character!]\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val CharacterType = schema.ref(\"Character\")\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"character\", List(Binding(\"id\", StringValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(CharacterType / \"id\", Const(id)), child)))\n  }\n}\ntrait DummyComponent extends TestMapping {\n  val schema = schema\"type Query { dummy: Int }\"\n}\n\nobject ComponentA extends DummyComponent\nobject ComponentB extends DummyComponent\nobject ComponentC extends DummyComponent\n\nobject ComposedMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        componenta: ComponentA!\n      }\n      type ComponentA {\n        fielda1: String!\n        fielda2: FieldA2\n      }\n      type FieldA2 {\n        componentb: ComponentB\n      }\n      type ComponentB {\n        fieldb1: String!\n        fieldb2: FieldB2\n      }\n      type FieldB2 {\n        componentc: ComponentC\n      }\n      type ComponentC {\n        fieldc1: Int\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val FieldA2Type = schema.ref(\"FieldA2\")\n  val FieldB2Type = schema.ref(\"FieldB2\")\n\n  override val typeMappings =\n    List(\n      ObjectMapping(\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            Delegate(\"componenta\", ComponentA)\n          )\n      ),\n      ObjectMapping(\n        tpe = FieldA2Type,\n        fieldMappings =\n          List(\n            Delegate(\"componentb\", ComponentB)\n          )\n      ),\n      ObjectMapping(\n        tpe = FieldB2Type,\n        fieldMappings =\n          List(\n            Delegate(\"componentc\", ComponentC)\n          )\n      )\n    )\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Ast.DirectiveLocation._\nimport Query._\n\nfinal class DirectivesSuite extends CatsEffectSuite {\n  def testDirectiveDefs(s: Schema): List[DirectiveDef] =\n    s.directives.filter {\n      case DirectiveDef(\"skip\"|\"include\"|\"deprecated\", _, _, _, _) => false\n      case _ => true\n    }\n\n  test(\"Simple directive definition\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with description\") {\n    val expected = DirectiveDef(\"foo\", Some(\"A directive\"), Nil, false, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        \"A directive\"\n        directive @foo on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with multiple locations (1)\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD, FRAGMENT_SPREAD, INLINE_FRAGMENT))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with multiple locations (2)\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD, FRAGMENT_SPREAD, INLINE_FRAGMENT))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on | FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with repeatable\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, true, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo repeatable on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with arguments (1)\") {\n    val expected =\n      DirectiveDef(\n        \"foo\",\n        None,\n        List(InputValue(\"arg\", None, ScalarType.StringType, None, Nil)),\n        false,\n        List(FIELD)\n      )\n\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo(arg: String!) on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with arguments (2)\") {\n    val expected =\n      DirectiveDef(\n        \"foo\",\n        None,\n        List(\n          InputValue(\"arg0\", None, ScalarType.StringType, None, Nil),\n          InputValue(\"arg1\", None, NullableType(ScalarType.IntType), None, Nil)\n        ),\n        false,\n        List(FIELD)\n      )\n\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo(arg0: String!, arg1: Int) on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Schema with directives\") {\n    val schema =\n    \"\"\"|schema @foo {\n       |  query: Query\n       |}\n       |scalar Scalar @foo\n       |interface Interface @foo {\n       |  field(e: Enum, i: Input): Int @foo\n       |}\n       |type Object implements Interface @foo {\n       |  field(e: Enum, i: Input): Int @foo\n       |}\n       |union Union @foo = Object\n       |enum Enum @foo {\n       |  VALUE @foo\n       |}\n       |input Input @foo {\n       |  field: Int @foo\n       |}\n       |directive @foo on SCHEMA|SCALAR|OBJECT|FIELD_DEFINITION|ARGUMENT_DEFINITION|INTERFACE|UNION|ENUM|ENUM_VALUE|INPUT_OBJECT|INPUT_FIELD_DEFINITION\n       |\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"Query with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.QueryType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|query @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Mutation with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.MutationType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|mutation @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Subscription with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.SubscriptionType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|subscription @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Fragment with directive\") { // TOD: will need new elaborator to expose fragment directives\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, Nil,\n          Narrow(DirectiveMapping.BazType,\n            UntypedSelect(\"baz\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n          )\n        ),\n        DirectiveMapping.QueryType,\n        Nil\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    ... Frag @dir\n         |  }\n         |}\n         |fragment Frag on Baz @dir {\n         |  baz @dir\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Inline fragment with directive\") { // TOD: will need new elaborator to expose fragment directives\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, Nil,\n          Narrow(DirectiveMapping.BazType,\n            UntypedSelect(\"baz\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n          )\n        ),\n        DirectiveMapping.QueryType,\n        Nil\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    ... on Baz @dir {\n         |      baz @dir\n         |    }\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n}\n\nobject DirectiveMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        foo: Bar\n      }\n      type Mutation {\n        foo: Bar\n      }\n      type Subscription {\n        foo: Bar\n      }\n      interface Bar {\n        id: ID\n      }\n      type Baz implements Bar {\n        id: ID\n        baz: Int\n      }\n      directive @dir on QUERY|MUTATION|SUBSCRIPTION|FIELD|FRAGMENT_DEFINITION|FRAGMENT_SPREAD|INLINE_FRAGMENT\n    \"\"\"\n\n  val QueryType = schema.queryType\n  val MutationType = schema.mutationType.get\n  val SubscriptionType = schema.subscriptionType.get\n  val BazType = schema.ref(\"Baz\")\n\n  override val selectElaborator = PreserveArgsElaborator\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.effect.IO\nimport cats.implicits._\nimport io.circe.Json\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Predicate._, Value._\nimport QueryCompiler._\n\nfinal class FragmentSuite extends CatsEffectSuite {\n  def runOperation(op: Result[Operation]): IO[List[Json]] = {\n    val op0 = op.toOption.get\n    FragmentMapping.interpreter.run(op0.query, op0.rootTpe, Env.empty).evalMap(FragmentMapping.mkResponse).compile.toList\n  }\n\n  test(\"simple fragment query\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Group(List(\n              Select(\"friends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              ),\n              Select(\"mutualFriends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              )\n            ))\n          )\n        )\n    )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ],\n            \"mutualFriends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"nested fragment query\") {\n    val query = \"\"\"\n      query withNestedFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        ...standardProfilePic\n      }\n\n      fragment standardProfilePic on User {\n        profilePic\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Group(List(\n              Select(\"friends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              ),\n              Select(\"mutualFriends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              )\n            ))\n          )\n        )\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ],\n            \"mutualFriends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"typed fragment query\") {\n    val query = \"\"\"\n      query FragmentTyping {\n        profiles {\n          id\n          __typename\n          ...userFragment\n          ...pageFragment\n        }\n      }\n\n      fragment userFragment on User {\n        name\n      }\n\n      fragment pageFragment on Page {\n        title\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Select(\"profiles\",\n        Group(List(\n          Select(\"id\"),\n          Introspect(FragmentMapping.schema, Select(\"__typename\")),\n          Narrow(User, Select(\"name\")),\n          Narrow(Page, Select(\"title\"))\n        ))\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"profiles\" : [\n            {\n              \"id\" : \"1\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Alice\"\n            },\n            {\n              \"id\" : \"2\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Bob\"\n            },\n            {\n              \"id\" : \"3\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Carol\"\n            },\n            {\n              \"id\" : \"4\",\n              \"__typename\" : \"Page\",\n              \"title\" : \"GraphQL\"\n            },\n            {\n              \"id\" : \"5\",\n              \"__typename\" : \"Page\",\n              \"title\" : \"Scala\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"inline fragment query\") {\n    val query = \"\"\"\n      query inlineFragmentTyping {\n        profiles {\n          id\n          ... on User {\n            name\n          }\n          ... on Page {\n            title\n          }\n        }\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Select(\"profiles\",\n        Group(List(\n          Select(\"id\"),\n          Narrow(User, Select(\"name\")),\n          Narrow(Page, Select(\"title\"))\n        ))\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"profiles\" : [\n            {\n              \"id\" : \"1\",\n              \"name\" : \"Alice\"\n            },\n            {\n              \"id\" : \"2\",\n              \"name\" : \"Bob\"\n            },\n            {\n              \"id\" : \"3\",\n              \"name\" : \"Carol\"\n            },\n            {\n              \"id\" : \"4\",\n              \"title\" : \"GraphQL\"\n            },\n            {\n              \"id\" : \"5\",\n              \"title\" : \"Scala\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"typed union fragment query\") {\n    val query = \"\"\"\n      query FragmentUnionTyping {\n        user: user(id: \"1\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n        page: user(id: \"2\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n      }\n\n      fragment userFragment on User {\n        id\n        name\n      }\n\n      fragment pageFragment on Page {\n        id\n        title\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Group(List(\n        Select(\"user\",\n          Unique(\n            Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n              Select(\"favourite\",\n                Group(List(\n                  Introspect(FragmentMapping.schema, Select(\"__typename\")),\n                  Narrow(\n                    User,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"name\")\n                    ))\n                  ),\n                  Narrow(\n                    Page,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"title\")\n                    ))\n                   )\n                ))\n              )\n            )\n          )\n        ),\n        Select(\"user\", Some(\"page\"),\n          Unique(\n            Filter(Eql(FragmentMapping.PageType / \"id\", Const(\"2\")),\n              Select(\"favourite\",\n                Group(List(\n                  Introspect(FragmentMapping.schema, Select(\"__typename\")),\n                  Narrow(\n                    User,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"name\")\n                    ))\n                  ),\n                  Narrow(\n                    Page,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"title\")\n                    ))\n                  )\n                ))\n              )\n            )\n          )\n        )\n      ))\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"favourite\" : {\n              \"__typename\" : \"User\",\n              \"id\" : \"2\",\n              \"name\" : \"Bob\"\n            }\n          },\n          \"page\" : {\n            \"favourite\" : {\n              \"__typename\" : \"Page\",\n              \"id\" : \"4\",\n              \"title\" : \"GraphQL\"\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"supertype fragment query (1)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...profileFields\n          }\n        }\n      }\n\n      fragment profileFields on Profile {\n        id\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Select(\"friends\",\n              Select(\"id\")\n            )\n          )\n        )\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\"\n              },\n              {\n                \"id\" : \"3\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"supertype fragment query (2)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\"\n              },\n              {\n                \"id\" : \"3\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (3)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              ... on User {\n                name\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (4)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"No field 'name' for type Profile\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (5)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...profileFields\n          }\n        }\n      }\n\n      fragment profileFields on Profile {\n        id\n        name\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"No field 'name' for type Profile\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with supertype fragment containing subtype refinement\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... ProfileFields\n          }\n        }\n      }\n\n      fragment ProfileFields on Profile {\n        id\n        ... on User {\n          name\n        }\n        ... on Page {\n          title\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with supertype fragment containing nested fragment spreads\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... ProfileFields\n          }\n        }\n      }\n\n      fragment ProfileFields on Profile {\n        id\n        ... UserFields\n        ... PageFields\n      }\n\n      fragment UserFields on User {\n        name\n      }\n\n      fragment PageFields on Page {\n        title\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with nested inline fragments\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              ... on User {\n                name\n              }\n              ... on Page {\n                title\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n}\n\nobject FragmentData {\n  sealed trait Profile {\n    def id: String\n  }\n\n  case class User(id: String, name: String, profilePic: String, friendIds: List[String], favouriteId: Option[String]) extends Profile {\n    def friends: List[User] =\n      friendIds.flatMap(fid => profiles.collect { case u: User if u.id == fid => u })\n    def mutualFriends: List[User] =\n      friendIds.flatMap(fid => profiles.collect { case u: User if u.id == fid && u.friendIds.contains(id) => u })\n    def favourite: Option[Profile] =\n      favouriteId.flatMap(id => profiles.find(_.id == id))\n  }\n\n  case class Page(id: String, title: String, likerIds: List[String]) extends Profile {\n    def likers: List[User] =\n      likerIds.flatMap(lid => profiles.collect { case u: User if u.id == lid => u })\n  }\n\n  val profiles = List(\n    User(\"1\", \"Alice\", \"A\", List(\"2\", \"3\"), Some(\"2\")),\n    User(\"2\", \"Bob\", \"B\", List(\"1\"), Some(\"4\")),\n    User(\"3\", \"Carol\", \"C\", List(\"1\", \"2\"), None),\n    Page(\"4\", \"GraphQL\", List(\"1\", \"3\")),\n    Page(\"5\", \"Scala\", List(\"2\"))\n  )\n}\n\nobject FragmentMapping extends ValueMapping[IO] {\n  import FragmentData._\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        user(id: ID!): User!\n        profiles: [Profile!]!\n      }\n      type User implements Profile {\n        id: String!\n        name: String!\n        profilePic: String!\n        friends: [User!]!\n        mutualFriends: [User!]!\n        favourite: UserOrPage\n      }\n      type Page implements Profile {\n        id: String!\n        title: String!\n        likers: [User!]!\n      }\n      union UserOrPage = User | Page\n      interface Profile {\n        id: String!\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val ProfileType = schema.ref(\"Profile\")\n  val UserType = schema.ref(\"User\")\n  val PageType = schema.ref(\"Page\")\n\n  val typeMappings =\n    List(\n      ValueObjectMapping[Unit](\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            ValueField(\"user\", _ => profiles.collect { case u: User => u }),\n            ValueField(\"profiles\", _ => profiles)\n          )\n      ),\n      ValueObjectMapping[Profile](\n        tpe = ProfileType,\n        fieldMappings =\n          List(\n            ValueField(\"id\", _.id)\n          )\n      ),\n      ValueObjectMapping[User](\n        tpe = UserType,\n        fieldMappings =\n          List(\n            ValueField(\"name\", _.name),\n            ValueField(\"profilePic\", _.profilePic),\n            ValueField(\"friends\", _.friends),\n            ValueField(\"mutualFriends\", _.mutualFriends),\n            ValueField(\"favourite\", _.favourite),\n          )\n      ),\n      ValueObjectMapping[Page](\n        tpe = PageType,\n        fieldMappings =\n          List(\n            ValueField(\"title\", _.title),\n            ValueField(\"likers\", _.likers)\n          )\n      )\n    )\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"user\", List(Binding(\"id\", IDValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(FragmentMapping.UserType / \"id\", Const(id)), child)))\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.data.NonEmptyChain\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Value._\n\nfinal class VariablesSuite extends CatsEffectSuite {\n  test(\"simple variables query\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"devicePicSize\": 60\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n        Group(List(\n          UntypedSelect(\"id\", None, Nil, Nil, Empty),\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"profilePic\", None, List(Binding(\"size\", IntValue(60))), Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"list variable query\") {\n    val query = \"\"\"\n      query getProfile($ids: [ID!]) {\n        users(ids: $ids) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"ids\": [1, 2, 3]\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"users\", None,\n        List(Binding(\"ids\", ListValue(List(IDValue(\"1\"), IDValue(\"2\"), IDValue(\"3\"))))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"enum variable query\") {\n    val query = \"\"\"\n      query getUserType($userType: UserType) {\n        usersByType(userType: $userType) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"userType\": \"ADMIN\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"usersByType\", None,\n        List(Binding(\"userType\", EnumValue(\"ADMIN\"))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable query\") {\n    val query = \"\"\"\n      query getLoggedInByDate($date: Date) {\n        usersLoggedInByDate(date: $date) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"date\": \"2021-02-22\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"usersLoggedInByDate\", None,\n        List(Binding(\"date\", StringValue(\"2021-02-22\"))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable query bigdecimal\") {\n    val query = \"\"\"\n      query queryWithBigDecimal($input: BigDecimal) {\n        queryWithBigDecimal(input: $input) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"input\": 2021\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"queryWithBigDecimal\", None,\n        List(Binding(\"input\", IntValue(2021))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"object variable query\") {\n    val query = \"\"\"\n      query doSearch($pattern: Pattern) {\n        search(pattern: $pattern) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"pattern\": {\n          \"name\": \"Foo\",\n          \"age\": 23,\n          \"id\": 123\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"invalid: bogus input object field\") {\n    val query = \"\"\"\n      query doSearch($pattern: Pattern) {\n        search(pattern: $pattern) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"pattern\": {\n          \"name\": \"Foo\",\n          \"age\": 23,\n          \"id\": 123,\n          \"quux\": 23\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Unknown field(s) 'quux' in input object value of type Pattern in variable values\")\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Failure(NonEmptyChain.one(expected)))\n  }\n\n  test(\"variable within list query\") {\n    val query = \"\"\"\n      query getProfile($id: ID!) {\n        users(ids: [1, $id, 3]) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"id\": 2\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"users\", None,\n        List(Binding(\"ids\", ListValue(List(IDValue(\"1\"), IDValue(\"2\"), IDValue(\"3\"))))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"simple variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($age: Int) {\n        search(pattern: { name: \"Foo\", age: $age, id: 123} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"age\": 23\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"enum variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($userType: UserType) {\n        search(pattern: { name: \"Foo\", age: 23, id: 123, userType: $userType} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"userType\": \"ADMIN\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", EnumValue(\"ADMIN\")),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($date: Date) {\n        search(pattern: { name: \"Foo\", age: 23, id: 123, date: $date} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"date\": \"2021-02-22\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", StringValue(\"2021-02-22\"))\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n}\n\nobject VariablesMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        user(id: ID!): User!\n        users(ids: [ID!]!): [User!]!\n        search(pattern: Pattern!): [User!]!\n        usersByType(userType: UserType!): [User!]!\n        usersLoggedInByDate(date: Date!): [User!]!\n        queryWithBigDecimal(input: BigDecimal!): [User!]!\n      }\n      type User {\n        id: String!\n        name: String!\n        profilePic(size: Int): String!\n      }\n      input Pattern {\n        name: String\n        age: Int\n        id: ID\n        userType: UserType\n        date: Date\n      }\n      enum UserType {\n        ADMIN\n        NORMAL\n      }\n      scalar Date\n      scalar BigDecimal\n    \"\"\"\n\n  override val selectElaborator = PreserveArgsElaborator\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage directives\n\nimport cats.MonadThrow\nimport cats.data.Chain\nimport cats.effect.IO\nimport cats.implicits._\nimport munit.CatsEffectSuite\n\nimport compiler.PreserveArgsElaborator\nimport grackle._\nimport grackle.syntax._\nimport Query._\n\nfinal class DirectiveValidationSuite extends CatsEffectSuite {\n  test(\"Schema with validly located directives\") {\n    val schema =\n      Schema(\n        \"\"\"\n          schema @onSchema {\n            query: Query @onFieldDefinition\n          }\n\n          type Query @onObject {\n            field: Interface @onFieldDefinition\n          }\n\n          interface Interface @onInterface {\n            field: String @onFieldDefinition\n          }\n\n          type Object1 implements Interface @onObject {\n            field: String @onFieldDefinition\n            fieldWithArg(arg: Input @onArgumentDefinition): String @onFieldDefinition\n            unionField: Union @onFieldDefinition\n            enumField: Enum @onFieldDefinition\n            scalarField: Scalar @onFieldDefinition\n          }\n\n          type Object2 implements Interface @onObject {\n            field: String @onFieldDefinition\n          }\n\n          union Union @onUnion = Object1 | Object2\n\n          enum Enum @onEnum {\n            FOO @onEnumValue\n            BAR @onEnumValue\n          }\n\n          scalar Scalar @onScalar\n\n          input Input @onInputObject {\n            field: String @onInputFieldDefinition\n          }\n\n          directive @onSchema on SCHEMA\n          directive @onScalar on SCALAR\n          directive @onObject on OBJECT\n          directive @onFieldDefinition on FIELD_DEFINITION\n          directive @onArgumentDefinition on ARGUMENT_DEFINITION\n          directive @onInterface on INTERFACE\n          directive @onUnion on UNION\n          directive @onEnum on ENUM\n          directive @onEnumValue on ENUM_VALUE\n          directive @onInputObject on INPUT_OBJECT\n          directive @onInputFieldDefinition on INPUT_FIELD_DEFINITION\n        \"\"\"\n      )\n\n    assertEquals(schema.toProblems, Chain.empty)\n  }\n\n  test(\"Schema with invalidly located directives\") {\n    val schema =\n      Schema(\n        \"\"\"\n          schema @onFieldDefinition {\n            query: Query @onSchema\n          }\n\n          type Query @onSchema {\n            field: Interface @onSchema\n          }\n\n          interface Interface @onSchema {\n            field: String @onSchema\n          }\n\n          type Object1 implements Interface @onSchema {\n            field: String @onSchema\n            fieldWithArg(arg: Input @onSchema): String @onSchema\n            unionField: Union @onSchema\n            enumField: Enum @onSchema\n            scalarField: Scalar @onSchema\n          }\n\n          type Object2 implements Interface @onSchema {\n            field: String @onSchema\n          }\n\n          union Union @onSchema = Object1 | Object2\n\n          enum Enum @onSchema {\n            FOO @onSchema\n            BAR @onSchema\n          }\n\n          scalar Scalar @onSchema\n\n          input Input @onSchema {\n            field: String @onSchema\n          }\n\n          directive @onSchema on SCHEMA\n          directive @onFieldDefinition on FIELD_DEFINITION\n        \"\"\"\n      )\n\n    val problems =\n      Chain(\n        Problem(\"Directive 'onFieldDefinition' is not allowed on SCHEMA\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on INTERFACE\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on ARGUMENT_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on UNION\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM_VALUE\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM_VALUE\"),\n        Problem(\"Directive 'onSchema' is not allowed on SCALAR\"),\n        Problem(\"Directive 'onSchema' is not allowed on INPUT_OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on INPUT_FIELD_DEFINITION\")\n      )\n\n    assertEquals(schema.toProblems, problems)\n  }\n\n  test(\"Schema with invalid directive arguments\") {\n    val schema =\n      Schema(\n        \"\"\"\n          type Query {\n            f1: Int @withArg(i: 1)\n            f2: Int @withArg\n            f3: Int @withArg(i: \"foo\")\n            f4: Int @withArg(x: \"foo\")\n            f5: Int @withRequiredArg(i: 1)\n            f6: Int @withRequiredArg\n            f7: Int @withRequiredArg(i: \"foo\")\n            f8: Int @withRequiredArg(x: \"foo\")\n            f9: Int @deprecated(reason: \"foo\")\n            f10: Int @deprecated\n            f11: Int @deprecated(reason: 1)\n            f12: Int @deprecated(x: \"foo\")\n          }\n\n          directive @withArg(i: Int) on FIELD_DEFINITION\n          directive @withRequiredArg(i: Int!) on FIELD_DEFINITION\n        \"\"\"\n      )\n\n    val problems =\n      Chain(\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withArg\"\"\"),\n        Problem(\"\"\"Value of type Int required for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected String found '1' for 'reason' in directive deprecated\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive deprecated\"\"\"),\n      )\n\n    assertEquals(schema.toProblems, problems)\n  }\n\n  test(\"Query with validly located directives\") {\n    val expected =\n      List(\n        Operation(\n          UntypedSelect(\"foo\", None, Nil, List(Directive(\"onField\", Nil)),\n            Group(\n              List(\n                UntypedSelect(\"bar\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n                UntypedSelect(\"bar\",None, Nil, List(Directive(\"onField\", Nil)), Empty)\n              )\n            )\n          ),\n          ExecutableDirectiveMapping.QueryType,\n          List(Directive(\"onQuery\",List()))\n        ),\n        Operation(\n          UntypedSelect(\"foo\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n          ExecutableDirectiveMapping.MutationType,\n          List(Directive(\"onMutation\",List()))\n        ),\n        Operation(\n          UntypedSelect(\"foo\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n          ExecutableDirectiveMapping.SubscriptionType,\n          List(Directive(\"onSubscription\",List()))\n        )\n      )\n\n    val query =\n      \"\"\"|query ($var: Boolean @onVariableDefinition) @onQuery {\n         |  foo @onField {\n         |    ...Frag @onFragmentSpread\n         |    ... @onInlineFragment {\n         |      bar @onField\n         |    }\n         |  }\n         |}\n         |\n         |mutation @onMutation {\n         |  foo @onField\n         |}\n         |\n         |subscription @onSubscription {\n         |  foo @onField\n         |}\n         |\n         |fragment Frag on Foo @onFragmentDefinition {\n         |  bar @onField\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Query with invalidly located directives\") {\n    val problems =\n      Chain(\n        Problem(\"Directive 'onField' is not allowed on VARIABLE_DEFINITION\"),\n        Problem(\"Directive 'onField' is not allowed on QUERY\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_SPREAD\"),\n        Problem(\"Directive 'onField' is not allowed on INLINE_FRAGMENT\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on MUTATION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on SUBSCRIPTION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\")\n      )\n\n    val query =\n      \"\"\"|query ($var: Boolean @onField) @onField {\n         |  foo @onQuery {\n         |    ...Frag @onField\n         |    ... @onField {\n         |      bar @onQuery\n         |    }\n         |  }\n         |}\n         |\n         |mutation @onField {\n         |  foo @onQuery\n         |}\n         |\n         |subscription @onField {\n         |  foo @onQuery\n         |}\n         |\n         |fragment Frag on Foo @onField {\n         |  bar @onQuery\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res.toProblems, problems)\n  }\n\n  test(\"Query with invalid directive arguments\") {\n    val problems =\n      Chain(\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withArg\"\"\"),\n        Problem(\"\"\"Value of type Int required for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withRequiredArg\"\"\")\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    b1: bar @withArg(i: 1)\n         |    b2: bar @withArg\n         |    b3: bar @withArg(i: \"foo\")\n         |    b4: bar @withArg(x: \"foo\")\n         |    b5: bar @withRequiredArg(i: 1)\n         |    b6: bar @withRequiredArg\n         |    b7: bar @withRequiredArg(i: \"foo\")\n         |    b8: bar @withRequiredArg(x: \"foo\")\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res.toProblems, problems)\n  }\n}\n\nobject ExecutableDirectiveMapping extends Mapping[IO] {\n  val M: MonadThrow[IO] = MonadThrow[IO]\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        foo: Foo\n      }\n      type Mutation {\n        foo: String\n      }\n      type Subscription {\n        foo: String\n      }\n      type Foo {\n        bar: String\n      }\n      directive @onQuery on QUERY\n      directive @onMutation on MUTATION\n      directive @onSubscription on SUBSCRIPTION\n      directive @onField on FIELD\n      directive @onFragmentDefinition on FRAGMENT_DEFINITION\n      directive @onFragmentSpread on FRAGMENT_SPREAD\n      directive @onInlineFragment on INLINE_FRAGMENT\n      directive @onVariableDefinition on VARIABLE_DEFINITION\n\n      directive @withArg(i: Int) on FIELD\n      directive @withRequiredArg(i: Int!) on FIELD\n    \"\"\"\n\n  val QueryType = schema.queryType\n  val MutationType = schema.mutationType.get\n  val SubscriptionType = schema.subscriptionType.get\n\n  val typeMappings: List[TypeMapping] = Nil\n\n  override val selectElaborator = PreserveArgsElaborator\n\n  def compileAllOperations(text: String): Result[List[Operation]] =\n    QueryParser.parseText(text).flatMap {\n      case (ops, frags) => ops.parTraverse(compiler.compileOperation(_, None, frags))\n    }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage minimizer\n\nimport munit.CatsEffectSuite\n\nimport grackle.{ GraphQLParser, QueryMinimizer }\n\nfinal class MinimizerSuite extends CatsEffectSuite {\n  def run(query: String, expected: String, echo: Boolean = false): Unit = {\n    val Right(minimized) = QueryMinimizer.minimizeText(query) : @unchecked\n    if (echo)\n      println(minimized)\n\n    assert(minimized == expected)\n\n    val Some(parsed0) = GraphQLParser.Document.parseAll(query).toOption : @unchecked\n    val Some(parsed1) = GraphQLParser.Document.parseAll(minimized).toOption : @unchecked\n\n    assertEquals(parsed0, parsed1)\n  }\n\n  test(\"minimize simple query\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{character(id:1000){name}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple parameters (commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\", bar: \"b\", baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{wibble(foo:\"a\",bar:\"b\",baz:3){quux}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple parameters (no commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\" bar: \"b\" baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{wibble(foo:\"a\",bar:\"b\",baz:3){quux}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{hero(episode:NEWHOPE){name,friends{name,friends{name}}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{user(id:4){id,name,smallPic:profilePic(size:64),bigPic:profilePic(size:1024)}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple root fields\") {\n    val query = \"\"\"\n      {\n        luke: character(id: \"1000\") {\n          name\n        }\n        darth: character(id: \"1001\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{luke:character(id:\"1000\"){name},darth:character(id:\"1001\"){name}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize variables\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query getZuckProfile($devicePicSize:Int){user(id:4){id,name,profilePic(size:$devicePicSize)}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize comments\") {\n    val query = \"\"\"\n      #comment at start of document\n      query IntrospectionQuery { #comment at end of line\n        __schema {\n          queryType {\n            name#comment eol no space\n          }\n          mutationType {\n            name\n            #several comments\n            #one after another\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n      #comment at end of document\n    \"\"\"\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name}}}\"\"\"\n\n    run(query, expected)\n  }\n\n\n  test(\"minimize simple fragment query\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected = \"\"\"query withFragments{user(id:1){friends{...friendFields},mutualFriends{...friendFields}}},fragment friendFields on User{id,name,profilePic}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize nested fragment query\") {\n    val query = \"\"\"\n      query withNestedFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        ...standardProfilePic\n      }\n\n      fragment standardProfilePic on User {\n        profilePic\n      }\n    \"\"\"\n\n    val expected = \"\"\"query withNestedFragments{user(id:1){friends{...friendFields},mutualFriends{...friendFields}}},fragment friendFields on User{id,name,...standardProfilePic},fragment standardProfilePic on User{profilePic}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize typed fragment query\") {\n    val query = \"\"\"\n      query FragmentTyping {\n        profiles {\n          id\n          __typename\n          ...userFragment\n          ...pageFragment\n        }\n      }\n\n      fragment userFragment on User {\n        name\n      }\n\n      fragment pageFragment on Page {\n        title\n      }\n    \"\"\"\n\n    val expected = \"\"\"query FragmentTyping{profiles{id,__typename,...userFragment,...pageFragment}},fragment userFragment on User{name},fragment pageFragment on Page{title}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize inline fragment query\") {\n    val query = \"\"\"\n      query inlineFragmentTyping {\n        profiles {\n          id\n          ... on User {\n            name\n          }\n          ... on Page {\n            title\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query inlineFragmentTyping{profiles{id,...on User{name},...on Page{title}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize typed union fragment query\") {\n    val query = \"\"\"\n      query FragmentUnionTyping {\n        user: user(id: \"1\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n        page: user(id: \"2\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n      }\n\n      fragment userFragment on User {\n        id\n        name\n      }\n\n      fragment pageFragment on Page {\n        id\n        title\n      }\n    \"\"\"\n\n    val expected = \"\"\"query FragmentUnionTyping{user:user(id:\"1\"){favourite{__typename,...userFragment,...pageFragment}},page:user(id:\"2\"){favourite{__typename,...userFragment,...pageFragment}}},fragment userFragment on User{id,name},fragment pageFragment on Page{id,title}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include field\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field @skip(if: $yup) {\n          subfieldA\n        }\n        b: field @skip(if: $nope) {\n          subfieldB\n        }\n        c: field @include(if: $yup) {\n          subfieldA\n        }\n        d: field @include(if: $nope) {\n          subfieldB\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field@skip(if:$yup){subfieldA},b:field@skip(if:$nope){subfieldB},c:field@include(if:$yup){subfieldA},d:field@include(if:$nope){subfieldB}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include fragment spread\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field {\n          ...frag @skip(if: $yup)\n        }\n        b: field {\n          ...frag @skip(if: $nope)\n        }\n        c: field {\n          ...frag @include(if: $yup)\n        }\n        d: field {\n          ...frag @include(if: $nope)\n        }\n      }\n\n      fragment frag on Value {\n        subfieldA\n        subfieldB\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field{...frag@skip(if:$yup)},b:field{...frag@skip(if:$nope)},c:field{...frag@include(if:$yup)},d:field{...frag@include(if:$nope)}},fragment frag on Value{subfieldA,subfieldB}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize fragment spread with nested skip/include\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        field {\n          ...frag\n        }\n      }\n\n      fragment frag on Value {\n        a: subfieldA @skip(if: $yup)\n        b: subfieldB @skip(if: $nope)\n        c: subfieldA @include(if: $yup)\n        d: subfieldB @include(if: $nope)\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){field{...frag}},fragment frag on Value{a:subfieldA@skip(if:$yup),b:subfieldB@skip(if:$nope),c:subfieldA@include(if:$yup),d:subfieldB@include(if:$nope)}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include inline fragment\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field {\n          ... on Value @skip(if: $yup) {\n            subfieldA\n            subfieldB\n          }\n        }\n        b: field {\n          ... on Value @skip(if: $nope) {\n            subfieldA\n            subfieldB\n          }\n        }\n        c: field {\n          ... on Value @include(if: $yup) {\n            subfieldA\n            subfieldB\n          }\n        }\n        d: field {\n          ... on Value @include(if: $nope) {\n            subfieldA\n            subfieldB\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field{...on Value@skip(if:$yup){subfieldA,subfieldB}},b:field{...on Value@skip(if:$nope){subfieldA,subfieldB}},c:field{...on Value@include(if:$yup){subfieldA,subfieldB}},d:field{...on Value@include(if:$nope){subfieldA,subfieldB}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize inline fragment with nested skip/include\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        field {\n          ... on Value {\n            a: subfieldA @skip(if: $yup)\n            b: subfieldB @skip(if: $nope)\n            c: subfieldA @include(if: $yup)\n            d: subfieldB @include(if: $nope)\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){field{...on Value{a:subfieldA@skip(if:$yup),b:subfieldB@skip(if:$nope),c:subfieldA@include(if:$yup),d:subfieldB@include(if:$nope)}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize null value\") {\n    val query = \"\"\"\n      query {\n        field {\n          subfield\n        }\n        field(arg: null) {\n          subfield\n        }\n        field(arg: 23) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{field{subfield},field(arg:null){subfield},field(arg:23){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize list value\") {\n    val query = \"\"\"\n      query {\n        listField(arg: []) {\n          subfield\n        }\n        listField(arg: [\"foo\", \"bar\"]) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{listField(arg:[]){subfield},listField(arg:[\"foo\",\"bar\"]){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize input object value\") {\n    val query = \"\"\"\n      query {\n        objectField(arg: { foo: 23, bar: true, baz: \"quux\" }) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{objectField(arg:{foo:23,bar:true,baz:\"quux\"}){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize query with UUID argument and custom scalar results\") {\n    val query = \"\"\"\n      query {\n        movieById(id: \"6a7837fc-b463-4d32-b628-0f4b3065cb21\") {\n          id\n          title\n          genre\n          releaseDate\n          showTime\n          nextShowing\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{movieById(id:\"6a7837fc-b463-4d32-b628-0f4b3065cb21\"){id,title,genre,releaseDate,showTime,nextShowing,duration}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize query with mapped enum argument\") {\n    val query = \"\"\"\n      query {\n        moviesByGenre(genre: COMEDY) {\n          title\n          genre\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{moviesByGenre(genre:COMEDY){title,genre}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"standard introspection query\") {\n    val query = \"\"\"\n      |query IntrospectionQuery {\n      |  __schema {\n      |    queryType { name }\n      |    mutationType { name }\n      |    subscriptionType { name }\n      |    types {\n      |      ...FullType\n      |    }\n      |    directives {\n      |      name\n      |      description\n      |      locations\n      |      args {\n      |        ...InputValue\n      |      }\n      |    }\n      |  }\n      |}\n      |\n      |fragment FullType on __Type {\n      |  kind\n      |  name\n      |  description\n      |  fields(includeDeprecated: true) {\n      |    name\n      |    description\n      |    args {\n      |      ...InputValue\n      |    }\n      |    type {\n      |      ...TypeRef\n      |    }\n      |    isDeprecated\n      |    deprecationReason\n      |  }\n      |  inputFields {\n      |    ...InputValue\n      |  }\n      |  interfaces {\n      |    ...TypeRef\n      |  }\n      |  enumValues(includeDeprecated: true) {\n      |    name\n      |    description\n      |    isDeprecated\n      |    deprecationReason\n      |  }\n      |  possibleTypes {\n      |    ...TypeRef\n      |  }\n      |}\n      |\n      |fragment InputValue on __InputValue {\n      |  name\n      |  description\n      |  type { ...TypeRef }\n      |  defaultValue\n      |}\n      |\n      |fragment TypeRef on __Type {\n      |  kind\n      |  name\n      |  ofType {\n      |    kind\n      |    name\n      |    ofType {\n      |      kind\n      |      name\n      |      ofType {\n      |        kind\n      |        name\n      |        ofType {\n      |          kind\n      |          name\n      |          ofType {\n      |            kind\n      |            name\n      |            ofType {\n      |              kind\n      |              name\n      |              ofType {\n      |                kind\n      |                name\n      |              }\n      |            }\n      |          }\n      |        }\n      |      }\n      |    }\n      |  }\n      |}\n    \"\"\".stripMargin.trim\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name},types{...FullType},directives{name,description,locations,args{...InputValue}}}},fragment FullType on __Type{kind,name,description,fields(includeDeprecated:true){name,description,args{...InputValue},type{...TypeRef},isDeprecated,deprecationReason},inputFields{...InputValue},interfaces{...TypeRef},enumValues(includeDeprecated:true){name,description,isDeprecated,deprecationReason},possibleTypes{...TypeRef}},fragment InputValue on __InputValue{name,description,type{...TypeRef},defaultValue},fragment TypeRef on __Type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}}\"\"\"\n\n    run(query, expected)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage parser\n\nimport cats.data.NonEmptyChain\nimport munit.CatsEffectSuite\n\nimport grackle.{Ast, GraphQLParser, Problem, Result}\nimport grackle.syntax._\nimport Ast._, OperationType._, OperationDefinition._, Selection._, Value._, Type.Named\n\nfinal class ParserSuite extends CatsEffectSuite {\n  test(\"simple query\") {\n    val query = doc\"\"\"\n      query {\n        character(id: 1000) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, None, Nil, Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil)\n            )\n          )\n        )\n      )\n\n    assertEquals(query, List(expected))\n  }\n\n  test(\"multiple parameters (commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\", bar: \"b\", baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,None,Nil,Nil,\n        List(\n          Field(None,Name(\"wibble\"),\n            List(\n              (Name(\"foo\"),StringValue(\"a\")),\n              (Name(\"bar\"),StringValue(\"b\")),\n              (Name(\"baz\"),IntValue(3))\n            ), Nil,\n            List(\n              Field(None,Name(\"quux\"),Nil,Nil,Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"multiple parameters (no commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\" bar: \"b\" baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,None,Nil,Nil,\n        List(\n          Field(None,Name(\"wibble\"),\n            List(\n              (Name(\"foo\"),StringValue(\"a\")),\n              (Name(\"bar\"),StringValue(\"b\")),\n              (Name(\"baz\"),IntValue(3))\n            ), Nil,\n            List(\n              Field(None,Name(\"quux\"),Nil,Nil,Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query,Some(Name(\"IntrospectionQuery\")),Nil,Nil,\n        List(\n          Field(None,Name(\"__schema\"),Nil,Nil,\n            List(\n              Field(None,Name(\"queryType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"mutationType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"subscriptionType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              )\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(None,Name(\"hero\"),List((Name(\"episode\"),EnumValue(Name(\"NEWHOPE\")))),Nil,\n            List(\n              Field(None,Name(\"name\"),Nil,Nil,Nil),\n              Field(None,Name(\"friends\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil),\n                  Field(None,Name(\"friends\"),Nil,Nil,\n                    List(\n                      Field(None,Name(\"name\"),Nil,Nil,Nil)\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(Some(Name(\"smallPic\")), Name(\"profilePic\"), List((Name(\"size\"), IntValue(64))), Nil, Nil),\n              Field(Some(Name(\"bigPic\")), Name(\"profilePic\"), List((Name(\"size\"), IntValue(1024))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"multiple root fields\") {\n    val query = \"\"\"\n      {\n        luke: character(id: \"1000\") {\n          name\n        }\n        darth: character(id: \"1001\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(Some(Name(\"luke\")), Name(\"character\"), List((Name(\"id\"), StringValue(\"1000\"))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil))),\n          Field(Some(Name(\"darth\")), Name(\"character\"), List((Name(\"id\"), StringValue(\"1001\"))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), None, Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables with default value\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int = 10) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), Some(IntValue(10)), Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables with directive\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int @dir) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), None, List(Directive(Name(\"dir\"), Nil)))),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"comments\") {\n    val query = \"\"\"\n      #comment at start of document\n      query IntrospectionQuery { #comment at end of line\n        __schema {\n          queryType {\n            name#comment eol no space\n          }\n          mutationType {\n            name\n            #several comments\n            #one after another\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n      #comment at end of document\n    \"\"\"\n\n    val expected =\n      Operation(Query,Some(Name(\"IntrospectionQuery\")),Nil,Nil,\n        List(\n          Field(None,Name(\"__schema\"),Nil,Nil,\n            List(\n              Field(None,Name(\"queryType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"mutationType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"subscriptionType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              )\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"invalid document\") {\n    GraphQLParser.Document.parseAll(\"scalar Foo woozle\").toOption match {\n      case Some(_) => fail(\"should have failed\")\n      case None    => ()\n    }\n  }\n\n  test(\"fragment\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          ...frag\n          ... on Character {\n            age\n          }\n        }\n      }\n\n      fragment frag on Character {\n        name\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        Operation(Query, None, Nil, Nil,\n          List(\n            Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n              List(\n                FragmentSpread(Name(\"frag\"),Nil),\n                InlineFragment(\n                  Some(Named(Name(\"Character\"))),\n                  Nil,\n                  List(\n                    Field(None,Name(\"age\"),Nil ,Nil ,Nil)\n                  )\n                )\n              )\n            )\n          )\n        ),\n        FragmentDefinition(\n          Name(\"frag\"),\n          Named(Name(\"Character\")),\n          Nil,\n          List(\n            Field(None,Name(\"name\"),Nil ,Nil ,Nil)\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(xs) => assertEquals(xs, expected)\n      case _ => assert(false)\n    }\n\n  }\n\n  test(\"fragment with standard directive\") {\n    val query = \"\"\"\n      query frag($expanded: Boolean){\n        character(id: 1000) {\n          name\n          ... @include(if: $expanded) {\n            age\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,\n        Some(Name(\"frag\")),\n        List(VariableDefinition(Name(\"expanded\"),Named(Name(\"Boolean\")),None, Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              InlineFragment(\n                None,\n                List(Directive(Name(\"include\"),List((Name(\"if\"),Variable(Name(\"expanded\")))))),\n                List(Field(None,Name(\"age\"),List(),List(),List()))\n              )\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"fragment with custorm directive\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          name\n          ... @dir {\n            age\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,\n        None,\n        Nil,\n        Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              InlineFragment(\n                None,\n                List(Directive(Name(\"dir\"), Nil)),\n                List(Field(None,Name(\"age\"),List(),List(),List()))\n              )\n            )\n          )\n        )\n      )\n\n    GraphQLParser.Document.parseAll(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"value literals\") {\n\n    def assertParse(input: String, expected: Value) =\n      GraphQLParser.Value.parseAll(input).toOption match {\n        case Some(v) => assertEquals(v, expected)\n        case _ => assert(false)\n      }\n\n    assertParse(\"\\\"foo\u03bb\\\"\", StringValue(\"foo\u03bb\"))\n    assertParse(\"\\\"\\\\u03BB\\\"\", StringValue(\"\u03bb\"))\n    assertParse(\"\\\"\\\\\\\" \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t\\\"\", StringValue(\"\\\" \\\\ / \\b \\f \\n \\r \\t\"))\n\n    assertParse(\"123.2\", FloatValue(123.2d))\n    assertParse(\"123E2\", FloatValue(123E2d))\n    assertParse(\"123.2E2\", FloatValue(123.2E2d))\n\n    assertParse(\"123\", IntValue(123))\n    assertParse(\"-123\", IntValue(-123))\n\n    assertParse(\"true\", BooleanValue(true))\n    assertParse(\"false\", BooleanValue(false))\n\n    assertParse(\"null\", NullValue)\n\n    assertParse(\"Foo\", EnumValue(Name(\"Foo\")))\n\n    assertParse(\"[1, \\\"foo\\\"]\", ListValue(List(IntValue(1), StringValue(\"foo\"))))\n\n    assertParse(\"{foo: 1, bar: \\\"baz\\\"}\", ObjectValue(List(Name(\"foo\") -> IntValue(1), Name(\"bar\") -> StringValue(\"baz\"))))\n\n    assertParse(\"\\\"\\\"\\\"one\\\"\\\"\\\"\", StringValue(\"one\"))\n    assertParse(\"\\\"\\\"\\\"    \\n\\n   first\\n   \\t\u03bb\\n  123\\n\\n\\n   \\t\\n\\n\\\"\\\"\\\"\", StringValue(\" first\\n \\t\u03bb\\n123\"))\n  }\n\n  test(\"parse object type extension\") {\n    val schema = \"\"\"\n      extend type Foo {\n        bar: Int\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        ObjectTypeExtension(Named(Name(\"Foo\")), List(FieldDefinition(Name(\"bar\"),None,Nil,Named(Name(\"Int\")),Nil)), Nil, Nil)\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema).toOption\n    assert(res == Some(expected))\n  }\n\n  test(\"parse schema extension\") {\n    val schema = \"\"\"\n      extend schema {\n        query: Query\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        SchemaExtension(List(RootOperationTypeDefinition(OperationType.Query, Named(Name(\"Query\")), Nil)), Nil)\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema).toOption\n    assert(res == Some(expected))\n  }\n\n  test(\"keywords parsed non-greedily (1)\") {\n    val schema =\n      \"\"\"|extend type Name {\n         |  value:String\n         |}\"\"\".stripMargin\n\n    val expected =\n      List(\n        ObjectTypeExtension(\n          Named(Name(\"Name\")),\n          List(\n            FieldDefinition(Name(\"value\"), None, Nil, Named(Name(\"String\")), Nil)\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema).toOption\n    assertEquals(res, Some(expected))\n  }\n\n  test(\"keywords parsed non-greedily (2)\") {\n    val schema =\n      \"\"\"|extendtypeName {\n         |  value:String\n         |}\"\"\".stripMargin\n\n    val expected =\n      NonEmptyChain(\n        Problem(\n          \"\"\"|Parse error at line 0 column 6\n            |extendtypeName {\n            |      ^\"\"\".stripMargin\n        )\n      )\n\n    val res = GraphQLParser.toResult(schema, GraphQLParser.Document.parseAll(schema))\n    assertEquals(res, Result.Failure(expected))\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage sdl\n\nimport munit.CatsEffectSuite\n\nimport grackle.{ Ast, GraphQLParser, SchemaParser }\nimport grackle.syntax._\nimport Ast._, OperationType._, Type.{ List => _, _ }\n\nfinal class SDLSuite extends CatsEffectSuite {\n  test(\"parse schema definition\") {\n    val schema = \"\"\"\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        SchemaDefinition(\n          List(\n            RootOperationTypeDefinition(Query, Named(Name(\"MyQuery\")), Nil),\n            RootOperationTypeDefinition(Mutation, Named(Name(\"MyMutation\")), Nil),\n            RootOperationTypeDefinition(Subscription, Named(Name(\"MySubscription\")), Nil)\n          ),\n          Nil\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse scalar type definition\") {\n    val schema = \"\"\"\n      \"A scalar type\"\n      scalar Url\n\n      \"A scalar type\"\n      scalar Time @deprecated\n    \"\"\"\n\n    val expected =\n      List(\n        ScalarTypeDefinition(Name(\"Url\"), Some(\"A scalar type\"), Nil),\n        ScalarTypeDefinition(Name(\"Time\"), Some(\"A scalar type\"), List(Directive(Name(\"deprecated\"), Nil)))\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse object type definition\") {\n    val schema = \"\"\"\n      \"An object type\"\n      type Query {\n        posts: [Post]\n        author(id: Int!): Author\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        ObjectTypeDefinition(Name(\"Query\"), Some(\"An object type\"),\n          List(\n            FieldDefinition(Name(\"posts\"), None, Nil, Type.List(Named(Name(\"Post\"))), Nil),\n            FieldDefinition(\n              Name(\"author\"),\n              None,\n              List(InputValueDefinition(Name(\"id\"), None, NonNull(Left(Named(Name(\"Int\")))), None, Nil)),\n              Named(Name(\"Author\")),\n              Nil\n            )\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse interface type definition\") {\n    val schema = \"\"\"\n      \"An interface type\"\n      interface Post {\n        \"A field\"\n        id: Int!\n        title: String\n        \"A deprecated field\"\n        author: Author @deprecated\n        votes: Int\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        InterfaceTypeDefinition(Name(\"Post\"), Some(\"An interface type\"),\n          List(\n            FieldDefinition(Name(\"id\"), Some(\"A field\"), Nil, NonNull(Left(Named(Name(\"Int\")))), Nil),\n            FieldDefinition(Name(\"title\"), None, Nil, Named(Name(\"String\")), Nil),\n            FieldDefinition(Name(\"author\"), Some(\"A deprecated field\"), Nil, Named(Name(\"Author\")), List(Directive(Name(\"deprecated\"), Nil))),\n            FieldDefinition(Name(\"votes\"), None, Nil, Named(Name(\"Int\")), Nil)\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse union type definition\") {\n    val schema = \"\"\"\n      \"A union type\"\n      union ThisOrThat = This | That\n    \"\"\"\n\n    val expected =\n      List(\n        UnionTypeDefinition(Name(\"ThisOrThat\"), Some(\"A union type\"), Nil,\n          List(\n            Named(Name(\"This\")),\n            Named(Name(\"That\"))\n          )\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse enum type definition\") {\n    val schema = \"\"\"\n      \"An enum type\"\n      enum Direction {\n        NORTH\n        EAST\n        SOUTH\n        WEST\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        EnumTypeDefinition(Name(\"Direction\"), Some(\"An enum type\"), Nil,\n          List(\n            EnumValueDefinition(Name(\"NORTH\"), None, Nil),\n            EnumValueDefinition(Name(\"EAST\"), None, Nil),\n            EnumValueDefinition(Name(\"SOUTH\"), None, Nil),\n            EnumValueDefinition(Name(\"WEST\"), None, Nil)\n          )\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse input object type definition\") {\n    val schema = \"\"\"\n      \"An input object type\"\n      input Point2D {\n        x: Float\n        y: Float\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        InputObjectTypeDefinition(Name(\"Point2D\"), Some(\"An input object type\"),\n          List(\n            InputValueDefinition(Name(\"x\"), None, Named(Name(\"Float\")), None, Nil),\n            InputValueDefinition(Name(\"y\"), None, Named(Name(\"Float\")), None, Nil)\n          ),\n          Nil\n        )\n      )\n\n    val res = GraphQLParser.Document.parseAll(schema)\n\n    assertEquals(res, Right(expected))\n  }\n\n  test(\"parse directive definition\") {\n    val schema =\n      \"\"\"|type Query {\n         |  foo: Int\n         |}\n         |\"A directive\"\n         |directive @delegateField(name: String!) repeatable on OBJECT|INTERFACE|FIELD|FIELD_DEFINITION|ENUM|ENUM_VALUE\n         |\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (1)\") {\n    val schema =\n    \"\"\"|type Author {\n       |  id: Int!\n       |  firstName: String\n       |  lastName: String\n       |  posts: [Post]\n       |}\n       |type Post {\n       |  id: Int!\n       |  title: String\n       |  author: Author\n       |  votes: Int\n       |}\n       |type Query {\n       |  posts: [Post]\n       |  author(id: Int! = 23): Author\n       |}\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (2)\") {\n    val schema =\n    \"\"\"|type Query {\n       |  hero(episode: Episode!): Character!\n       |  character(id: ID!): Character\n       |  human(id: ID!): Human\n       |  droid(id: ID!): Droid\n       |}\n       |enum Episode {\n       |  ROGUEONE @deprecated(reason: \"use NEWHOPE instead\")\n       |  NEWHOPE\n       |  EMPIRE\n       |  JEDI\n       |}\n       |interface Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |}\n       |type Human implements Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |  homePlanet: String\n       |}\n       |type Droid implements Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |  primaryFunction: String\n       |}\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (3)\") {\n    val schema =\n    \"\"\"|type Query {\n       |  whatsat(p: Point!): ThisOrThat!\n       |}\n       |union ThisOrThat = This | That\n       |type This {\n       |  id: ID!\n       |}\n       |type That {\n       |  id: ID!\n       |}\n       |input Point {\n       |  x: Int\n       |  y: Int\n       |}\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"round-trip extensions\") {\n    val schema =\n      \"\"\"|schema {\n         |  query: MyQuery\n         |}\n         |type MyQuery {\n         |  foo(s: Scalar, i: Input, e: Enum): Union\n         |}\n         |type Mutation {\n         |  bar: Int\n         |}\n         |scalar Scalar\n         |interface Intrf {\n         |  bar: String\n         |}\n         |type Obj implements Intrf {\n         |  bar: String\n         |}\n         |union Union = Intrf | Obj\n         |enum Enum {\n         |  A\n         |  B\n         |}\n         |input Input {\n         |  baz: Float\n         |}\n         |type Quux {\n         |  quux: String\n         |}\n         |extend schema @Sch {\n         |  mutation: Mutation\n         |}\n         |extend scalar Scalar @Sca\n         |extend interface Intrf @Intrf {\n         |  baz: Boolean\n         |}\n         |extend type Obj @Obj {\n         |  baz: Boolean\n         |  quux: String\n         |}\n         |extend union Union @Uni = Quux\n         |extend enum Enum @Enu {\n         |  C\n         |}\n         |extend input Input @Inp {\n         |  foo: Int\n         |}\n         |directive @Sch on SCHEMA\n         |directive @Sca on SCALAR\n         |directive @Obj on OBJECT\n         |directive @Intrf on INTERFACE\n         |directive @Uni on UNION\n         |directive @Enu on ENUM\n         |directive @Inp on INPUT_OBJECT\n         |\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"round-trip extensions (no fields or members\") {\n    val schema =\n      \"\"\"|schema {\n         |  query: MyQuery\n         |}\n         |type MyQuery {\n         |  foo(s: Scalar, i: Input, e: Enum): Union\n         |}\n         |scalar Scalar\n         |interface Intrf {\n         |  bar: String\n         |}\n         |type Obj implements Intrf {\n         |  bar: String\n         |}\n         |union Union = Intrf | Obj\n         |enum Enum {\n         |  A\n         |  B\n         |}\n         |input Input {\n         |  baz: Float\n         |}\n         |extend schema @Sch\n         |extend scalar Scalar @Sca\n         |extend interface Intrf @Intrf\n         |extend type Obj @Obj\n         |extend union Union @Uni\n         |extend enum Enum @Enu\n         |extend input Input @Inp\n         |directive @Sch on SCHEMA\n         |directive @Sca on SCALAR\n         |directive @Obj on OBJECT\n         |directive @Intrf on INTERFACE\n         |directive @Uni on UNION\n         |directive @Enu on ENUM\n         |directive @Inp on INPUT_OBJECT\n         |\"\"\".stripMargin\n\n    val res = SchemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\npackage generic\n\nimport java.time.{Duration, LocalDate, LocalTime, OffsetDateTime}\nimport java.util.UUID\nimport scala.util.Try\n\nimport cats.{Eq, Order}\nimport cats.effect.IO\nimport cats.implicits._\nimport io.circe.Encoder\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle.syntax._\nimport Query._, Predicate._, Value._\nimport QueryCompiler._\n\nobject MovieData {\n  import MovieMapping._\n  import semiauto._\n\n  sealed trait Genre extends Product with Serializable\n  object Genre {\n    case object Drama extends Genre\n    case object Action extends Genre\n    case object Comedy extends Genre\n\n    implicit val genreEq: Eq[Genre] = Eq.fromUniversalEquals[Genre]\n\n    def fromString(s: String): Option[Genre] =\n      s.trim.toUpperCase match {\n        case \"DRAMA\"  => Some(Drama)\n        case \"ACTION\" => Some(Action)\n        case \"COMEDY\" => Some(Comedy)\n        case _ => None\n      }\n\n    implicit val genreEncoder: Encoder[Genre] =\n      Encoder[String].contramap(_ match {\n        case Drama => \"DRAMA\"\n        case Action => \"ACTION\"\n        case Comedy => \"COMEDY\"\n      })\n\n    implicit val cursorBuilder: CursorBuilder[Genre] =\n      CursorBuilder.deriveLeafCursorBuilder[Genre](GenreType)\n  }\n\n  implicit val localDateOrder: Order[LocalDate] =\n    Order.from(_.compareTo(_))\n\n  implicit val localTimeOrder: Order[LocalTime] =\n    Order.fromComparable[LocalTime]\n\n  implicit val offsetDateTimeOrder: Order[OffsetDateTime] =\n    Order.from(_.compareTo(_))\n\n  implicit val durationOrder: Order[Duration] =\n    Order.fromComparable[Duration]\n\n  import Genre.{Action, Comedy, Drama}\n\n  case class Movie(\n    id: UUID,\n    title: String,\n    genre: Genre,\n    releaseDate: LocalDate,\n    showTime: LocalTime,\n    nextShowing: OffsetDateTime,\n    duration: Duration\n  )\n\n  object Movie {\n    implicit val cursorBuilder: CursorBuilder[Movie] =\n      deriveObjectCursorBuilder[Movie](MovieType)\n  }\n\n  val movies =\n    List(\n      Movie(UUID.fromString(\"6a7837fc-b463-4d32-b628-0f4b3065cb21\"), \"Celine et Julie Vont en Bateau\", Drama, LocalDate.parse(\"1974-10-07\"), LocalTime.parse(\"19:35:00\"), OffsetDateTime.parse(\"2020-05-22T19:35:00Z\"), Duration.ofMillis(12300000)),\n      Movie(UUID.fromString(\"11daf8c0-11c3-4453-bfe1-cb6e6e2f9115\"), \"Duelle\", Drama, LocalDate.parse(\"1975-09-15\"), LocalTime.parse(\"19:20:00\"), OffsetDateTime.parse(\"2020-05-27T19:20:00Z\"), Duration.ofMillis(7260000)),\n      Movie(UUID.fromString(\"aea9756f-621b-42d5-b130-71f3916c4ba3\"), \"L'Amour fou\", Drama, LocalDate.parse(\"1969-01-15\"), LocalTime.parse(\"21:00:00\"), OffsetDateTime.parse(\"2020-05-27T21:00:00Z\"), Duration.ofMillis(15120000)),\n      Movie(UUID.fromString(\"2ddb041f-86c2-4bd3-848c-990a3862634e\"), \"Last Year at Marienbad\", Drama, LocalDate.parse(\"1961-06-25\"), LocalTime.parse(\"20:30:00\"), OffsetDateTime.parse(\"2020-05-26T20:30:00Z\"), Duration.ofMillis(5640000)),\n      Movie(UUID.fromString(\"8ae5b13b-044c-4ff0-8b71-ccdb7d77cd88\"), \"Zazie dans le M\u00e9tro\", Comedy, LocalDate.parse(\"1960-10-28\"), LocalTime.parse(\"20:15:00\"), OffsetDateTime.parse(\"2020-05-25T20:15:00Z\"), Duration.ofMillis(5340000)),\n      Movie(UUID.fromString(\"9dce9deb-9188-4cc2-9685-9842b8abdd34\"), \"Alphaville\", Action, LocalDate.parse(\"1965-05-05\"), LocalTime.parse(\"19:45:00\"), OffsetDateTime.parse(\"2020-05-19T19:45:00Z\"), Duration.ofMillis(5940000)),\n      Movie(UUID.fromString(\"1bf00ac6-91ab-4e51-b686-3fd5e2324077\"), \"Stalker\", Drama, LocalDate.parse(\"1979-05-13\"), LocalTime.parse(\"15:30:00\"), OffsetDateTime.parse(\"2020-05-19T15:30:00Z\"), Duration.ofMillis(9660000)),\n      Movie(UUID.fromString(\"6a878e06-6563-4a0c-acd9-d28dcfb2e91a\"), \"Weekend\", Comedy, LocalDate.parse(\"1967-12-29\"), LocalTime.parse(\"22:30:00\"), OffsetDateTime.parse(\"2020-05-19T22:30:00Z\"), Duration.ofMillis(6300000)),\n      Movie(UUID.fromString(\"2a40415c-ea6a-413f-bbef-a80ae280c4ff\"), \"Daisies\", Comedy, LocalDate.parse(\"1966-12-30\"), LocalTime.parse(\"21:30:00\"), OffsetDateTime.parse(\"2020-05-15T21:30:00Z\"), Duration.ofMillis(4560000)),\n      Movie(UUID.fromString(\"2f6dcb0a-4122-4a21-a1c6-534744dd6b85\"), \"Le Pont du Nord\", Drama, LocalDate.parse(\"1982-01-13\"), LocalTime.parse(\"20:45:00\"), OffsetDateTime.parse(\"2020-05-11T20:45:00Z\"), Duration.ofMillis(7620000))\n    ).sortBy(_.id.toString)\n}\n\nobject MovieMapping extends GenericMapping[IO] {\n  import MovieData._\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        movieById(id: UUID!): Movie\n        moviesByGenre(genre: Genre!): [Movie!]!\n        moviesReleasedBetween(from: Date!, to: Date!): [Movie!]!\n        moviesLongerThan(duration: Interval!): [Movie!]!\n        moviesShownLaterThan(time: Time!): [Movie!]!\n        moviesShownBetween(from: DateTime!, to: DateTime!): [Movie!]!\n      }\n      scalar UUID\n      scalar Time\n      scalar Date\n      scalar DateTime\n      scalar Interval\n      enum Genre {\n        DRAMA\n        ACTION\n        COMEDY\n      }\n      type Movie {\n        id: UUID!\n        title: String!\n        genre: Genre!\n        releaseDate: Date!\n        showTime: Time!\n        nextShowing: DateTime!\n        duration: Interval!\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val MovieType = schema.ref(\"Movie\")\n  val GenreType = schema.ref(\"Genre\")\n\n  val typeMappings =\n    List(\n      ObjectMapping(\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            GenericField(\"movieById\", movies),\n            GenericField(\"moviesByGenre\", movies),\n            GenericField(\"moviesReleasedBetween\", movies),\n            GenericField(\"moviesLongerThan\", movies),\n            GenericField(\"moviesShownLaterThan\", movies),\n            GenericField(\"moviesShownBetween\", movies)\n          )\n      )\n    )\n\n  object UUIDValue {\n    def unapply(s: StringValue): Option[UUID] =\n      Try(UUID.fromString(s.value)).toOption\n  }\n\n  object GenreValue {\n    def unapply(e: EnumValue): Option[Genre] =\n      Genre.fromString(e.name)\n  }\n\n  object DateValue {\n    def unapply(s: StringValue): Option[LocalDate] =\n      Try(LocalDate.parse(s.value)).toOption\n  }\n\n  object TimeValue {\n    def unapply(s: StringValue): Option[LocalTime] =\n      Try(LocalTime.parse(s.value)).toOption\n  }\n\n  object DateTimeValue {\n    def unapply(s: StringValue): Option[OffsetDateTime] =\n      Try(OffsetDateTime.parse(s.value)).toOption\n  }\n\n  object IntervalValue {\n    def unapply(s: StringValue): Option[Duration] =\n      Try(Duration.parse(s.value)).toOption\n  }\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"movieById\", List(Binding(\"id\", UUIDValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(MovieType / \"id\", Const(id)), child)))\n    case (QueryType, \"moviesByGenre\", List(Binding(\"genre\", GenreValue(genre)))) =>\n      Elab.transformChild(child => Filter(Eql(MovieType / \"genre\", Const(genre)), child))\n    case (QueryType, \"moviesReleasedBetween\", List(Binding(\"from\", DateValue(from)), Binding(\"to\", DateValue(to)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          And(\n            Not(Lt(MovieType / \"releaseDate\", Const(from))),\n            Lt(MovieType / \"releaseDate\", Const(to))\n          ),\n          child\n        )\n      )\n    case (QueryType, \"moviesLongerThan\", List(Binding(\"duration\", IntervalValue(duration)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          Not(Lt(MovieType / \"duration\", Const(duration))),\n          child\n        )\n      )\n    case (QueryType, \"moviesShownLaterThan\", List(Binding(\"time\", TimeValue(time)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          Not(Lt(MovieType / \"showTime\", Const(time))),\n          child\n        )\n      )\n    case (QueryType, \"moviesShownBetween\", List(Binding(\"from\", DateTimeValue(from)), Binding(\"to\", DateTimeValue(to)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          And(\n            Not(Lt(MovieType / \"nextShowing\", Const(from))),\n            Lt(MovieType / \"nextShowing\", Const(to))\n          ),\n          child\n        )\n      )\n  }\n}\n\nfinal class ScalarsSuite extends CatsEffectSuite {\n  test(\"query with UUID argument and custom scalar results\") {\n    val query = \"\"\"\n      query {\n        movieById(id: \"6a7837fc-b463-4d32-b628-0f4b3065cb21\") {\n          id\n          title\n          genre\n          releaseDate\n          showTime\n          nextShowing\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"movieById\" : {\n            \"id\" : \"6a7837fc-b463-4d32-b628-0f4b3065cb21\",\n            \"title\" : \"Celine et Julie Vont en Bateau\",\n            \"genre\" : \"DRAMA\",\n            \"releaseDate\" : \"1974-10-07\",\n            \"showTime\" : \"19:35:00\",\n            \"nextShowing\" : \"2020-05-22T19:35:00Z\",\n            \"duration\" : \"PT3H25M\"\n          }\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with mapped enum argument\") {\n    val query = \"\"\"\n      query {\n        moviesByGenre(genre: COMEDY) {\n          title\n          genre\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesByGenre\" : [\n            {\n              \"title\" : \"Daisies\",\n              \"genre\" : \"COMEDY\"\n            },\n            {\n              \"title\" : \"Weekend\",\n              \"genre\" : \"COMEDY\"\n            },\n            {\n              \"title\" : \"Zazie dans le M\u00e9tro\",\n              \"genre\" : \"COMEDY\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with LocalDate argument\") {\n    val query = \"\"\"\n      query {\n        moviesReleasedBetween(from: \"1970-01-01\", to: \"1980-01-01\") {\n          title\n          releaseDate\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesReleasedBetween\" : [\n            {\n              \"title\" : \"Duelle\",\n              \"releaseDate\" : \"1975-09-15\"\n            },\n            {\n              \"title\" : \"Stalker\",\n              \"releaseDate\" : \"1979-05-13\"\n            },\n            {\n              \"title\" : \"Celine et Julie Vont en Bateau\",\n              \"releaseDate\" : \"1974-10-07\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with Duration argument\") {\n    val query = \"\"\"\n      query {\n        moviesLongerThan(duration: \"PT3H\") {\n          title\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesLongerThan\" : [\n            {\n              \"title\" : \"Celine et Julie Vont en Bateau\",\n              \"duration\" : \"PT3H25M\"\n            },\n            {\n              \"title\" : \"L'Amour fou\",\n              \"duration\" : \"PT4H12M\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with LocalTime argument\") {\n    val query = \"\"\"\n      query {\n        moviesShownLaterThan(time: \"21:00:00\") {\n          title\n          showTime\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesShownLaterThan\" : [\n            {\n              \"title\" : \"Daisies\",\n              \"showTime\" : \"21:30:00\"\n            },\n            {\n              \"title\" : \"Weekend\",\n              \"showTime\" : \"22:30:00\"\n            },\n            {\n              \"title\" : \"L'Amour fou\",\n              \"showTime\" : \"21:00:00\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with OffsetDateTime argument\") {\n    val query = \"\"\"\n      query {\n        moviesShownBetween(from: \"2020-05-01T10:30:00Z\", to: \"2020-05-19T18:00:00Z\") {\n          title\n          nextShowing\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesShownBetween\" : [\n            {\n              \"title\" : \"Stalker\",\n              \"nextShowing\" : \"2020-05-19T15:30:00Z\"\n            },\n            {\n              \"title\" : \"Daisies\",\n              \"nextShowing\" : \"2020-05-15T21:30:00Z\"\n            },\n            {\n              \"title\" : \"Le Pont du Nord\",\n              \"nextShowing\" : \"2020-05-11T20:45:00Z\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n}\n"], "fixing_code": ["import nl.zolotko.sbt.jfr.{JfrRecording, JfrRecorderOptions}\nimport scala.concurrent.duration.DurationInt\n\nval catsVersion            = \"2.10.0\"\nval catsParseVersion       = \"1.0.0\"\nval catsEffectVersion      = \"3.5.2\"\nval circeVersion           = \"0.14.6\"\nval disciplineMunitVersion = \"2.0.0-M3\"\nval doobieVersion          = \"1.0.0-RC5\"\nval flywayVersion          = \"10.3.0\"\nval fs2Version             = \"3.9.3\"\nval http4sVersion          = \"0.23.24\"\nval jnrUnixsocketVersion   = \"0.38.21\"\nval kindProjectorVersion   = \"0.13.2\"\nval literallyVersion       = \"1.1.0\"\nval logbackVersion         = \"1.4.14\"\nval log4catsVersion        = \"2.6.0\"\nval munitVersion           = \"1.0.0-M10\"\nval munitCatsEffectVersion = \"2.0.0-M4\"\nval skunkVersion           = \"0.6.2\"\nval shapeless2Version      = \"2.3.10\"\nval shapeless3Version      = \"3.1.0\"\nval sourcePosVersion       = \"1.1.0\"\nval typenameVersion        = \"1.1.0\"\nval whaleTailVersion       = \"0.0.10\"\n\nval Scala2 = \"2.13.12\"\nval Scala3 = \"3.3.1\"\nThisBuild / scalaVersion        := Scala2\nThisBuild / crossScalaVersions  := Seq(Scala2, Scala3)\nThisBuild / tlJdkRelease        := Some(11)\n\nThisBuild / tlBaseVersion    := \"0.18\"\nThisBuild / startYear        := Some(2019)\nThisBuild / licenses         := Seq(License.Apache2)\nThisBuild / developers       := List(\n  Developer(\"milessabin\", \"Miles Sabin\", \"miles@milessabin.com\", url(\"http://milessabin.com/blog\")),\n  Developer(\"tpolecat\",   \"Rob Norris\",  \"rnorris@gemini.edu\",   url(\"http://www.tpolecat.org\")),\n)\n\nThisBuild / tlCiScalafmtCheck       := false\nThisBuild / tlCiReleaseBranches     := Seq(\"main\")\nThisBuild / tlSonatypeUseLegacyHost := false\nThisBuild / githubWorkflowBuild     ~= { steps =>\n  WorkflowStep.Sbt(\n    commands = List(\"headerCheckAll\"),\n    name = Some(\"Check Headers\"),\n  ) +: steps\n}\nThisBuild / githubWorkflowJavaVersions := Seq(JavaSpec.temurin(\"11\"))\nThisBuild / tlBspCrossProjectPlatforms := Set(JVMPlatform)\n\nThisBuild / githubWorkflowAddedJobs +=\n  WorkflowJob(\n    id = \"coverage\",\n    name = s\"Generate coverage report (2.13 JVM only)\",\n    scalas = Nil,\n    sbtStepPreamble = Nil,\n    steps = githubWorkflowJobSetup.value.toList ++\n      List(\n        WorkflowStep.Sbt(List(\"coverage\", \"rootJVM/test\", \"coverageReport\")),\n        WorkflowStep.Use(UseRef.Public(\"codecov\", \"codecov-action\", \"v3\"))\n      )\n  )\n\n\nThisBuild / tlSitePublishBranch := Some(\"main\")\n\nlazy val commonSettings = Seq(\n  //scalacOptions --= Seq(\"-Wunused:params\", \"-Wunused:imports\", \"-Wunused:patvars\", \"-Wdead-code\", \"-Wunused:locals\", \"-Wunused:privates\", \"-Wunused:implicits\"),\n  libraryDependencies ++= Seq(\n    \"org.scalameta\" %%% \"munit\"             % munitVersion % \"test\",\n    \"org.scalameta\" %%% \"munit-scalacheck\"  % munitVersion % \"test\",\n    \"org.typelevel\" %%% \"cats-laws\"         % catsVersion % \"test\",\n    \"org.typelevel\" %%% \"discipline-munit\"  % disciplineMunitVersion % \"test\",\n    \"org.typelevel\" %%% \"munit-cats-effect\" % munitCatsEffectVersion % \"test\",\n    \"io.circe\"      %%% \"circe-literal\"     % circeVersion % \"test\",\n    \"io.circe\"      %%% \"circe-jawn\"        % circeVersion % \"test\",\n  ) ++ Seq(\n    compilerPlugin(\"org.typelevel\" %% \"kind-projector\" % kindProjectorVersion cross CrossVersion.full),\n  ).filterNot(_ => tlIsScala3.value),\n  headerMappings := headerMappings.value + (HeaderFileType.scala -> HeaderCommentStyle.cppStyleLineComment),\n  headerLicense  := Some(HeaderLicense.Custom(\n    \"\"\"|Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n       |Copyright (c) 2016-2023 Grackle Contributors\n       |\n       |Licensed under the Apache License, Version 2.0 (the \"License\");\n       |you may not use this file except in compliance with the License.\n       |You may obtain a copy of the License at\n       |\n       |  http://www.apache.org/licenses/LICENSE-2.0\n       |\n       |Unless required by applicable law or agreed to in writing, software\n       |distributed under the License is distributed on an \"AS IS\" BASIS,\n       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n       |See the License for the specific language governing permissions and\n       |limitations under the License.\n       |\"\"\".stripMargin\n  ))\n)\n\nlazy val modules: List[CompositeProject] = List(\n  core,\n  circe,\n  sql,\n  doobie,\n  skunk,\n  generic,\n  docs,\n  unidocs,\n  demo,\n  benchmarks,\n  profile\n)\n\nlazy val root = tlCrossRootProject\n  .aggregate(modules:_*)\n  .disablePlugins(RevolverPlugin)\n\nlazy val core = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/core\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-core\",\n    libraryDependencies ++=\n      Seq(\n        \"org.typelevel\" %%% \"cats-parse\"   % catsParseVersion,\n        \"org.typelevel\" %%% \"cats-core\"    % catsVersion,\n        \"org.typelevel\" %%% \"literally\"    % literallyVersion,\n        \"io.circe\"      %%% \"circe-core\"   % circeVersion,\n        \"org.tpolecat\"  %%% \"typename\"     % typenameVersion,\n        \"org.tpolecat\"  %%% \"sourcepos\"    % sourcePosVersion,\n        \"co.fs2\"        %%% \"fs2-core\"     % fs2Version,\n      )\n  )\n  .jsSettings(\n    libraryDependencies += \"io.github.cquiroz\" %%% \"scala-java-time\" % \"2.5.0\",\n    scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.CommonJSModule))\n  )\n\nlazy val circe = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/circe\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-circe\",\n  )\n\nlazy val buildInfo = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/build-info\"))\n  .enablePlugins(BuildInfoPlugin, NoPublishPlugin)\n  .settings(commonSettings)\n  .settings(\n    buildInfoKeys += \"baseDirectory\" -> (LocalRootProject / baseDirectory).value.toString\n  )\n\nlazy val sql = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Full)\n  .in(file(\"modules/sql\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core % \"test->test;compile->compile\", circe, buildInfo % Test)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-sql\",\n    libraryDependencies ++= Seq(\n      \"io.circe\"          %%% \"circe-generic\"      % circeVersion % \"test\",\n      \"co.fs2\"            %%% \"fs2-io\"             % fs2Version % \"test\",\n    )\n  )\n  .platformsSettings(JVMPlatform, JSPlatform)(\n    libraryDependencies ++= Seq(\n      \"io.chrisdavenport\" %%% \"whale-tail-manager\" % whaleTailVersion % \"test\",\n    )\n  )\n  .jvmSettings(\n    libraryDependencies ++= Seq(\n      \"com.github.jnr\"    % \"jnr-unixsocket\"      % jnrUnixsocketVersion % \"test\"\n    )\n  )\n\nlazy val doobie = project\n  .in(file(\"modules/doobie-pg\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(sql.jvm % \"test->test;compile->compile\", circe.jvm)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-doobie-pg\",\n    Test / fork := true,\n    Test / parallelExecution := false,\n    libraryDependencies ++= Seq(\n      \"org.tpolecat\"   %% \"doobie-core\"           % doobieVersion,\n      \"org.tpolecat\"   %% \"doobie-postgres-circe\" % doobieVersion,\n      \"org.typelevel\"  %% \"log4cats-core\"         % log4catsVersion,\n      \"ch.qos.logback\" %  \"logback-classic\"       % logbackVersion % \"test\"\n    )\n  )\n\nlazy val skunk = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Full)\n  .in(file(\"modules/skunk\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(sql % \"test->test;compile->compile\", circe)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-skunk\",\n    Test / parallelExecution := false,\n    libraryDependencies ++= Seq(\n      \"org.tpolecat\" %%% \"skunk-core\"  % skunkVersion,\n      \"org.tpolecat\" %%% \"skunk-circe\" % skunkVersion,\n    )\n  )\n  .jvmSettings(\n    Test / fork := true\n  )\n  .jsSettings(\n    scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.CommonJSModule))\n  )\n\nlazy val generic = crossProject(JVMPlatform, JSPlatform, NativePlatform)\n  .crossType(CrossType.Pure)\n  .in(file(\"modules/generic\"))\n  .enablePlugins(AutomateHeaderPlugin)\n  .disablePlugins(RevolverPlugin)\n  .dependsOn(core)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-generic\",\n    libraryDependencies += (\n      scalaVersion.value match {\n        case Scala3 => \"org.typelevel\" %%% \"shapeless3-deriving\" % shapeless3Version\n        case Scala2 => \"com.chuusai\"   %%% \"shapeless\"           % shapeless2Version\n      })\n  )\n\nlazy val demo = project\n  .in(file(\"demo\"))\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin)\n  .dependsOn(core.jvm, generic.jvm, doobie)\n  .settings(commonSettings)\n  .settings(\n    name := \"grackle-demo\",\n    coverageEnabled := false,\n    libraryDependencies ++= Seq(\n      \"org.typelevel\"     %% \"log4cats-slf4j\"             % log4catsVersion,\n      \"ch.qos.logback\"    %  \"logback-classic\"            % logbackVersion,\n      \"org.tpolecat\"      %% \"doobie-core\"                % doobieVersion,\n      \"org.tpolecat\"      %% \"doobie-postgres\"            % doobieVersion,\n      \"org.tpolecat\"      %% \"doobie-hikari\"              % doobieVersion,\n      \"org.http4s\"        %% \"http4s-ember-server\"        % http4sVersion,\n      \"org.http4s\"        %% \"http4s-ember-client\"        % http4sVersion,\n      \"org.http4s\"        %% \"http4s-circe\"               % http4sVersion,\n      \"org.http4s\"        %% \"http4s-dsl\"                 % http4sVersion,\n      \"org.flywaydb\"      %  \"flyway-database-postgresql\" % flywayVersion,\n      \"io.chrisdavenport\" %% \"whale-tail-manager\"         % whaleTailVersion,\n      \"com.github.jnr\"    % \"jnr-unixsocket\"              % jnrUnixsocketVersion\n    )\n  )\n\nlazy val benchmarks = project\n  .in(file(\"benchmarks\"))\n  .dependsOn(core.jvm)\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin, JmhPlugin)\n  .settings(commonSettings)\n  .settings(    \n    coverageEnabled := false,\n)\n\nlazy val profile = project\n  .in(file(\"profile\"))\n  .enablePlugins(NoPublishPlugin, AutomateHeaderPlugin)\n  .dependsOn(core.jvm)\n  .dependsOn(doobie)\n  .settings(commonSettings)\n  .settings(\n    jfrRecordings := Seq(\n      JfrRecording(\n        fileName = file(\"profile.jfr\").toPath.some,\n        name = \"profile\".some,\n        delay = 5.seconds.some,\n        disk = true.some,\n        dumpOnExit = true.some,\n        duration = 30.seconds.some,\n        pathToGcRoots = true.some,\n      )\n    ),\n    fork := true,\n    coverageEnabled := false,\n  )\n\nlazy val docs = project\n  .in(file(\"modules/docs\"))\n  .enablePlugins(TypelevelSitePlugin, AutomateHeaderPlugin)\n  .settings(commonSettings)\n  .settings(\n    mdocVariables ++= Map(\"headerVariant\" -> \"tutorial\"),\n    libraryDependencies ++= Seq(\n      \"org.typelevel\" %% \"cats-effect\" % catsEffectVersion\n    ),\n    coverageEnabled := false,\n  )\n\n// Run repoDocs / mdoc manually to generated README.md from docs/index.md and header.md\nlazy val repoDocs = project\n  .in(file(\"repo-docs\"))\n  .dependsOn(core.jvm, docs)\n  .enablePlugins(MdocPlugin, NoPublishPlugin)\n  .settings(\n    mdocVariables :=\n      Map(\n        \"VERSION\"       -> tlLatestVersion.value.getOrElse(version.value),\n        \"headerVariant\" -> \"repo\"\n        ),\n    mdocIn  := file(\"docs/index.md\"),\n    mdocOut := file(\"README.md\"),\n    coverageEnabled := false,\n  )\n\nlazy val unidocs = project\n  .in(file(\"unidocs\"))\n  .enablePlugins(TypelevelUnidocPlugin)\n  .settings(\n    name := \"grackle-docs\",\n    coverageEnabled := false,\n    ScalaUnidoc / unidoc / unidocProjectFilter := inProjects(\n      core.jvm,\n      circe.jvm,\n      sql.jvm,\n      doobie,\n      skunk.jvm,\n      generic.jvm,\n    )\n  )\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.data.NonEmptyChain\nimport cats.syntax.all._\nimport org.typelevel.literally.Literally\nimport grackle.Ast.Document\nimport grackle.Schema\n\ntrait VersionSpecificSyntax {\n  implicit def toStringContextOps(sc: StringContext): StringContextOps =\n    new StringContextOps(sc)\n}\n\nclass StringContextOps(val sc: StringContext) extends AnyVal {\n  def schema(args: Any*): Schema = macro SchemaLiteral.make\n  def doc(args: Any*): Document = macro DocumentLiteral.make\n}\n\nprivate object SchemaLiteral extends Literally[Schema] {\n  def validate(c: Context)(s: String): Either[String,c.Expr[Schema]] = {\n    import c.universe._\n    def mkError(err: Either[Throwable, NonEmptyChain[Problem]]) =\n      err.fold(\n        t  => s\"Internal error: ${t.getMessage}\",\n        ps => s\"Invalid schema: ${ps.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n      )\n    Schema(s, CompiletimeParsers.schemaParser).toEither.bimap(mkError, _ => c.Expr(q\"_root_.grackle.Schema($s, _root_.grackle.CompiletimeParsers.schemaParser).toOption.get\"))\n  }\n  def make(c: Context)(args: c.Expr[Any]*): c.Expr[Schema] = apply(c)(args: _*)\n}\n\nprivate object DocumentLiteral extends Literally[Document] {\n  def validate(c: Context)(s: String): Either[String,c.Expr[Document]] = {\n    import c.universe._\n    CompiletimeParsers.parser.parseText(s).toEither.bimap(\n      _.fold(thr => show\"Invalid document: ${thr.getMessage}\", _.toList.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")),\n      _  => c.Expr(q\"_root_.grackle.CompiletimeParsers.parser.parseText($s).toOption.get\"),\n    )\n  }\n  def make(c: Context)(args: c.Expr[Any]*): c.Expr[Document] = apply(c)(args: _*)\n}\n\nobject CompiletimeParsers {\n  val parser: GraphQLParser = GraphQLParser(GraphQLParser.defaultConfig)\n  val schemaParser: SchemaParser = SchemaParser(parser)\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.syntax.all._\nimport org.typelevel.literally.Literally\nimport grackle.Ast.Document\n\ntrait VersionSpecificSyntax:\n\n  extension (inline ctx: StringContext)\n    inline def schema(inline args: Any*): Schema = ${SchemaLiteral('ctx, 'args)}\n    inline def doc(inline args: Any*): Document = ${DocumentLiteral('ctx, 'args) }\n\nobject SchemaLiteral extends Literally[Schema]:\n  def validate(s: String)(using Quotes) =\n    Schema(s, CompiletimeParsers.schemaParser).toEither.bimap(\n      nec => s\"Invalid schema:${nec.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n      _   => '{Schema(${Expr(s)}, CompiletimeParsers.schemaParser).toOption.get}\n    )\n\nobject DocumentLiteral extends Literally[Document]:\n  def validate(s: String)(using Quotes) =\n    CompiletimeParsers.parser.parseText(s).toEither.bimap(\n      _.fold(thr => show\"Invalid document: ${thr.getMessage}\", _.toList.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")),\n      _ => '{CompiletimeParsers.parser.parseText(${Expr(s)}).toOption.get}\n    )\n\nobject CompiletimeParsers:\n  val parser: GraphQLParser = GraphQLParser(GraphQLParser.defaultConfig)\n  val schemaParser: SchemaParser = SchemaParser(parser)\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport scala.annotation.tailrec\nimport scala.reflect.ClassTag\n\nimport cats.data.StateT\nimport cats.implicits._\nimport io.circe.Json\nimport org.tpolecat.typename.{ TypeName, typeName }\n\nimport syntax._\nimport Query._, Predicate._, Value._, UntypedOperation._\nimport QueryCompiler._\nimport ScalarType._\n\n/**\n * GraphQL query parser\n */\ntrait QueryParser {\n  /**\n   *  Parse a String to query algebra operations and fragments.\n   *\n   *  GraphQL errors and warnings are accumulated in the result.\n   */\n  def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])]\n\n  /**\n   *  Parse a document AST to query algebra operations and fragments.\n   *\n   *  GraphQL errors and warnings are accumulated in the result.\n   */\n  def parseDocument(doc: Ast.Document): Result[(List[UntypedOperation], List[UntypedFragment])]\n}\n\nobject QueryParser {\n  def apply(parser: GraphQLParser): QueryParser =\n    new Impl(parser)\n\n  private final class Impl(parser: GraphQLParser) extends QueryParser {\n    import Ast.{ Directive => _, Type => _, Value => _, _ }, OperationDefinition._, Selection._\n\n    /**\n    *  Parse a String to query algebra operations and fragments.\n    *\n    *  GraphQL errors and warnings are accumulated in the result.\n    */\n    def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])] =\n      for {\n        doc <- parser.parseText(text)\n        res <- parseDocument(doc)\n        _   <- Result.failure(\"At least one operation required\").whenA(res._1.isEmpty)\n      } yield res\n\n    /**\n    *  Parse a document AST to query algebra operations and fragments.\n    *\n    *  GraphQL errors and warnings are accumulated in the result.\n    */\n    def parseDocument(doc: Document): Result[(List[UntypedOperation], List[UntypedFragment])] = {\n      val ops0 = doc.collect { case op: OperationDefinition => op }\n      val fragments0 = doc.collect { case frag: FragmentDefinition => frag }\n\n      for {\n        ops    <- ops0.traverse {\n                    case op: Operation => parseOperation(op)\n                    case qs: QueryShorthand => parseQueryShorthand(qs)\n                  }\n        frags  <- fragments0.traverse { frag =>\n                    val tpnme = frag.typeCondition.name\n                    for {\n                      sels <- parseSelections(frag.selectionSet)\n                      dirs <- parseDirectives(frag.directives)\n                    } yield UntypedFragment(frag.name.value, tpnme, dirs, sels)\n                  }\n      } yield (ops, frags)\n    }\n\n    /**\n    *  Parse an operation AST to a query algebra operation.\n    *\n    *  GraphQL errors and warnings are accumulated in the result.\n    */\n    def parseOperation(op: Operation): Result[UntypedOperation] = {\n      val Operation(opType, name, vds, dirs0, sels) = op\n      for {\n        vs   <- parseVariableDefinitions(vds)\n        q    <- parseSelections(sels)\n        dirs <- parseDirectives(dirs0)\n      } yield {\n        val name0 = name.map(_.value)\n        opType match {\n          case OperationType.Query => UntypedQuery(name0, q, vs, dirs)\n          case OperationType.Mutation => UntypedMutation(name0, q, vs, dirs)\n          case OperationType.Subscription => UntypedSubscription(name0, q, vs, dirs)\n        }\n      }\n    }\n\n    /**\n      * Parse variable definition ASTs to query algebra variable definitions.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseVariableDefinitions(vds: List[VariableDefinition]): Result[List[UntypedVarDef]] =\n      vds.traverse {\n        case VariableDefinition(Name(nme), tpe, dv0, dirs0) =>\n          for {\n            dv   <- dv0.traverse(Value.fromAst)\n            dirs <- parseDirectives(dirs0)\n          } yield UntypedVarDef(nme, tpe, dv, dirs)\n      }\n\n    /**\n      * Parse a query shorthand AST to query algebra operation.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseQueryShorthand(qs: QueryShorthand): Result[UntypedOperation] =\n      parseSelections(qs.selectionSet).map(q => UntypedQuery(None, q, Nil, Nil))\n\n    /**\n      * Parse selection ASTs to query algebra terms.\n      *\n      * GraphQL errors and warnings are accumulated in the result\n      */\n    def parseSelections(sels: List[Selection]): Result[Query] =\n      sels.traverse(parseSelection).map { sels0 =>\n        if (sels0.sizeCompare(1) == 0) sels0.head else Group(sels0)\n      }\n\n    /**\n      * Parse a selection AST to a query algebra term.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseSelection(sel: Selection): Result[Query] = sel match {\n      case Field(alias, name, args, directives, sels) =>\n        for {\n          args0 <- parseArgs(args)\n          sels0 <- parseSelections(sels)\n          dirs  <- parseDirectives(directives)\n        } yield {\n          val nme = name.value\n          val alias0 = alias.map(_.value).flatMap(n => if (n == nme) None else Some(n))\n          if (sels.isEmpty) UntypedSelect(nme, alias0, args0, dirs, Empty)\n          else UntypedSelect(nme, alias0, args0, dirs, sels0)\n        }\n\n      case FragmentSpread(Name(name), directives) =>\n        for {\n          dirs <- parseDirectives(directives)\n        } yield UntypedFragmentSpread(name, dirs)\n\n      case InlineFragment(typeCondition, directives, sels) =>\n        for {\n          dirs  <- parseDirectives(directives)\n          sels0 <- parseSelections(sels)\n        } yield UntypedInlineFragment(typeCondition.map(_.name), dirs, sels0)\n    }\n\n    /**\n      * Parse directive ASTs to query algebra directives.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseDirectives(directives: List[Ast.Directive]): Result[List[Directive]] =\n      directives.traverse(Directive.fromAst)\n\n    /**\n      * Parse argument ASTs to query algebra bindings.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseArgs(args: List[(Name, Ast.Value)]): Result[List[Binding]] =\n      args.traverse((parseArg _).tupled)\n\n    /**\n      * Parse an argument AST to a query algebra binding.\n      *\n      * GraphQL errors and warnings are accumulated in the result.\n      */\n    def parseArg(name: Name, value: Ast.Value): Result[Binding] =\n      Value.fromAst(value).map(v => Binding(name.value, v))\n  }\n}\n\n/**\n * GraphQL query compiler.\n *\n * A QueryCompiler parses GraphQL queries to query algebra terms, then\n * applies a collection of transformation phases in sequence, yielding a\n * query algebra term which can be directly interpreted.\n */\nclass QueryCompiler(parser: QueryParser, schema: Schema, phases: List[Phase]) {\n  import IntrospectionLevel._\n\n  /**\n   * Compiles the GraphQL query `text` to a query algebra term which\n   * can be directly executed.\n   *\n   * GraphQL errors and warnings are accumulated in the result.\n   */\n  def compile(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty): Result[Operation] =\n    parser.parseText(text).flatMap { case (ops, frags) =>\n      for {\n        _    <- Result.fromProblems(validateVariablesAndFragments(ops, frags, reportUnused))\n        ops0 <- ops.traverse(op => compileOperation(op, untypedVars, frags, introspectionLevel, env).map(op0 => (op.name, op0)))\n        res  <- (ops0, name) match {\n                  case (List((_, op)), None) =>\n                    op.success\n                  case (Nil, _) =>\n                    Result.failure(\"At least one operation required\")\n                  case (_, None) =>\n                    Result.failure(\"Operation name required to select unique operation\")\n                  case (ops, _) if ops.lengthCompare(1) > 0 && ops.exists(_._1.isEmpty) =>\n                    Result.failure(\"Query shorthand cannot be combined with multiple operations\")\n                  case (ops, name) =>\n                    ops.filter(_._1 == name) match {\n                      case List((_, op)) =>\n                        op.success\n                      case Nil =>\n                        Result.failure(s\"No operation named '$name'\")\n                      case _ =>\n                        Result.failure(s\"Multiple operations named '$name'\")\n                    }\n                }\n      } yield res\n    }\n\n  /**\n    * Compiles the provided operation AST to a query algebra term\n    * which can be directly executed.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileOperation(op: UntypedOperation, untypedVars: Option[Json], frags: List[UntypedFragment], introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Result[Operation] = {\n    val allPhases =\n      IntrospectionElaborator(introspectionLevel).toList ++ (VariablesSkipAndFragmentElaborator :: phases)\n\n    for {\n      varDefs <- compileVarDefs(op.variables)\n      vars    <- compileVars(varDefs, untypedVars)\n      _       <- Directive.validateDirectivesForQuery(schema, op, frags, vars)\n      rootTpe <- op.rootTpe(schema)\n      res     <- (\n                   for {\n                     query <- allPhases.foldLeftM(op.query) { (acc, phase) => phase.transformFragments *> phase.transform(acc) }\n                   } yield Operation(query, rootTpe, op.directives)\n                 ).runA(\n                   ElabState(\n                     None,\n                     schema,\n                     Context(rootTpe),\n                     vars,\n                     frags.map(f => (f.name, f)).toMap,\n                     op.query,\n                     env,\n                     List.empty,\n                     Elab.pure\n                   )\n                 )\n    } yield res\n  }\n\n  /**\n    * Compiles variable definition ASTs to variable definitions for the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileVarDefs(untypedVarDefs: UntypedVarDefs): Result[VarDefs] =\n    untypedVarDefs.traverse {\n      case UntypedVarDef(name, untypedTpe, default, dirs) =>\n        compileType(untypedTpe).map(tpe => InputValue(name, None, tpe, default, dirs))\n    }\n\n  /**\n    * Compiles raw query variables to variables for the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileVars(varDefs: VarDefs, untypedVars: Option[Json]): Result[Vars] =\n    untypedVars match {\n      case None => Map.empty.success\n      case Some(untypedVars) =>\n        untypedVars.asObject match {\n          case None =>\n            Result.failure(s\"Variables must be represented as a Json object\")\n          case Some(obj) =>\n            varDefs.traverse(iv => checkVarValue(iv, obj(iv.name), \"variable values\").map(v => (iv.name, (iv.tpe, v)))).map(_.toMap)\n        }\n    }\n\n  /**\n    * Compiles a type AST to a type in the target schema.\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n  def compileType(tpe: Ast.Type): Result[Type] = {\n    def loop(tpe: Ast.Type, nonNull: Boolean): Result[Type] = tpe match {\n      case Ast.Type.NonNull(Left(named)) => loop(named, true)\n      case Ast.Type.NonNull(Right(list)) => loop(list, true)\n      case Ast.Type.List(elem) => loop(elem, false).map(e => if (nonNull) ListType(e) else NullableType(ListType(e)))\n      case Ast.Type.Named(name) => schema.definition(name.value) match {\n        case None => Result.failure(s\"Undefined type '${name.value}'\")\n        case Some(tpe) => (if (nonNull) tpe else NullableType(tpe)).success\n      }\n    }\n    loop(tpe, false)\n  }\n\n  def validateVariablesAndFragments(ops: List[UntypedOperation], frags: List[UntypedFragment], reportUnused: Boolean): List[Problem] = {\n    val (uniqueFrags, duplicateFrags) = frags.map(_.name).foldLeft((Set.empty[String], Set.empty[String])) {\n      case ((unique, duplicate), nme) =>\n        if (unique.contains(nme)) (unique, duplicate + nme)\n        else (unique + nme, duplicate)\n    }\n\n    if (duplicateFrags.nonEmpty)\n      duplicateFrags.toList.map(nme => Problem(s\"Fragment '$nme' is defined more than once\"))\n    else {\n      def collectQueryRefs(query: Query): (Set[String], Set[String]) = {\n        @tailrec\n        def loop(queries: Iterator[Query], vars: Set[String], frags: Set[String]): (Set[String], Set[String]) =\n          if (!queries.hasNext) (vars, frags)\n          else\n            queries.next() match {\n              case UntypedSelect(_, _, args, dirs, child) =>\n                val v0 = args.iterator.flatMap(arg => collectValueRefs(arg.value)).toSet\n                val v1 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n                loop(Iterator.single(child) ++ queries, vars ++ v0 ++ v1, frags)\n              case UntypedFragmentSpread(nme, dirs) =>\n                val v0 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n                loop(queries, vars ++ v0, frags + nme)\n              case UntypedInlineFragment(_, dirs, child) =>\n                val v0 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n                loop(Iterator.single(child) ++ queries, vars ++ v0, frags)\n              case Group(children) =>\n                loop(children.iterator ++ queries, vars, frags)\n              case Select(_, _, child)       => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Narrow(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Unique(child)             => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Filter(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Limit(_, child)           => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Offset(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n              case OrderBy(_, child)         => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Introspect(_, child)      => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Environment(_, child)     => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Component(_, _, child)    => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Effect(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n              case TransformCursor(_, child) => loop(Iterator.single(child) ++ queries, vars, frags)\n              case Count(_)                  => loop(queries, vars, frags)\n              case Empty                     => loop(queries, vars, frags)\n            }\n\n        loop(Iterator.single(query), Set.empty[String], Set.empty[String])\n      }\n\n      def collectValueRefs(value: Value): Set[String] = {\n        @tailrec\n        def loop(values: Iterator[Value], vars: Set[String]): Set[String] =\n          if (!values.hasNext) vars\n          else\n            values.next() match {\n              case VariableRef(nme) =>\n                loop(values, Set(nme))\n              case ObjectValue(fields) =>\n                loop(fields.iterator.map(_._2) ++ values, vars)\n              case ListValue(elems) =>\n                loop(elems.iterator ++ values, vars)\n              case _ => loop(values, vars)\n            }\n\n        loop(Iterator.single(value), Set.empty[String])\n      }\n\n      val fragRefs: Map[String, (Set[String], Set[String])] =\n        frags.map { frag =>\n          (frag.name, collectQueryRefs(frag.child))\n        }.toMap\n\n      @tailrec\n      def checkCycle(pendingFrags: Set[String], seen: Set[String]): Option[Set[String]] = {\n        if (pendingFrags.isEmpty) Some(seen)\n        else {\n          val hd = pendingFrags.head\n          if (seen.contains(hd)) None\n          else checkCycle(fragRefs(hd)._2 ++ pendingFrags.tail, seen + hd)\n        }\n      }\n\n      def findCycle: Option[String] = {\n        @tailrec\n        def loop(pendingFrags: Set[String]): Either[Set[String], String] = {\n          if(pendingFrags.isEmpty) Left(Set.empty[String])\n          else {\n            val hd = pendingFrags.head\n            checkCycle(Set(hd), Set.empty[String]) match {\n              case None => Right(hd)\n              case Some(seen) => loop(pendingFrags.tail.diff(seen))\n            }\n          }\n        }\n\n        if (uniqueFrags.isEmpty) None\n        else loop(uniqueFrags).toOption\n      }\n\n      findCycle match {\n        case Some(from) => List(Problem(s\"Fragment cycle starting from '$from'\"))\n        case _ =>\n          def validateOp(op: UntypedOperation, pendingFrags: Set[String]): (List[Problem], Set[String]) = {\n            val pendingVars = op.variables.map(_.name).toSet\n            val (dqv, dqf) = collectQueryRefs(op.query)\n\n            val (qv, qf) = {\n              dqf.foldLeft((dqv, dqf)) {\n                case ((v, f), nme) => fragRefs.get(nme) match {\n                  case None => (v, f)\n                  case Some((fv, ff)) => (v ++ fv, f ++ ff)\n                }\n              }\n            }\n\n            val varProblems =\n              if (qv == pendingVars) Nil\n              else {\n                val undefinedProblems =\n                  qv.diff(pendingVars).toList.map(nme => Problem(s\"Variable '$nme' is undefined\"))\n\n                val unusedProblems =\n                  if (!reportUnused) Nil\n                  else pendingVars.diff(qv).toList.map(nme => Problem(s\"Variable '$nme' is unused\"))\n\n                undefinedProblems ++ unusedProblems\n              }\n\n            val fragProblems =\n              if (qf.subsetOf(uniqueFrags)) Nil\n              else {\n                val undefined = qf.diff(uniqueFrags)\n                val undefinedProblems = undefined.toList.map(nme => Problem(s\"Fragment '$nme' is undefined\"))\n                undefinedProblems\n              }\n\n            (varProblems ++ fragProblems, pendingFrags.diff(qf))\n          }\n\n          val (opProblems, unreferencedFrags) =\n            ops.foldLeft((List.empty[Problem], uniqueFrags)) {\n              case ((acc, pendingFrags), op) =>\n                val (problems, pendingFrags0) = validateOp(op, pendingFrags)\n                (acc ++ problems, pendingFrags0)\n              }\n\n          val unreferencedFragProblems =\n            if (!reportUnused) Nil\n            else unreferencedFrags.toList.map(nme => Problem(s\"Fragment '$nme' is unused\"))\n\n          opProblems ++ unreferencedFragProblems\n      }\n    }\n  }\n}\n\nobject QueryCompiler {\n  sealed trait IntrospectionLevel\n  object IntrospectionLevel {\n    case object Full extends IntrospectionLevel\n    case object TypenameOnly extends IntrospectionLevel\n    case object Disabled extends IntrospectionLevel\n  }\n\n  import IntrospectionLevel._\n\n  /**\n    * Elaboration monad.\n    *\n    * Supports threading of state through the elaboration of a query. Provides,\n    * + access to the schema, context, variables and fragments of a query.\n    * + ability to transform the children of Selects to supply semantics for field arguments.\n    * + ability to add contextual data to the resulting query both to support propagation of\n    *   context to the elaboration of children, and to to drive run time behaviour.\n    * + ability to add selects for additional attributes to the resulting query.\n    * + ability to test existence and properties of neighbour nodes of the node being\n    *   elaborated.\n    * + ability to report errors and warnings during elaboration.\n    */\n  type Elab[T] = StateT[Result, ElabState, T]\n  object Elab {\n    def unit: Elab[Unit] = StateT.pure(())\n    def pure[T](t: T): Elab[T] = StateT.pure(t)\n    def liftR[T](rt: Result[T]): Elab[T] = StateT.liftF(rt)\n\n    /** The scheam of the query being elaborated */\n    def schema: Elab[Schema] = StateT.inspect(_.schema)\n    /** The context of the node currently being elaborated */\n    def context: Elab[Context] = StateT.inspect(_.context)\n    /** The variables of the query being elaborated */\n    def vars: Elab[Vars] = StateT.inspect(_.vars)\n    /** The fragments of the query being elaborated */\n    def fragments: Elab[Map[String, UntypedFragment]] = StateT.inspect(_.fragments)\n    /** The fragment with the supplied name, if defined, failing otherwise */\n    def fragment(nme: String): Elab[UntypedFragment] =\n      StateT.inspectF(_.fragments.get(nme).toResult(s\"Fragment '$nme' is not defined\"))\n    def transformFragments(f: Map[String, UntypedFragment] => Elab[Map[String, UntypedFragment]]): Elab[Unit] =\n      for {\n        fs  <- fragments\n        fs0 <- f(fs)\n        _   <- StateT.modify(_.copy(fragments = fs0)): Elab[Unit]\n      } yield ()\n    /** `true` if the node currently being elaborated has a child with the supplied name */\n    def hasField(name: String): Elab[Boolean] = StateT.inspect(_.hasField(name))\n    /** The alias, if any, of the child with the supplied name */\n    def fieldAlias(name: String): Elab[Option[String]] = StateT.inspect(_.fieldAlias(name))\n    /** `true` if the node currently being elaborated has a sibling with the supplied name */\n    def hasSibling(name: String): Elab[Boolean] = StateT.inspect(_.hasSibling(name))\n    /** The result name of the node currently being elaborated */\n    def resultName: Elab[Option[String]] = StateT.inspect(_.resultName)\n\n    /** Binds the supplied value to the supplied name in the elaboration environment */\n    def env(nme: String, value: Any): Elab[Unit] = env(List(nme -> value))\n    /** Binds the supplied names and values in the elaboration environment */\n    def env(kv: (String, Any), kvs: (String, Any)*): Elab[Unit] = env(kv +: kvs.toSeq)\n    /** Binds the supplied names and values in the elaboration environment */\n    def env(kvs: Seq[(String, Any)]): Elab[Unit] = StateT.modify(_.env(kvs))\n    /** Adds all the bindings of the supplied environment to the elaboration environment */\n    def env(other: Env): Elab[Unit] = StateT.modify(_.env(other))\n    /** The value bound to the supplied name in the elaboration environment, if any */\n    def env[T: ClassTag](nme: String): Elab[Option[T]] = StateT.inspect(_.env[T](nme))\n    /** The value bound to the supplied name in the elaboration environment, if any, failing otherwise */\n    def envE[T: ClassTag: TypeName](nme: String): Elab[T] =\n      env(nme).flatMap(v => Elab.liftR(v.toResultOrError(s\"Key '$nme' of type ${typeName[T]} was not found in $this\")))\n    /** The subset of the elaboration environment defined directly at this node */\n    def localEnv: Elab[Env] = StateT.inspect(_.localEnv)\n\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Elab[Query]): Elab[Unit] = StateT.modify(_.addChildTransform(f))\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Query)(implicit dummy: DummyImplicit): Elab[Unit] = transformChild(q => Elab.pure(f(q)))\n    /** Applies the supplied transformation to the child of the node currently being elaborated */\n    def transformChild(f: Query => Result[Query])(implicit dummy1: DummyImplicit, dummy2: DummyImplicit): Elab[Unit] = transformChild(q => Elab.liftR(f(q)))\n    /** The transformation to be applied to the child of the node currently being elaborated */\n    def transform: Elab[Query => Elab[Query]] = StateT.inspect(_.childTransform)\n    /** Add the supplied attributed and corresponding query, if any, to the query being elaborated */\n    def addAttribute(name: String, query: Query = Empty): Elab[Unit] = StateT.modify(_.addAttribute(name, query))\n    /** The attributes which have been added to the query being elaborated */\n    def attributes: Elab[List[(String, Query)]] = StateT.inspect(_.attributes)\n\n    /** Report the supplied GraphQL warning during elaboration */\n    def warning(msg: String): Elab[Unit] = StateT(s => Result.warning[(ElabState, Unit)](msg, (s, ())))\n    /** Report the supplied GraphQL warning during elaboration */\n    def warning(err: Problem): Elab[Unit] = StateT(s => Result.warning[(ElabState, Unit)](err, (s, ())))\n    /** Report the supplied GraphQL error during elaboration */\n    def failure[T](msg: String): Elab[T] = StateT(_ => Result.failure[(ElabState, T)](msg))\n    /** Report the supplied GraphQL error during elaboration */\n    def failure[T](err: Problem): Elab[T] = StateT(_ => Result.failure[(ElabState, T)](err))\n    /** Report the supplied internal error during elaboration */\n    def internalError[T](msg: String): Elab[T] = StateT(_ => Result.internalError[(ElabState, T)](msg))\n    /** Report the supplied internal error during elaboration */\n    def internalError[T](err: Throwable): Elab[T] = StateT(_ => Result.internalError[(ElabState, T)](err))\n\n    /** Save the current elaboration state */\n    def push: Elab[Unit] = StateT.modify(_.push)\n    /** Save the current elaboration state and switch to the supplied context and query */\n    def push(context: Context, query: Query): Elab[Unit] = StateT.modify(_.push(context, query))\n    /** Save the current elaboration state and switch to the supplied schema, context and query */\n    def push(schema: Schema, context: Context, query: Query): Elab[Unit] = StateT.modify(_.push(schema, context, query))\n    /** Restore the previous elaboration state */\n    def pop: Elab[Unit] = StateT.modifyF(s => s.parent.toResultOrError(\"Cannot pop root state\"))\n  }\n\n  /**\n    * The state managed by the elaboration monad.\n    */\n  case class ElabState(\n    parent: Option[ElabState],\n    schema: Schema,\n    context: Context,\n    vars: Vars,\n    fragments: Map[String, UntypedFragment],\n    query: Query,\n    localEnv: Env,\n    attributes: List[(String, Query)],\n    childTransform: Query => Elab[Query]\n  ) {\n    def hasField(fieldName: String): Boolean = Query.hasField(query, fieldName)\n    def fieldAlias(fieldName: String): Option[String] = Query.fieldAlias(query, fieldName)\n    def hasSibling(fieldName: String): Boolean = parent.exists(s => Query.hasField(s.query, fieldName))\n    def resultName: Option[String] = Query.ungroup(query).headOption.flatMap(Query.resultName)\n    def env(kvs: Seq[(String, Any)]): ElabState = copy(localEnv = localEnv.add(kvs: _*))\n    def env(other: Env): ElabState = copy(localEnv = localEnv.add(other))\n    def env[T: ClassTag](nme: String): Option[T] = localEnv.get(nme).orElse(parent.flatMap(_.env(nme)))\n    def addAttribute(name: String, query: Query = Empty): ElabState = copy(attributes = (name, query) :: attributes)\n    def addChildTransform(f: Query => Elab[Query]): ElabState = copy(childTransform = childTransform.andThen(_.flatMap(f)))\n    def push: ElabState = copy(parent = Some(this), localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n    def push(context: Context, query: Query): ElabState =\n      copy(parent = Some(this), context = context, query = query, localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n    def push(schema: Schema, context: Context, query: Query): ElabState =\n      copy(parent = Some(this), schema = schema, context = context, query = query, localEnv = Env.empty, attributes = Nil, childTransform = Elab.pure)\n  }\n\n  /** A QueryCompiler phase. */\n  trait Phase {\n    def transformFragments: Elab[Unit] = Elab.unit\n\n    /**\n     * Transform the supplied query algebra term `query`.\n     */\n    def transform(query: Query): Elab[Query] =\n      query match {\n        case s@UntypedSelect(fieldName, alias, _, _, child) =>\n          transformSelect(fieldName, alias, child).map(ec => s.copy(child = ec))\n\n        case s@Select(fieldName, alias, child) =>\n          transformSelect(fieldName, alias, child).map(ec => s.copy(child = ec))\n\n        case n@Narrow(subtpe, child)  =>\n          for {\n            c  <- Elab.context\n            _  <- Elab.push(c.asType(subtpe), child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield n.copy(child = ec)\n\n        case f@UntypedFragmentSpread(_, _) => Elab.pure(f)\n        case i@UntypedInlineFragment(None, _, child) =>\n          transform(child).map(ec => i.copy(child = ec))\n        case i@UntypedInlineFragment(Some(tpnme), _, child) =>\n          for {\n            s      <- Elab.schema\n            c      <- Elab.context\n            subtpe <- Elab.liftR(Result.fromOption(s.definition(tpnme), s\"Unknown type '$tpnme' in type condition\"))\n            _      <- Elab.push(c.asType(subtpe), child)\n            ec     <- transform(child)\n            _      <- Elab.pop\n          } yield i.copy(child = ec)\n\n        case i@Introspect(_, child) =>\n          for {\n            s    <- Elab.schema\n            c    <- Elab.context\n            iTpe =  if(c.tpe =:= s.queryType) Introspection.schema.queryType else TypenameType\n            _    <- Elab.push(Introspection.schema, c.asType(iTpe), child)\n            ec   <- transform(child)\n            _    <- Elab.pop\n          } yield i.copy(child = ec)\n\n        case u@Unique(child) =>\n          for {\n            c  <- Elab.context\n            _  <- Elab.push(c.asType(c.tpe.nonNull.list), child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield u.copy(child = ec)\n\n        case f@Filter(_, child) =>\n          for {\n            c    <- Elab.context\n            item <- Elab.liftR(c.tpe.item.toResultOrError(s\"Filter of non-List type ${c.tpe}\"))\n            _    <- Elab.push(c.asType(item), child)\n            ec   <- transform(child)\n            _    <- Elab.pop\n          } yield f.copy(child = ec)\n\n        case n@Count(child) =>\n          for {\n            c  <- Elab.context\n            pc <- Elab.liftR(c.parent.toResultOrError(s\"Count node has no parent\"))\n            _  <- Elab.push(pc, child)\n            ec <- transform(child)\n            _  <- Elab.pop\n          } yield n.copy(child = ec)\n\n        case g@Group(children) =>\n          children.traverse { c =>\n            for {\n              _  <- Elab.push\n              tc <- transform(c)\n              _  <- Elab.pop\n            } yield tc\n          }.map(eqs => g.copy(queries = eqs))\n\n        case c@Component(_, _, child) => transform(child).map(ec => c.copy(child = ec))\n        case e@Effect(_, child)       => transform(child).map(ec => e.copy(child = ec))\n        case l@Limit(_, child)        => transform(child).map(ec => l.copy(child = ec))\n        case o@Offset(_, child)       => transform(child).map(ec => o.copy(child = ec))\n        case o@OrderBy(_, child)      => transform(child).map(ec => o.copy(child = ec))\n        case e@Environment(_, child)  => transform(child).map(ec => e.copy(child = ec))\n        case t@TransformCursor(_, child) => transform(child).map(ec => t.copy(child = ec))\n        case Empty                    => Elab.pure(Empty)\n      }\n\n    def transformSelect(fieldName: String, alias: Option[String], child: Query): Elab[Query] =\n      for {\n        c        <- Elab.context\n        _        <- validateSubselection(fieldName, child)\n        childCtx <- Elab.liftR(c.forField(fieldName, alias))\n        _        <- Elab.push(childCtx, child)\n        ec       <- transform(child)\n        _        <- Elab.pop\n      } yield ec\n\n    def validateSubselection(fieldName: String, child: Query): Elab[Unit] =\n      for {\n        c        <- Elab.context\n        obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n        childCtx <- Elab.liftR(c.forField(fieldName, None))\n        tpe      =  childCtx.tpe\n        _        <- {\n                      val isLeaf = tpe.isUnderlyingLeaf\n                      if (isLeaf && child != Empty)\n                        Elab.failure(s\"Leaf field '$fieldName' of $obj must have an empty subselection set\")\n                      else if (!isLeaf && child == Empty)\n                        Elab.failure(s\"Non-leaf field '$fieldName' of $obj must have a non-empty subselection set\")\n                      else\n                        Elab.pure(())\n                    }\n      } yield ()\n\n    val TypenameType = ObjectType(s\"__Typename\", None, List(Field(\"__typename\", None, Nil, StringType, Nil)), Nil, Nil)\n  }\n\n  /**\n   * A phase which elaborates GraphQL introspection queries into the query algrebra.\n   */\n  class IntrospectionElaborator(level: IntrospectionLevel) extends Phase {\n    override def transformFragments: Elab[Unit] =\n      Elab.transformFragments { fs =>\n        fs.toList.traverse {\n          case (nme, f@UntypedFragment(_, tpnme, _, child)) =>\n            for {\n              s   <- Elab.schema\n              c   <- Elab.context\n              tpe <- Elab.liftR(Result.fromOption(s.definition(tpnme).orElse(Introspection.schema.definition(tpnme)), s\"Unknown type '$tpnme' in fragment definition\"))\n              _   <- Elab.push(c.asType(tpe), child)\n              ec  <- transform(child)\n              _   <- Elab.pop\n           } yield (nme, f.copy(child = ec))\n        }.map(_.toMap)\n      }\n\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@UntypedSelect(fieldName @ (\"__typename\" | \"__schema\" | \"__type\"), _, _, _, _) =>\n          (fieldName, level) match {\n            case (\"__typename\", Disabled) =>\n              Elab.failure(\"Introspection is disabled\")\n            case (\"__schema\" | \"__type\", TypenameOnly | Disabled) =>\n              Elab.failure(\"Introspection is disabled\")\n            case _ =>\n              for {\n                schema <- Elab.schema\n              } yield Introspect(schema, s)\n          }\n        case _ => super.transform(query)\n      }\n  }\n\n  object IntrospectionElaborator {\n    def apply(level: IntrospectionLevel): Option[IntrospectionElaborator] =\n      level match {\n        case Disabled => None\n        case other => Some(new IntrospectionElaborator(other))\n      }\n  }\n\n  /**\n   * A phase which elaborates variables, directives, fragment spreads\n   * and inline fragments.\n   *\n   * 1. Query variable values are substituted for all variable\n   *    references.\n   *\n   * 2. `skip` and `include` directives are handled during this phase\n   *    and the guarded subqueries are retained or removed as\n   *    appropriate.\n   *\n   * 3. Fragment spread and inline fragments are expanded.\n   *\n   * 4. types narrowing coercions by resolving the target type\n   *    against the schema.\n   *\n   * 5. verifies that leaves have an empty subselection set and that\n   *    structured types have a non-empty subselection set.\n   */\n  object VariablesSkipAndFragmentElaborator extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case Group(children) =>\n          children.traverse(q => transform(q)).map { eqs =>\n            eqs.filterNot(_ == Empty) match {\n              case Nil => Empty\n              case eq :: Nil => eq\n              case eqs => Group(eqs)\n            }\n          }\n        case sel@UntypedSelect(fieldName, alias, args, dirs, child) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              _        <- validateSubselection(fieldName, child)\n              s        <- Elab.schema\n              c        <- Elab.context\n              childCtx <- Elab.liftR(c.forField(fieldName, alias))\n              vars     <- Elab.vars\n              eArgs    <- args.traverse(elaborateBinding(_, vars))\n              eDirs    <- Elab.liftR(Directive.elaborateDirectives(s, dirs, vars))\n              _        <- Elab.push(childCtx, child)\n              ec       <- transform(child)\n              _        <- Elab.pop\n            } yield sel.copy(args = eArgs, directives = eDirs, child = ec)\n          )\n\n        case UntypedFragmentSpread(nme, dirs) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              s      <- Elab.schema\n              c      <- Elab.context\n              f      <- Elab.fragment(nme)\n              ctpe   <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n              subtpe <- Elab.liftR(s.definition(f.tpnme).toResult(s\"Unknown type '${f.tpnme}' in type condition of fragment '$nme'\"))\n              _      <- Elab.failure(s\"Fragment '$nme' is not compatible with type '${c.tpe}'\").whenA(!(subtpe <:< ctpe) && !(ctpe <:< subtpe))\n              _      <- Elab.push(c.asType(subtpe), f.child)\n              ec     <- transform(f.child)\n              _      <- Elab.pop\n            } yield\n              if (ctpe <:< subtpe) ec\n              else Narrow(s.ref(subtpe.name), ec)\n          )\n\n        case UntypedInlineFragment(tpnme0, dirs, child) =>\n          isSkipped(dirs).ifM(\n            Elab.pure(Empty),\n            for {\n              s      <- Elab.schema\n              c      <- Elab.context\n              ctpe   <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n              subtpe <- tpnme0 match {\n                          case None =>\n                            Elab.pure(ctpe)\n                          case Some(tpnme) =>\n                            Elab.liftR(s.definition(tpnme).toResult(s\"Unknown type '$tpnme' in type condition inline fragment\"))\n                        }\n              _      <- Elab.failure(s\"Inline fragment with type condition '$subtpe' is not compatible with type '$ctpe'\").whenA(!(subtpe <:< ctpe) && !(ctpe <:< subtpe))\n              _      <- Elab.push(c.asType(subtpe), child)\n              ec     <- transform(child)\n              _      <- Elab.pop\n            } yield\n              if (ctpe <:< subtpe) ec\n              else Narrow(s.ref(subtpe.name), ec)\n          )\n\n        case _ => super.transform(query)\n      }\n\n    def elaborateBinding(b: Binding, vars: Vars): Elab[Binding] =\n      Elab.liftR(Value.elaborateValue(b.value, vars).map(ev => b.copy(value = ev)))\n\n    def isSkipped(dirs: List[Directive]): Elab[Boolean] =\n      dirs.filter(d => d.name == \"skip\" || d.name == \"include\") match {\n        case Nil => Elab.pure(false)\n        case List(Directive(nme, List(Binding(\"if\", value)))) =>\n          for {\n            c <- extractCond(value)\n          } yield (nme == \"skip\" && c) || (nme == \"include\" && !c)\n        case List(Directive(nme, _)) => Elab.failure(s\"Directive '$nme' must have a single Boolean 'if' argument\")\n        case _ => Elab.failure(\"skip/include directives must be unique\")\n      }\n\n    def extractCond(value: Value): Elab[Boolean] =\n      value match {\n        case VariableRef(varName) =>\n          for {\n            v  <- Elab.vars\n            tv <- Elab.liftR(Result.fromOption(v.get(varName), s\"Variable '$varName' is undefined\"))\n            b  <- tv match {\n                    case (tpe, BooleanValue(value)) if tpe.nonNull =:= BooleanType => Elab.pure(value)\n                    case _ => Elab.failure(s\"Argument of skip/include must be boolean\")\n                  }\n          } yield b\n        case BooleanValue(value) => Elab.pure(value)\n        case _ => Elab.failure(s\"Argument of skip/include must be boolean\")\n      }\n  }\n\n  /**\n   * A compiler phase which translates `Select` nodes to be directly\n   * interpretable.\n   *\n   * This phase,\n   *\n   * 1. types bindings according to the schema:\n   *    i)   untyped enums are validated and typed according to their\n   *         declared type.\n   *    ii)  String and Int bindings are translated to ID bindings\n   *         where appropriate.\n   *    iii) default values are supplied for missing arguments.\n   *    iv)  arguments are permuted into the order declared in the\n   *         schema.\n   *\n   * 2. eliminates Select arguments by delegating to a model-specific\n   *    `PartialFunction` which is responsible for translating `Select`\n   *    nodes into a form which is directly interpretable, for example,\n   *    replacing them with a `Filter` or `Unique` node with a\n   *    `Predicate` which is parameterized by the arguments, ie.,\n   *\n   *    ```\n   *    UntypedSelect(\"character\", None, List(IDBinding(\"id\", \"1000\")), Nil, child)\n   *    ```\n   *    might be translated to,\n   *    ```\n   *    Select(\"character, None, Filter(FieldEquals(\"id\", \"1000\"), child))\n   *    ```\n   * 3. GraphQL introspection query field arguments are elaborated.\n   */\n  trait SelectElaborator extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case sel@UntypedSelect(fieldName, resultName, args, dirs, child) =>\n          for {\n            c        <- Elab.context\n            s        <- Elab.schema\n            childCtx <- Elab.liftR(c.forField(fieldName, resultName))\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Expected object type, found ${c.tpe}\"))\n            field    <- obj match {\n                          case twf: TypeWithFields =>\n                            Elab.liftR(twf.fieldInfo(fieldName).toResult(s\"No field '$fieldName' for type ${obj.underlying}\"))\n                          case _ => Elab.failure(s\"Type $obj is not an object or interface type\")\n                        }\n            eArgs    <- Elab.liftR(elaborateFieldArgs(obj, field, args))\n            ref      <- Elab.liftR(s.ref(obj).orElse(introspectionRef(obj)).toResultOrError(s\"Type $obj not found in schema\"))\n            _        <- if (s eq Introspection.schema) elaborateIntrospection(ref, fieldName, eArgs)\n                        else select(ref, fieldName, eArgs, dirs)\n            elab     <- Elab.transform\n            env      <- Elab.localEnv\n            attrs    <- Elab.attributes\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            e2       <- elab(ec)\n          } yield {\n            val e1 = Select(sel.name, sel.alias, e2)\n            val e0 =\n              if(attrs.isEmpty) e1\n              else Group((e1 :: attrs.map { case (nme, child) => Select(nme, child) }).flatMap(Query.ungroup))\n\n            if (env.isEmpty) e0\n            else Environment(env, e0)\n          }\n\n        case _ => super.transform(query)\n      }\n\n    def select(ref: TypeRef, name: String, args: List[Binding], directives: List[Directive]): Elab[Unit]\n\n    val QueryTypeRef = Introspection.schema.ref(\"Query\")\n    val TypeTypeRef = Introspection.schema.ref(\"__Type\")\n    val FieldTypeRef = Introspection.schema.ref(\"__Field\")\n    val EnumValueTypeRef = Introspection.schema.ref(\"__EnumValue\")\n\n    def introspectionRef(tpe: Type): Option[TypeRef] =\n      Introspection.schema.ref(tpe).orElse(tpe.asNamed.flatMap(\n        _.name match {\n          case \"__Typename\" => Some(Introspection.schema.ref(\"__Typename\"))\n          case _ => None\n        }\n      ))\n\n    def elaborateIntrospection(ref: TypeRef, name: String, args: List[Binding]): Elab[Unit] =\n      (ref, name, args) match {\n        case (QueryTypeRef, \"__type\", List(Binding(\"name\", StringValue(name)))) =>\n          Elab.transformChild(child => Unique(Filter(Eql(TypeTypeRef / \"name\", Const(Option(name))), child)))\n\n        case (TypeTypeRef, \"fields\", List(Binding(\"includeDeprecated\", BooleanValue(include)))) =>\n          Elab.transformChild(child => if (include) child else Filter(Eql(FieldTypeRef / \"isDeprecated\", Const(false)), child))\n        case (TypeTypeRef, \"enumValues\", List(Binding(\"includeDeprecated\", BooleanValue(include)))) =>\n          Elab.transformChild(child => if (include) child else Filter(Eql(EnumValueTypeRef / \"isDeprecated\", Const(false)), child))\n\n        case _ =>\n          Elab.unit\n      }\n\n    def elaborateFieldArgs(tpe: NamedType, field: Field, args: List[Binding]): Result[List[Binding]] = {\n      val infos = field.args\n      val unknownArgs = args.filterNot(arg => infos.exists(_.name == arg.name))\n      if (unknownArgs.nonEmpty)\n        Result.failure(s\"Unknown argument(s) ${unknownArgs.map(s => s\"'${s.name}'\").mkString(\"\", \", \", \"\")} in field ${field.name} of type ${tpe.name}\")\n      else {\n        val argMap = args.groupMapReduce(_.name)(_.value)((x, _) => x)\n        infos.traverse(info => checkValue(info, argMap.get(info.name), s\"field '${field.name}' of type '$tpe'\").map(v => Binding(info.name, v)))\n      }\n    }\n  }\n\n  object SelectElaborator {\n    /**\n     * Construct a `SelectElaborator` given a partial function which is called for each\n     * Select` node in the query.\n     */\n    def apply(sel: PartialFunction[(TypeRef, String, List[Binding]), Elab[Unit]]): SelectElaborator =\n      new SelectElaborator {\n        def select(ref: TypeRef, name: String, args: List[Binding], directives: List[Directive]): Elab[Unit] =\n          if(sel.isDefinedAt((ref, name, args))) sel((ref, name, args))\n          else Elab.unit\n      }\n\n    /** A select elaborator which discards all field arguments */\n    def identity: SelectElaborator = SelectElaborator(_ => Elab.unit)\n  }\n\n  /**\n   * A compiler phase which partitions a query for execution by multiple\n   * composed mappings.\n   *\n   * This phase transforms the input query by assigning subtrees to component\n   * mappings as specified by the supplied `cmapping`.\n   *\n   * The mapping has `Type` and field name pairs as keys and mapping and\n   * join function pairs as values. When the traversal of the input query\n   * visits a `Select` node with type `Type.field name` it will replace the\n   * `Select` with a `Component` node comprising,\n   *\n   * 1. the mapping which will be responsible for evaluating the subquery.\n   * 2. A join function which will be called during interpretation with,\n   *\n   *    i) The deferred subquery.\n   *    ii)  the cursor at that point in evaluation.\n   *\n   *    This join function is responsible for computing the continuation\n   *    query which will be evaluated by the responsible interpreter.\n   *\n   *    Because the join is provided with the cursor of the parent\n   *    interpreter the subquery can be parameterised with values derived\n   *    from the parent query.\n   */\n  class ComponentElaborator[F[_]] private (cmapping: Map[(Type, String), (Mapping[F], (Query, Cursor) => Result[Query])]) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@Select(fieldName, resultName, child) =>\n          for {\n            c        <- Elab.context\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Type ${c.tpe} is not an object or interface type\"))\n            childCtx =  c.forFieldOrAttribute(fieldName, resultName)\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            schema   <- Elab.schema\n            ref      =  schema.ref(obj.name)\n          } yield\n            cmapping.get((ref, fieldName)) match {\n              case Some((component, join)) =>\n                Component(component, join, s.copy(child = ec))\n              case None =>\n                s.copy(child = ec)\n            }\n\n        case _ => super.transform(query)\n      }\n  }\n\n  object ComponentElaborator {\n    val TrivialJoin = (q: Query, _: Cursor) => q.success\n\n    case class ComponentMapping[F[_]](tpe: TypeRef, fieldName: String, mapping: Mapping[F], join: (Query, Cursor) => Result[Query] = TrivialJoin)\n\n    def apply[F[_]](mappings: List[ComponentMapping[F]]): ComponentElaborator[F] =\n      new ComponentElaborator(mappings.map(m => ((m.tpe, m.fieldName), (m.mapping, m.join))).toMap)\n  }\n\n  /**\n   * A compiler phase which partitions a query for execution which may invoke\n   * multiple effect handlers.\n   *\n   * This phase transforms the input query by assigning subtrees to effect\n   * handlers as specified by the supplied `emapping`.\n   *\n   * The mapping has `Type` and field name pairs as keys and effect handlers\n   * as values. When the traversal of the input query visits a `Select` node\n   * with type `Type.field name` it will replace the\n   * `Select` with an `Effect` node comprising,\n   *\n   * 1. the effect handler which will be responsible for running the effect\n   *    and evaluating the subquery against its result.\n   * 2. the subquery which will be evaluated by the effect handler.\n   */\n  class EffectElaborator[F[_]] private (emapping: Map[(Type, String), EffectHandler[F]]) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      query match {\n        case s@Select(fieldName, resultName, child) =>\n          for {\n            c        <- Elab.context\n            obj      <- Elab.liftR(c.tpe.underlyingObject.toResultOrError(s\"Type ${c.tpe} is not an object or interface type\"))\n            childCtx =  c.forFieldOrAttribute(fieldName, resultName)\n            _        <- Elab.push(childCtx, child)\n            ec       <- transform(child)\n            _        <- Elab.pop\n            schema   <- Elab.schema\n            ref      =  schema.ref(obj.name)\n          } yield\n            emapping.get((ref, fieldName)) match {\n              case Some(handler) =>\n                Select(fieldName, resultName, Effect(handler, s.copy(child = ec)))\n              case None =>\n                s.copy(child = ec)\n            }\n\n        case _ => super.transform(query)\n      }\n  }\n\n  object EffectElaborator {\n    case class EffectMapping[F[_]](tpe: TypeRef, fieldName: String, handler: EffectHandler[F])\n\n    def apply[F[_]](mappings: List[EffectMapping[F]]): EffectElaborator[F] =\n      new EffectElaborator(mappings.map(m => ((m.tpe, m.fieldName), m.handler)).toMap)\n  }\n\n  /**\n    * A compiler phase which estimates the size of a query and applies width\n    * and depth limits.\n    */\n  class QuerySizeValidator(maxDepth: Int, maxWidth: Int) extends Phase {\n    override def transform(query: Query): Elab[Query] =\n      Elab.fragments.flatMap { frags =>\n        querySize(query, frags) match {\n          case (depth, _) if depth > maxDepth => Elab.failure(s\"Query is too deep: depth is $depth levels, maximum is $maxDepth\")\n          case (_, width) if width > maxWidth => Elab.failure(s\"Query is too wide: width is $width leaves, maximum is $maxWidth\")\n          case (depth, width) if depth > maxDepth && width > maxWidth => Elab.failure(s\"Query is too complex: width/depth is $width/$depth leaves/levels, maximum is $maxWidth/$maxDepth\")\n          case (_, _) => Elab.pure(query)\n        }\n      }\n\n    def querySize(query: Query, frags: Map[String, UntypedFragment]): (Int, Int) = {\n      def handleGroup(g: Group, depth: Int, width: Int): (Int, Int) = {\n        val dws = Query.ungroup(g).map(loop(_, depth, width))\n        val (depths, widths) = dws.unzip\n        (depths.max, widths.sum)\n      }\n\n      @tailrec\n      def loop(q: Query, depth: Int, width: Int): (Int, Int) =\n        q match {\n          case UntypedSelect(_, _, _, _, Empty) => (depth + 1, width + 1)\n          case Select(_, _, Empty) => (depth + 1, width + 1)\n          case Count(_) => (depth + 1, width + 1)\n          case UntypedSelect(_, _, _, _, child) => loop(child, depth + 1, width)\n          case Select(_, _, child) => loop(child, depth + 1, width)\n          case g: Group => handleGroup(g, depth, width)\n          case Component(_, _, child) => loop(child, depth, width)\n          case Effect(_, child) => loop(child, depth, width)\n          case Environment(_, child) => loop(child, depth, width)\n          case Empty => (depth, width)\n          case Filter(_, child) => loop(child, depth, width)\n          case Introspect(_, _) => (depth, width)\n          case Limit(_, child) => loop(child, depth, width)\n          case Offset(_, child) => loop(child, depth, width)\n          case Narrow(_, child) => loop(child, depth, width)\n          case OrderBy(_, child) => loop(child, depth, width)\n          case TransformCursor(_, child) => loop(child, depth, width)\n          case Unique(child) => loop(child, depth, width)\n          case UntypedFragmentSpread(nme, _) =>\n            frags.get(nme) match {\n              case Some(frag) => loop(frag.child, depth, width)\n              case None => (depth, width)\n            }\n          case UntypedInlineFragment(_, _, child) => loop(child, depth, width)\n        }\n\n      loop(query, 0, 0)\n    }\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport scala.collection.Factory\nimport scala.reflect.ClassTag\n\nimport cats.MonadThrow\nimport cats.data.Chain\nimport cats.implicits._\nimport fs2.{ Stream, Compiler }\nimport io.circe.{Encoder, Json}\nimport io.circe.syntax._\nimport org.tpolecat.sourcepos.SourcePos\nimport org.tpolecat.typename._\n\nimport syntax._\nimport Cursor.{AbstractCursor, ProxyCursor}\nimport Query.EffectHandler\nimport QueryCompiler.{ComponentElaborator, EffectElaborator, IntrospectionLevel, SelectElaborator}\nimport QueryInterpreter.ProtoJson\nimport IntrospectionLevel._\n\n/**\n * Represents a mapping between a GraphQL schema and an underlying abstract data source.\n */\nabstract class Mapping[F[_]] {\n  implicit val M: MonadThrow[F]\n  val schema: Schema\n  val typeMappings: List[TypeMapping]\n\n  /**\n    * Compile and run a single GraphQL query or mutation.\n    *\n    * Yields a JSON response containing the result of the query or mutation.\n    */\n  def compileAndRun(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty)(\n    implicit sc: Compiler[F,F]\n  ): F[Json] =\n    compileAndRunSubscription(text, name, untypedVars, introspectionLevel, reportUnused, env).compile.toList.flatMap {\n      case List(j) => j.pure[F]\n      case Nil     => M.raiseError(new IllegalStateException(\"Result stream was empty.\"))\n      case js      => M.raiseError(new IllegalStateException(s\"Result stream contained ${js.length} results; expected exactly one.\"))\n    }\n\n  /**\n   * Compile and run a GraphQL subscription.\n   *\n   * Yields a stream of JSON responses containing the results of the subscription.\n   */\n  def compileAndRunSubscription(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty): Stream[F,Json] = {\n    val compiled = compiler.compile(text, name, untypedVars, introspectionLevel, reportUnused, env)\n    Stream.eval(compiled.pure[F]).flatMap(_.flatTraverse(op => interpreter.run(op.query, op.rootTpe, env))).evalMap(mkResponse)\n  }\n\n  /** Combine and execute multiple queries.\n   *\n   *  Each query is interpreted in the context of the Cursor it is\n   *  paired with. The result list is aligned with the argument\n   *  query list. For each query at most one stage will be run and the\n   *  corresponding result may contain deferred components.\n   *\n   *  Errors are aggregated across all the argument queries and are\n   *  accumulated on the `Left` of the result.\n   *\n   *  This method is typically called at the end of a stage to evaluate\n   *  deferred subqueries in the result of that stage. These will be\n   *  grouped by and passed jointly to the responsible mapping in\n   *  the next stage using this method. Maappongs which are able\n   *  to benefit from combining queries may do so by overriding this\n   *  method to implement their specific combinging logic.\n   */\n  def combineAndRun(queries: List[(Query, Cursor)]): F[Result[List[ProtoJson]]] =\n    queries.map { case (q, c) => (q, schema.queryType, c) }.traverse((interpreter.runOneShot _).tupled).map(ProtoJson.combineResults)\n\n  /** Yields a `Cursor` focused on the top level operation type of the query */\n  def defaultRootCursor(query: Query, tpe: Type, parentCursor: Option[Cursor]): F[Result[(Query, Cursor)]] =\n    Result((query, RootCursor(Context(tpe), parentCursor, Env.empty))).pure[F].widen\n\n  /**\n   * Root `Cursor` focussed on the top level operation of a query\n   *\n   * Construction of mapping-specific cursors is handled by delegation to\n   * `mkCursorForField which is typically overridden in `Mapping` subtypes.\n   */\n  case class RootCursor(context: Context, parent: Option[Cursor], env: Env) extends AbstractCursor {\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    def focus: Any = ()\n\n    override def hasField(fieldName: String): Boolean =\n      fieldMapping(context, fieldName).isDefined\n\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      mkCursorForField(this, fieldName, resultName)\n  }\n\n  /**\n    * Yields a `Cursor` suitable for traversing the query result corresponding to\n    * the `fieldName` child of `parent`.\n    *\n    * This method is typically overridden in and delegated to by `Mapping` subtypes.\n    */\n  def mkCursorForField(parent: Cursor, fieldName: String, resultName: Option[String]): Result[Cursor] = {\n    val context = parent.context\n    val fieldContext = context.forFieldOrAttribute(fieldName, resultName)\n\n    def mkLeafCursor(focus: Any): Result[Cursor] =\n      LeafCursor(fieldContext, focus, Some(parent), parent.env).success\n\n    fieldMapping(context, fieldName) match {\n      case Some(_ : EffectMapping) =>\n        mkLeafCursor(parent.focus)\n      case Some(CursorField(_, f, _, _, _)) =>\n        f(parent).flatMap(res => mkLeafCursor(res))\n      case _ =>\n        Result.failure(s\"No field '$fieldName' for type ${parent.tpe}\")\n    }\n  }\n\n  /** Yields the `TypeMapping` associated with the provided type, if any. */\n  def typeMapping(tpe: NamedType): Option[TypeMapping] =\n    typeMappingIndex.get(tpe.name)\n\n  private lazy val typeMappingIndex =\n    typeMappings.flatMap(tm => tm.tpe.asNamed.map(tpe => (tpe.name, tm)).toList).toMap\n\n  val validator: MappingValidator =\n    MappingValidator(this)\n\n  /** Yields the `ObjectMapping` associated with the provided context, if any. */\n  def objectMapping(context: Context): Option[ObjectMapping] =\n    context.tpe.underlyingObject.flatMap { obj =>\n      obj.asNamed.flatMap(typeMapping) match {\n        case Some(om: ObjectMapping) => Some(om)\n        case Some(pm: PrefixedMapping) =>\n          val revPath = context.path.reverse\n          pm.mappings.filter(m => revPath.endsWith(m._1)).maxByOption(_._1.length).map(_._2)\n        case _ => None\n      }\n    }\n\n  /** Yields the `FieldMapping` associated with `fieldName` in `context`, if any. */\n  def fieldMapping(context: Context, fieldName: String): Option[FieldMapping] =\n    objectMapping(context).flatMap(_.fieldMapping(fieldName)).orElse {\n      context.tpe.underlyingObject match {\n        case Some(ot: ObjectType) =>\n          ot.interfaces.collectFirstSome(nt => fieldMapping(context.asType(nt), fieldName))\n        case _ => None\n      }\n    }\n\n  /** Yields the `RootEffect`, if any, associated with `fieldName`. */\n  def rootEffect(context: Context, fieldName: String): Option[RootEffect] =\n    fieldMapping(context, fieldName).collect {\n      case re: RootEffect => re\n    }\n\n  /** Yields the `RootStream`, if any, associated with `fieldName`. */\n  def rootStream(context: Context, fieldName: String): Option[RootStream] =\n    fieldMapping(context, fieldName).collect {\n      case rs: RootStream => rs\n    }\n\n  /** Yields the `LeafMapping` associated with the provided type, if any. */\n  def leafMapping[T](tpe: Type): Option[LeafMapping[T]] =\n    typeMappings.collectFirst {\n      case lm@LeafMapping(tpe0, _) if tpe0 =:= tpe => lm.asInstanceOf[LeafMapping[T]]\n    }\n\n  /**\n   * True if the supplied type is a leaf with respect to the GraphQL schema\n   * or mapping, false otherwise.\n   */\n  def isLeaf(tpe: Type): Boolean = tpe.underlying match {\n    case (_: ScalarType)|(_: EnumType) => true\n    case tpe => leafMapping(tpe).isDefined\n  }\n\n  /** Yields the `Encoder` associated with the provided type, if any. */\n  def encoderForLeaf(tpe: Type): Option[Encoder[Any]] =\n    encoderMemo.get(tpe.dealias)\n\n  private lazy val encoderMemo: scala.collection.immutable.Map[Type, Encoder[Any]] = {\n    val intTypeEncoder: Encoder[Any] =\n      new Encoder[Any] {\n        def apply(i: Any): Json = (i: @unchecked) match {\n          case i: Int => Json.fromInt(i)\n          case l: Long => Json.fromLong(l)\n        }\n      }\n\n    val floatTypeEncoder: Encoder[Any] =\n      new Encoder[Any] {\n        def apply(f: Any): Json = (f: @unchecked) match {\n          case f: Float => Json.fromFloatOrString(f)\n          case d: Double => Json.fromDoubleOrString(d)\n          case d: BigDecimal => Json.fromBigDecimal(d)\n        }\n      }\n\n    val definedEncoders: List[(Type, Encoder[Any])] =\n      typeMappings.collect { case lm: LeafMapping[_] => (lm.tpe.dealias -> lm.encoder.asInstanceOf[Encoder[Any]]) }\n\n    val defaultEncoders: List[(Type, Encoder[Any])] =\n      List(\n        ScalarType.StringType -> Encoder[String].asInstanceOf[Encoder[Any]],\n        ScalarType.IntType -> intTypeEncoder,\n        ScalarType.FloatType -> floatTypeEncoder,\n        ScalarType.BooleanType -> Encoder[Boolean].asInstanceOf[Encoder[Any]],\n        ScalarType.IDType -> Encoder[String].asInstanceOf[Encoder[Any]]\n      )\n\n    (definedEncoders ++ defaultEncoders).toMap\n  }\n\n  trait TypeMapping extends Product with Serializable {\n    def tpe: Type\n    def pos: SourcePos\n  }\n\n  case class PrimitiveMapping(tpe: Type)(implicit val pos: SourcePos) extends TypeMapping\n\n  abstract class ObjectMapping extends TypeMapping {\n    private lazy val fieldMappingIndex = fieldMappings.map(fm => (fm.fieldName, fm)).toMap\n\n    def fieldMappings: List[FieldMapping]\n    def fieldMapping(fieldName: String): Option[FieldMapping] = fieldMappingIndex.get(fieldName)\n  }\n\n  object ObjectMapping {\n\n    case class DefaultObjectMapping(tpe: Type, fieldMappings: List[FieldMapping])(\n      implicit val pos: SourcePos\n    ) extends ObjectMapping\n\n    def apply(tpe: Type, fieldMappings: List[FieldMapping])(\n      implicit pos: SourcePos\n    ): ObjectMapping =\n      DefaultObjectMapping(tpe, fieldMappings.map(_.withParent(tpe)))\n  }\n\n  case class PrefixedMapping(tpe: Type, mappings: List[(List[String], ObjectMapping)])(\n    implicit val pos: SourcePos\n  ) extends TypeMapping\n\n  trait FieldMapping extends Product with Serializable {\n    def fieldName: String\n    def hidden: Boolean\n    def withParent(tpe: Type): FieldMapping\n    def pos: SourcePos\n  }\n\n  case class PrimitiveField(fieldName: String, hidden: Boolean = false)(implicit val pos: SourcePos) extends FieldMapping {\n    def withParent(tpe: Type): PrimitiveField = this\n  }\n\n  /**\n    * Abstract type of field mappings with effects.\n    */\n  trait EffectMapping extends FieldMapping\n\n  case class EffectField(fieldName: String, handler: EffectHandler[F], required: List[String] = Nil, hidden: Boolean = false)(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def withParent(tpe: Type): EffectField = this\n  }\n\n  /**\n   * Root effects can perform an intial effect prior to computing the resulting\n   * `Cursor` and effective `Query`.\n   *\n   * These effects are used to perform initial effectful setup for a query or to\n   * perform the effect associated with a GraphQL mutation. Convenience methods\n   * are provided to cover the cases where only one of the query or the cursor\n   * are computed.\n   *\n   * If only the query is computed the default root cursor for the mapping will\n   * be used. If only the cursor is computed the client query (after elaboration)\n   * is used unmodified ... in this case results of the performed effect can only\n   * be passed to the result construction stage via the environment associated\n   * with the returned cursor.\n   */\n  case class RootEffect private (fieldName: String, effect: (Query, Path, Env) => F[Result[(Query, Cursor)]])(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def hidden = false\n    def withParent(tpe: Type): RootEffect = this\n    def toRootStream: RootStream = RootStream(fieldName)((q, p, e) => Stream.eval(effect(q, p, e)))\n  }\n\n  object RootEffect {\n    /**\n     * Yields a `RootEffect` which performs both an initial effect and yields an effect-specific query and\n     * corresponding root cursor.\n     */\n    def apply(fieldName: String)(effect: (Query, Path, Env) => F[Result[(Query, Cursor)]])(implicit pos: SourcePos, di: DummyImplicit): RootEffect =\n      new RootEffect(fieldName, effect)\n\n    /**\n     * Yields a `RootEffect` which performs an initial effect which leaves the query and default root cursor\n     * unchanged.\n     */\n    def computeUnit(fieldName: String)(effect: Env => F[Result[Unit]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) =>\n          (for {\n            _  <- ResultT(effect(env))\n            qc <- ResultT(defaultRootCursor(query, path.rootTpe, None))\n          } yield qc.map(_.withEnv(env))).value\n      )\n\n    /**\n      * Yields a `RootEffect` which performs an initial effect and yields an effect-specific root cursor.\n      */\n    def computeCursor(fieldName: String)(effect: (Path, Env) => F[Result[Cursor]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) => effect(path, env).map(_.map(c => (query, c)))\n      )\n\n    /**\n      * Yields a `RootEffect` which performs an initial effect and yields an effect-specific query\n      * which is executed with respect to the default root cursor for the corresponding `Mapping`.\n      */\n    def computeChild(fieldName: String)(effect: (Query, Path, Env) => F[Result[Query]])(implicit pos: SourcePos): RootEffect =\n      new RootEffect(\n        fieldName,\n        (query, path, env) =>\n          (for {\n            child <- ResultT(Query.extractChild(query).toResultOrError(\"Root query has unexpected shape\").pure[F])\n            q     <- ResultT(effect(child, path, env).map(_.flatMap(Query.substChild(query, _).toResultOrError(\"Root query has unexpected shape\"))))\n            qc    <- ResultT(defaultRootCursor(q, path.rootTpe, None))\n          } yield qc.map(_.withEnv(env))).value\n      )\n  }\n\n  /**\n   * Root streams can perform an intial effect prior to emitting the resulting\n   * cursors and effective queries.\n   *\n   * Stream effects are used for GraphQL subscriptions. Convenience methods are\n   * provided to cover the cases where only one of the query or the cursor are\n   * computed\n   *\n   * If only the query is computed the default root cursor for the mapping will\n   * be used. If only the cursor is computed the client query (after elaboration)\n   * is used unmodified ... in this case results of the performed effect can only\n   * be passed to the result construction stage via the environment associated\n   * with the returned cursor.\n   */\n  case class RootStream private (fieldName: String, effect: (Query, Path, Env) => Stream[F, Result[(Query, Cursor)]])(implicit val pos: SourcePos)\n    extends EffectMapping {\n    def hidden = false\n    def withParent(tpe: Type): RootStream = this\n  }\n\n  object RootStream {\n    /**\n     * Yields a `RootStream` which performs both an initial effect and yields an effect-specific query and\n     * corresponding root cursor.\n     */\n    def apply(fieldName: String)(effect: (Query, Path, Env) => Stream[F, Result[(Query, Cursor)]])(implicit pos: SourcePos, di: DummyImplicit): RootStream =\n      new RootStream(fieldName, effect)\n\n    /**\n      * Yields a `RootStream` which yields a stream of effect-specific root cursors.\n      *\n      * This form of effect is typically used to implement GraphQL subscriptions.\n      */\n    def computeCursor(fieldName: String)(effect: (Path, Env) => Stream[F, Result[Cursor]])(implicit pos: SourcePos): RootStream =\n      new RootStream(\n        fieldName,\n        (query, path, env) => effect(path, env).map(_.map(c => (query, c)))\n      )\n\n    /**\n      * Yields a `RootStream` which yields a stream of effect-specific queries\n      * which are executed with respect to the default root cursor for the\n      * corresponding `Mapping`.\n      *\n      * This form of effect is typically used to implement GraphQL subscriptions.\n      */\n    def computeChild(fieldName: String)(effect: (Query, Path, Env) => Stream[F, Result[Query]])(implicit pos: SourcePos): RootStream =\n      new RootStream(\n        fieldName,\n        (query, path, env) =>\n          Query.extractChild(query).fold(Stream.emit[F, Result[(Query, Cursor)]](Result.internalError(\"Root query has unexpected shape\"))) { child =>\n            effect(child, path, env).flatMap(child0 =>\n              Stream.eval(\n                (for {\n                  q  <- ResultT(child0.flatMap(Query.substChild(query, _).toResultOrError(\"Root query has unexpected shape\")).pure[F])\n                  qc <- ResultT(defaultRootCursor(q, path.rootTpe, None))\n                } yield qc.map(_.withEnv(env))).value\n              )\n            )\n          }\n      )\n  }\n\n  trait LeafMapping[T] extends TypeMapping {\n    def tpe: Type\n    def encoder: Encoder[T]\n    def scalaTypeName: String\n    def pos: SourcePos\n  }\n  object LeafMapping {\n\n    case class DefaultLeafMapping[T](tpe: Type, encoder: Encoder[T], scalaTypeName: String)(\n      implicit val pos: SourcePos\n    ) extends LeafMapping[T]\n\n    def apply[T: TypeName](tpe: Type)(implicit encoder: Encoder[T], pos: SourcePos): LeafMapping[T] =\n      DefaultLeafMapping(tpe, encoder, typeName)\n\n    def unapply[T](lm: LeafMapping[T]): Option[(Type, Encoder[T])] =\n      Some((lm.tpe, lm.encoder))\n  }\n\n  case class CursorField[T](fieldName: String, f: Cursor => Result[T], encoder: Encoder[T], required: List[String], hidden: Boolean)(\n    implicit val pos: SourcePos\n  ) extends FieldMapping {\n    def withParent(tpe: Type): CursorField[T] = this\n  }\n  object CursorField {\n    def apply[T](fieldName: String, f: Cursor => Result[T], required: List[String] = Nil, hidden: Boolean = false)(implicit encoder: Encoder[T], di: DummyImplicit): CursorField[T] =\n      new CursorField(fieldName, f, encoder, required, hidden)\n  }\n\n  case class Delegate(\n    fieldName: String,\n    mapping: Mapping[F],\n    join: (Query, Cursor) => Result[Query] = ComponentElaborator.TrivialJoin\n  )(implicit val pos: SourcePos) extends FieldMapping {\n    def hidden = false\n    def withParent(tpe: Type): Delegate = this\n  }\n\n  val selectElaborator: SelectElaborator = SelectElaborator.identity\n\n  lazy val componentElaborator = {\n    val componentMappings =\n      typeMappings.flatMap {\n        case om: ObjectMapping =>\n          om.fieldMappings.collect {\n            case Delegate(fieldName, mapping, join) =>\n              ComponentElaborator.ComponentMapping(schema.ref(om.tpe.toString), fieldName, mapping, join)\n          }\n        case _ => Nil\n      }\n\n    ComponentElaborator(componentMappings)\n  }\n\n  lazy val effectElaborator = {\n    val effectMappings =\n      typeMappings.flatMap {\n        case om: ObjectMapping =>\n          om.fieldMappings.collect {\n            case EffectField(fieldName, handler, _, _) =>\n              EffectElaborator.EffectMapping(schema.ref(om.tpe.toString), fieldName, handler)\n          }\n        case _ => Nil\n      }\n\n    EffectElaborator(effectMappings)\n  }\n\n  def compilerPhases: List[QueryCompiler.Phase] = List(selectElaborator, componentElaborator, effectElaborator)\n\n  def parserConfig: GraphQLParser.Config = GraphQLParser.defaultConfig\n  lazy val graphQLParser: GraphQLParser = GraphQLParser(parserConfig)\n  lazy val queryParser: QueryParser = QueryParser(graphQLParser)\n\n  lazy val compiler: QueryCompiler = new QueryCompiler(queryParser, schema, compilerPhases)\n\n  val interpreter: QueryInterpreter[F] = new QueryInterpreter(this)\n\n  /** Cursor positioned at a GraphQL result leaf */\n  case class LeafCursor(context: Context, focus: Any, parent: Option[Cursor], env: Env) extends Cursor {\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    def mkChild(context: Context = context, focus: Any = focus): LeafCursor =\n      LeafCursor(context, focus, Some(this), Env.empty)\n\n    def isLeaf: Boolean = tpe.isLeaf\n\n    def asLeaf: Result[Json] =\n      encoderForLeaf(tpe).map(enc => enc(focus).success).getOrElse(Result.internalError(\n        s\"Cannot encode value $focus at ${context.path.reverse.mkString(\"/\")} (of GraphQL type ${context.tpe}). Did you forget a LeafMapping?\".stripMargin.trim\n      ))\n\n    def preunique: Result[Cursor] = {\n      val listTpe = tpe.nonNull.list\n      focus match {\n        case _: List[_] => mkChild(context.asType(listTpe), focus).success\n        case _ =>\n          Result.internalError(s\"Expected List type, found $focus for ${listTpe}\")\n      }\n    }\n\n    def isList: Boolean =\n      tpe match {\n        case ListType(_) => true\n        case _ => false\n      }\n\n    def asList[C](factory: Factory[Cursor, C]): Result[C] = (tpe, focus) match {\n      case (ListType(tpe), it: List[_]) => it.view.map(f => mkChild(context.asType(tpe), focus = f)).to(factory).success\n      case _ => Result.internalError(s\"Expected List type, found $tpe\")\n    }\n\n    def listSize: Result[Int] = (tpe, focus) match {\n      case (ListType(_), it: List[_]) => it.size.success\n      case _ => Result.internalError(s\"Expected List type, found $tpe\")\n    }\n\n    def isNullable: Boolean =\n      tpe match {\n        case NullableType(_) => true\n        case _ => false\n      }\n\n    def asNullable: Result[Option[Cursor]] =\n      (tpe, focus) match {\n        case (NullableType(_), None) => None.success\n        case (NullableType(tpe), Some(v)) => Some(mkChild(context.asType(tpe), focus = v)).success\n        case _ => Result.internalError(s\"Not nullable at ${context.path}\")\n      }\n\n    def isDefined: Result[Boolean] =\n      (tpe, focus) match {\n        case (NullableType(_), opt: Option[_]) => opt.isDefined.success\n        case _ => Result.internalError(s\"Not nullable at ${context.path}\")\n      }\n\n    def narrowsTo(subtpe: TypeRef): Boolean = false\n    def narrow(subtpe: TypeRef): Result[Cursor] =\n      Result.failure(s\"Cannot narrow $tpe to $subtpe\")\n\n    def hasField(fieldName: String): Boolean = false\n    def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      Result.failure(s\"Cannot select field '$fieldName' from leaf type $tpe\")\n  }\n\n  /**\n   * Proxy `Cursor` which applies a function to the focus of an underlying `LeafCursor`.\n   */\n  case class FieldTransformCursor[T : ClassTag : TypeName](underlying: Cursor, f: T => Result[T]) extends ProxyCursor(underlying) {\n    override def withEnv(env: Env): Cursor = new FieldTransformCursor(underlying.withEnv(env), f)\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      underlying.field(fieldName, resultName).flatMap {\n        case l: LeafCursor =>\n          for {\n            focus  <- l.as[T]\n            ffocus <- f(focus)\n          } yield l.copy(focus = ffocus)\n        case _ =>\n          Result.internalError(s\"Expected leaf cursor for field $fieldName\")\n      }\n  }\n\n  /**\n   * Construct a GraphQL response from the possibly absent result `data`\n   * and a collection of errors.\n   */\n  def mkResponse(data: Option[Json], errors: Chain[Problem]): Json = {\n    val dataField = data.map { value => (\"data\", value) }.toList\n    val fields =\n      (dataField, errors.toList) match {\n        case (Nil, Nil)   => List((\"errors\", Json.fromValues(List(Problem(\"Invalid query\").asJson))))\n        case (data, Nil)  => data\n        case (data, errs) => (\"errors\", errs.asJson) :: data\n      }\n    Json.fromFields(fields)\n  }\n\n  /** Construct a GraphQL response from a `Result`. */\n  def mkResponse(result: Result[Json]): F[Json] =\n    result match {\n      case Result.InternalError(err) => M.raiseError(err)\n      case _ => mkResponse(result.toOption, result.toProblems).pure[F]\n    }\n}\n\nabstract class ComposedMapping[F[_]](implicit val M: MonadThrow[F]) extends Mapping[F] {\n  override def mkCursorForField(parent: Cursor, fieldName: String, resultName: Option[String]): Result[Cursor] = {\n    val context = parent.context\n    val fieldContext = context.forFieldOrAttribute(fieldName, resultName)\n    fieldMapping(context, fieldName) match {\n      case Some(_) =>\n        ComposedCursor(fieldContext, parent.env).success\n      case _ =>\n        super.mkCursorForField(parent, fieldName, resultName)\n    }\n  }\n\n  case class ComposedCursor(context: Context, env: Env) extends AbstractCursor {\n    val focus = null\n    val parent = None\n\n    def withEnv(env0: Env): Cursor = copy(env = env.add(env0))\n\n    override def hasField(fieldName: String): Boolean =\n      fieldMapping(context, fieldName).isDefined\n\n    override def field(fieldName: String, resultName: Option[String]): Result[Cursor] =\n      mkCursorForField(this, fieldName, resultName)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\ntrait QueryMinimizer {\n  def minimizeText(text: String): Result[String]\n  def minimizeDocument(doc: Ast.Document): String\n}\n\nobject QueryMinimizer {\n  def apply(parser: GraphQLParser): QueryMinimizer =\n    new Impl(parser)\n\n  private final class Impl(parser: GraphQLParser) extends QueryMinimizer {\n    import Ast._\n\n    def minimizeText(text: String): Result[String] =\n      for {\n        doc <- parser.parseText(text)\n      } yield minimizeDocument(doc)\n\n    def minimizeDocument(doc: Document): String = {\n      import OperationDefinition._\n      import OperationType._\n      import Selection._\n      import Value._\n\n      def renderDefinition(defn: Definition): String =\n        defn match {\n          case e: ExecutableDefinition => renderExecutableDefinition(e)\n          case _ => \"\"\n        }\n\n      def renderExecutableDefinition(ex: ExecutableDefinition): String =\n        ex match {\n          case op: OperationDefinition => renderOperationDefinition(op)\n          case frag: FragmentDefinition => renderFragmentDefinition(frag)\n        }\n\n      def renderOperationDefinition(op: OperationDefinition): String =\n        op match {\n          case qs: QueryShorthand => renderSelectionSet(qs.selectionSet)\n          case op: Operation => renderOperation(op)\n        }\n\n      def renderOperation(op: Operation): String =\n        renderOperationType(op.operationType) +\n        op.name.map(nme => s\" ${nme.value}\").getOrElse(\"\") +\n        renderVariableDefns(op.variables)+\n        renderDirectives(op.directives)+\n        renderSelectionSet(op.selectionSet)\n\n      def renderOperationType(op: OperationType): String =\n        op match {\n          case Query => \"query\"\n          case Mutation => \"mutation\"\n          case Subscription => \"subscription\"\n        }\n\n      def renderDirectives(dirs: List[Directive]): String =\n        dirs.map { case Directive(name, args) => s\"@${name.value}${renderArguments(args)}\" }.mkString(\"\")\n\n      def renderVariableDefns(vars: List[VariableDefinition]): String =\n        vars match {\n          case Nil => \"\"\n          case _ =>\n            vars.map {\n              case VariableDefinition(name, tpe, default, dirs) =>\n                s\"$$${name.value}:${tpe.name}${default.map(v => s\"=${renderValue(v)}\").getOrElse(\"\")}${renderDirectives(dirs)}\"\n            }.mkString(\"(\", \",\", \")\")\n        }\n\n      def renderSelectionSet(sels: List[Selection]): String =\n        sels match {\n          case Nil => \"\"\n          case _ => sels.map(renderSelection).mkString(\"{\", \",\", \"}\")\n        }\n\n      def renderSelection(sel: Selection): String =\n        sel match {\n          case f: Field => renderField(f)\n          case s: FragmentSpread => renderFragmentSpread(s)\n          case i: InlineFragment => renderInlineFragment(i)\n        }\n\n      def renderField(f: Field) = {\n        f.alias.map(a => s\"${a.value}:\").getOrElse(\"\")+\n        f.name.value+\n        renderArguments(f.arguments)+\n        renderDirectives(f.directives)+\n        renderSelectionSet(f.selectionSet)\n      }\n\n      def renderArguments(args: List[(Name, Value)]): String =\n        args match {\n          case Nil => \"\"\n          case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"(\", \",\", \")\")\n        }\n\n      def renderInputObject(args: List[(Name, Value)]): String =\n        args match {\n          case Nil => \"\"\n          case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"{\", \",\", \"}\")\n        }\n\n      def renderTypeCondition(tpe: Type): String =\n        s\"on ${tpe.name}\"\n\n      def renderFragmentDefinition(frag: FragmentDefinition): String =\n        s\"fragment ${frag.name.value} ${renderTypeCondition(frag.typeCondition)}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n\n      def renderFragmentSpread(spread: FragmentSpread): String =\n        s\"...${spread.name.value}${renderDirectives(spread.directives)}\"\n\n      def renderInlineFragment(frag: InlineFragment): String =\n        s\"...${frag.typeCondition.map(renderTypeCondition).getOrElse(\"\")}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n\n      def renderValue(v: Value): String =\n        v match {\n          case Variable(name) => s\"$$${name.value}\"\n          case IntValue(value) => value.toString\n          case FloatValue(value) => value.toString\n          case StringValue(value) => s\"\"\"\"$value\"\"\"\"\n          case BooleanValue(value) => value.toString\n          case NullValue => \"null\"\n          case EnumValue(name) => name.value\n          case ListValue(values) => values.map(renderValue).mkString(\"[\", \",\", \"]\")\n          case ObjectValue(fields) => renderInputObject(fields)\n        }\n\n      doc.map(renderDefinition).mkString(\",\")\n    }\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport scala.util.matching.Regex\n\nimport cats.implicits._\nimport cats.parse.{Parser, Parser0}\nimport cats.parse.Parser._\nimport cats.parse.Numbers._\nimport cats.parse.Rfc5234.{cr, crlf, digit, hexdig, lf}\n\ntrait GraphQLParser {\n  def parseText(text: String): Result[Ast.Document]\n}\n\nobject GraphQLParser {\n  case class Config(\n    maxSelectionDepth: Int,\n    maxSelectionWidth: Int,\n    maxInputValueDepth: Int,\n    maxListTypeDepth: Int,\n    terseError: Boolean\n  )\n\n  val defaultConfig: Config =\n    Config(\n      maxSelectionDepth = 100,\n      maxSelectionWidth = 1000,\n      maxInputValueDepth = 5,\n      maxListTypeDepth = 5,\n      terseError = true\n    )\n\n  def apply(config: Config): GraphQLParser =\n    new Impl(config)\n\n  def toResult[T](pr: Either[Parser.Error, T]): Result[T] =\n    Result.fromEither(pr.leftMap(_.show))\n\n  def toResultTerseError[T](pr: Either[Parser.Error, T]): Result[T] =\n    Result.fromEither(pr.leftMap(_.copy().show))\n\n  import CommentedText._\n  import Literals._\n\n  private final class Impl(config: Config) extends GraphQLParser {\n    import config._\n\n    def parseText(text: String): Result[Ast.Document] = {\n      val res = Document.parseAll(text)\n      if (config.terseError) toResultTerseError(res) else toResult(res)\n    }\n\n    val nameInitial    = ('A' to 'Z') ++ ('a' to 'z') ++ Seq('_')\n    val nameSubsequent = nameInitial ++ ('0' to '9')\n\n    def keyword(s: String) = token(string(s) <* not(charIn(nameSubsequent)))\n\n    def punctuation(s: String) = token(string(s))\n\n    lazy val Document: Parser0[Ast.Document] =\n      (whitespace.void | comment).rep0 *> Definition.rep0 <* Parser.end\n\n    lazy val Definition: Parser[Ast.Definition] =\n      ExecutableDefinition | TypeSystemDefinition | TypeSystemExtension\n\n    lazy val TypeSystemDefinition: Parser[Ast.TypeSystemDefinition] = {\n      val SchemaDefinition: Parser[Ast.SchemaDefinition] =\n        ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0)).map {\n          case (dirs, rootdefs) => Ast.SchemaDefinition(rootdefs, dirs.getOrElse(Nil))\n        }\n\n      def typeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.TypeDefinition] = {\n\n        def scalarTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ScalarTypeDefinition] =\n          ((keyword(\"scalar\") *> Name) ~ Directives.?).map {\n            case (name, dirs) => Ast.ScalarTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n          }\n\n        def objectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ObjectTypeDefinition] =\n          ((keyword(\"type\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n            case (((name, ifs), dirs), fields) => Ast.ObjectTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n          }\n\n        def interfaceTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InterfaceTypeDefinition] =\n          ((keyword(\"interface\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n            case (((name, ifs), dirs), fields) => Ast.InterfaceTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n          }\n\n        def unionTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.UnionTypeDefinition] =\n          ((keyword(\"union\") *> Name) ~ Directives.? ~ UnionMemberTypes).map {\n            case ((name, dirs), members) => Ast.UnionTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), members)\n          }\n\n        def enumTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.EnumTypeDefinition] =\n          ((keyword(\"enum\") *> Name) ~ Directives.? ~ EnumValuesDefinition).map {\n            case ((name, dirs), values) => Ast.EnumTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), values)\n          }\n\n        def inputObjectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InputObjectTypeDefinition] =\n          ((keyword(\"input\") *> Name) ~ Directives.? ~ InputFieldsDefinition).map {\n            case ((name, dirs), fields) => Ast.InputObjectTypeDefinition(name, desc.map(_.value), fields, dirs.getOrElse(Nil))\n          }\n\n        scalarTypeDefinition(desc)|\n          objectTypeDefinition(desc) |\n          interfaceTypeDefinition(desc) |\n          unionTypeDefinition(desc) |\n          enumTypeDefinition(desc) |\n          inputObjectTypeDefinition(desc)\n      }\n\n      def directiveDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.DirectiveDefinition] =\n        ((keyword(\"directive\") *> punctuation(\"@\") *> Name) ~\n          ArgumentsDefinition.? ~ (keyword(\"repeatable\").? <* keyword(\"on\")) ~ DirectiveLocations).map {\n          case (((name, args), rpt), locs) => Ast.DirectiveDefinition(name, desc.map(_.value), args.getOrElse(Nil), rpt.isDefined, locs)\n        }\n\n      SchemaDefinition |\n        Description.?.with1.flatMap { desc =>\n          typeDefinition(desc) | directiveDefinition(desc)\n        }\n    }\n\n    lazy val TypeSystemExtension: Parser[Ast.TypeSystemExtension] = {\n\n      val SchemaExtension: Parser[Ast.SchemaExtension] =\n        ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0).?).map {\n          case (dirs, rootdefs) => Ast.SchemaExtension(rootdefs.getOrElse(Nil), dirs.getOrElse(Nil))\n        }\n\n      val TypeExtension: Parser[Ast.TypeExtension] = {\n\n        val ScalarTypeExtension: Parser[Ast.ScalarTypeExtension] =\n          ((keyword(\"scalar\") *> NamedType) ~ Directives.?).map {\n            case (((name), dirs)) => Ast.ScalarTypeExtension(name, dirs.getOrElse(Nil))\n          }\n\n        val ObjectTypeExtension: Parser[Ast.ObjectTypeExtension] =\n          ((keyword(\"type\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n            case (((name, ifs), dirs), fields) => Ast.ObjectTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n          }\n\n        val InterfaceTypeExtension: Parser[Ast.InterfaceTypeExtension] =\n          ((keyword(\"interface\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n            case (((name, ifs), dirs), fields) => Ast.InterfaceTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n          }\n\n        val UnionTypeExtension: Parser[Ast.UnionTypeExtension] =\n          ((keyword(\"union\") *> NamedType) ~ Directives.? ~ UnionMemberTypes.?).map {\n            case (((name), dirs), members) => Ast.UnionTypeExtension(name, dirs.getOrElse(Nil), members.getOrElse(Nil))\n          }\n\n        val EnumTypeExtension: Parser[Ast.EnumTypeExtension] =\n          ((keyword(\"enum\") *> NamedType) ~ Directives.? ~ EnumValuesDefinition.?).map {\n            case (((name), dirs), values) => Ast.EnumTypeExtension(name, dirs.getOrElse(Nil), values.getOrElse(Nil))\n          }\n\n        val InputObjectTypeExtension: Parser[Ast.InputObjectTypeExtension] =\n          ((keyword(\"input\") *> NamedType) ~ Directives.? ~ InputFieldsDefinition.?).map {\n            case (((name), dirs), fields) => Ast.InputObjectTypeExtension(name, dirs.getOrElse(Nil), fields.getOrElse(Nil))\n          }\n\n        ScalarTypeExtension|\n        ObjectTypeExtension|\n        InterfaceTypeExtension|\n        UnionTypeExtension|\n        EnumTypeExtension|\n        InputObjectTypeExtension\n      }\n\n      keyword(\"extend\") *> (SchemaExtension | TypeExtension)\n    }\n\n    lazy val RootOperationTypeDefinition: Parser[Ast.RootOperationTypeDefinition] =\n      (OperationType ~ punctuation(\":\") ~ NamedType ~ Directives).map {\n        case (((optpe, _), tpe), dirs) => Ast.RootOperationTypeDefinition(optpe, tpe, dirs)\n      }\n\n\n    lazy val Description = StringValue\n\n    lazy val ImplementsInterfaces =\n      (keyword(\"implements\") ~ punctuation(\"&\").?) *> NamedType.repSep0(punctuation(\"&\"))\n\n    lazy val FieldsDefinition: Parser[List[Ast.FieldDefinition]] =\n      braces(FieldDefinition.rep0)\n\n    lazy val FieldDefinition: Parser[Ast.FieldDefinition] =\n      (Description.?.with1 ~ Name ~ ArgumentsDefinition.? ~ punctuation(\":\") ~ Type ~ Directives.?).map {\n        case (((((desc, name), args), _), tpe), dirs) => Ast.FieldDefinition(name, desc.map(_.value), args.getOrElse(Nil), tpe, dirs.getOrElse(Nil))\n      }\n\n    lazy val ArgumentsDefinition: Parser[List[Ast.InputValueDefinition]] =\n      parens(InputValueDefinition.rep0)\n\n    lazy val InputFieldsDefinition: Parser[List[Ast.InputValueDefinition]] =\n      braces(InputValueDefinition.rep0)\n\n    lazy val InputValueDefinition: Parser[Ast.InputValueDefinition] =\n      (Description.?.with1 ~ (Name <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n        case ((((desc, name), tpe), dv), dirs) => Ast.InputValueDefinition(name, desc.map(_.value), tpe, dv, dirs.getOrElse(Nil))\n      }\n\n    lazy val UnionMemberTypes: Parser[List[Ast.Type.Named]] =\n      (punctuation(\"=\") *> punctuation(\"|\").?) *> NamedType.repSep0(punctuation(\"|\"))\n\n    lazy val EnumValuesDefinition: Parser[List[Ast.EnumValueDefinition]] =\n      braces(EnumValueDefinition.rep0)\n\n    lazy val EnumValueDefinition: Parser[Ast.EnumValueDefinition] =\n      (Description.?.with1 ~ Name ~ Directives.?).map {\n        case ((desc, name), dirs) => Ast.EnumValueDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n      }\n\n    lazy val DirectiveLocations: Parser0[List[Ast.DirectiveLocation]] =\n      punctuation(\"|\").? *> DirectiveLocation.repSep0(punctuation(\"|\"))\n\n    lazy val DirectiveLocation: Parser[Ast.DirectiveLocation] =\n      keyword(\"QUERY\")       .as(Ast.DirectiveLocation.QUERY) |\n      keyword(\"MUTATION\")    .as(Ast.DirectiveLocation.MUTATION) |\n      keyword(\"SUBSCRIPTION\").as(Ast.DirectiveLocation.SUBSCRIPTION) |\n      keyword(\"FIELD_DEFINITION\").as(Ast.DirectiveLocation.FIELD_DEFINITION) |\n      keyword(\"FIELD\").as(Ast.DirectiveLocation.FIELD) |\n      keyword(\"FRAGMENT_DEFINITION\").as(Ast.DirectiveLocation.FRAGMENT_DEFINITION) |\n      keyword(\"FRAGMENT_SPREAD\").as(Ast.DirectiveLocation.FRAGMENT_SPREAD) |\n      keyword(\"INLINE_FRAGMENT\").as(Ast.DirectiveLocation.INLINE_FRAGMENT) |\n      keyword(\"VARIABLE_DEFINITION\").as(Ast.DirectiveLocation.VARIABLE_DEFINITION) |\n      keyword(\"SCHEMA\").as(Ast.DirectiveLocation.SCHEMA) |\n      keyword(\"SCALAR\").as(Ast.DirectiveLocation.SCALAR) |\n      keyword(\"OBJECT\").as(Ast.DirectiveLocation.OBJECT) |\n      keyword(\"ARGUMENT_DEFINITION\").as(Ast.DirectiveLocation.ARGUMENT_DEFINITION) |\n      keyword(\"INTERFACE\").as(Ast.DirectiveLocation.INTERFACE) |\n      keyword(\"UNION\").as(Ast.DirectiveLocation.UNION) |\n      keyword(\"ENUM_VALUE\").as(Ast.DirectiveLocation.ENUM_VALUE) |\n      keyword(\"ENUM\").as(Ast.DirectiveLocation.ENUM) |\n      keyword(\"INPUT_OBJECT\").as(Ast.DirectiveLocation.INPUT_OBJECT) |\n      keyword(\"INPUT_FIELD_DEFINITION\").as(Ast.DirectiveLocation.INPUT_FIELD_DEFINITION)\n\n    lazy val ExecutableDefinition: Parser[Ast.ExecutableDefinition] =\n      OperationDefinition | FragmentDefinition\n\n    lazy val OperationDefinition: Parser[Ast.OperationDefinition] =\n      QueryShorthand | Operation\n\n    lazy val QueryShorthand: Parser[Ast.OperationDefinition.QueryShorthand] =\n      SelectionSet.map(Ast.OperationDefinition.QueryShorthand.apply)\n\n    lazy val Operation: Parser[Ast.OperationDefinition.Operation] =\n      (OperationType ~ Name.? ~ VariableDefinitions.? ~ Directives ~ SelectionSet).map {\n        case ((((op, name), vars), dirs), sels) => Ast.OperationDefinition.Operation(op, name, vars.orEmpty, dirs, sels)\n      }\n\n    lazy val OperationType: Parser[Ast.OperationType] =\n      keyword(\"query\")       .as(Ast.OperationType.Query) |\n      keyword(\"mutation\")    .as(Ast.OperationType.Mutation) |\n      keyword(\"subscription\").as(Ast.OperationType.Subscription)\n\n    lazy val Alias: Parser[Ast.Name] =\n      Name <* punctuation(\":\")\n\n    lazy val FragmentSpread: Parser[Ast.Selection.FragmentSpread] =\n      (FragmentName ~ Directives).map{ case (name, dirs) => Ast.Selection.FragmentSpread.apply(name, dirs)}\n\n    def Field(n: Int): Parser[Ast.Selection.Field] =\n      (Alias.backtrack.?.with1 ~ Name ~ Arguments.? ~ Directives ~ SelectionSetN(n).?).map {\n        case ((((alias, name), args), dirs), sel) => Ast.Selection.Field(alias, name, args.orEmpty, dirs, sel.orEmpty)\n      }\n\n    def InlineFragment(n: Int): Parser[Ast.Selection.InlineFragment] =\n      ((TypeCondition.? ~ Directives).with1 ~ SelectionSetN(n)).map {\n        case ((cond, dirs), sel) => Ast.Selection.InlineFragment(cond, dirs, sel)\n      }\n\n    def Selection(n: Int): Parser[Ast.Selection] =\n      Field(n) |\n      (punctuation(\"...\") *> (InlineFragment(n) | FragmentSpread))\n\n    lazy val SelectionSet: Parser[List[Ast.Selection]] =\n      SelectionSetN(maxSelectionDepth)\n\n    def SelectionSetN(n: Int): Parser[List[Ast.Selection]] =\n      braces(guard0(n, \"exceeded maximum selection depth\")(Selection(_).repAs0(max = maxSelectionWidth)))\n\n    lazy val Arguments: Parser[List[(Ast.Name, Ast.Value)]] =\n      parens(Argument.rep0)\n\n    lazy val Argument: Parser[(Ast.Name, Ast.Value)] =\n      (Name <* punctuation(\":\")) ~ Value\n\n    lazy val FragmentName: Parser[Ast.Name] =\n      not(string(\"on\")).with1 *> Name\n\n    lazy val FragmentDefinition: Parser[Ast.FragmentDefinition] =\n      ((keyword(\"fragment\") *> FragmentName) ~ TypeCondition ~ Directives ~ SelectionSet).map {\n        case (((name, cond), dirs), sel) => Ast.FragmentDefinition(name, cond, dirs, sel)\n      }\n\n    lazy val TypeCondition: Parser[Ast.Type.Named] =\n      keyword(\"on\") *> NamedType\n\n    lazy val NullValue: Parser[Ast.Value.NullValue.type] =\n      keyword(\"null\").as(Ast.Value.NullValue)\n\n    lazy val EnumValue: Parser[Ast.Value.EnumValue] =\n      (not(string(\"true\") | string(\"false\") | string(\"null\")).with1 *> Name)\n        .map(Ast.Value.EnumValue.apply)\n\n    def ListValue(n: Int): Parser[Ast.Value.ListValue] =\n      token(squareBrackets(guard0(n, \"exceeded maximum input value depth\")(ValueN(_).rep0)).map(Ast.Value.ListValue.apply))\n\n    lazy val NumericLiteral: Parser[Ast.Value] = {\n      def narrow(d: BigDecimal): Ast.Value.FloatValue =\n        Ast.Value.FloatValue(d.toDouble)\n\n      token(\n        (intLiteral ~ (char('.') *> digit.rep.string).? ~ ((char('e') | char('E')) *> intLiteral.string).?)\n          .map {\n            case ((a, Some(b)), None) => narrow(BigDecimal(s\"$a.$b\"))\n            case ((a, None), Some(c)) => narrow(BigDecimal(s\"${a}E$c\"))\n            case ((a, Some(b)), Some(c)) => narrow(BigDecimal(s\"$a.${b}E$c\"))\n            case ((a, None), None) => Ast.Value.IntValue(a)\n          }\n      )\n    }\n\n    lazy val BooleanValue: Parser[Ast.Value.BooleanValue] =\n      token(booleanLiteral).map(Ast.Value.BooleanValue.apply)\n\n    def ObjectField(n: Int): Parser[(Ast.Name, Ast.Value)] =\n      (Name <* punctuation(\":\")) ~ ValueN(n)\n\n    def ObjectValue(n: Int): Parser[Ast.Value.ObjectValue] =\n      braces(guard0(n, \"exceeded maximum input value depth\")(ObjectField(_).rep0)).map(Ast.Value.ObjectValue.apply)\n\n    lazy val StringValue: Parser[Ast.Value.StringValue] =\n      token(stringLiteral).map(Ast.Value.StringValue.apply)\n\n    def ValueN(n: Int): Parser[Ast.Value] =\n      Variable |\n        NumericLiteral |\n        StringValue |\n        BooleanValue |\n        NullValue |\n        EnumValue |\n        ListValue(n) |\n        ObjectValue(n)\n\n    lazy val Value: Parser[Ast.Value] =\n      ValueN(maxInputValueDepth)\n\n    lazy val VariableDefinitions: Parser[List[Ast.VariableDefinition]] =\n      parens(VariableDefinition.rep0)\n\n    lazy val VariableDefinition: Parser[Ast.VariableDefinition] =\n      ((Variable <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n        case (((v, tpe), dv), dirs) => Ast.VariableDefinition(v.name, tpe, dv, dirs.getOrElse(Nil))\n      }\n\n    lazy val Variable: Parser[Ast.Value.Variable] =\n      punctuation(\"$\") *> Name.map(Ast.Value.Variable.apply)\n\n    lazy val DefaultValue: Parser[Ast.Value] =\n      punctuation(\"=\") *> Value\n\n    def ListType(n: Int): Parser[Ast.Type.List] =\n      squareBrackets(guard(n, \"exceeded maximum list type depth\")(TypeN)).map(Ast.Type.List.apply)\n\n    lazy val namedMaybeNull: Parser[Ast.Type] = (NamedType ~ punctuation(\"!\").?).map {\n      case (t, None) => t\n      case (t, _) => Ast.Type.NonNull(Left(t))\n    }\n\n    def listMaybeNull(n: Int): Parser[Ast.Type] = (ListType(n) ~ punctuation(\"!\").?).map {\n      case (t, None) => t\n      case (t, _) => Ast.Type.NonNull(Right(t))\n    }\n\n    def TypeN(n: Int): Parser[Ast.Type] =\n      namedMaybeNull | listMaybeNull(n)\n\n    lazy val Type: Parser[Ast.Type] =\n      TypeN(maxListTypeDepth)\n\n    lazy val NamedType: Parser[Ast.Type.Named] =\n      Name.map(Ast.Type.Named.apply)\n\n    lazy val Directives: Parser0[List[Ast.Directive]] =\n      Directive.rep0\n\n    lazy val Directive: Parser[Ast.Directive] =\n      punctuation(\"@\") *> (Name ~ Arguments.?).map { case (n, ods) => Ast.Directive(n, ods.orEmpty)}\n\n    lazy val Name: Parser[Ast.Name] =\n      token(charIn(nameInitial) ~ charIn(nameSubsequent).rep0).map {\n        case (h, t) => Ast.Name((h :: t).mkString)\n      }\n\n    def guard0[T](n: Int, msg: String)(p: Int => Parser0[T]): Parser0[T] =\n      if (n <= 0) Parser.failWith(msg) else defer0(p(n-1))\n\n    def guard[T](n: Int, msg: String)(p: Int => Parser[T]): Parser[T] =\n      if (n <= 0) Parser.failWith(msg) else defer(p(n-1))\n  }\n\n  private object CommentedText {\n\n    val whitespace: Parser[Char] = charWhere(_.isWhitespace)\n\n    val skipWhitespace: Parser0[Unit] =\n      charsWhile0(c => c.isWhitespace || c == ',').void\n\n    /** Parser that consumes a comment */\n    val comment: Parser[Unit] =\n      (char('#') *> (charWhere(c => c != '\\n' && c != '\\r')).rep0 <* charIn('\\n', '\\r') <* skipWhitespace).void\n\n    /** Turns a parser into one that skips trailing whitespace and comments */\n    def token[A](p: Parser[A]): Parser[A] =\n      p <* skipWhitespace <* comment.rep0\n\n    def token0[A](p: Parser0[A]): Parser0[A] =\n      p <* skipWhitespace <* comment.rep0\n\n    /**\n    * Consumes `left` and `right`, including the trailing and preceding whitespace,\n    * respectively, and returns the value of `p`.\n    */\n    private def _bracket[A,B,C](left: Parser[B], p: Parser0[A], right: Parser[C]): Parser[A] =\n      token(left) *> token0(p) <* token(right)\n\n    /** Turns a parser into one that consumes surrounding parentheses `()` */\n    def parens[A](p: Parser0[A]): Parser[A] =\n      _bracket(char('('), p, char(')'))\n\n    /** Turns a parser into one that consumes surrounding curly braces `{}` */\n    def braces[A](p: Parser0[A]): Parser[A] =\n      _bracket(char('{'), p, char('}'))\n\n    /** Turns a parser into one that consumes surrounding square brackets `[]` */\n    def squareBrackets[A](p: Parser0[A]): Parser[A] =\n      _bracket(char('['), p, char(']'))\n  }\n\n  private object Literals {\n\n    val stringLiteral: Parser[String] = {\n\n      val lineTerminator: Parser[String] = (lf | cr | crlf).string\n\n      val sourceCharacter: Parser[String] = (charIn(0x0009.toChar, 0x000A.toChar, 0x000D.toChar) | charIn(0x0020.toChar to 0xFFFF.toChar)).string\n\n      val escapedUnicode: Parser[String] = string(\"\\\\u\") *>\n        hexdig\n          .repExactlyAs[String](4)\n          .map(hex => Integer.parseInt(hex, 16).toChar.toString)\n\n      val escapedCharacter: Parser[String] = char('\\\\') *>\n        (\n          char('\"').as(\"\\\"\") |\n            char('\\\\').as(\"\\\\\") |\n            char('/').as(\"/\") |\n            char('b').as(\"\\b\") |\n            char('f').as(\"\\f\") |\n            char('n').as(\"\\n\") |\n            char('r').as(\"\\r\") |\n            char('t').as(\"\\t\")\n        )\n\n      val stringCharacter: Parser[String] = (\n        (not(charIn('\"', '\\\\') | lineTerminator).with1 *> sourceCharacter) |\n          escapedUnicode |\n        escapedCharacter\n      )\n\n      val blockStringCharacter: Parser[String] = string(\"\\\\\\\"\\\"\\\"\").as(\"\\\"\\\"\\\"\") |\n        (not(string(\"\\\"\\\"\\\"\")).with1 *> sourceCharacter)\n\n      //https://spec.graphql.org/June2018/#BlockStringValue()\n      //TODO this traverses over lines a hideous number of times(but matching the\n      //algorithm in the spec). Can it be optimized?\n      val blockQuotesInner: Parser0[String] = blockStringCharacter.repAs0[String].map { str =>\n        val isWhitespace: Regex = \"[ \\t]*\".r\n        var commonIndent: Int = -1\n        var lineNum: Int = 0\n        for (line <- str.linesIterator) {\n          if (lineNum != 0) {\n            val len = line.length()\n            val indent = line.takeWhile(c => c == ' ' || c == '\\t').length()\n            if (indent < len) {\n              if (commonIndent < 0 || indent < commonIndent) {\n                commonIndent = indent\n              }\n            }\n          }\n          lineNum = lineNum + 1\n        }\n        val formattedReversed: List[String] = if ( commonIndent >= 0) {\n          str.linesIterator.foldLeft[List[String]](Nil) {\n            (acc, l) => if (acc == Nil) l :: acc else l.drop(commonIndent) :: acc\n          }\n        } else {\n          str.linesIterator.toList\n        }\n        val noTrailingEmpty = formattedReversed.dropWhile(isWhitespace.matches(_)).reverse\n        noTrailingEmpty.dropWhile(isWhitespace.matches(_)).mkString(\"\\n\")\n      }\n\n\n      (not(string(\"\\\"\\\"\\\"\")).with1 *> stringCharacter.repAs0[String].with1.surroundedBy(char('\"'))) | blockQuotesInner.with1.surroundedBy(string(\"\\\"\\\"\\\"\"))\n\n    }\n\n    val intLiteral: Parser[Int] =\n      bigInt.flatMap {\n        case v if v.isValidInt => pure(v.toInt)\n        case v => failWith(s\"$v is larger than max int\")\n      }\n\n    val booleanLiteral: Parser[Boolean] = string(\"true\").as(true) | string(\"false\").as(false)\n\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\n\nimport cats.implicits._\nimport io.circe.Json\nimport org.tpolecat.sourcepos.SourcePos\n\nimport syntax._\nimport Ast.{DirectiveLocation, InterfaceTypeDefinition, ObjectTypeDefinition, TypeDefinition, UnionTypeDefinition}\nimport Query._\nimport ScalarType._\nimport UntypedOperation._\nimport Value._\n\n/**\n * Representation of a GraphQL schema\n *\n * A `Schema` is a collection of type and directive declarations.\n */\ntrait Schema {\n\n  def pos: SourcePos\n\n  /** The types defined by this `Schema` prior to any extensions. */\n  def baseTypes: List[NamedType]\n\n  /** The types defined by this `Schema` with any extensions applied. */\n  lazy val types: List[NamedType] =\n    if (typeExtensions.isEmpty) baseTypes\n    else baseTypes.map(extendType(typeExtensions))\n\n  /** The directives defined by this `Schema`. */\n  def directives: List[DirectiveDef]\n\n  /** The schema extensions defined by this `Schema` */\n  def schemaExtensions: List[SchemaExtension]\n\n  /** The type extensions defined by this `Schema` */\n  def typeExtensions: List[TypeExtension]\n\n  /** A reference by name to a type defined by this `Schema`.\n   *\n   * `TypeRef`s refer to types defined in this schema by name and hence\n   * can be used as part of mutually recursive type definitions.\n   */\n  def ref(tpnme: String): TypeRef = new TypeRef(this, tpnme)\n\n  /**\n   * Alias for `ref` for use within constructors of concrete\n   * `Schema` values.\n   */\n  protected def TypeRef(tpnme: String): TypeRef = ref(tpnme)\n\n  /**\n   * The default type of a GraphQL schema\n   *\n   * Unless a type named `\"Schema\"` is explicitly defined as part of\n   * this `Schema` a definition of the form,\n   *\n   * ```\n   * type Schema {\n   *   query: Query!\n   *   mutation: Mutation\n   *   subscription: Subscription\n   * }\n   * ```\n   *\n   * is used.\n   */\n  def defaultSchemaType: NamedType = {\n    def mkRootDef(fieldName: String)(tpe: NamedType): Field =\n      Field(fieldName, None, Nil, tpe, Nil)\n\n    ObjectType(\n      name = \"Schema\",\n      description = None,\n      fields =\n        List(\n          definition(\"Query\").map(mkRootDef(\"query\")),\n          definition(\"Mutation\").map(mkRootDef(\"mutation\")),\n          definition(\"Subscription\").map(mkRootDef(\"subscription\"))\n        ).flatten,\n      interfaces = Nil,\n      directives = Nil\n    )\n  }\n\n  /**\n   * Look up by name a type defined in this `Schema`.\n   *\n   * Yields the type, if defined, `None` otherwise.\n   */\n  def definition(name: String): Option[NamedType] =\n    typeIndex.get(name).orElse(ScalarType.builtIn(name)).map(_.dealias)\n\n  private lazy val typeIndex = types.map(tpe => (tpe.name, tpe)).toMap\n\n  def ref(tp: Type): Option[TypeRef] = tp match {\n    case nt: NamedType if types.exists(_.name == nt.name) => Some(ref(nt.name))\n    case _ => None\n  }\n\n  def baseSchemaType: NamedType = definition(\"Schema\").getOrElse(defaultSchemaType)\n\n  /**\n   * The schema type.\n   *\n   * Either the explicitly defined type named `\"Schema\"` or the default\n   * schema type if not defined.\n   */\n  lazy val schemaType: NamedType =\n    if (schemaExtensions.isEmpty) baseSchemaType\n    else extendSchemaType(schemaExtensions, baseSchemaType)\n\n  /** The type of queries defined by this `Schema`*/\n  def queryType: NamedType = schemaType.field(\"query\").flatMap(_.nonNull.asNamed).get\n\n  /** The type of mutations defined by this `Schema`*/\n  def mutationType: Option[NamedType] = schemaType.field(\"mutation\").flatMap(_.nonNull.asNamed)\n\n  /** The type of subscriptions defined by this `Schema`*/\n  def subscriptionType: Option[NamedType] = schemaType.field(\"subscription\").flatMap(_.nonNull.asNamed)\n\n  /** True if the supplied type is one of the Query, Mutation or Subscription root types, false otherwise */\n  def isRootType(tpe: Type): Boolean =\n    tpe =:= queryType || mutationType.exists(_ =:= tpe) || subscriptionType.exists(_ =:= tpe)\n\n  /** Are the supplied alternatives exhaustive for `tp` */\n  def exhaustive(tp: Type, branches: List[Type]): Boolean = {\n    types.forall {\n      case o: ObjectType => !(o <:< tp) || branches.exists(b => o <:< b)\n      case _ => true\n    }\n  }\n\n  override def toString = SchemaRenderer.renderSchema(this)\n\n  private def extendType(extns: List[TypeExtension])(baseType: NamedType): NamedType = {\n    baseType match {\n      case ScalarType(name, description, directives) =>\n        val exts = extns.collect { case se@ScalarExtension(`name`, _) => se }\n        if (exts.isEmpty) baseType\n        else {\n          val newDirectives = exts.flatMap(_.directives)\n          ScalarType(name, description, directives ++ newDirectives)\n        }\n\n      case InterfaceType(name, description, fields, interfaces, directives) =>\n        val exts = extns.collect { case ie@InterfaceExtension(`name`, _, _, _) => ie }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.fields)\n          val newInterfaces = exts.flatMap(_.interfaces)\n          val newDirectives = exts.flatMap(_.directives)\n          InterfaceType(name, description, fields ++ newFields, interfaces ++ newInterfaces, directives ++ newDirectives)\n        }\n\n      case ObjectType(name, description, fields, interfaces, directives) =>\n        val exts = extns.collect { case oe@ObjectExtension(`name`, _, _, _) => oe }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.fields)\n          val newInterfaces = exts.flatMap(_.interfaces)\n          val newDirectives = exts.flatMap(_.directives)\n          ObjectType(name, description, fields ++ newFields, interfaces ++ newInterfaces, directives ++ newDirectives)\n        }\n\n      case UnionType(name, description, members, directives) =>\n        val exts = extns.collect { case ue@UnionExtension(`name`, _, _) => ue }\n        if (exts.isEmpty) baseType\n        else {\n          val newMembers = exts.flatMap(_.members)\n          val newDirectives = exts.flatMap(_.directives)\n          UnionType(name, description, members ++ newMembers, directives ++ newDirectives)\n        }\n\n      case EnumType(name, description, enumValues, directives) =>\n        val exts = extns.collect { case ee@EnumExtension(`name`, _, _) => ee }\n        if (exts.isEmpty) baseType\n        else {\n          val newValues = exts.flatMap(_.enumValues)\n          val newDirectives = exts.flatMap(_.directives)\n          EnumType(name, description, enumValues ++ newValues, directives ++ newDirectives)\n        }\n\n      case InputObjectType(name, description, inputFields, directives) =>\n        val exts = extns.collect { case ioe@InputObjectExtension(`name`, _, _) => ioe }\n        if (exts.isEmpty) baseType\n        else {\n          val newFields = exts.flatMap(_.inputFields)\n          val newDirectives = exts.flatMap(_.directives)\n          InputObjectType(name, description, inputFields ++ newFields, directives ++ newDirectives)\n        }\n\n      case tr: TypeRef =>\n        // This case should never be hit, however, it is the correct behaviour to return\n        // the ref as is. If the underlying type is present it will be extended, if not\n        // there will be an error reported elsewhere.\n        tr\n    }\n  }\n\n  private def extendSchemaType(extns: List[SchemaExtension], schemaType: NamedType): NamedType = {\n    schemaType match {\n      case ObjectType(name, description, fields, interfaces, directives) =>\n        val newFields = extns.flatMap(_.rootOperations)\n        val newDirectives = extns.flatMap(_.directives)\n        ObjectType(name, description, fields ++ newFields, interfaces, directives ++ newDirectives)\n\n      case _ => schemaType\n    }\n  }\n}\n\nobject Schema {\n  def apply(schemaText: String)(implicit pos: SourcePos): Result[Schema] =\n    apply(schemaText, SchemaParser(GraphQLParser(GraphQLParser.defaultConfig)))\n\n  def apply(schemaText: String, parser: SchemaParser)(implicit pos: SourcePos): Result[Schema] =\n    parser.parseText(schemaText)\n}\n\ncase class SchemaExtension(\n  rootOperations: List[Field],\n  directives: List[Directive]\n)\n\n/**\n * A GraphQL type definition.\n */\nsealed trait Type extends Product {\n  /**\n   * Is this type equivalent to `other`.\n   *\n   * Note that plain `==` will distinguish types from type aliases,\n   * which is typically not desirable, so `=:=` is usually the\n   * most appropriate comparison operator.\n   */\n  def =:=(other: Type): Boolean = (this eq other) || (dealias == other.dealias)\n\n  /** `true` if this type is a subtype of `other`. */\n  def <:<(other: Type): Boolean =\n    (this.dealias, other.dealias) match {\n      case (tp1, tp2) if tp1 == tp2 => true\n      case (tp1, UnionType(_, _, members, _)) => members.exists(tp1 <:< _.dealias)\n      case (ObjectType(_, _, _, interfaces, _), tp2) => interfaces.exists(_ <:< tp2)\n      case (InterfaceType(_, _, _, interfaces, _), tp2) => interfaces.exists(_ <:< tp2)\n      case (NullableType(tp1), NullableType(tp2)) => tp1 <:< tp2\n      case (tp1, NullableType(tp2)) => tp1 <:< tp2\n      case (ListType(tp1), ListType(tp2)) => tp1 <:< tp2\n      case _ => false\n    }\n\n  def nominal_=:=(other: Type): Boolean =\n    this =:= other ||\n      ((this.dealias, other.dealias) match {\n        case (nt1: NamedType, nt2: NamedType) => nt1.name == nt2.name\n        case _ => false\n      })\n\n  /**\n   * Yield the type of the field of this type named `fieldName` or\n   * `None` if there is no such field.\n   */\n  def field(fieldName: String): Option[Type] = this match {\n    case NullableType(tpe) => tpe.field(fieldName)\n    case TypeRef(_, _) if exists => dealias.field(fieldName)\n    case ObjectType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case InterfaceType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case _ => None\n  }\n\n  /** `true` if this type has a field named `fieldName`, false otherwise. */\n  def hasField(fieldName: String): Boolean =\n    field(fieldName).isDefined\n\n  /** Yields the definition of `fieldName` in this type if it exists, `None` otherwise. */\n  def fieldInfo(fieldName: String): Option[Field] = this match {\n    case NullableType(tpe) => tpe.fieldInfo(fieldName)\n    case ListType(tpe) => tpe.fieldInfo(fieldName)\n    case _: TypeRef => dealias.fieldInfo(fieldName)\n    case _ => None\n  }\n\n  /**\n   * `true` if this type has a field named `fieldName` which is undefined in\n   * some interface it implements\n   */\n  def variantField(fieldName: String): Boolean =\n    underlyingObject match {\n      case Some(ObjectType(_, _, _, interfaces, _)) =>\n        hasField(fieldName) && interfaces.exists(!_.hasField(fieldName))\n      case _ => false\n    }\n\n  /**\n   * Yield the type of the field at the end of the path `fns` starting\n   * from this type, or `None` if there is no such field.\n   */\n  def path(fns: List[String]): Option[Type] = (fns, this) match {\n    case (Nil, _) => Some(this)\n    case (_, ListType(tpe)) => tpe.path(fns)\n    case (_, NullableType(tpe)) => tpe.path(fns)\n    case (_, TypeRef(_, _)) => dealias.path(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).flatMap(_.tpe.path(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).flatMap(_.tpe.path(rest))\n    case _ => None\n  }\n\n  /**\n   * Does the path `fns` from this type specify multiple values.\n   *\n   * `true` if navigating through the path `fns` from this type\n   * might specify 0 or more values. This will be the case if the\n   * path passes through at least one field of a List type.\n   */\n  def pathIsList(fns: List[String]): Boolean = (fns, this) match {\n    case (Nil, _) => this.isList\n    case (_, _: ListType) => true\n    case (_, NullableType(tpe)) => tpe.pathIsList(fns)\n    case (_, TypeRef(_, _)) => dealias.pathIsList(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsList(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsList(rest))\n    case _ => false\n  }\n\n  /**\n   * Does the path `fns` from this type specify a nullable type.\n   *\n   * `true` if navigating through the path `fns` from this type\n   * might specify an optional value. This will be the case if the\n   * path passes through at least one field of a nullable type.\n   */\n  def pathIsNullable(fns: List[String]): Boolean = (fns, this) match {\n    case (Nil, _) => false\n    case (_, ListType(tpe)) => tpe.pathIsNullable(fns)\n    case (_, _: NullableType) => true\n    case (_, TypeRef(_, _)) => dealias.pathIsNullable(fns)\n    case (fieldName :: rest, ObjectType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsNullable(rest))\n    case (fieldName :: rest, InterfaceType(_, _, fields, _, _)) =>\n      fields.find(_.name == fieldName).exists(_.tpe.pathIsNullable(rest))\n    case _ => false\n  }\n\n  /** Strip off aliases */\n  def dealias: Type = this\n\n  /** true if a non-TypeRef or a TypeRef to a defined type */\n  def exists: Boolean = true\n\n  /** Is this type nullable? */\n  def isNullable: Boolean = this match {\n    case NullableType(_) => true\n    case _ => false\n  }\n\n  /** This type if it is nullable, `Nullable(this)` otherwise. */\n  def nullable: Type = this match {\n    case t: NullableType => t\n    case t => NullableType(t)\n  }\n\n  /**\n   * A non-nullable version of this type.\n   *\n   * If this type is nullable, yield the non-nullable underlying\n   * type. Otherwise yield this type.\n   */\n  def nonNull: Type = this match {\n    case NullableType(tpe) => tpe.nonNull\n    case _ => this\n  }\n\n  /** Is this type a list. */\n  def isList: Boolean = this match {\n    case ListType(_) => true\n    case _ => false\n  }\n\n  /**\n   * The element type of this type.\n   *\n   * If this type is is a list, yield the non-list underlying type.\n   * Otherwise yield `None`.\n   */\n  def item: Option[Type] = this match {\n    case NullableType(tpe) => tpe.item\n    case ListType(tpe) => Some(tpe)\n    case _ => None\n  }\n\n  /** This type if it is a (nullable) list, `ListType(this)` otherwise. */\n  def list: Type = this match {\n    case l: ListType => l\n    case NullableType(tpe) => NullableType(tpe.list)\n    case tpe => ListType(tpe)\n  }\n\n  def underlying: Type = this match {\n    case NullableType(tpe) => tpe.underlying\n    case ListType(tpe) => tpe.underlying\n    case _: TypeRef => dealias.underlying\n    case _ => this\n  }\n\n  /**\n   * Yield the object type underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying object type is reached, in which case yield it, or a\n   * non-object type which isn't further reducible is reached, in which\n   * case yield `None`.\n   */\n  def underlyingObject: Option[NamedType] = this match {\n    case NullableType(tpe) => tpe.underlyingObject\n    case ListType(tpe) => tpe.underlyingObject\n    case _: TypeRef => dealias.underlyingObject\n    case o: ObjectType => Some(o)\n    case i: InterfaceType => Some(i)\n    case u: UnionType => Some(u)\n    case _ => None\n  }\n\n  /**\n   * Yield the type of the field named `fieldName` of the object type\n   * underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying object type is reached which has a field named\n   * `fieldName`, in which case yield the type of that field; if there\n   * is no such field, yields `None`.\n   */\n  def underlyingField(fieldName: String): Option[Type] = this match {\n    case NullableType(tpe) => tpe.underlyingField(fieldName)\n    case ListType(tpe) => tpe.underlyingField(fieldName)\n    case TypeRef(_, _) => dealias.underlyingField(fieldName)\n    case ObjectType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case InterfaceType(_, _, fields, _, _) => fields.find(_.name == fieldName).map(_.tpe)\n    case _ => None\n  }\n\n  /** Is this type a leaf type?\n   *\n   * `true` if after stripping of aliases the underlying type a scalar or an\n   * enum, `false` otherwise.\n   */\n  def isLeaf: Boolean = this match {\n    case TypeRef(_, _) => dealias.isLeaf\n    case _: ScalarType => true\n    case _: EnumType => true\n    case _ => false\n  }\n\n  /**\n   * If the underlying type of this type is a scalar or an enum then yield it\n   * otherwise yield `None`.\n   */\n  def asLeaf: Option[Type] = this match {\n    case TypeRef(_, _) => dealias.asLeaf\n    case _: ScalarType => Some(this)\n    case _: EnumType => Some(this)\n    case _ => None\n  }\n\n\n  /**\n   * Is the underlying of this type a leaf type?\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying leaf type is reached, in which case yield true, or an\n   * a object, interface or union type which is reached, in which case\n   * yield false.\n   */\n  def isUnderlyingLeaf: Boolean = this match {\n    case NullableType(tpe) => tpe.isUnderlyingLeaf\n    case ListType(tpe) => tpe.isUnderlyingLeaf\n    case _: TypeRef => dealias.isUnderlyingLeaf\n    case (_: ObjectType)|(_: InterfaceType)|(_: UnionType) => false\n    case _ => true\n  }\n\n  /**\n   * Yield the leaf type underlying this type.\n   *\n   * Strip off all aliases, nullability and enclosing list types until\n   * an underlying leaf type is reached, in which case yield it, or an\n   * a object, interface or union type which is reached, in which case\n   * yield `None`.\n   */\n  def underlyingLeaf: Option[Type] = this match {\n    case NullableType(tpe) => tpe.underlyingLeaf\n    case ListType(tpe) => tpe.underlyingLeaf\n    case _: TypeRef => dealias.underlyingLeaf\n    case (_: ObjectType)|(_: InterfaceType)|(_: UnionType) => None\n    case tpe => Some(tpe)\n  }\n\n  def withModifiersOf(tpe: Type): Type = {\n    def loop(rtpe: Type, tpe: Type): Type = tpe match {\n      case NullableType(tpe) => loop(NullableType(rtpe), tpe)\n      case ListType(tpe) => loop(ListType(rtpe), tpe)\n      case _ => rtpe\n    }\n    loop(this, tpe)\n  }\n\n  def isNamed: Boolean = false\n\n  def asNamed: Option[NamedType] = None\n\n  def isInterface: Boolean = false\n\n  def isUnion: Boolean = false\n\n  def /(pathElement: String): Path =\n    Path.from(this) / pathElement\n\n  def directives: List[Directive]\n}\n\n// Move all below into object Type?\n\n/** A type with a schema-defined name.\n *\n * This includes object types, inferface types and enums.\n */\nsealed trait NamedType extends Type {\n  /** The name of this type */\n  def name: String\n\n  override def dealias: NamedType = this\n\n  override def isNamed: Boolean = true\n\n  override def asNamed: Option[NamedType] = Some(this)\n\n  def description: Option[String]\n\n  def directives: List[Directive]\n\n  override def toString: String = name\n}\n\n/**\n * A GraphQL type extension\n */\nsealed trait TypeExtension {\n  def baseType: String\n}\n\n/**\n * A by name reference to a type defined in `schema`.\n */\ncase class TypeRef(schema: Schema, name: String) extends NamedType {\n  override lazy val dealias: NamedType = schema.definition(name).getOrElse(this)\n\n  override lazy val exists: Boolean = schema.definition(name).isDefined\n\n  def description: Option[String] = dealias.description\n\n  def directives: List[Directive] = dealias.directives\n}\n\n/**\n * Represents scalar types such as Int, String, and Boolean. Scalars cannot have fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Scalar\n */\ncase class ScalarType(\n  name: String,\n  description: Option[String],\n  directives: List[Directive]\n) extends Type with NamedType {\n  import ScalarType._\n\n  /** True if this is one of the five built-in Scalar types defined in the GraphQL Specification. */\n  def isBuiltIn: Boolean =\n    this match {\n      case IntType     |\n           FloatType   |\n           StringType  |\n           BooleanType |\n           IDType      => true\n      case _           => false\n    }\n\n}\n\nobject ScalarType {\n  def builtIn(tpnme: String): Option[ScalarType] = tpnme match {\n    case \"Int\" => Some(IntType)\n    case \"Float\" => Some(FloatType)\n    case \"String\" => Some(StringType)\n    case \"Boolean\" => Some(BooleanType)\n    case \"ID\" => Some(IDType)\n    case _ => None\n  }\n\n  val IntType = ScalarType(\n    name = \"Int\",\n    description =\n      Some(\n        \"\"\"|The Int scalar type represents a signed 32\u2010bit numeric non\u2010fractional value.\n           |Response formats that support a 32\u2010bit integer or a number type should use that\n           |type to represent this scalar.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val FloatType = ScalarType(\n    name = \"Float\",\n    description =\n      Some(\n        \"\"\"|The Float scalar type represents signed double\u2010precision fractional values as\n           |specified by IEEE 754. Response formats that support an appropriate\n           |double\u2010precision number type should use that type to represent this scalar.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val StringType = ScalarType(\n    name = \"String\",\n    description =\n      Some(\n        \"\"\"|The String scalar type represents textual data, represented as UTF\u20108 character\n           |sequences. The String type is most often used by GraphQL to represent free\u2010form\n           |human\u2010readable text.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n  val BooleanType = ScalarType(\n    name = \"Boolean\",\n    description =\n      Some(\n        \"\"\"|The Boolean scalar type represents true or false. Response formats should use a\n           |built\u2010in boolean type if supported; otherwise, they should use their\n           |representation of the integers 1 and 0.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n\n  val IDType = ScalarType(\n    name = \"ID\",\n    description =\n      Some(\n        \"\"\"|The ID scalar type represents a unique identifier, often used to refetch an\n           |object or as the key for a cache. The ID type is serialized in the same way as a\n           |String; however, it is not intended to be human\u2010readable.\n        \"\"\".stripMargin.trim\n      ),\n    directives = Nil\n  )\n\n  val AttributeType = ScalarType(\n    name = \"InternalAttribute\",\n    description = None,\n    directives = Nil\n  )\n}\n\n/**\n * A type with fields.\n *\n * This includes object types and inferface types.\n */\nsealed trait TypeWithFields extends NamedType {\n  def fields: List[Field]\n  def interfaces: List[NamedType]\n\n  override def fieldInfo(name: String): Option[Field] = fields.find(_.name == name)\n}\n\n/**\n  * Scalar extensions allow additional directives to be applied to a pre-existing Scalar type\n  *\n  * @see https://spec.graphql.org/draft/#sec-Scalar-Extensions\n  */\ncase class ScalarExtension(\n  baseType: String,\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Interfaces are an abstract type where there are common fields declared. Any type that\n * implements an interface must define all the fields with names and types exactly matching.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Interface\n */\ncase class InterfaceType(\n  name: String,\n  description: Option[String],\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeWithFields {\n  override def isInterface: Boolean = true\n}\n\n/**\n * Interface extensions allow additional fields to be added to a pre-existing interface type\n *\n * @see https://spec.graphql.org/draft/#sec-Interface-Extensions\n **/\ncase class InterfaceExtension(\n  baseType: String,\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Object types represent concrete instantiations of sets of fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Object\n */\ncase class ObjectType(\n  name: String,\n  description: Option[String],\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeWithFields\n\n/**\n * Object extensions allow additional fields to be added to a pre-existing object type\n *\n * @see https://spec.graphql.org/draft/#sec-Object-Extensions\n **/\ncase class ObjectExtension(\n  baseType: String,\n  fields: List[Field],\n  interfaces: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Unions are an abstract type where no common fields are declared. The possible types of a union\n * are explicitly listed out in elements. Types can be made parts of unions without\n * modification of that type.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Union\n */\ncase class UnionType(\n  name: String,\n  description: Option[String],\n  members: List[NamedType],\n  directives: List[Directive]\n) extends Type with NamedType {\n  override def isUnion: Boolean = true\n  override def toString: String = members.mkString(\"|\")\n}\n\n/**\n * Union extensions allow additional members to be added to a pre-existing union type\n *\n * @see https://spec.graphql.org/draft/#sec-Union-Extensions\n **/\ncase class UnionExtension(\n  baseType: String,\n  members: List[NamedType],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Enums are special scalars that can only have a defined set of values.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Enum\n */\ncase class EnumType(\n  name: String,\n  description: Option[String],\n  enumValues: List[EnumValueDefinition],\n  directives: List[Directive]\n) extends Type with NamedType {\n  def hasValue(name: String): Boolean = enumValues.exists(_.name == name)\n\n  def value(name: String): Option[EnumValue] = valueDefinition(name).map(_ => EnumValue(name))\n  def valueDefinition(name: String): Option[EnumValueDefinition] = enumValues.find(_.name == name)\n}\n\n/**\n * Enum extensions allow additional values to be added to a pre-existing enum type\n *\n * @see https://spec.graphql.org/draft/#sec-Enum-Extensions\n **/\ncase class EnumExtension(\n  baseType: String,\n  enumValues: List[EnumValueDefinition],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * The `EnumValue` type represents one of possible values of an enum.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__EnumValue-Type\n */\ncase class EnumValueDefinition(\n  name: String,\n  description: Option[String],\n  directives: List[Directive]\n) {\n  def deprecatedDirective: Option[Directive] =\n    directives.find(_.name == \"deprecated\")\n  def isDeprecated: Boolean = deprecatedDirective.isDefined\n  def deprecationReason: Option[String] =\n    for {\n      dir    <- deprecatedDirective\n      reason <- dir.args.collectFirst { case Binding(\"reason\", StringValue(reason)) => reason }\n    } yield reason\n}\n\n/**\n * Input objects are composite types used as inputs into queries defined as a list of named input\n * values.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Input-Object\n */\ncase class InputObjectType(\n  name: String,\n  description: Option[String],\n  inputFields: List[InputValue],\n  directives: List[Directive]\n) extends Type with NamedType {\n  def inputFieldInfo(name: String): Option[InputValue] = inputFields.find(_.name == name)\n}\n\n/**\n * Input Object extensions allow additional fields to be added to a pre-existing Input Object type\n *\n * @see https://spec.graphql.org/draft/#sec-Input-Object-Extensions\n **/\ncase class InputObjectExtension(\n  baseType: String,\n  inputFields: List[InputValue],\n  directives: List[Directive]\n) extends TypeExtension\n\n/**\n * Lists represent sequences of values in GraphQL. A List type is a type modifier: it wraps\n * another type instance in the ofType field, which defines the type of each item in the list.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Type-Kinds.List\n */\ncase class ListType(\n  ofType: Type\n) extends Type {\n  def directives: List[Directive] = Nil\n  override def toString: String = s\"[$ofType]\"\n}\n\n/**\n * A Non\u2010null type is a type modifier: it wraps another type instance in the `ofType` field.\n * Non\u2010null types do not allow null as a response, and indicate required inputs for arguments\n * and input object fields.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-Type-Kinds.Non-Null\n */\ncase class NullableType(\n  ofType: Type\n) extends Type {\n  def directives: List[Directive] = Nil\n  override def toString: String = s\"$ofType?\"\n}\n\n/**\n * The `Field` type represents each field in an Object or Interface type.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__Field-Type\n */\ncase class Field(\n  name: String,\n  description: Option[String],\n  args: List[InputValue],\n  tpe: Type,\n  directives: List[Directive]\n) {\n  def deprecatedDirective: Option[Directive] =\n    directives.find(_.name == \"deprecated\")\n  def isDeprecated: Boolean = deprecatedDirective.isDefined\n  def deprecationReason: Option[String] =\n    for {\n      dir    <- deprecatedDirective\n      reason <- dir.args.collectFirst { case Binding(\"reason\", StringValue(reason)) => reason }\n    } yield reason\n}\n\n/**\n * @param defaultValue a String encoding (using the GraphQL language) of the default value used by\n *                     this input value in the condition a value is not provided at runtime.\n */\ncase class InputValue(\n  name: String,\n  description: Option[String],\n  tpe: Type,\n  defaultValue: Option[Value],\n  directives: List[Directive]\n)\n\nsealed trait Value\n\nobject Value {\n\n  case class IntValue(value: Int) extends Value\n\n  case class FloatValue(value: Double) extends Value\n\n  case class StringValue(value: String) extends Value\n\n  case class BooleanValue(value: Boolean) extends Value\n\n  case class IDValue(value: String) extends Value\n\n  case class EnumValue(name: String) extends Value\n\n  case class ListValue(elems: List[Value]) extends Value\n\n  case class ObjectValue(fields: List[(String, Value)]) extends Value\n\n  case class VariableRef(name: String) extends Value\n\n  case object NullValue extends Value\n\n  case object AbsentValue extends Value\n\n  def fromAst(value: Ast.Value): Result[Value] = {\n    value match {\n      case Ast.Value.IntValue(i) => IntValue(i).success\n      case Ast.Value.FloatValue(d) => FloatValue(d).success\n      case Ast.Value.StringValue(s) => StringValue(s).success\n      case Ast.Value.BooleanValue(b) => BooleanValue(b).success\n      case Ast.Value.EnumValue(e) => EnumValue(e.value).success\n      case Ast.Value.Variable(v) => VariableRef(v.value).success\n      case Ast.Value.NullValue => NullValue.success\n      case Ast.Value.ListValue(vs) => vs.traverse(fromAst).map(ListValue(_))\n      case Ast.Value.ObjectValue(fs) =>\n        fs.traverse { case (name, value) =>\n          fromAst(value).map(v => (name.value, v))\n        }.map(ObjectValue(_))\n    }\n  }\n\n  object StringListValue {\n    def apply(ss: List[String]): Value =\n      ListValue(ss.map(StringValue(_)))\n\n    def unapply(value: Value): Option[List[String]] =\n      value match {\n        case ListValue(l) => l.traverse {\n          case StringValue(s) => Some(s)\n          case _ => None\n        }\n        case _ => None\n      }\n  }\n\n  /**\n   * Elaborate a value by replacing variable references with their values.\n   */\n  def elaborateValue(value: Value, vars: Vars): Result[Value] = {\n    def loop(value: Value): Result[Value] =\n      value match {\n        case VariableRef(varName) =>\n          Result.fromOption(vars.get(varName).map(_._2), s\"Variable '$varName' is undefined\")\n        case ObjectValue(fields) =>\n          val (keys, values) = fields.unzip\n          values.traverse(loop).map(evs => ObjectValue(keys.zip(evs)))\n        case ListValue(elems) => elems.traverse(loop).map(ListValue.apply)\n        case other => Result(other)\n      }\n    loop(value)\n  }\n\n  /**\n   * Resolve a value against its definition.\n   *\n   * + Absent and null values are defaulted if the InputValue provides a default.\n   * + Absent and null values are checked against the nullability of the InputValue.\n   * + Enum values are checked against the possible values of the EnumType.\n   * + Primitive values are converted to custom Scalars or IDs where appropriate.\n   * + The elements of list values are checked against their element type.\n   * + The fields of input object values are checked against their field definitions.\n   */\n  def checkValue(iv: InputValue, value: Option[Value], location: String): Result[Value] =\n    (iv.tpe.dealias, value) match {\n      case (_, None) if iv.defaultValue.isDefined =>\n        iv.defaultValue.get.success\n      case (_: NullableType, None) =>\n        AbsentValue.success\n      case (_: NullableType, Some(AbsentValue)) =>\n        AbsentValue.success\n      case (_: NullableType, Some(NullValue)) =>\n        NullValue.success\n      case (NullableType(tpe), Some(_)) =>\n        checkValue(iv.copy(tpe = tpe), value, location)\n      case (IntType, Some(value: IntValue)) =>\n        value.success\n      case (FloatType, Some(value: FloatValue)) =>\n        value.success\n      case (StringType, Some(value: StringValue)) =>\n        value.success\n      case (BooleanType, Some(value: BooleanValue)) =>\n        value.success\n\n      // Custom Scalars\n      case (s: ScalarType, Some(value: IntValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: FloatValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: StringValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(value: BooleanValue)) if !s.isBuiltIn =>\n        value.success\n      case (s: ScalarType, Some(enumValue: EnumValue)) if !s.isBuiltIn =>\n        StringValue(enumValue.name).success\n\n      case (IDType, Some(value: IDValue)) =>\n        value.success\n      case (IDType, Some(StringValue(s))) =>\n        IDValue(s).success\n      case (IDType, Some(IntValue(i))) =>\n        IDValue(i.toString).success\n      case (e: EnumType, Some(value@EnumValue(name))) if e.hasValue(name) =>\n        value.success\n      case (ListType(tpe), Some(ListValue(arr))) =>\n        arr.traverse { elem =>\n          checkValue(iv.copy(tpe = tpe, defaultValue = None), Some(elem), location)\n        }.map(ListValue.apply)\n      case (InputObjectType(nme, _, ivs, _), Some(ObjectValue(fs))) =>\n        val obj = fs.toMap\n        val unknownFields = fs.map(_._1).filterNot(f => ivs.exists(_.name == f))\n        if (unknownFields.nonEmpty)\n          Result.failure(s\"Unknown field(s) ${unknownFields.map(s => s\"'$s'\").mkString(\"\", \", \", \"\")} for input object value of type ${nme} in $location\")\n        else\n          ivs.traverse(iv => checkValue(iv, obj.get(iv.name), location).map(v => (iv.name, v))).map(ObjectValue.apply)\n      case (tpe, Some(value)) => Result.failure(s\"Expected $tpe found '${SchemaRenderer.renderValue(value)}' for '${iv.name}' in $location\")\n      case (tpe, None) => Result.failure(s\"Value of type $tpe required for '${iv.name}' in $location\")\n    }\n\n  /**\n   * Resolve a Json variable value against its definition.\n   *\n   * + Absent and null values are defaulted if the InputValue provides a default.\n   * + Absent and null values are checked against the nullability of the InputValue.\n   * + Enum values are checked against the possible values of the EnumType.\n   * + Primitive values are converted to custom Scalars or IDs where appropriate.\n   * + The elements of list values are checked against their element type.\n   * + The fields of input object values are checked against their field definitions.\n   */\n  def checkVarValue(iv: InputValue, value: Option[Json], location: String): Result[Value] = {\n    import JsonExtractor._\n\n    (iv.tpe.dealias, value) match {\n      case (_, None) if iv.defaultValue.isDefined =>\n        iv.defaultValue.get.success\n      case (_: NullableType, None) =>\n        AbsentValue.success\n      case (_: NullableType, Some(jsonNull(_))) =>\n        NullValue.success\n      case (NullableType(tpe), Some(_)) =>\n        checkVarValue(iv.copy(tpe = tpe), value, location)\n      case (IntType, Some(jsonInt(value))) =>\n        IntValue(value).success\n      case (FloatType, Some(jsonDouble(value))) =>\n        FloatValue(value).success\n      case (StringType, Some(jsonString(value))) =>\n        StringValue(value).success\n      case (BooleanType, Some(jsonBoolean(value))) =>\n        BooleanValue(value).success\n      case (IDType, Some(jsonInt(value))) =>\n        IDValue(value.toString).success\n\n      // Custom scalars\n      case (s: ScalarType, Some(jsonInt(value))) if !s.isBuiltIn =>\n        IntValue(value).success\n      case (s: ScalarType, Some(jsonDouble(value))) if !s.isBuiltIn =>\n        FloatValue(value).success\n      case (s: ScalarType, Some(jsonString(value))) if !s.isBuiltIn =>\n        StringValue(value).success\n      case (s: ScalarType, Some(jsonBoolean(value))) if !s.isBuiltIn =>\n        BooleanValue(value).success\n\n      case (IDType, Some(jsonString(value))) =>\n        IDValue(value).success\n      case (e: EnumType, Some(jsonString(name))) if e.hasValue(name) =>\n        EnumValue(name).success\n      case (ListType(tpe), Some(jsonArray(arr))) =>\n        arr.traverse { elem =>\n          checkVarValue(iv.copy(tpe = tpe, defaultValue = None), Some(elem), location)\n        }.map(vs => ListValue(vs.toList))\n      case (InputObjectType(nme, _, ivs, _), Some(jsonObject(obj))) =>\n        val unknownFields = obj.keys.filterNot(f => ivs.exists(_.name == f))\n        if (unknownFields.nonEmpty)\n          Result.failure(s\"Unknown field(s) ${unknownFields.map(s => s\"'$s'\").mkString(\"\", \", \", \"\")} in input object value of type ${nme} in $location\")\n        else\n          ivs.traverse(iv => checkVarValue(iv, obj(iv.name), location).map(v => (iv.name, v))).map(ObjectValue.apply)\n      case (tpe, Some(value)) => Result.failure(s\"Expected $tpe found '$value' for '${iv.name}' in $location\")\n      case (tpe, None) => Result.failure(s\"Value of type $tpe required for '${iv.name}' in $location\")\n    }\n  }\n}\n\n/**\n * The `Directive` type represents a Directive that a server supports.\n *\n * @see https://facebook.github.io/graphql/draft/#sec-The-__Directive-Type\n */\ncase class DirectiveDef(\n  name: String,\n  description: Option[String],\n  args: List[InputValue],\n  isRepeatable: Boolean,\n  locations: List[DirectiveLocation]\n)\n\nobject DirectiveDef {\n  val Skip: DirectiveDef =\n    DirectiveDef(\n      \"skip\",\n      Some(\n        \"\"\"|The @skip directive may be provided for fields, fragment spreads, and inline\n           |fragments, and allows for conditional exclusion during execution as described\n           |by the if argument.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"if\", Some(\"Skipped with true.\"), BooleanType, None, Nil)),\n      false,\n      List(DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT)\n    )\n\n  val Include: DirectiveDef =\n    DirectiveDef(\n      \"include\",\n      Some(\n        \"\"\"|The @include directive may be provided for fields, fragment spreads, and inline\n           |fragments, and allows for conditional inclusion during execution as described\n           |by the if argument.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"if\", Some(\"Included when true.\"), BooleanType, None, Nil)),\n      false,\n      List(DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT)\n    )\n\n  val Deprecated: DirectiveDef =\n    DirectiveDef(\n      \"deprecated\",\n      Some(\n        \"\"\"|The @deprecated directive is used within the type system definition language\n           |to indicate deprecated portions of a GraphQL service\u2019s schema, such as deprecated\n           |fields on a type or deprecated enum values.\n        \"\"\".stripMargin.trim\n      ),\n      List(InputValue(\"reason\", Some(\"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).\"), NullableType(StringType), Some(StringValue(\"No longer supported\")), Nil)),\n      false,\n      List(DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE)\n    )\n\n  val builtIns: List[DirectiveDef] =\n    List(Skip, Include, Deprecated)\n}\n\ncase class Directive(\n  name: String,\n  args: List[Binding]\n)\n\nobject Directive {\n  def fromAst(d: Ast.Directive): Result[Directive] = {\n    val Ast.Directive(Ast.Name(nme), args) = d\n    args.traverse {\n      case (Ast.Name(nme), value) => Value.fromAst(value).map(Binding(nme, _))\n    }.map(Directive(nme, _))\n  }\n\n  def validateDirectivesForSchema(schema: Schema): List[Problem] = {\n    def validateTypeDirectives(tpe: NamedType): List[Problem] =\n      tpe match {\n        case o: ObjectType =>\n          validateDirectives(schema, Ast.DirectiveLocation.OBJECT, o.directives, Map.empty) ++\n          o.fields.flatMap(validateFieldDirectives)\n        case i: InterfaceType =>\n          validateDirectives(schema, Ast.DirectiveLocation.INTERFACE, i.directives, Map.empty) ++\n          i.fields.flatMap(validateFieldDirectives)\n        case u: UnionType =>\n          validateDirectives(schema, Ast.DirectiveLocation.UNION, u.directives, Map.empty)\n        case e: EnumType =>\n          validateDirectives(schema, Ast.DirectiveLocation.ENUM, e.directives, Map.empty) ++\n          e.enumValues.flatMap(v => validateDirectives(schema, Ast.DirectiveLocation.ENUM_VALUE, v.directives, Map.empty))\n        case s: ScalarType =>\n          validateDirectives(schema, Ast.DirectiveLocation.SCALAR, s.directives, Map.empty)\n        case i: InputObjectType =>\n          validateDirectives(schema, Ast.DirectiveLocation.INPUT_OBJECT, i.directives, Map.empty) ++\n          i.inputFields.flatMap(f => validateDirectives(schema, Ast.DirectiveLocation.INPUT_FIELD_DEFINITION, f.directives, Map.empty))\n        case _ => Nil\n      }\n\n    def validateFieldDirectives(field: Field): List[Problem] =\n      validateDirectives(schema, Ast.DirectiveLocation.FIELD_DEFINITION, field.directives, Map.empty) ++\n      field.args.flatMap(a => validateDirectives(schema, Ast.DirectiveLocation.ARGUMENT_DEFINITION, a.directives, Map.empty))\n\n    validateDirectives(schema, Ast.DirectiveLocation.SCHEMA, schema.schemaType.directives, Map.empty) ++\n    (schema.schemaType match {\n      case twf: TypeWithFields => twf.fields.flatMap(validateFieldDirectives)\n      case _ => Nil\n    }) ++\n    schema.types.flatMap(validateTypeDirectives)\n  }\n\n  def validateDirectivesForQuery(schema: Schema, op: UntypedOperation, frags: List[UntypedFragment], vars: Vars): Result[Unit] = {\n    def queryWarnings(query: Query): List[Problem] = {\n      def loop(query: Query): List[Problem] =\n        query match {\n          case UntypedSelect(_, _, _, dirs, child) =>\n            validateDirectives(schema, Ast.DirectiveLocation.FIELD, dirs, vars) ++ loop(child)\n          case UntypedFragmentSpread(_, dirs) =>\n            validateDirectives(schema, Ast.DirectiveLocation.FRAGMENT_SPREAD, dirs, vars)\n          case UntypedInlineFragment(_, dirs, child) =>\n            validateDirectives(schema, Ast.DirectiveLocation.INLINE_FRAGMENT, dirs, vars) ++ loop(child)\n          case Select(_, _, child)       => loop(child)\n          case Group(children)           => children.flatMap(loop)\n          case Narrow(_, child)          => loop(child)\n          case Unique(child)             => loop(child)\n          case Filter(_, child)          => loop(child)\n          case Limit(_, child)           => loop(child)\n          case Offset(_, child)          => loop(child)\n          case OrderBy(_, child)         => loop(child)\n          case Introspect(_, child)      => loop(child)\n          case Environment(_, child)     => loop(child)\n          case Component(_, _, child)    => loop(child)\n          case Effect(_, child)          => loop(child)\n          case TransformCursor(_, child) => loop(child)\n          case Count(_)                  => Nil\n          case Empty                     => Nil\n      }\n\n      loop(query)\n    }\n\n    def operationWarnings(op: UntypedOperation): List[Problem] = {\n      lazy val opLocation = op match {\n        case _: UntypedQuery => Ast.DirectiveLocation.QUERY\n        case _: UntypedMutation => Ast.DirectiveLocation.MUTATION\n        case _: UntypedSubscription => Ast.DirectiveLocation.SUBSCRIPTION\n      }\n\n      val varWarnings = op.variables.flatMap(v => validateDirectives(schema, Ast.DirectiveLocation.VARIABLE_DEFINITION, v.directives, vars))\n      val opWarnings = validateDirectives(schema, opLocation, op.directives, vars)\n      val childWarnings = queryWarnings(op.query)\n      varWarnings ++ opWarnings ++ childWarnings\n    }\n\n    def fragmentWarnings(frag: UntypedFragment): List[Problem] = {\n      val defnWarnings = validateDirectives(schema, Ast.DirectiveLocation.FRAGMENT_DEFINITION, frag.directives, vars)\n      val childWarnings = queryWarnings(frag.child)\n      defnWarnings ++ childWarnings\n    }\n\n    val opWarnings = operationWarnings(op)\n    val fragWarnings = frags.flatMap(fragmentWarnings)\n\n    Result.fromProblems(opWarnings ++ fragWarnings)\n  }\n\n  def validateDirectiveOccurrences(schema: Schema, location: Ast.DirectiveLocation, directives: List[Directive]): List[Problem] = {\n    val (locationProblems, repetitionProblems) =\n      directives.foldLeft((List.empty[Problem], List.empty[Problem])) { case ((locs, reps), directive) =>\n        val nme = directive.name\n        schema.directives.find(_.name == nme) match {\n          case None => (Problem(s\"Undefined directive '$nme'\") :: locs, reps)\n          case Some(defn) =>\n            val locs0 =\n              if (defn.locations.contains(location)) locs\n              else Problem(s\"Directive '$nme' is not allowed on $location\") :: locs\n\n            val reps0 =\n              if (!defn.isRepeatable && directives.count(_.name == nme) > 1)\n                Problem(s\"Directive '$nme' may not occur more than once\") :: reps\n              else reps\n\n            (locs0, reps0)\n        }\n      }\n\n    locationProblems.reverse ++ repetitionProblems.reverse.distinct\n  }\n\n  def validateDirectives(schema: Schema, location: Ast.DirectiveLocation, directives: List[Directive], vars: Vars): List[Problem] = {\n    val occurrenceProblems = validateDirectiveOccurrences(schema, location, directives)\n    val argProblems =\n      directives.flatMap { directive =>\n        val nme = directive.name\n        schema.directives.find(_.name == nme) match {\n          case None => List(Problem(s\"Undefined directive '$nme'\"))\n          case Some(defn) =>\n            val infos = defn.args\n            val unknownArgs = directive.args.filterNot(arg => infos.exists(_.name == arg.name))\n            if (unknownArgs.nonEmpty)\n              List(Problem(s\"Unknown argument(s) ${unknownArgs.map(s => s\"'${s.name}'\").mkString(\"\", \", \", \"\")} in directive $nme\"))\n            else {\n              val argMap = directive.args.groupMapReduce(_.name)(_.value)((x, _) => x)\n              infos.traverse { info =>\n                for {\n                  value <- argMap.get(info.name).traverse(Value.elaborateValue(_, vars))\n                  _     <- checkValue(info, value, s\"directive ${defn.name}\")\n                } yield ()\n              }.toProblems.toList\n            }\n        }\n      }\n\n    occurrenceProblems ++ argProblems\n  }\n\n  def elaborateDirectives(schema: Schema, directives: List[Directive], vars: Vars): Result[List[Directive]] =\n    directives.traverse { directive =>\n      val nme = directive.name\n      schema.directives.find(_.name == nme) match {\n        case None => Result.failure(s\"Undefined directive '$nme'\")\n        case Some(defn) =>\n          val argMap = directive.args.groupMapReduce(_.name)(_.value)((x, _) => x)\n          defn.args.traverse { info =>\n            for {\n              value0 <- argMap.get(info.name).traverse(Value.elaborateValue(_, vars))\n              value1 <- checkValue(info, value0, s\"directive ${defn.name}\")\n            } yield Binding(info.name, value1)\n          }.map(eArgs => directive.copy(args = eArgs))\n      }\n    }\n}\n\n/**\n * GraphQL schema parser\n */\ntrait SchemaParser {\n    def parseText(text: String)(implicit pos: SourcePos): Result[Schema]\n    def parseDocument(doc: Ast.Document)(implicit sourcePos: SourcePos): Result[Schema]\n}\n\nobject SchemaParser {\n  def apply(parser: GraphQLParser): SchemaParser =\n    new Impl(parser)\n\n  private final class Impl(parser: GraphQLParser) extends SchemaParser {\n\n    import Ast.{Directive => _, EnumValueDefinition => _, SchemaExtension => _, Type => _, TypeExtension => _, Value => _, _}\n\n    /**\n    * Parse a query String to a query algebra term.\n    *\n    * Yields a Query value on the right and accumulates errors on the left.\n    */\n    def parseText(text: String)(implicit pos: SourcePos): Result[Schema] =\n      for {\n        doc <- parser.parseText(text)\n        query <- parseDocument(doc)\n      } yield query\n\n    def parseDocument(doc: Document)(implicit sourcePos: SourcePos): Result[Schema] = {\n      object schema extends Schema {\n        var baseTypes: List[NamedType] = Nil\n        var baseSchemaType1: Option[NamedType] = null\n        var pos: SourcePos = sourcePos\n\n        override def baseSchemaType: NamedType = baseSchemaType1.getOrElse(super.baseSchemaType)\n\n        var directives: List[DirectiveDef] = Nil\n        var schemaExtensions: List[SchemaExtension] = Nil\n        var typeExtensions: List[TypeExtension] = Nil\n\n        def complete(types0: List[NamedType], baseSchemaType0: Option[NamedType], directives0: List[DirectiveDef], schemaExtensions0: List[SchemaExtension], typeExtensions0: List[TypeExtension]): Unit = {\n          baseTypes = types0\n          baseSchemaType1 = baseSchemaType0\n          directives = directives0 ++ DirectiveDef.builtIns\n          schemaExtensions = schemaExtensions0\n          typeExtensions = typeExtensions0\n        }\n      }\n\n      val schemaExtnDefns: List[Ast.SchemaExtension] = doc.collect { case tpe: Ast.SchemaExtension => tpe }\n      val typeDefns: List[TypeDefinition] = doc.collect { case tpe: TypeDefinition => tpe }\n      val dirDefns: List[DirectiveDefinition] = doc.collect { case dir: DirectiveDefinition => dir }\n      val extnDefns: List[Ast.TypeExtension] = doc.collect { case tpe: Ast.TypeExtension => tpe }\n\n      for {\n        baseTypes   <- mkTypeDefs(schema, typeDefns)\n        schemaExtns <- mkSchemaExtensions(schema, schemaExtnDefns)\n        typeExtns   <- mkExtensions(schema, extnDefns)\n        directives  <- mkDirectiveDefs(schema, dirDefns)\n        schemaType  <- mkSchemaType(schema, doc)\n        _           =  schema.complete(baseTypes, schemaType, directives, schemaExtns, typeExtns)\n        _           <- Result.fromProblems(SchemaValidator.validateSchema(schema, typeDefns, extnDefns))\n      } yield schema\n    }\n\n    // explicit Schema type, if any\n    def mkSchemaType(schema: Schema, doc: Document): Result[Option[NamedType]] = {\n      def build(dirs: List[Directive], ops: List[Field]): NamedType = {\n        val query = ops.find(_.name == \"query\").getOrElse(Field(\"query\", None, Nil, defaultQueryType, Nil))\n        ObjectType(\n          name = \"Schema\",\n          description = None,\n          fields = query :: List(ops.find(_.name == \"mutation\"), ops.find(_.name == \"subscription\")).flatten,\n          interfaces = Nil,\n          directives = dirs\n        )\n      }\n\n      def defaultQueryType = schema.ref(\"Query\")\n\n      val defns = doc.collect { case schema: SchemaDefinition => schema }\n      defns match {\n        case Nil => None.success\n        case SchemaDefinition(rootOpTpes, dirs0) :: Nil =>\n          for {\n            ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n            dirs <- dirs0.traverse(Directive.fromAst)\n          } yield Some(build(dirs, ops))\n\n        case _ => Result.failure(\"At most one schema definition permitted\")\n      }\n    }\n\n    def mkSchemaExtensions(schema: Schema, extnDefns: List[Ast.SchemaExtension]): Result[List[SchemaExtension]] =\n      extnDefns.traverse(mkSchemaExtension(schema))\n\n    def mkSchemaExtension(schema: Schema)(se: Ast.SchemaExtension): Result[SchemaExtension] = {\n      val Ast.SchemaExtension(rootOpTpes, dirs0) = se\n      for {\n        ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n        dirs <- dirs0.traverse(Directive.fromAst)\n      } yield SchemaExtension(ops, dirs)\n    }\n\n    def mkRootOperation(schema: Schema)(rootTpe: RootOperationTypeDefinition): Result[Field] = {\n      val RootOperationTypeDefinition(optype, tpe, dirs0) = rootTpe\n      for {\n        dirs <- dirs0.traverse(Directive.fromAst)\n        tpe  <- mkType(schema)(tpe)\n        _    <- Result.failure(s\"Root operation types must be named types, found '$tpe'\").whenA(!tpe.nonNull.isNamed)\n      } yield Field(optype.name, None, Nil, tpe, dirs)\n    }\n\n    def mkExtensions(schema: Schema, extnDefns: List[Ast.TypeExtension]): Result[List[TypeExtension]] =\n      extnDefns.traverse(mkExtension(schema))\n\n    def mkExtension(schema: Schema)(ed: Ast.TypeExtension): Result[TypeExtension] =\n      ed match {\n        case ScalarTypeExtension(Ast.Type.Named(Name(name)), dirs0) =>\n          for {\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield ScalarExtension(name, dirs)\n        case InterfaceTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n          for {\n            fields <- fields0.traverse(mkField(schema))\n            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield InterfaceExtension(name, fields, ifs, dirs)\n        case ObjectTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n          for {\n            fields <- fields0.traverse(mkField(schema))\n            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield ObjectExtension(name, fields, ifs, dirs)\n        case UnionTypeExtension(Ast.Type.Named(Name(name)), dirs0, members0) =>\n          for {\n            dirs    <- dirs0.traverse(Directive.fromAst)\n            members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          } yield UnionExtension(name, members, dirs)\n        case EnumTypeExtension(Ast.Type.Named(Name(name)), dirs0, values0) =>\n          for {\n            values  <- values0.traverse(mkEnumValue)\n            dirs    <- dirs0.traverse(Directive.fromAst)\n          } yield EnumExtension(name, values, dirs)\n        case InputObjectTypeExtension(Ast.Type.Named(Name(name)), dirs0, fields0) =>\n          for {\n            fields <- fields0.traverse(mkInputValue(schema))\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield InputObjectExtension(name, fields, dirs)\n      }\n\n    def mkTypeDefs(schema: Schema, defns: List[TypeDefinition]): Result[List[NamedType]] =\n      defns.traverse(mkTypeDef(schema))\n\n    def mkTypeDef(schema: Schema)(td: TypeDefinition): Result[NamedType] = td match {\n      case ScalarTypeDefinition(Name(\"Int\"), _, _) => IntType.success\n      case ScalarTypeDefinition(Name(\"Float\"), _, _) => FloatType.success\n      case ScalarTypeDefinition(Name(\"String\"), _, _) => StringType.success\n      case ScalarTypeDefinition(Name(\"Boolean\"), _, _) => BooleanType.success\n      case ScalarTypeDefinition(Name(\"ID\"), _, _) => IDType.success\n      case ScalarTypeDefinition(Name(nme), desc, dirs0) =>\n        for {\n          dirs <- dirs0.traverse(Directive.fromAst)\n        } yield ScalarType(nme, desc, dirs)\n      case ObjectTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n        if (fields0.isEmpty) Result.failure(s\"object type $nme must define at least one field\")\n        else\n          for {\n            fields <- fields0.traverse(mkField(schema))\n            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield ObjectType(nme, desc, fields, ifs, dirs)\n      case InterfaceTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n        if (fields0.isEmpty) Result.failure(s\"interface type $nme must define at least one field\")\n        else\n          for {\n            fields <- fields0.traverse(mkField(schema))\n            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield InterfaceType(nme, desc, fields, ifs, dirs)\n      case UnionTypeDefinition(Name(nme), desc, dirs0, members0) =>\n        if (members0.isEmpty) Result.failure(s\"union type $nme must define at least one member\")\n        else {\n          for {\n            dirs    <- dirs0.traverse(Directive.fromAst)\n            members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n          } yield UnionType(nme, desc, members, dirs)\n        }\n      case EnumTypeDefinition(Name(nme), desc, dirs0, values0) =>\n        if (values0.isEmpty) Result.failure(s\"enum type $nme must define at least one enum value\")\n        else\n          for {\n            values <- values0.traverse(mkEnumValue)\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield EnumType(nme, desc, values, dirs)\n      case InputObjectTypeDefinition(Name(nme), desc, fields0, dirs0) =>\n        if (fields0.isEmpty) Result.failure(s\"input object type $nme must define at least one input field\")\n        else\n          for {\n            fields <- fields0.traverse(mkInputValue(schema))\n            dirs   <- dirs0.traverse(Directive.fromAst)\n          } yield InputObjectType(nme, desc, fields, dirs)\n    }\n\n    def mkField(schema: Schema)(f: FieldDefinition): Result[Field] = {\n      val FieldDefinition(Name(nme), desc, args0, tpe0, dirs0) = f\n      for {\n        args <- args0.traverse(mkInputValue(schema))\n        tpe  <- mkType(schema)(tpe0)\n        dirs <- dirs0.traverse(Directive.fromAst)\n      } yield Field(nme, desc, args, tpe, dirs)\n    }\n\n    def mkType(schema: Schema)(tpe: Ast.Type): Result[Type] = {\n      def loop(tpe: Ast.Type, nullable: Boolean): Result[Type] = {\n        def wrap(tpe: Type): Type = if (nullable) NullableType(tpe) else tpe\n\n        tpe match {\n          case Ast.Type.List(tpe) => loop(tpe, true).map(tpe => wrap(ListType(tpe)))\n          case Ast.Type.NonNull(Left(tpe)) => loop(tpe, false)\n          case Ast.Type.NonNull(Right(tpe)) => loop(tpe, false)\n          case Ast.Type.Named(Name(nme)) => wrap(ScalarType.builtIn(nme).getOrElse(schema.ref(nme))).success\n        }\n      }\n\n      loop(tpe, true)\n    }\n\n    def mkDirectiveDefs(schema: Schema, defns: List[DirectiveDefinition]): Result[List[DirectiveDef]] =\n      defns.traverse(mkDirectiveDef(schema))\n\n    def mkDirectiveDef(schema: Schema)(dd: DirectiveDefinition): Result[DirectiveDef] = {\n      val DirectiveDefinition(Name(nme), desc, args0, repeatable, locations) = dd\n      for {\n        args <- args0.traverse(mkInputValue(schema))\n      } yield DirectiveDef(nme, desc, args, repeatable, locations)\n    }\n\n    def mkInputValue(schema: Schema)(f: InputValueDefinition): Result[InputValue] = {\n      val InputValueDefinition(Name(nme), desc, tpe0, default0, dirs0) = f\n      for {\n        tpe <- mkType(schema)(tpe0)\n        dflt <- default0.traverse(Value.fromAst)\n        dirs <- dirs0.traverse(Directive.fromAst)\n      } yield InputValue(nme, desc, tpe, dflt, dirs)\n    }\n\n    def mkEnumValue(e: Ast.EnumValueDefinition): Result[EnumValueDefinition] = {\n      val Ast.EnumValueDefinition(Name(nme), desc, dirs0) = e\n      for {\n        dirs <- dirs0.traverse(Directive.fromAst)\n      } yield EnumValueDefinition(nme, desc, dirs)\n    }\n  }\n}\n\nobject SchemaValidator {\n  import SchemaRenderer.renderType\n\n  def validateSchema(schema: Schema, defns: List[TypeDefinition], typeExtnDefns: List[Ast.TypeExtension]): List[Problem] =\n    validateReferences(schema, defns) ++\n    validateUniqueDefns(schema) ++\n    validateUniqueFields(schema) ++\n    validateUnionMembers(schema) ++\n    validateUniqueEnumValues(schema) ++\n    validateImplementations(schema) ++\n    validateTypeExtensions(defns, typeExtnDefns) ++\n    Directive.validateDirectivesForSchema(schema)\n\n  def validateReferences(schema: Schema, defns: List[TypeDefinition]): List[Problem] = {\n    def underlyingName(tpe: Ast.Type): String =\n      tpe match {\n        case Ast.Type.List(tpe) => underlyingName(tpe)\n        case Ast.Type.NonNull(Left(tpe)) => underlyingName(tpe)\n        case Ast.Type.NonNull(Right(tpe)) => underlyingName(tpe)\n        case Ast.Type.Named(Ast.Name(nme)) => nme\n      }\n\n    def referencedTypes(defns: List[TypeDefinition]): List[String] = {\n      defns.flatMap {\n        case ObjectTypeDefinition(_, _, fields, _, _) =>\n          (fields.flatMap(_.args.map(_.tpe)) ++ fields.map(_.tpe)).map(underlyingName)\n        case InterfaceTypeDefinition(_, _, fields, _, _) =>\n          (fields.flatMap(_.args.map(_.tpe)) ++ fields.map(_.tpe)).map(underlyingName)\n        case u: UnionTypeDefinition =>\n          u.members.map(underlyingName)\n        case _ => Nil\n      }\n    }\n\n    val defaultTypes = List(StringType, IntType, FloatType, BooleanType, IDType)\n    val typeNames = (defaultTypes ++ schema.types).map(_.name).toSet\n\n    referencedTypes(defns).collect {\n      case tpe if !typeNames.contains(tpe) => Problem(s\"Reference to undefined type '$tpe'\")\n    }\n  }\n\n  def validateUniqueDefns(schema: Schema): List[Problem] = {\n    val dupes = schema.types.groupBy(_.name).collect {\n      case (nme, tpes) if tpes.length > 1 => nme\n    }.toSet\n\n    schema.types.map(_.name).distinct.collect {\n      case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of type '$nme' found\")\n    }\n  }\n\n  def validateUniqueFields(schema: Schema): List[Problem] = {\n    val withFields = schema.types.collect {\n      case wf: TypeWithFields => wf\n    }\n\n    val inputObjs = schema.types.collect {\n      case io: InputObjectType => io\n    }\n\n    withFields.flatMap { tpe =>\n      val dupes = tpe.fields.groupBy(_.name).collect {\n        case (nme, fields) if fields.length > 1 => nme\n      }.toSet\n\n      tpe.fields.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of field '$nme' for type '${tpe.name}'\")\n      }\n    } ++\n    inputObjs.flatMap { tpe =>\n      val dupes = tpe.inputFields.groupBy(_.name).collect {\n        case (nme, fields) if fields.length > 1 => nme\n      }.toSet\n\n      tpe.inputFields.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of field '$nme' for type '${tpe.name}'\")\n      }\n    }\n  }\n\n  def validateUnionMembers(schema: Schema): List[Problem] = {\n    val unions = schema.types.collect {\n      case u: UnionType => u\n    }\n\n    unions.flatMap { tpe =>\n      val dupes = tpe.members.groupBy(_.name).collect {\n        case (nme, vs) if vs.length > 1 => nme\n      }.toSet\n\n      tpe.members.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate inclusion of union member '$nme' for type '${tpe.name}'\")\n      } ++\n      tpe.members.flatMap { member =>\n        schema.definition(member.name) match {\n          case None => List(Problem(s\"Undefined type '${member.name}' included in union '${tpe.name}'\"))\n          case Some(mtpe) =>\n            mtpe match {\n              case (_: ObjectType) | (_: InterfaceType) => Nil\n              case _ => List(Problem(s\"Non-object type '${member.name}' included in union '${tpe.name}'\"))\n            }\n        }\n      }\n    }\n  }\n\n  def validateUniqueEnumValues(schema: Schema): List[Problem] = {\n    val enums = schema.types.collect {\n      case e: EnumType => e\n    }\n\n    enums.flatMap { tpe =>\n      val dupes = tpe.enumValues.groupBy(_.name).collect {\n        case (nme, vs) if vs.length > 1 => nme\n      }.toSet\n\n      tpe.enumValues.map(_.name).distinct.collect {\n        case nme if dupes.contains(nme) => Problem(s\"Duplicate definition of enum value '$nme' for type '${tpe.name}'\")\n      }\n    }\n  }\n\n  def validateImplementations(schema: Schema): List[Problem] = {\n\n    def validateImplementor(impl: TypeWithFields): List[Problem] = {\n      import impl.{name, fields, interfaces}\n\n      interfaces.flatMap(_.dealias match {\n        case iface: InterfaceType =>\n          iface.fields.flatMap { ifField =>\n            fields.find(_.name == ifField.name).map { implField =>\n              val ifTpe = ifField.tpe\n              val implTpe = implField.tpe\n\n              val rp =\n                if (implTpe <:< ifTpe) Nil\n                else List(Problem(s\"Field '${implField.name}' of type '$name' has type '${renderType(implTpe)}', however implemented interface '${iface.name}' requires it to be a subtype of '${renderType(ifTpe)}'\"))\n\n              val argsMatch =\n                implField.args.corresponds(ifField.args) { case (arg0, arg1) =>\n                  arg0.name == arg1.name && arg0.tpe == arg1.tpe\n                }\n\n              val ap =\n                if (argsMatch) Nil\n                else List(Problem(s\"Field '${implField.name}' of type '$name' has has an argument list that does not conform to that specified by implemented interface '${iface.name}'\"))\n\n              rp ++ ap\n            }.getOrElse(List(Problem(s\"Field '${ifField.name}' from interface '${iface.name}' is not defined by implementing type '$name'\")))\n          }\n        case undefined: TypeRef =>\n          List(Problem(s\"Undefined type '${undefined.name}' declared as implemented by type '$name'\"))\n        case other =>\n          List(Problem(s\"Non-interface type '${other.name}' declared as implemented by type '$name'\"))\n      })\n    }\n\n    val impls = schema.types.collect { case impl: TypeWithFields => impl }\n    impls.flatMap(validateImplementor)\n  }\n\n  def validateTypeExtensions(defns: List[TypeDefinition], extnDefns: List[Ast.TypeExtension]): List[Problem] = {\n    extnDefns.mapFilter { extension =>\n      val notFound = Some(Problem(s\"Unable apply extension to non-existent ${extension.baseType.name}\"))\n      defns.find(_.name == extension.baseType.astName).fold[Option[Problem]](notFound) { baseType =>\n        def wrongTypeExtended(typ: String) = Problem(s\"Attempted to apply $typ extension to ${baseType.name.value} but it is not a $typ\").some\n\n        extension match {\n          case _: Ast.ScalarTypeExtension =>\n            baseType match {\n              case _: Ast.ScalarTypeDefinition => None\n              case _ => wrongTypeExtended(\"Scalar\")\n          }\n          case _: Ast.InterfaceTypeExtension =>\n            baseType match {\n              case _: Ast.InterfaceTypeDefinition => None\n              case _ => wrongTypeExtended(\"Interface\")\n            }\n          case _: Ast.ObjectTypeExtension =>\n            baseType match {\n              case _: Ast.ObjectTypeDefinition => None\n              case _ => wrongTypeExtended(\"Object\")\n            }\n          case _: Ast.UnionTypeExtension =>\n            baseType match {\n              case _: Ast.UnionTypeDefinition => None\n              case _ => wrongTypeExtended(\"Union\")\n            }\n          case _: Ast.EnumTypeExtension =>\n            baseType match {\n              case _: Ast.EnumTypeDefinition => None\n              case _ => wrongTypeExtended(\"Enum\")\n            }\n          case _: Ast.InputObjectTypeExtension =>\n            baseType match {\n              case _: Ast.InputObjectTypeDefinition => None\n              case _ => wrongTypeExtended(\"Input Object\")\n            }\n        }\n      }\n    }\n  }\n}\n\nobject SchemaRenderer {\n  def renderSchema(schema: Schema): String = {\n    val schemaDefn = {\n      val dirs0 = schema.baseSchemaType.directives\n      if (\n        schema.queryType.name == \"Query\" &&\n        schema.mutationType.forall(_.name == \"Mutation\") &&\n        schema.subscriptionType.forall(_.name == \"Subscription\") &&\n        dirs0.isEmpty\n      ) \"\"\n      else {\n        val fields =\n          schema.baseSchemaType match {\n            case twf: TypeWithFields => twf.fields.map(renderField)\n            case _ => Nil\n          }\n\n        val dirs = renderDirectives(dirs0)\n        fields.mkString(s\"schema$dirs {\\n  \", \"\\n  \", \"\\n}\\n\")\n      }\n    }\n\n    val schemaExtnDefns =\n      if(schema.schemaExtensions.isEmpty) \"\"\n      else \"\\n\"+schema.schemaExtensions.map(renderSchemaExtension).mkString(\"\\n\")\n\n    val typeExtnDefns =\n      if(schema.typeExtensions.isEmpty) \"\"\n      else \"\\n\"+schema.typeExtensions.map(renderTypeExtension).mkString(\"\\n\")\n\n    val dirDefns = {\n      val nonBuiltInDefns =\n        schema.directives.filter {\n          case DirectiveDef(\"skip\"|\"include\"|\"deprecated\", _, _, _, _) => false\n          case _ => true\n        }\n\n      if(nonBuiltInDefns.isEmpty) \"\"\n      else \"\\n\"+nonBuiltInDefns.map(renderDirectiveDefn).mkString(\"\\n\")+\"\\n\"\n    }\n\n    schemaDefn ++\n      schema.baseTypes.map(renderTypeDefn).mkString(\"\\n\") ++\n      schemaExtnDefns ++\n      typeExtnDefns ++\n      dirDefns\n  }\n\n  def renderDescription(desc: Option[String]): String =\n    desc match {\n      case None => \"\"\n      case Some(desc) => s\"\"\"\"$desc\"\\n\"\"\"\n    }\n\n  def renderDirectives(dirs: List[Directive]): String =\n    if (dirs.isEmpty) \"\" else dirs.map(renderDirective).mkString(\" \", \" \", \"\")\n\n  def renderDirective(d: Directive): String = {\n    val Directive(name, args0) = d\n    val args = if(args0.isEmpty) \"\" else args0.map { case Binding(nme, v) => s\"$nme: ${renderValue(v)}\" }.mkString(\"(\", \", \", \")\")\n    s\"@$name$args\"\n  }\n\n  def renderField(f: Field): String = {\n    val Field(nme, _, args, tpe, dirs0) = f\n    val dirs = renderDirectives(dirs0)\n    if (args.isEmpty)\n      s\"$nme: ${renderType(tpe)}$dirs\"\n    else\n      s\"$nme(${args.map(renderInputValue).mkString(\", \")}): ${renderType(tpe)}$dirs\"\n  }\n\n  def renderSchemaExtension(extension: SchemaExtension): String = {\n    val SchemaExtension(ops0, dirs0) = extension\n    val dirs = renderDirectives(dirs0)\n    val ops =\n      if (ops0.isEmpty) \"\"\n      else\n        s\"\"\"| {\n            |  ${ops0.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n    s\"extend schema$dirs$ops\"\n  }\n\n  def renderTypeExtension(extension: TypeExtension): String = {\n    extension match {\n      case ScalarExtension(nme, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"extend scalar $nme$dirs\"\n\n      case ObjectExtension(nme, fields0, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderField).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend type $nme$ifs$dirs$fields\"\n\n      case InterfaceExtension(nme, fields0, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderField).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend interface $nme$ifs$dirs$fields\"\n\n      case UnionExtension(nme, members0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val members =\n          if(members0.isEmpty) \"\"\n          else s\" = ${members0.map(_.name).mkString(\" | \")}\"\n\n        s\"extend union $nme$dirs$members\"\n\n      case EnumExtension(nme, values0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val values =\n          if(values0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${values0.map(renderEnumValueDefinition).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend enum $nme$dirs$values\"\n\n      case InputObjectExtension(nme, fields0, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        val fields =\n          if(fields0.isEmpty) \"\"\n          else \n            s\"\"\"| {\n                |  ${fields0.map(renderInputValue).mkString(\"\\n  \")}\n                |}\"\"\".stripMargin\n\n        s\"extend input $nme$dirs$fields\"\n    }\n  }\n\n  def renderTypeDefn(tpe: NamedType): String = {\n    tpe match {\n      case tr: TypeRef => renderTypeDefn(tr.dealias)\n\n      case ScalarType(nme, _, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"scalar $nme$dirs\"\"\"\n\n      case ObjectType(nme, _, fields, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n\n        s\"\"\"|type $nme$ifs$dirs {\n            |  ${fields.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case InterfaceType(nme, _, fields, ifs0, dirs0) =>\n        val ifs = if (ifs0.isEmpty) \"\" else \" implements \" + ifs0.map(_.name).mkString(\"&\")\n        val dirs = renderDirectives(dirs0)\n\n        s\"\"\"|interface $nme$ifs$dirs {\n            |  ${fields.map(renderField).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case UnionType(nme, _, members, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"union $nme$dirs = ${members.map(_.name).mkString(\" | \")}\"\"\"\n\n      case EnumType(nme, _, values, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"|enum $nme$dirs {\n            |  ${values.map(renderEnumValueDefinition).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n\n      case InputObjectType(nme, _, fields, dirs0) =>\n        val dirs = renderDirectives(dirs0)\n        s\"\"\"|input $nme$dirs {\n            |  ${fields.map(renderInputValue).mkString(\"\\n  \")}\n            |}\"\"\".stripMargin\n    }\n  }\n\n  def renderType(tpe: Type): String = {\n    def loop(tpe: Type, nullable: Boolean): String = {\n      def wrap(tpe: String) = if (nullable) tpe else s\"$tpe!\"\n\n      tpe match {\n        case NullableType(tpe) => loop(tpe, true)\n        case ListType(tpe) => wrap(s\"[${loop(tpe, false)}]\")\n        case nt: NamedType => wrap(nt.name)\n      }\n    }\n\n    loop(tpe, false)\n  }\n\n  def renderDirectiveDefn(directive: DirectiveDef): String = {\n     val DirectiveDef(nme, desc, args, repeatable, locations) = directive\n     val rpt = if (repeatable) \" repeatable\" else \"\"\n     if (args.isEmpty)\n       s\"${renderDescription(desc)}directive @$nme$rpt on ${locations.mkString(\"|\")}\"\n     else\n       s\"${renderDescription(desc)}directive @$nme(${args.map(renderInputValue).mkString(\", \")})$rpt on ${locations.mkString(\"|\")}\"\n  }\n\n  def renderEnumValueDefinition(v: EnumValueDefinition): String = {\n    val EnumValueDefinition(nme, _, dirs0) = v\n    val dirs = renderDirectives(dirs0)\n    s\"$nme$dirs\"\n  }\n\n  def renderInputValue(iv: InputValue): String = {\n    val InputValue(nme, _, tpe, default, dirs0) = iv\n    val dirs = renderDirectives(dirs0)\n    val df = default.map(v => s\" = ${renderValue(v)}\").getOrElse(\"\")\n    s\"$nme: ${renderType(tpe)}$df$dirs\"\n  }\n\n  def renderValue(value: Value): String = value match {\n    case IntValue(i) => i.toString\n    case FloatValue(f) => f.toString\n    case StringValue(s) => s\"\"\"\"$s\"\"\"\"\n    case BooleanValue(b) => b.toString\n    case IDValue(i) => s\"\"\"\"$i\"\"\"\"\n    case EnumValue(e) => e\n    case ListValue(elems) => elems.map(renderValue).mkString(\"[\", \", \", \"]\")\n    case ObjectValue(fields) =>\n      fields.map {\n        case (name, value) => s\"$name : ${renderValue(value)}\"\n      }.mkString(\"{\", \", \", \"}\")\n    case _ => \"null\"\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.data.NonEmptyChain\nimport cats.implicits._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Predicate._, Value._, UntypedOperation._\nimport QueryCompiler._, ComponentElaborator.TrivialJoin\n\nfinal class CompilerSuite extends CatsEffectSuite {\n  val queryParser = QueryParser(GraphQLParser(GraphQLParser.defaultConfig.copy(terseError = false)))\n\n  test(\"simple query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple mutation\") {\n    val query = \"\"\"\n      mutation {\n        update_character(id: \"1000\", name: \"Luke\") {\n          character {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"update_character\", None, List(Binding(\"id\", StringValue(\"1000\")), Binding(\"name\", StringValue(\"Luke\"))), Nil,\n        UntypedSelect(\"character\", None, Nil, Nil,\n          UntypedSelect(\"name\", None, Nil, Nil, Empty)\n        )\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedMutation(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple subscription\") {\n    val query = \"\"\"\n      subscription {\n        character(id: \"1000\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedSubscription(None, expected, Nil, Nil))))\n  }\n\n  test(\"simple nested query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n          friends {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"character\", None, List(Binding(\"id\", StringValue(\"1000\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n          UntypedSelect(\n            \"friends\", None, Nil, Nil,\n            UntypedSelect(\"name\", None, Nil, Nil, Empty)\n          )\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"hero\", None, List(Binding(\"episode\", EnumValue(\"NEWHOPE\"))), Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n        UntypedSelect(\"friends\", None, Nil, Nil,\n          UntypedSelect(\"name\", None, Nil, Nil, Empty) ~\n          UntypedSelect(\"friends\", None, Nil, Nil,\n            UntypedSelect(\"name\", None, Nil, Nil, Empty)\n          )\n        )\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"user\", None, List(Binding(\"id\", IntValue(4))), Nil,\n        Group(List(\n          UntypedSelect(\"id\", None, Nil, Nil, Empty),\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"profilePic\", Some(\"smallPic\"), List(Binding(\"size\", IntValue(64))), Nil, Empty),\n          UntypedSelect(\"profilePic\", Some(\"bigPic\"), List(Binding(\"size\", IntValue(1024))), Nil, Empty)\n        ))\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n  }\n\n  test(\"introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\n        \"__schema\", None, Nil, Nil,\n        UntypedSelect(\"queryType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty)) ~\n        UntypedSelect(\"mutationType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty)) ~\n        UntypedSelect(\"subscriptionType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty))\n      )\n\n    val res = queryParser.parseText(query).map(_._1)\n    assertEquals(res, Result.Success(List(UntypedQuery(Some(\"IntrospectionQuery\"), expected, Nil, Nil))))\n  }\n\n  test(\"simple selector elaborated query\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name\n          friends {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Select(\n        \"character\", None,\n        Unique(\n          Filter(Eql(AtomicMapping.CharacterType / \"id\", Const(\"1000\")),\n          Select(\"name\") ~\n              Select(\n                \"friends\",\n                Select(\"name\")\n              )\n          )\n        )\n    )\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res.map(_.query), Result.Success(expected))\n  }\n\n  test(\"invalid: object subselection set empty\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\")\n      }\n    \"\"\"\n\n    val expected = Problem(\"Non-leaf field 'character' of Query must have a non-empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: object subselection set invalid\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          foo\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"No field 'foo' for type Character\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: leaf subselection set not empty (1)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name {\n            __typename\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Leaf field 'name' of Character must have an empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: leaf subselection set not empty (2)\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\") {\n          name {\n            foo\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Leaf field 'name' of Character must have an empty subselection set\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"invalid: bogus field argument\") {\n    val query = \"\"\"\n      query {\n        character(id: \"1000\", quux: 23) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Unknown argument(s) 'quux' in field character of type Query\")\n\n    val res = AtomicMapping.compiler.compile(query)\n\n    assertEquals(res, Result.Failure(NonEmptyChain(expected)))\n  }\n\n  test(\"simple component elaborated query\") {\n    val query = \"\"\"\n      query {\n        componenta {\n          fielda1\n          fielda2 {\n            componentb {\n              fieldb1\n              fieldb2 {\n                componentc {\n                  fieldc1\n                }\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Component(ComponentA, TrivialJoin,\n        Select(\"componenta\",\n          Select(\"fielda1\") ~\n          Select(\"fielda2\",\n            Component(ComponentB, TrivialJoin,\n              Select(\"componentb\",\n                Select(\"fieldb1\") ~\n                Select(\"fieldb2\",\n                  Component(ComponentC, TrivialJoin,\n                    Select(\"componentc\",\n                      Select(\"fieldc1\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n\n    val res = ComposedMapping.compiler.compile(query)\n\n    assertEquals(res.map(_.query), Result.Success(expected))\n  }\n\n  test(\"malformed query (1)\") {\n    val query =\n      \"\"\"|query {\n         |  character(id: \"1000\" {\n         |    name\n         |  }\n         |}\"\"\".stripMargin\n\n    val expected =\n      \"\"\"|query {\n         |  character(id: \"1000\" {\n         |                       ^\n         |expectation:\n         |* must be char: ')'\n         |    name\n         |  }\"\"\".stripMargin\n\n    val res = queryParser.parseText(query)\n\n    assertEquals(res, Result.failure(expected))\n  }\n\n  test(\"malformed query (2)\") {\n    val query = \"\"\n\n    val res = queryParser.parseText(query)\n\n    assertEquals(res, Result.failure(\"At least one operation required\"))\n  }\n\n  test(\"malformed query (3)\") {\n    val query =\n      \"\"\"|query {\n         |  character(id: \"1000\") {\n         |    name\n         |  }\"\"\".stripMargin\n\n    val expected =\n      \"\"\"|...\n         |  character(id: \"1000\") {\n         |    name\n         |  }\n         |   ^\n         |expectation:\n         |* must be char: '}'\"\"\".stripMargin\n\n    val res = queryParser.parseText(query)\n    //println(res.toProblems.toList.head.message)\n\n    assertEquals(res, Result.failure(expected))\n  }\n}\n\nobject AtomicMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        character(id: String!): Character\n      }\n      type Character {\n        id: String!\n        name: String\n        friends: [Character!]\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val CharacterType = schema.ref(\"Character\")\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"character\", List(Binding(\"id\", StringValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(CharacterType / \"id\", Const(id)), child)))\n  }\n}\ntrait DummyComponent extends TestMapping {\n  val schema = schema\"type Query { dummy: Int }\"\n}\n\nobject ComponentA extends DummyComponent\nobject ComponentB extends DummyComponent\nobject ComponentC extends DummyComponent\n\nobject ComposedMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        componenta: ComponentA!\n      }\n      type ComponentA {\n        fielda1: String!\n        fielda2: FieldA2\n      }\n      type FieldA2 {\n        componentb: ComponentB\n      }\n      type ComponentB {\n        fieldb1: String!\n        fieldb2: FieldB2\n      }\n      type FieldB2 {\n        componentc: ComponentC\n      }\n      type ComponentC {\n        fieldc1: Int\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val FieldA2Type = schema.ref(\"FieldA2\")\n  val FieldB2Type = schema.ref(\"FieldB2\")\n\n  override val typeMappings =\n    List(\n      ObjectMapping(\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            Delegate(\"componenta\", ComponentA)\n          )\n      ),\n      ObjectMapping(\n        tpe = FieldA2Type,\n        fieldMappings =\n          List(\n            Delegate(\"componentb\", ComponentB)\n          )\n      ),\n      ObjectMapping(\n        tpe = FieldB2Type,\n        fieldMappings =\n          List(\n            Delegate(\"componentc\", ComponentC)\n          )\n      )\n    )\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Ast.DirectiveLocation._\nimport Query._\n\nfinal class DirectivesSuite extends CatsEffectSuite {\n  val schemaParser = SchemaParser(GraphQLParser(GraphQLParser.defaultConfig))\n\n  def testDirectiveDefs(s: Schema): List[DirectiveDef] =\n    s.directives.filter {\n      case DirectiveDef(\"skip\"|\"include\"|\"deprecated\", _, _, _, _) => false\n      case _ => true\n    }\n\n  test(\"Simple directive definition\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with description\") {\n    val expected = DirectiveDef(\"foo\", Some(\"A directive\"), Nil, false, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        \"A directive\"\n        directive @foo on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with multiple locations (1)\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD, FRAGMENT_SPREAD, INLINE_FRAGMENT))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with multiple locations (2)\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, false, List(FIELD, FRAGMENT_SPREAD, INLINE_FRAGMENT))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo on | FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with repeatable\") {\n    val expected = DirectiveDef(\"foo\", None, Nil, true, List(FIELD))\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo repeatable on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with arguments (1)\") {\n    val expected =\n      DirectiveDef(\n        \"foo\",\n        None,\n        List(InputValue(\"arg\", None, ScalarType.StringType, None, Nil)),\n        false,\n        List(FIELD)\n      )\n\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo(arg: String!) on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Directive definition with arguments (2)\") {\n    val expected =\n      DirectiveDef(\n        \"foo\",\n        None,\n        List(\n          InputValue(\"arg0\", None, ScalarType.StringType, None, Nil),\n          InputValue(\"arg1\", None, NullableType(ScalarType.IntType), None, Nil)\n        ),\n        false,\n        List(FIELD)\n      )\n\n    val schema =\n      Schema(\"\"\"\n        type Query {\n          foo: Int\n        }\n\n        directive @foo(arg0: String!, arg1: Int) on FIELD\n      \"\"\")\n\n    assertEquals(schema.map(testDirectiveDefs), List(expected).success)\n  }\n\n  test(\"Schema with directives\") {\n    val schema =\n    \"\"\"|schema @foo {\n       |  query: Query\n       |}\n       |scalar Scalar @foo\n       |interface Interface @foo {\n       |  field(e: Enum, i: Input): Int @foo\n       |}\n       |type Object implements Interface @foo {\n       |  field(e: Enum, i: Input): Int @foo\n       |}\n       |union Union @foo = Object\n       |enum Enum @foo {\n       |  VALUE @foo\n       |}\n       |input Input @foo {\n       |  field: Int @foo\n       |}\n       |directive @foo on SCHEMA|SCALAR|OBJECT|FIELD_DEFINITION|ARGUMENT_DEFINITION|INTERFACE|UNION|ENUM|ENUM_VALUE|INPUT_OBJECT|INPUT_FIELD_DEFINITION\n       |\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"Query with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.QueryType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|query @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Mutation with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.MutationType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|mutation @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Subscription with directive\") {\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, List(Directive(\"dir\", Nil)),\n          UntypedSelect(\"id\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n        ),\n        DirectiveMapping.SubscriptionType,\n        List(Directive(\"dir\", Nil))\n      )\n\n    val query =\n      \"\"\"|subscription @dir {\n         |  foo @dir {\n         |    id @dir\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Fragment with directive\") { // TOD: will need new elaborator to expose fragment directives\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, Nil,\n          Narrow(DirectiveMapping.BazType,\n            UntypedSelect(\"baz\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n          )\n        ),\n        DirectiveMapping.QueryType,\n        Nil\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    ... Frag @dir\n         |  }\n         |}\n         |fragment Frag on Baz @dir {\n         |  baz @dir\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Inline fragment with directive\") { // TOD: will need new elaborator to expose fragment directives\n    val expected =\n      Operation(\n        UntypedSelect(\"foo\", None, Nil, Nil,\n          Narrow(DirectiveMapping.BazType,\n            UntypedSelect(\"baz\", None, Nil, List(Directive(\"dir\", Nil)), Empty)\n          )\n        ),\n        DirectiveMapping.QueryType,\n        Nil\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    ... on Baz @dir {\n         |      baz @dir\n         |    }\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = DirectiveMapping.compiler.compile(query)\n\n    assertEquals(res, expected.success)\n  }\n}\n\nobject DirectiveMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        foo: Bar\n      }\n      type Mutation {\n        foo: Bar\n      }\n      type Subscription {\n        foo: Bar\n      }\n      interface Bar {\n        id: ID\n      }\n      type Baz implements Bar {\n        id: ID\n        baz: Int\n      }\n      directive @dir on QUERY|MUTATION|SUBSCRIPTION|FIELD|FRAGMENT_DEFINITION|FRAGMENT_SPREAD|INLINE_FRAGMENT\n    \"\"\"\n\n  val QueryType = schema.queryType\n  val MutationType = schema.mutationType.get\n  val SubscriptionType = schema.subscriptionType.get\n  val BazType = schema.ref(\"Baz\")\n\n  override val selectElaborator = PreserveArgsElaborator\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.effect.IO\nimport cats.implicits._\nimport io.circe.Json\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Predicate._, Value._\nimport QueryCompiler._\n\nfinal class FragmentSuite extends CatsEffectSuite {\n  def runOperation(op: Result[Operation]): IO[List[Json]] = {\n    val op0 = op.toOption.get\n    FragmentMapping.interpreter.run(op0.query, op0.rootTpe, Env.empty).evalMap(FragmentMapping.mkResponse).compile.toList\n  }\n\n  test(\"simple fragment query\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Group(List(\n              Select(\"friends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              ),\n              Select(\"mutualFriends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              )\n            ))\n          )\n        )\n    )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ],\n            \"mutualFriends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"nested fragment query\") {\n    val query = \"\"\"\n      query withNestedFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        ...standardProfilePic\n      }\n\n      fragment standardProfilePic on User {\n        profilePic\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Group(List(\n              Select(\"friends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              ),\n              Select(\"mutualFriends\",\n                Group(List(\n                  Select(\"id\"),\n                  Select(\"name\"),\n                  Select(\"profilePic\")\n                ))\n              )\n            ))\n          )\n        )\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ],\n            \"mutualFriends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"typed fragment query\") {\n    val query = \"\"\"\n      query FragmentTyping {\n        profiles {\n          id\n          __typename\n          ...userFragment\n          ...pageFragment\n        }\n      }\n\n      fragment userFragment on User {\n        name\n      }\n\n      fragment pageFragment on Page {\n        title\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Select(\"profiles\",\n        Group(List(\n          Select(\"id\"),\n          Introspect(FragmentMapping.schema, Select(\"__typename\")),\n          Narrow(User, Select(\"name\")),\n          Narrow(Page, Select(\"title\"))\n        ))\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"profiles\" : [\n            {\n              \"id\" : \"1\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Alice\"\n            },\n            {\n              \"id\" : \"2\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Bob\"\n            },\n            {\n              \"id\" : \"3\",\n              \"__typename\" : \"User\",\n              \"name\" : \"Carol\"\n            },\n            {\n              \"id\" : \"4\",\n              \"__typename\" : \"Page\",\n              \"title\" : \"GraphQL\"\n            },\n            {\n              \"id\" : \"5\",\n              \"__typename\" : \"Page\",\n              \"title\" : \"Scala\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"inline fragment query\") {\n    val query = \"\"\"\n      query inlineFragmentTyping {\n        profiles {\n          id\n          ... on User {\n            name\n          }\n          ... on Page {\n            title\n          }\n        }\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Select(\"profiles\",\n        Group(List(\n          Select(\"id\"),\n          Narrow(User, Select(\"name\")),\n          Narrow(Page, Select(\"title\"))\n        ))\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"profiles\" : [\n            {\n              \"id\" : \"1\",\n              \"name\" : \"Alice\"\n            },\n            {\n              \"id\" : \"2\",\n              \"name\" : \"Bob\"\n            },\n            {\n              \"id\" : \"3\",\n              \"name\" : \"Carol\"\n            },\n            {\n              \"id\" : \"4\",\n              \"title\" : \"GraphQL\"\n            },\n            {\n              \"id\" : \"5\",\n              \"title\" : \"Scala\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"typed union fragment query\") {\n    val query = \"\"\"\n      query FragmentUnionTyping {\n        user: user(id: \"1\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n        page: user(id: \"2\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n      }\n\n      fragment userFragment on User {\n        id\n        name\n      }\n\n      fragment pageFragment on Page {\n        id\n        title\n      }\n    \"\"\"\n\n    val User = FragmentMapping.schema.ref(\"User\")\n    val Page = FragmentMapping.schema.ref(\"Page\")\n\n    val expected =\n      Group(List(\n        Select(\"user\",\n          Unique(\n            Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n              Select(\"favourite\",\n                Group(List(\n                  Introspect(FragmentMapping.schema, Select(\"__typename\")),\n                  Narrow(\n                    User,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"name\")\n                    ))\n                  ),\n                  Narrow(\n                    Page,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"title\")\n                    ))\n                   )\n                ))\n              )\n            )\n          )\n        ),\n        Select(\"user\", Some(\"page\"),\n          Unique(\n            Filter(Eql(FragmentMapping.PageType / \"id\", Const(\"2\")),\n              Select(\"favourite\",\n                Group(List(\n                  Introspect(FragmentMapping.schema, Select(\"__typename\")),\n                  Narrow(\n                    User,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"name\")\n                    ))\n                  ),\n                  Narrow(\n                    Page,\n                    Group(List(\n                      Select(\"id\"),\n                      Select(\"title\")\n                    ))\n                  )\n                ))\n              )\n            )\n          )\n        )\n      ))\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"favourite\" : {\n              \"__typename\" : \"User\",\n              \"id\" : \"2\",\n              \"name\" : \"Bob\"\n            }\n          },\n          \"page\" : {\n            \"favourite\" : {\n              \"__typename\" : \"Page\",\n              \"id\" : \"4\",\n              \"title\" : \"GraphQL\"\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"supertype fragment query (1)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...profileFields\n          }\n        }\n      }\n\n      fragment profileFields on Profile {\n        id\n      }\n    \"\"\"\n\n    val expected =\n      Select(\"user\",\n        Unique(\n          Filter(Eql(FragmentMapping.UserType / \"id\", Const(\"1\")),\n            Select(\"friends\",\n              Select(\"id\")\n            )\n          )\n        )\n      )\n\n    val expectedResult = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\"\n              },\n              {\n                \"id\" : \"3\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val compiled = FragmentMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n\n    val res = runOperation(compiled)\n\n    assertIO(res, List(expectedResult))\n  }\n\n  test(\"supertype fragment query (2)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\"\n              },\n              {\n                \"id\" : \"3\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (3)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              ... on User {\n                name\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (4)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"No field 'name' for type Profile\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"supertype fragment query (5)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...profileFields\n          }\n        }\n      }\n\n      fragment profileFields on Profile {\n        id\n        name\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"No field 'name' for type Profile\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with supertype fragment containing subtype refinement\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... ProfileFields\n          }\n        }\n      }\n\n      fragment ProfileFields on Profile {\n        id\n        ... on User {\n          name\n        }\n        ... on Page {\n          title\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with supertype fragment containing nested fragment spreads\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... ProfileFields\n          }\n        }\n      }\n\n      fragment ProfileFields on Profile {\n        id\n        ... UserFields\n        ... PageFields\n      }\n\n      fragment UserFields on User {\n        name\n      }\n\n      fragment PageFields on Page {\n        title\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"interface query with nested inline fragments\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ... on Profile {\n              id\n              ... on User {\n                name\n              }\n              ... on Page {\n                title\n              }\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment defined\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment 'friendFields' is undefined\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment unused (1)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            id\n            name\n            profilePic\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment 'friendFields' is unused\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment unused (2)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            id\n            name\n            profilePic\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"user\" : {\n            \"friends\" : [\n              {\n                \"id\" : \"2\",\n                \"name\" : \"Bob\",\n                \"profilePic\" : \"B\"\n              },\n              {\n                \"id\" : \"3\",\n                \"name\" : \"Carol\",\n                \"profilePic\" : \"C\"\n              }\n            ]\n          }\n        }\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query, reportUnused = false)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment duplication\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          ...userFields\n        }\n      }\n\n      fragment userFields on User {\n        name\n      }\n\n      fragment userFields on User {\n        name\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment 'userFields' is defined more than once\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n\n  test(\"fragment recursion (1)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          ...userFields\n        }\n      }\n\n      fragment userFields on User {\n        name\n        friends {\n          ...userFields\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment cycle starting from 'userFields'\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment recursion (2)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          ...userFields\n        }\n      }\n\n      fragment userFields on User {\n        name\n        favourite {\n          ...pageFields\n        }\n      }\n\n      fragment pageFields on Page {\n        title\n        likers {\n          ...userFields\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment cycle starting from 'userFields'\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment recursion (3)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          ...userFields\n        }\n      }\n\n      fragment userFields on User {\n        name\n        favourite {\n          ...pageFields\n        }\n      }\n\n      fragment pageFields on Page {\n        title\n        likers {\n          ...userFields2\n        }\n      }\n\n      fragment userFields2 on User {\n        profilePic\n        favourite {\n          ...userFields\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment cycle starting from 'userFields'\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"fragment recursion (4)\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          ...userFields\n        }\n      }\n\n      fragment pageFields on Page {\n        title\n        likers {\n          ...userFields2\n        }\n      }\n\n      fragment userFields2 on User {\n        profilePic\n        favourite {\n          ...pageFields\n        }\n      }\n\n      fragment userFields on User {\n        name\n        favourite {\n          ...pageFields\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"errors\" : [\n          {\n            \"message\" : \"Fragment cycle starting from 'pageFields'\"\n          }\n        ]\n      }\n    \"\"\"\n\n    val res = FragmentMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n}\n\nobject FragmentData {\n  sealed trait Profile {\n    def id: String\n  }\n\n  case class User(id: String, name: String, profilePic: String, friendIds: List[String], favouriteId: Option[String]) extends Profile {\n    def friends: List[User] =\n      friendIds.flatMap(fid => profiles.collect { case u: User if u.id == fid => u })\n    def mutualFriends: List[User] =\n      friendIds.flatMap(fid => profiles.collect { case u: User if u.id == fid && u.friendIds.contains(id) => u })\n    def favourite: Option[Profile] =\n      favouriteId.flatMap(id => profiles.find(_.id == id))\n  }\n\n  case class Page(id: String, title: String, likerIds: List[String]) extends Profile {\n    def likers: List[User] =\n      likerIds.flatMap(lid => profiles.collect { case u: User if u.id == lid => u })\n  }\n\n  val profiles = List(\n    User(\"1\", \"Alice\", \"A\", List(\"2\", \"3\"), Some(\"2\")),\n    User(\"2\", \"Bob\", \"B\", List(\"1\"), Some(\"4\")),\n    User(\"3\", \"Carol\", \"C\", List(\"1\", \"2\"), None),\n    Page(\"4\", \"GraphQL\", List(\"1\", \"3\")),\n    Page(\"5\", \"Scala\", List(\"2\"))\n  )\n}\n\nobject FragmentMapping extends ValueMapping[IO] {\n  import FragmentData._\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        user(id: ID!): User!\n        profiles: [Profile!]!\n      }\n      type User implements Profile {\n        id: String!\n        name: String!\n        profilePic: String!\n        friends: [User!]!\n        mutualFriends: [User!]!\n        favourite: UserOrPage\n      }\n      type Page implements Profile {\n        id: String!\n        title: String!\n        likers: [User!]!\n      }\n      union UserOrPage = User | Page\n      interface Profile {\n        id: String!\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val ProfileType = schema.ref(\"Profile\")\n  val UserType = schema.ref(\"User\")\n  val PageType = schema.ref(\"Page\")\n\n  val typeMappings =\n    List(\n      ValueObjectMapping[Unit](\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            ValueField(\"user\", _ => profiles.collect { case u: User => u }),\n            ValueField(\"profiles\", _ => profiles)\n          )\n      ),\n      ValueObjectMapping[Profile](\n        tpe = ProfileType,\n        fieldMappings =\n          List(\n            ValueField(\"id\", _.id)\n          )\n      ),\n      ValueObjectMapping[User](\n        tpe = UserType,\n        fieldMappings =\n          List(\n            ValueField(\"name\", _.name),\n            ValueField(\"profilePic\", _.profilePic),\n            ValueField(\"friends\", _.friends),\n            ValueField(\"mutualFriends\", _.mutualFriends),\n            ValueField(\"favourite\", _.favourite),\n          )\n      ),\n      ValueObjectMapping[Page](\n        tpe = PageType,\n        fieldMappings =\n          List(\n            ValueField(\"title\", _.title),\n            ValueField(\"likers\", _.likers)\n          )\n      )\n    )\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"user\", List(Binding(\"id\", IDValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(FragmentMapping.UserType / \"id\", Const(id)), child)))\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage compiler\n\nimport cats.data.NonEmptyChain\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle._\nimport grackle.syntax._\nimport Query._\nimport Value._\n\nfinal class VariablesSuite extends CatsEffectSuite {\n  test(\"simple variables query\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"devicePicSize\": 60\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n        Group(List(\n          UntypedSelect(\"id\", None, Nil, Nil, Empty),\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"profilePic\", None, List(Binding(\"size\", IntValue(60))), Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"list variable query\") {\n    val query = \"\"\"\n      query getProfile($ids: [ID!]) {\n        users(ids: $ids) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"ids\": [1, 2, 3]\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"users\", None,\n        List(Binding(\"ids\", ListValue(List(IDValue(\"1\"), IDValue(\"2\"), IDValue(\"3\"))))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"enum variable query\") {\n    val query = \"\"\"\n      query getUserType($userType: UserType) {\n        usersByType(userType: $userType) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"userType\": \"ADMIN\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"usersByType\", None,\n        List(Binding(\"userType\", EnumValue(\"ADMIN\"))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable query\") {\n    val query = \"\"\"\n      query getLoggedInByDate($date: Date) {\n        usersLoggedInByDate(date: $date) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"date\": \"2021-02-22\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"usersLoggedInByDate\", None,\n        List(Binding(\"date\", StringValue(\"2021-02-22\"))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable query bigdecimal\") {\n    val query = \"\"\"\n      query queryWithBigDecimal($input: BigDecimal) {\n        queryWithBigDecimal(input: $input) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"input\": 2021\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"queryWithBigDecimal\", None,\n        List(Binding(\"input\", IntValue(2021))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"object variable query\") {\n    val query = \"\"\"\n      query doSearch($pattern: Pattern) {\n        search(pattern: $pattern) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"pattern\": {\n          \"name\": \"Foo\",\n          \"age\": 23,\n          \"id\": 123\n        }\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"invalid: bogus input object field\") {\n    val query = \"\"\"\n      query doSearch($pattern: Pattern) {\n        search(pattern: $pattern) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"pattern\": {\n          \"name\": \"Foo\",\n          \"age\": 23,\n          \"id\": 123,\n          \"quux\": 23\n        }\n      }\n    \"\"\"\n\n    val expected = Problem(\"Unknown field(s) 'quux' in input object value of type Pattern in variable values\")\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Failure(NonEmptyChain.one(expected)))\n  }\n\n  test(\"variable within list query\") {\n    val query = \"\"\"\n      query getProfile($id: ID!) {\n        users(ids: [1, $id, 3]) {\n          name\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"id\": 2\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"users\", None,\n        List(Binding(\"ids\", ListValue(List(IDValue(\"1\"), IDValue(\"2\"), IDValue(\"3\"))))),\n        Nil,\n        UntypedSelect(\"name\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"simple variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($age: Int) {\n        search(pattern: { name: \"Foo\", age: $age, id: 123} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"age\": 23\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"enum variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($userType: UserType) {\n        search(pattern: { name: \"Foo\", age: 23, id: 123, userType: $userType} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"userType\": \"ADMIN\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", EnumValue(\"ADMIN\")),\n            (\"date\", AbsentValue)\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"scalar variable within an object query\") {\n    val query = \"\"\"\n      query doSearch($date: Date) {\n        search(pattern: { name: \"Foo\", age: 23, id: 123, date: $date} ) {\n          name\n          id\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"date\": \"2021-02-22\"\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"search\", None,\n        List(Binding(\"pattern\",\n          ObjectValue(List(\n            (\"name\", StringValue(\"Foo\")),\n            (\"age\", IntValue(23)),\n            (\"id\", IDValue(\"123\")),\n            (\"userType\", AbsentValue),\n            (\"date\", StringValue(\"2021-02-22\"))\n          ))\n        )),\n        Nil,\n        Group(List(\n          UntypedSelect(\"name\", None, Nil, Nil, Empty),\n          UntypedSelect(\"id\", None, Nil, Nil, Empty)\n        ))\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"variables in directive argument\") {\n    val query = \"\"\"\n      query getZuckProfile($skipName: Boolean) {\n        user(id: 4) {\n          id\n          name @skip(if: $skipName)\n        }\n      }\n    \"\"\"\n\n    val variables = json\"\"\"\n      {\n        \"skipName\": true\n      }\n    \"\"\"\n\n    val expected =\n      UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n        UntypedSelect(\"id\", None, Nil, Nil, Empty)\n      )\n\n    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n\n    assertEquals(compiled.map(_.query), Result.Success(expected))\n  }\n\n  test(\"variable not defined (1)\") {\n    val query = \"\"\"\n      query getZuckProfile {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n\n    assertEquals(compiled, expected)\n  }\n\n\n  test(\"variable not defined (2)\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n\n    assertEquals(compiled, expected)\n  }\n\n  test(\"variable not defined (3)\") {\n    val query = \"\"\"\n      query getZuckProfile($skipPic: Boolean) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize) @skip(if: $skipPic)\n        }\n      }\n    \"\"\"\n\n    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), expected)\n  }\n\n  test(\"variable not defined (4)\") {\n    val query = \"\"\"\n      query getZuckProfile {\n        user(id: 4) {\n          id\n          name @skip(if: $skipName)\n        }\n      }\n    \"\"\"\n\n    val expected = Result.failure(\"Variable 'skipName' is undefined\")\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), expected)\n  }\n\n\n  test(\"variable not defined (5)\") {\n    val query = \"\"\"\n      query getZuckProfile($skipName: Boolean) {\n        user(id: 4) {\n          id\n          name @skip(if: $skipName)\n        }\n      }\n    \"\"\"\n\n    val expected = Result.failure(\"Variable 'skipName' is undefined\")\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    assertEquals(compiled.map(_.query), expected)\n  }\n\n  test(\"variable unused (1)\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n        }\n      }\n    \"\"\"\n\n    val compiled = VariablesMapping.compiler.compile(query)\n\n    val expected = Result.failure(\"Variable 'devicePicSize' is unused\")\n\n    assertEquals(compiled, expected)\n  }\n\n  test(\"variable unused (2)\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n        }\n      }\n    \"\"\"\n\n    val compiled = VariablesMapping.compiler.compile(query, reportUnused = false)\n    println(compiled)\n\n    val expected =\n      Operation(\n        UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n          Group(\n            List(\n              UntypedSelect(\"id\", None, Nil, Nil, Empty),\n              UntypedSelect(\"name\", None, Nil, Nil, Empty)\n            )\n          )\n        ),\n        VariablesMapping.QueryType,\n        Nil\n      )\n\n    assertEquals(compiled, Result.success(expected))\n  }\n}\n\nobject VariablesMapping extends TestMapping {\n  val schema =\n    schema\"\"\"\n      type Query {\n        user(id: ID!): User!\n        users(ids: [ID!]!): [User!]!\n        search(pattern: Pattern!): [User!]!\n        usersByType(userType: UserType!): [User!]!\n        usersLoggedInByDate(date: Date!): [User!]!\n        queryWithBigDecimal(input: BigDecimal!): [User!]!\n      }\n      type User {\n        id: String!\n        name: String!\n        profilePic(size: Int): String!\n      }\n      input Pattern {\n        name: String\n        age: Int\n        id: ID\n        userType: UserType\n        date: Date\n      }\n      enum UserType {\n        ADMIN\n        NORMAL\n      }\n      scalar Date\n      scalar BigDecimal\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\").dealias\n\n  override val selectElaborator = PreserveArgsElaborator\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage directives\n\nimport cats.MonadThrow\nimport cats.data.Chain\nimport cats.effect.IO\nimport cats.implicits._\nimport munit.CatsEffectSuite\n\nimport compiler.PreserveArgsElaborator\nimport grackle._\nimport grackle.syntax._\nimport Query._\n\nfinal class DirectiveValidationSuite extends CatsEffectSuite {\n  test(\"Schema with validly located directives\") {\n    val schema =\n      Schema(\n        \"\"\"\n          schema @onSchema {\n            query: Query @onFieldDefinition\n          }\n\n          type Query @onObject {\n            field: Interface @onFieldDefinition\n          }\n\n          interface Interface @onInterface {\n            field: String @onFieldDefinition\n          }\n\n          type Object1 implements Interface @onObject {\n            field: String @onFieldDefinition\n            fieldWithArg(arg: Input @onArgumentDefinition): String @onFieldDefinition\n            unionField: Union @onFieldDefinition\n            enumField: Enum @onFieldDefinition\n            scalarField: Scalar @onFieldDefinition\n          }\n\n          type Object2 implements Interface @onObject {\n            field: String @onFieldDefinition\n          }\n\n          union Union @onUnion = Object1 | Object2\n\n          enum Enum @onEnum {\n            FOO @onEnumValue\n            BAR @onEnumValue\n          }\n\n          scalar Scalar @onScalar\n\n          input Input @onInputObject {\n            field: String @onInputFieldDefinition\n          }\n\n          directive @onSchema on SCHEMA\n          directive @onScalar on SCALAR\n          directive @onObject on OBJECT\n          directive @onFieldDefinition on FIELD_DEFINITION\n          directive @onArgumentDefinition on ARGUMENT_DEFINITION\n          directive @onInterface on INTERFACE\n          directive @onUnion on UNION\n          directive @onEnum on ENUM\n          directive @onEnumValue on ENUM_VALUE\n          directive @onInputObject on INPUT_OBJECT\n          directive @onInputFieldDefinition on INPUT_FIELD_DEFINITION\n        \"\"\"\n      )\n\n    assertEquals(schema.toProblems, Chain.empty)\n  }\n\n  test(\"Schema with invalidly located directives\") {\n    val schema =\n      Schema(\n        \"\"\"\n          schema @onFieldDefinition {\n            query: Query @onSchema\n          }\n\n          type Query @onSchema {\n            field: Interface @onSchema\n          }\n\n          interface Interface @onSchema {\n            field: String @onSchema\n          }\n\n          type Object1 implements Interface @onSchema {\n            field: String @onSchema\n            fieldWithArg(arg: Input @onSchema): String @onSchema\n            unionField: Union @onSchema\n            enumField: Enum @onSchema\n            scalarField: Scalar @onSchema\n          }\n\n          type Object2 implements Interface @onSchema {\n            field: String @onSchema\n          }\n\n          union Union @onSchema = Object1 | Object2\n\n          enum Enum @onSchema {\n            FOO @onSchema\n            BAR @onSchema\n          }\n\n          scalar Scalar @onSchema\n\n          input Input @onSchema {\n            field: String @onSchema\n          }\n\n          directive @onSchema on SCHEMA\n          directive @onFieldDefinition on FIELD_DEFINITION\n        \"\"\"\n      )\n\n    val problems =\n      Chain(\n        Problem(\"Directive 'onFieldDefinition' is not allowed on SCHEMA\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on INTERFACE\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on ARGUMENT_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on FIELD_DEFINITION\"),\n        Problem(\"Directive 'onSchema' is not allowed on UNION\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM_VALUE\"),\n        Problem(\"Directive 'onSchema' is not allowed on ENUM_VALUE\"),\n        Problem(\"Directive 'onSchema' is not allowed on SCALAR\"),\n        Problem(\"Directive 'onSchema' is not allowed on INPUT_OBJECT\"),\n        Problem(\"Directive 'onSchema' is not allowed on INPUT_FIELD_DEFINITION\")\n      )\n\n    assertEquals(schema.toProblems, problems)\n  }\n\n  test(\"Schema with invalid directive arguments\") {\n    val schema =\n      Schema(\n        \"\"\"\n          type Query {\n            f1: Int @withArg(i: 1)\n            f2: Int @withArg\n            f3: Int @withArg(i: \"foo\")\n            f4: Int @withArg(x: \"foo\")\n            f5: Int @withRequiredArg(i: 1)\n            f6: Int @withRequiredArg\n            f7: Int @withRequiredArg(i: \"foo\")\n            f8: Int @withRequiredArg(x: \"foo\")\n            f9: Int @deprecated(reason: \"foo\")\n            f10: Int @deprecated\n            f11: Int @deprecated(reason: 1)\n            f12: Int @deprecated(x: \"foo\")\n          }\n\n          directive @withArg(i: Int) on FIELD_DEFINITION\n          directive @withRequiredArg(i: Int!) on FIELD_DEFINITION\n        \"\"\"\n      )\n\n    val problems =\n      Chain(\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withArg\"\"\"),\n        Problem(\"\"\"Value of type Int required for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected String found '1' for 'reason' in directive deprecated\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive deprecated\"\"\"),\n      )\n\n    assertEquals(schema.toProblems, problems)\n  }\n\n  test(\"Query with validly located directives\") {\n    val expected =\n      List(\n        Operation(\n          UntypedSelect(\"foo\", None, Nil, List(Directive(\"onField\", Nil)),\n            Group(\n              List(\n                UntypedSelect(\"bar\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n                UntypedSelect(\"bar\",None, Nil, List(Directive(\"onField\", Nil)), Empty)\n              )\n            )\n          ),\n          ExecutableDirectiveMapping.QueryType,\n          List(Directive(\"onQuery\",List()))\n        ),\n        Operation(\n          UntypedSelect(\"foo\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n          ExecutableDirectiveMapping.MutationType,\n          List(Directive(\"onMutation\",List()))\n        ),\n        Operation(\n          UntypedSelect(\"foo\",None, Nil, List(Directive(\"onField\", Nil)), Empty),\n          ExecutableDirectiveMapping.SubscriptionType,\n          List(Directive(\"onSubscription\",List()))\n        )\n      )\n\n    val query =\n      \"\"\"|query ($var: Boolean @onVariableDefinition) @onQuery {\n         |  foo @onField {\n         |    ...Frag @onFragmentSpread\n         |    ... @onInlineFragment {\n         |      bar @onField\n         |    }\n         |  }\n         |}\n         |\n         |mutation @onMutation {\n         |  foo @onField\n         |}\n         |\n         |subscription @onSubscription {\n         |  foo @onField\n         |}\n         |\n         |fragment Frag on Foo @onFragmentDefinition {\n         |  bar @onField\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"Query with invalidly located directives\") {\n    val problems =\n      Chain(\n        Problem(\"Directive 'onField' is not allowed on VARIABLE_DEFINITION\"),\n        Problem(\"Directive 'onField' is not allowed on QUERY\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_SPREAD\"),\n        Problem(\"Directive 'onField' is not allowed on INLINE_FRAGMENT\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on MUTATION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on SUBSCRIPTION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\"),\n        Problem(\"Directive 'onField' is not allowed on FRAGMENT_DEFINITION\"),\n        Problem(\"Directive 'onQuery' is not allowed on FIELD\")\n      )\n\n    val query =\n      \"\"\"|query ($var: Boolean @onField) @onField {\n         |  foo @onQuery {\n         |    ...Frag @onField\n         |    ... @onField {\n         |      bar @onQuery\n         |    }\n         |  }\n         |}\n         |\n         |mutation @onField {\n         |  foo @onQuery\n         |}\n         |\n         |subscription @onField {\n         |  foo @onQuery\n         |}\n         |\n         |fragment Frag on Foo @onField {\n         |  bar @onQuery\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res.toProblems, problems)\n  }\n\n  test(\"Query with invalid directive arguments\") {\n    val problems =\n      Chain(\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withArg\"\"\"),\n        Problem(\"\"\"Value of type Int required for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Expected Int found '\"foo\"' for 'i' in directive withRequiredArg\"\"\"),\n        Problem(\"\"\"Unknown argument(s) 'x' in directive withRequiredArg\"\"\")\n      )\n\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    b1: bar @withArg(i: 1)\n         |    b2: bar @withArg\n         |    b3: bar @withArg(i: \"foo\")\n         |    b4: bar @withArg(x: \"foo\")\n         |    b5: bar @withRequiredArg(i: 1)\n         |    b6: bar @withRequiredArg\n         |    b7: bar @withRequiredArg(i: \"foo\")\n         |    b8: bar @withRequiredArg(x: \"foo\")\n         |  }\n         |}\n         |\"\"\".stripMargin\n\n    val res = ExecutableDirectiveMapping.compileAllOperations(query)\n    //println(res)\n\n    assertEquals(res.toProblems, problems)\n  }\n}\n\nobject ExecutableDirectiveMapping extends Mapping[IO] {\n  val M: MonadThrow[IO] = MonadThrow[IO]\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        foo: Foo\n      }\n      type Mutation {\n        foo: String\n      }\n      type Subscription {\n        foo: String\n      }\n      type Foo {\n        bar: String\n      }\n      directive @onQuery on QUERY\n      directive @onMutation on MUTATION\n      directive @onSubscription on SUBSCRIPTION\n      directive @onField on FIELD\n      directive @onFragmentDefinition on FRAGMENT_DEFINITION\n      directive @onFragmentSpread on FRAGMENT_SPREAD\n      directive @onInlineFragment on INLINE_FRAGMENT\n      directive @onVariableDefinition on VARIABLE_DEFINITION\n\n      directive @withArg(i: Int) on FIELD\n      directive @withRequiredArg(i: Int!) on FIELD\n    \"\"\"\n\n  val QueryType = schema.queryType\n  val MutationType = schema.mutationType.get\n  val SubscriptionType = schema.subscriptionType.get\n\n  val typeMappings: List[TypeMapping] = Nil\n\n  override val selectElaborator = PreserveArgsElaborator\n\n  def compileAllOperations(text: String): Result[List[Operation]] =\n    queryParser.parseText(text).flatMap {\n      case (ops, frags) => ops.parTraverse(compiler.compileOperation(_, None, frags))\n    }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage minimizer\n\nimport munit.CatsEffectSuite\n\nimport grackle.{ GraphQLParser, QueryMinimizer, Result }\n\nfinal class MinimizerSuite extends CatsEffectSuite {\n  val parser = GraphQLParser(GraphQLParser.defaultConfig)\n  val minimizer = QueryMinimizer(parser)\n\n  def run(query: String, expected: String, echo: Boolean = false): Unit = {\n\n    val Result.Success(minimized) = minimizer.minimizeText(query) : @unchecked\n    if (echo)\n      println(minimized)\n\n    assert(minimized == expected)\n\n    val Some(parsed0) = parser.parseText(query).toOption : @unchecked\n    val Some(parsed1) = parser.parseText(minimized).toOption : @unchecked\n\n    assertEquals(parsed0, parsed1)\n  }\n\n  test(\"minimize simple query\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{character(id:1000){name}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple parameters (commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\", bar: \"b\", baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{wibble(foo:\"a\",bar:\"b\",baz:3){quux}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple parameters (no commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\" bar: \"b\" baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{wibble(foo:\"a\",bar:\"b\",baz:3){quux}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{hero(episode:NEWHOPE){name,friends{name,friends{name}}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{user(id:4){id,name,smallPic:profilePic(size:64),bigPic:profilePic(size:1024)}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize multiple root fields\") {\n    val query = \"\"\"\n      {\n        luke: character(id: \"1000\") {\n          name\n        }\n        darth: character(id: \"1001\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"{luke:character(id:\"1000\"){name},darth:character(id:\"1001\"){name}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize variables\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query getZuckProfile($devicePicSize:Int){user(id:4){id,name,profilePic(size:$devicePicSize)}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize comments\") {\n    val query = \"\"\"\n      #comment at start of document\n      query IntrospectionQuery { #comment at end of line\n        __schema {\n          queryType {\n            name#comment eol no space\n          }\n          mutationType {\n            name\n            #several comments\n            #one after another\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n      #comment at end of document\n    \"\"\"\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name}}}\"\"\"\n\n    run(query, expected)\n  }\n\n\n  test(\"minimize simple fragment query\") {\n    val query = \"\"\"\n      query withFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        profilePic\n      }\n    \"\"\"\n\n    val expected = \"\"\"query withFragments{user(id:1){friends{...friendFields},mutualFriends{...friendFields}}},fragment friendFields on User{id,name,profilePic}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize nested fragment query\") {\n    val query = \"\"\"\n      query withNestedFragments {\n        user(id: 1) {\n          friends {\n            ...friendFields\n          }\n          mutualFriends {\n            ...friendFields\n          }\n        }\n      }\n\n      fragment friendFields on User {\n        id\n        name\n        ...standardProfilePic\n      }\n\n      fragment standardProfilePic on User {\n        profilePic\n      }\n    \"\"\"\n\n    val expected = \"\"\"query withNestedFragments{user(id:1){friends{...friendFields},mutualFriends{...friendFields}}},fragment friendFields on User{id,name,...standardProfilePic},fragment standardProfilePic on User{profilePic}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize typed fragment query\") {\n    val query = \"\"\"\n      query FragmentTyping {\n        profiles {\n          id\n          __typename\n          ...userFragment\n          ...pageFragment\n        }\n      }\n\n      fragment userFragment on User {\n        name\n      }\n\n      fragment pageFragment on Page {\n        title\n      }\n    \"\"\"\n\n    val expected = \"\"\"query FragmentTyping{profiles{id,__typename,...userFragment,...pageFragment}},fragment userFragment on User{name},fragment pageFragment on Page{title}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize inline fragment query\") {\n    val query = \"\"\"\n      query inlineFragmentTyping {\n        profiles {\n          id\n          ... on User {\n            name\n          }\n          ... on Page {\n            title\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query inlineFragmentTyping{profiles{id,...on User{name},...on Page{title}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize typed union fragment query\") {\n    val query = \"\"\"\n      query FragmentUnionTyping {\n        user: user(id: \"1\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n        page: user(id: \"2\") {\n          favourite {\n            __typename\n            ...userFragment\n            ...pageFragment\n          }\n        }\n      }\n\n      fragment userFragment on User {\n        id\n        name\n      }\n\n      fragment pageFragment on Page {\n        id\n        title\n      }\n    \"\"\"\n\n    val expected = \"\"\"query FragmentUnionTyping{user:user(id:\"1\"){favourite{__typename,...userFragment,...pageFragment}},page:user(id:\"2\"){favourite{__typename,...userFragment,...pageFragment}}},fragment userFragment on User{id,name},fragment pageFragment on Page{id,title}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include field\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field @skip(if: $yup) {\n          subfieldA\n        }\n        b: field @skip(if: $nope) {\n          subfieldB\n        }\n        c: field @include(if: $yup) {\n          subfieldA\n        }\n        d: field @include(if: $nope) {\n          subfieldB\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field@skip(if:$yup){subfieldA},b:field@skip(if:$nope){subfieldB},c:field@include(if:$yup){subfieldA},d:field@include(if:$nope){subfieldB}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include fragment spread\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field {\n          ...frag @skip(if: $yup)\n        }\n        b: field {\n          ...frag @skip(if: $nope)\n        }\n        c: field {\n          ...frag @include(if: $yup)\n        }\n        d: field {\n          ...frag @include(if: $nope)\n        }\n      }\n\n      fragment frag on Value {\n        subfieldA\n        subfieldB\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field{...frag@skip(if:$yup)},b:field{...frag@skip(if:$nope)},c:field{...frag@include(if:$yup)},d:field{...frag@include(if:$nope)}},fragment frag on Value{subfieldA,subfieldB}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize fragment spread with nested skip/include\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        field {\n          ...frag\n        }\n      }\n\n      fragment frag on Value {\n        a: subfieldA @skip(if: $yup)\n        b: subfieldB @skip(if: $nope)\n        c: subfieldA @include(if: $yup)\n        d: subfieldB @include(if: $nope)\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){field{...frag}},fragment frag on Value{a:subfieldA@skip(if:$yup),b:subfieldB@skip(if:$nope),c:subfieldA@include(if:$yup),d:subfieldB@include(if:$nope)}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize skip/include inline fragment\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        a: field {\n          ... on Value @skip(if: $yup) {\n            subfieldA\n            subfieldB\n          }\n        }\n        b: field {\n          ... on Value @skip(if: $nope) {\n            subfieldA\n            subfieldB\n          }\n        }\n        c: field {\n          ... on Value @include(if: $yup) {\n            subfieldA\n            subfieldB\n          }\n        }\n        d: field {\n          ... on Value @include(if: $nope) {\n            subfieldA\n            subfieldB\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){a:field{...on Value@skip(if:$yup){subfieldA,subfieldB}},b:field{...on Value@skip(if:$nope){subfieldA,subfieldB}},c:field{...on Value@include(if:$yup){subfieldA,subfieldB}},d:field{...on Value@include(if:$nope){subfieldA,subfieldB}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize inline fragment with nested skip/include\") {\n    val query = \"\"\"\n      query ($yup: Boolean, $nope: Boolean) {\n        field {\n          ... on Value {\n            a: subfieldA @skip(if: $yup)\n            b: subfieldB @skip(if: $nope)\n            c: subfieldA @include(if: $yup)\n            d: subfieldB @include(if: $nope)\n          }\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query($yup:Boolean,$nope:Boolean){field{...on Value{a:subfieldA@skip(if:$yup),b:subfieldB@skip(if:$nope),c:subfieldA@include(if:$yup),d:subfieldB@include(if:$nope)}}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize null value\") {\n    val query = \"\"\"\n      query {\n        field {\n          subfield\n        }\n        field(arg: null) {\n          subfield\n        }\n        field(arg: 23) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{field{subfield},field(arg:null){subfield},field(arg:23){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize list value\") {\n    val query = \"\"\"\n      query {\n        listField(arg: []) {\n          subfield\n        }\n        listField(arg: [\"foo\", \"bar\"]) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{listField(arg:[]){subfield},listField(arg:[\"foo\",\"bar\"]){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize input object value\") {\n    val query = \"\"\"\n      query {\n        objectField(arg: { foo: 23, bar: true, baz: \"quux\" }) {\n          subfield\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{objectField(arg:{foo:23,bar:true,baz:\"quux\"}){subfield}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize query with UUID argument and custom scalar results\") {\n    val query = \"\"\"\n      query {\n        movieById(id: \"6a7837fc-b463-4d32-b628-0f4b3065cb21\") {\n          id\n          title\n          genre\n          releaseDate\n          showTime\n          nextShowing\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{movieById(id:\"6a7837fc-b463-4d32-b628-0f4b3065cb21\"){id,title,genre,releaseDate,showTime,nextShowing,duration}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"minimize query with mapped enum argument\") {\n    val query = \"\"\"\n      query {\n        moviesByGenre(genre: COMEDY) {\n          title\n          genre\n        }\n      }\n    \"\"\"\n\n    val expected = \"\"\"query{moviesByGenre(genre:COMEDY){title,genre}}\"\"\"\n\n    run(query, expected)\n  }\n\n  test(\"standard introspection query\") {\n    val query = \"\"\"\n      |query IntrospectionQuery {\n      |  __schema {\n      |    queryType { name }\n      |    mutationType { name }\n      |    subscriptionType { name }\n      |    types {\n      |      ...FullType\n      |    }\n      |    directives {\n      |      name\n      |      description\n      |      locations\n      |      args {\n      |        ...InputValue\n      |      }\n      |    }\n      |  }\n      |}\n      |\n      |fragment FullType on __Type {\n      |  kind\n      |  name\n      |  description\n      |  fields(includeDeprecated: true) {\n      |    name\n      |    description\n      |    args {\n      |      ...InputValue\n      |    }\n      |    type {\n      |      ...TypeRef\n      |    }\n      |    isDeprecated\n      |    deprecationReason\n      |  }\n      |  inputFields {\n      |    ...InputValue\n      |  }\n      |  interfaces {\n      |    ...TypeRef\n      |  }\n      |  enumValues(includeDeprecated: true) {\n      |    name\n      |    description\n      |    isDeprecated\n      |    deprecationReason\n      |  }\n      |  possibleTypes {\n      |    ...TypeRef\n      |  }\n      |}\n      |\n      |fragment InputValue on __InputValue {\n      |  name\n      |  description\n      |  type { ...TypeRef }\n      |  defaultValue\n      |}\n      |\n      |fragment TypeRef on __Type {\n      |  kind\n      |  name\n      |  ofType {\n      |    kind\n      |    name\n      |    ofType {\n      |      kind\n      |      name\n      |      ofType {\n      |        kind\n      |        name\n      |        ofType {\n      |          kind\n      |          name\n      |          ofType {\n      |            kind\n      |            name\n      |            ofType {\n      |              kind\n      |              name\n      |              ofType {\n      |                kind\n      |                name\n      |              }\n      |            }\n      |          }\n      |        }\n      |      }\n      |    }\n      |  }\n      |}\n    \"\"\".stripMargin.trim\n\n    val expected = \"\"\"query IntrospectionQuery{__schema{queryType{name},mutationType{name},subscriptionType{name},types{...FullType},directives{name,description,locations,args{...InputValue}}}},fragment FullType on __Type{kind,name,description,fields(includeDeprecated:true){name,description,args{...InputValue},type{...TypeRef},isDeprecated,deprecationReason},inputFields{...InputValue},interfaces{...TypeRef},enumValues(includeDeprecated:true){name,description,isDeprecated,deprecationReason},possibleTypes{...TypeRef}},fragment InputValue on __InputValue{name,description,type{...TypeRef},defaultValue},fragment TypeRef on __Type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}}\"\"\"\n\n    run(query, expected)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage parser\n\nimport munit.CatsEffectSuite\n\nimport grackle.{Ast, GraphQLParser, Result}\nimport grackle.syntax._\nimport Ast._, OperationType._, OperationDefinition._, Selection._, Value._, Type.Named\n\nfinal class ParserSuite extends CatsEffectSuite {\n  val parser = mkParser()\n\n  test(\"simple query\") {\n    val query = doc\"\"\"\n      query {\n        character(id: 1000) {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, None, Nil, Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil)\n            )\n          )\n        )\n      )\n\n    assertEquals(query, List(expected))\n  }\n\n  test(\"multiple parameters (commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\", bar: \"b\", baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,None,Nil,Nil,\n        List(\n          Field(None,Name(\"wibble\"),\n            List(\n              (Name(\"foo\"),StringValue(\"a\")),\n              (Name(\"bar\"),StringValue(\"b\")),\n              (Name(\"baz\"),IntValue(3))\n            ), Nil,\n            List(\n              Field(None,Name(\"quux\"),Nil,Nil,Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"multiple parameters (no commas)\") {\n    val query = \"\"\"\n      query {\n        wibble(foo: \"a\" bar: \"b\" baz: 3) {\n          quux\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,None,Nil,Nil,\n        List(\n          Field(None,Name(\"wibble\"),\n            List(\n              (Name(\"foo\"),StringValue(\"a\")),\n              (Name(\"bar\"),StringValue(\"b\")),\n              (Name(\"baz\"),IntValue(3))\n            ), Nil,\n            List(\n              Field(None,Name(\"quux\"),Nil,Nil,Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"introspection query\") {\n    val query = \"\"\"\n      query IntrospectionQuery {\n        __schema {\n          queryType {\n            name\n          }\n          mutationType {\n            name\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query,Some(Name(\"IntrospectionQuery\")),Nil,Nil,\n        List(\n          Field(None,Name(\"__schema\"),Nil,Nil,\n            List(\n              Field(None,Name(\"queryType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"mutationType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"subscriptionType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              )\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"shorthand query\") {\n    val query = \"\"\"\n      {\n        hero(episode: NEWHOPE) {\n          name\n          friends {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(None,Name(\"hero\"),List((Name(\"episode\"),EnumValue(Name(\"NEWHOPE\")))),Nil,\n            List(\n              Field(None,Name(\"name\"),Nil,Nil,Nil),\n              Field(None,Name(\"friends\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil),\n                  Field(None,Name(\"friends\"),Nil,Nil,\n                    List(\n                      Field(None,Name(\"name\"),Nil,Nil,Nil)\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"field alias\") {\n    val query = \"\"\"\n      {\n        user(id: 4) {\n          id\n          name\n          smallPic: profilePic(size: 64)\n          bigPic: profilePic(size: 1024)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(Some(Name(\"smallPic\")), Name(\"profilePic\"), List((Name(\"size\"), IntValue(64))), Nil, Nil),\n              Field(Some(Name(\"bigPic\")), Name(\"profilePic\"), List((Name(\"size\"), IntValue(1024))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"multiple root fields\") {\n    val query = \"\"\"\n      {\n        luke: character(id: \"1000\") {\n          name\n        }\n        darth: character(id: \"1001\") {\n          name\n        }\n      }\n    \"\"\"\n\n    val expected =\n      QueryShorthand(\n        List(\n          Field(Some(Name(\"luke\")), Name(\"character\"), List((Name(\"id\"), StringValue(\"1000\"))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil))),\n          Field(Some(Name(\"darth\")), Name(\"character\"), List((Name(\"id\"), StringValue(\"1001\"))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), None, Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables with default value\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int = 10) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), Some(IntValue(10)), Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"variables with directive\") {\n    val query = \"\"\"\n      query getZuckProfile($devicePicSize: Int @dir) {\n        user(id: 4) {\n          id\n          name\n          profilePic(size: $devicePicSize)\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(Query, Some(Name(\"getZuckProfile\")),\n        List(VariableDefinition(Name(\"devicePicSize\"), Named(Name(\"Int\")), None, List(Directive(Name(\"dir\"), Nil)))),\n        Nil,\n        List(\n          Field(None, Name(\"user\"), List((Name(\"id\"), IntValue(4))), Nil,\n            List(\n              Field(None, Name(\"id\"), Nil, Nil, Nil),\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              Field(None, Name(\"profilePic\"), List((Name(\"size\"), Variable(Name(\"devicePicSize\")))), Nil, Nil)\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"comments\") {\n    val query = \"\"\"\n      #comment at start of document\n      query IntrospectionQuery { #comment at end of line\n        __schema {\n          queryType {\n            name#comment eol no space\n          }\n          mutationType {\n            name\n            #several comments\n            #one after another\n          }\n          subscriptionType {\n            name\n          }\n        }\n      }\n      #comment at end of document\n    \"\"\"\n\n    val expected =\n      Operation(Query,Some(Name(\"IntrospectionQuery\")),Nil,Nil,\n        List(\n          Field(None,Name(\"__schema\"),Nil,Nil,\n            List(\n              Field(None,Name(\"queryType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"mutationType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              ),\n              Field(None,Name(\"subscriptionType\"),Nil,Nil,\n                List(\n                  Field(None,Name(\"name\"),Nil,Nil,Nil)\n                )\n              )\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"invalid document\") {\n    parser.parseText(\"scalar Foo woozle\").toOption match {\n      case Some(_) => fail(\"should have failed\")\n      case None    => ()\n    }\n  }\n\n  test(\"fragment\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          ...frag\n          ... on Character {\n            age\n          }\n        }\n      }\n\n      fragment frag on Character {\n        name\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        Operation(Query, None, Nil, Nil,\n          List(\n            Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n              List(\n                FragmentSpread(Name(\"frag\"),Nil),\n                InlineFragment(\n                  Some(Named(Name(\"Character\"))),\n                  Nil,\n                  List(\n                    Field(None,Name(\"age\"),Nil ,Nil ,Nil)\n                  )\n                )\n              )\n            )\n          )\n        ),\n        FragmentDefinition(\n          Name(\"frag\"),\n          Named(Name(\"Character\")),\n          Nil,\n          List(\n            Field(None,Name(\"name\"),Nil ,Nil ,Nil)\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(xs) => assertEquals(xs, expected)\n      case _ => assert(false)\n    }\n\n  }\n\n  test(\"fragment with standard directive\") {\n    val query = \"\"\"\n      query frag($expanded: Boolean){\n        character(id: 1000) {\n          name\n          ... @include(if: $expanded) {\n            age\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,\n        Some(Name(\"frag\")),\n        List(VariableDefinition(Name(\"expanded\"),Named(Name(\"Boolean\")),None, Nil)),\n        Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              InlineFragment(\n                None,\n                List(Directive(Name(\"include\"),List((Name(\"if\"),Variable(Name(\"expanded\")))))),\n                List(Field(None,Name(\"age\"),List(),List(),List()))\n              )\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"fragment with custorm directive\") {\n    val query = \"\"\"\n      query {\n        character(id: 1000) {\n          name\n          ... @dir {\n            age\n          }\n        }\n      }\n    \"\"\"\n\n    val expected =\n      Operation(\n        Query,\n        None,\n        Nil,\n        Nil,\n        List(\n          Field(None, Name(\"character\"), List((Name(\"id\"), IntValue(1000))), Nil,\n            List(\n              Field(None, Name(\"name\"), Nil, Nil, Nil),\n              InlineFragment(\n                None,\n                List(Directive(Name(\"dir\"), Nil)),\n                List(Field(None,Name(\"age\"),List(),List(),List()))\n              )\n            )\n          )\n        )\n      )\n\n    parser.parseText(query).toOption match {\n      case Some(List(q)) => assertEquals(q, expected)\n      case _ => assert(false)\n    }\n  }\n\n  test(\"value literals\") {\n\n    def assertParse(input: String, expected: Value) =\n      parser.parseText(s\"query { foo(bar: $input) }\").toOption match {\n        case Some(List(Operation(_, _, _, _,List(Field(_, _, List((_, v)), _, _))))) =>\n          assertEquals(v, expected)\n        case _ => assert(false)\n      }\n\n    assertParse(\"\\\"foo\u03bb\\\"\", StringValue(\"foo\u03bb\"))\n    assertParse(\"\\\"\\\\u03BB\\\"\", StringValue(\"\u03bb\"))\n    assertParse(\"\\\"\\\\\\\" \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t\\\"\", StringValue(\"\\\" \\\\ / \\b \\f \\n \\r \\t\"))\n\n    assertParse(\"123.2\", FloatValue(123.2d))\n    assertParse(\"123E2\", FloatValue(123E2d))\n    assertParse(\"123.2E2\", FloatValue(123.2E2d))\n\n    assertParse(\"123\", IntValue(123))\n    assertParse(\"-123\", IntValue(-123))\n\n    assertParse(\"true\", BooleanValue(true))\n    assertParse(\"false\", BooleanValue(false))\n\n    assertParse(\"null\", NullValue)\n\n    assertParse(\"Foo\", EnumValue(Name(\"Foo\")))\n\n    assertParse(\"[1, \\\"foo\\\"]\", ListValue(List(IntValue(1), StringValue(\"foo\"))))\n\n    assertParse(\"{foo: 1, bar: \\\"baz\\\"}\", ObjectValue(List(Name(\"foo\") -> IntValue(1), Name(\"bar\") -> StringValue(\"baz\"))))\n\n    assertParse(\"\\\"\\\"\\\"one\\\"\\\"\\\"\", StringValue(\"one\"))\n    assertParse(\"\\\"\\\"\\\"    \\n\\n   first\\n   \\t\u03bb\\n  123\\n\\n\\n   \\t\\n\\n\\\"\\\"\\\"\", StringValue(\" first\\n \\t\u03bb\\n123\"))\n  }\n\n  test(\"outsized int\") {\n    val query =\n      \"\"\"|query {\n         |  foo {\n         |    bar {\n         |      baz(id: 2147483648)\n         |    }\n         |  }\n         |}\"\"\".stripMargin\n\n    val expected =\n      \"\"\"|...\n         |  foo {\n         |    bar {\n         |      baz(id: 2147483648)\n         |                        ^\n         |expectation:\n         |* must fail: 2147483648 is larger than max int\n         |    }\n         |  }\"\"\".stripMargin\n\n    val res = parser.parseText(query)\n\n    assertEquals(res, Result.failure(expected))\n  }\n\n  test(\"parse object type extension\") {\n    val schema = \"\"\"\n      extend type Foo {\n        bar: Int\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        ObjectTypeExtension(Named(Name(\"Foo\")), List(FieldDefinition(Name(\"bar\"),None,Nil,Named(Name(\"Int\")),Nil)), Nil, Nil)\n      )\n\n    val res = parser.parseText(schema).toOption\n    assert(res == Some(expected))\n  }\n\n  test(\"parse schema extension\") {\n    val schema = \"\"\"\n      extend schema {\n        query: Query\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        SchemaExtension(List(RootOperationTypeDefinition(OperationType.Query, Named(Name(\"Query\")), Nil)), Nil)\n      )\n\n    val res = parser.parseText(schema).toOption\n    assert(res == Some(expected))\n  }\n\n  test(\"keywords parsed non-greedily (1)\") {\n    val schema =\n      \"\"\"|extend type Name {\n         |  value:String\n         |}\"\"\".stripMargin\n\n    val expected =\n      List(\n        ObjectTypeExtension(\n          Named(Name(\"Name\")),\n          List(\n            FieldDefinition(Name(\"value\"), None, Nil, Named(Name(\"String\")), Nil)\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = parser.parseText(schema).toOption\n    assertEquals(res, Some(expected))\n  }\n\n  test(\"keywords parsed non-greedily (2)\") {\n    val schema =\n      \"\"\"|extendtypeName {\n         |  value: String\n         |}\"\"\".stripMargin\n\n    val expected =\n      \"\"\"|extendtypeName {\n         |      ^\n         |expectation:\n         |* must fail but matched with t\n         |  value: String\n         |}\"\"\".stripMargin\n\n    val res = parser.parseText(schema)\n    assertEquals(res, Result.failure(expected))\n  }\n\n  test(\"deep query\") {\n    def mkQuery(depth: Int): String = {\n      val depth0 = depth - 1\n      \"query{\" + (\"f{\" *depth0) + \"f\" + (\"}\" * depth0) + \"}\"\n    }\n\n    val limit = 5\n    val limitedParser = mkParser(maxSelectionDepth = limit)\n\n    val queryOk = mkQuery(limit)\n    val queryFail = mkQuery(limit + 1)\n\n    val expectedFail =\n      \"\"\"|query{f{f{f{f{f{f}}}}}}\n         |                ^\n         |expectation:\n         |* must fail: exceeded maximum selection depth\"\"\".stripMargin\n\n    val resOk = limitedParser.parseText(queryOk)\n    assert(resOk.hasValue)\n\n    val resFail = limitedParser.parseText(queryFail)\n    assertEquals(resFail, Result.failure(expectedFail))\n  }\n\n  test(\"wide query\") {\n    def mkQuery(width: Int): String =\n      \"query{r{\" + (\"f,\" * (width - 1) + \"f\") + \"}}\"\n\n    val limit = 5\n    val limitedParser = mkParser(maxSelectionWidth = limit)\n\n    val queryOk = mkQuery(limit)\n    val queryFail = mkQuery(limit + 1)\n\n    val expectedFail =\n      \"\"\"|query{r{f,f,f,f,f,f}}\n         |                  ^\n         |expectation:\n         |* must be char: '}'\"\"\".stripMargin\n\n    val resOk = limitedParser.parseText(queryOk)\n    assert(resOk.hasValue)\n\n    val resFail = limitedParser.parseText(queryFail)\n    assertEquals(resFail, Result.failure(expectedFail))\n  }\n\n  test(\"deep list value\") {\n    def mkQuery(depth: Int): String =\n      \"query{f(l: \" + (\"[\" *depth) + \"0\" + (\"]\" * depth) + \"){f}}\"\n\n    val limit = 5\n    val limitedParser = mkParser(maxInputValueDepth = limit)\n\n    val queryOk = mkQuery(limit)\n    val queryFail = mkQuery(limit + 1)\n\n    val expectedFail =\n      \"\"\"|query{f(l: [[[[[[0]]]]]]){f}}\n         |                 ^\n         |expectation:\n         |* must fail: exceeded maximum input value depth\"\"\".stripMargin\n\n    val resOk = limitedParser.parseText(queryOk)\n    assert(resOk.hasValue)\n\n    val resFail = limitedParser.parseText(queryFail)\n    assertEquals(resFail, Result.failure(expectedFail))\n  }\n\n  test(\"deep input object value\") {\n    def mkQuery(depth: Int): String =\n      \"query{f(l: \" + (\"{m:\" *depth) + \"0\" + (\"}\" * depth) + \"){f}}\"\n\n    val limit = 5\n    val limitedParser = mkParser(maxInputValueDepth = limit)\n\n    val queryOk = mkQuery(limit)\n    val queryFail = mkQuery(limit + 1)\n\n    val expectedFail =\n      \"\"\"|query{f(l: {m:{m:{m:{m:{m:{m:0}}}}}}){f}}\n         |                           ^\n         |expectation:\n         |* must fail: exceeded maximum input value depth\"\"\".stripMargin\n\n    val resOk = limitedParser.parseText(queryOk)\n    assert(resOk.hasValue)\n\n    val resFail = limitedParser.parseText(queryFail)\n    assertEquals(resFail, Result.failure(expectedFail))\n  }\n\n  test(\"deep variable type\") {\n    def mkQuery(depth: Int): String =\n      \"query($l: \" + (\"[\" *depth) + \"Int\" + (\"]\" * depth) + \"){f(a:$l)}\"\n\n    val limit = 5\n    val limitedParser = mkParser(maxListTypeDepth = limit)\n\n    val queryOk = mkQuery(limit)\n    val queryFail = mkQuery(limit + 1)\n\n    val expectedFail =\n      \"\"\"|query($l: [[[[[[Int]]]]]]){f(a:$l)}\n         |                ^\n         |expectation:\n         |* must fail: exceeded maximum list type depth\"\"\".stripMargin\n\n    val resOk = limitedParser.parseText(queryOk)\n    assert(resOk.hasValue)\n\n    val resFail = limitedParser.parseText(queryFail)\n    assertEquals(resFail, Result.failure(expectedFail))\n  }\n\n  def mkParser(\n    maxSelectionDepth: Int = GraphQLParser.defaultConfig.maxSelectionDepth,\n    maxSelectionWidth: Int = GraphQLParser.defaultConfig.maxSelectionWidth,\n    maxInputValueDepth: Int = GraphQLParser.defaultConfig.maxInputValueDepth,\n    maxListTypeDepth: Int = GraphQLParser.defaultConfig.maxListTypeDepth,\n  ): GraphQLParser =\n    GraphQLParser(\n      GraphQLParser.Config(\n        maxSelectionDepth = maxSelectionDepth,\n        maxSelectionWidth = maxSelectionWidth,\n        maxInputValueDepth = maxInputValueDepth,\n        maxListTypeDepth = maxListTypeDepth,\n        terseError = false\n      )\n    )\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage sdl\n\nimport munit.CatsEffectSuite\n\nimport grackle.{ Ast, GraphQLParser, SchemaParser }\nimport grackle.syntax._\nimport Ast._, OperationType._, Type.{ List => _, _ }\n\nfinal class SDLSuite extends CatsEffectSuite {\n  val parser = GraphQLParser(GraphQLParser.defaultConfig)\n  val schemaParser = SchemaParser(parser)\n\n  test(\"parse schema definition\") {\n    val schema = \"\"\"\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        SchemaDefinition(\n          List(\n            RootOperationTypeDefinition(Query, Named(Name(\"MyQuery\")), Nil),\n            RootOperationTypeDefinition(Mutation, Named(Name(\"MyMutation\")), Nil),\n            RootOperationTypeDefinition(Subscription, Named(Name(\"MySubscription\")), Nil)\n          ),\n          Nil\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse scalar type definition\") {\n    val schema = \"\"\"\n      \"A scalar type\"\n      scalar Url\n\n      \"A scalar type\"\n      scalar Time @deprecated\n    \"\"\"\n\n    val expected =\n      List(\n        ScalarTypeDefinition(Name(\"Url\"), Some(\"A scalar type\"), Nil),\n        ScalarTypeDefinition(Name(\"Time\"), Some(\"A scalar type\"), List(Directive(Name(\"deprecated\"), Nil)))\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse object type definition\") {\n    val schema = \"\"\"\n      \"An object type\"\n      type Query {\n        posts: [Post]\n        author(id: Int!): Author\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        ObjectTypeDefinition(Name(\"Query\"), Some(\"An object type\"),\n          List(\n            FieldDefinition(Name(\"posts\"), None, Nil, Type.List(Named(Name(\"Post\"))), Nil),\n            FieldDefinition(\n              Name(\"author\"),\n              None,\n              List(InputValueDefinition(Name(\"id\"), None, NonNull(Left(Named(Name(\"Int\")))), None, Nil)),\n              Named(Name(\"Author\")),\n              Nil\n            )\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse interface type definition\") {\n    val schema = \"\"\"\n      \"An interface type\"\n      interface Post {\n        \"A field\"\n        id: Int!\n        title: String\n        \"A deprecated field\"\n        author: Author @deprecated\n        votes: Int\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        InterfaceTypeDefinition(Name(\"Post\"), Some(\"An interface type\"),\n          List(\n            FieldDefinition(Name(\"id\"), Some(\"A field\"), Nil, NonNull(Left(Named(Name(\"Int\")))), Nil),\n            FieldDefinition(Name(\"title\"), None, Nil, Named(Name(\"String\")), Nil),\n            FieldDefinition(Name(\"author\"), Some(\"A deprecated field\"), Nil, Named(Name(\"Author\")), List(Directive(Name(\"deprecated\"), Nil))),\n            FieldDefinition(Name(\"votes\"), None, Nil, Named(Name(\"Int\")), Nil)\n          ),\n          Nil,\n          Nil\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse union type definition\") {\n    val schema = \"\"\"\n      \"A union type\"\n      union ThisOrThat = This | That\n    \"\"\"\n\n    val expected =\n      List(\n        UnionTypeDefinition(Name(\"ThisOrThat\"), Some(\"A union type\"), Nil,\n          List(\n            Named(Name(\"This\")),\n            Named(Name(\"That\"))\n          )\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse enum type definition\") {\n    val schema = \"\"\"\n      \"An enum type\"\n      enum Direction {\n        NORTH\n        EAST\n        SOUTH\n        WEST\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        EnumTypeDefinition(Name(\"Direction\"), Some(\"An enum type\"), Nil,\n          List(\n            EnumValueDefinition(Name(\"NORTH\"), None, Nil),\n            EnumValueDefinition(Name(\"EAST\"), None, Nil),\n            EnumValueDefinition(Name(\"SOUTH\"), None, Nil),\n            EnumValueDefinition(Name(\"WEST\"), None, Nil)\n          )\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse input object type definition\") {\n    val schema = \"\"\"\n      \"An input object type\"\n      input Point2D {\n        x: Float\n        y: Float\n      }\n    \"\"\"\n\n    val expected =\n      List(\n        InputObjectTypeDefinition(Name(\"Point2D\"), Some(\"An input object type\"),\n          List(\n            InputValueDefinition(Name(\"x\"), None, Named(Name(\"Float\")), None, Nil),\n            InputValueDefinition(Name(\"y\"), None, Named(Name(\"Float\")), None, Nil)\n          ),\n          Nil\n        )\n      )\n\n    val res = parser.parseText(schema)\n\n    assertEquals(res, expected.success)\n  }\n\n  test(\"parse directive definition\") {\n    val schema =\n      \"\"\"|type Query {\n         |  foo: Int\n         |}\n         |\"A directive\"\n         |directive @delegateField(name: String!) repeatable on OBJECT|INTERFACE|FIELD|FIELD_DEFINITION|ENUM|ENUM_VALUE\n         |\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (1)\") {\n    val schema =\n    \"\"\"|type Author {\n       |  id: Int!\n       |  firstName: String\n       |  lastName: String\n       |  posts: [Post]\n       |}\n       |type Post {\n       |  id: Int!\n       |  title: String\n       |  author: Author\n       |  votes: Int\n       |}\n       |type Query {\n       |  posts: [Post]\n       |  author(id: Int! = 23): Author\n       |}\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (2)\") {\n    val schema =\n    \"\"\"|type Query {\n       |  hero(episode: Episode!): Character!\n       |  character(id: ID!): Character\n       |  human(id: ID!): Human\n       |  droid(id: ID!): Droid\n       |}\n       |enum Episode {\n       |  ROGUEONE @deprecated(reason: \"use NEWHOPE instead\")\n       |  NEWHOPE\n       |  EMPIRE\n       |  JEDI\n       |}\n       |interface Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |}\n       |type Human implements Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |  homePlanet: String\n       |}\n       |type Droid implements Character {\n       |  id: String!\n       |  name: String\n       |  fullname: String @deprecated(reason: \"use 'name' instead\")\n       |  friends: [Character!]\n       |  appearsIn: [Episode!]\n       |  primaryFunction: String\n       |}\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"deserialize schema (3)\") {\n    val schema =\n    \"\"\"|type Query {\n       |  whatsat(p: Point!): ThisOrThat!\n       |}\n       |union ThisOrThat = This | That\n       |type This {\n       |  id: ID!\n       |}\n       |type That {\n       |  id: ID!\n       |}\n       |input Point {\n       |  x: Int\n       |  y: Int\n       |}\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"round-trip extensions\") {\n    val schema =\n      \"\"\"|schema {\n         |  query: MyQuery\n         |}\n         |type MyQuery {\n         |  foo(s: Scalar, i: Input, e: Enum): Union\n         |}\n         |type Mutation {\n         |  bar: Int\n         |}\n         |scalar Scalar\n         |interface Intrf {\n         |  bar: String\n         |}\n         |type Obj implements Intrf {\n         |  bar: String\n         |}\n         |union Union = Intrf | Obj\n         |enum Enum {\n         |  A\n         |  B\n         |}\n         |input Input {\n         |  baz: Float\n         |}\n         |type Quux {\n         |  quux: String\n         |}\n         |extend schema @Sch {\n         |  mutation: Mutation\n         |}\n         |extend scalar Scalar @Sca\n         |extend interface Intrf @Intrf {\n         |  baz: Boolean\n         |}\n         |extend type Obj @Obj {\n         |  baz: Boolean\n         |  quux: String\n         |}\n         |extend union Union @Uni = Quux\n         |extend enum Enum @Enu {\n         |  C\n         |}\n         |extend input Input @Inp {\n         |  foo: Int\n         |}\n         |directive @Sch on SCHEMA\n         |directive @Sca on SCALAR\n         |directive @Obj on OBJECT\n         |directive @Intrf on INTERFACE\n         |directive @Uni on UNION\n         |directive @Enu on ENUM\n         |directive @Inp on INPUT_OBJECT\n         |\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n\n  test(\"round-trip extensions (no fields or members\") {\n    val schema =\n      \"\"\"|schema {\n         |  query: MyQuery\n         |}\n         |type MyQuery {\n         |  foo(s: Scalar, i: Input, e: Enum): Union\n         |}\n         |scalar Scalar\n         |interface Intrf {\n         |  bar: String\n         |}\n         |type Obj implements Intrf {\n         |  bar: String\n         |}\n         |union Union = Intrf | Obj\n         |enum Enum {\n         |  A\n         |  B\n         |}\n         |input Input {\n         |  baz: Float\n         |}\n         |extend schema @Sch\n         |extend scalar Scalar @Sca\n         |extend interface Intrf @Intrf\n         |extend type Obj @Obj\n         |extend union Union @Uni\n         |extend enum Enum @Enu\n         |extend input Input @Inp\n         |directive @Sch on SCHEMA\n         |directive @Sca on SCALAR\n         |directive @Obj on OBJECT\n         |directive @Intrf on INTERFACE\n         |directive @Uni on UNION\n         |directive @Enu on ENUM\n         |directive @Inp on INPUT_OBJECT\n         |\"\"\".stripMargin\n\n    val res = schemaParser.parseText(schema)\n    val ser = res.map(_.toString)\n\n    assertEquals(ser, schema.success)\n  }\n}\n", "// Copyright (c) 2016-2023 Association of Universities for Research in Astronomy, Inc. (AURA)\n// Copyright (c) 2016-2023 Grackle Contributors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage grackle\npackage generic\n\nimport java.time.{Duration, LocalDate, LocalTime, OffsetDateTime}\nimport java.util.UUID\nimport scala.util.Try\n\nimport cats.{Eq, Order}\nimport cats.effect.IO\nimport cats.implicits._\nimport io.circe.Encoder\nimport io.circe.literal._\nimport munit.CatsEffectSuite\n\nimport grackle.syntax._\nimport Query._, Predicate._, Value._\nimport QueryCompiler._\n\nobject MovieData {\n  import MovieMapping._\n  import semiauto._\n\n  sealed trait Genre extends Product with Serializable\n  object Genre {\n    case object Drama extends Genre\n    case object Action extends Genre\n    case object Comedy extends Genre\n\n    implicit val genreEq: Eq[Genre] = Eq.fromUniversalEquals[Genre]\n\n    def fromString(s: String): Option[Genre] =\n      s.trim.toUpperCase match {\n        case \"DRAMA\"  => Some(Drama)\n        case \"ACTION\" => Some(Action)\n        case \"COMEDY\" => Some(Comedy)\n        case _ => None\n      }\n\n    implicit val genreEncoder: Encoder[Genre] =\n      Encoder[String].contramap(_ match {\n        case Drama => \"DRAMA\"\n        case Action => \"ACTION\"\n        case Comedy => \"COMEDY\"\n      })\n\n    implicit val cursorBuilder: CursorBuilder[Genre] =\n      CursorBuilder.deriveLeafCursorBuilder[Genre](GenreType)\n  }\n\n  implicit val localDateOrder: Order[LocalDate] =\n    Order.from(_.compareTo(_))\n\n  implicit val localTimeOrder: Order[LocalTime] =\n    Order.fromComparable[LocalTime]\n\n  implicit val offsetDateTimeOrder: Order[OffsetDateTime] =\n    Order.from(_.compareTo(_))\n\n  implicit val durationOrder: Order[Duration] =\n    Order.fromComparable[Duration]\n\n  import Genre.{Action, Comedy, Drama}\n\n  case class Movie(\n    id: UUID,\n    title: String,\n    genre: Genre,\n    releaseDate: LocalDate,\n    showTime: LocalTime,\n    nextShowing: OffsetDateTime,\n    duration: Duration\n  )\n\n  object Movie {\n    implicit val cursorBuilder: CursorBuilder[Movie] =\n      deriveObjectCursorBuilder[Movie](MovieType)\n  }\n\n  val movies =\n    List(\n      Movie(UUID.fromString(\"6a7837fc-b463-4d32-b628-0f4b3065cb21\"), \"Celine et Julie Vont en Bateau\", Drama, LocalDate.parse(\"1974-10-07\"), LocalTime.parse(\"19:35:00\"), OffsetDateTime.parse(\"2020-05-22T19:35:00Z\"), Duration.ofMillis(12300000)),\n      Movie(UUID.fromString(\"11daf8c0-11c3-4453-bfe1-cb6e6e2f9115\"), \"Duelle\", Drama, LocalDate.parse(\"1975-09-15\"), LocalTime.parse(\"19:20:00\"), OffsetDateTime.parse(\"2020-05-27T19:20:00Z\"), Duration.ofMillis(7260000)),\n      Movie(UUID.fromString(\"aea9756f-621b-42d5-b130-71f3916c4ba3\"), \"L'Amour fou\", Drama, LocalDate.parse(\"1969-01-15\"), LocalTime.parse(\"21:00:00\"), OffsetDateTime.parse(\"2020-05-27T21:00:00Z\"), Duration.ofMillis(15120000)),\n      Movie(UUID.fromString(\"2ddb041f-86c2-4bd3-848c-990a3862634e\"), \"Last Year at Marienbad\", Drama, LocalDate.parse(\"1961-06-25\"), LocalTime.parse(\"20:30:00\"), OffsetDateTime.parse(\"2020-05-26T20:30:00Z\"), Duration.ofMillis(5640000)),\n      Movie(UUID.fromString(\"8ae5b13b-044c-4ff0-8b71-ccdb7d77cd88\"), \"Zazie dans le M\u00e9tro\", Comedy, LocalDate.parse(\"1960-10-28\"), LocalTime.parse(\"20:15:00\"), OffsetDateTime.parse(\"2020-05-25T20:15:00Z\"), Duration.ofMillis(5340000)),\n      Movie(UUID.fromString(\"9dce9deb-9188-4cc2-9685-9842b8abdd34\"), \"Alphaville\", Action, LocalDate.parse(\"1965-05-05\"), LocalTime.parse(\"19:45:00\"), OffsetDateTime.parse(\"2020-05-19T19:45:00Z\"), Duration.ofMillis(5940000)),\n      Movie(UUID.fromString(\"1bf00ac6-91ab-4e51-b686-3fd5e2324077\"), \"Stalker\", Drama, LocalDate.parse(\"1979-05-13\"), LocalTime.parse(\"15:30:00\"), OffsetDateTime.parse(\"2020-05-19T15:30:00Z\"), Duration.ofMillis(9660000)),\n      Movie(UUID.fromString(\"6a878e06-6563-4a0c-acd9-d28dcfb2e91a\"), \"Weekend\", Comedy, LocalDate.parse(\"1967-12-29\"), LocalTime.parse(\"22:30:00\"), OffsetDateTime.parse(\"2020-05-19T22:30:00Z\"), Duration.ofMillis(6300000)),\n      Movie(UUID.fromString(\"2a40415c-ea6a-413f-bbef-a80ae280c4ff\"), \"Daisies\", Comedy, LocalDate.parse(\"1966-12-30\"), LocalTime.parse(\"21:30:00\"), OffsetDateTime.parse(\"2020-05-15T21:30:00Z\"), Duration.ofMillis(4560000)),\n      Movie(UUID.fromString(\"2f6dcb0a-4122-4a21-a1c6-534744dd6b85\"), \"Le Pont du Nord\", Drama, LocalDate.parse(\"1982-01-13\"), LocalTime.parse(\"20:45:00\"), OffsetDateTime.parse(\"2020-05-11T20:45:00Z\"), Duration.ofMillis(7620000))\n    ).sortBy(_.id.toString)\n}\n\nobject MovieMapping extends GenericMapping[IO] {\n  import MovieData._\n\n  val schema =\n    schema\"\"\"\n      type Query {\n        movieById(id: UUID!): Movie\n        moviesByGenre(genre: Genre!): [Movie!]!\n        moviesReleasedBetween(from: Date!, to: Date!): [Movie!]!\n        moviesLongerThan(duration: Interval!): [Movie!]!\n        moviesShownLaterThan(time: Time!): [Movie!]!\n        moviesShownBetween(from: DateTime!, to: DateTime!): [Movie!]!\n      }\n      scalar UUID\n      scalar Time\n      scalar Date\n      scalar DateTime\n      scalar Interval\n      enum Genre {\n        DRAMA\n        ACTION\n        COMEDY\n      }\n      type Movie {\n        id: UUID!\n        title: String!\n        genre: Genre!\n        releaseDate: Date!\n        showTime: Time!\n        nextShowing: DateTime!\n        duration: Interval!\n      }\n    \"\"\"\n\n  val QueryType = schema.ref(\"Query\")\n  val MovieType = schema.ref(\"Movie\")\n  val GenreType = schema.ref(\"Genre\")\n\n  val typeMappings =\n    List(\n      ObjectMapping(\n        tpe = QueryType,\n        fieldMappings =\n          List(\n            GenericField(\"movieById\", movies),\n            GenericField(\"moviesByGenre\", movies),\n            GenericField(\"moviesReleasedBetween\", movies),\n            GenericField(\"moviesLongerThan\", movies),\n            GenericField(\"moviesShownLaterThan\", movies),\n            GenericField(\"moviesShownBetween\", movies)\n          )\n      )\n    )\n\n  object UUIDValue {\n    def unapply(s: StringValue): Option[UUID] =\n      Try(UUID.fromString(s.value)).toOption\n  }\n\n  object GenreValue {\n    def unapply(e: EnumValue): Option[Genre] =\n      Genre.fromString(e.name)\n  }\n\n  object DateValue {\n    def unapply(s: StringValue): Option[LocalDate] =\n      Try(LocalDate.parse(s.value)).toOption\n  }\n\n  object TimeValue {\n    def unapply(s: StringValue): Option[LocalTime] =\n      Try(LocalTime.parse(s.value)).toOption\n  }\n\n  object DateTimeValue {\n    def unapply(s: StringValue): Option[OffsetDateTime] =\n      Try(OffsetDateTime.parse(s.value)).toOption\n  }\n\n  object IntervalValue {\n    def unapply(s: StringValue): Option[Duration] =\n      Try(Duration.parse(s.value)).toOption\n  }\n\n  override val selectElaborator = SelectElaborator {\n    case (QueryType, \"movieById\", List(Binding(\"id\", UUIDValue(id)))) =>\n      Elab.transformChild(child => Unique(Filter(Eql(MovieType / \"id\", Const(id)), child)))\n    case (QueryType, \"moviesByGenre\", List(Binding(\"genre\", GenreValue(genre)))) =>\n      Elab.transformChild(child => Filter(Eql(MovieType / \"genre\", Const(genre)), child))\n    case (QueryType, \"moviesReleasedBetween\", List(Binding(\"from\", DateValue(from)), Binding(\"to\", DateValue(to)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          And(\n            Not(Lt(MovieType / \"releaseDate\", Const(from))),\n            Lt(MovieType / \"releaseDate\", Const(to))\n          ),\n          child\n        )\n      )\n    case (QueryType, \"moviesLongerThan\", List(Binding(\"duration\", IntervalValue(duration)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          Not(Lt(MovieType / \"duration\", Const(duration))),\n          child\n        )\n      )\n    case (QueryType, \"moviesShownLaterThan\", List(Binding(\"time\", TimeValue(time)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          Not(Lt(MovieType / \"showTime\", Const(time))),\n          child\n        )\n      )\n    case (QueryType, \"moviesShownBetween\", List(Binding(\"from\", DateTimeValue(from)), Binding(\"to\", DateTimeValue(to)))) =>\n      Elab.transformChild(child =>\n        Filter(\n          And(\n            Not(Lt(MovieType / \"nextShowing\", Const(from))),\n            Lt(MovieType / \"nextShowing\", Const(to))\n          ),\n          child\n        )\n      )\n  }\n}\n\nfinal class ScalarsSuite extends CatsEffectSuite {\n  test(\"query with UUID argument and custom scalar results\") {\n    val query = \"\"\"\n      query {\n        movieById(id: \"6a7837fc-b463-4d32-b628-0f4b3065cb21\") {\n          id\n          title\n          genre\n          releaseDate\n          showTime\n          nextShowing\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"movieById\" : {\n            \"id\" : \"6a7837fc-b463-4d32-b628-0f4b3065cb21\",\n            \"title\" : \"Celine et Julie Vont en Bateau\",\n            \"genre\" : \"DRAMA\",\n            \"releaseDate\" : \"1974-10-07\",\n            \"showTime\" : \"19:35:00\",\n            \"nextShowing\" : \"2020-05-22T19:35:00Z\",\n            \"duration\" : \"PT3H25M\"\n          }\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with mapped enum argument\") {\n    val query = \"\"\"\n      query {\n        moviesByGenre(genre: COMEDY) {\n          title\n          genre\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesByGenre\" : [\n            {\n              \"title\" : \"Daisies\",\n              \"genre\" : \"COMEDY\"\n            },\n            {\n              \"title\" : \"Weekend\",\n              \"genre\" : \"COMEDY\"\n            },\n            {\n              \"title\" : \"Zazie dans le M\u00e9tro\",\n              \"genre\" : \"COMEDY\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with LocalDate argument\") {\n    val query = \"\"\"\n      query {\n        moviesReleasedBetween(from: \"1970-01-01\", to: \"1980-01-01\") {\n          title\n          releaseDate\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesReleasedBetween\" : [\n            {\n              \"title\" : \"Duelle\",\n              \"releaseDate\" : \"1975-09-15\"\n            },\n            {\n              \"title\" : \"Stalker\",\n              \"releaseDate\" : \"1979-05-13\"\n            },\n            {\n              \"title\" : \"Celine et Julie Vont en Bateau\",\n              \"releaseDate\" : \"1974-10-07\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with Duration argument\") {\n    val query = \"\"\"\n      query {\n        moviesLongerThan(duration: \"PT3H\") {\n          title\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesLongerThan\" : [\n            {\n              \"title\" : \"Celine et Julie Vont en Bateau\",\n              \"duration\" : \"PT3H25M\"\n            },\n            {\n              \"title\" : \"L'Amour fou\",\n              \"duration\" : \"PT4H12M\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with scalar argument without apostrophes\") {\n    val query = \"\"\"\n      query {\n        moviesLongerThan(duration: PT3H) {\n          title\n          duration\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesLongerThan\" : [\n            {\n              \"title\" : \"Celine et Julie Vont en Bateau\",\n              \"duration\" : \"PT3H25M\"\n            },\n            {\n              \"title\" : \"L'Amour fou\",\n              \"duration\" : \"PT4H12M\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with LocalTime argument\") {\n    val query = \"\"\"\n      query {\n        moviesShownLaterThan(time: \"21:00:00\") {\n          title\n          showTime\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesShownLaterThan\" : [\n            {\n              \"title\" : \"Daisies\",\n              \"showTime\" : \"21:30:00\"\n            },\n            {\n              \"title\" : \"Weekend\",\n              \"showTime\" : \"22:30:00\"\n            },\n            {\n              \"title\" : \"L'Amour fou\",\n              \"showTime\" : \"21:00:00\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n\n  test(\"query with OffsetDateTime argument\") {\n    val query = \"\"\"\n      query {\n        moviesShownBetween(from: \"2020-05-01T10:30:00Z\", to: \"2020-05-19T18:00:00Z\") {\n          title\n          nextShowing\n        }\n      }\n    \"\"\"\n\n    val expected = json\"\"\"\n      {\n        \"data\" : {\n          \"moviesShownBetween\" : [\n            {\n              \"title\" : \"Stalker\",\n              \"nextShowing\" : \"2020-05-19T15:30:00Z\"\n            },\n            {\n              \"title\" : \"Daisies\",\n              \"nextShowing\" : \"2020-05-15T21:30:00Z\"\n            },\n            {\n              \"title\" : \"Le Pont du Nord\",\n              \"nextShowing\" : \"2020-05-11T20:45:00Z\"\n            }\n          ]\n        }\n      }\n    \"\"\"\n\n    val res = MovieMapping.compileAndRun(query)\n\n    assertIO(res, expected)\n  }\n}\n"], "filenames": ["build.sbt", "modules/core/src/main/scala-2/syntax2.scala", "modules/core/src/main/scala-3/syntax3.scala", "modules/core/src/main/scala/compiler.scala", "modules/core/src/main/scala/mapping.scala", "modules/core/src/main/scala/minimizer.scala", "modules/core/src/main/scala/parser.scala", "modules/core/src/main/scala/schema.scala", "modules/core/src/test/scala/compiler/CompilerSuite.scala", "modules/core/src/test/scala/compiler/DirectivesSuite.scala", "modules/core/src/test/scala/compiler/FragmentSuite.scala", "modules/core/src/test/scala/compiler/VariablesSuite.scala", "modules/core/src/test/scala/directives/DirectiveValidationSuite.scala", "modules/core/src/test/scala/minimizer/MinimizerSuite.scala", "modules/core/src/test/scala/parser/ParserSuite.scala", "modules/core/src/test/scala/sdl/SDLSuite.scala", "modules/generic/src/test/scala/ScalarsSuite.scala"], "buggy_code_start_loc": [33, 22, 21, 34, 50, 18, 18, 231, 28, 25, 792, 380, 378, 20, 18, 24, 375], "buggy_code_end_loc": [34, 57, 41, 714, 484, 139, 505, 1590, 398, 173, 792, 413, 379, 32, 655, 418, 375], "fixing_code_start_loc": [33, 21, 20, 34, 50, 18, 18, 231, 29, 26, 793, 381, 378, 20, 17, 25, 376], "fixing_code_end_loc": [34, 62, 45, 892, 488, 145, 536, 1603, 409, 175, 1090, 579, 379, 36, 815, 421, 408], "type": "CWE-400", "message": "Grackle is a GraphQL server written in functional Scala, built on the Typelevel stack. The GraphQL specification requires that GraphQL fragments must not form cycles, either directly or indirectly. Prior to Grackle version 0.18.0, that requirement wasn't checked, and queries with cyclic fragments would have been accepted for type checking and compilation. The attempted compilation of such fragments would result in a JVM `StackOverflowError` being thrown. Some knowledge of an applications GraphQL schema would be required to construct such a query, however no knowledge of any application-specific performance or other behavioural characteristics would be needed.\n\nGrackle uses the cats-parse library for parsing GraphQL queries. Prior to version 0.18.0, Grackle made use of the cats-parse `recursive` operator. However, `recursive` is not currently stack safe. `recursive` was used in three places in the parser: nested selection sets, nested input values (lists and objects), and nested list type declarations. Consequently, queries with deeply nested selection sets, input values or list types could be constructed which exploited this, causing a JVM `StackOverflowException` to be thrown during parsing. Because this happens very early in query processing, no specific knowledge of an applications GraphQL schema would be required to construct such a query.\n\nThe possibility of small queries resulting in stack overflow is a potential denial of service vulnerability. This potentially affects all applications using Grackle which have untrusted users. Both stack overflow issues have been resolved in the v0.18.0 release of Grackle. As a workaround, users could interpose a sanitizing layer in between untrusted input and Grackle query processing.", "other": {"cve": {"id": "CVE-2023-50730", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-22T21:15:07.930", "lastModified": "2024-01-08T12:57:18.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grackle is a GraphQL server written in functional Scala, built on the Typelevel stack. The GraphQL specification requires that GraphQL fragments must not form cycles, either directly or indirectly. Prior to Grackle version 0.18.0, that requirement wasn't checked, and queries with cyclic fragments would have been accepted for type checking and compilation. The attempted compilation of such fragments would result in a JVM `StackOverflowError` being thrown. Some knowledge of an applications GraphQL schema would be required to construct such a query, however no knowledge of any application-specific performance or other behavioural characteristics would be needed.\n\nGrackle uses the cats-parse library for parsing GraphQL queries. Prior to version 0.18.0, Grackle made use of the cats-parse `recursive` operator. However, `recursive` is not currently stack safe. `recursive` was used in three places in the parser: nested selection sets, nested input values (lists and objects), and nested list type declarations. Consequently, queries with deeply nested selection sets, input values or list types could be constructed which exploited this, causing a JVM `StackOverflowException` to be thrown during parsing. Because this happens very early in query processing, no specific knowledge of an applications GraphQL schema would be required to construct such a query.\n\nThe possibility of small queries resulting in stack overflow is a potential denial of service vulnerability. This potentially affects all applications using Grackle which have untrusted users. Both stack overflow issues have been resolved in the v0.18.0 release of Grackle. As a workaround, users could interpose a sanitizing layer in between untrusted input and Grackle query processing."}, {"lang": "es", "value": "Grackle es un servidor GraphQL escrito en functional Scala, construido en la pila Typelevel. La especificaci\u00f3n GraphQL requiere que los fragmentos de GraphQL no formen ciclos, ni directa ni indirectamente. Antes de la versi\u00f3n 0.18.0 de Grackle, ese requisito no se verificaba y las consultas con fragmentos c\u00edclicos se habr\u00edan aceptado para la verificaci\u00f3n y compilaci\u00f3n de tipos. El intento de compilaci\u00f3n de dichos fragmentos dar\u00eda como resultado que se generara un \"StackOverflowError\" de JVM. Se necesitar\u00eda cierto conocimiento del esquema GraphQL de una aplicaci\u00f3n para construir dicha consulta; sin embargo, no se necesitar\u00eda ning\u00fan conocimiento del rendimiento espec\u00edfico de la aplicaci\u00f3n ni de otras caracter\u00edsticas de comportamiento. Grackle usa la librer\u00eda cats-parse para analizar consultas GraphQL. Antes de la versi\u00f3n 0.18.0, Grackle hac\u00eda uso del operador \"recursive\" de cats-parse. Sin embargo, \"recursive\" actualmente no es seguro para pilas. \"recursive\" se us\u00f3 en tres lugares del analizador: conjuntos de selecci\u00f3n anidados, valores de entrada anidados (listas y objetos) y declaraciones de tipos de listas anidadas. En consecuencia, se podr\u00edan construir consultas con conjuntos de selecci\u00f3n, valores de entrada o tipos de listas profundamente anidados que explotaran esto, provocando que se lanzara una `StackOverflowException` de JVM durante el an\u00e1lisis. Debido a que esto sucede muy temprano en el procesamiento de consultas, no se requerir\u00eda ning\u00fan conocimiento espec\u00edfico del esquema GraphQL de una aplicaci\u00f3n para construir dicha consulta. La posibilidad de que peque\u00f1as consultas provoquen un desbordamiento de la pila es una posible vulnerabilidad de denegaci\u00f3n de servicio. Esto afecta potencialmente a todas las aplicaciones que utilizan Grackle y que tienen usuarios que no son de confianza. Ambos problemas de desbordamiento de pila se resolvieron en la versi\u00f3n v0.18.0 de Grackle. Como workaround, los usuarios podr\u00edan interponer una capa de sanitizaci\u00f3n entre las entradas que no son de confianza y el procesamiento de consultas de Grackle."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:grackle:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.18.0", "matchCriteriaId": "7CDE45B5-5A5B-487E-87ED-A62DCD8DD851"}]}]}], "references": [{"url": "https://github.com/typelevel/grackle/commit/56e244b91659cf385df590fc6c46695b6f36cbfd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/typelevel/grackle/releases/tag/v0.18.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/typelevel/grackle/security/advisories/GHSA-g56x-7j6w-g8r8", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/typelevel/grackle/commit/56e244b91659cf385df590fc6c46695b6f36cbfd"}}