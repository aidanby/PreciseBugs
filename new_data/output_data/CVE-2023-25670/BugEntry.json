{"buggy_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Implements a quantized eight-bit version of the matmul operation with bias,\n// relu and requantization fusion support utilizing oneDNN u8s8s32 inner\n// product API. Right now, this version can support\n//   - Input: quantized as uint8 via either MIN_FIRST or SCALE mode.\n//            SCALE mode is selected when input is guaranteed to be non-\n//            negative, e.g., MatMul is fed by Relu. Otherwise, MIN_FIRST is\n//            selected.\n//   - Weight: quantized to int8 via SCALE mode.\n//   - Bias: float32/int32. For int32, it is quantized according to input and\n//           filter min-max values.\n// Other than that, this op does not support other input combination yet.\n// When input is quantized to uint8 via MIN_FIRST, bias needs compensation.\n// The detailed algorithm is illustrated as below:\n//\n// Af32 is the original fp32 activation 2D tensor.\n// Min(Af32) is the minimum scalar value of Af32.\n// Max(Af32) is the maximum scalar value of Af32.\n// Qa is the quantization scale for activation.\n// Au8 is the quantized unsigned int8 activation tensor.\n// With SCALE quantization (used for non-negative Af32), Qa and Au8 can be\n// calculated as below:\n//    Qa = 255.0 / Max(Af32)\n//    Au8 = round(Qa * Af32).\n// With MIN_FIRST quantization, Q'a and A'u8 can be calculated as below:\n//    Q'a = 255.0 / (Max(Af32) - Min(Af32))\n//    A'u8 = round(Q'a * (Af32 - Min(Af32) * ones(Af32))),\n// where, ones(.) is a tensor of all 1s with the same shape of its argument and\n// round(.) rounds a number to its nearest integer.\n//\n// Wf32 is the original fp32 2D weight tensor.\n// MaxAbs(Wf32) is the maximum absolute scalar value of Wf32.\n// Qw is the quantization scale of weight.\n// Ws8 is the quantized signed int8 weight tensor.\n// Qw and Ws8 can be calculated as below:\n//    Qw = 127.0 / MaxAbs(Wf32)\n//    Ws8 = round(Qw * Wf32).\n//\n// Bf32 is the original fp32 1D bias tensor matching the innermost dim of\n// Wf32.\n// With SCALE quantization of activation, the scaled bias, Bs32, is calculated\n// as below:\n//      Bs32 = Qa * Qw * Bf32.\n// With MIN_FIRST quantization of activation, the scaled bias tensor with\n// compensation, B's32, is calculated as below:\n//      B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 * Wf32\n//            = Q'a * Qw * Bf32 + Q'a * Min(Af32) * 1 * Ws8.\n// where, 1 denotes a row vector matching the outermost dim of Wf32.\n//\n// The QuantizedMatMulWithBias op calculates 32bit integer output as below:\n//  - with SCALE activation quantization:\n//    Xs32 = Au8 * Ws8 + 1' * Bs32\n//         = Qa * Qw * Af32 * Wf32  + Qa * Qw * 1' * Bf32\n//         = Qa * Qw * (Af32 * Wf32 + 1' * Bf32) = Qa * Qw * Xf32,\n//    where, 1' denotes a column vector matching the outermost dim of Af32 and\n//    Xf32 represents the output of original fp32 MatMul with BiasAdd fusion.\n//\n//  - with MIN_FIRST activation quantization:\n//    Xs32 = A'u8 * Ws8 + 1' * B's32\n//         = Q'a * (Af32 - Min(Af32) * ones(Af32)) * Qw * Wf32 +\n//           Q'a * Qw * 1' * Bf32 + Q'a * Qw * Min(Af32) * 1' * 1 * Wf32\n//         = Q'a * Qw * (Af32 * Wf32 + 1' * Bf32)\n//         = Q'a * Qw * Xf32.\n//    Note that 1' * 1 = ones(Af32).\n//\n// The QuantizedMatMulWithBiasAndRelu op does the same calculation as above\n// except adding relu function for the 32bit integer output.\n//\n// The QuantizedMatMulWithBiasAndReluAndRequantize op does one more step of\n// requantize calculation based on above. Since the fusion ends with a Relu the\n// activation Xf32 at Relu, in the original fp32 graph, is guaranteed to be\n// non-negative. The requantize scale Qr is calculated from offline calibration.\n//    Qr = 255 / Max(Xf32)\n//    Xu8 = Qr * Xf32.\n//\n// More information of this implementation can be found in\n// https://software.intel.com/en-us/articles/lower-numerical-precision-deep-learning-inference-and-training\n#ifdef INTEL_MKL\n\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/kernels/fill_functor.h\"\n#include \"tensorflow/core/kernels/mkl/mkl_matmul_ops_common.h\"\n#include \"tensorflow/core/kernels/mkl/mkl_quantized_conv_ops.h\"\n#include \"tensorflow/core/kernels/no_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/mkl_threadpool.h\"\n#include \"tensorflow/core/util/mkl_util.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace {\nenum {\n  QUANTIZE_MODE_MIN_FIRST,\n  QUANTIZE_MODE_SCALED,\n};\n}  // namespace\n\nnamespace tensorflow {\n\ntemplate <typename Device, typename Tinput, typename Tweight, typename Tbias,\n          typename Toutput, bool native_format = false>\nclass MklDnnQuantizedMatMulOp : public MklDnnMatMulOpBase<Tweight, Toutput> {\n public:\n  virtual ~MklDnnQuantizedMatMulOp() {\n    if (this->input_bias_ != nullptr) {\n      delete this->input_bias_;\n      input_bias_ = nullptr;\n    }\n    if (this->scaled_bias_ != nullptr) {\n      delete this->scaled_bias_;\n      scaled_bias_ = nullptr;\n    }\n    if (this->comp_bias_ != nullptr) {\n      delete this->comp_bias_;\n      comp_bias_ = nullptr;\n    }\n  }\n\n  float* GetCompBiasBuffer(int size) {\n    if (comp_bias_ == nullptr) {\n      comp_bias_ = new float[size];\n    }\n    return comp_bias_;\n  }\n\n  explicit MklDnnQuantizedMatMulOp(OpKernelConstruction* context)\n      : MklDnnMatMulOpBase<Tweight, Toutput>(context) {\n    string mode_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"input_quant_mode\", &mode_string));\n    if (mode_string == \"MIN_FIRST\") {\n      mode_ = QUANTIZE_MODE_MIN_FIRST;\n    } else if (mode_string == \"SCALED\") {\n      mode_ = QUANTIZE_MODE_SCALED;\n    } else {\n      context->CtxFailure(errors::InvalidArgument(\n          \"Quantization mode must be either MIN_FIRST or SCALED, but received \",\n          mode_string));\n    }\n    this->is_weight_const_ = false;\n    if (context->HasAttr(\"is_weight_const\")) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"is_weight_const\",\n                                               &(this->is_weight_const_)));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    try {\n      // Input tensors\n      const Tensor& src_tensor = MklGetInput(context, this->kInputIndexSrc);\n      const Tensor& weight_tensor =\n          MklGetInput(context, this->kInputIndexWeight);\n      const Tensor& bias_tensor = MklGetInput(context, this->kInputIndexBias);\n\n      MklDnnShape src_mkl_shape, weight_mkl_shape;\n      GetMklShape(context, this->kInputIndexSrc, &src_mkl_shape, native_format);\n      GetMklShape(context, this->kInputIndexWeight, &weight_mkl_shape,\n                  native_format);\n      OP_REQUIRES(context, !weight_mkl_shape.IsMklTensor(),\n                  errors::InvalidArgument(\"Weight should not be in \"\n                                          \"MKL Layout\"));\n\n      MklDnnData<Tinput> src(&(this->cpu_engine_));\n      MklDnnData<Tweight> weight(&(this->cpu_engine_));\n\n      memory::dims src_dims, weight_dims;\n      memory::dims dst_dims_tf_order, dst_dims_mkl_order;\n\n      // Get shapes of input tensors in oneDNN order\n      auto src_tf_shape = src_mkl_shape.IsMklTensor()\n                              ? src_mkl_shape.GetTfShape()\n                              : src_tensor.shape();\n      auto weight_tf_shape = weight_mkl_shape.IsMklTensor()\n                                 ? weight_mkl_shape.GetTfShape()\n                                 : weight_tensor.shape();\n\n      src_dims = TFShapeToMklDnnDims(src_tf_shape);\n      weight_dims = TFShapeToMklDnnDims(weight_tf_shape);\n      dst_dims_mkl_order = {static_cast<int>(src_tf_shape.dim_size(0)),\n                            static_cast<int>(weight_tf_shape.dim_size(1))};\n\n      // Weight dims need to be reversed to create inner-product forward\n      // descriptor\n      weight_dims = {static_cast<int>(weight_tf_shape.dim_size(1)),\n                     static_cast<int>(weight_tf_shape.dim_size(0))};\n\n      // Create memory for user data.\n      // Describe how the inputs and outputs of inner-product look like. Also\n      // specify buffers containing actual input and output data.\n      Tensor* dst_tensor = nullptr;\n      auto input_output_fmt = memory::format_tag::nc;\n      auto input_output_fmt_mkldnn = MklTensorFormat::FORMAT_NC;\n\n      // If input is in MKL layout, then simply take input layout; otherwise,\n      // construct input TF layout. For TF layout, although input shape\n      // (src_dims) required is in oneDNN order, the layout is Tensorflow's\n      // layout depending on data format.\n      auto src_md =\n          src_mkl_shape.IsMklTensor()\n              ? src_mkl_shape.GetMklLayout()\n              : memory::desc(src_dims, MklDnnType<Tinput>(), input_output_fmt);\n      src.SetUsrMem(src_md, &src_tensor);\n\n      // Although weight shape (weight_dims) required is in oneDNN order,\n      // the layout is TensorFlow's layout.\n      auto weight_md = weight_mkl_shape.IsMklTensor()\n                           ? weight_mkl_shape.GetMklLayout()\n                           : memory::desc(weight_dims, MklDnnType<Tweight>(),\n                                          memory::format_tag::io);\n      weight.SetUsrMem(weight_md, &weight_tensor);\n\n      MklDnnMatMulFwdPrimitive<float, Tinput, Tweight, Tbias, Toutput>*\n          matmul_fwd = nullptr;\n      memory::dims bias_dims = {static_cast<int>(bias_tensor.dim_size(0))};\n\n      MklDnnMatMulFwdParams matmul_fwd_dims(src_dims, weight_dims, bias_dims,\n                                            dst_dims_mkl_order);\n\n      // Extend the basic parameters for data types and fusions.\n      this->ExtendMklDnnMatMulFwdParams(context, matmul_fwd_dims);\n\n      // Get a MatMul fwd from primitive pool.\n      matmul_fwd =\n          MklDnnMatMulFwdPrimitiveFactory<float, Tinput, Tweight, Tbias,\n                                          Toutput>::Get(matmul_fwd_dims, 0);\n\n      // Allocate output Tensor.\n      std::shared_ptr<dnnl::inner_product_forward::primitive_desc>\n          matmul_fwd_pd = matmul_fwd->GetPrimitiveDesc();\n      this->AllocateOutputTensor(context, *matmul_fwd_pd, dst_dims_mkl_order,\n                                 input_output_fmt_mkldnn, &dst_tensor,\n                                 native_format);\n\n      Toutput* dst_data =\n          reinterpret_cast<Toutput*>(dst_tensor->flat<Toutput>().data());\n\n      // Check if src and weight data need to be reordered.\n      Tinput* src_data = nullptr;\n      if (!native_format && src_md != matmul_fwd_pd->src_desc()) {\n        src.SetUsrMem(src_md, &src_tensor);\n        src.CheckReorderToOpMem(matmul_fwd_pd.get()->src_desc(),\n                                this->cpu_engine_, context);\n        src_data = static_cast<Tinput*>(src.GetOpMem().get_data_handle());\n      } else {\n        src_data = static_cast<Tinput*>(\n            const_cast<Tinput*>(src_tensor.flat<Tinput>().data()));\n      }\n\n      Tweight* weight_data = nullptr;\n      if (weight_md != matmul_fwd_pd->weights_desc()) {\n        bool is_weight_cached = false;\n        // For batch size 1, oneDNN expects that weight format is OI whereas\n        // TF default format is IO. So in that case convert weight from IO\n        // to OI for the first iteration and cache it to reuse in the\n        // subsequent iterations, if the weight is constant.\n        if (this->is_weight_const_) {\n          // Check if the weight is already cached or not\n          if (this->IsWeightCacheEmpty(context)) {\n            // Cache weight if it is not cached.\n            this->CacheWeight(context, matmul_fwd_pd, weight_data,\n                              weight_tensor, weight, weight_md);\n          }\n          weight_data =\n              this->GetCachedWeight(context, matmul_fwd_pd->weights_desc());\n          is_weight_cached = (weight_data != nullptr);\n        }\n\n        if (!is_weight_cached) {\n          weight.SetUsrMem(weight_md, &weight_tensor);\n          weight.CheckReorderToOpMem(matmul_fwd_pd.get()->weights_desc(),\n                                     this->cpu_engine_, context);\n          weight_data =\n              static_cast<Tweight*>(weight.GetOpMem().get_data_handle());\n        }\n\n      } else {\n        weight_data = static_cast<Tweight*>(\n            const_cast<Tweight*>(weight_tensor.flat<Tweight>().data()));\n      }\n\n      std::shared_ptr<stream> cpu_stream;\n      MklDnnThreadPool eigen_tp(context);\n      cpu_stream.reset(CreateStream(&eigen_tp, matmul_fwd->GetEngine()));\n\n      UserScratchPad<unsigned char> scratch_pad;\n      scratch_pad.AllocateSPTensor(matmul_fwd, context);\n\n      // Execute inner-product\n      Tbias* bias_data = this->GetBiasHandle(\n          context, matmul_fwd_pd, bias_tensor, weight_tensor, cpu_stream);\n      matmul_fwd->Execute(src_data, weight_data, bias_data, dst_data,\n                          scratch_pad.Get(), cpu_stream);\n    } catch (dnnl::error& e) {\n      string error_msg = tensorflow::strings::StrCat(\n          \"Status: \", e.status, \", message: \", string(e.message), \", in file \",\n          __FILE__, \":\", __LINE__);\n      OP_REQUIRES_OK(\n          context,\n          errors::Aborted(\"Operation received an exception:\", error_msg));\n    }\n    float min_output_value;\n    float max_output_value;\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value) {\n      // This is the case the inner-product and requantization are fused.\n      // \"min_freezed_output\" and \"max_freezed_output\" are the requested range\n      // for the output.\n      min_output_value = context->input(7).flat<float>()(0);\n      max_output_value = context->input(8).flat<float>()(0);\n    } else {\n      ComputeOutputRangeForInt32(context, &min_output_value, &max_output_value);\n    }\n\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value ||\n        std::is_same<Toutput, qint32>::value) {\n      Tensor* output_min = nullptr;\n      Tensor* output_max = nullptr;\n      MklDnnShape output_min_mkl_shape, output_max_mkl_shape;\n      output_min_mkl_shape.SetMklTensor(false);\n      output_max_mkl_shape.SetMklTensor(false);\n      AllocateOutputSetMklShape(context, 1, &output_min, {},\n                                output_min_mkl_shape, native_format);\n      AllocateOutputSetMklShape(context, 2, &output_max, {},\n                                output_max_mkl_shape, native_format);\n      output_min->flat<float>()(0) = min_output_value;\n      output_max->flat<float>()(0) = max_output_value;\n    }\n  }\n\n protected:\n  void ComputeOutputRangeForInt32(OpKernelContext* context,\n                                  float* min_output_value,\n                                  float* max_output_value) {\n    const float min_input = context->input(3).flat<float>()(0);\n    const float max_input = context->input(4).flat<float>()(0);\n    const float min_weight = context->input(5).flat<float>()(0);\n    const float max_weight = context->input(6).flat<float>()(0);\n    MklQuantizationRangeForMultiplication<quint8, qint8, qint32>(\n        min_input, max_input, min_weight, max_weight, min_output_value,\n        max_output_value);\n  }\n\n  virtual void ExtendMklDnnMatMulFwdParams(OpKernelContext* context,\n                                           MklDnnMatMulFwdParams& params) {\n    // Append data type names of input, weight, bias, and output.\n    params.dtypes.append(typeid(Tinput).name());\n    params.dtypes.append(typeid(Tweight).name());\n    params.dtypes.append(typeid(Tbias).name());\n    params.dtypes.append(typeid(Toutput).name());\n\n    // When the output type is quint8, the output data is requantized into\n    // quint8. A post_op \"output_scale\" is added to do the conversion.\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value ||\n        std::is_same<Toutput, float>::value) {\n      float min_output_value;\n      float max_output_value;\n      ComputeOutputRangeForInt32(context, &min_output_value, &max_output_value);\n      float scale_int32 =\n          std::max(std::abs(min_output_value), std::abs(max_output_value));\n      const float min_freezed_output = context->input(7).flat<float>()(0);\n      const float max_freezed_output = context->input(8).flat<float>()(0);\n      float scale_eightbit =\n          std::max(std::abs(min_freezed_output), std::abs(max_freezed_output));\n      float scale = 1.0;\n      if (std::is_same<Toutput, quint8>::value) {\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 23);\n      } else if (std::is_same<Toutput, qint8>::value) {\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 24);\n      } else if (std::is_same<Toutput, float>::value) {\n        scale = scale_int32 / static_cast<float>(1u << 31);\n      } else {\n        // TODO(intel-tf): Keep the default qint8 as before.\n        // Change to error later.\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 24);\n      }\n      std::vector<float> output_scale;\n      output_scale.push_back(scale);\n      params.post_op_params.push_back({\"output_scale\", output_scale});\n    }\n  }\n\n  // This function handles bias conversion and compensation for MIN_FIRST and\n  // SCALE mode. If input is quantized via MIN_FIRST,\n  //  B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 * Wf32\n  // If input is quantized via SCALE,\n  //   Bs32 = Qa * Qw * Bf32.\n  Tbias* GetBiasHandle(\n      OpKernelContext* context,\n      std::shared_ptr<dnnl::inner_product_forward::primitive_desc>&\n          mkldnn_matmul_fwd_pd,\n      const Tensor& bias_tensor, const Tensor& weight_tensor,\n      std::shared_ptr<stream> reorder_stream) {\n    // If the bias is qint32, it means the bias is already converted offline.\n    // and it can be added to matmul output directly.\n    if (std::is_same<Tbias, qint32>::value) {\n      return static_cast<Tbias*>(\n          const_cast<Tbias*>(bias_tensor.flat<Tbias>().data()));\n    } else {\n      // If the bias is fp32, then need to calculate the bias\n      const float min_input = context->input(3).flat<float>()(0);\n      const float max_input = context->input(4).flat<float>()(0);\n      const float min_weight = context->input(5).flat<float>()(0);\n      const float max_weight = context->input(6).flat<float>()(0);\n\n      std::vector<dnnl::primitive> net;\n      float out_scale;\n      // If the bias is float and input quantize is MIN_FIRST, bias has to be\n      // compensated with B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 *\n      // Wf32.\n      if (mode_ == QUANTIZE_MODE_MIN_FIRST) {\n        int k = weight_tensor.dim_size(0);\n        int n = weight_tensor.dim_size(1);\n        float* comp_bias = GetCompBiasBuffer(n);\n\n        qint8* wt_buf = static_cast<qint8*>(\n            const_cast<qint8*>(weight_tensor.flat<qint8>().data()));\n\n        const float* bias_buf = static_cast<float*>(\n            const_cast<float*>(bias_tensor.flat<float>().data()));\n\n        float qa_amin = 255 * min_input / (max_input - min_input);\n\n        out_scale = (255.0 * 127.0) /\n                    ((max_input - min_input) *\n                     std::max(std::abs(max_weight), std::abs(min_weight)));\n\n#ifndef ENABLE_ONEDNN_OPENMP\n        auto parallel_func = [&](int64 start, int64 end) {\n          for (int64 j = start; j < end; j++) {\n            int x = 0;\n            for (int64 i = 0; i < k; ++i) {\n              x += wt_buf[i * n + j];\n            }\n            comp_bias[j] =\n                ((bias_buf[j] * out_scale) + static_cast<float>(x * qa_amin));\n          }\n        };\n\n        const float kArithCost = 2.5f;\n        const float kMovCost = 1.0f;\n        float shard_cost = 4 * kArithCost + kMovCost;\n        const DeviceBase::CpuWorkerThreads& worker_threads =\n            *(context->device()->tensorflow_cpu_worker_threads());\n        Shard(worker_threads.num_threads, worker_threads.workers, n, shard_cost,\n              parallel_func);\n#else\n#pragma omp parallel for schedule(static)\n        for (int j = 0; j < n; ++j) {\n          int x = 0;\n          for (int i = 0; i < k; ++i) {\n            x += wt_buf[i * n + j];\n          }\n          comp_bias[j] =\n              ((bias_buf[j] * out_scale) + static_cast<float>(x * qa_amin));\n        }\n#endif  // !ENABLE_ONEDNN_OPENMP\n        return reinterpret_cast<Tbias*>(comp_bias_);\n\n      } else if (mode_ == QUANTIZE_MODE_SCALED) {\n        // If the bias is float and input quantize is SCALE, bias has to be\n        // compensated with Bs32 = Qa * Qw * Bf32.\n        out_scale = 255.0 * 127.0 / max_input *\n                    std::max(std::abs(max_weight), std::abs(min_weight));\n\n        std::vector<float> scales;\n        scales.push_back(out_scale);\n        dnnl::primitive_attr bias_attr;\n        bias_attr.set_output_scales(0, scales);\n\n        void* bias_buf = static_cast<void*>(\n            const_cast<Tbias*>(bias_tensor.flat<Tbias>().data()));\n        input_bias_ = new memory(mkldnn_matmul_fwd_pd->bias_desc(),\n                                 this->cpu_engine_, bias_buf);\n        scaled_bias_ =\n            new memory(mkldnn_matmul_fwd_pd->bias_desc(), this->cpu_engine_);\n\n        auto reorder_desc = dnnl::reorder::primitive_desc(\n            *input_bias_, *scaled_bias_, bias_attr);\n        net.push_back(dnnl::reorder(reorder_desc));\n        std::unordered_map<int, memory> reorder_net_args = {\n            {DNNL_ARG_FROM, *input_bias_}, {DNNL_ARG_TO, *scaled_bias_}};\n        net.at(0).execute(*reorder_stream, reorder_net_args);\n\n        return reinterpret_cast<Tbias*>(scaled_bias_->get_data_handle());\n      } else {\n        context->CtxFailure(\n            errors::InvalidArgument(\"Quantization mode must be\"\n                                    \"either MIN_FIRST or SCALED.\"));\n        return nullptr;\n      }\n    }\n  }\n\n private:\n  memory* input_bias_ = nullptr;\n  memory* scaled_bias_ = nullptr;\n\n  // Buffer to save the compensated bias\n  float* comp_bias_ = nullptr;\n\n  int mode_;\n};\n\ntemplate <typename Device, typename Tinput, typename Tweight, typename Tbias,\n          typename Toutput, bool native_format = false>\nclass MklDnnQuantizedMatMulReluOp\n    : public MklDnnQuantizedMatMulOp<Device, Tinput, Tweight, Tbias, Toutput,\n                                     native_format> {\n public:\n  virtual ~MklDnnQuantizedMatMulReluOp() {}\n\n  explicit MklDnnQuantizedMatMulReluOp(OpKernelConstruction* context)\n      : MklDnnQuantizedMatMulOp<Device, Tinput, Tweight, Tbias, Toutput,\n                                native_format>(context) {}\n\n protected:\n  void ExtendMklDnnMatMulFwdParams(OpKernelContext* context,\n                                   MklDnnMatMulFwdParams& params) override {\n    MklDnnQuantizedMatMulOp<Device, quint8, qint8, Tbias, Toutput,\n                            native_format>::ExtendMklDnnMatMulFwdParams(context,\n                                                                        params);\n    params.post_op_params.push_back({\"relu\", {1.0, 0.0, 0.0}});\n  }\n};\n\n#define REGISTER_MKL_KERNEL(op, kernel, bias_type, output_type, is_native)   \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(op)                                                               \\\n          .Device(DEVICE_CPU)                                                \\\n          .TypeConstraint<quint8>(\"T1\")                                      \\\n          .TypeConstraint<qint8>(\"T2\") BIAS_TYPE_CONSTRAINT(bias_type)       \\\n          .TypeConstraint<output_type>(\"Toutput\") LABEL,                     \\\n      kernel TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                           is_native));\n\n#define REGISTER_MKL_KERNEL_ALL_BIAS_TYPES(op, kernel, output_type, is_native) \\\n  REGISTER_MKL_KERNEL(op, kernel, float, output_type, is_native)               \\\n  REGISTER_MKL_KERNEL(op, kernel, qint32, output_type, is_native);\n\n#define LABEL\n#define TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                      is_native)\n#define BIAS_TYPE_CONSTRAINT(bias_type)\nREGISTER_MKL_KERNEL(\"QuantizedMatMulWithBiasAndRelu\", NoOp, float, qint32,\n                    false);\n#undef BIAS_TYPE_CONSTRAINT\n\n#define BIAS_TYPE_CONSTRAINT(bias_type) .TypeConstraint<bias_type>(\"Tbias\")\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBias\", NoOp, qint32,\n                                   false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\n    \"QuantizedMatMulWithBiasAndReluAndRequantize\", NoOp, quint8, false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBiasAndRequantize\", NoOp,\n                                   quint8, false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBiasAndDequantize\", NoOp,\n                                   float, false);\n#undef BIAS_TYPE_CONSTRAINT\n#undef TEMPLATE_ARGS\n#undef LABEL\n\n#define LABEL .Label(mkl_op_registry::kMklQuantizedOpLabel)\n#define TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                      is_native)                                        \\\n<CPUDevice, quint8, qint8, bias_type, output_type, is_native>\n#define BIAS_TYPE_CONSTRAINT(bias_type)\nREGISTER_MKL_KERNEL(\"_MklQuantizedMatMulWithBiasAndRelu\",\n                    MklDnnQuantizedMatMulReluOp, float, qint32, true);\n#undef BIAS_TYPE_CONSTRAINT\n\n#define BIAS_TYPE_CONSTRAINT(bias_type) .TypeConstraint<bias_type>(\"Tbias\")\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBias\",\n                                   MklDnnQuantizedMatMulOp, qint32, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\n    \"_MklQuantizedMatMulWithBiasAndReluAndRequantize\",\n    MklDnnQuantizedMatMulReluOp, quint8, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBiasAndRequantize\",\n                                   MklDnnQuantizedMatMulOp, quint8, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBiasAndDequantize\",\n                                   MklDnnQuantizedMatMulOp, float, true);\n#undef BIAS_TYPE_CONSTRAINT\n#undef TEMPLATE_ARGS\n#undef LABEL\n\n}  // namespace tensorflow\n\n#endif  // INTEL_MKL\n", "\ufeff/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#if defined(INTEL_MKL) && defined(ENABLE_MKL)\n#define EIGEN_USE_THREADS\n\n#include <functional>\n#include <memory>\n#include <vector>\n\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/fake_input.h\"\n#include \"tensorflow/core/framework/node_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_testutil.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/ops_testutil.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/platform/test.h\"\n\nnamespace tensorflow {\n\nclass QuantizedMatMulTest : public OpsTestBase {};\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias\nTEST_F(QuantizedMatMulTest, Small_withBias) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {1, 2, 3, 4});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // Final result after Bias addition:\n  // 74  + 1 = 75 , 80  + 2 = 82 , 86  + 3 = 89 , 92  + 4 = 96,\n  // 173 + 1 = 174, 188 + 2 = 190, 203 + 3 = 206, 218 + 4 = 222\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected, {75, 82, 89, 96, 174, 190, 206, 222});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with neg bias as well\nTEST_F(QuantizedMatMulTest, Small_withNegBias) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {100, -200, 300, -400});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // Final result after Bias addition:\n  // 74+100=174, 80-200=-120, 86+300=386, 92-400=-308,\n  // 173+100=273, 188-200=-12, 203+300=503, 218-400=-182\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected,\n                           {174, -120, 386, -308, 273, -12, 503, -182});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 (converted from signed integer)\n// and B of type int8  are multiplied and the result is added with float bias\nTEST_F(QuantizedMatMulTest, Small_WithNegInp) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"input_quant_mode\", \"MIN_FIRST\")\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // The A matrix is:\n  // |  -1 |  -5 |  -9 |\n  // |  -2 |  -6 | -10 |\n  // |  -3 |  -7 | -11 |\n  // |  -4 |  -8 | -12 |\n  // The input array only contains unsigned bytes, so we specify the actual\n  // quantized values as Au8 = (Af32 - Min(A\ud835\udc5332)) * Qa, where\n  // Qa = 255/(Max(A\ud835\udc5332) - Min(A\ud835\udc5332)). For example, -1 is represented\n  // as -1 + 12, or 11 as Qa = 255/(243+12).\n  AddInputFromArray<quint8>(TensorShape({4, 3}),\n                            {11, 7, 3, 10, 6, 2, 9, 5, 1, 8, 4, 0});\n\n  // The B matrix is:\n  // |   1 |   4|\n  // |   2 |   5|\n  // |   3 |   6|\n  AddInputFromArray<qint8>(TensorShape({3, 2}), {1, 4, 2, 5, 3, 6});\n  // Bias\n  AddInputFromArray<float>(TensorShape({2}), {10.0f, 20.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-12.0f});\n  AddInputFromArray<float>(TensorShape({1}), {243.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // First calculate C = A * B,\n  // so we expect to get these results for MatMul:\n  // 1*-1 + 2*-5 + 3*-9 = -38\n  // 4*-1 + 5*-5 + 6*-9 = -83\n  // 1*-2 + 2*-6 + 3*-10 = -44\n  // 4*-2 + 5*-6 + 6*-10 = -98\n  // 1*-3 + 2*-7 + 3*-11 = -50\n  // 4*-3 + 5*-7 + 6*-11 = -113\n  // 1*-4 + 2*-8 + 3*-12 = -56\n  // 4*-4 + 5*-8 + 6*-12 = -128\n  // |  -38 |  -83 |\n  // |  -44 |  -98 |\n  // |  -50 | -113 |\n  // |  -56 | -128 |\n  // After Bias add {10, 20}, the expected result is\n  // |  -28 |  -63 |\n  // |  -34 |  -78 |\n  // |  -40 |  -93 |\n  // |  -46 | -108 |\n  Tensor expected(allocator(), DT_QINT32, TensorShape({4, 2}));\n  test::FillValues<qint32>(&expected,\n                           {-28, -63, -34, -78, -40, -93, -46, -108});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias and Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndReq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndRequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<quint8>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Requantize\n  // requantscale = scale_int32 / scale_eightbit / static_cast<float>(1 << 23)\n  // requantscale = 2^31/255/2^23 ~= 1.00392\n  // 84 * 1.00392 ~= 84.329 ~= 84\n  // 60 * 1.00392 ~= 60.235 ~= 60\n  // 116 * 1.00392 ~= 116.454 ~= 116\n  // 52 * 1.00392 ~= 52.203 ~= 52\n  // 183 * 1.00392 ~= 183.717 ~= 184\n  // 168 * 1.00392 ~= 168.658 ~= 169\n  // 233 * 1.00392 ~= 233.913 ~= 234\n  // 178 * 1.00392 ~= 178.698 ~= 179\n\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({2, 4}));\n  test::FillValues<quint8>(&expected, {84, 60, 116, 52, 184, 169, 234, 179});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<quint8>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias and Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndDeq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndDequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<float>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Dequantize\n  // requantscale = scale_int32 / static_cast<float>(1 << 31)\n  // requantscale = 2^31/2^31 ~= 1.0000\n  // 84 * 1.00000 ~= 84\n  // 60 * 1.00000 ~=  60\n  // 116 * 1.00000 ~= 116\n  // 52 * 1.00000 ~= 52\n  // 183 * 1.00000 ~= 183\n  // 168 * 1.00000 ~= 168\n  // 233 * 1.00000 ~= 233\n  // 178 * 1.00000 ~= 178\n\n  Tensor expected(allocator(), DT_FLOAT, TensorShape({2, 4}));\n  test::FillValues<float>(&expected, {84, 60, 116, 52, 183, 168, 233, 178});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<float>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with float bias and then performed relu on the result\nTEST_F(QuantizedMatMulTest, Small_withBiasAndRelu) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndRelu\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<float>(TensorShape({4}),\n                           {100.0f, -200.0f, 300.0f, -400.0f});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+100=174, 80-200=-120, 86+300=386, 92-400=-308,\n  // 173+100=273, 188-200=-12, 203+300=503, 218-400=-182\n  // After Relu\n  // 174, 0, 386, 0, 273, 0, 503, 0\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected, {174, 0, 386, 0, 273, 0, 503, 0});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Simple test for Matrix multiplication with Bias, Relu and\n// Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndReluAndReq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndReluAndRequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<quint8>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Relu\n  // 84, 60, 116, 52, 183, 168, 233, 178\n  // After Requantize\n  // requantscale = scale_int32 / scale_eightbit / static_cast<float>(1 << 23)\n  // requantscale = 2^31/255/2^23 ~= 1.00392\n  // 84 * 1.00392 ~= 84.329 ~= 84\n  // 60 * 1.00392 ~= 60.235 ~= 60\n  // 116 * 1.00392 ~= 116.454 ~= 116\n  // 52 * 1.00392 ~= 52.203 ~= 52\n  // 183 * 1.00392 ~= 183.717 ~= 184\n  // 168 * 1.00392 ~= 168.658 ~= 169\n  // 233 * 1.00392 ~= 233.913 ~= 234\n  // 178 * 1.00392 ~= 178.698 ~= 179\n\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({2, 4}));\n  test::FillValues<quint8>(&expected, {84, 60, 116, 52, 184, 169, 234, 179});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<quint8>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8 are multiplied\n// and the result is added with int32 bias\n// For the first time B matrix will be reordered and cached which will be\n// used for subsequent runs\nTEST_F(QuantizedMatMulTest, Small_withWeightCached) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // The tensor shape of (1,3) is selected to allow the oneDNN expected\n  // weight format to be made as OI rather than IO for BS > 1\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  AddInputFromArray<quint8>(TensorShape({1, 3}), {1, 2, 3});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {1, 2, 3, 4});\n  AddInputFromArray<float>(TensorShape({1}), {0});\n  AddInputFromArray<float>(TensorShape({1}), {255.0f});\n  AddInputFromArray<float>(TensorShape({1}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({1}), {127.0f});\n\n  int64 start_time = Env::Default()->NowMicros();\n  TF_ASSERT_OK(RunOpKernel());\n  int64 end_time = Env::Default()->NowMicros();\n  int64 total_duration_unopt = end_time - start_time;\n\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // Final result after Bias addition:\n  // 74  + 1 = 75 , 80  + 2 = 82 , 86  + 3 = 89 , 92  + 4 = 96,\n  Tensor expected(allocator(), DT_QINT32, TensorShape({1, 4}));\n  test::FillValues<qint32>(&expected, {75, 82, 89, 96});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n\n  // Test for the second time to use the cached weight\n  start_time = Env::Default()->NowMicros();\n  TF_ASSERT_OK(RunOpKernel());\n  end_time = Env::Default()->NowMicros();\n  int64 total_duration_opt = end_time - start_time;\n  LOG(INFO) << \" Time taken by first call : \" << total_duration_unopt\n            << \", Time taken after Caching : \" << total_duration_opt;\n\n  // Cached call should be at least 20% faster.\n  EXPECT_LT(total_duration_opt, total_duration_unopt * 0.8);\n\n  // Compare the result with expected result\n  const Tensor& output_new = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output_new);\n}\n\n}  // namespace tensorflow\n\n#endif  // INTEL_MKL && ENABLE_MKL\n"], "fixing_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Implements a quantized eight-bit version of the matmul operation with bias,\n// relu and requantization fusion support utilizing oneDNN u8s8s32 inner\n// product API. Right now, this version can support\n//   - Input: quantized as uint8 via either MIN_FIRST or SCALE mode.\n//            SCALE mode is selected when input is guaranteed to be non-\n//            negative, e.g., MatMul is fed by Relu. Otherwise, MIN_FIRST is\n//            selected.\n//   - Weight: quantized to int8 via SCALE mode.\n//   - Bias: float32/int32. For int32, it is quantized according to input and\n//           filter min-max values.\n// Other than that, this op does not support other input combination yet.\n// When input is quantized to uint8 via MIN_FIRST, bias needs compensation.\n// The detailed algorithm is illustrated as below:\n//\n// Af32 is the original fp32 activation 2D tensor.\n// Min(Af32) is the minimum scalar value of Af32.\n// Max(Af32) is the maximum scalar value of Af32.\n// Qa is the quantization scale for activation.\n// Au8 is the quantized unsigned int8 activation tensor.\n// With SCALE quantization (used for non-negative Af32), Qa and Au8 can be\n// calculated as below:\n//    Qa = 255.0 / Max(Af32)\n//    Au8 = round(Qa * Af32).\n// With MIN_FIRST quantization, Q'a and A'u8 can be calculated as below:\n//    Q'a = 255.0 / (Max(Af32) - Min(Af32))\n//    A'u8 = round(Q'a * (Af32 - Min(Af32) * ones(Af32))),\n// where, ones(.) is a tensor of all 1s with the same shape of its argument and\n// round(.) rounds a number to its nearest integer.\n//\n// Wf32 is the original fp32 2D weight tensor.\n// MaxAbs(Wf32) is the maximum absolute scalar value of Wf32.\n// Qw is the quantization scale of weight.\n// Ws8 is the quantized signed int8 weight tensor.\n// Qw and Ws8 can be calculated as below:\n//    Qw = 127.0 / MaxAbs(Wf32)\n//    Ws8 = round(Qw * Wf32).\n//\n// Bf32 is the original fp32 1D bias tensor matching the innermost dim of\n// Wf32.\n// With SCALE quantization of activation, the scaled bias, Bs32, is calculated\n// as below:\n//      Bs32 = Qa * Qw * Bf32.\n// With MIN_FIRST quantization of activation, the scaled bias tensor with\n// compensation, B's32, is calculated as below:\n//      B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 * Wf32\n//            = Q'a * Qw * Bf32 + Q'a * Min(Af32) * 1 * Ws8.\n// where, 1 denotes a row vector matching the outermost dim of Wf32.\n//\n// The QuantizedMatMulWithBias op calculates 32bit integer output as below:\n//  - with SCALE activation quantization:\n//    Xs32 = Au8 * Ws8 + 1' * Bs32\n//         = Qa * Qw * Af32 * Wf32  + Qa * Qw * 1' * Bf32\n//         = Qa * Qw * (Af32 * Wf32 + 1' * Bf32) = Qa * Qw * Xf32,\n//    where, 1' denotes a column vector matching the outermost dim of Af32 and\n//    Xf32 represents the output of original fp32 MatMul with BiasAdd fusion.\n//\n//  - with MIN_FIRST activation quantization:\n//    Xs32 = A'u8 * Ws8 + 1' * B's32\n//         = Q'a * (Af32 - Min(Af32) * ones(Af32)) * Qw * Wf32 +\n//           Q'a * Qw * 1' * Bf32 + Q'a * Qw * Min(Af32) * 1' * 1 * Wf32\n//         = Q'a * Qw * (Af32 * Wf32 + 1' * Bf32)\n//         = Q'a * Qw * Xf32.\n//    Note that 1' * 1 = ones(Af32).\n//\n// The QuantizedMatMulWithBiasAndRelu op does the same calculation as above\n// except adding relu function for the 32bit integer output.\n//\n// The QuantizedMatMulWithBiasAndReluAndRequantize op does one more step of\n// requantize calculation based on above. Since the fusion ends with a Relu the\n// activation Xf32 at Relu, in the original fp32 graph, is guaranteed to be\n// non-negative. The requantize scale Qr is calculated from offline calibration.\n//    Qr = 255 / Max(Xf32)\n//    Xu8 = Qr * Xf32.\n//\n// More information of this implementation can be found in\n// https://software.intel.com/en-us/articles/lower-numerical-precision-deep-learning-inference-and-training\n#ifdef INTEL_MKL\n\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/kernels/fill_functor.h\"\n#include \"tensorflow/core/kernels/mkl/mkl_matmul_ops_common.h\"\n#include \"tensorflow/core/kernels/mkl/mkl_quantized_conv_ops.h\"\n#include \"tensorflow/core/kernels/no_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/mkl_threadpool.h\"\n#include \"tensorflow/core/util/mkl_util.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace {\nenum {\n  QUANTIZE_MODE_MIN_FIRST,\n  QUANTIZE_MODE_SCALED,\n};\n}  // namespace\n\nnamespace tensorflow {\n\ntemplate <typename Device, typename Tinput, typename Tweight, typename Tbias,\n          typename Toutput, bool native_format = false>\nclass MklDnnQuantizedMatMulOp : public MklDnnMatMulOpBase<Tweight, Toutput> {\n public:\n  virtual ~MklDnnQuantizedMatMulOp() {\n    if (this->input_bias_ != nullptr) {\n      delete this->input_bias_;\n      input_bias_ = nullptr;\n    }\n    if (this->scaled_bias_ != nullptr) {\n      delete this->scaled_bias_;\n      scaled_bias_ = nullptr;\n    }\n    if (this->comp_bias_ != nullptr) {\n      delete this->comp_bias_;\n      comp_bias_ = nullptr;\n    }\n  }\n\n  float* GetCompBiasBuffer(int size) {\n    if (comp_bias_ == nullptr) {\n      comp_bias_ = new float[size];\n    }\n    return comp_bias_;\n  }\n\n  explicit MklDnnQuantizedMatMulOp(OpKernelConstruction* context)\n      : MklDnnMatMulOpBase<Tweight, Toutput>(context) {\n    string mode_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"input_quant_mode\", &mode_string));\n    if (mode_string == \"MIN_FIRST\") {\n      mode_ = QUANTIZE_MODE_MIN_FIRST;\n    } else if (mode_string == \"SCALED\") {\n      mode_ = QUANTIZE_MODE_SCALED;\n    } else {\n      context->CtxFailure(errors::InvalidArgument(\n          \"Quantization mode must be either MIN_FIRST or SCALED, but received \",\n          mode_string));\n    }\n    this->is_weight_const_ = false;\n    if (context->HasAttr(\"is_weight_const\")) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"is_weight_const\",\n                                               &(this->is_weight_const_)));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    try {\n      // Input tensors\n      const Tensor& src_tensor = MklGetInput(context, this->kInputIndexSrc);\n      const Tensor& weight_tensor =\n          MklGetInput(context, this->kInputIndexWeight);\n      const Tensor& bias_tensor = MklGetInput(context, this->kInputIndexBias);\n\n      MklDnnShape src_mkl_shape, weight_mkl_shape;\n      GetMklShape(context, this->kInputIndexSrc, &src_mkl_shape, native_format);\n      GetMklShape(context, this->kInputIndexWeight, &weight_mkl_shape,\n                  native_format);\n      OP_REQUIRES(context, !weight_mkl_shape.IsMklTensor(),\n                  errors::InvalidArgument(\"Weight should not be in \"\n                                          \"MKL Layout\"));\n\n      MklDnnData<Tinput> src(&(this->cpu_engine_));\n      MklDnnData<Tweight> weight(&(this->cpu_engine_));\n\n      memory::dims src_dims, weight_dims;\n      memory::dims dst_dims_tf_order, dst_dims_mkl_order;\n\n      // Get shapes of input tensors in oneDNN order\n      auto src_tf_shape = src_mkl_shape.IsMklTensor()\n                              ? src_mkl_shape.GetTfShape()\n                              : src_tensor.shape();\n      auto weight_tf_shape = weight_mkl_shape.IsMklTensor()\n                                 ? weight_mkl_shape.GetTfShape()\n                                 : weight_tensor.shape();\n\n      src_dims = TFShapeToMklDnnDims(src_tf_shape);\n      weight_dims = TFShapeToMklDnnDims(weight_tf_shape);\n      dst_dims_mkl_order = {static_cast<int>(src_tf_shape.dim_size(0)),\n                            static_cast<int>(weight_tf_shape.dim_size(1))};\n\n      // Weight dims need to be reversed to create inner-product forward\n      // descriptor\n      weight_dims = {static_cast<int>(weight_tf_shape.dim_size(1)),\n                     static_cast<int>(weight_tf_shape.dim_size(0))};\n\n      // Create memory for user data.\n      // Describe how the inputs and outputs of inner-product look like. Also\n      // specify buffers containing actual input and output data.\n      Tensor* dst_tensor = nullptr;\n      auto input_output_fmt = memory::format_tag::nc;\n      auto input_output_fmt_mkldnn = MklTensorFormat::FORMAT_NC;\n\n      // If input is in MKL layout, then simply take input layout; otherwise,\n      // construct input TF layout. For TF layout, although input shape\n      // (src_dims) required is in oneDNN order, the layout is Tensorflow's\n      // layout depending on data format.\n      auto src_md =\n          src_mkl_shape.IsMklTensor()\n              ? src_mkl_shape.GetMklLayout()\n              : memory::desc(src_dims, MklDnnType<Tinput>(), input_output_fmt);\n      src.SetUsrMem(src_md, &src_tensor);\n\n      // Although weight shape (weight_dims) required is in oneDNN order,\n      // the layout is TensorFlow's layout.\n      auto weight_md = weight_mkl_shape.IsMklTensor()\n                           ? weight_mkl_shape.GetMklLayout()\n                           : memory::desc(weight_dims, MklDnnType<Tweight>(),\n                                          memory::format_tag::io);\n      weight.SetUsrMem(weight_md, &weight_tensor);\n\n      MklDnnMatMulFwdPrimitive<float, Tinput, Tweight, Tbias, Toutput>*\n          matmul_fwd = nullptr;\n      memory::dims bias_dims = {static_cast<int>(bias_tensor.dim_size(0))};\n\n      MklDnnMatMulFwdParams matmul_fwd_dims(src_dims, weight_dims, bias_dims,\n                                            dst_dims_mkl_order);\n\n      // Extend the basic parameters for data types and fusions.\n      this->ExtendMklDnnMatMulFwdParams(context, matmul_fwd_dims);\n\n      // Get a MatMul fwd from primitive pool.\n      matmul_fwd =\n          MklDnnMatMulFwdPrimitiveFactory<float, Tinput, Tweight, Tbias,\n                                          Toutput>::Get(matmul_fwd_dims, 0);\n\n      // Allocate output Tensor.\n      std::shared_ptr<dnnl::inner_product_forward::primitive_desc>\n          matmul_fwd_pd = matmul_fwd->GetPrimitiveDesc();\n      this->AllocateOutputTensor(context, *matmul_fwd_pd, dst_dims_mkl_order,\n                                 input_output_fmt_mkldnn, &dst_tensor,\n                                 native_format);\n\n      Toutput* dst_data =\n          reinterpret_cast<Toutput*>(dst_tensor->flat<Toutput>().data());\n\n      // Check if src and weight data need to be reordered.\n      Tinput* src_data = nullptr;\n      if (!native_format && src_md != matmul_fwd_pd->src_desc()) {\n        src.SetUsrMem(src_md, &src_tensor);\n        src.CheckReorderToOpMem(matmul_fwd_pd.get()->src_desc(),\n                                this->cpu_engine_, context);\n        src_data = static_cast<Tinput*>(src.GetOpMem().get_data_handle());\n      } else {\n        src_data = static_cast<Tinput*>(\n            const_cast<Tinput*>(src_tensor.flat<Tinput>().data()));\n      }\n\n      Tweight* weight_data = nullptr;\n      if (weight_md != matmul_fwd_pd->weights_desc()) {\n        bool is_weight_cached = false;\n        // For batch size 1, oneDNN expects that weight format is OI whereas\n        // TF default format is IO. So in that case convert weight from IO\n        // to OI for the first iteration and cache it to reuse in the\n        // subsequent iterations, if the weight is constant.\n        if (this->is_weight_const_) {\n          // Check if the weight is already cached or not\n          if (this->IsWeightCacheEmpty(context)) {\n            // Cache weight if it is not cached.\n            this->CacheWeight(context, matmul_fwd_pd, weight_data,\n                              weight_tensor, weight, weight_md);\n          }\n          weight_data =\n              this->GetCachedWeight(context, matmul_fwd_pd->weights_desc());\n          is_weight_cached = (weight_data != nullptr);\n        }\n\n        if (!is_weight_cached) {\n          weight.SetUsrMem(weight_md, &weight_tensor);\n          weight.CheckReorderToOpMem(matmul_fwd_pd.get()->weights_desc(),\n                                     this->cpu_engine_, context);\n          weight_data =\n              static_cast<Tweight*>(weight.GetOpMem().get_data_handle());\n        }\n\n      } else {\n        weight_data = static_cast<Tweight*>(\n            const_cast<Tweight*>(weight_tensor.flat<Tweight>().data()));\n      }\n\n      std::shared_ptr<stream> cpu_stream;\n      MklDnnThreadPool eigen_tp(context);\n      cpu_stream.reset(CreateStream(&eigen_tp, matmul_fwd->GetEngine()));\n\n      UserScratchPad<unsigned char> scratch_pad;\n      scratch_pad.AllocateSPTensor(matmul_fwd, context);\n\n      // Execute inner-product\n      Tbias* bias_data = this->GetBiasHandle(\n          context, matmul_fwd_pd, bias_tensor, weight_tensor, cpu_stream);\n      matmul_fwd->Execute(src_data, weight_data, bias_data, dst_data,\n                          scratch_pad.Get(), cpu_stream);\n    } catch (dnnl::error& e) {\n      string error_msg = tensorflow::strings::StrCat(\n          \"Status: \", e.status, \", message: \", string(e.message), \", in file \",\n          __FILE__, \":\", __LINE__);\n      OP_REQUIRES_OK(\n          context,\n          errors::Aborted(\"Operation received an exception:\", error_msg));\n    }\n    float min_output_value;\n    float max_output_value;\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value) {\n      // This is the case the inner-product and requantization are fused.\n      // \"min_freezed_output\" and \"max_freezed_output\" are the requested range\n      // for the output.\n      const Tensor& min_freezed_tensor = context->input(7);\n      const Tensor& max_freezed_tensor = context->input(8);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(min_freezed_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"`min_freezed_output` must be rank 0 but is rank \",\n                      min_freezed_tensor.dims()));\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(max_freezed_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"`max_freezed_output` must be rank 0 but is rank \",\n                      max_freezed_tensor.dims()));\n      min_output_value = min_freezed_tensor.scalar<float>()();\n      max_output_value = max_freezed_tensor.scalar<float>()();\n    } else {\n      ComputeOutputRangeForInt32(context, &min_output_value, &max_output_value);\n    }\n\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value ||\n        std::is_same<Toutput, qint32>::value) {\n      Tensor* output_min = nullptr;\n      Tensor* output_max = nullptr;\n      MklDnnShape output_min_mkl_shape, output_max_mkl_shape;\n      output_min_mkl_shape.SetMklTensor(false);\n      output_max_mkl_shape.SetMklTensor(false);\n      AllocateOutputSetMklShape(context, 1, &output_min, {},\n                                output_min_mkl_shape, native_format);\n      AllocateOutputSetMklShape(context, 2, &output_max, {},\n                                output_max_mkl_shape, native_format);\n      output_min->flat<float>()(0) = min_output_value;\n      output_max->flat<float>()(0) = max_output_value;\n    }\n  }\n\n protected:\n  void ComputeOutputRangeForInt32(OpKernelContext* context,\n                                  float* min_output_value,\n                                  float* max_output_value) {\n    const float min_input = context->input(3).scalar<float>()();\n    const float max_input = context->input(4).scalar<float>()();\n    const float min_weight = context->input(5).scalar<float>()();\n    const float max_weight = context->input(6).scalar<float>()();\n    MklQuantizationRangeForMultiplication<quint8, qint8, qint32>(\n        min_input, max_input, min_weight, max_weight, min_output_value,\n        max_output_value);\n  }\n\n  virtual void ExtendMklDnnMatMulFwdParams(OpKernelContext* context,\n                                           MklDnnMatMulFwdParams& params) {\n    // Append data type names of input, weight, bias, and output.\n    params.dtypes.append(typeid(Tinput).name());\n    params.dtypes.append(typeid(Tweight).name());\n    params.dtypes.append(typeid(Tbias).name());\n    params.dtypes.append(typeid(Toutput).name());\n\n    // min-max values for input and weight should be scalar.\n    const Tensor& min_input_tensor = context->input(3);\n    const Tensor& max_input_tensor = context->input(4);\n    const Tensor& min_weight_tensor = context->input(5);\n    const Tensor& max_weight_tensor = context->input(6);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),\n                errors::InvalidArgument(\"`min_a` must be rank 0 but is rank \",\n                                        min_input_tensor.dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),\n                errors::InvalidArgument(\"`max_a` must be rank 0 but is rank \",\n                                        max_input_tensor.dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_weight_tensor.shape()),\n                errors::InvalidArgument(\"`min_b` must be rank 0 but is rank \",\n                                        min_weight_tensor.dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_weight_tensor.shape()),\n                errors::InvalidArgument(\"`max_b` must be rank 0 but is rank \",\n                                        max_weight_tensor.dims()));\n\n    // When the output type is quint8, the output data is requantized into\n    // quint8. A post_op \"output_scale\" is added to do the conversion.\n    if (std::is_same<Toutput, quint8>::value ||\n        std::is_same<Toutput, qint8>::value ||\n        std::is_same<Toutput, float>::value) {\n      float min_output_value;\n      float max_output_value;\n      ComputeOutputRangeForInt32(context, &min_output_value, &max_output_value);\n      float scale_int32 =\n          std::max(std::abs(min_output_value), std::abs(max_output_value));\n      const Tensor& min_freezed_tensor = context->input(7);\n      const Tensor& max_freezed_tensor = context->input(8);\n      // min-max values of freezed output range should be scalar.\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(min_freezed_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"`min_freezed_output` must be rank 0 but is rank \",\n                      min_freezed_tensor.dims()));\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(max_freezed_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"`max_freezed_output` must be rank 0 but is rank \",\n                      max_freezed_tensor.dims()));\n      const float min_freezed_output = min_freezed_tensor.scalar<float>()();\n      const float max_freezed_output = max_freezed_tensor.scalar<float>()();\n      float scale_eightbit =\n          std::max(std::abs(min_freezed_output), std::abs(max_freezed_output));\n      float scale = 1.0;\n      if (std::is_same<Toutput, quint8>::value) {\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 23);\n      } else if (std::is_same<Toutput, qint8>::value) {\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 24);\n      } else if (std::is_same<Toutput, float>::value) {\n        scale = scale_int32 / static_cast<float>(1u << 31);\n      } else {\n        // TODO(intel-tf): Keep the default qint8 as before.\n        // Change to error later.\n        scale = scale_int32 / scale_eightbit / static_cast<float>(1u << 24);\n      }\n      std::vector<float> output_scale;\n      output_scale.push_back(scale);\n      params.post_op_params.push_back({\"output_scale\", output_scale});\n    }\n  }\n\n  // This function handles bias conversion and compensation for MIN_FIRST and\n  // SCALE mode. If input is quantized via MIN_FIRST,\n  //  B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 * Wf32\n  // If input is quantized via SCALE,\n  //   Bs32 = Qa * Qw * Bf32.\n  Tbias* GetBiasHandle(\n      OpKernelContext* context,\n      std::shared_ptr<dnnl::inner_product_forward::primitive_desc>&\n          mkldnn_matmul_fwd_pd,\n      const Tensor& bias_tensor, const Tensor& weight_tensor,\n      std::shared_ptr<stream> reorder_stream) {\n    // If the bias is qint32, it means the bias is already converted offline.\n    // and it can be added to matmul output directly.\n    if (std::is_same<Tbias, qint32>::value) {\n      return static_cast<Tbias*>(\n          const_cast<Tbias*>(bias_tensor.flat<Tbias>().data()));\n    } else {\n      // If the bias is fp32, then need to calculate the bias\n      const float min_input = context->input(3).flat<float>()(0);\n      const float max_input = context->input(4).flat<float>()(0);\n      const float min_weight = context->input(5).flat<float>()(0);\n      const float max_weight = context->input(6).flat<float>()(0);\n\n      std::vector<dnnl::primitive> net;\n      float out_scale;\n      // If the bias is float and input quantize is MIN_FIRST, bias has to be\n      // compensated with B's32 = Q'a * Qw * Bf32 + Q'a * Qw * Min(Af32) * 1 *\n      // Wf32.\n      if (mode_ == QUANTIZE_MODE_MIN_FIRST) {\n        int k = weight_tensor.dim_size(0);\n        int n = weight_tensor.dim_size(1);\n        float* comp_bias = GetCompBiasBuffer(n);\n\n        qint8* wt_buf = static_cast<qint8*>(\n            const_cast<qint8*>(weight_tensor.flat<qint8>().data()));\n\n        const float* bias_buf = static_cast<float*>(\n            const_cast<float*>(bias_tensor.flat<float>().data()));\n\n        float qa_amin = 255 * min_input / (max_input - min_input);\n\n        out_scale = (255.0 * 127.0) /\n                    ((max_input - min_input) *\n                     std::max(std::abs(max_weight), std::abs(min_weight)));\n\n#ifndef ENABLE_ONEDNN_OPENMP\n        auto parallel_func = [&](int64 start, int64 end) {\n          for (int64 j = start; j < end; j++) {\n            int x = 0;\n            for (int64 i = 0; i < k; ++i) {\n              x += wt_buf[i * n + j];\n            }\n            comp_bias[j] =\n                ((bias_buf[j] * out_scale) + static_cast<float>(x * qa_amin));\n          }\n        };\n\n        const float kArithCost = 2.5f;\n        const float kMovCost = 1.0f;\n        float shard_cost = 4 * kArithCost + kMovCost;\n        const DeviceBase::CpuWorkerThreads& worker_threads =\n            *(context->device()->tensorflow_cpu_worker_threads());\n        Shard(worker_threads.num_threads, worker_threads.workers, n, shard_cost,\n              parallel_func);\n#else\n#pragma omp parallel for schedule(static)\n        for (int j = 0; j < n; ++j) {\n          int x = 0;\n          for (int i = 0; i < k; ++i) {\n            x += wt_buf[i * n + j];\n          }\n          comp_bias[j] =\n              ((bias_buf[j] * out_scale) + static_cast<float>(x * qa_amin));\n        }\n#endif  // !ENABLE_ONEDNN_OPENMP\n        return reinterpret_cast<Tbias*>(comp_bias_);\n\n      } else if (mode_ == QUANTIZE_MODE_SCALED) {\n        // If the bias is float and input quantize is SCALE, bias has to be\n        // compensated with Bs32 = Qa * Qw * Bf32.\n        out_scale = 255.0 * 127.0 / max_input *\n                    std::max(std::abs(max_weight), std::abs(min_weight));\n\n        std::vector<float> scales;\n        scales.push_back(out_scale);\n        dnnl::primitive_attr bias_attr;\n        bias_attr.set_output_scales(0, scales);\n\n        void* bias_buf = static_cast<void*>(\n            const_cast<Tbias*>(bias_tensor.flat<Tbias>().data()));\n        input_bias_ = new memory(mkldnn_matmul_fwd_pd->bias_desc(),\n                                 this->cpu_engine_, bias_buf);\n        scaled_bias_ =\n            new memory(mkldnn_matmul_fwd_pd->bias_desc(), this->cpu_engine_);\n\n        auto reorder_desc = dnnl::reorder::primitive_desc(\n            *input_bias_, *scaled_bias_, bias_attr);\n        net.push_back(dnnl::reorder(reorder_desc));\n        std::unordered_map<int, memory> reorder_net_args = {\n            {DNNL_ARG_FROM, *input_bias_}, {DNNL_ARG_TO, *scaled_bias_}};\n        net.at(0).execute(*reorder_stream, reorder_net_args);\n\n        return reinterpret_cast<Tbias*>(scaled_bias_->get_data_handle());\n      } else {\n        context->CtxFailure(\n            errors::InvalidArgument(\"Quantization mode must be\"\n                                    \"either MIN_FIRST or SCALED.\"));\n        return nullptr;\n      }\n    }\n  }\n\n private:\n  memory* input_bias_ = nullptr;\n  memory* scaled_bias_ = nullptr;\n\n  // Buffer to save the compensated bias\n  float* comp_bias_ = nullptr;\n\n  int mode_;\n};\n\ntemplate <typename Device, typename Tinput, typename Tweight, typename Tbias,\n          typename Toutput, bool native_format = false>\nclass MklDnnQuantizedMatMulReluOp\n    : public MklDnnQuantizedMatMulOp<Device, Tinput, Tweight, Tbias, Toutput,\n                                     native_format> {\n public:\n  virtual ~MklDnnQuantizedMatMulReluOp() {}\n\n  explicit MklDnnQuantizedMatMulReluOp(OpKernelConstruction* context)\n      : MklDnnQuantizedMatMulOp<Device, Tinput, Tweight, Tbias, Toutput,\n                                native_format>(context) {}\n\n protected:\n  void ExtendMklDnnMatMulFwdParams(OpKernelContext* context,\n                                   MklDnnMatMulFwdParams& params) override {\n    MklDnnQuantizedMatMulOp<Device, quint8, qint8, Tbias, Toutput,\n                            native_format>::ExtendMklDnnMatMulFwdParams(context,\n                                                                        params);\n    params.post_op_params.push_back({\"relu\", {1.0, 0.0, 0.0}});\n  }\n};\n\n#define REGISTER_MKL_KERNEL(op, kernel, bias_type, output_type, is_native)   \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(op)                                                               \\\n          .Device(DEVICE_CPU)                                                \\\n          .TypeConstraint<quint8>(\"T1\")                                      \\\n          .TypeConstraint<qint8>(\"T2\") BIAS_TYPE_CONSTRAINT(bias_type)       \\\n          .TypeConstraint<output_type>(\"Toutput\") LABEL,                     \\\n      kernel TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                           is_native));\n\n#define REGISTER_MKL_KERNEL_ALL_BIAS_TYPES(op, kernel, output_type, is_native) \\\n  REGISTER_MKL_KERNEL(op, kernel, float, output_type, is_native)               \\\n  REGISTER_MKL_KERNEL(op, kernel, qint32, output_type, is_native);\n\n#define LABEL\n#define TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                      is_native)\n#define BIAS_TYPE_CONSTRAINT(bias_type)\nREGISTER_MKL_KERNEL(\"QuantizedMatMulWithBiasAndRelu\", NoOp, float, qint32,\n                    false);\n#undef BIAS_TYPE_CONSTRAINT\n\n#define BIAS_TYPE_CONSTRAINT(bias_type) .TypeConstraint<bias_type>(\"Tbias\")\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBias\", NoOp, qint32,\n                                   false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\n    \"QuantizedMatMulWithBiasAndReluAndRequantize\", NoOp, quint8, false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBiasAndRequantize\", NoOp,\n                                   quint8, false);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"QuantizedMatMulWithBiasAndDequantize\", NoOp,\n                                   float, false);\n#undef BIAS_TYPE_CONSTRAINT\n#undef TEMPLATE_ARGS\n#undef LABEL\n\n#define LABEL .Label(mkl_op_registry::kMklQuantizedOpLabel)\n#define TEMPLATE_ARGS(CPUDevice, quint8, qint8, bias_type, output_type, \\\n                      is_native)                                        \\\n<CPUDevice, quint8, qint8, bias_type, output_type, is_native>\n#define BIAS_TYPE_CONSTRAINT(bias_type)\nREGISTER_MKL_KERNEL(\"_MklQuantizedMatMulWithBiasAndRelu\",\n                    MklDnnQuantizedMatMulReluOp, float, qint32, true);\n#undef BIAS_TYPE_CONSTRAINT\n\n#define BIAS_TYPE_CONSTRAINT(bias_type) .TypeConstraint<bias_type>(\"Tbias\")\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBias\",\n                                   MklDnnQuantizedMatMulOp, qint32, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\n    \"_MklQuantizedMatMulWithBiasAndReluAndRequantize\",\n    MklDnnQuantizedMatMulReluOp, quint8, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBiasAndRequantize\",\n                                   MklDnnQuantizedMatMulOp, quint8, true);\nREGISTER_MKL_KERNEL_ALL_BIAS_TYPES(\"_MklQuantizedMatMulWithBiasAndDequantize\",\n                                   MklDnnQuantizedMatMulOp, float, true);\n#undef BIAS_TYPE_CONSTRAINT\n#undef TEMPLATE_ARGS\n#undef LABEL\n\n}  // namespace tensorflow\n\n#endif  // INTEL_MKL\n", "\ufeff/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#if defined(INTEL_MKL)\n#define EIGEN_USE_THREADS\n\n#include <functional>\n#include <memory>\n#include <vector>\n\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/fake_input.h\"\n#include \"tensorflow/core/framework/node_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_testutil.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/ops_testutil.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/platform/test.h\"\n\nnamespace tensorflow {\n\nclass QuantizedMatMulTest : public OpsTestBase {};\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias\nTEST_F(QuantizedMatMulTest, Small_withBias) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {1, 2, 3, 4});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // Final result after Bias addition:\n  // 74  + 1 = 75 , 80  + 2 = 82 , 86  + 3 = 89 , 92  + 4 = 96,\n  // 173 + 1 = 174, 188 + 2 = 190, 203 + 3 = 206, 218 + 4 = 222\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected, {75, 82, 89, 96, 174, 190, 206, 222});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with neg bias as well\nTEST_F(QuantizedMatMulTest, Small_withNegBias) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {100, -200, 300, -400});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // Final result after Bias addition:\n  // 74+100=174, 80-200=-120, 86+300=386, 92-400=-308,\n  // 173+100=273, 188-200=-12, 203+300=503, 218-400=-182\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected,\n                           {174, -120, 386, -308, 273, -12, 503, -182});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 (converted from signed integer)\n// and B of type int8  are multiplied and the result is added with float bias\nTEST_F(QuantizedMatMulTest, Small_WithNegInp) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"input_quant_mode\", \"MIN_FIRST\")\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // The A matrix is:\n  // |  -1 |  -5 |  -9 |\n  // |  -2 |  -6 | -10 |\n  // |  -3 |  -7 | -11 |\n  // |  -4 |  -8 | -12 |\n  // The input array only contains unsigned bytes, so we specify the actual\n  // quantized values as Au8 = (Af32 - Min(A\ud835\udc5332)) * Qa, where\n  // Qa = 255/(Max(A\ud835\udc5332) - Min(A\ud835\udc5332)). For example, -1 is represented\n  // as -1 + 12, or 11 as Qa = 255/(243+12).\n  AddInputFromArray<quint8>(TensorShape({4, 3}),\n                            {11, 7, 3, 10, 6, 2, 9, 5, 1, 8, 4, 0});\n\n  // The B matrix is:\n  // |   1 |   4|\n  // |   2 |   5|\n  // |   3 |   6|\n  AddInputFromArray<qint8>(TensorShape({3, 2}), {1, 4, 2, 5, 3, 6});\n  // Bias\n  AddInputFromArray<float>(TensorShape({2}), {10.0f, 20.0f});\n  AddInputFromArray<float>(TensorShape({}), {-12.0f});\n  AddInputFromArray<float>(TensorShape({}), {243.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // First calculate C = A * B,\n  // so we expect to get these results for MatMul:\n  // 1*-1 + 2*-5 + 3*-9 = -38\n  // 4*-1 + 5*-5 + 6*-9 = -83\n  // 1*-2 + 2*-6 + 3*-10 = -44\n  // 4*-2 + 5*-6 + 6*-10 = -98\n  // 1*-3 + 2*-7 + 3*-11 = -50\n  // 4*-3 + 5*-7 + 6*-11 = -113\n  // 1*-4 + 2*-8 + 3*-12 = -56\n  // 4*-4 + 5*-8 + 6*-12 = -128\n  // |  -38 |  -83 |\n  // |  -44 |  -98 |\n  // |  -50 | -113 |\n  // |  -56 | -128 |\n  // After Bias add {10, 20}, the expected result is\n  // |  -28 |  -63 |\n  // |  -34 |  -78 |\n  // |  -40 |  -93 |\n  // |  -46 | -108 |\n  Tensor expected(allocator(), DT_QINT32, TensorShape({4, 2}));\n  test::FillValues<qint32>(&expected,\n                           {-28, -63, -34, -78, -40, -93, -46, -108});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias and Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndReq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndRequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<quint8>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Requantize\n  // requantscale = scale_int32 / scale_eightbit / static_cast<float>(1 << 23)\n  // requantscale = 2^31/255/2^23 ~= 1.00392\n  // 84 * 1.00392 ~= 84.329 ~= 84\n  // 60 * 1.00392 ~= 60.235 ~= 60\n  // 116 * 1.00392 ~= 116.454 ~= 116\n  // 52 * 1.00392 ~= 52.203 ~= 52\n  // 183 * 1.00392 ~= 183.717 ~= 184\n  // 168 * 1.00392 ~= 168.658 ~= 169\n  // 233 * 1.00392 ~= 233.913 ~= 234\n  // 178 * 1.00392 ~= 178.698 ~= 179\n\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({2, 4}));\n  test::FillValues<quint8>(&expected, {84, 60, 116, 52, 184, 169, 234, 179});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<quint8>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with int32 bias and Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndDeq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndDequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<float>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Dequantize\n  // requantscale = scale_int32 / static_cast<float>(1 << 31)\n  // requantscale = 2^31/2^31 ~= 1.0000\n  // 84 * 1.00000 ~= 84\n  // 60 * 1.00000 ~=  60\n  // 116 * 1.00000 ~= 116\n  // 52 * 1.00000 ~= 52\n  // 183 * 1.00000 ~= 183\n  // 168 * 1.00000 ~= 168\n  // 233 * 1.00000 ~= 233\n  // 178 * 1.00000 ~= 178\n\n  Tensor expected(allocator(), DT_FLOAT, TensorShape({2, 4}));\n  test::FillValues<float>(&expected, {84, 60, 116, 52, 183, 168, 233, 178});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<float>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8  are multiplied\n// and the result is added with float bias and then performed relu on the result\nTEST_F(QuantizedMatMulTest, Small_withBiasAndRelu) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndRelu\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<float>(TensorShape({4}),\n                           {100.0f, -200.0f, 300.0f, -400.0f});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+100=174, 80-200=-120, 86+300=386, 92-400=-308,\n  // 173+100=273, 188-200=-12, 203+300=503, 218-400=-182\n  // After Relu\n  // 174, 0, 386, 0, 273, 0, 503, 0\n  Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));\n  test::FillValues<qint32>(&expected, {174, 0, 386, 0, 273, 0, 503, 0});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n}\n\n// Simple test for Matrix multiplication with Bias, Relu and\n// Requantization fusion\nTEST_F(QuantizedMatMulTest, Small_withBiasAndReluAndReq) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\",\n                              \"_MklQuantizedMatMulWithBiasAndReluAndRequantize\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QINT8))\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Toutput\", DataTypeToEnum<quint8>::v())\n                   .Attr(\"_kernel\", \"QuantizedMklOp\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  // |  4 |  5 |  6 |\n  AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {10, -20, 30, -40});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n\n  TF_ASSERT_OK(RunOpKernel());\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // (4 * 7) + (5 * 11) + (6 * 15) = 173\n  // (4 * 8) + (5 * 12) + (6 * 16) = 188\n  // (4 * 9) + (5 * 13) + (6 * 17) = 203\n  // (4 * 10) + (5 * 14) + (6 * 18) = 218\n  // After Bias addition\n  // 74+10=84, 80-20=60, 86+30=116, 92-40=52,\n  // 173+10=183, 188-20=168, 203+30=233, 218-40=178\n  // After Relu\n  // 84, 60, 116, 52, 183, 168, 233, 178\n  // After Requantize\n  // requantscale = scale_int32 / scale_eightbit / static_cast<float>(1 << 23)\n  // requantscale = 2^31/255/2^23 ~= 1.00392\n  // 84 * 1.00392 ~= 84.329 ~= 84\n  // 60 * 1.00392 ~= 60.235 ~= 60\n  // 116 * 1.00392 ~= 116.454 ~= 116\n  // 52 * 1.00392 ~= 52.203 ~= 52\n  // 183 * 1.00392 ~= 183.717 ~= 184\n  // 168 * 1.00392 ~= 168.658 ~= 169\n  // 233 * 1.00392 ~= 233.913 ~= 234\n  // 178 * 1.00392 ~= 178.698 ~= 179\n\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({2, 4}));\n  test::FillValues<quint8>(&expected, {84, 60, 116, 52, 184, 169, 234, 179});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<quint8>(expected, output);\n}\n\n// Two small matrices A of type uint8 and B of type int8 are multiplied\n// and the result is added with int32 bias\n// For the first time B matrix will be reordered and cached which will be\n// used for subsequent runs\nTEST_F(QuantizedMatMulTest, Small_withWeightCached) {\n  TF_ASSERT_OK(\n      NodeDefBuilder(\"quantized_mat_mul_op\", \"_MklQuantizedMatMulWithBias\")\n          .Input(FakeInput(DT_QUINT8))\n          .Input(FakeInput(DT_QINT8))\n          .Input(FakeInput(DT_QINT32))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Input(FakeInput(DT_FLOAT))\n          .Attr(\"Toutput\", DataTypeToEnum<qint32>::v())\n          .Attr(\"_kernel\", \"QuantizedMklOp\")\n          .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  // The tensor shape of (1,3) is selected to allow the oneDNN expected\n  // weight format to be made as OI rather than IO for BS > 1\n  // A matrix is:\n  // |  1 |  2 |  3 |\n  AddInputFromArray<quint8>(TensorShape({1, 3}), {1, 2, 3});\n  // B matrix is:\n  // |  7 |  8 |  9 | 10 |\n  // | 11 | 12 | 13 | 14 |\n  // | 15 | 16 | 17 | 18 |\n  AddInputFromArray<qint8>(TensorShape({3, 4}),\n                           {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\n  AddInputFromArray<qint32>(TensorShape({4}), {1, 2, 3, 4});\n  AddInputFromArray<float>(TensorShape({}), {0});\n  AddInputFromArray<float>(TensorShape({}), {255.0f});\n  AddInputFromArray<float>(TensorShape({}), {-127.0f});\n  AddInputFromArray<float>(TensorShape({}), {127.0f});\n\n  int64 start_time = Env::Default()->NowMicros();\n  TF_ASSERT_OK(RunOpKernel());\n  int64 end_time = Env::Default()->NowMicros();\n  int64 total_duration_unopt = end_time - start_time;\n\n  // Here are the results we expect, from hand calculations:\n  // (1 * 7) + (2 * 11) + (3 * 15) = 74\n  // (1 * 8) + (2 * 12) + (3 * 16) = 80\n  // (1 * 9) + (2 * 13) + (3 * 17) = 86\n  // (1 * 10) + (2 * 14) + (3 * 18) = 92\n  // Final result after Bias addition:\n  // 74  + 1 = 75 , 80  + 2 = 82 , 86  + 3 = 89 , 92  + 4 = 96,\n  Tensor expected(allocator(), DT_QINT32, TensorShape({1, 4}));\n  test::FillValues<qint32>(&expected, {75, 82, 89, 96});\n\n  const Tensor& output = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output);\n\n  // Test for the second time to use the cached weight\n  start_time = Env::Default()->NowMicros();\n  TF_ASSERT_OK(RunOpKernel());\n  end_time = Env::Default()->NowMicros();\n  int64 total_duration_opt = end_time - start_time;\n  LOG(INFO) << \" Time taken by first call : \" << total_duration_unopt\n            << \", Time taken after Caching : \" << total_duration_opt;\n\n  // Cached call should be at least 20% faster.\n  EXPECT_LT(total_duration_opt, total_duration_unopt * 0.8);\n\n  // Compare the result with expected result\n  const Tensor& output_new = *GetOutput(0);\n  test::ExpectTensorEqual<qint32>(expected, output_new);\n}\n\n}  // namespace tensorflow\n\n#endif  // INTEL_MKL\n"], "filenames": ["tensorflow/core/kernels/mkl/mkl_qmatmul_op.cc", "tensorflow/core/kernels/mkl/mkl_qmatmul_op_test.cc"], "buggy_code_start_loc": [320, 15], "buggy_code_end_loc": [376, 547], "fixing_code_start_loc": [320, 15], "fixing_code_end_loc": [420, 547], "type": "CWE-476", "message": "TensorFlow is an open source platform for machine learning. Versions prior to 2.12.0 and 2.11.1 have a null point error in QuantizedMatMulWithBiasAndDequantize with MKL enabled. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.", "other": {"cve": {"id": "CVE-2023-25670", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-25T00:15:07.710", "lastModified": "2023-03-30T17:46:48.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Versions prior to 2.12.0 and 2.11.1 have a null point error in QuantizedMatMulWithBiasAndDequantize with MKL enabled. A fix is included in TensorFlow version 2.12.0 and version 2.11.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.12.0", "matchCriteriaId": "FAC3DE54-93B4-4D6C-9648-B9D416B9770F"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/8a47a39d9697969206d23a523c977238717e8727", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-49rq-hwc3-x77w", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/8a47a39d9697969206d23a523c977238717e8727"}}