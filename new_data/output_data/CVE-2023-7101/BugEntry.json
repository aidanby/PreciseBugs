{"buggy_code": ["package Spreadsheet::ParseExcel::Utility;\n\n###############################################################################\n#\n# Spreadsheet::ParseExcel::Utility - Utility functions for ParseExcel.\n#\n# Used in conjunction with Spreadsheet::ParseExcel.\n#\n# Copyright (c) 2014      Douglas Wilson\n# Copyright (c) 2009-2013 John McNamara\n# Copyright (c) 2006-2008 Gabor Szabo\n# Copyright (c) 2000-2006 Kawai Takanori\n#\n# perltidy with standard settings.\n#\n# Documentation after __END__\n#\n\nuse strict;\nuse warnings;\n\nrequire Exporter;\nuse vars qw(@ISA @EXPORT_OK);\n@ISA       = qw(Exporter);\n@EXPORT_OK = qw(ExcelFmt LocaltimeExcel ExcelLocaltime\n  col2int int2col sheetRef xls2csv);\n\nour $VERSION = '0.65';\n\nmy $qrNUMBER = qr/(^[+-]?\\d+(\\.\\d+)?$)|(^[+-]?\\d+\\.?(\\d*)[eE][+-](\\d+))$/;\n\n###############################################################################\n#\n# ExcelFmt()\n#\n# This function takes an Excel style number format and converts a number into\n# that format. for example: 'hh:mm:ss AM/PM' + 0.01023148 = '12:14:44 AM'.\n#\n# It does this with a type of templating mechanism. The format string is parsed\n# to identify tokens that need to be replaced and their position within the\n# string is recorded. These can be thought of as placeholders. The number is\n# then converted to the required formats and substituted into the placeholders.\n#\n# Interested parties should refer to the Excel documentation on cell formats for\n# more information: http://office.microsoft.com/en-us/excel/HP051995001033.aspx\n# The Microsoft documentation for the Excel Binary File Format, [MS-XLS].pdf,\n# also contains a ABNF grammar for number format strings.\n#\n# Maintainers notes:\n# ==================\n#\n# Note on format subsections:\n# A format string can contain 4 possible sub-sections separated by semi-colons:\n# Positive numbers, negative numbers, zero values, and text.\n# For example: _(* #,##0_);_(* (#,##0);_(* \"-\"_);_(@_)\n#\n# Note on conditional formats.\n# A number format in Excel can have a conditional expression such as:\n#     [>9999999](000)000-0000;000-0000\n# This is equivalent to the following in Perl:\n#     $format = $number > 9999999 ? '(000)000-0000' : '000-0000';\n# Nested conditionals are also possible but we don't support them.\n#\n# Efficiency: The excessive use of substr() isn't very efficient. However,\n# it probably doesn't merit rewriting this function with a parser or regular\n# expressions and \\G.\n#\n# TODO: I think the single quote handling may not be required. Check.\n#\nsub ExcelFmt {\n\n    my ( $format_str, $number, $is_1904, $number_type, $want_subformats ) = @_;\n\n    # Return text strings without further formatting.\n    return $number unless $number =~ $qrNUMBER;\n\n    # Handle OpenOffice.org GENERAL format.\n    $format_str = '@' if uc($format_str) eq \"GENERAL\";\n\n    # Check for a conditional at the start of the format. See notes above.\n    my $conditional;\n    if ( $format_str =~ /^\\[([<>=][^\\]]+)\\](.*)$/ ) {\n        $conditional = $1;\n        $format_str  = $2;\n    }\n\n    # Ignore the underscore token which is used to indicate a padding space.\n    $format_str =~ s/_/ /g;\n\n    # Split the format string into 4 possible sub-sections: positive numbers,\n    # negative numbers, zero values, and text. See notes above.\n    my @formats;\n    my $section      = 0;\n    my $double_quote = 0;\n    my $single_quote = 0;\n\n    # Initial parsing of the format string to remove escape characters. This\n    # also handles quoted strings. See note about single quotes above.\n  CHARACTER:\n    for my $char ( split //, $format_str ) {\n\n        if ( $double_quote or $single_quote ) {\n            $formats[$section] .= $char;\n            $double_quote = 0 if $char eq '\"';\n            $single_quote = 0;\n            next CHARACTER;\n        }\n\n        if ( $char eq ';' ) {\n            $section++;\n            next CHARACTER;\n        }\n        elsif ( $char eq '\"' ) {\n            $double_quote = 1;\n        }\n        elsif ( $char eq '!' ) {\n            $single_quote = 1;\n        }\n        elsif ( $char eq '\\\\' ) {\n            $single_quote = 1;\n        }\n        elsif ( $char eq '(' ) {\n            next CHARACTER;    # Ignore.\n        }\n        elsif ( $char eq ')' ) {\n            next CHARACTER;    # Ignore.\n        }\n\n        # Convert upper case OpenOffice.org date/time formats to lowercase..\n        $char = lc($char) if $char =~ /[DMYHS]/;\n\n        $formats[$section] .= $char;\n    }\n\n    # Select the appropriate format from the 4 possible sub-sections:\n    # positive numbers, negative numbers, zero values, and text.\n    # We ignore the Text section since non-numeric values are returned\n    # unformatted at the start of the function.\n    my $format;\n    $section = 0;\n\n    if ( @formats == 1 ) {\n        $section = 0;\n    }\n    elsif ( @formats == 2 ) {\n        if ( $number < 0 ) {\n            $section = 1;\n        }\n        else {\n            $section = 0;\n        }\n    }\n    elsif ( @formats == 3 ) {\n        if ( $number == 0 ) {\n            $section = 2;\n        }\n        elsif ( $number < 0 ) {\n            $section = 1;\n        }\n        else {\n            $section = 0;\n        }\n    }\n    else {\n        $section = 0;\n    }\n\n    # Override the previous choice if the format is conditional.\n    if ($conditional) {\n\n        # TODO. Replace string eval with a function.\n        $section = eval \"$number $conditional\" ? 0 : 1;\n    }\n\n    # We now have the required format.\n    $format = $formats[$section];\n\n    # The format string can contain one of the following colours:\n    # [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]\n    # or the string [ColorX] where x is a colour index from 1 to 56.\n    # We don't use the colour but we return it to the caller.\n    #\n    my $color = '';\n    if ( $format =~ s/^(\\[[A-Za-z]{3,}(\\d{1,2})?\\])// ) {\n        $color = $1;\n    }\n\n    # Remove the locale, such as [$-409], from the format string.\n    my $locale = '';\n    if ( $format =~ s/^(\\[\\$?-F?\\d+\\])// ) {\n        $locale = $1;\n    }\n\n    # Replace currency locale, such as [$$-409], with $ in the format string.\n    # See the RT#60547 test cases in 21_number_format_user.t.\n    if ( $format =~ s/(\\[\\$([^-]+)(-\\d+)?\\])/$2/s ) {\n        $locale = $1;\n    }\n\n\n    # Remove leading # from '# ?/?', '# ??/??' fraction formats.\n    $format =~ s{# \\?}{?}g;\n\n    # Parse the format string and create an AoA of placeholders that contain\n    # the parts of the string to be replaced. The format of the information\n    # stored is: [ $token, $start_pos, $end_pos, $option_info ].\n    #\n    my $format_mode  = '';    # Either: '', 'number', 'date'\n    my $pos          = 0;     # Character position within format string.\n    my @placeholders = ();    # Arefs with parts of the format to be replaced.\n    my $token        = '';    # The actual format extracted from the total str.\n    my $start_pos;            # A position variable. Initial parser position.\n    my $token_start = -1;     # A position variable.\n    my $decimal_pos = -1;     # Position of the punctuation char \".\" or \",\".\n    my $comma_count = 0;      # Count of the commas in the format.\n    my $is_fraction = 0;      # Number format is a fraction.\n    my $is_currency = 0;      # Number format is a currency.\n    my $is_percent  = 0;      # Number format is a percentage.\n    my $is_12_hour  = 0;      # Time format is using 12 hour clock.\n    my $seen_dot    = 0;      # Treat only the first \".\" as the decimal point.\n\n    # Parse the format.\n  PARSER:\n    while ( $pos < length $format ) {\n        $start_pos = $pos;\n        my $char = substr( $format, $pos, 1 );\n\n        # Ignore control format characters such as '#0+-.?eE,%'. However,\n        # only ignore '.' if it is the first one encountered. RT 45502.\n        if ( ( !$seen_dot && $char !~ /[#0\\+\\-\\.\\?eE\\,\\%]/ )\n            || $char !~ /[#0\\+\\-\\?eE\\,\\%]/ )\n        {\n\n            if ( $token_start != -1 ) {\n                push @placeholders,\n                  [\n                    substr( $format, $token_start, $pos - $token_start ),\n                    $decimal_pos, $pos - $token_start\n                  ];\n                $token_start = -1;\n            }\n        }\n\n        # Processing for quoted strings within the format. See notes above.\n        if ( $char eq '\"' ) {\n            $double_quote = $double_quote ? 0 : 1;\n            $pos++;\n            next PARSER;\n        }\n        elsif ( $char eq '!' ) {\n            $single_quote = 1;\n            $pos++;\n            next PARSER;\n        }\n        elsif ( $char eq '\\\\' ) {\n            if ( $single_quote != 1 ) {\n                $single_quote = 1;\n                $pos++;\n                next PARSER;\n            }\n        }\n\n        if (   ( defined($double_quote) and ($double_quote) )\n            or ( defined($single_quote) and ($single_quote) )\n            or ( $seen_dot && $char eq '.' ) )\n        {\n            $single_quote = 0;\n            if (\n                ( $format_mode ne 'date' )\n                and (  ( substr( $format, $pos, 2 ) eq \"\\x81\\xA2\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\x81\\xA3\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\xA2\\xA4\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\xA2\\xA5\" ) )\n              )\n            {\n\n                # The above matches are currency symbols.\n                push @placeholders,\n                  [ substr( $format, $pos, 2 ), length($token), 2 ];\n                $is_currency = 1;\n                $pos += 2;\n            }\n            else {\n                $pos++;\n            }\n        }\n        elsif (\n            ( $char =~ /[#0\\+\\.\\?eE\\,\\%]/ )\n            || (    ( $format_mode ne 'date' )\n                and ( ( $char eq '-' ) || ( $char eq '(' ) || ( $char eq ')' ) )\n            )\n          )\n        {\n            $format_mode = 'number' unless $format_mode;\n            if ( substr( $format, $pos, 1 ) =~ /[#0]/ ) {\n                if (\n                    substr( $format, $pos ) =~\n                    /^([#0]+[\\.]?[0#]*[eE][\\+\\-][0#]+)/ )\n                {\n                    push @placeholders, [ $1, $pos, length($1) ];\n                    $pos += length($1);\n                }\n                else {\n                    if ( $token_start == -1 ) {\n                        $token_start = $pos;\n                        $decimal_pos = length($token);\n                    }\n                }\n            }\n            elsif ( substr( $format, $pos, 1 ) eq '?' ) {\n\n                # Look for a fraction format like ?/? or ??/??\n                if ( $token_start != -1 ) {\n                    push @placeholders,\n                      [\n                        substr(\n                            $format, $token_start, $pos - $token_start + 1\n                        ),\n                        $decimal_pos,\n                        $pos - $token_start + 1\n                      ];\n                }\n                $token_start = $pos;\n\n                # Find the end of the fraction format.\n              FRACTION:\n                while ( $pos < length($format) ) {\n                    if ( substr( $format, $pos, 1 ) eq '/' ) {\n                        $is_fraction = 1;\n                    }\n                    elsif ( substr( $format, $pos, 1 ) eq '?' ) {\n                        $pos++;\n                        next FRACTION;\n                    }\n                    else {\n                        if ( $is_fraction\n                            && ( substr( $format, $pos, 1 ) =~ /[0-9]/ ) )\n                        {\n\n                            # TODO: Could invert if() logic and remove this.\n                            $pos++;\n                            next FRACTION;\n                        }\n                        else {\n                            last FRACTION;\n                        }\n                    }\n                    $pos++;\n                }\n                $pos--;\n\n                push @placeholders,\n                  [\n                    substr( $format, $token_start, $pos - $token_start + 1 ),\n                    length($token), $pos - $token_start + 1\n                  ];\n                $token_start = -1;\n            }\n            elsif ( substr( $format, $pos, 3 ) =~ /^[eE][\\+\\-][0#]$/ ) {\n                if ( substr( $format, $pos ) =~ /([eE][\\+\\-][0#]+)/ ) {\n                    push @placeholders, [ $1, $pos, length($1) ];\n                    $pos += length($1);\n                }\n                $token_start = -1;\n            }\n            else {\n                if ( $token_start != -1 ) {\n                    push @placeholders,\n                      [\n                        substr( $format, $token_start, $pos - $token_start ),\n                        $decimal_pos, $pos - $token_start\n                      ];\n                    $token_start = -1;\n                }\n                if ( substr( $format, $pos, 1 ) =~ /[\\+\\-]/ ) {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $is_currency = 1;\n                }\n                elsif ( substr( $format, $pos, 1 ) eq '.' ) {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $seen_dot = 1;\n                }\n                elsif ( substr( $format, $pos, 1 ) eq ',' ) {\n                    $comma_count++;\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                }\n                elsif ( substr( $format, $pos, 1 ) eq '%' ) {\n                    $is_percent = 1;\n                }\n                elsif (( substr( $format, $pos, 1 ) eq '(' )\n                    || ( substr( $format, $pos, 1 ) eq ')' ) )\n                {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $is_currency = 1;\n                }\n            }\n            $pos++;\n        }\n        elsif ( $char =~ /[ymdhsapg]/i ) {\n            $format_mode = 'date' unless $format_mode;\n            if ( substr( $format, $pos, 5 ) =~ /am\\/pm/i ) {\n                push @placeholders, [ 'am/pm', length($token), 5 ];\n                $is_12_hour = 1;\n                $pos += 5;\n            }\n            elsif ( substr( $format, $pos, 3 ) =~ /a\\/p/i ) {\n                push @placeholders, [ 'a/p', length($token), 3 ];\n                $is_12_hour = 1;\n                $pos += 3;\n            }\n            elsif ( substr( $format, $pos, 5 ) eq 'mmmmm' ) {\n                push @placeholders, [ 'mmmmm', length($token), 5 ];\n                $pos += 5;\n            }\n            elsif (( substr( $format, $pos, 4 ) eq 'mmmm' )\n                || ( substr( $format, $pos, 4 ) eq 'dddd' )\n                || ( substr( $format, $pos, 4 ) eq 'yyyy' )\n                || ( substr( $format, $pos, 4 ) eq 'ggge' ) )\n            {\n                push @placeholders,\n                  [ substr( $format, $pos, 4 ), length($token), 4 ];\n                $pos += 4;\n            }\n            elsif (( substr( $format, $pos, 3 ) eq 'ddd' )\n                || ( substr( $format, $pos, 3 ) eq 'mmm' )\n                || ( substr( $format, $pos, 3 ) eq 'yyy' ) )\n            {\n                push @placeholders,\n                  [ substr( $format, $pos, 3 ), length($token), 3 ];\n                $pos += 3;\n            }\n            elsif (( substr( $format, $pos, 2 ) eq 'yy' )\n                || ( substr( $format, $pos, 2 ) eq 'mm' )\n                || ( substr( $format, $pos, 2 ) eq 'dd' )\n                || ( substr( $format, $pos, 2 ) eq 'hh' )\n                || ( substr( $format, $pos, 2 ) eq 'ss' )\n                || ( substr( $format, $pos, 2 ) eq 'ge' ) )\n            {\n                if (\n                       ( substr( $format, $pos, 2 ) eq 'mm' )\n                    && (@placeholders)\n                    && (   ( $placeholders[-1]->[0] eq 'h' )\n                        or ( $placeholders[-1]->[0] eq 'hh' ) )\n                  )\n                {\n\n                    # For this case 'm' is minutes not months.\n                    push @placeholders, [ 'mm', length($token), 2, 'minutes' ];\n                }\n                else {\n                    push @placeholders,\n                      [ substr( $format, $pos, 2 ), length($token), 2 ];\n                }\n                if (   ( substr( $format, $pos, 2 ) eq 'ss' )\n                    && ( @placeholders > 1 ) )\n                {\n                    if (   ( $placeholders[-2]->[0] eq 'm' )\n                        || ( $placeholders[-2]->[0] eq 'mm' ) )\n                    {\n\n                        # For this case 'm' is minutes not months.\n                        push( @{ $placeholders[-2] }, 'minutes' );\n                    }\n                }\n                $pos += 2;\n            }\n            elsif (( substr( $format, $pos, 1 ) eq 'm' )\n                || ( substr( $format, $pos, 1 ) eq 'd' )\n                || ( substr( $format, $pos, 1 ) eq 'h' )\n                || ( substr( $format, $pos, 1 ) eq 's' ) )\n            {\n                if (\n                       ( substr( $format, $pos, 1 ) eq 'm' )\n                    && (@placeholders)\n                    && (   ( $placeholders[-1]->[0] eq 'h' )\n                        or ( $placeholders[-1]->[0] eq 'hh' ) )\n                  )\n                {\n\n                    # For this case 'm' is minutes not months.\n                    push @placeholders, [ 'm', length($token), 1, 'minutes' ];\n                }\n                else {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                }\n                if (   ( substr( $format, $pos, 1 ) eq 's' )\n                    && ( @placeholders > 1 ) )\n                {\n                    if (   ( $placeholders[-2]->[0] eq 'm' )\n                        || ( $placeholders[-2]->[0] eq 'mm' ) )\n                    {\n\n                        # For this case 'm' is minutes not months.\n                        push( @{ $placeholders[-2] }, 'minutes' );\n                    }\n                }\n                $pos += 1;\n            }\n        }\n        elsif ( ( substr( $format, $pos, 3 ) eq '[h]' ) ) {\n            $format_mode = 'date' unless $format_mode;\n            push @placeholders, [ '[h]', length($token), 3 ];\n            $pos += 3;\n        }\n        elsif ( ( substr( $format, $pos, 4 ) eq '[mm]' ) ) {\n            $format_mode = 'date' unless $format_mode;\n            push @placeholders, [ '[mm]', length($token), 4 ];\n            $pos += 4;\n        }\n        elsif ( $char eq '@' ) {\n            push @placeholders, [ '@', length($token), 1 ];\n            $pos++;\n        }\n        elsif ( $char eq '*' ) {\n            push @placeholders,\n              [ substr( $format, $pos, 1 ), length($token), 1 ];\n        }\n        else {\n            $pos++;\n        }\n        $pos++ if ( $pos == $start_pos );    #No Format match\n        $token .= substr( $format, $start_pos, $pos - $start_pos );\n\n    }    # End of parsing.\n\n    # Copy the located format string to a result string that we will perform\n    # the substitutions on and return to the user.\n    my $result = $token;\n\n    # Add a placeholder between the decimal/comma and end of the token, if any.\n    if ( $token_start != -1 ) {\n        push @placeholders,\n          [\n            substr( $format, $token_start, $pos - $token_start + 1 ),\n            $decimal_pos, $pos - $token_start + 1\n          ];\n    }\n\n    #\n    # In the next sections we process date, number and text formats. We take a\n    # format such as yyyy/mm/dd and replace it with something like 2008/12/25.\n    #\n    if ( ( $format_mode eq 'date' ) && ( $number =~ $qrNUMBER ) ) {\n\n        # The maximum allowable date in Excel is 9999-12-31T23:59:59.000 which\n        # equates to 2958465.999+ in the 1900 epoch and 2957003.999+ in the\n        # 1904 epoch. We use 0 as the minimum in both epochs. The 1904 system\n        # actually supports negative numbers but that isn't worth the effort.\n        my $min_date = 0;\n        my $max_date = 2958466;\n        $max_date = 2957004 if $is_1904;\n\n        if ( $number < $min_date || $number >= $max_date ) {\n            return $number;    # Return unformatted number.\n        }\n\n        # Process date formats.\n        my @time = ExcelLocaltime( $number, $is_1904 );\n\n        #    0     1     2      3     4       5      6      7\n        my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;\n\n        $month++;              # localtime() zero indexed month.\n        $year += 1900;         # localtime() year.\n\n        my @full_month_name = qw(\n          None January February March April May June July\n          August September October November December\n        );\n        my @short_month_name = qw(\n          None Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n        );\n        my @full_day_name = qw(\n          Sunday Monday Tuesday Wednesday Thursday Friday Saturday\n        );\n        my @short_day_name = qw(\n          Sun Mon Tue Wed Thu Fri Sat\n        );\n\n        # Replace the placeholders in the template such as yyyy mm dd with\n        # actual numbers or strings.\n        my $replacement;\n        for my $placeholder ( reverse @placeholders ) {\n\n            if ( $placeholder->[-1] eq 'minutes' ) {\n\n                # For this case 'm/mm' is minutes not months.\n                if ( $placeholder->[0] eq 'mm' ) {\n                    $replacement = sprintf( \"%02d\", $min );\n                }\n                else {\n                    $replacement = sprintf( \"%d\", $min );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'yyyy' ) {\n\n                # 4 digit Year. 2000 -> 2000.\n                $replacement = sprintf( '%04d', $year );\n            }\n            elsif ( $placeholder->[0] eq 'yy' ) {\n\n                # 2 digit Year. 2000 -> 00.\n                $replacement = sprintf( '%02d', $year % 100 );\n            }\n            elsif ( $placeholder->[0] eq 'mmmmm' ) {\n\n                # First character of the month name. 1 -> J.\n                $replacement = substr( $short_month_name[$month], 0, 1 );\n            }\n            elsif ( $placeholder->[0] eq 'mmmm' ) {\n\n                # Full month name. 1 -> January.\n                $replacement = $full_month_name[$month];\n            }\n            elsif ( $placeholder->[0] eq 'mmm' ) {\n\n                # Short month name. 1 -> Jan.\n                $replacement = $short_month_name[$month];\n            }\n            elsif ( $placeholder->[0] eq 'mm' ) {\n\n                # 2 digit month. 1 -> 01.\n                $replacement = sprintf( '%02d', $month );\n            }\n            elsif ( $placeholder->[0] eq 'm' ) {\n\n                # 1 digit month. 1 -> 1.\n                $replacement = sprintf( '%d', $month );\n            }\n            elsif ( $placeholder->[0] eq 'dddd' ) {\n\n                # Full day name. Wednesday (for example.)\n                $replacement = $full_day_name[$wday];\n            }\n            elsif ( $placeholder->[0] eq 'ddd' ) {\n\n                # Short day name. Wed (for example.)\n                $replacement = $short_day_name[$wday];\n            }\n            elsif ( $placeholder->[0] eq 'dd' ) {\n\n                # 2 digit day. 1 -> 01.\n                $replacement = sprintf( '%02d', $day );\n            }\n            elsif ( $placeholder->[0] eq 'd' ) {\n\n                # 1 digit day. 1 -> 1.\n                $replacement = sprintf( '%d', $day );\n            }\n            elsif ( $placeholder->[0] eq 'hh' ) {\n\n                # 2 digit hour.\n                if ($is_12_hour) {\n                    my $hour_tmp = $hour % 12;\n                    $hour_tmp = 12 if $hour % 12 == 0;\n                    $replacement = sprintf( '%d', $hour_tmp );\n                }\n                else {\n                    $replacement = sprintf( '%02d', $hour );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'h' ) {\n\n                # 1 digit hour.\n                if ($is_12_hour) {\n                    my $hour_tmp = $hour % 12;\n                    $hour_tmp = 12 if $hour % 12 == 0;\n                    $replacement = sprintf( '%2d', $hour_tmp );\n                }\n                else {\n                    $replacement = sprintf( '%d', $hour );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'ss' ) {\n\n                # 2 digit seconds.\n                $replacement = sprintf( '%02d', $sec );\n            }\n            elsif ( $placeholder->[0] eq 's' ) {\n\n                # 1 digit seconds.\n                $replacement = sprintf( '%d', $sec );\n            }\n            elsif ( $placeholder->[0] eq 'am/pm' ) {\n\n                # AM/PM.\n                $replacement = ( $hour >= 12 ) ? 'PM' : 'AM';\n            }\n            elsif ( $placeholder->[0] eq 'a/p' ) {\n\n                # AM/PM.\n                $replacement = ( $hour >= 12 ) ? 'P' : 'A';\n            }\n            elsif ( $placeholder->[0] eq '.' ) {\n\n                # Decimal point for seconds.\n                $replacement = '.';\n            }\n            elsif ( $placeholder->[0] =~ /(^0+$)/ ) {\n\n                # Milliseconds. For example h:ss.000.\n                my $length = length($1);\n                $replacement =\n                  substr( sprintf( \"%.${length}f\", $msec / 1000 ), 2, $length );\n            }\n            elsif ( $placeholder->[0] eq '[h]' ) {\n\n                # Hours modulus 24. 25 displays as 25 not as 1.\n                $replacement = sprintf( '%d', int($number) * 24 + $hour );\n            }\n            elsif ( $placeholder->[0] eq '[mm]' ) {\n\n                # Mins modulus 60. 72 displays as 72 not as 12.\n                $replacement =\n                  sprintf( '%d', ( int($number) * 24 + $hour ) * 60 + $min );\n            }\n            elsif ( $placeholder->[0] eq 'ge' ) {\n                require Spreadsheet::ParseExcel::FmtJapan;\n                # Japanese Nengo (aka Gengo) in initialism (abbr. name)\n                 $replacement =\n                  Spreadsheet::ParseExcel::FmtJapan::CnvNengo( abbr_name => @time );\n            }\n            elsif ( $placeholder->[0] eq 'ggge' ) {\n                require Spreadsheet::ParseExcel::FmtJapan;\n                # Japanese Nengo (aka Gengo) in Kanji (full name)\n                 $replacement =\n                  Spreadsheet::ParseExcel::FmtJapan::CnvNengo( name => @time );\n            }\n            elsif ( $placeholder->[0] eq '@' ) {\n\n                # Text format.\n                $replacement = $number;\n            }\n            elsif ( $placeholder->[0] eq ',' ) {\n                next;\n            }\n\n            # Substitute the replacement string back into the template.\n            substr( $result, $placeholder->[1], $placeholder->[2],\n                $replacement );\n        }\n    }\n    elsif ( ( $format_mode eq 'number' ) && ( $number =~ $qrNUMBER ) ) {\n\n        # Process non date formats.\n        if (@placeholders) {\n            while ( $placeholders[-1]->[0] eq ',' ) {\n                $comma_count--;\n                substr(\n                    $result,\n                    $placeholders[-1]->[1],\n                    $placeholders[-1]->[2], ''\n                );\n                $number /= 1000;\n                pop @placeholders;\n            }\n\n            my $number_format = join( '', map { $_->[0] } @placeholders );\n            my $number_result;\n            my $str_length    = 0;\n            my $engineering   = 0;\n            my $is_decimal    = 0;\n            my $is_integer    = 0;\n            my $after_decimal = undef;\n\n            for my $token ( split //, $number_format ) {\n                if ( $token eq '.' ) {\n                    $str_length++;\n                    $is_decimal = 1;\n                }\n                elsif ( ( $token eq 'E' ) || ( $token eq 'e' ) ) {\n                    $engineering = 1;\n                }\n                elsif ( $token eq '0' ) {\n                    $str_length++;\n                    $after_decimal++ if $is_decimal;\n                    $is_integer = 1;\n                }\n                elsif ( $token eq '#' ) {\n                    $after_decimal++ if $is_decimal;\n                    $is_integer = 1;\n                }\n                elsif ( $token eq '?' ) {\n                    $after_decimal++ if $is_decimal;\n                }\n            }\n\n            $number *= 100.0 if $is_percent;\n\n            my $data = ($is_currency) ? abs($number) : $number + 0;\n\n            if ($is_fraction) {\n                $number_result = sprintf( \"%0${str_length}d\", int($data) );\n            }\n            else {\n                if ($is_decimal) {\n\n                    if ( defined $after_decimal ) {\n                        $number_result =\n                          sprintf \"%0${str_length}.${after_decimal}f\", $data;\n                    }\n                    else {\n                        $number_result = sprintf \"%0${str_length}f\", $data;\n                    }\n\n                    # Fix for Perl and sprintf not rounding up like Excel.\n                    # http://rt.cpan.org/Public/Bug/Display.html?id=45626\n                    if ( $data =~ /^${number_result}5/ ) {\n                        $number_result =\n                          sprintf \"%0${str_length}.${after_decimal}f\",\n                          $data . '1';\n                    }\n                }\n                else {\n                    $number_result = sprintf( \"%0${str_length}.0f\", $data );\n                }\n            }\n\n            $number_result = AddComma($number_result) if $comma_count > 0;\n\n            my $number_length = length($number_result);\n            my $decimal_pos   = -1;\n            my $replacement;\n\n            for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {\n                my $placeholder = $placeholders[$i];\n\n                if ( $placeholder->[0] =~\n                    /([#0]*)([\\.]?)([0#]*)([eE])([\\+\\-])([0#]+)/ )\n                {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        MakeE( $placeholder->[0], $number ) );\n                }\n                elsif ( $placeholder->[0] =~ /\\// ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        MakeFraction( $placeholder->[0], $number, $is_integer )\n                    );\n                }\n                elsif ( $placeholder->[0] eq '.' ) {\n                    $number_length--;\n                    $decimal_pos = $number_length;\n                }\n                elsif ( $placeholder->[0] eq '+' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        ( $number > 0 )\n                        ? '+'\n                        : ( ( $number == 0 ) ? '+' : '-' ) );\n                }\n                elsif ( $placeholder->[0] eq '-' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        ( $number > 0 )\n                        ? ''\n                        : ( ( $number == 0 ) ? '' : '-' ) );\n                }\n                elsif ( $placeholder->[0] eq '@' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        $number );\n                }\n                elsif ( $placeholder->[0] eq '*' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2], '' );\n                }\n                elsif (( $placeholder->[0] eq \"\\xA2\\xA4\" )\n                    or ( $placeholder->[0] eq \"\\xA2\\xA5\" )\n                    or ( $placeholder->[0] eq \"\\x81\\xA2\" )\n                    or ( $placeholder->[0] eq \"\\x81\\xA3\" ) )\n                {\n                    substr(\n                        $result,           $placeholder->[1],\n                        $placeholder->[2], $placeholder->[0]\n                    );\n                }\n                elsif (( $placeholder->[0] eq '(' )\n                    or ( $placeholder->[0] eq ')' ) )\n                {\n                    substr(\n                        $result,           $placeholder->[1],\n                        $placeholder->[2], $placeholder->[0]\n                    );\n                }\n                else {\n                    if ( $number_length > 0 ) {\n                        if ( $i <= 0 ) {\n                            $replacement =\n                              substr( $number_result, 0, $number_length );\n                            $number_length = 0;\n                        }\n                        else {\n                            my $real_part_length = length( $placeholder->[0] );\n                            if ( $decimal_pos >= 0 ) {\n                                my $format = $placeholder->[0];\n                                $format =~ s/^#+//;\n                                $real_part_length = length $format;\n                                $real_part_length =\n                                  ( $number_length <= $real_part_length )\n                                  ? $number_length\n                                  : $real_part_length;\n                            }\n                            else {\n                                $real_part_length =\n                                  ( $number_length <= $real_part_length )\n                                  ? $number_length\n                                  : $real_part_length;\n                            }\n                            $replacement =\n                              substr( $number_result,\n                                $number_length - $real_part_length,\n                                $real_part_length );\n                            $number_length -= $real_part_length;\n                        }\n                    }\n                    else {\n                        $replacement = '';\n                    }\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        \"\\x00\" . $replacement );\n                }\n            }\n            $replacement =\n              ( $number_length > 0 )\n              ? substr( $number_result, 0, $number_length )\n              : '';\n            $result =~ s/\\x00/$replacement/;\n            $result =~ s/\\x00//g;\n        }\n    }\n    else {\n\n        # Process text formats\n        my $is_text = 0;\n        for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {\n            my $placeholder = $placeholders[$i];\n            if ( $placeholder->[0] eq '@' ) {\n                substr( $result, $placeholder->[1], $placeholder->[2],\n                    $number );\n                $is_text++;\n            }\n            else {\n                substr( $result, $placeholder->[1], $placeholder->[2], '' );\n            }\n        }\n\n        $result = $number unless $is_text;\n\n    }    # End of placeholder substitutions.\n\n    # Trim the leading and trailing whitespace from the results.\n    $result =~ s/^\\s+//;\n    $result =~ s/\\s+$//;\n\n    # Fix for negative currency.\n    $result =~ s/^\\$\\-/\\-\\$/;\n    $result =~ s/^\\$ \\-/\\-\\$ /;\n\n    # Return color and locale strings if required.\n    if ($want_subformats) {\n        return ( $result, $color, $locale );\n    }\n    else {\n        return $result;\n    }\n}\n\n#------------------------------------------------------------------------------\n# AddComma (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub AddComma {\n    my ($sNum) = @_;\n\n    if ( $sNum =~ /^([^\\d]*)(\\d\\d\\d\\d+)(\\.*.*)$/ ) {\n        my ( $sPre, $sObj, $sAft ) = ( $1, $2, $3 );\n        for ( my $i = length($sObj) - 3 ; $i > 0 ; $i -= 3 ) {\n            substr( $sObj, $i, 0, ',' );\n        }\n        return $sPre . $sObj . $sAft;\n    }\n    else {\n        return $sNum;\n    }\n}\n\n#------------------------------------------------------------------------------\n# MakeFraction (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub MakeFraction {\n    my ( $sFmt, $iData, $iFlg ) = @_;\n    my $iBunbo;\n    my $iShou;\n\n    #1. Init\n    # print \"FLG: $iFlg\\n\";\n    if ($iFlg) {\n        $iShou = $iData - int($iData);\n        return '' if ( $iShou == 0 );\n    }\n    else {\n        $iShou = $iData;\n    }\n    $iShou = abs($iShou);\n    my $sSWk;\n\n    #2.Calc BUNBO\n    #2.1 BUNBO defined\n    if ( $sFmt =~ /\\/(\\d+)$/ ) {\n        $iBunbo = $1;\n        return sprintf( \"%d/%d\", $iShou * $iBunbo, $iBunbo );\n    }\n    else {\n\n        #2.2 Calc BUNBO\n        $sFmt =~ /\\/(\\?+)$/;\n        my $iKeta = length($1);\n        my $iSWk  = 1;\n        my $sSWk  = '';\n        my $iBunsi;\n        for ( my $iBunbo = 2 ; $iBunbo < 10**$iKeta ; $iBunbo++ ) {\n            $iBunsi = int( $iShou * $iBunbo + 0.5 );\n            my $iCmp = abs( $iShou - ( $iBunsi / $iBunbo ) );\n            if ( $iCmp < $iSWk ) {\n                $iSWk = $iCmp;\n                $sSWk = sprintf( \"%d/%d\", $iBunsi, $iBunbo );\n                last if ( $iSWk == 0 );\n            }\n        }\n        return $sSWk;\n    }\n}\n\n#------------------------------------------------------------------------------\n# MakeE (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub MakeE {\n    my ( $sFmt, $iData ) = @_;\n\n    $sFmt =~ /(([#0]*)[\\.]?[#0]*)([eE])([\\+\\-][0#]+)/;\n    my ( $sKari, $iKeta, $sE, $sSisu ) = ( $1, length($2), $3, $4 );\n    $iKeta = 1 if ( $iKeta <= 0 );\n\n    my $iLog10 = 0;\n    $iLog10 = ( $iData == 0 ) ? 0 : ( log( abs($iData) ) / log(10) );\n    $iLog10 = (\n        int( $iLog10 / $iKeta ) +\n          ( ( ( $iLog10 - int( $iLog10 / $iKeta ) ) < 0 ) ? -1 : 0 ) ) * $iKeta;\n\n    my $sUe = ExcelFmt( $sKari, $iData * ( 10**( $iLog10 * -1 ) ), 0 );\n    my $sShita = ExcelFmt( $sSisu, $iLog10, 0 );\n    return $sUe . $sE . $sShita;\n}\n\n#------------------------------------------------------------------------------\n# LeapYear (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub LeapYear {\n    my ($iYear) = @_;\n    return 1 if ( $iYear == 1900 );    #Special for Excel\n    return ( ( ( $iYear % 4 ) == 0 )\n          && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) )\n      ? 1\n      : 0;\n}\n\n#------------------------------------------------------------------------------\n# LocaltimeExcel (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub LocaltimeExcel {\n    my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec, $flg1904 )\n      = @_;\n\n    #0. Init\n    $iMon++;\n    $iYear += 1900;\n\n    #1. Calc Time\n    my $iTime;\n    $iTime = $iHour;\n    $iTime *= 60;\n    $iTime += $iMin;\n    $iTime *= 60;\n    $iTime += $iSec;\n    $iTime += $iMSec / 1000.0 if ( defined($iMSec) );\n    $iTime /= 86400.0;    #3600*24(1day in seconds)\n    my $iY;\n    my $iYDays;\n\n    #2. Calc Days\n    if ($flg1904) {\n        $iY = 1904;\n        $iTime--;         #Start from Jan 1st\n        $iYDays = 366;\n    }\n    else {\n        $iY     = 1900;\n        $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)\n    }\n    while ( $iY < $iYear ) {\n        $iTime += $iYDays;\n        $iY++;\n        $iYDays = ( LeapYear($iY) ) ? 366 : 365;\n    }\n    for ( my $iM = 1 ; $iM < $iMon ; $iM++ ) {\n        if (   $iM == 1\n            || $iM == 3\n            || $iM == 5\n            || $iM == 7\n            || $iM == 8\n            || $iM == 10\n            || $iM == 12 )\n        {\n            $iTime += 31;\n        }\n        elsif ( $iM == 4 || $iM == 6 || $iM == 9 || $iM == 11 ) {\n            $iTime += 30;\n        }\n        elsif ( $iM == 2 ) {\n            $iTime += ( LeapYear($iYear) ) ? 29 : 28;\n        }\n    }\n    $iTime += $iDay;\n    return $iTime;\n}\n\nmy @month_days = qw(\n  0 31 28 31 30 31 30 31 31 30 31 30 31\n);\n\n#------------------------------------------------------------------------------\n# ExcelLocaltime (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub ExcelLocaltime {\n\n    my ( $dObj, $flg1904 ) = @_;\n    my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );\n    my ( $iDt, $iTime, $iYDays, $iMD );\n\n    $iDt   = int($dObj);\n    $iTime = $dObj - $iDt;\n\n    #1. Calc Days\n    if ($flg1904) {\n        $iYear = 1904;\n        $iDt++;    #Start from Jan 1st\n        $iYDays = 366;\n        $iwDay = ( ( $iDt + 4 ) % 7 );\n    }\n    else {\n        $iYear  = 1900;\n        $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)\n        $iwDay = ( ( $iDt + 6 ) % 7 );\n    }\n    while ( $iDt > $iYDays ) {\n        $iDt -= $iYDays;\n        $iYear++;\n        $iYDays =\n          (      ( ( $iYear % 4 ) == 0 )\n              && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) ) ? 366 : 365;\n    }\n    $iYear -= 1900;       # Localtime year is relative to 1900.\n\n    for ( $iMon = 1 ; $iMon <= 12 ; $iMon++ ) {\n        $iMD = $month_days[$iMon];\n        $iMD++ if $iMon == 2 and $iYear % 4 == 0;\n\n        last if ( $iDt <= $iMD );\n        $iDt -= $iMD;\n    }\n\n    #2. Calc Time\n    $iDay = $iDt;\n    $iTime += ( 0.0005 / 86400.0 );\n    if ($iTime >= 1.0)\n    {\n        $iTime -= int($iTime);\n        $iwDay = ($iwDay == 6) ? 0 : $iwDay + 1;\n        if ($iDay == $iMD)\n        {\n            if ($iMon == 12)\n            {\n                $iMon = 1;\n                $iYear++;\n            }\n            else\n            {\n                $iMon++;\n            }\n            $iDay = 1;\n        }\n        else\n        {\n            $iDay++;\n        }\n    }\n\n    # Localtime month is 0 based.\n    $iMon  -= 1;\n    $iTime *= 24.0;\n    $iHour = int($iTime);\n    $iTime -= $iHour;\n    $iTime *= 60.0;\n    $iMin = int($iTime);\n    $iTime -= $iMin;\n    $iTime *= 60.0;\n    $iSec = int($iTime);\n    $iTime -= $iSec;\n    $iTime *= 1000.0;\n    $iMSec = int($iTime);\n\n    return ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );\n}\n\n# -----------------------------------------------------------------------------\n# col2int (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n# converts a excel row letter into an int for use in an array\nsub col2int {\n    my $result = 0;\n    my $str    = shift;\n    my $incr   = 0;\n\n    for ( my $i = length($str) ; $i > 0 ; $i-- ) {\n        my $char = substr( $str, $i - 1 );\n        my $curr += ord( lc($char) ) - ord('a') + 1;\n        $curr *= $incr if ($incr);\n        $result += $curr;\n        $incr   += 26;\n    }\n\n    # this is one out as we range 0..x-1 not 1..x\n    $result--;\n\n    return $result;\n}\n\n# -----------------------------------------------------------------------------\n# int2col (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n### int2col\n# convert a column number into column letters\n# @note this is quite a brute force coarse method\n#   does not manage values over 701 (ZZ)\n# @arg number, to convert\n# @returns string, column name\n#\nsub int2col {\n    my $out = \"\";\n    my $val = shift;\n\n    do {\n        $out .= chr( ( $val % 26 ) + ord('A') );\n        $val = int( $val / 26 ) - 1;\n    } while ( $val >= 0 );\n\n    return scalar reverse $out;\n}\n\n# -----------------------------------------------------------------------------\n# sheetRef (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n### sheetRef\n# convert an excel letter-number address into a useful array address\n# @note that also Excel uses X-Y notation, we normally use Y-X in arrays\n# @args $str, excel coord eg. A2\n# @returns an array - 2 elements - column, row, or undefined\n#\nsub sheetRef {\n    my $str = shift;\n    my @ret;\n\n    $str =~ m/^(\\D+)(\\d+)$/;\n\n    if ( $1 && $2 ) {\n        push( @ret, $2 - 1, col2int($1) );\n    }\n    if ( $ret[0] < 0 ) {\n        undef @ret;\n    }\n\n    return @ret;\n}\n\n# -----------------------------------------------------------------------------\n# xls2csv (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n### xls2csv\n# convert a chunk of an excel file into csv text chunk\n# @args $param, sheet-colrow:colrow (1-A1:B2 or A1:B2 for sheet 1\n# @args $rotate, 0 or 1 decides if output should be rotated or not\n# @returns string containing a chunk of csv\n#\nsub xls2csv {\n    my ( $filename, $regions, $rotate ) = @_;\n    my $sheet = 0;\n\n    # We need Text::CSV_XS for proper CSV handling.\n    require Text::CSV_XS;\n\n    # extract any sheet number from the region string\n    $regions =~ m/^(\\d+)-(.*)/;\n\n    if ($2) {\n        $sheet   = $1 - 1;\n        $regions = $2;\n    }\n\n    # now extract the start and end regions\n    $regions =~ m/(.*):(.*)/;\n\n    if ( !$1 || !$2 ) {\n        print STDERR \"Bad Params\";\n        return \"\";\n    }\n\n    my @start = sheetRef($1);\n    my @end   = sheetRef($2);\n    if ( !@start ) {\n        print STDERR \"Bad coorinates - $1\";\n        return \"\";\n    }\n    if ( !@end ) {\n        print STDERR \"Bad coorinates - $2\";\n        return \"\";\n    }\n\n    if ( $start[1] > $end[1] ) {\n        print STDERR \"Bad COLUMN ordering\\n\";\n        print STDERR \"Start column \" . int2col( $start[1] );\n        print STDERR \" after end column \" . int2col( $end[1] ) . \"\\n\";\n        return \"\";\n    }\n    if ( $start[0] > $end[0] ) {\n        print STDERR \"Bad ROW ordering\\n\";\n        print STDERR \"Start row \" . ( $start[0] + 1 );\n        print STDERR \" after end row \" . ( $end[0] + 1 ) . \"\\n\";\n        exit;\n    }\n\n    # start the excel object now\n    my $oExcel = new Spreadsheet::ParseExcel;\n    my $oBook  = $oExcel->Parse($filename);\n\n    # open the sheet\n    my $oWkS = $oBook->{Worksheet}[$sheet];\n\n    # now check that the region exists in the file\n    # if not truncate to the possible region\n    # output a warning msg\n    if ( $start[1] < $oWkS->{MinCol} ) {\n        print STDERR int2col( $start[1] )\n          . \" < min col \"\n          . int2col( $oWkS->{MinCol} )\n          . \" Resetting\\n\";\n        $start[1] = $oWkS->{MinCol};\n    }\n    if ( $end[1] > $oWkS->{MaxCol} ) {\n        print STDERR int2col( $end[1] )\n          . \" > max col \"\n          . int2col( $oWkS->{MaxCol} )\n          . \" Resetting\\n\";\n        $end[1] = $oWkS->{MaxCol};\n    }\n    if ( $start[0] < $oWkS->{MinRow} ) {\n        print STDERR \"\"\n          . ( $start[0] + 1 )\n          . \" < min row \"\n          . ( $oWkS->{MinRow} + 1 )\n          . \" Resetting\\n\";\n        $start[0] = $oWkS->{MinCol};\n    }\n    if ( $end[0] > $oWkS->{MaxRow} ) {\n        print STDERR \"\"\n          . ( $end[0] + 1 )\n          . \" > max row \"\n          . ( $oWkS->{MaxRow} + 1 )\n          . \" Resetting\\n\";\n        $end[0] = $oWkS->{MaxRow};\n\n    }\n\n    my $x1 = $start[1];\n    my $y1 = $start[0];\n    my $x2 = $end[1];\n    my $y2 = $end[0];\n\n    my @cell_data;\n    my $row = 0;\n\n    if ( !$rotate ) {\n        for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {\n            for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {\n                my $cell = $oWkS->{Cells}[$y][$x];\n\n                my $value;\n                if ( defined $cell ) {\n                    $value .= $cell->value();\n                }\n                else {\n                    $value = '';\n                }\n\n                push @{ $cell_data[$row] }, $value;\n            }\n            $row++;\n        }\n    }\n    else {\n        for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {\n            for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {\n                my $cell = $oWkS->{Cells}[$y][$x];\n\n                my $value;\n                if ( defined $cell ) {\n                    $value .= $cell->value();\n                }\n                else {\n                    $value = '';\n                }\n\n                push @{ $cell_data[$row] }, $value;\n            }\n            $row++;\n        }\n    }\n\n    # Create the CSV output string.\n    my $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );\n    my $output = \"\";\n\n    for my $row (@cell_data) {\n        $csv->combine(@$row);\n        $output .= $csv->string();\n    }\n\n    return $output;\n}\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nSpreadsheet::ParseExcel::Utility - Utility functions for Spreadsheet::ParseExcel.\n\n=head1 SYNOPSIS\n\n    use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);\n\n    # Convert localtime to Excel time\n    my $datetime = LocaltimeExcel(11, 10, 12, 23, 2, 64); # 1964-3-23 12:10:11\n\n    print $datetime, \"\\n\"; # 23459.5070717593 (Excel date/time format)\n\n    # Convert Excel Time to localtime\n    my @time = ExcelLocaltime($datetime);\n    print join(\":\", @time), \"\\n\";   # 11:10:12:23:2:64:1:0\n\n    # Formatting\n    print ExcelFmt('yyyy-mm-dd', $datetime), \"\\n\"; # 1964-3-23\n    print ExcelFmt('m-d-yy',     $datetime), \"\\n\"; # 3-23-64\n    print ExcelFmt('#,##0',      $datetime), \"\\n\"; # 23,460\n    print ExcelFmt('#,##0.00',   $datetime), \"\\n\"; # 23,459.51\n\n=head1 DESCRIPTION\n\nThe C<Spreadsheet::ParseExcel::Utility> module provides utility functions for working with ParseExcel and Excel data.\n\n=head1 Functions\n\nC<Spreadsheet::ParseExcel::Utility> can export the following functions:\n\n    ExcelFmt\n    ExcelLocaltime\n    LocaltimeExcel\n    col2int\n    int2col\n    sheetRef\n    xls2csv\n\nThese functions must be imported implicitly:\n\n    # Just one function.\n    use Spreadsheet::ParseExcel::Utility 'col2int';\n\n    # More than one.\n    use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);\n\n\n=head2 ExcelFmt($format_string, $number, $is_1904)\n\nExcel stores data such as dates and currency values as numbers. The way these numbers are displayed is controlled by the number format string for the cell. For example a cell with a number format of C<'$#,##0.00'> for currency and a value of 1234.567 would be displayed as follows:\n\n    '$#,##0.00' + 1234.567 = '$1,234.57'.\n\nThe C<ExcelFmt()> function tries to emulate this formatting so that the user can convert raw numbers returned by C<Spreadsheet::ParseExel> to a desired format. For example:\n\n    print ExcelFmt('$#,##0.00', 1234.567); # $1,234.57.\n\nThe syntax of the function is:\n\n    my $text = ExcelFmt($format_string, $number, $is_1904);\n\nWhere C<$format_string> is an Excel number format string, C<$number> is a real or integer number and C<is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\nC<ExcelFmt()> is also used internally to convert numbers returned by the C<Cell::unformatted()> method to the formatted value returned by the C<Cell::value()> method:\n\n\n    my $cell = $worksheet->get_cell( 0, 0 );\n\n    print $cell->unformatted(), \"\\n\"; # 1234.567\n    print $cell->value(),       \"\\n\"; # $1,234.57\n\nThe most common usage for C<ExcelFmt> is to convert numbers to dates. Dates and times in Excel are represented by real numbers, for example \"1 Jan 2001 12:30 PM\" is represented by the number 36892.521. The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day. By applying an Excel number format the number is converted to the desired string representation:\n\n    print ExcelFmt('d mmm yyyy h:mm AM/PM', 36892.521);  # 1 Jan 2001 12:30 PM\n\nC<$is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch. Excel for Windows generally uses 1900 and Excel for Mac OS uses 1904. The C<$is1904> flag isn't required very often by a casual user and can usually be ignored.\n\n\n=head2 ExcelLocaltime($excel_datetime, $is_1904)\n\nThe C<ExcelLocaltime()> function converts from an Excel date/time number to a C<localtime()>-like array of values:\n\n        my @time = ExcelLocaltime($excel_datetime);\n\n        #    0     1     2      3     4       5      6      7\n        my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;\n\nThe array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. This means that you will usually need to do the following:\n\n        $month++;\n        $year += 1900;\n\nSee also Perl's documentation for L<localtime()|perlfunc>:\n\nThe C<$is_1904> flag is an optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\n=head2 LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec, $is_1904)\n\nThe C<LocaltimeExcel()> function converts from a C<localtime()>-like array of values to an Excel date/time number:\n\n    $excel_datetime = LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec);\n\nThe array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. See also Perl's documentation for L<localtime()|perlfunc>:\n\nThe C<$wday> and C<$msec> elements are usually optional. This time elements can also be zeroed if they aren't of interest:\n\n                                    # sec, min, hour, day, month, year\n    $excel_datetime = LocaltimeExcel( 0,   0,   0,    1,   0,     101 );\n\n    print ExcelFmt('d mmm yyyy', $excel_datetime);  # 1 Jan 2001\n\nThe C<$is_1904> flag is also optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\n\n=head2 col2int($column)\n\nThe C<col2int()> function converts an Excel column letter to an zero-indexed column number:\n\n    print col2int('A');  # 0\n    print col2int('AA'); # 26\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 int2col($column_number)\n\nThe C<int2col()> function converts an zero-indexed Excel column number to a column letter:\n\n    print int2col(0);  # 'A'\n    print int2col(26); # 'AA'\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 sheetRef($cell_string)\n\nThe C<sheetRef()> function converts an Excel cell reference in 'A1' notation to a zero-indexed C<(row, col)> pair.\n\n    my ($row, $col) = sheetRef('A1'); # ( 0, 0 )\n    my ($row, $col) = sheetRef('C2'); # ( 1, 2 )\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 xls2csv($filename, $region, $rotate)\n\nThe C<xls2csv()> function converts a section of an Excel file into a CSV text string.\n\n    $csv_text = xls2csv($filename, $region, $rotate);\n\nWhere:\n\n    $region = \"sheet-colrow:colrow\"\n    For example '1-A1:B2' means 'A1:B2' for sheet 1.\n\n    and\n\n    $rotate  = 0 or 1 (output is rotated/transposed or not)\n\nThis function requires C<Text::CSV_XS> to be installed. It was contributed by Kevin Mulholland along with the C<xls2csv> script in the C<sample> directory of the distro.\n\nSee also the following xls2csv utilities: Ken Prows' C<xls2csv>: http://search.cpan.org/~ken/xls2csv/script/xls2csv and H.Merijn Brand's C<xls2csv> (which is part of Spreadsheet::Read): http://search.cpan.org/~hmbrand/Spreadsheet-Read/\n\n\n=head1 AUTHOR\n\nCurrent maintainer 0.60+: Douglas Wilson dougw@cpan.org\n\nMaintainer 0.40-0.59: John McNamara jmcnamara@cpan.org\n\nMaintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org\n\nOriginal author: Kawai Takanori kwitknr@cpan.org\n\n=head1 COPYRIGHT\n\nCopyright (c) 2014 Douglas Wilson\n\nCopyright (c) 2009-2013 John McNamara\n\nCopyright (c) 2006-2008 Gabor Szabo\n\nCopyright (c) 2000-2006 Kawai Takanori\n\nAll rights reserved.\n\nYou may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.\n\n=cut\n"], "fixing_code": ["package Spreadsheet::ParseExcel::Utility;\n\n###############################################################################\n#\n# Spreadsheet::ParseExcel::Utility - Utility functions for ParseExcel.\n#\n# Used in conjunction with Spreadsheet::ParseExcel.\n#\n# Copyright (c) 2014      Douglas Wilson\n# Copyright (c) 2009-2013 John McNamara\n# Copyright (c) 2006-2008 Gabor Szabo\n# Copyright (c) 2000-2006 Kawai Takanori\n#\n# perltidy with standard settings.\n#\n# Documentation after __END__\n#\n\nuse strict;\nuse warnings;\n\nrequire Exporter;\nuse vars qw(@ISA @EXPORT_OK);\n@ISA       = qw(Exporter);\n@EXPORT_OK = qw(ExcelFmt LocaltimeExcel ExcelLocaltime\n  col2int int2col sheetRef xls2csv);\n\nour $VERSION = '0.65';\n\nmy $qrNUMBER = qr/(^[+-]?\\d+(\\.\\d+)?$)|(^[+-]?\\d+\\.?(\\d*)[eE][+-](\\d+))$/;\n\n###############################################################################\n#\n# ExcelFmt()\n#\n# This function takes an Excel style number format and converts a number into\n# that format. for example: 'hh:mm:ss AM/PM' + 0.01023148 = '12:14:44 AM'.\n#\n# It does this with a type of templating mechanism. The format string is parsed\n# to identify tokens that need to be replaced and their position within the\n# string is recorded. These can be thought of as placeholders. The number is\n# then converted to the required formats and substituted into the placeholders.\n#\n# Interested parties should refer to the Excel documentation on cell formats for\n# more information: http://office.microsoft.com/en-us/excel/HP051995001033.aspx\n# The Microsoft documentation for the Excel Binary File Format, [MS-XLS].pdf,\n# also contains a ABNF grammar for number format strings.\n#\n# Maintainers notes:\n# ==================\n#\n# Note on format subsections:\n# A format string can contain 4 possible sub-sections separated by semi-colons:\n# Positive numbers, negative numbers, zero values, and text.\n# For example: _(* #,##0_);_(* (#,##0);_(* \"-\"_);_(@_)\n#\n# Note on conditional formats.\n# A number format in Excel can have a conditional expression such as:\n#     [>9999999](000)000-0000;000-0000\n# This is equivalent to the following in Perl:\n#     $format = $number > 9999999 ? '(000)000-0000' : '000-0000';\n# Nested conditionals are also possible but we don't support them.\n#\n# Efficiency: The excessive use of substr() isn't very efficient. However,\n# it probably doesn't merit rewriting this function with a parser or regular\n# expressions and \\G.\n#\n# TODO: I think the single quote handling may not be required. Check.\n#\nsub ExcelFmt {\n\n    my ( $format_str, $number, $is_1904, $number_type, $want_subformats ) = @_;\n\n    # Return text strings without further formatting.\n    return $number unless $number =~ $qrNUMBER;\n\n    # Handle OpenOffice.org GENERAL format.\n    $format_str = '@' if uc($format_str) eq \"GENERAL\";\n\n    # Check for a conditional at the start of the format. See notes above.\n    my $conditional_op;\n    my $conditional_value;\n    if ( $format_str =~ /^\\[([<>=]+)([^\\]]+)\\](.*)$/ ) {\n        $conditional_op = $1;\n        $conditional_value = $2;\n        $format_str = $3;\n    }\n\n    # Ignore the underscore token which is used to indicate a padding space.\n    $format_str =~ s/_/ /g;\n\n    # Split the format string into 4 possible sub-sections: positive numbers,\n    # negative numbers, zero values, and text. See notes above.\n    my @formats;\n    my $section      = 0;\n    my $double_quote = 0;\n    my $single_quote = 0;\n\n    # Initial parsing of the format string to remove escape characters. This\n    # also handles quoted strings. See note about single quotes above.\n  CHARACTER:\n    for my $char ( split //, $format_str ) {\n\n        if ( $double_quote or $single_quote ) {\n            $formats[$section] .= $char;\n            $double_quote = 0 if $char eq '\"';\n            $single_quote = 0;\n            next CHARACTER;\n        }\n\n        if ( $char eq ';' ) {\n            $section++;\n            next CHARACTER;\n        }\n        elsif ( $char eq '\"' ) {\n            $double_quote = 1;\n        }\n        elsif ( $char eq '!' ) {\n            $single_quote = 1;\n        }\n        elsif ( $char eq '\\\\' ) {\n            $single_quote = 1;\n        }\n        elsif ( $char eq '(' ) {\n            next CHARACTER;    # Ignore.\n        }\n        elsif ( $char eq ')' ) {\n            next CHARACTER;    # Ignore.\n        }\n\n        # Convert upper case OpenOffice.org date/time formats to lowercase..\n        $char = lc($char) if $char =~ /[DMYHS]/;\n\n        $formats[$section] .= $char;\n    }\n\n    # Select the appropriate format from the 4 possible sub-sections:\n    # positive numbers, negative numbers, zero values, and text.\n    # We ignore the Text section since non-numeric values are returned\n    # unformatted at the start of the function.\n    my $format;\n    $section = 0;\n\n    if ( @formats == 1 ) {\n        $section = 0;\n    }\n    elsif ( @formats == 2 ) {\n        if ( $number < 0 ) {\n            $section = 1;\n        }\n        else {\n            $section = 0;\n        }\n    }\n    elsif ( @formats == 3 ) {\n        if ( $number == 0 ) {\n            $section = 2;\n        }\n        elsif ( $number < 0 ) {\n            $section = 1;\n        }\n        else {\n            $section = 0;\n        }\n    }\n    else {\n        $section = 0;\n    }\n\n    # Override the previous choice if the format is conditional.\n    if ($conditional_op) {\n        if ($conditional_op eq '>') {\n            $section = $number > $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '>=') {\n            $section = $number >= $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '<') {\n            $section = $number < $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '<=') {\n            $section = $number <= $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '=') {\n            $section = $number == $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '==') {\n            $section = $number == $conditional_value ? 0 : 1;\n        } elsif ($conditional_op eq '<>') {\n            $section = $number != $conditional_value ? 0 : 1;\n        }\n    }\n    # We now have the required format.\n    $format = $formats[$section];\n\n    # The format string can contain one of the following colours:\n    # [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]\n    # or the string [ColorX] where x is a colour index from 1 to 56.\n    # We don't use the colour but we return it to the caller.\n    #\n    my $color = '';\n    if ( $format =~ s/^(\\[[A-Za-z]{3,}(\\d{1,2})?\\])// ) {\n        $color = $1;\n    }\n\n    # Remove the locale, such as [$-409], from the format string.\n    my $locale = '';\n    if ( $format =~ s/^(\\[\\$?-F?\\d+\\])// ) {\n        $locale = $1;\n    }\n\n    # Replace currency locale, such as [$$-409], with $ in the format string.\n    # See the RT#60547 test cases in 21_number_format_user.t.\n    if ( $format =~ s/(\\[\\$([^-]+)(-\\d+)?\\])/$2/s ) {\n        $locale = $1;\n    }\n\n\n    # Remove leading # from '# ?/?', '# ??/??' fraction formats.\n    $format =~ s{# \\?}{?}g;\n\n    # Parse the format string and create an AoA of placeholders that contain\n    # the parts of the string to be replaced. The format of the information\n    # stored is: [ $token, $start_pos, $end_pos, $option_info ].\n    #\n    my $format_mode  = '';    # Either: '', 'number', 'date'\n    my $pos          = 0;     # Character position within format string.\n    my @placeholders = ();    # Arefs with parts of the format to be replaced.\n    my $token        = '';    # The actual format extracted from the total str.\n    my $start_pos;            # A position variable. Initial parser position.\n    my $token_start = -1;     # A position variable.\n    my $decimal_pos = -1;     # Position of the punctuation char \".\" or \",\".\n    my $comma_count = 0;      # Count of the commas in the format.\n    my $is_fraction = 0;      # Number format is a fraction.\n    my $is_currency = 0;      # Number format is a currency.\n    my $is_percent  = 0;      # Number format is a percentage.\n    my $is_12_hour  = 0;      # Time format is using 12 hour clock.\n    my $seen_dot    = 0;      # Treat only the first \".\" as the decimal point.\n\n    # Parse the format.\n  PARSER:\n    while ( $pos < length $format ) {\n        $start_pos = $pos;\n        my $char = substr( $format, $pos, 1 );\n\n        # Ignore control format characters such as '#0+-.?eE,%'. However,\n        # only ignore '.' if it is the first one encountered. RT 45502.\n        if ( ( !$seen_dot && $char !~ /[#0\\+\\-\\.\\?eE\\,\\%]/ )\n            || $char !~ /[#0\\+\\-\\?eE\\,\\%]/ )\n        {\n\n            if ( $token_start != -1 ) {\n                push @placeholders,\n                  [\n                    substr( $format, $token_start, $pos - $token_start ),\n                    $decimal_pos, $pos - $token_start\n                  ];\n                $token_start = -1;\n            }\n        }\n\n        # Processing for quoted strings within the format. See notes above.\n        if ( $char eq '\"' ) {\n            $double_quote = $double_quote ? 0 : 1;\n            $pos++;\n            next PARSER;\n        }\n        elsif ( $char eq '!' ) {\n            $single_quote = 1;\n            $pos++;\n            next PARSER;\n        }\n        elsif ( $char eq '\\\\' ) {\n            if ( $single_quote != 1 ) {\n                $single_quote = 1;\n                $pos++;\n                next PARSER;\n            }\n        }\n\n        if (   ( defined($double_quote) and ($double_quote) )\n            or ( defined($single_quote) and ($single_quote) )\n            or ( $seen_dot && $char eq '.' ) )\n        {\n            $single_quote = 0;\n            if (\n                ( $format_mode ne 'date' )\n                and (  ( substr( $format, $pos, 2 ) eq \"\\x81\\xA2\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\x81\\xA3\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\xA2\\xA4\" )\n                    || ( substr( $format, $pos, 2 ) eq \"\\xA2\\xA5\" ) )\n              )\n            {\n\n                # The above matches are currency symbols.\n                push @placeholders,\n                  [ substr( $format, $pos, 2 ), length($token), 2 ];\n                $is_currency = 1;\n                $pos += 2;\n            }\n            else {\n                $pos++;\n            }\n        }\n        elsif (\n            ( $char =~ /[#0\\+\\.\\?eE\\,\\%]/ )\n            || (    ( $format_mode ne 'date' )\n                and ( ( $char eq '-' ) || ( $char eq '(' ) || ( $char eq ')' ) )\n            )\n          )\n        {\n            $format_mode = 'number' unless $format_mode;\n            if ( substr( $format, $pos, 1 ) =~ /[#0]/ ) {\n                if (\n                    substr( $format, $pos ) =~\n                    /^([#0]+[\\.]?[0#]*[eE][\\+\\-][0#]+)/ )\n                {\n                    push @placeholders, [ $1, $pos, length($1) ];\n                    $pos += length($1);\n                }\n                else {\n                    if ( $token_start == -1 ) {\n                        $token_start = $pos;\n                        $decimal_pos = length($token);\n                    }\n                }\n            }\n            elsif ( substr( $format, $pos, 1 ) eq '?' ) {\n\n                # Look for a fraction format like ?/? or ??/??\n                if ( $token_start != -1 ) {\n                    push @placeholders,\n                      [\n                        substr(\n                            $format, $token_start, $pos - $token_start + 1\n                        ),\n                        $decimal_pos,\n                        $pos - $token_start + 1\n                      ];\n                }\n                $token_start = $pos;\n\n                # Find the end of the fraction format.\n              FRACTION:\n                while ( $pos < length($format) ) {\n                    if ( substr( $format, $pos, 1 ) eq '/' ) {\n                        $is_fraction = 1;\n                    }\n                    elsif ( substr( $format, $pos, 1 ) eq '?' ) {\n                        $pos++;\n                        next FRACTION;\n                    }\n                    else {\n                        if ( $is_fraction\n                            && ( substr( $format, $pos, 1 ) =~ /[0-9]/ ) )\n                        {\n\n                            # TODO: Could invert if() logic and remove this.\n                            $pos++;\n                            next FRACTION;\n                        }\n                        else {\n                            last FRACTION;\n                        }\n                    }\n                    $pos++;\n                }\n                $pos--;\n\n                push @placeholders,\n                  [\n                    substr( $format, $token_start, $pos - $token_start + 1 ),\n                    length($token), $pos - $token_start + 1\n                  ];\n                $token_start = -1;\n            }\n            elsif ( substr( $format, $pos, 3 ) =~ /^[eE][\\+\\-][0#]$/ ) {\n                if ( substr( $format, $pos ) =~ /([eE][\\+\\-][0#]+)/ ) {\n                    push @placeholders, [ $1, $pos, length($1) ];\n                    $pos += length($1);\n                }\n                $token_start = -1;\n            }\n            else {\n                if ( $token_start != -1 ) {\n                    push @placeholders,\n                      [\n                        substr( $format, $token_start, $pos - $token_start ),\n                        $decimal_pos, $pos - $token_start\n                      ];\n                    $token_start = -1;\n                }\n                if ( substr( $format, $pos, 1 ) =~ /[\\+\\-]/ ) {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $is_currency = 1;\n                }\n                elsif ( substr( $format, $pos, 1 ) eq '.' ) {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $seen_dot = 1;\n                }\n                elsif ( substr( $format, $pos, 1 ) eq ',' ) {\n                    $comma_count++;\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                }\n                elsif ( substr( $format, $pos, 1 ) eq '%' ) {\n                    $is_percent = 1;\n                }\n                elsif (( substr( $format, $pos, 1 ) eq '(' )\n                    || ( substr( $format, $pos, 1 ) eq ')' ) )\n                {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                    $is_currency = 1;\n                }\n            }\n            $pos++;\n        }\n        elsif ( $char =~ /[ymdhsapg]/i ) {\n            $format_mode = 'date' unless $format_mode;\n            if ( substr( $format, $pos, 5 ) =~ /am\\/pm/i ) {\n                push @placeholders, [ 'am/pm', length($token), 5 ];\n                $is_12_hour = 1;\n                $pos += 5;\n            }\n            elsif ( substr( $format, $pos, 3 ) =~ /a\\/p/i ) {\n                push @placeholders, [ 'a/p', length($token), 3 ];\n                $is_12_hour = 1;\n                $pos += 3;\n            }\n            elsif ( substr( $format, $pos, 5 ) eq 'mmmmm' ) {\n                push @placeholders, [ 'mmmmm', length($token), 5 ];\n                $pos += 5;\n            }\n            elsif (( substr( $format, $pos, 4 ) eq 'mmmm' )\n                || ( substr( $format, $pos, 4 ) eq 'dddd' )\n                || ( substr( $format, $pos, 4 ) eq 'yyyy' )\n                || ( substr( $format, $pos, 4 ) eq 'ggge' ) )\n            {\n                push @placeholders,\n                  [ substr( $format, $pos, 4 ), length($token), 4 ];\n                $pos += 4;\n            }\n            elsif (( substr( $format, $pos, 3 ) eq 'ddd' )\n                || ( substr( $format, $pos, 3 ) eq 'mmm' )\n                || ( substr( $format, $pos, 3 ) eq 'yyy' ) )\n            {\n                push @placeholders,\n                  [ substr( $format, $pos, 3 ), length($token), 3 ];\n                $pos += 3;\n            }\n            elsif (( substr( $format, $pos, 2 ) eq 'yy' )\n                || ( substr( $format, $pos, 2 ) eq 'mm' )\n                || ( substr( $format, $pos, 2 ) eq 'dd' )\n                || ( substr( $format, $pos, 2 ) eq 'hh' )\n                || ( substr( $format, $pos, 2 ) eq 'ss' )\n                || ( substr( $format, $pos, 2 ) eq 'ge' ) )\n            {\n                if (\n                       ( substr( $format, $pos, 2 ) eq 'mm' )\n                    && (@placeholders)\n                    && (   ( $placeholders[-1]->[0] eq 'h' )\n                        or ( $placeholders[-1]->[0] eq 'hh' ) )\n                  )\n                {\n\n                    # For this case 'm' is minutes not months.\n                    push @placeholders, [ 'mm', length($token), 2, 'minutes' ];\n                }\n                else {\n                    push @placeholders,\n                      [ substr( $format, $pos, 2 ), length($token), 2 ];\n                }\n                if (   ( substr( $format, $pos, 2 ) eq 'ss' )\n                    && ( @placeholders > 1 ) )\n                {\n                    if (   ( $placeholders[-2]->[0] eq 'm' )\n                        || ( $placeholders[-2]->[0] eq 'mm' ) )\n                    {\n\n                        # For this case 'm' is minutes not months.\n                        push( @{ $placeholders[-2] }, 'minutes' );\n                    }\n                }\n                $pos += 2;\n            }\n            elsif (( substr( $format, $pos, 1 ) eq 'm' )\n                || ( substr( $format, $pos, 1 ) eq 'd' )\n                || ( substr( $format, $pos, 1 ) eq 'h' )\n                || ( substr( $format, $pos, 1 ) eq 's' ) )\n            {\n                if (\n                       ( substr( $format, $pos, 1 ) eq 'm' )\n                    && (@placeholders)\n                    && (   ( $placeholders[-1]->[0] eq 'h' )\n                        or ( $placeholders[-1]->[0] eq 'hh' ) )\n                  )\n                {\n\n                    # For this case 'm' is minutes not months.\n                    push @placeholders, [ 'm', length($token), 1, 'minutes' ];\n                }\n                else {\n                    push @placeholders,\n                      [ substr( $format, $pos, 1 ), length($token), 1 ];\n                }\n                if (   ( substr( $format, $pos, 1 ) eq 's' )\n                    && ( @placeholders > 1 ) )\n                {\n                    if (   ( $placeholders[-2]->[0] eq 'm' )\n                        || ( $placeholders[-2]->[0] eq 'mm' ) )\n                    {\n\n                        # For this case 'm' is minutes not months.\n                        push( @{ $placeholders[-2] }, 'minutes' );\n                    }\n                }\n                $pos += 1;\n            }\n        }\n        elsif ( ( substr( $format, $pos, 3 ) eq '[h]' ) ) {\n            $format_mode = 'date' unless $format_mode;\n            push @placeholders, [ '[h]', length($token), 3 ];\n            $pos += 3;\n        }\n        elsif ( ( substr( $format, $pos, 4 ) eq '[mm]' ) ) {\n            $format_mode = 'date' unless $format_mode;\n            push @placeholders, [ '[mm]', length($token), 4 ];\n            $pos += 4;\n        }\n        elsif ( $char eq '@' ) {\n            push @placeholders, [ '@', length($token), 1 ];\n            $pos++;\n        }\n        elsif ( $char eq '*' ) {\n            push @placeholders,\n              [ substr( $format, $pos, 1 ), length($token), 1 ];\n        }\n        else {\n            $pos++;\n        }\n        $pos++ if ( $pos == $start_pos );    #No Format match\n        $token .= substr( $format, $start_pos, $pos - $start_pos );\n\n    }    # End of parsing.\n\n    # Copy the located format string to a result string that we will perform\n    # the substitutions on and return to the user.\n    my $result = $token;\n\n    # Add a placeholder between the decimal/comma and end of the token, if any.\n    if ( $token_start != -1 ) {\n        push @placeholders,\n          [\n            substr( $format, $token_start, $pos - $token_start + 1 ),\n            $decimal_pos, $pos - $token_start + 1\n          ];\n    }\n\n    #\n    # In the next sections we process date, number and text formats. We take a\n    # format such as yyyy/mm/dd and replace it with something like 2008/12/25.\n    #\n    if ( ( $format_mode eq 'date' ) && ( $number =~ $qrNUMBER ) ) {\n\n        # The maximum allowable date in Excel is 9999-12-31T23:59:59.000 which\n        # equates to 2958465.999+ in the 1900 epoch and 2957003.999+ in the\n        # 1904 epoch. We use 0 as the minimum in both epochs. The 1904 system\n        # actually supports negative numbers but that isn't worth the effort.\n        my $min_date = 0;\n        my $max_date = 2958466;\n        $max_date = 2957004 if $is_1904;\n\n        if ( $number < $min_date || $number >= $max_date ) {\n            return $number;    # Return unformatted number.\n        }\n\n        # Process date formats.\n        my @time = ExcelLocaltime( $number, $is_1904 );\n\n        #    0     1     2      3     4       5      6      7\n        my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;\n\n        $month++;              # localtime() zero indexed month.\n        $year += 1900;         # localtime() year.\n\n        my @full_month_name = qw(\n          None January February March April May June July\n          August September October November December\n        );\n        my @short_month_name = qw(\n          None Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n        );\n        my @full_day_name = qw(\n          Sunday Monday Tuesday Wednesday Thursday Friday Saturday\n        );\n        my @short_day_name = qw(\n          Sun Mon Tue Wed Thu Fri Sat\n        );\n\n        # Replace the placeholders in the template such as yyyy mm dd with\n        # actual numbers or strings.\n        my $replacement;\n        for my $placeholder ( reverse @placeholders ) {\n\n            if ( $placeholder->[-1] eq 'minutes' ) {\n\n                # For this case 'm/mm' is minutes not months.\n                if ( $placeholder->[0] eq 'mm' ) {\n                    $replacement = sprintf( \"%02d\", $min );\n                }\n                else {\n                    $replacement = sprintf( \"%d\", $min );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'yyyy' ) {\n\n                # 4 digit Year. 2000 -> 2000.\n                $replacement = sprintf( '%04d', $year );\n            }\n            elsif ( $placeholder->[0] eq 'yy' ) {\n\n                # 2 digit Year. 2000 -> 00.\n                $replacement = sprintf( '%02d', $year % 100 );\n            }\n            elsif ( $placeholder->[0] eq 'mmmmm' ) {\n\n                # First character of the month name. 1 -> J.\n                $replacement = substr( $short_month_name[$month], 0, 1 );\n            }\n            elsif ( $placeholder->[0] eq 'mmmm' ) {\n\n                # Full month name. 1 -> January.\n                $replacement = $full_month_name[$month];\n            }\n            elsif ( $placeholder->[0] eq 'mmm' ) {\n\n                # Short month name. 1 -> Jan.\n                $replacement = $short_month_name[$month];\n            }\n            elsif ( $placeholder->[0] eq 'mm' ) {\n\n                # 2 digit month. 1 -> 01.\n                $replacement = sprintf( '%02d', $month );\n            }\n            elsif ( $placeholder->[0] eq 'm' ) {\n\n                # 1 digit month. 1 -> 1.\n                $replacement = sprintf( '%d', $month );\n            }\n            elsif ( $placeholder->[0] eq 'dddd' ) {\n\n                # Full day name. Wednesday (for example.)\n                $replacement = $full_day_name[$wday];\n            }\n            elsif ( $placeholder->[0] eq 'ddd' ) {\n\n                # Short day name. Wed (for example.)\n                $replacement = $short_day_name[$wday];\n            }\n            elsif ( $placeholder->[0] eq 'dd' ) {\n\n                # 2 digit day. 1 -> 01.\n                $replacement = sprintf( '%02d', $day );\n            }\n            elsif ( $placeholder->[0] eq 'd' ) {\n\n                # 1 digit day. 1 -> 1.\n                $replacement = sprintf( '%d', $day );\n            }\n            elsif ( $placeholder->[0] eq 'hh' ) {\n\n                # 2 digit hour.\n                if ($is_12_hour) {\n                    my $hour_tmp = $hour % 12;\n                    $hour_tmp = 12 if $hour % 12 == 0;\n                    $replacement = sprintf( '%d', $hour_tmp );\n                }\n                else {\n                    $replacement = sprintf( '%02d', $hour );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'h' ) {\n\n                # 1 digit hour.\n                if ($is_12_hour) {\n                    my $hour_tmp = $hour % 12;\n                    $hour_tmp = 12 if $hour % 12 == 0;\n                    $replacement = sprintf( '%2d', $hour_tmp );\n                }\n                else {\n                    $replacement = sprintf( '%d', $hour );\n                }\n            }\n            elsif ( $placeholder->[0] eq 'ss' ) {\n\n                # 2 digit seconds.\n                $replacement = sprintf( '%02d', $sec );\n            }\n            elsif ( $placeholder->[0] eq 's' ) {\n\n                # 1 digit seconds.\n                $replacement = sprintf( '%d', $sec );\n            }\n            elsif ( $placeholder->[0] eq 'am/pm' ) {\n\n                # AM/PM.\n                $replacement = ( $hour >= 12 ) ? 'PM' : 'AM';\n            }\n            elsif ( $placeholder->[0] eq 'a/p' ) {\n\n                # AM/PM.\n                $replacement = ( $hour >= 12 ) ? 'P' : 'A';\n            }\n            elsif ( $placeholder->[0] eq '.' ) {\n\n                # Decimal point for seconds.\n                $replacement = '.';\n            }\n            elsif ( $placeholder->[0] =~ /(^0+$)/ ) {\n\n                # Milliseconds. For example h:ss.000.\n                my $length = length($1);\n                $replacement =\n                  substr( sprintf( \"%.${length}f\", $msec / 1000 ), 2, $length );\n            }\n            elsif ( $placeholder->[0] eq '[h]' ) {\n\n                # Hours modulus 24. 25 displays as 25 not as 1.\n                $replacement = sprintf( '%d', int($number) * 24 + $hour );\n            }\n            elsif ( $placeholder->[0] eq '[mm]' ) {\n\n                # Mins modulus 60. 72 displays as 72 not as 12.\n                $replacement =\n                  sprintf( '%d', ( int($number) * 24 + $hour ) * 60 + $min );\n            }\n            elsif ( $placeholder->[0] eq 'ge' ) {\n                require Spreadsheet::ParseExcel::FmtJapan;\n                # Japanese Nengo (aka Gengo) in initialism (abbr. name)\n                 $replacement =\n                  Spreadsheet::ParseExcel::FmtJapan::CnvNengo( abbr_name => @time );\n            }\n            elsif ( $placeholder->[0] eq 'ggge' ) {\n                require Spreadsheet::ParseExcel::FmtJapan;\n                # Japanese Nengo (aka Gengo) in Kanji (full name)\n                 $replacement =\n                  Spreadsheet::ParseExcel::FmtJapan::CnvNengo( name => @time );\n            }\n            elsif ( $placeholder->[0] eq '@' ) {\n\n                # Text format.\n                $replacement = $number;\n            }\n            elsif ( $placeholder->[0] eq ',' ) {\n                next;\n            }\n\n            # Substitute the replacement string back into the template.\n            substr( $result, $placeholder->[1], $placeholder->[2],\n                $replacement );\n        }\n    }\n    elsif ( ( $format_mode eq 'number' ) && ( $number =~ $qrNUMBER ) ) {\n\n        # Process non date formats.\n        if (@placeholders) {\n            while ( $placeholders[-1]->[0] eq ',' ) {\n                $comma_count--;\n                substr(\n                    $result,\n                    $placeholders[-1]->[1],\n                    $placeholders[-1]->[2], ''\n                );\n                $number /= 1000;\n                pop @placeholders;\n            }\n\n            my $number_format = join( '', map { $_->[0] } @placeholders );\n            my $number_result;\n            my $str_length    = 0;\n            my $engineering   = 0;\n            my $is_decimal    = 0;\n            my $is_integer    = 0;\n            my $after_decimal = undef;\n\n            for my $token ( split //, $number_format ) {\n                if ( $token eq '.' ) {\n                    $str_length++;\n                    $is_decimal = 1;\n                }\n                elsif ( ( $token eq 'E' ) || ( $token eq 'e' ) ) {\n                    $engineering = 1;\n                }\n                elsif ( $token eq '0' ) {\n                    $str_length++;\n                    $after_decimal++ if $is_decimal;\n                    $is_integer = 1;\n                }\n                elsif ( $token eq '#' ) {\n                    $after_decimal++ if $is_decimal;\n                    $is_integer = 1;\n                }\n                elsif ( $token eq '?' ) {\n                    $after_decimal++ if $is_decimal;\n                }\n            }\n\n            $number *= 100.0 if $is_percent;\n\n            my $data = ($is_currency) ? abs($number) : $number + 0;\n\n            if ($is_fraction) {\n                $number_result = sprintf( \"%0${str_length}d\", int($data) );\n            }\n            else {\n                if ($is_decimal) {\n\n                    if ( defined $after_decimal ) {\n                        $number_result =\n                          sprintf \"%0${str_length}.${after_decimal}f\", $data;\n                    }\n                    else {\n                        $number_result = sprintf \"%0${str_length}f\", $data;\n                    }\n\n                    # Fix for Perl and sprintf not rounding up like Excel.\n                    # http://rt.cpan.org/Public/Bug/Display.html?id=45626\n                    if ( $data =~ /^${number_result}5/ ) {\n                        $number_result =\n                          sprintf \"%0${str_length}.${after_decimal}f\",\n                          $data . '1';\n                    }\n                }\n                else {\n                    $number_result = sprintf( \"%0${str_length}.0f\", $data );\n                }\n            }\n\n            $number_result = AddComma($number_result) if $comma_count > 0;\n\n            my $number_length = length($number_result);\n            my $decimal_pos   = -1;\n            my $replacement;\n\n            for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {\n                my $placeholder = $placeholders[$i];\n\n                if ( $placeholder->[0] =~\n                    /([#0]*)([\\.]?)([0#]*)([eE])([\\+\\-])([0#]+)/ )\n                {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        MakeE( $placeholder->[0], $number ) );\n                }\n                elsif ( $placeholder->[0] =~ /\\// ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        MakeFraction( $placeholder->[0], $number, $is_integer )\n                    );\n                }\n                elsif ( $placeholder->[0] eq '.' ) {\n                    $number_length--;\n                    $decimal_pos = $number_length;\n                }\n                elsif ( $placeholder->[0] eq '+' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        ( $number > 0 )\n                        ? '+'\n                        : ( ( $number == 0 ) ? '+' : '-' ) );\n                }\n                elsif ( $placeholder->[0] eq '-' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        ( $number > 0 )\n                        ? ''\n                        : ( ( $number == 0 ) ? '' : '-' ) );\n                }\n                elsif ( $placeholder->[0] eq '@' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        $number );\n                }\n                elsif ( $placeholder->[0] eq '*' ) {\n                    substr( $result, $placeholder->[1], $placeholder->[2], '' );\n                }\n                elsif (( $placeholder->[0] eq \"\\xA2\\xA4\" )\n                    or ( $placeholder->[0] eq \"\\xA2\\xA5\" )\n                    or ( $placeholder->[0] eq \"\\x81\\xA2\" )\n                    or ( $placeholder->[0] eq \"\\x81\\xA3\" ) )\n                {\n                    substr(\n                        $result,           $placeholder->[1],\n                        $placeholder->[2], $placeholder->[0]\n                    );\n                }\n                elsif (( $placeholder->[0] eq '(' )\n                    or ( $placeholder->[0] eq ')' ) )\n                {\n                    substr(\n                        $result,           $placeholder->[1],\n                        $placeholder->[2], $placeholder->[0]\n                    );\n                }\n                else {\n                    if ( $number_length > 0 ) {\n                        if ( $i <= 0 ) {\n                            $replacement =\n                              substr( $number_result, 0, $number_length );\n                            $number_length = 0;\n                        }\n                        else {\n                            my $real_part_length = length( $placeholder->[0] );\n                            if ( $decimal_pos >= 0 ) {\n                                my $format = $placeholder->[0];\n                                $format =~ s/^#+//;\n                                $real_part_length = length $format;\n                                $real_part_length =\n                                  ( $number_length <= $real_part_length )\n                                  ? $number_length\n                                  : $real_part_length;\n                            }\n                            else {\n                                $real_part_length =\n                                  ( $number_length <= $real_part_length )\n                                  ? $number_length\n                                  : $real_part_length;\n                            }\n                            $replacement =\n                              substr( $number_result,\n                                $number_length - $real_part_length,\n                                $real_part_length );\n                            $number_length -= $real_part_length;\n                        }\n                    }\n                    else {\n                        $replacement = '';\n                    }\n                    substr( $result, $placeholder->[1], $placeholder->[2],\n                        \"\\x00\" . $replacement );\n                }\n            }\n            $replacement =\n              ( $number_length > 0 )\n              ? substr( $number_result, 0, $number_length )\n              : '';\n            $result =~ s/\\x00/$replacement/;\n            $result =~ s/\\x00//g;\n        }\n    }\n    else {\n\n        # Process text formats\n        my $is_text = 0;\n        for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {\n            my $placeholder = $placeholders[$i];\n            if ( $placeholder->[0] eq '@' ) {\n                substr( $result, $placeholder->[1], $placeholder->[2],\n                    $number );\n                $is_text++;\n            }\n            else {\n                substr( $result, $placeholder->[1], $placeholder->[2], '' );\n            }\n        }\n\n        $result = $number unless $is_text;\n\n    }    # End of placeholder substitutions.\n\n    # Trim the leading and trailing whitespace from the results.\n    $result =~ s/^\\s+//;\n    $result =~ s/\\s+$//;\n\n    # Fix for negative currency.\n    $result =~ s/^\\$\\-/\\-\\$/;\n    $result =~ s/^\\$ \\-/\\-\\$ /;\n\n    # Return color and locale strings if required.\n    if ($want_subformats) {\n        return ( $result, $color, $locale );\n    }\n    else {\n        return $result;\n    }\n}\n\n#------------------------------------------------------------------------------\n# AddComma (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub AddComma {\n    my ($sNum) = @_;\n\n    if ( $sNum =~ /^([^\\d]*)(\\d\\d\\d\\d+)(\\.*.*)$/ ) {\n        my ( $sPre, $sObj, $sAft ) = ( $1, $2, $3 );\n        for ( my $i = length($sObj) - 3 ; $i > 0 ; $i -= 3 ) {\n            substr( $sObj, $i, 0, ',' );\n        }\n        return $sPre . $sObj . $sAft;\n    }\n    else {\n        return $sNum;\n    }\n}\n\n#------------------------------------------------------------------------------\n# MakeFraction (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub MakeFraction {\n    my ( $sFmt, $iData, $iFlg ) = @_;\n    my $iBunbo;\n    my $iShou;\n\n    #1. Init\n    # print \"FLG: $iFlg\\n\";\n    if ($iFlg) {\n        $iShou = $iData - int($iData);\n        return '' if ( $iShou == 0 );\n    }\n    else {\n        $iShou = $iData;\n    }\n    $iShou = abs($iShou);\n    my $sSWk;\n\n    #2.Calc BUNBO\n    #2.1 BUNBO defined\n    if ( $sFmt =~ /\\/(\\d+)$/ ) {\n        $iBunbo = $1;\n        return sprintf( \"%d/%d\", $iShou * $iBunbo, $iBunbo );\n    }\n    else {\n\n        #2.2 Calc BUNBO\n        $sFmt =~ /\\/(\\?+)$/;\n        my $iKeta = length($1);\n        my $iSWk  = 1;\n        my $sSWk  = '';\n        my $iBunsi;\n        for ( my $iBunbo = 2 ; $iBunbo < 10**$iKeta ; $iBunbo++ ) {\n            $iBunsi = int( $iShou * $iBunbo + 0.5 );\n            my $iCmp = abs( $iShou - ( $iBunsi / $iBunbo ) );\n            if ( $iCmp < $iSWk ) {\n                $iSWk = $iCmp;\n                $sSWk = sprintf( \"%d/%d\", $iBunsi, $iBunbo );\n                last if ( $iSWk == 0 );\n            }\n        }\n        return $sSWk;\n    }\n}\n\n#------------------------------------------------------------------------------\n# MakeE (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub MakeE {\n    my ( $sFmt, $iData ) = @_;\n\n    $sFmt =~ /(([#0]*)[\\.]?[#0]*)([eE])([\\+\\-][0#]+)/;\n    my ( $sKari, $iKeta, $sE, $sSisu ) = ( $1, length($2), $3, $4 );\n    $iKeta = 1 if ( $iKeta <= 0 );\n\n    my $iLog10 = 0;\n    $iLog10 = ( $iData == 0 ) ? 0 : ( log( abs($iData) ) / log(10) );\n    $iLog10 = (\n        int( $iLog10 / $iKeta ) +\n          ( ( ( $iLog10 - int( $iLog10 / $iKeta ) ) < 0 ) ? -1 : 0 ) ) * $iKeta;\n\n    my $sUe = ExcelFmt( $sKari, $iData * ( 10**( $iLog10 * -1 ) ), 0 );\n    my $sShita = ExcelFmt( $sSisu, $iLog10, 0 );\n    return $sUe . $sE . $sShita;\n}\n\n#------------------------------------------------------------------------------\n# LeapYear (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub LeapYear {\n    my ($iYear) = @_;\n    return 1 if ( $iYear == 1900 );    #Special for Excel\n    return ( ( ( $iYear % 4 ) == 0 )\n          && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) )\n      ? 1\n      : 0;\n}\n\n#------------------------------------------------------------------------------\n# LocaltimeExcel (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub LocaltimeExcel {\n    my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec, $flg1904 )\n      = @_;\n\n    #0. Init\n    $iMon++;\n    $iYear += 1900;\n\n    #1. Calc Time\n    my $iTime;\n    $iTime = $iHour;\n    $iTime *= 60;\n    $iTime += $iMin;\n    $iTime *= 60;\n    $iTime += $iSec;\n    $iTime += $iMSec / 1000.0 if ( defined($iMSec) );\n    $iTime /= 86400.0;    #3600*24(1day in seconds)\n    my $iY;\n    my $iYDays;\n\n    #2. Calc Days\n    if ($flg1904) {\n        $iY = 1904;\n        $iTime--;         #Start from Jan 1st\n        $iYDays = 366;\n    }\n    else {\n        $iY     = 1900;\n        $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)\n    }\n    while ( $iY < $iYear ) {\n        $iTime += $iYDays;\n        $iY++;\n        $iYDays = ( LeapYear($iY) ) ? 366 : 365;\n    }\n    for ( my $iM = 1 ; $iM < $iMon ; $iM++ ) {\n        if (   $iM == 1\n            || $iM == 3\n            || $iM == 5\n            || $iM == 7\n            || $iM == 8\n            || $iM == 10\n            || $iM == 12 )\n        {\n            $iTime += 31;\n        }\n        elsif ( $iM == 4 || $iM == 6 || $iM == 9 || $iM == 11 ) {\n            $iTime += 30;\n        }\n        elsif ( $iM == 2 ) {\n            $iTime += ( LeapYear($iYear) ) ? 29 : 28;\n        }\n    }\n    $iTime += $iDay;\n    return $iTime;\n}\n\nmy @month_days = qw(\n  0 31 28 31 30 31 30 31 31 30 31 30 31\n);\n\n#------------------------------------------------------------------------------\n# ExcelLocaltime (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\nsub ExcelLocaltime {\n\n    my ( $dObj, $flg1904 ) = @_;\n    my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );\n    my ( $iDt, $iTime, $iYDays, $iMD );\n\n    $iDt   = int($dObj);\n    $iTime = $dObj - $iDt;\n\n    #1. Calc Days\n    if ($flg1904) {\n        $iYear = 1904;\n        $iDt++;    #Start from Jan 1st\n        $iYDays = 366;\n        $iwDay = ( ( $iDt + 4 ) % 7 );\n    }\n    else {\n        $iYear  = 1900;\n        $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)\n        $iwDay = ( ( $iDt + 6 ) % 7 );\n    }\n    while ( $iDt > $iYDays ) {\n        $iDt -= $iYDays;\n        $iYear++;\n        $iYDays =\n          (      ( ( $iYear % 4 ) == 0 )\n              && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) ) ? 366 : 365;\n    }\n    $iYear -= 1900;       # Localtime year is relative to 1900.\n\n    for ( $iMon = 1 ; $iMon <= 12 ; $iMon++ ) {\n        $iMD = $month_days[$iMon];\n        $iMD++ if $iMon == 2 and $iYear % 4 == 0;\n\n        last if ( $iDt <= $iMD );\n        $iDt -= $iMD;\n    }\n\n    #2. Calc Time\n    $iDay = $iDt;\n    $iTime += ( 0.0005 / 86400.0 );\n    if ($iTime >= 1.0)\n    {\n        $iTime -= int($iTime);\n        $iwDay = ($iwDay == 6) ? 0 : $iwDay + 1;\n        if ($iDay == $iMD)\n        {\n            if ($iMon == 12)\n            {\n                $iMon = 1;\n                $iYear++;\n            }\n            else\n            {\n                $iMon++;\n            }\n            $iDay = 1;\n        }\n        else\n        {\n            $iDay++;\n        }\n    }\n\n    # Localtime month is 0 based.\n    $iMon  -= 1;\n    $iTime *= 24.0;\n    $iHour = int($iTime);\n    $iTime -= $iHour;\n    $iTime *= 60.0;\n    $iMin = int($iTime);\n    $iTime -= $iMin;\n    $iTime *= 60.0;\n    $iSec = int($iTime);\n    $iTime -= $iSec;\n    $iTime *= 1000.0;\n    $iMSec = int($iTime);\n\n    return ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );\n}\n\n# -----------------------------------------------------------------------------\n# col2int (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n# converts a excel row letter into an int for use in an array\nsub col2int {\n    my $result = 0;\n    my $str    = shift;\n    my $incr   = 0;\n\n    for ( my $i = length($str) ; $i > 0 ; $i-- ) {\n        my $char = substr( $str, $i - 1 );\n        my $curr += ord( lc($char) ) - ord('a') + 1;\n        $curr *= $incr if ($incr);\n        $result += $curr;\n        $incr   += 26;\n    }\n\n    # this is one out as we range 0..x-1 not 1..x\n    $result--;\n\n    return $result;\n}\n\n# -----------------------------------------------------------------------------\n# int2col (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n### int2col\n# convert a column number into column letters\n# @note this is quite a brute force coarse method\n#   does not manage values over 701 (ZZ)\n# @arg number, to convert\n# @returns string, column name\n#\nsub int2col {\n    my $out = \"\";\n    my $val = shift;\n\n    do {\n        $out .= chr( ( $val % 26 ) + ord('A') );\n        $val = int( $val / 26 ) - 1;\n    } while ( $val >= 0 );\n\n    return scalar reverse $out;\n}\n\n# -----------------------------------------------------------------------------\n# sheetRef (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n### sheetRef\n# convert an excel letter-number address into a useful array address\n# @note that also Excel uses X-Y notation, we normally use Y-X in arrays\n# @args $str, excel coord eg. A2\n# @returns an array - 2 elements - column, row, or undefined\n#\nsub sheetRef {\n    my $str = shift;\n    my @ret;\n\n    $str =~ m/^(\\D+)(\\d+)$/;\n\n    if ( $1 && $2 ) {\n        push( @ret, $2 - 1, col2int($1) );\n    }\n    if ( $ret[0] < 0 ) {\n        undef @ret;\n    }\n\n    return @ret;\n}\n\n# -----------------------------------------------------------------------------\n# xls2csv (for Spreadsheet::ParseExcel::Utility)\n#------------------------------------------------------------------------------\n### xls2csv\n# convert a chunk of an excel file into csv text chunk\n# @args $param, sheet-colrow:colrow (1-A1:B2 or A1:B2 for sheet 1\n# @args $rotate, 0 or 1 decides if output should be rotated or not\n# @returns string containing a chunk of csv\n#\nsub xls2csv {\n    my ( $filename, $regions, $rotate ) = @_;\n    my $sheet = 0;\n\n    # We need Text::CSV_XS for proper CSV handling.\n    require Text::CSV_XS;\n\n    # extract any sheet number from the region string\n    $regions =~ m/^(\\d+)-(.*)/;\n\n    if ($2) {\n        $sheet   = $1 - 1;\n        $regions = $2;\n    }\n\n    # now extract the start and end regions\n    $regions =~ m/(.*):(.*)/;\n\n    if ( !$1 || !$2 ) {\n        print STDERR \"Bad Params\";\n        return \"\";\n    }\n\n    my @start = sheetRef($1);\n    my @end   = sheetRef($2);\n    if ( !@start ) {\n        print STDERR \"Bad coorinates - $1\";\n        return \"\";\n    }\n    if ( !@end ) {\n        print STDERR \"Bad coorinates - $2\";\n        return \"\";\n    }\n\n    if ( $start[1] > $end[1] ) {\n        print STDERR \"Bad COLUMN ordering\\n\";\n        print STDERR \"Start column \" . int2col( $start[1] );\n        print STDERR \" after end column \" . int2col( $end[1] ) . \"\\n\";\n        return \"\";\n    }\n    if ( $start[0] > $end[0] ) {\n        print STDERR \"Bad ROW ordering\\n\";\n        print STDERR \"Start row \" . ( $start[0] + 1 );\n        print STDERR \" after end row \" . ( $end[0] + 1 ) . \"\\n\";\n        exit;\n    }\n\n    # start the excel object now\n    my $oExcel = new Spreadsheet::ParseExcel;\n    my $oBook  = $oExcel->Parse($filename);\n\n    # open the sheet\n    my $oWkS = $oBook->{Worksheet}[$sheet];\n\n    # now check that the region exists in the file\n    # if not truncate to the possible region\n    # output a warning msg\n    if ( $start[1] < $oWkS->{MinCol} ) {\n        print STDERR int2col( $start[1] )\n          . \" < min col \"\n          . int2col( $oWkS->{MinCol} )\n          . \" Resetting\\n\";\n        $start[1] = $oWkS->{MinCol};\n    }\n    if ( $end[1] > $oWkS->{MaxCol} ) {\n        print STDERR int2col( $end[1] )\n          . \" > max col \"\n          . int2col( $oWkS->{MaxCol} )\n          . \" Resetting\\n\";\n        $end[1] = $oWkS->{MaxCol};\n    }\n    if ( $start[0] < $oWkS->{MinRow} ) {\n        print STDERR \"\"\n          . ( $start[0] + 1 )\n          . \" < min row \"\n          . ( $oWkS->{MinRow} + 1 )\n          . \" Resetting\\n\";\n        $start[0] = $oWkS->{MinCol};\n    }\n    if ( $end[0] > $oWkS->{MaxRow} ) {\n        print STDERR \"\"\n          . ( $end[0] + 1 )\n          . \" > max row \"\n          . ( $oWkS->{MaxRow} + 1 )\n          . \" Resetting\\n\";\n        $end[0] = $oWkS->{MaxRow};\n\n    }\n\n    my $x1 = $start[1];\n    my $y1 = $start[0];\n    my $x2 = $end[1];\n    my $y2 = $end[0];\n\n    my @cell_data;\n    my $row = 0;\n\n    if ( !$rotate ) {\n        for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {\n            for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {\n                my $cell = $oWkS->{Cells}[$y][$x];\n\n                my $value;\n                if ( defined $cell ) {\n                    $value .= $cell->value();\n                }\n                else {\n                    $value = '';\n                }\n\n                push @{ $cell_data[$row] }, $value;\n            }\n            $row++;\n        }\n    }\n    else {\n        for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {\n            for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {\n                my $cell = $oWkS->{Cells}[$y][$x];\n\n                my $value;\n                if ( defined $cell ) {\n                    $value .= $cell->value();\n                }\n                else {\n                    $value = '';\n                }\n\n                push @{ $cell_data[$row] }, $value;\n            }\n            $row++;\n        }\n    }\n\n    # Create the CSV output string.\n    my $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );\n    my $output = \"\";\n\n    for my $row (@cell_data) {\n        $csv->combine(@$row);\n        $output .= $csv->string();\n    }\n\n    return $output;\n}\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nSpreadsheet::ParseExcel::Utility - Utility functions for Spreadsheet::ParseExcel.\n\n=head1 SYNOPSIS\n\n    use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);\n\n    # Convert localtime to Excel time\n    my $datetime = LocaltimeExcel(11, 10, 12, 23, 2, 64); # 1964-3-23 12:10:11\n\n    print $datetime, \"\\n\"; # 23459.5070717593 (Excel date/time format)\n\n    # Convert Excel Time to localtime\n    my @time = ExcelLocaltime($datetime);\n    print join(\":\", @time), \"\\n\";   # 11:10:12:23:2:64:1:0\n\n    # Formatting\n    print ExcelFmt('yyyy-mm-dd', $datetime), \"\\n\"; # 1964-3-23\n    print ExcelFmt('m-d-yy',     $datetime), \"\\n\"; # 3-23-64\n    print ExcelFmt('#,##0',      $datetime), \"\\n\"; # 23,460\n    print ExcelFmt('#,##0.00',   $datetime), \"\\n\"; # 23,459.51\n\n=head1 DESCRIPTION\n\nThe C<Spreadsheet::ParseExcel::Utility> module provides utility functions for working with ParseExcel and Excel data.\n\n=head1 Functions\n\nC<Spreadsheet::ParseExcel::Utility> can export the following functions:\n\n    ExcelFmt\n    ExcelLocaltime\n    LocaltimeExcel\n    col2int\n    int2col\n    sheetRef\n    xls2csv\n\nThese functions must be imported implicitly:\n\n    # Just one function.\n    use Spreadsheet::ParseExcel::Utility 'col2int';\n\n    # More than one.\n    use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);\n\n\n=head2 ExcelFmt($format_string, $number, $is_1904)\n\nExcel stores data such as dates and currency values as numbers. The way these numbers are displayed is controlled by the number format string for the cell. For example a cell with a number format of C<'$#,##0.00'> for currency and a value of 1234.567 would be displayed as follows:\n\n    '$#,##0.00' + 1234.567 = '$1,234.57'.\n\nThe C<ExcelFmt()> function tries to emulate this formatting so that the user can convert raw numbers returned by C<Spreadsheet::ParseExel> to a desired format. For example:\n\n    print ExcelFmt('$#,##0.00', 1234.567); # $1,234.57.\n\nThe syntax of the function is:\n\n    my $text = ExcelFmt($format_string, $number, $is_1904);\n\nWhere C<$format_string> is an Excel number format string, C<$number> is a real or integer number and C<is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\nC<ExcelFmt()> is also used internally to convert numbers returned by the C<Cell::unformatted()> method to the formatted value returned by the C<Cell::value()> method:\n\n\n    my $cell = $worksheet->get_cell( 0, 0 );\n\n    print $cell->unformatted(), \"\\n\"; # 1234.567\n    print $cell->value(),       \"\\n\"; # $1,234.57\n\nThe most common usage for C<ExcelFmt> is to convert numbers to dates. Dates and times in Excel are represented by real numbers, for example \"1 Jan 2001 12:30 PM\" is represented by the number 36892.521. The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day. By applying an Excel number format the number is converted to the desired string representation:\n\n    print ExcelFmt('d mmm yyyy h:mm AM/PM', 36892.521);  # 1 Jan 2001 12:30 PM\n\nC<$is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch. Excel for Windows generally uses 1900 and Excel for Mac OS uses 1904. The C<$is1904> flag isn't required very often by a casual user and can usually be ignored.\n\n\n=head2 ExcelLocaltime($excel_datetime, $is_1904)\n\nThe C<ExcelLocaltime()> function converts from an Excel date/time number to a C<localtime()>-like array of values:\n\n        my @time = ExcelLocaltime($excel_datetime);\n\n        #    0     1     2      3     4       5      6      7\n        my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;\n\nThe array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. This means that you will usually need to do the following:\n\n        $month++;\n        $year += 1900;\n\nSee also Perl's documentation for L<localtime()|perlfunc>:\n\nThe C<$is_1904> flag is an optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\n=head2 LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec, $is_1904)\n\nThe C<LocaltimeExcel()> function converts from a C<localtime()>-like array of values to an Excel date/time number:\n\n    $excel_datetime = LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec);\n\nThe array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. See also Perl's documentation for L<localtime()|perlfunc>:\n\nThe C<$wday> and C<$msec> elements are usually optional. This time elements can also be zeroed if they aren't of interest:\n\n                                    # sec, min, hour, day, month, year\n    $excel_datetime = LocaltimeExcel( 0,   0,   0,    1,   0,     101 );\n\n    print ExcelFmt('d mmm yyyy', $excel_datetime);  # 1 Jan 2001\n\nThe C<$is_1904> flag is also optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.\n\n\n=head2 col2int($column)\n\nThe C<col2int()> function converts an Excel column letter to an zero-indexed column number:\n\n    print col2int('A');  # 0\n    print col2int('AA'); # 26\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 int2col($column_number)\n\nThe C<int2col()> function converts an zero-indexed Excel column number to a column letter:\n\n    print int2col(0);  # 'A'\n    print int2col(26); # 'AA'\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 sheetRef($cell_string)\n\nThe C<sheetRef()> function converts an Excel cell reference in 'A1' notation to a zero-indexed C<(row, col)> pair.\n\n    my ($row, $col) = sheetRef('A1'); # ( 0, 0 )\n    my ($row, $col) = sheetRef('C2'); # ( 1, 2 )\n\nThis function was contributed by Kevin Mulholland.\n\n\n=head2 xls2csv($filename, $region, $rotate)\n\nThe C<xls2csv()> function converts a section of an Excel file into a CSV text string.\n\n    $csv_text = xls2csv($filename, $region, $rotate);\n\nWhere:\n\n    $region = \"sheet-colrow:colrow\"\n    For example '1-A1:B2' means 'A1:B2' for sheet 1.\n\n    and\n\n    $rotate  = 0 or 1 (output is rotated/transposed or not)\n\nThis function requires C<Text::CSV_XS> to be installed. It was contributed by Kevin Mulholland along with the C<xls2csv> script in the C<sample> directory of the distro.\n\nSee also the following xls2csv utilities: Ken Prows' C<xls2csv>: http://search.cpan.org/~ken/xls2csv/script/xls2csv and H.Merijn Brand's C<xls2csv> (which is part of Spreadsheet::Read): http://search.cpan.org/~hmbrand/Spreadsheet-Read/\n\n\n=head1 AUTHOR\n\nCurrent maintainer 0.60+: Douglas Wilson dougw@cpan.org\n\nMaintainer 0.40-0.59: John McNamara jmcnamara@cpan.org\n\nMaintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org\n\nOriginal author: Kawai Takanori kwitknr@cpan.org\n\n=head1 COPYRIGHT\n\nCopyright (c) 2014 Douglas Wilson\n\nCopyright (c) 2009-2013 John McNamara\n\nCopyright (c) 2006-2008 Gabor Szabo\n\nCopyright (c) 2000-2006 Kawai Takanori\n\nAll rights reserved.\n\nYou may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.\n\n=cut\n"], "filenames": ["lib/Spreadsheet/ParseExcel/Utility.pm"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [175], "fixing_code_start_loc": [81], "fixing_code_end_loc": [188], "type": "CWE-94", "message": "Spreadsheet::ParseExcel version 0.65 is a Perl module used for parsing Excel files. Spreadsheet::ParseExcel is vulnerable to an arbitrary code execution (ACE) vulnerability due to passing unvalidated input from a file into a string-type \u201ceval\u201d. Specifically, the issue stems from the evaluation of Number format strings (not to be confused with printf-style format strings) within the Excel parsing logic. \n", "other": {"cve": {"id": "CVE-2023-7101", "sourceIdentifier": "mandiant-cve@google.com", "published": "2023-12-24T22:15:07.983", "lastModified": "2024-01-09T20:07:41.527", "vulnStatus": "Analyzed", "cisaExploitAdd": "2024-01-02", "cisaActionDue": "2024-01-23", "cisaRequiredAction": "Apply mitigations per vendor instructions or discontinue use of the product if mitigations are unavailable.", "cisaVulnerabilityName": "Spreadsheet::ParseExcel Remote Code Execution Vulnerability", "descriptions": [{"lang": "en", "value": "Spreadsheet::ParseExcel version 0.65 is a Perl module used for parsing Excel files. Spreadsheet::ParseExcel is vulnerable to an arbitrary code execution (ACE) vulnerability due to passing unvalidated input from a file into a string-type \u201ceval\u201d. Specifically, the issue stems from the evaluation of Number format strings (not to be confused with printf-style format strings) within the Excel parsing logic. \n"}, {"lang": "es", "value": "Spreadsheet::ParseExcel version 0.65 es un m\u00f3dulo Perl utilizado para analizar archivos Excel. Spreadsheet::ParseExcel es afectado por una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo arbitrario (ACE) debido a que se pasa una entrada no validada de un archivo a una \"evaluaci\u00f3n\" de tipo cadena. Espec\u00edficamente, el problema surge de la evaluaci\u00f3n de cadenas de formato num\u00e9rico (que no deben confundirse con cadenas de formato de estilo printf) dentro de la l\u00f3gica de an\u00e1lisis de Excel."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "mandiant-cve@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-95"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jmcnamara:spreadsheet\\:\\:parseexcel:*:*:*:*:*:perl:*:*", "versionEndIncluding": "0.65", "matchCriteriaId": "1C81AC37-3219-4A80-A89E-8BDC1E238F82"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/12/29/4", "source": "mandiant-cve@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/jmcnamara/spreadsheet-parseexcel/blob/c7298592e102a375d43150cd002feed806557c15/lib/Spreadsheet/ParseExcel/Utility.pm#L171", "source": "mandiant-cve@google.com", "tags": ["Product"]}, {"url": "https://github.com/mandiant/Vulnerability-Disclosures/blob/master/2023/MNDT-2023-0019.md", "source": "mandiant-cve@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://https://github.com/haile01/perl_spreadsheet_excel_rce_poc", "source": "mandiant-cve@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://https://github.com/jmcnamara/spreadsheet-parseexcel/commit/bd3159277e745468e2c553417b35d5d7dc7405bc", "source": "mandiant-cve@google.com", "tags": ["Patch"]}, {"url": "https://https://metacpan.org/dist/Spreadsheet-ParseExcel", "source": "mandiant-cve@google.com", "tags": ["Product"]}, {"url": "https://https://www.cve.org/CVERecord?id=CVE-2023-7101", "source": "mandiant-cve@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00025.html", "source": "mandiant-cve@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IFEHKULQRVXHIV7XXK2RGD4VQN6Y4CV5/", "source": "mandiant-cve@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M2FIWDHRYTAAQLGM6AFOZVM7AFZ4H2ZR/", "source": "mandiant-cve@google.com", "tags": ["Mailing List"]}]}, "github_commit_url": "https://https://github.com/jmcnamara/spreadsheet-parseexcel/commit/bd3159277e745468e2c553417b35d5d7dc7405bc"}}