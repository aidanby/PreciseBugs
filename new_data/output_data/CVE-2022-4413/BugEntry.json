{"buggy_code": ["import { createRenderer, renderResourceHeaders } from 'vue-bundle-renderer/runtime'\nimport type { RenderResponse } from 'nitropack'\nimport type { Manifest } from 'vite'\nimport { appendHeader, getQuery, writeEarlyHints } from 'h3'\nimport devalue from '@nuxt/devalue'\nimport { joinURL } from 'ufo'\nimport { renderToString as _renderToString } from 'vue/server-renderer'\nimport { useRuntimeConfig, useNitroApp, defineRenderHandler, getRouteRules } from '#internal/nitro'\n// eslint-disable-next-line import/no-restricted-paths\nimport type { NuxtApp, NuxtSSRContext } from '#app'\n\n// @ts-ignore\nimport { buildAssetsURL, publicAssetsURL } from '#paths'\n\n// @ts-ignore\nglobalThis.__buildAssetsURL = buildAssetsURL\n// @ts-ignore\nglobalThis.__publicAssetsURL = publicAssetsURL\n\nexport interface NuxtRenderHTMLContext {\n  htmlAttrs: string[]\n  head: string[]\n  bodyAttrs: string[]\n  bodyPreprend: string[]\n  body: string[]\n  bodyAppend: string[]\n}\n\nexport interface NuxtRenderResponse {\n  body: string,\n  statusCode: number,\n  statusMessage?: string,\n  headers: Record<string, string>\n}\n\ninterface ClientManifest {}\n\n// @ts-ignore\nconst getClientManifest: () => Promise<Manifest> = () => import('#build/dist/server/client.manifest.mjs')\n  .then(r => r.default || r)\n  .then(r => typeof r === 'function' ? r() : r) as Promise<ClientManifest>\n\n// @ts-ignore\nconst getServerEntry = () => import('#build/dist/server/server.mjs').then(r => r.default || r)\n\n// @ts-ignore\nconst getSSRStyles = (): Promise<Record<string, () => Promise<string[]>>> => import('#build/dist/server/styles.mjs').then(r => r.default || r)\n\n// -- SSR Renderer --\nconst getSSRRenderer = lazyCachedFunction(async () => {\n  // Load client manifest\n  const manifest = await getClientManifest()\n  if (!manifest) { throw new Error('client.manifest is not available') }\n\n  // Load server bundle\n  const createSSRApp = await getServerEntry()\n  if (!createSSRApp) { throw new Error('Server bundle is not available') }\n\n  const options = {\n    manifest,\n    renderToString,\n    buildAssetsURL\n  }\n  // Create renderer\n  const renderer = createRenderer(createSSRApp, options)\n\n  type RenderToStringParams = Parameters<typeof _renderToString>\n  async function renderToString (input: RenderToStringParams[0], context: RenderToStringParams[1]) {\n    const html = await _renderToString(input, context)\n    // In development with vite-node, the manifest is on-demand and will be available after rendering\n    if (process.dev && process.env.NUXT_VITE_NODE_OPTIONS) {\n      renderer.rendererContext.updateManifest(await getClientManifest())\n    }\n    return `<div id=\"__nuxt\">${html}</div>`\n  }\n\n  return renderer\n})\n\n// -- SPA Renderer --\nconst getSPARenderer = lazyCachedFunction(async () => {\n  const manifest = await getClientManifest()\n\n  const options = {\n    manifest,\n    renderToString: () => '<div id=\"__nuxt\"></div>',\n    buildAssetsURL\n  }\n  // Create SPA renderer and cache the result for all requests\n  const renderer = createRenderer(() => () => {}, options)\n  const result = await renderer.renderToString({})\n\n  const renderToString = (ssrContext: NuxtSSRContext) => {\n    const config = useRuntimeConfig()\n    ssrContext!.payload = {\n      serverRendered: false,\n      config: {\n        public: config.public,\n        app: config.app\n      },\n      data: {},\n      state: {}\n    }\n    ssrContext!.renderMeta = ssrContext!.renderMeta ?? (() => ({}))\n    return Promise.resolve(result)\n  }\n\n  return {\n    rendererContext: renderer.rendererContext,\n    renderToString\n  }\n})\n\nconst PAYLOAD_CACHE = (process.env.NUXT_PAYLOAD_EXTRACTION && process.env.prerender) ? new Map() : null // TODO: Use LRU cache\nconst PAYLOAD_URL_RE = /\\/_payload(\\.[a-zA-Z0-9]+)?.js(\\?.*)?$/\n\nconst PRERENDER_NO_SSR_ROUTES = new Set(['/index.html', '/200.html', '/404.html'])\n\nexport default defineRenderHandler(async (event) => {\n  // Whether we're rendering an error page\n  const ssrError = event.req.url?.startsWith('/__nuxt_error')\n    ? getQuery(event) as Exclude<NuxtApp['payload']['error'], Error>\n    : null\n  let url = ssrError?.url as string || event.req.url!\n\n  // Whether we are rendering payload route\n  const isRenderingPayload = PAYLOAD_URL_RE.test(url)\n  if (isRenderingPayload) {\n    url = url.substring(0, url.lastIndexOf('/')) || '/'\n    event.req.url = url\n    if (process.env.prerender && PAYLOAD_CACHE!.has(url)) {\n      return PAYLOAD_CACHE!.get(url)\n    }\n  }\n\n  // Get route options (currently to apply `ssr: false`)\n  const routeOptions = getRouteRules(event)\n\n  // Initialize ssr context\n  const ssrContext: NuxtSSRContext = {\n    url,\n    event,\n    runtimeConfig: useRuntimeConfig() as NuxtSSRContext['runtimeConfig'],\n    noSSR:\n      !!(process.env.NUXT_NO_SSR) ||\n      !!(event.req.headers['x-nuxt-no-ssr']) ||\n      routeOptions.ssr === false ||\n      (process.env.prerender ? PRERENDER_NO_SSR_ROUTES.has(url) : false),\n    error: !!ssrError,\n    nuxt: undefined!, /* NuxtApp */\n    payload: (ssrError ? { error: ssrError } : {}) as NuxtSSRContext['payload']\n  }\n\n  // Whether we are prerendering route\n  const _PAYLOAD_EXTRACTION = process.env.prerender && process.env.NUXT_PAYLOAD_EXTRACTION && !ssrContext.noSSR\n  const payloadURL = _PAYLOAD_EXTRACTION ? joinURL(useRuntimeConfig().app.baseURL, url, '_payload.js') : undefined\n  if (process.env.prerender) {\n    ssrContext.payload.prerenderedAt = Date.now()\n  }\n\n  // Render app\n  const renderer = (process.env.NUXT_NO_SSR || ssrContext.noSSR) ? await getSPARenderer() : await getSSRRenderer()\n\n  // Render 103 Early Hints\n  if (process.env.NUXT_EARLY_HINTS && !isRenderingPayload && !process.env.prerender) {\n    const { link } = renderResourceHeaders({}, renderer.rendererContext)\n    writeEarlyHints(event, link)\n  }\n\n  const _rendered = await renderer.renderToString(ssrContext).catch((err) => {\n    if (!ssrError) {\n      // Use explicitly thrown error in preference to subsequent rendering errors\n      throw ssrContext.payload?.error || err\n    }\n  })\n  await ssrContext.nuxt?.hooks.callHook('app:rendered', { ssrContext })\n\n  // Handle errors\n  if (!_rendered) {\n    return undefined!\n  }\n  if (ssrContext.payload?.error && !ssrError) {\n    throw ssrContext.payload.error\n  }\n\n  // Directly render payload routes\n  if (isRenderingPayload) {\n    const response = renderPayloadResponse(ssrContext)\n    if (process.env.prerender) {\n      PAYLOAD_CACHE!.set(url, response)\n    }\n    return response\n  }\n\n  if (_PAYLOAD_EXTRACTION) {\n    // Hint nitro to prerender payload for this route\n    appendHeader(event, 'x-nitro-prerender', joinURL(url, '_payload.js'))\n    // Use same ssr context to generate payload for this route\n    PAYLOAD_CACHE!.set(url, renderPayloadResponse(ssrContext))\n  }\n\n  // Render meta\n  const renderedMeta = await ssrContext.renderMeta?.() ?? {}\n\n  // Render inline styles\n  const inlinedStyles = process.env.NUXT_INLINE_STYLES\n    ? await renderInlineStyles(ssrContext.modules ?? ssrContext._registeredComponents ?? [])\n    : ''\n\n  // Create render context\n  const htmlContext: NuxtRenderHTMLContext = {\n    htmlAttrs: normalizeChunks([renderedMeta.htmlAttrs]),\n    head: normalizeChunks([\n      renderedMeta.headTags,\n      _PAYLOAD_EXTRACTION ? `<link rel=\"modulepreload\" href=\"${payloadURL}\">` : null,\n      _rendered.renderResourceHints(),\n      _rendered.renderStyles(),\n      inlinedStyles,\n      ssrContext.styles\n    ]),\n    bodyAttrs: normalizeChunks([renderedMeta.bodyAttrs!]),\n    bodyPreprend: normalizeChunks([\n      renderedMeta.bodyScriptsPrepend,\n      ssrContext.teleports?.body\n    ]),\n    body: [\n      // TODO: Rename to _rendered.body in next vue-bundle-renderer\n      _rendered.html\n    ],\n    bodyAppend: normalizeChunks([\n      process.env.NUXT_NO_SCRIPTS\n        ? undefined\n        : (_PAYLOAD_EXTRACTION\n            ? `<script type=\"module\">import p from \"${payloadURL}\";window.__NUXT__={...p,...(${devalue(splitPayload(ssrContext).initial)})}</script>`\n            : `<script>window.__NUXT__=${devalue(ssrContext.payload)}</script>`\n          ),\n      _rendered.renderScripts(),\n      // Note: bodyScripts may contain tags other than <script>\n      renderedMeta.bodyScripts\n    ])\n  }\n\n  // Allow hooking into the rendered result\n  const nitroApp = useNitroApp()\n  await nitroApp.hooks.callHook('render:html', htmlContext, { event })\n\n  // Construct HTML response\n  const response: RenderResponse = {\n    body: renderHTMLDocument(htmlContext),\n    statusCode: event.res.statusCode,\n    statusMessage: event.res.statusMessage,\n    headers: {\n      'Content-Type': 'text/html;charset=UTF-8',\n      'X-Powered-By': 'Nuxt'\n    }\n  }\n\n  return response\n})\n\nfunction lazyCachedFunction <T> (fn: () => Promise<T>): () => Promise<T> {\n  let res: Promise<T> | null = null\n  return () => {\n    if (res === null) {\n      res = fn().catch((err) => { res = null; throw err })\n    }\n    return res\n  }\n}\n\nfunction normalizeChunks (chunks: (string | undefined)[]) {\n  return chunks.filter(Boolean).map(i => i!.trim())\n}\n\nfunction joinTags (tags: string[]) {\n  return tags.join('')\n}\n\nfunction joinAttrs (chunks: string[]) {\n  return chunks.join(' ')\n}\n\nfunction renderHTMLDocument (html: NuxtRenderHTMLContext) {\n  return `<!DOCTYPE html>\n<html ${joinAttrs(html.htmlAttrs)}>\n<head>${joinTags(html.head)}</head>\n<body ${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPreprend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body>\n</html>`\n}\n\nasync function renderInlineStyles (usedModules: Set<string> | string[]) {\n  const styleMap = await getSSRStyles()\n  const inlinedStyles = new Set<string>()\n  for (const mod of usedModules) {\n    if (mod in styleMap) {\n      for (const style of await styleMap[mod]()) {\n        inlinedStyles.add(`<style>${style}</style>`)\n      }\n    }\n  }\n  return Array.from(inlinedStyles).join('')\n}\n\nfunction renderPayloadResponse (ssrContext: NuxtSSRContext) {\n  return <RenderResponse> {\n    body: `export default ${devalue(splitPayload(ssrContext).payload)}`,\n    statusCode: ssrContext.event.res.statusCode,\n    statusMessage: ssrContext.event.res.statusMessage,\n    headers: {\n      'content-type': 'text/javascript;charset=UTF-8',\n      'x-powered-by': 'Nuxt'\n    }\n  }\n}\n\nfunction splitPayload (ssrContext: NuxtSSRContext) {\n  const { data, prerenderedAt, ...initial } = ssrContext.payload\n  return {\n    initial: { ...initial, prerenderedAt },\n    payload: { data, prerenderedAt }\n  }\n}\n"], "fixing_code": ["import { createRenderer, renderResourceHeaders } from 'vue-bundle-renderer/runtime'\nimport type { RenderResponse } from 'nitropack'\nimport type { Manifest } from 'vite'\nimport { appendHeader, createError, getQuery, writeEarlyHints } from 'h3'\nimport devalue from '@nuxt/devalue'\nimport { joinURL } from 'ufo'\nimport { renderToString as _renderToString } from 'vue/server-renderer'\nimport { useRuntimeConfig, useNitroApp, defineRenderHandler, getRouteRules } from '#internal/nitro'\n// eslint-disable-next-line import/no-restricted-paths\nimport type { NuxtApp, NuxtSSRContext } from '#app'\n\n// @ts-ignore\nimport { buildAssetsURL, publicAssetsURL } from '#paths'\n\n// @ts-ignore\nglobalThis.__buildAssetsURL = buildAssetsURL\n// @ts-ignore\nglobalThis.__publicAssetsURL = publicAssetsURL\n\nexport interface NuxtRenderHTMLContext {\n  htmlAttrs: string[]\n  head: string[]\n  bodyAttrs: string[]\n  bodyPreprend: string[]\n  body: string[]\n  bodyAppend: string[]\n}\n\nexport interface NuxtRenderResponse {\n  body: string,\n  statusCode: number,\n  statusMessage?: string,\n  headers: Record<string, string>\n}\n\ninterface ClientManifest {}\n\n// @ts-ignore\nconst getClientManifest: () => Promise<Manifest> = () => import('#build/dist/server/client.manifest.mjs')\n  .then(r => r.default || r)\n  .then(r => typeof r === 'function' ? r() : r) as Promise<ClientManifest>\n\n// @ts-ignore\nconst getServerEntry = () => import('#build/dist/server/server.mjs').then(r => r.default || r)\n\n// @ts-ignore\nconst getSSRStyles = (): Promise<Record<string, () => Promise<string[]>>> => import('#build/dist/server/styles.mjs').then(r => r.default || r)\n\n// -- SSR Renderer --\nconst getSSRRenderer = lazyCachedFunction(async () => {\n  // Load client manifest\n  const manifest = await getClientManifest()\n  if (!manifest) { throw new Error('client.manifest is not available') }\n\n  // Load server bundle\n  const createSSRApp = await getServerEntry()\n  if (!createSSRApp) { throw new Error('Server bundle is not available') }\n\n  const options = {\n    manifest,\n    renderToString,\n    buildAssetsURL\n  }\n  // Create renderer\n  const renderer = createRenderer(createSSRApp, options)\n\n  type RenderToStringParams = Parameters<typeof _renderToString>\n  async function renderToString (input: RenderToStringParams[0], context: RenderToStringParams[1]) {\n    const html = await _renderToString(input, context)\n    // In development with vite-node, the manifest is on-demand and will be available after rendering\n    if (process.dev && process.env.NUXT_VITE_NODE_OPTIONS) {\n      renderer.rendererContext.updateManifest(await getClientManifest())\n    }\n    return `<div id=\"__nuxt\">${html}</div>`\n  }\n\n  return renderer\n})\n\n// -- SPA Renderer --\nconst getSPARenderer = lazyCachedFunction(async () => {\n  const manifest = await getClientManifest()\n\n  const options = {\n    manifest,\n    renderToString: () => '<div id=\"__nuxt\"></div>',\n    buildAssetsURL\n  }\n  // Create SPA renderer and cache the result for all requests\n  const renderer = createRenderer(() => () => {}, options)\n  const result = await renderer.renderToString({})\n\n  const renderToString = (ssrContext: NuxtSSRContext) => {\n    const config = useRuntimeConfig()\n    ssrContext!.payload = {\n      serverRendered: false,\n      config: {\n        public: config.public,\n        app: config.app\n      },\n      data: {},\n      state: {}\n    }\n    ssrContext!.renderMeta = ssrContext!.renderMeta ?? (() => ({}))\n    return Promise.resolve(result)\n  }\n\n  return {\n    rendererContext: renderer.rendererContext,\n    renderToString\n  }\n})\n\nconst PAYLOAD_CACHE = (process.env.NUXT_PAYLOAD_EXTRACTION && process.env.prerender) ? new Map() : null // TODO: Use LRU cache\nconst PAYLOAD_URL_RE = /\\/_payload(\\.[a-zA-Z0-9]+)?.js(\\?.*)?$/\n\nconst PRERENDER_NO_SSR_ROUTES = new Set(['/index.html', '/200.html', '/404.html'])\n\nexport default defineRenderHandler(async (event) => {\n  // Whether we're rendering an error page\n  const ssrError = event.req.url?.startsWith('/__nuxt_error')\n    ? getQuery(event) as Exclude<NuxtApp['payload']['error'], Error>\n    : null\n  if (ssrError && event.req.socket.readyState !== 'readOnly' /* direct request */) {\n    throw createError('Cannot directly render error page!')\n  }\n\n  let url = ssrError?.url as string || event.req.url!\n\n  // Whether we are rendering payload route\n  const isRenderingPayload = PAYLOAD_URL_RE.test(url)\n  if (isRenderingPayload) {\n    url = url.substring(0, url.lastIndexOf('/')) || '/'\n    event.req.url = url\n    if (process.env.prerender && PAYLOAD_CACHE!.has(url)) {\n      return PAYLOAD_CACHE!.get(url)\n    }\n  }\n\n  // Get route options (currently to apply `ssr: false`)\n  const routeOptions = getRouteRules(event)\n\n  // Initialize ssr context\n  const ssrContext: NuxtSSRContext = {\n    url,\n    event,\n    runtimeConfig: useRuntimeConfig() as NuxtSSRContext['runtimeConfig'],\n    noSSR:\n      !!(process.env.NUXT_NO_SSR) ||\n      !!(event.req.headers['x-nuxt-no-ssr']) ||\n      routeOptions.ssr === false ||\n      (process.env.prerender ? PRERENDER_NO_SSR_ROUTES.has(url) : false),\n    error: !!ssrError,\n    nuxt: undefined!, /* NuxtApp */\n    payload: (ssrError ? { error: ssrError } : {}) as NuxtSSRContext['payload']\n  }\n\n  // Whether we are prerendering route\n  const _PAYLOAD_EXTRACTION = process.env.prerender && process.env.NUXT_PAYLOAD_EXTRACTION && !ssrContext.noSSR\n  const payloadURL = _PAYLOAD_EXTRACTION ? joinURL(useRuntimeConfig().app.baseURL, url, '_payload.js') : undefined\n  if (process.env.prerender) {\n    ssrContext.payload.prerenderedAt = Date.now()\n  }\n\n  // Render app\n  const renderer = (process.env.NUXT_NO_SSR || ssrContext.noSSR) ? await getSPARenderer() : await getSSRRenderer()\n\n  // Render 103 Early Hints\n  if (process.env.NUXT_EARLY_HINTS && !isRenderingPayload && !process.env.prerender) {\n    const { link } = renderResourceHeaders({}, renderer.rendererContext)\n    writeEarlyHints(event, link)\n  }\n\n  const _rendered = await renderer.renderToString(ssrContext).catch((err) => {\n    if (!ssrError) {\n      // Use explicitly thrown error in preference to subsequent rendering errors\n      throw ssrContext.payload?.error || err\n    }\n  })\n  await ssrContext.nuxt?.hooks.callHook('app:rendered', { ssrContext })\n\n  // Handle errors\n  if (!_rendered) {\n    return undefined!\n  }\n  if (ssrContext.payload?.error && !ssrError) {\n    throw ssrContext.payload.error\n  }\n\n  // Directly render payload routes\n  if (isRenderingPayload) {\n    const response = renderPayloadResponse(ssrContext)\n    if (process.env.prerender) {\n      PAYLOAD_CACHE!.set(url, response)\n    }\n    return response\n  }\n\n  if (_PAYLOAD_EXTRACTION) {\n    // Hint nitro to prerender payload for this route\n    appendHeader(event, 'x-nitro-prerender', joinURL(url, '_payload.js'))\n    // Use same ssr context to generate payload for this route\n    PAYLOAD_CACHE!.set(url, renderPayloadResponse(ssrContext))\n  }\n\n  // Render meta\n  const renderedMeta = await ssrContext.renderMeta?.() ?? {}\n\n  // Render inline styles\n  const inlinedStyles = process.env.NUXT_INLINE_STYLES\n    ? await renderInlineStyles(ssrContext.modules ?? ssrContext._registeredComponents ?? [])\n    : ''\n\n  // Create render context\n  const htmlContext: NuxtRenderHTMLContext = {\n    htmlAttrs: normalizeChunks([renderedMeta.htmlAttrs]),\n    head: normalizeChunks([\n      renderedMeta.headTags,\n      _PAYLOAD_EXTRACTION ? `<link rel=\"modulepreload\" href=\"${payloadURL}\">` : null,\n      _rendered.renderResourceHints(),\n      _rendered.renderStyles(),\n      inlinedStyles,\n      ssrContext.styles\n    ]),\n    bodyAttrs: normalizeChunks([renderedMeta.bodyAttrs!]),\n    bodyPreprend: normalizeChunks([\n      renderedMeta.bodyScriptsPrepend,\n      ssrContext.teleports?.body\n    ]),\n    body: [\n      // TODO: Rename to _rendered.body in next vue-bundle-renderer\n      _rendered.html\n    ],\n    bodyAppend: normalizeChunks([\n      process.env.NUXT_NO_SCRIPTS\n        ? undefined\n        : (_PAYLOAD_EXTRACTION\n            ? `<script type=\"module\">import p from \"${payloadURL}\";window.__NUXT__={...p,...(${devalue(splitPayload(ssrContext).initial)})}</script>`\n            : `<script>window.__NUXT__=${devalue(ssrContext.payload)}</script>`\n          ),\n      _rendered.renderScripts(),\n      // Note: bodyScripts may contain tags other than <script>\n      renderedMeta.bodyScripts\n    ])\n  }\n\n  // Allow hooking into the rendered result\n  const nitroApp = useNitroApp()\n  await nitroApp.hooks.callHook('render:html', htmlContext, { event })\n\n  // Construct HTML response\n  const response: RenderResponse = {\n    body: renderHTMLDocument(htmlContext),\n    statusCode: event.res.statusCode,\n    statusMessage: event.res.statusMessage,\n    headers: {\n      'Content-Type': 'text/html;charset=UTF-8',\n      'X-Powered-By': 'Nuxt'\n    }\n  }\n\n  return response\n})\n\nfunction lazyCachedFunction <T> (fn: () => Promise<T>): () => Promise<T> {\n  let res: Promise<T> | null = null\n  return () => {\n    if (res === null) {\n      res = fn().catch((err) => { res = null; throw err })\n    }\n    return res\n  }\n}\n\nfunction normalizeChunks (chunks: (string | undefined)[]) {\n  return chunks.filter(Boolean).map(i => i!.trim())\n}\n\nfunction joinTags (tags: string[]) {\n  return tags.join('')\n}\n\nfunction joinAttrs (chunks: string[]) {\n  return chunks.join(' ')\n}\n\nfunction renderHTMLDocument (html: NuxtRenderHTMLContext) {\n  return `<!DOCTYPE html>\n<html ${joinAttrs(html.htmlAttrs)}>\n<head>${joinTags(html.head)}</head>\n<body ${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPreprend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body>\n</html>`\n}\n\nasync function renderInlineStyles (usedModules: Set<string> | string[]) {\n  const styleMap = await getSSRStyles()\n  const inlinedStyles = new Set<string>()\n  for (const mod of usedModules) {\n    if (mod in styleMap) {\n      for (const style of await styleMap[mod]()) {\n        inlinedStyles.add(`<style>${style}</style>`)\n      }\n    }\n  }\n  return Array.from(inlinedStyles).join('')\n}\n\nfunction renderPayloadResponse (ssrContext: NuxtSSRContext) {\n  return <RenderResponse> {\n    body: `export default ${devalue(splitPayload(ssrContext).payload)}`,\n    statusCode: ssrContext.event.res.statusCode,\n    statusMessage: ssrContext.event.res.statusMessage,\n    headers: {\n      'content-type': 'text/javascript;charset=UTF-8',\n      'x-powered-by': 'Nuxt'\n    }\n  }\n}\n\nfunction splitPayload (ssrContext: NuxtSSRContext) {\n  const { data, prerenderedAt, ...initial } = ssrContext.payload\n  return {\n    initial: { ...initial, prerenderedAt },\n    payload: { data, prerenderedAt }\n  }\n}\n"], "filenames": ["packages/nuxt/src/core/runtime/nitro/renderer.ts"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [123], "fixing_code_start_loc": [4], "fixing_code_end_loc": [128], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository nuxt/framework prior to v3.0.0-rc.13.", "other": {"cve": {"id": "CVE-2022-4413", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-12T00:15:09.710", "lastModified": "2022-12-12T20:00:33.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository nuxt/framework prior to v3.0.0-rc.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "8BC97469-8637-4AA1-AB99-5C4F13C00460"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc10:*:*:*:*:*:*", "matchCriteriaId": "85C15286-F49F-49C7-ABC7-EAFD384E6F8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc11:*:*:*:*:*:*", "matchCriteriaId": "710252E4-2388-422E-9F25-00B09B9AF001"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc12:*:*:*:*:*:*", "matchCriteriaId": "ACE878E2-243D-48D3-965A-2DD9648F4588"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "170E272B-B181-4D27-825B-6B50C4C09130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "101C3063-EF48-4655-9628-CACB38324B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "8F8AFDB7-1140-46D1-8B6D-10AED2824724"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "DE6B2A9F-6F11-47E6-9438-EFA658F65BA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "D4A5B907-6298-4D96-841D-8A698AC01292"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "57371FA5-1903-41F2-B690-97F76DDAA02F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc8:*:*:*:*:*:*", "matchCriteriaId": "8878AF2E-0F79-49B6-8BC5-CCF3267BF6B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nuxt:framework:3.0.0:rc9:*:*:*:*:*:*", "matchCriteriaId": "626711F0-EAE8-4CEA-994C-144E8E871645"}]}]}], "references": [{"url": "https://github.com/nuxt/framework/commit/253c8f7ee0c0c580c44dedbe9387646264e90a1e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/70ac720d-c932-4ed3-98b1-dd2cbcb90185", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nuxt/framework/commit/253c8f7ee0c0c580c44dedbe9387646264e90a1e"}}