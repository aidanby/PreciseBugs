{"buggy_code": ["--- occu/WebUI/www/config/cp_maintenance.cgi.orig\n+++ occu/WebUI/www/config/cp_maintenance.cgi\n@@ -61,10 +61,14 @@\n       puts \"conInfo(\\\"EULA found\\\");\"\n       puts \"jQuery('#fwUpload').hide();\"\n       puts \"var dlg = new EulaDialog(translateKey('dialogEulaTitle'), data, function(result) {\"\n+        puts \"var dlgPopup = parent.top.dlgPopup;\"\n+        puts \"if (dlgPopup === undefined) {\"\n+          puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+        puts \"}\"\n         puts \"if (result == 1) {\"\n-          puts \"parent.top.dlgPopup.hide();\"\n-          puts \"parent.top.dlgPopup.setWidth(450);\"\n-          puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+          puts \"dlgPopup.hide();\"\n+          puts \"dlgPopup.setWidth(450);\"\n+          puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n         puts \"} else {\"\n           puts \"jQuery('#fwUpload').hide();\"\n           puts \"dlgPopup.hide();\"\n@@ -77,16 +81,19 @@\n \n     puts \"req.fail(function(data) {\"\n       puts \"conInfo(\\\"EULA not available\\\");\"\n-      puts \"parent.top.dlgPopup.hide();\"\n-      puts \"parent.top.dlgPopup.setWidth(450);\"\n-      puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+      puts \"var dlgPopup = parent.top.dlgPopup;\"\n+      puts \"if (dlgPopup === undefined) {\"\n+        puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+      puts \"}\"\n+      puts \"dlgPopup.hide();\"\n+      puts \"dlgPopup.setWidth(450);\"\n+      puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n     puts \"});\"\n   }\n }\n \n proc action_firmware_update_confirm {} {\n   global env\n-   cgi_debug -on\n   http_head\n   division {class=\"popupTitle\"} {\n     #puts \"Softwareupdate - Best&auml;tigung\"\n@@ -266,7 +273,7 @@\n }\n \n proc action_firmware_update_cancel {} {\n-  global env\n+  global env filename\n \n   if {[getProduct] < 3} {\n     catch {exec rm /var/new_firmware.tar.gz}\n@@ -432,9 +439,7 @@\n             table_row {\n               td {width=\"20\"} {}\n               table_data {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=firmware_form {target=firmware_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=firmware_upload\n-                  export downloadOnly=$downloadOnly\n+                form \"/config/fileupload.ccc?sid=$sid&action=firmware_upload&downloadOnly=$downloadOnly&url=$env(SCRIPT_NAME)\" {target=firmware_upload_iframe} name=firmware_form enctype=multipart/form-data method=post {\n                   file_button firmware_file size=30 maxlength=1000000\n                 }\n                 puts {<iframe name=\"firmware_upload_iframe\" style=\"display: none;\"></iframe>}\n@@ -1020,7 +1025,7 @@\n \n proc action_firmware_upload {} {\n \n-  global env sid downloadOnly\n+  global env sid downloadOnly filename\n \n   if { [catch { import directDownload } error] } {\n     set directDownload false\n@@ -1029,10 +1034,7 @@\n   http_head\n   \n   if { $directDownload } {\n-    set filename \"/tmp/fup.tgz\"\n-  } else {\n-    import_file -client firmware_file\n-    set filename [lindex $firmware_file 0]\n+    set filename \"/usr/local/tmp/firmwareUpdateFile\"\n   }\n \n   if {[getProduct] < 3} {\n@@ -1102,10 +1104,14 @@\n \n   cgi_javascript {\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n-    puts \"parent.top.dlgPopup.hide();\"\n-    puts \"parent.top.dlgPopup.setWidth(450);\"\n-    puts \"parent.top.dlgPopup.downloadOnly = $downloadOnly;\"\n-    puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+    puts \"var dlgPopup = parent.top.dlgPopup;\"\n+    puts \"if (dlgPopup === undefined) {\"\n+      puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+    puts \"}\"\n+    puts \"dlgPopup.hide();\"\n+    puts \"dlgPopup.setWidth(450);\"\n+    puts \"dlgPopup.downloadOnly = $downloadOnly;\"\n+    puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n   }\n }\n \n@@ -1393,10 +1399,10 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n \n   set action \"put_page\"\n   set downloadOnly 0\n--- occu/WebUI/www/config/cp_network.cgi.orig\n+++ occu/WebUI/www/config/cp_network.cgi\n@@ -149,6 +149,8 @@\n   \n   http_head\n \n+  file rename -force -- \"/usr/local/tmp/server.pem\" \"/etc/config/server.pem\"\n+\n   put_message \"\\${dialogSettingsNetworkMessageCertificateTitle}\" \"\\${dialogSettingsNetworkMessageCertificateCCURestart}\" {\\${btnNewLogin} \"window.location.href='/';\"}\n   \n   #save DOM\n@@ -245,37 +247,43 @@\n }\n \n proc action_cert_upload {} {\n-  global env sid\n-  cd /tmp/\n+  global env sid filename\n+  cd /usr/local/tmp/\n   \n   http_head\n-  import_file -client cert_file\n-  file rename -force -- [lindex $cert_file 0] \"/var/server.pem\"\n-  \n-  set filename [open \"/var/server.pem\" r]\n-  gets $filename line\n-  close $filename\n+  set fp [open \"$filename\" r]\n+  gets $fp line\n+  close $fp\n   #puts $line;\n   if { [string equal $line \"-----BEGIN RSA PRIVATE KEY-----\"] == 1 || [string equal $line \"-----BEGIN PRIVATE KEY-----\"] == 1} {\n-    file copy -force -- \"/var/server.pem\" \"/etc/config/server.pem\"\n-    file delete \"/var/server.pem\"\n+    file rename -force -- $filename \"/usr/local/tmp/server.pem\"\n     \n     cgi_javascript {\n       puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n       puts {\n-        parent.top.dlgPopup.hide();\n-        parent.top.dlgPopup.setWidth(600);\n-        parent.top.dlgPopup.LoadFromFile(url, \"action=cert_update_confirm\");\n+        var dlgPopup = parent.top.dlgPopup;\n+        if (dlgPopup === undefined) {\n+          dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+        }\n+        dlgPopup.hide();\n+        dlgPopup.setWidth(600);\n+        dlgPopup.LoadFromFile(url, \"action=cert_update_confirm\");\n       }\n     }\n   } else {\n+    file delete -force -- $filename\n+\n     cgi_javascript {\n-    puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n-    puts {\n-      parent.top.dlgPopup.hide();\n-      parent.top.dlgPopup.setWidth(600);\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=cert_update_failed\");\n-    }\n+      puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n+      puts {\n+        var dlgPopup = parent.top.dlgPopup;\n+        if (dlgPopup === undefined) {\n+          dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+        }\n+        dlgPopup.hide();\n+        dlgPopup.setWidth(600);\n+        dlgPopup.LoadFromFile(url, \"action=cert_update_failed\");\n+      }\n     }\n   }\n }\n@@ -459,8 +467,7 @@\n             table_row {\n               table_data {width=\"20\"} {}\n               table_data {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=cert_form {target=cert_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=cert_upload\n+                form \"/config/fileupload.ccc?sid=$sid&action=cert_upload&url=$env(SCRIPT_NAME)\" name=cert_form {target=cert_upload_iframe} enctype=multipart/form-data method=post {\n                   file_button cert_file size=30 maxlength=1000000\n                 }\n                 puts {<iframe name=\"cert_upload_iframe\" style=\"display: none;\"></iframe>}\n@@ -774,13 +781,16 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n   set action \"put_page\"\n+  set filename \"\"\n \n   catch { import action }\n+  catch { import filename }\n+\n   if {[session_requestisvalid 8] > 0} then action_$action\n }\n \n--- occu/WebUI/www/config/cp_security.cgi.orig\n+++ occu/WebUI/www/config/cp_security.cgi\n@@ -928,8 +928,6 @@\n proc action_put_page {} {\n   global env sid\n \n-  cgi_debug -on\n-\n   http_head\n   division {class=\"popupTitle j_translate\"} {\n     puts \"\\${dialogSettingsSecurityTitle}\"\n@@ -1022,8 +1020,7 @@\n             table_row {\n               td {width=\"20\"} {}\n               table_data {align=\"left\"} {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=backup_form {target=config_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=backup_upload\n+                form \"/config/fileupload.ccc?sid=$sid&action=backup_upload&url=$env(SCRIPT_NAME)\" name=backup_form {target=config_upload_iframe} enctype=multipart/form-data method=post {\n                   file_button backup_file size=20 maxlength=1000000\n                 }\n                 puts {<iframe name=\"config_upload_iframe\" class=\"CLASS20820\" style=\"display: none;\"></iframe>}\n@@ -1536,19 +1533,21 @@\n }\n \n proc action_backup_upload {} {\n-  global env sid\n-  cd /tmp/\n+  global env sid filename\n+  cd /usr/local/tmp/\n \n+  file rename -force -- $filename \"/usr/local/tmp/new_config.tar\"\n   http_head\n-  import_file -client backup_file\n-  file rename -force -- [lindex $backup_file 0] \"/tmp/new_config.tar\"\n   cgi_javascript {\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n     puts {\n-      //parent.top.ProgressBar.IncCounter(\"Backup wurde \u5699\u7badertragen.\");\n-      parent.top.dlgPopup.hide();\n-      parent.top.dlgPopup.setWidth(400);\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=backup_restore_check\");\n+      var dlgPopup = parent.top.dlgPopup;\n+      if (dlgPopup === undefined) {\n+        dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+      }\n+      dlgPopup.hide();\n+      dlgPopup.setWidth(400);\n+      dlgPopup.LoadFromFile(url, \"action=backup_restore_check\");\n     }\n   }\n }\n@@ -1617,14 +1616,16 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n \n   set action \"put_page\"\n+  set filename \"\"\n \n   catch { import action }\n+  catch { import filename }\n \n   if {[session_requestisvalid 8] > 0} then action_$action\n }\n--- occu/WebUI/www/config/cp_software.cgi.orig\n+++ occu/WebUI/www/config/cp_software.cgi\n@@ -353,8 +353,7 @@\n                 puts \"\\${dialogSettingsExtraSoftwareLblSelectExtraSoftware}\"\r\n               }\r\n               table_data {\r\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=upload_form {target=image_upload_iframe} enctype=multipart/form-data method=post {\r\n-                  export action=image_upload\r\n+                form \"/config/fileupload.ccc?sid=$sid&action=image_upload&url=$env(SCRIPT_NAME)\" name=upload_form {target=image_upload_iframe} enctype=multipart/form-data method=post {\r\n                   file_button firmware_file size=30 maxlength=1000000\r\n                 }\r\n                 puts {<iframe name=\"image_upload_iframe\" style=\"display: none;\"></iframe>}\r\n@@ -487,24 +486,27 @@\n }\r\n \r\n proc action_image_upload {} {\r\n-  global env sid\r\n-  cd /tmp/\r\n+  global env sid filename\r\n+  cd /usr/local/tmp/\r\n   \r\n   http_head\r\n-  import_file -client firmware_file\r\n   if {[getProduct] < 3} {\r\n     # CCU2\r\n-    file rename -force -- [lindex $firmware_file 0] \"/var/new_firmware.tar.gz\"\r\n+    file rename -force -- $filename \"/var/new_firmware.tar.gz\"\r\n   } else {\r\n     # CCU3\r\n-    file rename -force -- [lindex $firmware_file 0] \"/usr/local/tmp/new_addon.tar.gz\"\r\n+    file rename -force -- $filename \"/usr/local/tmp/new_addon.tar.gz\"\r\n   }\r\n   cgi_javascript {\r\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\r\n     puts {\r\n-      parent.top.dlgPopup.hide();\r\n-      parent.top.dlgPopup.setWidth(600);\r\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=install_confirm\");\r\n+      var dlgPopup = parent.top.dlgPopup;\r\n+      if (dlgPopup === undefined) {\r\n+        dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\r\n+      }\r\n+      dlgPopup.hide();\r\n+      dlgPopup.setWidth(600);\r\n+      dlgPopup.LoadFromFile(url, \"action=install_confirm\");\r\n     }\r\n   }\r\n }\r\n@@ -519,14 +521,16 @@\n cgi_eval {\r\n   #cgi_debug -on\r\n   cgi_input\r\n-  catch {\r\n-    import debug\r\n-    cgi_debug -on\r\n-  }\r\n+  #catch {\r\n+  #  import debug\r\n+  #  cgi_debug -on\r\n+  #}\r\n \r\n   set action \"put_page\"\r\n+  set filename \"\"\r\n \r\n   catch { import action }\r\n+  catch { import filename }\r\n \r\n   if {[session_requestisvalid 8] > 0} then action_$action\r\n }\r\n--- occu/WebUI/www/config/fileupload.ccc.orig\n+++ occu/WebUI/www/config/fileupload.ccc\n@@ -0,0 +1,61 @@\n+#!/bin/sh\n+# shellcheck shell=dash disable=SC2169,SC2034,SC2154\n+\n+echo -ne \"Content-Type: text/html; charset=iso-8859-1\\r\\n\\r\\n\"\n+\n+# fake read boundary+disposition, etc.\n+read -r boundary\n+read -r disposition\n+read -r ctype\n+read -r junk\n+\n+# get length\n+a=${#boundary}\n+b=${#disposition}\n+c=${#ctype}\n+d=0\n+\n+# Due to \\n\\r line breaks we have 2 extra bytes per line read,\n+# 6 + 2 newlines == 10 junk bytes\n+a=$((a*2+b+c+d+10))\n+\n+# extract all params from QUERY_STRING\n+# shellcheck disable=SC2046,SC2116,SC2086\n+eval $(echo ${QUERY_STRING//&/;})\n+\n+# calculate the expected content length using\n+# HTTP_CONTENT_LENGTH or CONTENT_LENGTH\n+if [ -z \"${HTTP_CONTENT_LENGTH}\" ]; then\n+  HTTP_CONTENT_LENGTH=${CONTENT_LENGTH}\n+fi\n+SIZE=$((HTTP_CONTENT_LENGTH-a))\n+\n+# write out the data\n+filename=$(mktemp -p /usr/local/tmp)\n+if ! /usr/bin/head -q -c ${SIZE} >\"${filename}\"; then\n+  echo \"ERROR (head)\"\n+fi\n+\n+echo \"<html>\"\n+echo \" <head>\"\n+echo \"  <script>\"\n+echo \"   <!--- Hide script from browsers that don't understand JavaScript\"\n+echo \"   var url = '${url}?sid=${sid}';\"\n+echo \"   var dlgPopup = parent.top.dlgPopup;\"\n+echo \"   if (dlgPopup === undefined) {\"\n+echo \"     dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+echo \"   }\"\n+echo \"   if (dlgPopup !== undefined) {\"\n+echo \"     dlgPopup.hide();\"\n+echo \"     dlgPopup.setWidth(450);\"\n+if [[ -n \"${downloadOnly}\" ]]; then\n+  echo \"     dlgPopup.downloadOnly=${downloadOnly};\"\n+fi\n+echo \"     dlgPopup.LoadFromFile(url, 'action=${action}&filename=${filename}');\"\n+echo \"   }\"\n+echo \"   // End hiding -->\"\n+echo \"  </script>\"\n+echo \" </head>\"\n+echo \"</html>\"\n+\n+exit 0\n--- occu/WebUI/www/tcl/extern/cgi.tcl.orig\n+++ occu/WebUI/www/tcl/extern/cgi.tcl\n@@ -3,15 +3,11 @@\n # cgi.tcl - routines for writing CGI scripts in Tcl\n # Author: Don Libes <libes@nist.gov>, January '95\n #\n-# Minor changes by Lars Reemts, eQ-3\n-#\n # These routines implement the code described in the paper\n # \"Writing CGI scripts in Tcl\" which appeared in the Tcl '96 conference.\n # Please read the paper before using this code.  The paper is:\n # http://expect.nist.gov/doc/cgi.pdf\n #\n-# F. Werner:\n-#  add \"charset=iso-8859-1\" to header Content-Type\n ##################################################\n \n ##################################################\n@@ -27,12 +23,10 @@\n \n     if {0 == [llength $args]} {\n \tcgi_content_type\n-    cgi_puts \"Expires: Sun, 06 Nov 1994 00:00:00 GMT\"\n     } else {\n \tif {[catch {uplevel 1 [lindex $args 0]} errMsg]} {\n \t    set savedInfo $errorInfo\n \t    cgi_content_type\n-        cgi_puts \"Expires: Sun, 06 Nov 1994 00:00:00 GMT\"\n \t}\n     }\n     cgi_puts \"\"\n@@ -310,7 +304,7 @@\n \t\t\t    catch {cgi_mail_add \"HTTP_HOST: $env(HTTP_HOST)\"}\n \t\t\t    catch {cgi_mail_add \"REMOTE_HOST: $env(REMOTE_HOST)\"}\n \t\t\t    catch {cgi_mail_add \"REMOTE_ADDR: $env(REMOTE_ADDR)\"}\n-\t\t\t    cgi_mail_add \"cgi.tcl version: 1.8.0\"\n+\t\t\t    cgi_mail_add \"cgi.tcl version: 1.10.0\"\n \t\t\t    cgi_mail_add \"input:\"\n \t\t\t    catch {cgi_mail_add $_cgi(input)}\n \t\t\t    cgi_mail_add \"cookie:\"\n@@ -472,10 +466,9 @@\n     foreach a [lrange $args 1 end] {\n         append buf \" $a\"\n     }\n-    return \"$buf ></iframe>\"\n+    return \"$buf />\"\n }\n \n-\n # generate an image reference (<img ...>)\n # first arg is image url\n # other args are passed through into <img> tag\n@@ -497,7 +490,7 @@\n \n # names an anchor so that it can be linked to\n proc cgi_anchor_name {name} {\n-    return \"<a name=\\\"$name\\\"></a>\"\n+    return \"<a name=\\\"$name\\\"/>\"\n }\n \n proc cgi_base {args} {\n@@ -513,7 +506,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \" / >\"\n+    cgi_puts \" />\"\n }\n \n ##################################################\n@@ -531,7 +524,8 @@\n \tregsub -all -nocase {%([a-f0-9][a-f0-9])} $buf {\\\\u00\\1} buf\n \n \t# process \\u unicode mapped chars\n-\tencoding convertfrom [subst -novar -nocommand $buf]\n+\tencoding convertfrom $::_cgi(queryencoding) \\\n+\t\t [subst -novar -nocommand $buf]\n     }\n } elseif {[info tclversion] >= 8.1} {\n     proc cgi_unquote_input buf {\n@@ -982,7 +976,7 @@\n # from cgi_http_head.\n proc cgi_http_equiv {type contents} {\n     _cgi_http_head_implicit\n-    cgi_puts \"<meta http-equiv=\\\"$type\\\" content=[cgi_dquote_html $contents]></meta>\"\n+    cgi_puts \"<meta http-equiv=\\\"$type\\\" content=[cgi_dquote_html $contents]/>\"\n }\n \n # Do whatever you want with meta tags.\n@@ -1010,7 +1004,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \"></link>\"\n+    cgi_puts \"/>\"\n }\n \n proc cgi_name {args} {\n@@ -1114,7 +1108,7 @@\n \n proc cgi_noscript {args} {\n     cgi_puts \"<noscript[_cgi_lrange $args 0 [expr [llength $args]-2]]>\"\n-    _cgi_close_proc_push {puts \"</noscript>\"}\n+    _cgi_close_proc_push {cgi_puts \"</noscript>\"}\n \n     uplevel 1 [lindex $args end]\n \n@@ -1135,7 +1129,7 @@\n     if {$q != \"=\"} {\n \tset value \"\"\n     }\n-    cgi_puts \"<param name=\\\"$name\\\" value=[cgi_dquote_html $value]></param>\"\n+    cgi_puts \"<param name=\\\"$name\\\" value=[cgi_dquote_html $value]/>\"\n }\n \n # record any proc's that must be called prior to displaying an error\n@@ -1254,7 +1248,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_put \"></isindex>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -1294,15 +1288,31 @@\n \t} else {\n \t    set length $env(CONTENT_LENGTH)\n \t    if {0!=[string compare $length \"-1\"]} {\n-        if { $length } {\n-\t\t    set input [read stdin $env(CONTENT_LENGTH)]\t\t\n-        } else {\n-            set input \"\"\n-        }\n+\t\tset input [read stdin $env(CONTENT_LENGTH)]\t\t\n \t    } else {\n \t\tset _cgi(client_error) 1\n \t\terror \"Your browser generated a content-length of -1 during a POST method.\"\n \t    }\n+\t    if {[info tclversion] >= 8.1} {\n+                # guess query encoding from Content-Type header\n+                if {[info exists env(CONTENT_TYPE)] \\\n+                    && [regexp -nocase -- {charset=([^[:space:]]+)} $env(CONTENT_TYPE) m cs]} {\n+                    if {[regexp -nocase -- {iso-?8859-([[:digit:]]+)} $cs m d]} {\n+                        set _cgi(queryencoding) \"iso8859-$d\"\n+                    } elseif {[regexp -nocase -- {windows-([[:digit:]]+)} $cs m d]} {\n+                        set _cgi(queryencoding) \"cp$d\"\n+                    } elseif {0==[string compare -nocase $cs \"utf-8\"]} {\n+                        set _cgi(queryencoding) \"utf-8\"\n+                    } elseif {0==[string compare -nocase $cs \"utf-16\"]} {\n+                        set _cgi(queryencoding) \"unicode\"\n+                    }\n+                    if { [lsearch -exact [encoding names] _cgi(queryencoding)] == -1} {\n+                        set _cgi(queryencoding) [encoding system]\n+                    }\n+                } else {\n+                    set _cgi(queryencoding) [encoding system]\n+                }\n+            }\n \t}\n \t# save input for possible diagnostics later\n \tset _cgi(input) $input\n@@ -1345,30 +1355,6 @@\n     }\n }\n \n-set _cgi_read_line_buffer \"\"\n-proc _cgi_read_line {fin bufvar crlfvar} {\n-    global _cgi_read_line_buffer\n-    upvar $bufvar buffer\n-    upvar $crlfvar crlf\n-    set line_end [string first \"\\r\\n\" $_cgi_read_line_buffer]\n-    while {($line_end < 0 ) && ![eof $fin]} {\n-        append _cgi_read_line_buffer [read $fin 65536]\n-        set line_end [string first \"\\r\\n\" $_cgi_read_line_buffer]\n-    }\n-    if {$line_end >= 0} { \n-        incr line_end -1\n-        set buffer [string range $_cgi_read_line_buffer 0 $line_end]\n-        set crlf \"\\r\\n\"\n-        set _cgi_read_line_buffer [string range $_cgi_read_line_buffer [expr $line_end + 3] end]\n-        return 1\n-    } else {\n-        set buffer $_cgi_read_line_buffer\n-        set crlf \"\"\n-        set _cgi_read_line_buffer \"\"\n-        return [expr ([string length $buffer] > 0)]\n-    }\n-}\n-\n proc _cgi_input_multipart {fin} {\n     global env _cgi _cgi_uservar _cgi_userfile\n \n@@ -1379,121 +1365,7 @@\n \t# can hang and we won't get to the termination code\n \tset dbg_fout [open $dbg_filename w]\n \tset _cgi(input) $dbg_filename\n-\tcatch {fconfigure $dbg_fout -translation binary -encoding binary}\n-    }\n-\n-    # figure out boundary\n-    if {0==[regexp boundary=(.*) $env(CONTENT_TYPE) dummy boundary]} {\n-\tset _cgi(client_error) 1\n-\terror \"Your browser failed to generate a \\\"boundary=\\\" line in a multipart response (CONTENT_TYPE: $env(CONTENT_TYPE)).  Please upgrade (or fix) your browser.\"\n-    }\n-\n-    set boundary \"--$boundary\"\n-    set boundary_length [string length $boundary]\n-    \n-    # don't corrupt or modify uploads yet allow Tcl 7.4 to work\n-    catch {fconfigure $fin -translation binary -encoding binary}\n-\n-    # get first boundary line\n-    gets $fin buf\n-    if {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n-\n-    set filecount 0\n-    set crlf \"\"\n-    while {1} {\n-\t# process Content-Disposition:\n-\tif { ! [_cgi_read_line $fin buf crlf] } break\n-\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-\tcatch {unset filename}\n-\tcatch {unset varname}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n-\tif {0==[info exists varname]} {\n-\t    set _cgi(client_error) 1\n-\t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n-\t}\t    \n-\t# Lame-o encoding (on Netscape at least) doesn't escape field\n-\t# delimiters (like quotes)!!  Since all we've ever seen is filename=\n-\t# at end of line, assuming nothing follows.  Sigh.\n-\tregexp {filename=\"(.*)\"} $buf dummy filename\n-\n-\t# Skip remaining headers until blank line.\n-\t# Content-Type: can appear here.\n-\tset conttype \"\"\n-\twhile {1} {\n-            if { ! [_cgi_read_line $fin buf crlf] } break\n-\t    if {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-\t    if {0==[string compare $buf \"\"]} break\n-\t    regexp -nocase \"^Content-Type:\\[ \\t]+(.*)\\r\\n\" $buf$crlf x conttype\n-\t}\n-\n-\tif {[info exists filename]} {\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Reading file $filename\"; flush $dbg_fout}\n-\t    # read the part into a file\n-\t    set foutname /tmp/CGI[pid].[incr filecount]\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n-\t    set fout [open $foutname w]\n-\t    # \"catch\" permits this to work with Tcl 7.4\n-\t    catch {fconfigure $fout -translation binary -encoding binary}\n-\t    _cgi_set_uservar $varname [list $foutname $filename $conttype]\n-\t    set _cgi_userfile($varname) [list $foutname $filename $conttype]\n-            \n-            set leftover \"\"\n-            while { 1 } {\n-                if { ! [_cgi_read_line $fin buf crlf] } {\n-                    set _cgi(client_error) 1\n-                    error \"Unexpected end of input data.\"\n-                }\n-\t\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-                if {[string compare -length $boundary_length $buf $boundary] == 0} {\n-                    if {[string first \"--\" $buf $boundary_length]>=0} {set eof 1}\n-                    break;\n-                }\n-                puts -nonewline $fout $leftover$buf\n-                set leftover $crlf\n-            }\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Read file $filename\"; flush $dbg_fout}\n-\t    close $fout\n-\t    unset fout\n-        \n-\t} else {\n-\t    # read the part into a variable\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Reading variable $varname\"; flush $dbg_fout}\n-\t    set val \"\"\n-            set leftover \"\"\n-            while { 1 } {\n-                if { ! [_cgi_read_line $fin buf crlf] } {\n-                    set _cgi(client_error) 1\n-                    error \"Unexpected end of input data.\"\n-                }\n-\t\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-                if {[string compare -length $boundary_length $buf $boundary] == 0} {\n-                    if {[string first \"--\" $buf $boundary_length]>=0} {set eof 1}\n-                    break;\n-                }\n-                append val $leftover$buf\n-                set leftover $crlf\n-\t    }\n-\t    _cgi_set_uservar $varname $val\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>$varname=$val\"; flush $dbg_fout}\n-\t}\n-        if {[info exists eof]} break\n-    }\n-    if {[info exists dbg_fout]} {close $dbg_fout}\n-}\n-\n-proc _cgi_input_multipart_buggy {fin} {\n-    global env _cgi _cgi_uservar _cgi_userfile\n-\n-    cgi_debug -noprint {\n-\t# save file for debugging purposes\n-\tset dbg_filename [file join $_cgi(tmpdir) CGIdbg.[pid]]\n-\t# explicitly flush all writes to fout, because sometimes the writer\n-\t# can hang and we won't get to the termination code\n-\tset dbg_fout [open $dbg_filename w]\n-\tset _cgi(input) $dbg_filename\n-\tcatch {fconfigure $dbg_fout -translation binary -encoding binary}\n+\tcatch {fconfigure $dbg_fout -translation binary}\n     }\n \n     # figure out boundary\n@@ -1513,24 +1385,28 @@\n     set boundary --$boundary\n \n     # don't corrupt or modify uploads yet allow Tcl 7.4 to work\n-    catch {fconfigure $fin -translation binary -encoding binary}\n+    catch {fconfigure $fin -translation binary}\n \n     # get first boundary line\n     gets $fin buf\n     if {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n \n-    set filecount 0\n+    set _cgi(file,filecount) 0\n+\n     while {1} {\n \t# process Content-Disposition:\n \tif {-1 == [gets $fin buf]} break\n \tif {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n \tcatch {unset filename}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n+\tregexp {name=\"([^\"]*)\"} $buf dummy varname\n \tif {0==[info exists varname]} {\n-\t    set _cgi(client_error) 1\n-\t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n+\t    # lynx violates spec and doesn't use quotes, so try again but\n+\t    # assume space is delimiter\n+\t    regexp {name=([^ ]*)} $buf dummy varname\n+\t    if {0==[info exists varname]} {\n+\t\tset _cgi(client_error) 1\n+\t\terror \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n+\t    }\n \t}\t    \n \t# Lame-o encoding (on Netscape at least) doesn't escape field\n \t# delimiters (like quotes)!!  Since all we've ever seen is filename=\n@@ -1548,14 +1424,18 @@\n \t}\n \n \tif {[info exists filename]} {\n+\t    if {$_cgi(file,filecount) > $_cgi(file,filelimit)} {\n+\t\terror \"Too many files submitted.  Max files allowed: $_cgi(file,filelimit)\"\n+\t    }\n+\n \t    # read the part into a file\n-\t    set foutname /tmp/CGI[pid].[incr filecount]\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n+\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr _cgi(file,filecount)]]\n \t    set fout [open $foutname w]\n \t    # \"catch\" permits this to work with Tcl 7.4\n-\t    catch {fconfigure $fout -translation binary -encoding binary}\n+\t    catch {fconfigure $fout -translation binary}\n \t    _cgi_set_uservar $varname [list $foutname $filename $conttype]\n \t    set _cgi_userfile($varname) [list $foutname $filename $conttype]\n+\n \t    #\n \t    # Look for a boundary line preceded by \\r\\n.\n \t    #\n@@ -1583,10 +1463,13 @@\n \t\t    puts -nonewline $fout $leftover$buf\n \t\t    set leftover \"\\n\"\n \t\t}\n+ \t\tif {[file size $foutname] > $_cgi(file,charlimit)} {\n+\t\t    error \"File size exceeded.  Max file size allowed: $_cgi(file,charlimit)\"\n+\t\t}\n \t    }\n+\n \t    close $fout\n \t    unset fout\n-        \n \t} else {\n \t    # read the part into a variable\n \t    set val \"\"\n@@ -1672,7 +1555,8 @@\n \t}\n     }\n \n-    set filecount 0\n+    set _cgi(file,filecount) 0\n+\n     while {1} {\n \t# process Content-Disposition:\n \texpect {\n@@ -1684,9 +1568,7 @@\n \t    eof break\n \t}\n \tcatch {unset filename}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n+\tregexp {name=\"([^\"]*)\"} $buf dummy varname\n \tif {0==[info exists varname]} {\n \t    set _cgi(client_error) 1\n \t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n@@ -1712,8 +1594,12 @@\n \t}\n \n \tif {[info exists filename]} {\n+\t    if {$_cgi(file,filecount) > $_cgi(file,filelimit)} {\n+\t\terror \"Too many files submitted.  Max files allowed: $_cgi(file,filelimit)\"\n+\t    }\n+\n \t    # read the part into a file\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n+\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr _cgi(file,filecount)]]\n \t    spawn -open [open $foutname w]\n \t    set fout_sid $spawn_id\n \n@@ -1967,6 +1853,23 @@\n     }\n }\n \n+# set the urlencoding\n+proc cgi_urlencoding {{encoding \"\"}} {\n+    global _cgi \n+    \n+    set result [expr {[info exists _cgi(queryencoding)]\n+                      ? $_cgi(queryencoding)\n+                      : \"\"}]\n+\n+    # check if the encoding is available \n+    if {[info tclversion] >= 8.1\n+        && [lsearch -exact [encoding names] $encoding] != -1 } {\t\n+        set _cgi(queryencoding) $encoding\n+    }\n+\n+    return $result\n+}\n+\n ##################################################\n # button support\n ##################################################\n@@ -2088,7 +1991,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_put \"></area>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -2182,6 +2085,15 @@\n     cgi_put \"<input type=file name=\\\"$name\\\"[_cgi_list_to_string $args]/>\"\n }\n \n+# establish a per-file limit for uploads\n+\n+proc cgi_file_limit {files chars} {\n+    global _cgi\n+\n+    set _cgi(file,filelimit) $files\n+    set _cgi(file,charlimit) $chars\n+}\n+\n ##################################################\n # select support\n ##################################################\n@@ -2224,7 +2136,7 @@\n     }\n     if {[info exists selected_if_equal]} {\n \tif {0 == [string compare $selected_if_equal $value]} {\n-\t    cgi_put \" selected=\\\"selected\\\"\"\n+\t    cgi_put \" selected\"\n \t}\n     }\n     cgi_puts \">[cgi_quote_html $o]</option>\"\n@@ -2251,7 +2163,7 @@\n \t    }\n \t}\n     }\n-    cgi_put \"></embed>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -2525,7 +2437,7 @@\n ##################################################\n \n proc cgi_stylesheet {href} {\n-    puts \"<link rel=stylesheet href=\\\"$href\\\" type=\\\"text/css\\\"></link>\"\n+    puts \"<link rel=stylesheet href=\\\"$href\\\" type=\\\"text/css\\\"/>\"\n }\n \n proc cgi_span {args} {\n@@ -2584,7 +2496,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \"></frame>\"\n+    cgi_puts \"/>\"\n }\n \n proc cgi_noframes {args} {\n@@ -2672,33 +2584,50 @@\n \n # User-defined procedure to generate DOCTYPE declaration\n proc cgi_doctype {} {\n-\t#Zeile hinzugef\u5790t: 22.02.2007, Badberg, ELV\n-\t#puts \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\"\n-\n-  # AG, eQ-3, 29.01.2013\n-\tputs \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\t\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-\n-\t#quirks puts \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\"\n+    # AG, eQ-3, 29.01.2013\n+    puts \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"  \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n }\n \n ##################################################\n # do some initialization\n ##################################################\n \n-cgi_name \"\"\n-cgi_root \"\"\n-cgi_body_args \"\"\n+# cgi_init initializes to a known state.\n+\n+proc cgi_init {} {\n+    global _cgi\n+    unset _cgi\n+\n+    # set explicitly for speed\n+    set _cgi(debug) -off\n+    set _cgi(buffer_nl) \"\\n\"\n \n-# email addr of person responsible for this service\n-cgi_admin_mail_addr \"root\"\t;# you should override this!\n+    cgi_name \"\"\n+    cgi_root \"\"\n+    cgi_body_args \"\"\n+    cgi_file_limit 10 100000000\n \n-# most services won't have an actual email addr\n-cgi_mail_addr \"CGI script - do not reply\"\n+    if {[info tclversion] >= 8.1} {\n+\t# set initial urlencoding\n+\tif { [lsearch -exact [encoding names] \"utf-8\"] != -1} {\n+\t    cgi_urlencoding \"utf-8\"\n+\t} else {\n+\t    cgi_urlencoding [encoding system]\n+\t}\n+    }\n+\n+    # email addr of person responsible for this service\n+    cgi_admin_mail_addr \"root\"\t;# you should override this!\n+\n+    # most services won't have an actual email addr\n+    cgi_mail_addr \"CGI script - do not reply\"\n+}\n+cgi_init\n \n # deduce tmp directory\n switch $tcl_platform(platform) {\n     unix {\n-\tset _cgi(tmpdir) /tmp\n+\tset _cgi(tmpdir) /usr/local/tmp\n     } macintosh {\n \tset _cgi(tmpdir) [pwd]\n     } default {\n@@ -2711,4 +2640,4 @@\n # regexp for matching attr=val\n set _cgi(attr,regexp) \"^(\\[^=]*)=(\\[^\\\"].*)\"\n \n-package provide cgi 1.8.0\n+package provide cgi 1.10.0\n--- occu/WebUI/www/webui/webui.js.orig\n+++ occu/WebUI/www/webui/webui.js\n@@ -7365,6 +7365,7 @@\n     this.currentPageOptions  = options;\n     \n     this.currentPage.enter(options);\n+    window.name = 'ccu-main-window';\n   },\n   \n   reload: function()\n", "#!/bin/sh\n# shellcheck shell=dash disable=SC2169,SC2034,SC2154\n\necho -ne \"Content-Type: text/html; charset=iso-8859-1\\r\\n\\r\\n\"\n\n# fake read boundary+disposition, etc.\nread -r boundary\nread -r disposition\nread -r ctype\nread -r junk\n\n# get length\na=${#boundary}\nb=${#disposition}\nc=${#ctype}\nd=0\n\n# Due to \\n\\r line breaks we have 2 extra bytes per line read,\n# 6 + 2 newlines == 10 junk bytes\na=$((a*2+b+c+d+10))\n\n# extract all params from QUERY_STRING\n# shellcheck disable=SC2046,SC2116,SC2086\neval $(echo ${QUERY_STRING//&/;})\n\n# calculate the expected content length using\n# HTTP_CONTENT_LENGTH or CONTENT_LENGTH\nif [ -z \"${HTTP_CONTENT_LENGTH}\" ]; then\n  HTTP_CONTENT_LENGTH=${CONTENT_LENGTH}\nfi\nSIZE=$((HTTP_CONTENT_LENGTH-a))\n\n# write out the data\nfilename=$(mktemp -p /usr/local/tmp)\nif ! /usr/bin/head -q -c ${SIZE} >\"${filename}\"; then\n  echo \"ERROR (head)\"\nfi\n\necho \"<html>\"\necho \" <head>\"\necho \"  <script>\"\necho \"   <!--- Hide script from browsers that don't understand JavaScript\"\necho \"   var url = '${url}?sid=${sid}';\"\necho \"   var dlgPopup = parent.top.dlgPopup;\"\necho \"   if (dlgPopup === undefined) {\"\necho \"     dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\necho \"   }\"\necho \"   if (dlgPopup !== undefined) {\"\necho \"     dlgPopup.hide();\"\necho \"     dlgPopup.setWidth(450);\"\nif [[ -n \"${downloadOnly}\" ]]; then\n  echo \"     dlgPopup.downloadOnly=${downloadOnly};\"\nfi\necho \"     dlgPopup.LoadFromFile(url, 'action=${action}&filename=${filename}');\"\necho \"   }\"\necho \"   // End hiding -->\"\necho \"  </script>\"\necho \" </head>\"\necho \"</html>\"\n\nexit 0\n"], "fixing_code": ["--- occu/WebUI/www/config/cp_maintenance.cgi.orig\n+++ occu/WebUI/www/config/cp_maintenance.cgi\n@@ -61,10 +61,14 @@\n       puts \"conInfo(\\\"EULA found\\\");\"\n       puts \"jQuery('#fwUpload').hide();\"\n       puts \"var dlg = new EulaDialog(translateKey('dialogEulaTitle'), data, function(result) {\"\n+        puts \"var dlgPopup = parent.top.dlgPopup;\"\n+        puts \"if (dlgPopup === undefined) {\"\n+          puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+        puts \"}\"\n         puts \"if (result == 1) {\"\n-          puts \"parent.top.dlgPopup.hide();\"\n-          puts \"parent.top.dlgPopup.setWidth(450);\"\n-          puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+          puts \"dlgPopup.hide();\"\n+          puts \"dlgPopup.setWidth(450);\"\n+          puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n         puts \"} else {\"\n           puts \"jQuery('#fwUpload').hide();\"\n           puts \"dlgPopup.hide();\"\n@@ -77,16 +81,19 @@\n \n     puts \"req.fail(function(data) {\"\n       puts \"conInfo(\\\"EULA not available\\\");\"\n-      puts \"parent.top.dlgPopup.hide();\"\n-      puts \"parent.top.dlgPopup.setWidth(450);\"\n-      puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+      puts \"var dlgPopup = parent.top.dlgPopup;\"\n+      puts \"if (dlgPopup === undefined) {\"\n+        puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+      puts \"}\"\n+      puts \"dlgPopup.hide();\"\n+      puts \"dlgPopup.setWidth(450);\"\n+      puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n     puts \"});\"\n   }\n }\n \n proc action_firmware_update_confirm {} {\n   global env\n-   cgi_debug -on\n   http_head\n   division {class=\"popupTitle\"} {\n     #puts \"Softwareupdate - Best&auml;tigung\"\n@@ -266,7 +273,7 @@\n }\n \n proc action_firmware_update_cancel {} {\n-  global env\n+  global env filename\n \n   if {[getProduct] < 3} {\n     catch {exec rm /var/new_firmware.tar.gz}\n@@ -432,9 +439,7 @@\n             table_row {\n               td {width=\"20\"} {}\n               table_data {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=firmware_form {target=firmware_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=firmware_upload\n-                  export downloadOnly=$downloadOnly\n+                form \"/config/fileupload.ccc?sid=$sid&action=firmware_upload&downloadOnly=$downloadOnly&url=$env(SCRIPT_NAME)\" {target=firmware_upload_iframe} name=firmware_form enctype=multipart/form-data method=post {\n                   file_button firmware_file size=30 maxlength=1000000\n                 }\n                 puts {<iframe name=\"firmware_upload_iframe\" style=\"display: none;\"></iframe>}\n@@ -1020,7 +1025,7 @@\n \n proc action_firmware_upload {} {\n \n-  global env sid downloadOnly\n+  global env sid downloadOnly filename\n \n   if { [catch { import directDownload } error] } {\n     set directDownload false\n@@ -1029,10 +1034,7 @@\n   http_head\n   \n   if { $directDownload } {\n-    set filename \"/tmp/fup.tgz\"\n-  } else {\n-    import_file -client firmware_file\n-    set filename [lindex $firmware_file 0]\n+    set filename \"/usr/local/tmp/firmwareUpdateFile\"\n   }\n \n   if {[getProduct] < 3} {\n@@ -1102,10 +1104,14 @@\n \n   cgi_javascript {\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n-    puts \"parent.top.dlgPopup.hide();\"\n-    puts \"parent.top.dlgPopup.setWidth(450);\"\n-    puts \"parent.top.dlgPopup.downloadOnly = $downloadOnly;\"\n-    puts \"parent.top.dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n+    puts \"var dlgPopup = parent.top.dlgPopup;\"\n+    puts \"if (dlgPopup === undefined) {\"\n+      puts \"dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+    puts \"}\"\n+    puts \"dlgPopup.hide();\"\n+    puts \"dlgPopup.setWidth(450);\"\n+    puts \"dlgPopup.downloadOnly = $downloadOnly;\"\n+    puts \"dlgPopup.LoadFromFile(url, \\\"action=$action\\\");\"\n   }\n }\n \n@@ -1393,10 +1399,10 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n \n   set action \"put_page\"\n   set downloadOnly 0\n--- occu/WebUI/www/config/cp_network.cgi.orig\n+++ occu/WebUI/www/config/cp_network.cgi\n@@ -149,6 +149,8 @@\n   \n   http_head\n \n+  file rename -force -- \"/usr/local/tmp/server.pem\" \"/etc/config/server.pem\"\n+\n   put_message \"\\${dialogSettingsNetworkMessageCertificateTitle}\" \"\\${dialogSettingsNetworkMessageCertificateCCURestart}\" {\\${btnNewLogin} \"window.location.href='/';\"}\n   \n   #save DOM\n@@ -245,37 +247,43 @@\n }\n \n proc action_cert_upload {} {\n-  global env sid\n-  cd /tmp/\n+  global env sid filename\n+  cd /usr/local/tmp/\n   \n   http_head\n-  import_file -client cert_file\n-  file rename -force -- [lindex $cert_file 0] \"/var/server.pem\"\n-  \n-  set filename [open \"/var/server.pem\" r]\n-  gets $filename line\n-  close $filename\n+  set fp [open \"$filename\" r]\n+  gets $fp line\n+  close $fp\n   #puts $line;\n   if { [string equal $line \"-----BEGIN RSA PRIVATE KEY-----\"] == 1 || [string equal $line \"-----BEGIN PRIVATE KEY-----\"] == 1} {\n-    file copy -force -- \"/var/server.pem\" \"/etc/config/server.pem\"\n-    file delete \"/var/server.pem\"\n+    file rename -force -- $filename \"/usr/local/tmp/server.pem\"\n     \n     cgi_javascript {\n       puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n       puts {\n-        parent.top.dlgPopup.hide();\n-        parent.top.dlgPopup.setWidth(600);\n-        parent.top.dlgPopup.LoadFromFile(url, \"action=cert_update_confirm\");\n+        var dlgPopup = parent.top.dlgPopup;\n+        if (dlgPopup === undefined) {\n+          dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+        }\n+        dlgPopup.hide();\n+        dlgPopup.setWidth(600);\n+        dlgPopup.LoadFromFile(url, \"action=cert_update_confirm\");\n       }\n     }\n   } else {\n+    file delete -force -- $filename\n+\n     cgi_javascript {\n-    puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n-    puts {\n-      parent.top.dlgPopup.hide();\n-      parent.top.dlgPopup.setWidth(600);\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=cert_update_failed\");\n-    }\n+      puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n+      puts {\n+        var dlgPopup = parent.top.dlgPopup;\n+        if (dlgPopup === undefined) {\n+          dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+        }\n+        dlgPopup.hide();\n+        dlgPopup.setWidth(600);\n+        dlgPopup.LoadFromFile(url, \"action=cert_update_failed\");\n+      }\n     }\n   }\n }\n@@ -459,8 +467,7 @@\n             table_row {\n               table_data {width=\"20\"} {}\n               table_data {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=cert_form {target=cert_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=cert_upload\n+                form \"/config/fileupload.ccc?sid=$sid&action=cert_upload&url=$env(SCRIPT_NAME)\" name=cert_form {target=cert_upload_iframe} enctype=multipart/form-data method=post {\n                   file_button cert_file size=30 maxlength=1000000\n                 }\n                 puts {<iframe name=\"cert_upload_iframe\" style=\"display: none;\"></iframe>}\n@@ -774,13 +781,16 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n   set action \"put_page\"\n+  set filename \"\"\n \n   catch { import action }\n+  catch { import filename }\n+\n   if {[session_requestisvalid 8] > 0} then action_$action\n }\n \n--- occu/WebUI/www/config/cp_security.cgi.orig\n+++ occu/WebUI/www/config/cp_security.cgi\n@@ -928,8 +928,6 @@\n proc action_put_page {} {\n   global env sid\n \n-  cgi_debug -on\n-\n   http_head\n   division {class=\"popupTitle j_translate\"} {\n     puts \"\\${dialogSettingsSecurityTitle}\"\n@@ -1022,8 +1020,7 @@\n             table_row {\n               td {width=\"20\"} {}\n               table_data {align=\"left\"} {colspan=\"2\"} {\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=backup_form {target=config_upload_iframe} enctype=multipart/form-data method=post {\n-                  export action=backup_upload\n+                form \"/config/fileupload.ccc?sid=$sid&action=backup_upload&url=$env(SCRIPT_NAME)\" name=backup_form {target=config_upload_iframe} enctype=multipart/form-data method=post {\n                   file_button backup_file size=20 maxlength=1000000\n                 }\n                 puts {<iframe name=\"config_upload_iframe\" class=\"CLASS20820\" style=\"display: none;\"></iframe>}\n@@ -1536,19 +1533,21 @@\n }\n \n proc action_backup_upload {} {\n-  global env sid\n-  cd /tmp/\n+  global env sid filename\n+  cd /usr/local/tmp/\n \n+  file rename -force -- $filename \"/usr/local/tmp/new_config.tar\"\n   http_head\n-  import_file -client backup_file\n-  file rename -force -- [lindex $backup_file 0] \"/tmp/new_config.tar\"\n   cgi_javascript {\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\n     puts {\n-      //parent.top.ProgressBar.IncCounter(\"Backup wurde \u010f\u017c\u02ddbertragen.\");\n-      parent.top.dlgPopup.hide();\n-      parent.top.dlgPopup.setWidth(400);\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=backup_restore_check\");\n+      var dlgPopup = parent.top.dlgPopup;\n+      if (dlgPopup === undefined) {\n+        dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\n+      }\n+      dlgPopup.hide();\n+      dlgPopup.setWidth(400);\n+      dlgPopup.LoadFromFile(url, \"action=backup_restore_check\");\n     }\n   }\n }\n@@ -1617,14 +1616,16 @@\n cgi_eval {\n   #cgi_debug -on\n   cgi_input\n-  catch {\n-    import debug\n-    cgi_debug -on\n-  }\n+  #catch {\n+  #  import debug\n+  #  cgi_debug -on\n+  #}\n \n   set action \"put_page\"\n+  set filename \"\"\n \n   catch { import action }\n+  catch { import filename }\n \n   if {[session_requestisvalid 8] > 0} then action_$action\n }\n--- occu/WebUI/www/config/cp_software.cgi.orig\n+++ occu/WebUI/www/config/cp_software.cgi\n@@ -353,8 +353,7 @@\n                 puts \"\\${dialogSettingsExtraSoftwareLblSelectExtraSoftware}\"\r\n               }\r\n               table_data {\r\n-                form \"$env(SCRIPT_NAME)?sid=$sid\" name=upload_form {target=image_upload_iframe} enctype=multipart/form-data method=post {\r\n-                  export action=image_upload\r\n+                form \"/config/fileupload.ccc?sid=$sid&action=image_upload&url=$env(SCRIPT_NAME)\" name=upload_form {target=image_upload_iframe} enctype=multipart/form-data method=post {\r\n                   file_button firmware_file size=30 maxlength=1000000\r\n                 }\r\n                 puts {<iframe name=\"image_upload_iframe\" style=\"display: none;\"></iframe>}\r\n@@ -487,24 +486,27 @@\n }\r\n \r\n proc action_image_upload {} {\r\n-  global env sid\r\n-  cd /tmp/\r\n+  global env sid filename\r\n+  cd /usr/local/tmp/\r\n   \r\n   http_head\r\n-  import_file -client firmware_file\r\n   if {[getProduct] < 3} {\r\n     # CCU2\r\n-    file rename -force -- [lindex $firmware_file 0] \"/var/new_firmware.tar.gz\"\r\n+    file rename -force -- $filename \"/var/new_firmware.tar.gz\"\r\n   } else {\r\n     # CCU3\r\n-    file rename -force -- [lindex $firmware_file 0] \"/usr/local/tmp/new_addon.tar.gz\"\r\n+    file rename -force -- $filename \"/usr/local/tmp/new_addon.tar.gz\"\r\n   }\r\n   cgi_javascript {\r\n     puts \"var url = \\\"$env(SCRIPT_NAME)?sid=$sid\\\";\"\r\n     puts {\r\n-      parent.top.dlgPopup.hide();\r\n-      parent.top.dlgPopup.setWidth(600);\r\n-      parent.top.dlgPopup.LoadFromFile(url, \"action=install_confirm\");\r\n+      var dlgPopup = parent.top.dlgPopup;\r\n+      if (dlgPopup === undefined) {\r\n+        dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\r\n+      }\r\n+      dlgPopup.hide();\r\n+      dlgPopup.setWidth(600);\r\n+      dlgPopup.LoadFromFile(url, \"action=install_confirm\");\r\n     }\r\n   }\r\n }\r\n@@ -519,14 +521,16 @@\n cgi_eval {\r\n   #cgi_debug -on\r\n   cgi_input\r\n-  catch {\r\n-    import debug\r\n-    cgi_debug -on\r\n-  }\r\n+  #catch {\r\n+  #  import debug\r\n+  #  cgi_debug -on\r\n+  #}\r\n \r\n   set action \"put_page\"\r\n+  set filename \"\"\r\n \r\n   catch { import action }\r\n+  catch { import filename }\r\n \r\n   if {[session_requestisvalid 8] > 0} then action_$action\r\n }\r\n--- occu/WebUI/www/config/fileupload.ccc.orig\n+++ occu/WebUI/www/config/fileupload.ccc\n@@ -0,0 +1,109 @@\n+#!/bin/sh\n+# shellcheck shell=dash disable=SC3036,SC3010,SC2034,SC3060,SC2116,SC3045 source=/dev/null\n+\n+echo -ne \"Content-Type: text/html; charset=iso-8859-1\\r\\n\\r\\n\"\n+\n+# allow only POST requests\n+if [[ \"${REQUEST_METHOD}\" != \"POST\" ]]; then\n+  echo \"ERROR: no POST request\"\n+  exit 1\n+fi\n+\n+# fake read boundary+disposition, etc.\n+read -r boundary\n+read -r disposition\n+read -r ctype\n+read -r junk\n+\n+# get length\n+a=${#boundary}\n+b=${#disposition}\n+c=${#ctype}\n+d=0\n+\n+# Due to \\n\\r line breaks we have 2 extra bytes per line read,\n+# 6 + 2 newlines == 10 junk bytes\n+a=$((a*2+b+c+d+10))\n+\n+# calculate the expected content length using\n+# HTTP_CONTENT_LENGTH or CONTENT_LENGTH\n+if [[ -z \"${HTTP_CONTENT_LENGTH}\" ]]; then\n+  HTTP_CONTENT_LENGTH=${CONTENT_LENGTH}\n+fi\n+SIZE=$((HTTP_CONTENT_LENGTH-a))\n+\n+# continue only if SIZE > 0\n+if [[ \"${SIZE}\" -le 0 ]]; then\n+  echo \"ERROR: POST size <= 0\"\n+  exit 1\n+fi\n+\n+# extract known params from QUERY_STRING only\n+while IFS= read -r -d '&' KEYVAL && [[ -n \"$KEYVAL\" ]]; do\n+  case ${KEYVAL%%=*} in\n+    url) url=${KEYVAL#*=} ;;\n+    sid) sid=${KEYVAL#*=} ;;\n+    action) action=${KEYVAL#*=} ;;\n+    downloadOnly) downloadOnly=${KEYVAL#*=} ;;\n+  esac\n+done <<END\n+$(echo \"${QUERY_STRING}&\")\n+END\n+\n+# check for url and action parameter\n+if [[ -z \"${url}\" ]] || [[ -z \"${action}\" ]]; then\n+  echo \"ERROR: missing required URL parameters\"\n+  exit 1\n+fi\n+\n+# check for a valid ADMIN session id\n+if [[ \"${#sid}\" -eq 12 ]]; then\n+  # parse the current version\n+  [[ -r /VERSION ]] && . /VERSION\n+\n+  # use CCU.getVersion which is allowed only for Admins\n+  RES=$(/usr/bin/curl http://127.0.0.1/api/homematic.cgi \\\n+                      -H 'Content-Type: application/json' \\\n+                      -d \"{\\\"method\\\":\\\"CCU.getVersion\\\",\\\"params\\\":{\\\"_session_id_\\\": \\\"${sid//@}\\\"}}\")\n+\n+  # check the curl result contains the current\n+  # version number or not\n+  if ! echo \"${RES}\" | grep -q \"${VERSION}\"; then\n+    echo \"ERROR: no valid admin session id\"\n+    exit 1\n+  fi\n+else\n+  echo \"ERROR: invalid session id\"\n+  exit 1\n+fi\n+\n+# write out the data\n+filename=$(mktemp -p /usr/local/tmp)\n+if ! /usr/bin/head -q -c ${SIZE} >\"${filename}\"; then\n+  echo \"ERROR: head failure\"\n+  exit 1\n+fi\n+\n+echo \"<html>\"\n+echo \" <head>\"\n+echo \"  <script>\"\n+echo \"   <!--- Hide script from browsers that don't understand JavaScript\"\n+echo \"   var url = '${url}?sid=${sid}';\"\n+echo \"   var dlgPopup = parent.top.dlgPopup;\"\n+echo \"   if (dlgPopup === undefined) {\"\n+echo \"     dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\n+echo \"   }\"\n+echo \"   if (dlgPopup !== undefined) {\"\n+echo \"     dlgPopup.hide();\"\n+echo \"     dlgPopup.setWidth(450);\"\n+if [[ -n \"${downloadOnly}\" ]]; then\n+  echo \"     dlgPopup.downloadOnly=${downloadOnly};\"\n+fi\n+echo \"     dlgPopup.LoadFromFile(url, 'action=${action}&filename=${filename}');\"\n+echo \"   }\"\n+echo \"   // End hiding -->\"\n+echo \"  </script>\"\n+echo \" </head>\"\n+echo \"</html>\"\n+\n+exit 0\n--- occu/WebUI/www/tcl/extern/cgi.tcl.orig\n+++ occu/WebUI/www/tcl/extern/cgi.tcl\n@@ -3,15 +3,11 @@\n # cgi.tcl - routines for writing CGI scripts in Tcl\n # Author: Don Libes <libes@nist.gov>, January '95\n #\n-# Minor changes by Lars Reemts, eQ-3\n-#\n # These routines implement the code described in the paper\n # \"Writing CGI scripts in Tcl\" which appeared in the Tcl '96 conference.\n # Please read the paper before using this code.  The paper is:\n # http://expect.nist.gov/doc/cgi.pdf\n #\n-# F. Werner:\n-#  add \"charset=iso-8859-1\" to header Content-Type\n ##################################################\n \n ##################################################\n@@ -27,12 +23,10 @@\n \n     if {0 == [llength $args]} {\n \tcgi_content_type\n-    cgi_puts \"Expires: Sun, 06 Nov 1994 00:00:00 GMT\"\n     } else {\n \tif {[catch {uplevel 1 [lindex $args 0]} errMsg]} {\n \t    set savedInfo $errorInfo\n \t    cgi_content_type\n-        cgi_puts \"Expires: Sun, 06 Nov 1994 00:00:00 GMT\"\n \t}\n     }\n     cgi_puts \"\"\n@@ -310,7 +304,7 @@\n \t\t\t    catch {cgi_mail_add \"HTTP_HOST: $env(HTTP_HOST)\"}\n \t\t\t    catch {cgi_mail_add \"REMOTE_HOST: $env(REMOTE_HOST)\"}\n \t\t\t    catch {cgi_mail_add \"REMOTE_ADDR: $env(REMOTE_ADDR)\"}\n-\t\t\t    cgi_mail_add \"cgi.tcl version: 1.8.0\"\n+\t\t\t    cgi_mail_add \"cgi.tcl version: 1.10.0\"\n \t\t\t    cgi_mail_add \"input:\"\n \t\t\t    catch {cgi_mail_add $_cgi(input)}\n \t\t\t    cgi_mail_add \"cookie:\"\n@@ -472,10 +466,9 @@\n     foreach a [lrange $args 1 end] {\n         append buf \" $a\"\n     }\n-    return \"$buf ></iframe>\"\n+    return \"$buf />\"\n }\n \n-\n # generate an image reference (<img ...>)\n # first arg is image url\n # other args are passed through into <img> tag\n@@ -497,7 +490,7 @@\n \n # names an anchor so that it can be linked to\n proc cgi_anchor_name {name} {\n-    return \"<a name=\\\"$name\\\"></a>\"\n+    return \"<a name=\\\"$name\\\"/>\"\n }\n \n proc cgi_base {args} {\n@@ -513,7 +506,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \" / >\"\n+    cgi_puts \" />\"\n }\n \n ##################################################\n@@ -531,7 +524,8 @@\n \tregsub -all -nocase {%([a-f0-9][a-f0-9])} $buf {\\\\u00\\1} buf\n \n \t# process \\u unicode mapped chars\n-\tencoding convertfrom [subst -novar -nocommand $buf]\n+\tencoding convertfrom $::_cgi(queryencoding) \\\n+\t\t [subst -novar -nocommand $buf]\n     }\n } elseif {[info tclversion] >= 8.1} {\n     proc cgi_unquote_input buf {\n@@ -982,7 +976,7 @@\n # from cgi_http_head.\n proc cgi_http_equiv {type contents} {\n     _cgi_http_head_implicit\n-    cgi_puts \"<meta http-equiv=\\\"$type\\\" content=[cgi_dquote_html $contents]></meta>\"\n+    cgi_puts \"<meta http-equiv=\\\"$type\\\" content=[cgi_dquote_html $contents]/>\"\n }\n \n # Do whatever you want with meta tags.\n@@ -1010,7 +1004,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \"></link>\"\n+    cgi_puts \"/>\"\n }\n \n proc cgi_name {args} {\n@@ -1114,7 +1108,7 @@\n \n proc cgi_noscript {args} {\n     cgi_puts \"<noscript[_cgi_lrange $args 0 [expr [llength $args]-2]]>\"\n-    _cgi_close_proc_push {puts \"</noscript>\"}\n+    _cgi_close_proc_push {cgi_puts \"</noscript>\"}\n \n     uplevel 1 [lindex $args end]\n \n@@ -1135,7 +1129,7 @@\n     if {$q != \"=\"} {\n \tset value \"\"\n     }\n-    cgi_puts \"<param name=\\\"$name\\\" value=[cgi_dquote_html $value]></param>\"\n+    cgi_puts \"<param name=\\\"$name\\\" value=[cgi_dquote_html $value]/>\"\n }\n \n # record any proc's that must be called prior to displaying an error\n@@ -1254,7 +1248,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_put \"></isindex>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -1294,15 +1288,31 @@\n \t} else {\n \t    set length $env(CONTENT_LENGTH)\n \t    if {0!=[string compare $length \"-1\"]} {\n-        if { $length } {\n-\t\t    set input [read stdin $env(CONTENT_LENGTH)]\t\t\n-        } else {\n-            set input \"\"\n-        }\n+\t\tset input [read stdin $env(CONTENT_LENGTH)]\t\t\n \t    } else {\n \t\tset _cgi(client_error) 1\n \t\terror \"Your browser generated a content-length of -1 during a POST method.\"\n \t    }\n+\t    if {[info tclversion] >= 8.1} {\n+                # guess query encoding from Content-Type header\n+                if {[info exists env(CONTENT_TYPE)] \\\n+                    && [regexp -nocase -- {charset=([^[:space:]]+)} $env(CONTENT_TYPE) m cs]} {\n+                    if {[regexp -nocase -- {iso-?8859-([[:digit:]]+)} $cs m d]} {\n+                        set _cgi(queryencoding) \"iso8859-$d\"\n+                    } elseif {[regexp -nocase -- {windows-([[:digit:]]+)} $cs m d]} {\n+                        set _cgi(queryencoding) \"cp$d\"\n+                    } elseif {0==[string compare -nocase $cs \"utf-8\"]} {\n+                        set _cgi(queryencoding) \"utf-8\"\n+                    } elseif {0==[string compare -nocase $cs \"utf-16\"]} {\n+                        set _cgi(queryencoding) \"unicode\"\n+                    }\n+                    if { [lsearch -exact [encoding names] _cgi(queryencoding)] == -1} {\n+                        set _cgi(queryencoding) [encoding system]\n+                    }\n+                } else {\n+                    set _cgi(queryencoding) [encoding system]\n+                }\n+            }\n \t}\n \t# save input for possible diagnostics later\n \tset _cgi(input) $input\n@@ -1345,30 +1355,6 @@\n     }\n }\n \n-set _cgi_read_line_buffer \"\"\n-proc _cgi_read_line {fin bufvar crlfvar} {\n-    global _cgi_read_line_buffer\n-    upvar $bufvar buffer\n-    upvar $crlfvar crlf\n-    set line_end [string first \"\\r\\n\" $_cgi_read_line_buffer]\n-    while {($line_end < 0 ) && ![eof $fin]} {\n-        append _cgi_read_line_buffer [read $fin 65536]\n-        set line_end [string first \"\\r\\n\" $_cgi_read_line_buffer]\n-    }\n-    if {$line_end >= 0} { \n-        incr line_end -1\n-        set buffer [string range $_cgi_read_line_buffer 0 $line_end]\n-        set crlf \"\\r\\n\"\n-        set _cgi_read_line_buffer [string range $_cgi_read_line_buffer [expr $line_end + 3] end]\n-        return 1\n-    } else {\n-        set buffer $_cgi_read_line_buffer\n-        set crlf \"\"\n-        set _cgi_read_line_buffer \"\"\n-        return [expr ([string length $buffer] > 0)]\n-    }\n-}\n-\n proc _cgi_input_multipart {fin} {\n     global env _cgi _cgi_uservar _cgi_userfile\n \n@@ -1379,121 +1365,7 @@\n \t# can hang and we won't get to the termination code\n \tset dbg_fout [open $dbg_filename w]\n \tset _cgi(input) $dbg_filename\n-\tcatch {fconfigure $dbg_fout -translation binary -encoding binary}\n-    }\n-\n-    # figure out boundary\n-    if {0==[regexp boundary=(.*) $env(CONTENT_TYPE) dummy boundary]} {\n-\tset _cgi(client_error) 1\n-\terror \"Your browser failed to generate a \\\"boundary=\\\" line in a multipart response (CONTENT_TYPE: $env(CONTENT_TYPE)).  Please upgrade (or fix) your browser.\"\n-    }\n-\n-    set boundary \"--$boundary\"\n-    set boundary_length [string length $boundary]\n-    \n-    # don't corrupt or modify uploads yet allow Tcl 7.4 to work\n-    catch {fconfigure $fin -translation binary -encoding binary}\n-\n-    # get first boundary line\n-    gets $fin buf\n-    if {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n-\n-    set filecount 0\n-    set crlf \"\"\n-    while {1} {\n-\t# process Content-Disposition:\n-\tif { ! [_cgi_read_line $fin buf crlf] } break\n-\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-\tcatch {unset filename}\n-\tcatch {unset varname}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n-\tif {0==[info exists varname]} {\n-\t    set _cgi(client_error) 1\n-\t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n-\t}\t    \n-\t# Lame-o encoding (on Netscape at least) doesn't escape field\n-\t# delimiters (like quotes)!!  Since all we've ever seen is filename=\n-\t# at end of line, assuming nothing follows.  Sigh.\n-\tregexp {filename=\"(.*)\"} $buf dummy filename\n-\n-\t# Skip remaining headers until blank line.\n-\t# Content-Type: can appear here.\n-\tset conttype \"\"\n-\twhile {1} {\n-            if { ! [_cgi_read_line $fin buf crlf] } break\n-\t    if {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-\t    if {0==[string compare $buf \"\"]} break\n-\t    regexp -nocase \"^Content-Type:\\[ \\t]+(.*)\\r\\n\" $buf$crlf x conttype\n-\t}\n-\n-\tif {[info exists filename]} {\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Reading file $filename\"; flush $dbg_fout}\n-\t    # read the part into a file\n-\t    set foutname /tmp/CGI[pid].[incr filecount]\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n-\t    set fout [open $foutname w]\n-\t    # \"catch\" permits this to work with Tcl 7.4\n-\t    catch {fconfigure $fout -translation binary -encoding binary}\n-\t    _cgi_set_uservar $varname [list $foutname $filename $conttype]\n-\t    set _cgi_userfile($varname) [list $foutname $filename $conttype]\n-            \n-            set leftover \"\"\n-            while { 1 } {\n-                if { ! [_cgi_read_line $fin buf crlf] } {\n-                    set _cgi(client_error) 1\n-                    error \"Unexpected end of input data.\"\n-                }\n-\t\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-                if {[string compare -length $boundary_length $buf $boundary] == 0} {\n-                    if {[string first \"--\" $buf $boundary_length]>=0} {set eof 1}\n-                    break;\n-                }\n-                puts -nonewline $fout $leftover$buf\n-                set leftover $crlf\n-            }\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Read file $filename\"; flush $dbg_fout}\n-\t    close $fout\n-\t    unset fout\n-        \n-\t} else {\n-\t    # read the part into a variable\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>Reading variable $varname\"; flush $dbg_fout}\n-\t    set val \"\"\n-            set leftover \"\"\n-            while { 1 } {\n-                if { ! [_cgi_read_line $fin buf crlf] } {\n-                    set _cgi(client_error) 1\n-                    error \"Unexpected end of input data.\"\n-                }\n-\t\tif {[info exists dbg_fout]} {puts -nonewline $dbg_fout $buf$crlf; flush $dbg_fout}\n-                if {[string compare -length $boundary_length $buf $boundary] == 0} {\n-                    if {[string first \"--\" $buf $boundary_length]>=0} {set eof 1}\n-                    break;\n-                }\n-                append val $leftover$buf\n-                set leftover $crlf\n-\t    }\n-\t    _cgi_set_uservar $varname $val\n-            if {[info exists dbg_fout]} {puts $dbg_fout \">>>>>$varname=$val\"; flush $dbg_fout}\n-\t}\n-        if {[info exists eof]} break\n-    }\n-    if {[info exists dbg_fout]} {close $dbg_fout}\n-}\n-\n-proc _cgi_input_multipart_buggy {fin} {\n-    global env _cgi _cgi_uservar _cgi_userfile\n-\n-    cgi_debug -noprint {\n-\t# save file for debugging purposes\n-\tset dbg_filename [file join $_cgi(tmpdir) CGIdbg.[pid]]\n-\t# explicitly flush all writes to fout, because sometimes the writer\n-\t# can hang and we won't get to the termination code\n-\tset dbg_fout [open $dbg_filename w]\n-\tset _cgi(input) $dbg_filename\n-\tcatch {fconfigure $dbg_fout -translation binary -encoding binary}\n+\tcatch {fconfigure $dbg_fout -translation binary}\n     }\n \n     # figure out boundary\n@@ -1513,24 +1385,28 @@\n     set boundary --$boundary\n \n     # don't corrupt or modify uploads yet allow Tcl 7.4 to work\n-    catch {fconfigure $fin -translation binary -encoding binary}\n+    catch {fconfigure $fin -translation binary}\n \n     # get first boundary line\n     gets $fin buf\n     if {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n \n-    set filecount 0\n+    set _cgi(file,filecount) 0\n+\n     while {1} {\n \t# process Content-Disposition:\n \tif {-1 == [gets $fin buf]} break\n \tif {[info exists dbg_fout]} {puts $dbg_fout $buf; flush $dbg_fout}\n \tcatch {unset filename}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n+\tregexp {name=\"([^\"]*)\"} $buf dummy varname\n \tif {0==[info exists varname]} {\n-\t    set _cgi(client_error) 1\n-\t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n+\t    # lynx violates spec and doesn't use quotes, so try again but\n+\t    # assume space is delimiter\n+\t    regexp {name=([^ ]*)} $buf dummy varname\n+\t    if {0==[info exists varname]} {\n+\t\tset _cgi(client_error) 1\n+\t\terror \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n+\t    }\n \t}\t    \n \t# Lame-o encoding (on Netscape at least) doesn't escape field\n \t# delimiters (like quotes)!!  Since all we've ever seen is filename=\n@@ -1548,14 +1424,18 @@\n \t}\n \n \tif {[info exists filename]} {\n+\t    if {$_cgi(file,filecount) > $_cgi(file,filelimit)} {\n+\t\terror \"Too many files submitted.  Max files allowed: $_cgi(file,filelimit)\"\n+\t    }\n+\n \t    # read the part into a file\n-\t    set foutname /tmp/CGI[pid].[incr filecount]\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n+\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr _cgi(file,filecount)]]\n \t    set fout [open $foutname w]\n \t    # \"catch\" permits this to work with Tcl 7.4\n-\t    catch {fconfigure $fout -translation binary -encoding binary}\n+\t    catch {fconfigure $fout -translation binary}\n \t    _cgi_set_uservar $varname [list $foutname $filename $conttype]\n \t    set _cgi_userfile($varname) [list $foutname $filename $conttype]\n+\n \t    #\n \t    # Look for a boundary line preceded by \\r\\n.\n \t    #\n@@ -1583,10 +1463,13 @@\n \t\t    puts -nonewline $fout $leftover$buf\n \t\t    set leftover \"\\n\"\n \t\t}\n+ \t\tif {[file size $foutname] > $_cgi(file,charlimit)} {\n+\t\t    error \"File size exceeded.  Max file size allowed: $_cgi(file,charlimit)\"\n+\t\t}\n \t    }\n+\n \t    close $fout\n \t    unset fout\n-        \n \t} else {\n \t    # read the part into a variable\n \t    set val \"\"\n@@ -1672,7 +1555,8 @@\n \t}\n     }\n \n-    set filecount 0\n+    set _cgi(file,filecount) 0\n+\n     while {1} {\n \t# process Content-Disposition:\n \texpect {\n@@ -1684,9 +1568,7 @@\n \t    eof break\n \t}\n \tcatch {unset filename}\n-\tforeach b $buf {\n-\t    regexp {^name=\"(.*)\"} $b dummy varname\n-\t}\n+\tregexp {name=\"([^\"]*)\"} $buf dummy varname\n \tif {0==[info exists varname]} {\n \t    set _cgi(client_error) 1\n \t    error \"In response to a request for a multipart form, your browser generated a part header without a name field.  Please upgrade (or fix) your browser.\"\n@@ -1712,8 +1594,12 @@\n \t}\n \n \tif {[info exists filename]} {\n+\t    if {$_cgi(file,filecount) > $_cgi(file,filelimit)} {\n+\t\terror \"Too many files submitted.  Max files allowed: $_cgi(file,filelimit)\"\n+\t    }\n+\n \t    # read the part into a file\n-\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr filecount]]\n+\t    set foutname [file join $_cgi(tmpdir) CGI[pid].[incr _cgi(file,filecount)]]\n \t    spawn -open [open $foutname w]\n \t    set fout_sid $spawn_id\n \n@@ -1967,6 +1853,23 @@\n     }\n }\n \n+# set the urlencoding\n+proc cgi_urlencoding {{encoding \"\"}} {\n+    global _cgi \n+    \n+    set result [expr {[info exists _cgi(queryencoding)]\n+                      ? $_cgi(queryencoding)\n+                      : \"\"}]\n+\n+    # check if the encoding is available \n+    if {[info tclversion] >= 8.1\n+        && [lsearch -exact [encoding names] $encoding] != -1 } {\t\n+        set _cgi(queryencoding) $encoding\n+    }\n+\n+    return $result\n+}\n+\n ##################################################\n # button support\n ##################################################\n@@ -2088,7 +1991,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_put \"></area>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -2182,6 +2085,15 @@\n     cgi_put \"<input type=file name=\\\"$name\\\"[_cgi_list_to_string $args]/>\"\n }\n \n+# establish a per-file limit for uploads\n+\n+proc cgi_file_limit {files chars} {\n+    global _cgi\n+\n+    set _cgi(file,filelimit) $files\n+    set _cgi(file,charlimit) $chars\n+}\n+\n ##################################################\n # select support\n ##################################################\n@@ -2224,7 +2136,7 @@\n     }\n     if {[info exists selected_if_equal]} {\n \tif {0 == [string compare $selected_if_equal $value]} {\n-\t    cgi_put \" selected=\\\"selected\\\"\"\n+\t    cgi_put \" selected\"\n \t}\n     }\n     cgi_puts \">[cgi_quote_html $o]</option>\"\n@@ -2251,7 +2163,7 @@\n \t    }\n \t}\n     }\n-    cgi_put \"></embed>\"\n+    cgi_put \"/>\"\n }\n \n ##################################################\n@@ -2525,7 +2437,7 @@\n ##################################################\n \n proc cgi_stylesheet {href} {\n-    puts \"<link rel=stylesheet href=\\\"$href\\\" type=\\\"text/css\\\"></link>\"\n+    puts \"<link rel=stylesheet href=\\\"$href\\\" type=\\\"text/css\\\"/>\"\n }\n \n proc cgi_span {args} {\n@@ -2584,7 +2496,7 @@\n \t    cgi_put \" $a\"\n \t}\n     }\n-    cgi_puts \"></frame>\"\n+    cgi_puts \"/>\"\n }\n \n proc cgi_noframes {args} {\n@@ -2672,33 +2584,50 @@\n \n # User-defined procedure to generate DOCTYPE declaration\n proc cgi_doctype {} {\n-\t#Zeile hinzugef\u00fcgt: 22.02.2007, Badberg, ELV\n-\t#puts \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\"\n-\n-  # AG, eQ-3, 29.01.2013\n-\tputs \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\t\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-\n-\t#quirks puts \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\"\n+    # AG, eQ-3, 29.01.2013\n+    puts \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"  \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n }\n \n ##################################################\n # do some initialization\n ##################################################\n \n-cgi_name \"\"\n-cgi_root \"\"\n-cgi_body_args \"\"\n+# cgi_init initializes to a known state.\n+\n+proc cgi_init {} {\n+    global _cgi\n+    unset _cgi\n+\n+    # set explicitly for speed\n+    set _cgi(debug) -off\n+    set _cgi(buffer_nl) \"\\n\"\n \n-# email addr of person responsible for this service\n-cgi_admin_mail_addr \"root\"\t;# you should override this!\n+    cgi_name \"\"\n+    cgi_root \"\"\n+    cgi_body_args \"\"\n+    cgi_file_limit 10 100000000\n \n-# most services won't have an actual email addr\n-cgi_mail_addr \"CGI script - do not reply\"\n+    if {[info tclversion] >= 8.1} {\n+\t# set initial urlencoding\n+\tif { [lsearch -exact [encoding names] \"utf-8\"] != -1} {\n+\t    cgi_urlencoding \"utf-8\"\n+\t} else {\n+\t    cgi_urlencoding [encoding system]\n+\t}\n+    }\n+\n+    # email addr of person responsible for this service\n+    cgi_admin_mail_addr \"root\"\t;# you should override this!\n+\n+    # most services won't have an actual email addr\n+    cgi_mail_addr \"CGI script - do not reply\"\n+}\n+cgi_init\n \n # deduce tmp directory\n switch $tcl_platform(platform) {\n     unix {\n-\tset _cgi(tmpdir) /tmp\n+\tset _cgi(tmpdir) /usr/local/tmp\n     } macintosh {\n \tset _cgi(tmpdir) [pwd]\n     } default {\n@@ -2711,4 +2640,4 @@\n # regexp for matching attr=val\n set _cgi(attr,regexp) \"^(\\[^=]*)=(\\[^\\\"].*)\"\n \n-package provide cgi 1.8.0\n+package provide cgi 1.10.0\n--- occu/WebUI/www/webui/webui.js.orig\n+++ occu/WebUI/www/webui/webui.js\n@@ -7365,6 +7365,7 @@\n     this.currentPageOptions  = options;\n     \n     this.currentPage.enter(options);\n+    window.name = 'ccu-main-window';\n   },\n   \n   reload: function()\n", "#!/bin/sh\n# shellcheck shell=dash disable=SC3036,SC3010,SC2034,SC3060,SC2116,SC3045 source=/dev/null\n\necho -ne \"Content-Type: text/html; charset=iso-8859-1\\r\\n\\r\\n\"\n\n# allow only POST requests\nif [[ \"${REQUEST_METHOD}\" != \"POST\" ]]; then\n  echo \"ERROR: no POST request\"\n  exit 1\nfi\n\n# fake read boundary+disposition, etc.\nread -r boundary\nread -r disposition\nread -r ctype\nread -r junk\n\n# get length\na=${#boundary}\nb=${#disposition}\nc=${#ctype}\nd=0\n\n# Due to \\n\\r line breaks we have 2 extra bytes per line read,\n# 6 + 2 newlines == 10 junk bytes\na=$((a*2+b+c+d+10))\n\n# calculate the expected content length using\n# HTTP_CONTENT_LENGTH or CONTENT_LENGTH\nif [[ -z \"${HTTP_CONTENT_LENGTH}\" ]]; then\n  HTTP_CONTENT_LENGTH=${CONTENT_LENGTH}\nfi\nSIZE=$((HTTP_CONTENT_LENGTH-a))\n\n# continue only if SIZE > 0\nif [[ \"${SIZE}\" -le 0 ]]; then\n  echo \"ERROR: POST size <= 0\"\n  exit 1\nfi\n\n# extract known params from QUERY_STRING only\nwhile IFS= read -r -d '&' KEYVAL && [[ -n \"$KEYVAL\" ]]; do\n  case ${KEYVAL%%=*} in\n    url) url=${KEYVAL#*=} ;;\n    sid) sid=${KEYVAL#*=} ;;\n    action) action=${KEYVAL#*=} ;;\n    downloadOnly) downloadOnly=${KEYVAL#*=} ;;\n  esac\ndone <<END\n$(echo \"${QUERY_STRING}&\")\nEND\n\n# check for url and action parameter\nif [[ -z \"${url}\" ]] || [[ -z \"${action}\" ]]; then\n  echo \"ERROR: missing required URL parameters\"\n  exit 1\nfi\n\n# check for a valid ADMIN session id\nif [[ \"${#sid}\" -eq 12 ]]; then\n  # parse the current version\n  [[ -r /VERSION ]] && . /VERSION\n\n  # use CCU.getVersion which is allowed only for Admins\n  RES=$(/usr/bin/curl http://127.0.0.1/api/homematic.cgi \\\n                      -H 'Content-Type: application/json' \\\n                      -d \"{\\\"method\\\":\\\"CCU.getVersion\\\",\\\"params\\\":{\\\"_session_id_\\\": \\\"${sid//@}\\\"}}\")\n\n  # check the curl result contains the current\n  # version number or not\n  if ! echo \"${RES}\" | grep -q \"${VERSION}\"; then\n    echo \"ERROR: no valid admin session id\"\n    exit 1\n  fi\nelse\n  echo \"ERROR: invalid session id\"\n  exit 1\nfi\n\n# write out the data\nfilename=$(mktemp -p /usr/local/tmp)\nif ! /usr/bin/head -q -c ${SIZE} >\"${filename}\"; then\n  echo \"ERROR: head failure\"\n  exit 1\nfi\n\necho \"<html>\"\necho \" <head>\"\necho \"  <script>\"\necho \"   <!--- Hide script from browsers that don't understand JavaScript\"\necho \"   var url = '${url}?sid=${sid}';\"\necho \"   var dlgPopup = parent.top.dlgPopup;\"\necho \"   if (dlgPopup === undefined) {\"\necho \"     dlgPopup = window.open('', 'ccu-main-window').dlgPopup;\"\necho \"   }\"\necho \"   if (dlgPopup !== undefined) {\"\necho \"     dlgPopup.hide();\"\necho \"     dlgPopup.setWidth(450);\"\nif [[ -n \"${downloadOnly}\" ]]; then\n  echo \"     dlgPopup.downloadOnly=${downloadOnly};\"\nfi\necho \"     dlgPopup.LoadFromFile(url, 'action=${action}&filename=${filename}');\"\necho \"   }\"\necho \"   // End hiding -->\"\necho \"  </script>\"\necho \" </head>\"\necho \"</html>\"\n\nexit 0\n"], "filenames": ["buildroot-external/patches/occu/0031-WebUI-Fix-FileUpload.patch", "buildroot-external/patches/occu/0031-WebUI-Fix-FileUpload/occu/WebUI/www/config/fileupload.ccc"], "buggy_code_start_loc": [262, 2], "buggy_code_end_loc": [944, 37], "fixing_code_start_loc": [262, 2], "fixing_code_end_loc": [992, 85], "type": "CWE-78", "message": "RaspberryMatic is a free and open-source operating system for running a cloud-free smart-home using the homematicIP / HomeMatic hardware line of IoT devices. A Remote Code Execution (RCE) vulnerability in the file upload facility of the WebUI interface of RaspberryMatic exists. Missing input validation/sanitization in the file upload mechanism allows remote, unauthenticated attackers with network access to the WebUI interface to achieve arbitrary operating system command execution via shell metacharacters in the HTTP query string. Injected commands are executed as root, thus leading to a full compromise of the underlying system and all its components. Versions after `2.31.25.20180428` and prior to `3.63.8.20220330` are affected. Users are advised to update to version `3.63.8.20220330` or newer. There are currently no known workarounds to mitigate the security impact and users are advised to update to the latest version available.", "other": {"cve": {"id": "CVE-2022-24796", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-31T23:15:08.187", "lastModified": "2022-04-08T17:01:32.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RaspberryMatic is a free and open-source operating system for running a cloud-free smart-home using the homematicIP / HomeMatic hardware line of IoT devices. A Remote Code Execution (RCE) vulnerability in the file upload facility of the WebUI interface of RaspberryMatic exists. Missing input validation/sanitization in the file upload mechanism allows remote, unauthenticated attackers with network access to the WebUI interface to achieve arbitrary operating system command execution via shell metacharacters in the HTTP query string. Injected commands are executed as root, thus leading to a full compromise of the underlying system and all its components. Versions after `2.31.25.20180428` and prior to `3.63.8.20220330` are affected. Users are advised to update to version `3.63.8.20220330` or newer. There are currently no known workarounds to mitigate the security impact and users are advised to update to the latest version available."}, {"lang": "es", "value": "RaspberryMatic es un sistema operativo libre y de c\u00f3digo abierto para ejecutar una casa inteligente sin nube usando la l\u00ednea de hardware homematicIP / HomeMatic de dispositivos IoT. Se presenta una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo remota (RCE) en la funci\u00f3n de carga de archivos de la interfaz WebUI de RaspberryMatic. Una falta de comprobaci\u00f3n/saneo de la entrada en el mecanismo de carga de archivos permite a atacantes remotos y no autenticados con acceso a la red a la interfaz WebUI lograr la ejecuci\u00f3n arbitraria de comandos del sistema operativo por medio de metacaracteres de shell en la cadena de consulta HTTP. Los comandos inyectados son ejecutados como root, conllevando as\u00ed a un compromiso total del sistema subyacente y todos sus componentes. Las versiones posteriores a la \"2.31.25.20180428\" y anteriores a \"3.63.8.20220330\" est\u00e1n afectadas. Es recomendado a usuarios actualizar a versi\u00f3n \"3.63.8.20220330\" o m\u00e1s reciente. Actualmente no se conocen medidas para mitigar el impacto de seguridad y es recomendado a usuarios actualizar a la \u00faltima versi\u00f3n disponible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:raspberrymatic:raspberrymatic:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.31.25.20180428", "versionEndExcluding": "3.63.8.20220330", "matchCriteriaId": "A097A067-7101-442C-B36A-1C351163BE0B"}]}]}], "references": [{"url": "https://github.com/jens-maus/RaspberryMatic/commit/34854659a63e9fb3ad529bb413e96978c6450a53", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jens-maus/RaspberryMatic/security/advisories/GHSA-g7vv-7rmf-mff7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jens-maus/RaspberryMatic/commit/34854659a63e9fb3ad529bb413e96978c6450a53"}}