{"buggy_code": ["<?php\n/**\n * SpecialOAuth2Client.php\n * Based on TwitterLogin by David Raison, which is based on the guideline published by Dave Challis at http://blogs.ecs.soton.ac.uk/webteam/2010/04/13/254/\n * @license: LGPL (GNU Lesser General Public License) http://www.gnu.org/licenses/lgpl.html\n *\n * @file SpecialOAuth2Client.php\n * @ingroup OAuth2Client\n *\n * @author Joost de Keijzer\n * @author Nischay Nahata for Schine GmbH\n *\n * Uses the OAuth2 library https://github.com/vznet/oauth_2.0_client_php\n *\n */\n\nif ( !defined( 'MEDIAWIKI' ) ) {\n\tdie( 'This is a MediaWiki extension, and must be run from within MediaWiki.' );\n}\nrequire __DIR__.'/JsonHelper.php';\n\nclass SpecialOAuth2Client extends SpecialPage {\n\n\tprivate $_provider;\n\n\t/**\n\t * Required settings in global $wgOAuth2Client\n\t *\n\t * $wgOAuth2Client['client']['id']\n\t * $wgOAuth2Client['client']['secret']\n\t * //$wgOAuth2Client['client']['callback_url'] // extension should know\n\t *\n\t * $wgOAuth2Client['configuration']['authorize_endpoint']\n\t * $wgOAuth2Client['configuration']['access_token_endpoint']\n\t * $wgOAuth2Client['configuration']['http_bearer_token']\n\t * $wgOAuth2Client['configuration']['query_parameter_token']\n\t * $wgOAuth2Client['configuration']['api_endpoint']\n\t */\n\tpublic function __construct() {\n\n\t\tparent::__construct('OAuth2Client'); // ???: wat doet dit?\n\t\tglobal $wgOAuth2Client, $wgScriptPath;\n\t\tglobal $wgServer, $wgArticlePath;\n\n\t\trequire __DIR__ . '/vendors/oauth2-client/vendor/autoload.php';\n\n\t\t$this->_provider = new \\League\\OAuth2\\Client\\Provider\\GenericProvider([\n\t\t\t'clientId'                => $wgOAuth2Client['client']['id'],    // The client ID assigned to you by the provider\n\t\t\t'clientSecret'            => $wgOAuth2Client['client']['secret'],   // The client password assigned to you by the provider\n\t\t\t'redirectUri'             => $wgOAuth2Client['configuration']['redirect_uri'],\n\t\t\t'urlAuthorize'            => $wgOAuth2Client['configuration']['authorize_endpoint'],\n\t\t\t'urlAccessToken'          => $wgOAuth2Client['configuration']['access_token_endpoint'],\n\t\t\t'urlResourceOwnerDetails' => $wgOAuth2Client['configuration']['api_endpoint'],\n\t\t\t'scopes'                  => $wgOAuth2Client['configuration']['scopes']\n\t\t]);\n\t}\n\n\t// default method being called by a specialpage\n\tpublic function execute( $parameter ){\n\t\t$this->setHeaders();\n\t\tswitch($parameter){\n\t\t\tcase 'redirect':\n\t\t\t\t$this->_redirect();\n\t\t\tbreak;\n\t\t\tcase 'callback':\n\t\t\t\t$this->_handleCallback();\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$this->_default();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tprivate function _redirect() {\n\n\t\tglobal $wgRequest, $wgOut;\n\t\t$wgRequest->getSession()->persist();\n\t\t$wgRequest->getSession()->set('returnto', $wgRequest->getVal( 'returnto' ));\n\n\t\t// Fetch the authorization URL from the provider; this returns the\n\t\t// urlAuthorize option and generates and applies any necessary parameters\n\t\t// (e.g. state).\n\t\t$authorizationUrl = $this->_provider->getAuthorizationUrl();\n\n\t\t// Get the state generated for you and store it to the session.\n\t\t$wgRequest->getSession()->set('oauth2state', $this->_provider->getState());\n\t\t$wgRequest->getSession()->save();\n\n\t\t// Redirect the user to the authorization URL.\n\t\t$wgOut->redirect( $authorizationUrl );\n\t}\n\n\tprivate function _handleCallback(){\n\t\ttry {\n\n\t\t\t// Try to get an access token using the authorization code grant.\n\t\t\t$accessToken = $this->_provider->getAccessToken('authorization_code', [\n\t\t\t\t'code' => $_GET['code']\n\t\t\t]);\n\t\t} catch (\\League\\OAuth2\\Client\\Provider\\Exception\\IdentityProviderException $e) {\n\n\t\t\t// Failed to get the access token or user details.\n\t\t\texit($e->getMessage());\n\n\t\t}\n\n\t\t$resourceOwner = $this->_provider->getResourceOwner($accessToken);\n\t\t$user = $this->_userHandling( $resourceOwner->toArray() );\n\t\t$user->setCookies();\n\n\t\tglobal $wgOut, $wgRequest;\n\t\t$title = null;\n\t\t$wgRequest->getSession()->persist();\n\t\tif( $wgRequest->getSession()->exists('returnto') ) {\n\t\t\t$title = Title::newFromText( $wgRequest->getSession()->get('returnto') );\n\t\t\t$wgRequest->getSession()->remove('returnto');\n\t\t\t$wgRequest->getSession()->save();\n\t\t}\n\n\t\tif( !$title instanceof Title || 0 > $title->mArticleID ) {\n\t\t\t$title = Title::newMainPage();\n\t\t}\n\t\t$wgOut->redirect( $title->getFullURL() );\n\t\treturn true;\n\t}\n\n\tprivate function _default(){\n\t\tglobal $wgOAuth2Client, $wgOut, $wgUser, $wgScriptPath, $wgExtensionAssetsPath;\n\t\t$service_name = ( isset( $wgOAuth2Client['configuration']['service_name'] ) && 0 < strlen( $wgOAuth2Client['configuration']['service_name'] ) ? $wgOAuth2Client['configuration']['service_name'] : 'OAuth2' );\n\n\t\t$wgOut->setPagetitle( wfMessage( 'oauth2client-login-header', $service_name)->text() );\n\t\tif ( !$wgUser->isLoggedIn() ) {\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-you-can-login-to-this-wiki-with-oauth2', $service_name );\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-login-with-oauth2', $this->getTitle( 'redirect' )->getPrefixedURL(), $service_name );\n\n\t\t} else {\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-youre-already-loggedin' );\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected function _userHandling( $response ) {\n\t\tglobal $wgOAuth2Client, $wgAuth, $wgRequest;\n\n\t\t$username = JsonHelper::extractValue($response, $wgOAuth2Client['configuration']['username']);\n\t\t$email =  JsonHelper::extractValue($response, $wgOAuth2Client['configuration']['email']);\n\n\t\t$user = User::newFromName($username, 'creatable');\n\t\tif (!$user) {\n\t\t\tthrow new MWException('Could not create user with username:' . $username);\n\t\t\tdie();\n\t\t}\n\t\t$user->setRealName($username);\n\t\t$user->setEmail($email);\n\t\t$user->load();\n\t\tif ( !( $user instanceof User && $user->getId() ) ) {\n\t\t\t$user->addToDatabase();\n\t\t\t// MediaWiki recommends below code instead of addToDatabase to create user but it seems to fail.\n\t\t\t// $authManager = MediaWiki\\Auth\\AuthManager::singleton();\n\t\t\t// $authManager->autoCreateUser( $user, MediaWiki\\Auth\\AuthManager::AUTOCREATE_SOURCE_SESSION );\n\t\t\t$user->confirmEmail();\n\t\t}\n\t\t$user->setToken();\n\n\t\t// Setup the session\n\t\t$wgRequest->getSession()->persist();\n\t\t$user->setCookies();\n\t\t$this->getContext()->setUser( $user );\n\t\t$user->saveSettings();\n\t\tglobal $wgUser;\n\t\t$wgUser = $user;\n\t\t$sessionUser = User::newFromSession($this->getRequest());\n\t\t$sessionUser->load();\n\t\treturn $user;\n\t}\n\n}\n", "{\n\t\"name\": \"MW-OAuth2Client\",\n\t\"version\": \"0.3\",\n\t\"author\": [\n\t\t\"[http://dekeijzer.org Joost de Keijzer]\",\n\t\t\"[https://www.mediawiki.org/wiki/User:Nischayn22 Nischay Nahata]\",\n\t\t\"[https://star-made.org Schine GmbH]\"\n\t],\n\t\"url\": \"https://www.mediawiki.org/wiki/Extension:OAuth2_Client\",\n\t\"descriptionmsg\": \"oauth2client-act-as-a-client-to-any-oauth2-server\",\n\t\"license-name\": \"LGPL-3.0\",\n\t\"type\": \"other\",\n\t\"AutoloadClasses\": {\n\t\t\"OAuth2ClientHooks\": \"OAuth2Client.php\",\n\t\t\"SpecialOAuth2Client\": \"SpecialOAuth2Client.php\"\n\t},\n\t\"ExtensionMessagesFiles\": {\n\t\t\"OAuth2ClientAlias\": \"OAuth2Client.alias.php\"\n\t},\n\t\"Hooks\": {\n\t\t\"PersonalUrls\": [\n\t\t\t\"OAuth2ClientHooks::onPersonalUrls\"\n\t\t]\n\t},\n\t\"SpecialPages\": {\n\t\t\"OAuth2Client\": \"SpecialOAuth2Client\"\n\t},\n\t\"MessagesDirs\": {\n\t\t\"MyExtension\": [\n\t\t\t\"i18n\"\n\t\t]\n\t},\n\t\"manifest_version\": 1\n}\n"], "fixing_code": ["<?php\n/**\n * SpecialOAuth2Client.php\n * Based on TwitterLogin by David Raison, which is based on the guideline published by Dave Challis at http://blogs.ecs.soton.ac.uk/webteam/2010/04/13/254/\n * @license: LGPL (GNU Lesser General Public License) http://www.gnu.org/licenses/lgpl.html\n *\n * @file SpecialOAuth2Client.php\n * @ingroup OAuth2Client\n *\n * @author Joost de Keijzer\n * @author Nischay Nahata for Schine GmbH\n *\n * Uses the OAuth2 library https://github.com/vznet/oauth_2.0_client_php\n *\n */\n\nif ( !defined( 'MEDIAWIKI' ) ) {\n\tdie( 'This is a MediaWiki extension, and must be run from within MediaWiki.' );\n}\nrequire __DIR__.'/JsonHelper.php';\n\nclass SpecialOAuth2Client extends SpecialPage {\n\n\tprivate $_provider;\n\n\t/**\n\t * Required settings in global $wgOAuth2Client\n\t *\n\t * $wgOAuth2Client['client']['id']\n\t * $wgOAuth2Client['client']['secret']\n\t * //$wgOAuth2Client['client']['callback_url'] // extension should know\n\t *\n\t * $wgOAuth2Client['configuration']['authorize_endpoint']\n\t * $wgOAuth2Client['configuration']['access_token_endpoint']\n\t * $wgOAuth2Client['configuration']['http_bearer_token']\n\t * $wgOAuth2Client['configuration']['query_parameter_token']\n\t * $wgOAuth2Client['configuration']['api_endpoint']\n\t */\n\tpublic function __construct() {\n\n\t\tparent::__construct('OAuth2Client'); // ???: wat doet dit?\n\t\tglobal $wgOAuth2Client, $wgScriptPath;\n\t\tglobal $wgServer, $wgArticlePath;\n\n\t\trequire __DIR__ . '/vendors/oauth2-client/vendor/autoload.php';\n\n\t\t$this->_provider = new \\League\\OAuth2\\Client\\Provider\\GenericProvider([\n\t\t\t'clientId'                => $wgOAuth2Client['client']['id'],    // The client ID assigned to you by the provider\n\t\t\t'clientSecret'            => $wgOAuth2Client['client']['secret'],   // The client password assigned to you by the provider\n\t\t\t'redirectUri'             => $wgOAuth2Client['configuration']['redirect_uri'],\n\t\t\t'urlAuthorize'            => $wgOAuth2Client['configuration']['authorize_endpoint'],\n\t\t\t'urlAccessToken'          => $wgOAuth2Client['configuration']['access_token_endpoint'],\n\t\t\t'urlResourceOwnerDetails' => $wgOAuth2Client['configuration']['api_endpoint'],\n\t\t\t'scopes'                  => $wgOAuth2Client['configuration']['scopes']\n\t\t]);\n\t}\n\n\t// default method being called by a specialpage\n\tpublic function execute( $parameter ){\n\t\t$this->setHeaders();\n\t\tswitch($parameter){\n\t\t\tcase 'redirect':\n\t\t\t\t$this->_redirect();\n\t\t\tbreak;\n\t\t\tcase 'callback':\n\t\t\t\t$this->_handleCallback();\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$this->_default();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tprivate function _redirect() {\n\n\t\tglobal $wgRequest, $wgOut;\n\t\t$wgRequest->getSession()->persist();\n\t\t$wgRequest->getSession()->set('returnto', $wgRequest->getVal( 'returnto' ));\n\n\t\t// Fetch the authorization URL from the provider; this returns the\n\t\t// urlAuthorize option and generates and applies any necessary parameters\n\t\t// (e.g. state).\n\t\t$authorizationUrl = $this->_provider->getAuthorizationUrl();\n\n\t\t// Get the state generated for you and store it to the session.\n\t\t$wgRequest->getSession()->set('oauth2state', $this->_provider->getState());\n\t\t$wgRequest->getSession()->save();\n\n\t\t// Redirect the user to the authorization URL.\n\t\t$wgOut->redirect( $authorizationUrl );\n\t}\n\n\tprivate function _handleCallback(){\n\t\tglobal $wgRequest;\n\n\t\ttry {\n\t\t\t$storedState = $wgRequest->getSession()->get('oauth2state');\n\t\t\t// Enforce the `state` parameter to prevent clickjacking/CSRF\n\t\t\tif(isset($storedState) && $storedState != $_GET['state']) {\n\t\t\t\tif(isset($_GET['state'])) {\n\t\t\t\t\tthrow new UnexpectedValueException(\"State parameter of callback does not match original state\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new UnexpectedValueException(\"Required state parameter missing\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try to get an access token using the authorization code grant.\n\t\t\t$accessToken = $this->_provider->getAccessToken('authorization_code', [\n\t\t\t\t'code' => $_GET['code']\n\t\t\t]);\n\t\t} catch (\\League\\OAuth2\\Client\\Provider\\Exception\\IdentityProviderException $e) {\n\t\t\texit($e->getMessage()); // Failed to get the access token or user details.\n\t\t} catch (UnexpectedValueException $e) {\n\t\t\texit($e->getMessage());\n\t\t}\n\n\t\t$resourceOwner = $this->_provider->getResourceOwner($accessToken);\n\t\t$user = $this->_userHandling( $resourceOwner->toArray() );\n\t\t$user->setCookies();\n\n\t\tglobal $wgOut, $wgRequest;\n\t\t$title = null;\n\t\t$wgRequest->getSession()->persist();\n\t\tif( $wgRequest->getSession()->exists('returnto') ) {\n\t\t\t$title = Title::newFromText( $wgRequest->getSession()->get('returnto') );\n\t\t\t$wgRequest->getSession()->remove('returnto');\n\t\t\t$wgRequest->getSession()->save();\n\t\t}\n\n\t\tif( !$title instanceof Title || 0 > $title->mArticleID ) {\n\t\t\t$title = Title::newMainPage();\n\t\t}\n\t\t$wgOut->redirect( $title->getFullURL() );\n\t\treturn true;\n\t}\n\n\tprivate function _default(){\n\t\tglobal $wgOAuth2Client, $wgOut, $wgUser, $wgScriptPath, $wgExtensionAssetsPath;\n\t\t$service_name = ( isset( $wgOAuth2Client['configuration']['service_name'] ) && 0 < strlen( $wgOAuth2Client['configuration']['service_name'] ) ? $wgOAuth2Client['configuration']['service_name'] : 'OAuth2' );\n\n\t\t$wgOut->setPagetitle( wfMessage( 'oauth2client-login-header', $service_name)->text() );\n\t\tif ( !$wgUser->isLoggedIn() ) {\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-you-can-login-to-this-wiki-with-oauth2', $service_name );\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-login-with-oauth2', $this->getTitle( 'redirect' )->getPrefixedURL(), $service_name );\n\n\t\t} else {\n\t\t\t$wgOut->addWikiMsg( 'oauth2client-youre-already-loggedin' );\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected function _userHandling( $response ) {\n\t\tglobal $wgOAuth2Client, $wgAuth, $wgRequest;\n\n\t\t$username = JsonHelper::extractValue($response, $wgOAuth2Client['configuration']['username']);\n\t\t$email =  JsonHelper::extractValue($response, $wgOAuth2Client['configuration']['email']);\n\n\t\t$user = User::newFromName($username, 'creatable');\n\t\tif (!$user) {\n\t\t\tthrow new MWException('Could not create user with username:' . $username);\n\t\t\tdie();\n\t\t}\n\t\t$user->setRealName($username);\n\t\t$user->setEmail($email);\n\t\t$user->load();\n\t\tif ( !( $user instanceof User && $user->getId() ) ) {\n\t\t\t$user->addToDatabase();\n\t\t\t// MediaWiki recommends below code instead of addToDatabase to create user but it seems to fail.\n\t\t\t// $authManager = MediaWiki\\Auth\\AuthManager::singleton();\n\t\t\t// $authManager->autoCreateUser( $user, MediaWiki\\Auth\\AuthManager::AUTOCREATE_SOURCE_SESSION );\n\t\t\t$user->confirmEmail();\n\t\t}\n\t\t$user->setToken();\n\n\t\t// Setup the session\n\t\t$wgRequest->getSession()->persist();\n\t\t$user->setCookies();\n\t\t$this->getContext()->setUser( $user );\n\t\t$user->saveSettings();\n\t\tglobal $wgUser;\n\t\t$wgUser = $user;\n\t\t$sessionUser = User::newFromSession($this->getRequest());\n\t\t$sessionUser->load();\n\t\treturn $user;\n\t}\n\n}\n", "{\n\t\"name\": \"MW-OAuth2Client\",\n\t\"version\": \"0.4\",\n\t\"author\": [\n\t\t\"[http://dekeijzer.org Joost de Keijzer]\",\n\t\t\"[https://www.mediawiki.org/wiki/User:Nischayn22 Nischay Nahata]\",\n\t\t\"[https://star-made.org Schine GmbH]\"\n\t],\n\t\"url\": \"https://www.mediawiki.org/wiki/Extension:OAuth2_Client\",\n\t\"descriptionmsg\": \"oauth2client-act-as-a-client-to-any-oauth2-server\",\n\t\"license-name\": \"LGPL-3.0\",\n\t\"type\": \"other\",\n\t\"AutoloadClasses\": {\n\t\t\"OAuth2ClientHooks\": \"OAuth2Client.php\",\n\t\t\"SpecialOAuth2Client\": \"SpecialOAuth2Client.php\"\n\t},\n\t\"ExtensionMessagesFiles\": {\n\t\t\"OAuth2ClientAlias\": \"OAuth2Client.alias.php\"\n\t},\n\t\"Hooks\": {\n\t\t\"PersonalUrls\": [\n\t\t\t\"OAuth2ClientHooks::onPersonalUrls\"\n\t\t]\n\t},\n\t\"SpecialPages\": {\n\t\t\"OAuth2Client\": \"SpecialOAuth2Client\"\n\t},\n\t\"MessagesDirs\": {\n\t\t\"MyExtension\": [\n\t\t\t\"i18n\"\n\t\t]\n\t},\n\t\"manifest_version\": 1\n}\n"], "filenames": ["SpecialOAuth2Client.php", "extension.json"], "buggy_code_start_loc": [94, 3], "buggy_code_end_loc": [106, 4], "fixing_code_start_loc": [95, 3], "fixing_code_end_loc": [115, 4], "type": "CWE-352", "message": "In the OAuth2 Client extension before 0.4 for MediaWiki, a CSRF vulnerability exists due to the OAuth2 state parameter not being checked in the callback function.", "other": {"cve": {"id": "CVE-2019-15150", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-19T04:15:13.517", "lastModified": "2023-03-08T01:21:08.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the OAuth2 Client extension before 0.4 for MediaWiki, a CSRF vulnerability exists due to the OAuth2 state parameter not being checked in the callback function."}, {"lang": "es", "value": "En la extensi\u00f3n OAuth2 Client versiones anteriores a 0.4 para MediaWiki, se presenta una vulnerabilidad de tipo CSRF debido a que el par\u00e1metro state de OAuth2 no se ha comprobado en la funci\u00f3n callback."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:schine.games:mw-oauth2client:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4", "matchCriteriaId": "478AD8F3-B58D-4CE8-8546-3E5506694BA5"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/154140/MediaWiki-OAuth2-Client-0.3-Cross-Site-Request-Forgery.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2019/Aug/25", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/08/19/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/Schine/MW-OAuth2Client/commit/6a4fe4500ddd72ad4e826d9d63b2d69512bd10d1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Schine/MW-OAuth2Client/releases/tag/v0.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://seclists.org/bugtraq/2019/Aug/32", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Schine/MW-OAuth2Client/commit/6a4fe4500ddd72ad4e826d9d63b2d69512bd10d1"}}