{"buggy_code": ["/*\n * IPVS         An implementation of the IP virtual server support for the\n *              LINUX operating system.  IPVS is now implemented as a module\n *              over the NetFilter framework. IPVS can be used to build a\n *              high-performance and highly available server based on a\n *              cluster of servers.\n *\n * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>\n *              Peter Kese <peter.kese@ijs.si>\n *              Julian Anastasov <ja@ssi.bg>\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Changes:\n *\n */\n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/workqueue.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/mutex.h>\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#ifdef CONFIG_IP_VS_IPV6\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#endif\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\n#include <asm/uaccess.h>\n\n#include <net/ip_vs.h>\n\n/* semaphore for IPVS sockopts. And, [gs]etsockopt may sleep. */\nstatic DEFINE_MUTEX(__ip_vs_mutex);\n\n/* lock for service table */\nstatic DEFINE_RWLOCK(__ip_vs_svc_lock);\n\n/* lock for table with the real services */\nstatic DEFINE_RWLOCK(__ip_vs_rs_lock);\n\n/* lock for state and timeout tables */\nstatic DEFINE_RWLOCK(__ip_vs_securetcp_lock);\n\n/* lock for drop entry handling */\nstatic DEFINE_SPINLOCK(__ip_vs_dropentry_lock);\n\n/* lock for drop packet handling */\nstatic DEFINE_SPINLOCK(__ip_vs_droppacket_lock);\n\n/* 1/rate drop and drop-entry variables */\nint ip_vs_drop_rate = 0;\nint ip_vs_drop_counter = 0;\nstatic atomic_t ip_vs_dropentry = ATOMIC_INIT(0);\n\n/* number of virtual services */\nstatic int ip_vs_num_services = 0;\n\n/* sysctl variables */\nstatic int sysctl_ip_vs_drop_entry = 0;\nstatic int sysctl_ip_vs_drop_packet = 0;\nstatic int sysctl_ip_vs_secure_tcp = 0;\nstatic int sysctl_ip_vs_amemthresh = 1024;\nstatic int sysctl_ip_vs_am_droprate = 10;\nint sysctl_ip_vs_cache_bypass = 0;\nint sysctl_ip_vs_expire_nodest_conn = 0;\nint sysctl_ip_vs_expire_quiescent_template = 0;\nint sysctl_ip_vs_sync_threshold[2] = { 3, 50 };\nint sysctl_ip_vs_nat_icmp_send = 0;\n\n\n#ifdef CONFIG_IP_VS_DEBUG\nstatic int sysctl_ip_vs_debug_level = 0;\n\nint ip_vs_get_debug_level(void)\n{\n\treturn sysctl_ip_vs_debug_level;\n}\n#endif\n\n#ifdef CONFIG_IP_VS_IPV6\n/* Taken from rt6_fill_node() in net/ipv6/route.c, is there a better way? */\nstatic int __ip_vs_addr_is_local_v6(const struct in6_addr *addr)\n{\n\tstruct rt6_info *rt;\n\tstruct flowi fl = {\n\t\t.oif = 0,\n\t\t.nl_u = {\n\t\t\t.ip6_u = {\n\t\t\t\t.daddr = *addr,\n\t\t\t\t.saddr = { .s6_addr32 = {0, 0, 0, 0} }, } },\n\t};\n\n\trt = (struct rt6_info *)ip6_route_output(&init_net, NULL, &fl);\n\tif (rt && rt->rt6i_dev && (rt->rt6i_dev->flags & IFF_LOOPBACK))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n#endif\n/*\n *\tupdate_defense_level is called from keventd and from sysctl,\n *\tso it needs to protect itself from softirqs\n */\nstatic void update_defense_level(void)\n{\n\tstruct sysinfo i;\n\tstatic int old_secure_tcp = 0;\n\tint availmem;\n\tint nomem;\n\tint to_change = -1;\n\n\t/* we only count free and buffered memory (in pages) */\n\tsi_meminfo(&i);\n\tavailmem = i.freeram + i.bufferram;\n\t/* however in linux 2.5 the i.bufferram is total page cache size,\n\t   we need adjust it */\n\t/* si_swapinfo(&i); */\n\t/* availmem = availmem - (i.totalswap - i.freeswap); */\n\n\tnomem = (availmem < sysctl_ip_vs_amemthresh);\n\n\tlocal_bh_disable();\n\n\t/* drop_entry */\n\tspin_lock(&__ip_vs_dropentry_lock);\n\tswitch (sysctl_ip_vs_drop_entry) {\n\tcase 0:\n\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\t\tsysctl_ip_vs_drop_entry = 2;\n\t\t} else {\n\t\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\t} else {\n\t\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\t\tsysctl_ip_vs_drop_entry = 1;\n\t\t};\n\t\tbreak;\n\tcase 3:\n\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\tbreak;\n\t}\n\tspin_unlock(&__ip_vs_dropentry_lock);\n\n\t/* drop_packet */\n\tspin_lock(&__ip_vs_droppacket_lock);\n\tswitch (sysctl_ip_vs_drop_packet) {\n\tcase 0:\n\t\tip_vs_drop_rate = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tip_vs_drop_rate = ip_vs_drop_counter\n\t\t\t\t= sysctl_ip_vs_amemthresh /\n\t\t\t\t(sysctl_ip_vs_amemthresh-availmem);\n\t\t\tsysctl_ip_vs_drop_packet = 2;\n\t\t} else {\n\t\t\tip_vs_drop_rate = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tip_vs_drop_rate = ip_vs_drop_counter\n\t\t\t\t= sysctl_ip_vs_amemthresh /\n\t\t\t\t(sysctl_ip_vs_amemthresh-availmem);\n\t\t} else {\n\t\t\tip_vs_drop_rate = 0;\n\t\t\tsysctl_ip_vs_drop_packet = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tip_vs_drop_rate = sysctl_ip_vs_am_droprate;\n\t\tbreak;\n\t}\n\tspin_unlock(&__ip_vs_droppacket_lock);\n\n\t/* secure_tcp */\n\twrite_lock(&__ip_vs_securetcp_lock);\n\tswitch (sysctl_ip_vs_secure_tcp) {\n\tcase 0:\n\t\tif (old_secure_tcp >= 2)\n\t\t\tto_change = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tif (old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t\tsysctl_ip_vs_secure_tcp = 2;\n\t\t} else {\n\t\t\tif (old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tif (old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t} else {\n\t\t\tif (old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t\tsysctl_ip_vs_secure_tcp = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (old_secure_tcp < 2)\n\t\t\tto_change = 1;\n\t\tbreak;\n\t}\n\told_secure_tcp = sysctl_ip_vs_secure_tcp;\n\tif (to_change >= 0)\n\t\tip_vs_protocol_timeout_change(sysctl_ip_vs_secure_tcp>1);\n\twrite_unlock(&__ip_vs_securetcp_lock);\n\n\tlocal_bh_enable();\n}\n\n\n/*\n *\tTimer for checking the defense\n */\n#define DEFENSE_TIMER_PERIOD\t1*HZ\nstatic void defense_work_handler(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(defense_work, defense_work_handler);\n\nstatic void defense_work_handler(struct work_struct *work)\n{\n\tupdate_defense_level();\n\tif (atomic_read(&ip_vs_dropentry))\n\t\tip_vs_random_dropentry();\n\n\tschedule_delayed_work(&defense_work, DEFENSE_TIMER_PERIOD);\n}\n\nint\nip_vs_use_count_inc(void)\n{\n\treturn try_module_get(THIS_MODULE);\n}\n\nvoid\nip_vs_use_count_dec(void)\n{\n\tmodule_put(THIS_MODULE);\n}\n\n\n/*\n *\tHash table: for virtual service lookups\n */\n#define IP_VS_SVC_TAB_BITS 8\n#define IP_VS_SVC_TAB_SIZE (1 << IP_VS_SVC_TAB_BITS)\n#define IP_VS_SVC_TAB_MASK (IP_VS_SVC_TAB_SIZE - 1)\n\n/* the service table hashed by <protocol, addr, port> */\nstatic struct list_head ip_vs_svc_table[IP_VS_SVC_TAB_SIZE];\n/* the service table hashed by fwmark */\nstatic struct list_head ip_vs_svc_fwm_table[IP_VS_SVC_TAB_SIZE];\n\n/*\n *\tHash table: for real service lookups\n */\n#define IP_VS_RTAB_BITS 4\n#define IP_VS_RTAB_SIZE (1 << IP_VS_RTAB_BITS)\n#define IP_VS_RTAB_MASK (IP_VS_RTAB_SIZE - 1)\n\nstatic struct list_head ip_vs_rtable[IP_VS_RTAB_SIZE];\n\n/*\n *\tTrash for destinations\n */\nstatic LIST_HEAD(ip_vs_dest_trash);\n\n/*\n *\tFTP & NULL virtual service counters\n */\nstatic atomic_t ip_vs_ftpsvc_counter = ATOMIC_INIT(0);\nstatic atomic_t ip_vs_nullsvc_counter = ATOMIC_INIT(0);\n\n\n/*\n *\tReturns hash value for virtual service\n */\nstatic __inline__ unsigned\nip_vs_svc_hashkey(int af, unsigned proto, const union nf_inet_addr *addr,\n\t\t  __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (proto^ntohl(addr_fold)^(porth>>IP_VS_SVC_TAB_BITS)^porth)\n\t\t& IP_VS_SVC_TAB_MASK;\n}\n\n/*\n *\tReturns hash value of fwmark for virtual service lookup\n */\nstatic __inline__ unsigned ip_vs_svc_fwm_hashkey(__u32 fwmark)\n{\n\treturn fwmark & IP_VS_SVC_TAB_MASK;\n}\n\n/*\n *\tHashes a service in the ip_vs_svc_table by <proto,addr,port>\n *\tor in the ip_vs_svc_fwm_table by fwmark.\n *\tShould be called with locked tables.\n */\nstatic int ip_vs_svc_hash(struct ip_vs_service *svc)\n{\n\tunsigned hash;\n\n\tif (svc->flags & IP_VS_SVC_F_HASHED) {\n\t\tpr_err(\"%s(): request for already hashed, called from %pF\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t/*\n\t\t *  Hash it by <protocol,addr,port> in ip_vs_svc_table\n\t\t */\n\t\thash = ip_vs_svc_hashkey(svc->af, svc->protocol, &svc->addr,\n\t\t\t\t\t svc->port);\n\t\tlist_add(&svc->s_list, &ip_vs_svc_table[hash]);\n\t} else {\n\t\t/*\n\t\t *  Hash it by fwmark in ip_vs_svc_fwm_table\n\t\t */\n\t\thash = ip_vs_svc_fwm_hashkey(svc->fwmark);\n\t\tlist_add(&svc->f_list, &ip_vs_svc_fwm_table[hash]);\n\t}\n\n\tsvc->flags |= IP_VS_SVC_F_HASHED;\n\t/* increase its refcnt because it is referenced by the svc table */\n\tatomic_inc(&svc->refcnt);\n\treturn 1;\n}\n\n\n/*\n *\tUnhashes a service from ip_vs_svc_table/ip_vs_svc_fwm_table.\n *\tShould be called with locked tables.\n */\nstatic int ip_vs_svc_unhash(struct ip_vs_service *svc)\n{\n\tif (!(svc->flags & IP_VS_SVC_F_HASHED)) {\n\t\tpr_err(\"%s(): request for unhash flagged, called from %pF\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t/* Remove it from the ip_vs_svc_table table */\n\t\tlist_del(&svc->s_list);\n\t} else {\n\t\t/* Remove it from the ip_vs_svc_fwm_table table */\n\t\tlist_del(&svc->f_list);\n\t}\n\n\tsvc->flags &= ~IP_VS_SVC_F_HASHED;\n\tatomic_dec(&svc->refcnt);\n\treturn 1;\n}\n\n\n/*\n *\tGet service by {proto,addr,port} in the service table.\n */\nstatic inline struct ip_vs_service *\n__ip_vs_service_get(int af, __u16 protocol, const union nf_inet_addr *vaddr,\n\t\t    __be16 vport)\n{\n\tunsigned hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for \"full\" addressed entries */\n\thash = ip_vs_svc_hashkey(af, protocol, vaddr, vport);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_table[hash], s_list){\n\t\tif ((svc->af == af)\n\t\t    && ip_vs_addr_equal(af, &svc->addr, vaddr)\n\t\t    && (svc->port == vport)\n\t\t    && (svc->protocol == protocol)) {\n\t\t\t/* HIT */\n\t\t\tatomic_inc(&svc->usecnt);\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n *\tGet service by {fwmark} in the service table.\n */\nstatic inline struct ip_vs_service *\n__ip_vs_svc_fwm_get(int af, __u32 fwmark)\n{\n\tunsigned hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for fwmark addressed entries */\n\thash = ip_vs_svc_fwm_hashkey(fwmark);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[hash], f_list) {\n\t\tif (svc->fwmark == fwmark && svc->af == af) {\n\t\t\t/* HIT */\n\t\t\tatomic_inc(&svc->usecnt);\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct ip_vs_service *\nip_vs_service_get(int af, __u32 fwmark, __u16 protocol,\n\t\t  const union nf_inet_addr *vaddr, __be16 vport)\n{\n\tstruct ip_vs_service *svc;\n\n\tread_lock(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tCheck the table hashed by fwmark first\n\t */\n\tif (fwmark && (svc = __ip_vs_svc_fwm_get(af, fwmark)))\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the table hashed by <protocol,addr,port>\n\t *\tfor \"full\" addressed entries\n\t */\n\tsvc = __ip_vs_service_get(af, protocol, vaddr, vport);\n\n\tif (svc == NULL\n\t    && protocol == IPPROTO_TCP\n\t    && atomic_read(&ip_vs_ftpsvc_counter)\n\t    && (vport == FTPDATA || ntohs(vport) >= PROT_SOCK)) {\n\t\t/*\n\t\t * Check if ftp service entry exists, the packet\n\t\t * might belong to FTP data connections.\n\t\t */\n\t\tsvc = __ip_vs_service_get(af, protocol, vaddr, FTPPORT);\n\t}\n\n\tif (svc == NULL\n\t    && atomic_read(&ip_vs_nullsvc_counter)) {\n\t\t/*\n\t\t * Check if the catch-all port (port zero) exists\n\t\t */\n\t\tsvc = __ip_vs_service_get(af, protocol, vaddr, 0);\n\t}\n\n  out:\n\tread_unlock(&__ip_vs_svc_lock);\n\n\tIP_VS_DBG_BUF(9, \"lookup service: fwm %u %s %s:%u %s\\n\",\n\t\t      fwmark, ip_vs_proto_name(protocol),\n\t\t      IP_VS_DBG_ADDR(af, vaddr), ntohs(vport),\n\t\t      svc ? \"hit\" : \"not hit\");\n\n\treturn svc;\n}\n\n\nstatic inline void\n__ip_vs_bind_svc(struct ip_vs_dest *dest, struct ip_vs_service *svc)\n{\n\tatomic_inc(&svc->refcnt);\n\tdest->svc = svc;\n}\n\nstatic inline void\n__ip_vs_unbind_svc(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_service *svc = dest->svc;\n\n\tdest->svc = NULL;\n\tif (atomic_dec_and_test(&svc->refcnt))\n\t\tkfree(svc);\n}\n\n\n/*\n *\tReturns hash value for real service\n */\nstatic inline unsigned ip_vs_rs_hashkey(int af,\n\t\t\t\t\t    const union nf_inet_addr *addr,\n\t\t\t\t\t    __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\n\t\t& IP_VS_RTAB_MASK;\n}\n\n/*\n *\tHashes ip_vs_dest in ip_vs_rtable by <proto,addr,port>.\n *\tshould be called with locked tables.\n */\nstatic int ip_vs_rs_hash(struct ip_vs_dest *dest)\n{\n\tunsigned hash;\n\n\tif (!list_empty(&dest->d_list)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tHash by proto,addr,port,\n\t *\twhich are the parameters of the real service.\n\t */\n\thash = ip_vs_rs_hashkey(dest->af, &dest->addr, dest->port);\n\n\tlist_add(&dest->d_list, &ip_vs_rtable[hash]);\n\n\treturn 1;\n}\n\n/*\n *\tUNhashes ip_vs_dest from ip_vs_rtable.\n *\tshould be called with locked tables.\n */\nstatic int ip_vs_rs_unhash(struct ip_vs_dest *dest)\n{\n\t/*\n\t * Remove it from the ip_vs_rtable table.\n\t */\n\tif (!list_empty(&dest->d_list)) {\n\t\tlist_del(&dest->d_list);\n\t\tINIT_LIST_HEAD(&dest->d_list);\n\t}\n\n\treturn 1;\n}\n\n/*\n *\tLookup real service by <proto,addr,port> in the real service table.\n */\nstruct ip_vs_dest *\nip_vs_lookup_real_service(int af, __u16 protocol,\n\t\t\t  const union nf_inet_addr *daddr,\n\t\t\t  __be16 dport)\n{\n\tunsigned hash;\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t *\tCheck for \"full\" addressed entries\n\t *\tReturn the first found entry\n\t */\n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\tread_lock(&__ip_vs_rs_lock);\n\tlist_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {\n\t\tif ((dest->af == af)\n\t\t    && ip_vs_addr_equal(af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)\n\t\t    && ((dest->protocol == protocol) ||\n\t\t\tdest->vfwmark)) {\n\t\t\t/* HIT */\n\t\t\tread_unlock(&__ip_vs_rs_lock);\n\t\t\treturn dest;\n\t\t}\n\t}\n\tread_unlock(&__ip_vs_rs_lock);\n\n\treturn NULL;\n}\n\n/*\n *\tLookup destination by {addr,port} in the given service\n */\nstatic struct ip_vs_dest *\nip_vs_lookup_dest(struct ip_vs_service *svc, const union nf_inet_addr *daddr,\n\t\t  __be16 dport)\n{\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t * Find the destination for the given service\n\t */\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tif ((dest->af == svc->af)\n\t\t    && ip_vs_addr_equal(svc->af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)) {\n\t\t\t/* HIT */\n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Find destination by {daddr,dport,vaddr,protocol}\n * Cretaed to be used in ip_vs_process_message() in\n * the backup synchronization daemon. It finds the\n * destination to be bound to the received connection\n * on the backup.\n *\n * ip_vs_lookup_real_service() looked promissing, but\n * seems not working as expected.\n */\nstruct ip_vs_dest *ip_vs_find_dest(int af, const union nf_inet_addr *daddr,\n\t\t\t\t   __be16 dport,\n\t\t\t\t   const union nf_inet_addr *vaddr,\n\t\t\t\t   __be16 vport, __u16 protocol)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_service *svc;\n\n\tsvc = ip_vs_service_get(af, 0, protocol, vaddr, vport);\n\tif (!svc)\n\t\treturn NULL;\n\tdest = ip_vs_lookup_dest(svc, daddr, dport);\n\tif (dest)\n\t\tatomic_inc(&dest->refcnt);\n\tip_vs_service_put(svc);\n\treturn dest;\n}\n\n/*\n *  Lookup dest by {svc,addr,port} in the destination trash.\n *  The destination trash is used to hold the destinations that are removed\n *  from the service table but are still referenced by some conn entries.\n *  The reason to add the destination trash is when the dest is temporary\n *  down (either by administrator or by monitor program), the dest can be\n *  picked back from the trash, the remaining connections to the dest can\n *  continue, and the counting information of the dest is also useful for\n *  scheduling.\n */\nstatic struct ip_vs_dest *\nip_vs_trash_get_dest(struct ip_vs_service *svc, const union nf_inet_addr *daddr,\n\t\t     __be16 dport)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\n\t/*\n\t * Find the destination in trash\n\t */\n\tlist_for_each_entry_safe(dest, nxt, &ip_vs_dest_trash, n_list) {\n\t\tIP_VS_DBG_BUF(3, \"Destination %u/%s:%u still in trash, \"\n\t\t\t      \"dest->refcnt=%d\\n\",\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      atomic_read(&dest->refcnt));\n\t\tif (dest->af == svc->af &&\n\t\t    ip_vs_addr_equal(svc->af, &dest->addr, daddr) &&\n\t\t    dest->port == dport &&\n\t\t    dest->vfwmark == svc->fwmark &&\n\t\t    dest->protocol == svc->protocol &&\n\t\t    (svc->fwmark ||\n\t\t     (ip_vs_addr_equal(svc->af, &dest->vaddr, &svc->addr) &&\n\t\t      dest->vport == svc->port))) {\n\t\t\t/* HIT */\n\t\t\treturn dest;\n\t\t}\n\n\t\t/*\n\t\t * Try to purge the destination from trash if not referenced\n\t\t */\n\t\tif (atomic_read(&dest->refcnt) == 1) {\n\t\t\tIP_VS_DBG_BUF(3, \"Removing destination %u/%s:%u \"\n\t\t\t\t      \"from trash\\n\",\n\t\t\t\t      dest->vfwmark,\n\t\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->addr),\n\t\t\t\t      ntohs(dest->port));\n\t\t\tlist_del(&dest->n_list);\n\t\t\tip_vs_dst_reset(dest);\n\t\t\t__ip_vs_unbind_svc(dest);\n\t\t\tkfree(dest);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n *  Clean up all the destinations in the trash\n *  Called by the ip_vs_control_cleanup()\n *\n *  When the ip_vs_control_clearup is activated by ipvs module exit,\n *  the service tables must have been flushed and all the connections\n *  are expired, and the refcnt of each destination in the trash must\n *  be 1, so we simply release them here.\n */\nstatic void ip_vs_trash_cleanup(void)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\n\tlist_for_each_entry_safe(dest, nxt, &ip_vs_dest_trash, n_list) {\n\t\tlist_del(&dest->n_list);\n\t\tip_vs_dst_reset(dest);\n\t\t__ip_vs_unbind_svc(dest);\n\t\tkfree(dest);\n\t}\n}\n\n\nstatic void\nip_vs_zero_stats(struct ip_vs_stats *stats)\n{\n\tspin_lock_bh(&stats->lock);\n\n\tmemset(&stats->ustats, 0, sizeof(stats->ustats));\n\tip_vs_zero_estimator(stats);\n\n\tspin_unlock_bh(&stats->lock);\n}\n\n/*\n *\tUpdate a destination in the given service\n */\nstatic void\n__ip_vs_update_dest(struct ip_vs_service *svc,\n\t\t    struct ip_vs_dest *dest, struct ip_vs_dest_user_kern *udest)\n{\n\tint conn_flags;\n\n\t/* set the weight and the flags */\n\tatomic_set(&dest->weight, udest->weight);\n\tconn_flags = udest->conn_flags | IP_VS_CONN_F_INACTIVE;\n\n\t/* check if local node and update the flags */\n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6) {\n\t\tif (__ip_vs_addr_is_local_v6(&udest->addr.in6)) {\n\t\t\tconn_flags = (conn_flags & ~IP_VS_CONN_F_FWD_MASK)\n\t\t\t\t| IP_VS_CONN_F_LOCALNODE;\n\t\t}\n\t} else\n#endif\n\t\tif (inet_addr_type(&init_net, udest->addr.ip) == RTN_LOCAL) {\n\t\t\tconn_flags = (conn_flags & ~IP_VS_CONN_F_FWD_MASK)\n\t\t\t\t| IP_VS_CONN_F_LOCALNODE;\n\t\t}\n\n\t/* set the IP_VS_CONN_F_NOOUTPUT flag if not masquerading/NAT */\n\tif ((conn_flags & IP_VS_CONN_F_FWD_MASK) != 0) {\n\t\tconn_flags |= IP_VS_CONN_F_NOOUTPUT;\n\t} else {\n\t\t/*\n\t\t *    Put the real service in ip_vs_rtable if not present.\n\t\t *    For now only for NAT!\n\t\t */\n\t\twrite_lock_bh(&__ip_vs_rs_lock);\n\t\tip_vs_rs_hash(dest);\n\t\twrite_unlock_bh(&__ip_vs_rs_lock);\n\t}\n\tatomic_set(&dest->conn_flags, conn_flags);\n\n\t/* bind the service */\n\tif (!dest->svc) {\n\t\t__ip_vs_bind_svc(dest, svc);\n\t} else {\n\t\tif (dest->svc != svc) {\n\t\t\t__ip_vs_unbind_svc(dest);\n\t\t\tip_vs_zero_stats(&dest->stats);\n\t\t\t__ip_vs_bind_svc(dest, svc);\n\t\t}\n\t}\n\n\t/* set the dest status flags */\n\tdest->flags |= IP_VS_DEST_F_AVAILABLE;\n\n\tif (udest->u_threshold == 0 || udest->u_threshold > dest->u_threshold)\n\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\tdest->u_threshold = udest->u_threshold;\n\tdest->l_threshold = udest->l_threshold;\n}\n\n\n/*\n *\tCreate a destination for the given service\n */\nstatic int\nip_vs_new_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest,\n\t       struct ip_vs_dest **dest_p)\n{\n\tstruct ip_vs_dest *dest;\n\tunsigned atype;\n\n\tEnterFunction(2);\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6) {\n\t\tatype = ipv6_addr_type(&udest->addr.in6);\n\t\tif ((!(atype & IPV6_ADDR_UNICAST) ||\n\t\t\tatype & IPV6_ADDR_LINKLOCAL) &&\n\t\t\t!__ip_vs_addr_is_local_v6(&udest->addr.in6))\n\t\t\treturn -EINVAL;\n\t} else\n#endif\n\t{\n\t\tatype = inet_addr_type(&init_net, udest->addr.ip);\n\t\tif (atype != RTN_LOCAL && atype != RTN_UNICAST)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdest = kzalloc(sizeof(struct ip_vs_dest), GFP_ATOMIC);\n\tif (dest == NULL) {\n\t\tpr_err(\"%s(): no memory.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdest->af = svc->af;\n\tdest->protocol = svc->protocol;\n\tdest->vaddr = svc->addr;\n\tdest->vport = svc->port;\n\tdest->vfwmark = svc->fwmark;\n\tip_vs_addr_copy(svc->af, &dest->addr, &udest->addr);\n\tdest->port = udest->port;\n\n\tatomic_set(&dest->activeconns, 0);\n\tatomic_set(&dest->inactconns, 0);\n\tatomic_set(&dest->persistconns, 0);\n\tatomic_set(&dest->refcnt, 0);\n\n\tINIT_LIST_HEAD(&dest->d_list);\n\tspin_lock_init(&dest->dst_lock);\n\tspin_lock_init(&dest->stats.lock);\n\t__ip_vs_update_dest(svc, dest, udest);\n\tip_vs_new_estimator(&dest->stats);\n\n\t*dest_p = dest;\n\n\tLeaveFunction(2);\n\treturn 0;\n}\n\n\n/*\n *\tAdd a destination into an existing service\n */\nstatic int\nip_vs_add_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\tint ret;\n\n\tEnterFunction(2);\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tip_vs_addr_copy(svc->af, &daddr, &udest->addr);\n\n\t/*\n\t * Check if the dest already exists in the list\n\t */\n\tdest = ip_vs_lookup_dest(svc, &daddr, dport);\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t/*\n\t * Check if the dest already exists in the trash and\n\t * is from the same service\n\t */\n\tdest = ip_vs_trash_get_dest(svc, &daddr, dport);\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG_BUF(3, \"Get destination %s:%u from trash, \"\n\t\t\t      \"dest->refcnt=%d, service %u/%s:%u\\n\",\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &daddr), ntohs(dport),\n\t\t\t      atomic_read(&dest->refcnt),\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->vaddr),\n\t\t\t      ntohs(dest->vport));\n\n\t\t__ip_vs_update_dest(svc, dest, udest);\n\n\t\t/*\n\t\t * Get the destination from the trash\n\t\t */\n\t\tlist_del(&dest->n_list);\n\n\t\tip_vs_new_estimator(&dest->stats);\n\n\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t\t/*\n\t\t * Wait until all other svc users go away.\n\t\t */\n\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t\tlist_add(&dest->n_list, &svc->destinations);\n\t\tsvc->num_dests++;\n\n\t\t/* call the update_service function of its scheduler */\n\t\tif (svc->scheduler->update_service)\n\t\t\tsvc->scheduler->update_service(svc);\n\n\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate and initialize the dest structure\n\t */\n\tret = ip_vs_new_dest(svc, udest, &dest);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Add the dest entry into the list\n\t */\n\tatomic_inc(&dest->refcnt);\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t * Wait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\tlist_add(&dest->n_list, &svc->destinations);\n\tsvc->num_dests++;\n\n\t/* call the update_service function of its scheduler */\n\tif (svc->scheduler->update_service)\n\t\tsvc->scheduler->update_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tEdit a destination in the given service\n */\nstatic int\nip_vs_edit_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\n\tEnterFunction(2);\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tip_vs_addr_copy(svc->af, &daddr, &udest->addr);\n\n\t/*\n\t *  Lookup the destination list\n\t */\n\tdest = ip_vs_lookup_dest(svc, &daddr, dport);\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest doesn't exist\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\t__ip_vs_update_dest(svc, dest, udest);\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/* Wait until all other svc users go away */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/* call the update_service, because server weight may be changed */\n\tif (svc->scheduler->update_service)\n\t\tsvc->scheduler->update_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tDelete a destination (must be already unlinked from the service)\n */\nstatic void __ip_vs_del_dest(struct ip_vs_dest *dest)\n{\n\tip_vs_kill_estimator(&dest->stats);\n\n\t/*\n\t *  Remove it from the d-linked list with the real services.\n\t */\n\twrite_lock_bh(&__ip_vs_rs_lock);\n\tip_vs_rs_unhash(dest);\n\twrite_unlock_bh(&__ip_vs_rs_lock);\n\n\t/*\n\t *  Decrease the refcnt of the dest, and free the dest\n\t *  if nobody refers to it (refcnt=0). Otherwise, throw\n\t *  the destination into the trash.\n\t */\n\tif (atomic_dec_and_test(&dest->refcnt)) {\n\t\tip_vs_dst_reset(dest);\n\t\t/* simply decrease svc->refcnt here, let the caller check\n\t\t   and release the service if nobody refers to it.\n\t\t   Only user context can release destination and service,\n\t\t   and only one user context can update virtual service at a\n\t\t   time, so the operation here is OK */\n\t\tatomic_dec(&dest->svc->refcnt);\n\t\tkfree(dest);\n\t} else {\n\t\tIP_VS_DBG_BUF(3, \"Moving dest %s:%u into trash, \"\n\t\t\t      \"dest->refcnt=%d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      atomic_read(&dest->refcnt));\n\t\tlist_add(&dest->n_list, &ip_vs_dest_trash);\n\t\tatomic_inc(&dest->refcnt);\n\t}\n}\n\n\n/*\n *\tUnlink a destination from the given service\n */\nstatic void __ip_vs_unlink_dest(struct ip_vs_service *svc,\n\t\t\t\tstruct ip_vs_dest *dest,\n\t\t\t\tint svcupd)\n{\n\tdest->flags &= ~IP_VS_DEST_F_AVAILABLE;\n\n\t/*\n\t *  Remove it from the d-linked destination list.\n\t */\n\tlist_del(&dest->n_list);\n\tsvc->num_dests--;\n\n\t/*\n\t *  Call the update_service function of its scheduler\n\t */\n\tif (svcupd && svc->scheduler->update_service)\n\t\t\tsvc->scheduler->update_service(svc);\n}\n\n\n/*\n *\tDelete a destination server in the given service\n */\nstatic int\nip_vs_del_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\t__be16 dport = udest->port;\n\n\tEnterFunction(2);\n\n\tdest = ip_vs_lookup_dest(svc, &udest->addr, dport);\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): destination not found!\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tWait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/*\n\t *\tUnlink dest from the service\n\t */\n\t__ip_vs_unlink_dest(svc, dest, 1);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tDelete the destination\n\t */\n\t__ip_vs_del_dest(dest);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tAdd a service into the service hash table\n */\nstatic int\nip_vs_add_service(struct ip_vs_service_user_kern *u,\n\t\t  struct ip_vs_service **svc_p)\n{\n\tint ret = 0;\n\tstruct ip_vs_scheduler *sched = NULL;\n\tstruct ip_vs_service *svc = NULL;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\t/* Lookup the scheduler by 'u->sched_name' */\n\tsched = ip_vs_scheduler_get(u->sched_name);\n\tif (sched == NULL) {\n\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\", u->sched_name);\n\t\tret = -ENOENT;\n\t\tgoto out_mod_dec;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6 && (u->netmask < 1 || u->netmask > 128)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n#endif\n\n\tsvc = kzalloc(sizeof(struct ip_vs_service), GFP_ATOMIC);\n\tif (svc == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): no memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t/* I'm the first user of the service */\n\tatomic_set(&svc->usecnt, 1);\n\tatomic_set(&svc->refcnt, 0);\n\n\tsvc->af = u->af;\n\tsvc->protocol = u->protocol;\n\tip_vs_addr_copy(svc->af, &svc->addr, &u->addr);\n\tsvc->port = u->port;\n\tsvc->fwmark = u->fwmark;\n\tsvc->flags = u->flags;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\tINIT_LIST_HEAD(&svc->destinations);\n\trwlock_init(&svc->sched_lock);\n\tspin_lock_init(&svc->stats.lock);\n\n\t/* Bind the scheduler */\n\tret = ip_vs_bind_scheduler(svc, sched);\n\tif (ret)\n\t\tgoto out_err;\n\tsched = NULL;\n\n\t/* Update the virtual service counters */\n\tif (svc->port == FTPPORT)\n\t\tatomic_inc(&ip_vs_ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_inc(&ip_vs_nullsvc_counter);\n\n\tip_vs_new_estimator(&svc->stats);\n\n\t/* Count only IPv4 services for old get/setsockopt interface */\n\tif (svc->af == AF_INET)\n\t\tip_vs_num_services++;\n\n\t/* Hash the service into the service table */\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\tip_vs_svc_hash(svc);\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\t*svc_p = svc;\n\treturn 0;\n\n  out_err:\n\tif (svc != NULL) {\n\t\tif (svc->scheduler)\n\t\t\tip_vs_unbind_scheduler(svc);\n\t\tif (svc->inc) {\n\t\t\tlocal_bh_disable();\n\t\t\tip_vs_app_inc_put(svc->inc);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t\tkfree(svc);\n\t}\n\tip_vs_scheduler_put(sched);\n\n  out_mod_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n\n\n/*\n *\tEdit a service and bind it with a new scheduler\n */\nstatic int\nip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)\n{\n\tstruct ip_vs_scheduler *sched, *old_sched;\n\tint ret = 0;\n\n\t/*\n\t * Lookup the scheduler, by 'u->sched_name'\n\t */\n\tsched = ip_vs_scheduler_get(u->sched_name);\n\tif (sched == NULL) {\n\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\", u->sched_name);\n\t\treturn -ENOENT;\n\t}\n\told_sched = sched;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6 && (u->netmask < 1 || u->netmask > 128)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t * Wait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/*\n\t * Set the flags and timeout value\n\t */\n\tsvc->flags = u->flags | IP_VS_SVC_F_HASHED;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\told_sched = svc->scheduler;\n\tif (sched != old_sched) {\n\t\t/*\n\t\t * Unbind the old scheduler\n\t\t */\n\t\tif ((ret = ip_vs_unbind_scheduler(svc))) {\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Bind the new scheduler\n\t\t */\n\t\tif ((ret = ip_vs_bind_scheduler(svc, sched))) {\n\t\t\t/*\n\t\t\t * If ip_vs_bind_scheduler fails, restore the old\n\t\t\t * scheduler.\n\t\t\t * The main reason of failure is out of memory.\n\t\t\t *\n\t\t\t * The question is if the old scheduler can be\n\t\t\t * restored all the time. TODO: if it cannot be\n\t\t\t * restored some time, we must delete the service,\n\t\t\t * otherwise the system may crash.\n\t\t\t */\n\t\t\tip_vs_bind_scheduler(svc, old_sched);\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n  out_unlock:\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n#ifdef CONFIG_IP_VS_IPV6\n  out:\n#endif\n\n\tif (old_sched)\n\t\tip_vs_scheduler_put(old_sched);\n\n\treturn ret;\n}\n\n\n/*\n *\tDelete a service from the service list\n *\t- The service must be unlinked, unlocked and not referenced!\n *\t- We are called under _bh lock\n */\nstatic void __ip_vs_del_service(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\tstruct ip_vs_scheduler *old_sched;\n\n\t/* Count only IPv4 services for old get/setsockopt interface */\n\tif (svc->af == AF_INET)\n\t\tip_vs_num_services--;\n\n\tip_vs_kill_estimator(&svc->stats);\n\n\t/* Unbind scheduler */\n\told_sched = svc->scheduler;\n\tip_vs_unbind_scheduler(svc);\n\tif (old_sched)\n\t\tip_vs_scheduler_put(old_sched);\n\n\t/* Unbind app inc */\n\tif (svc->inc) {\n\t\tip_vs_app_inc_put(svc->inc);\n\t\tsvc->inc = NULL;\n\t}\n\n\t/*\n\t *    Unlink the whole destination list\n\t */\n\tlist_for_each_entry_safe(dest, nxt, &svc->destinations, n_list) {\n\t\t__ip_vs_unlink_dest(svc, dest, 0);\n\t\t__ip_vs_del_dest(dest);\n\t}\n\n\t/*\n\t *    Update the virtual service counters\n\t */\n\tif (svc->port == FTPPORT)\n\t\tatomic_dec(&ip_vs_ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_dec(&ip_vs_nullsvc_counter);\n\n\t/*\n\t *    Free the service if nobody refers to it\n\t */\n\tif (atomic_read(&svc->refcnt) == 0)\n\t\tkfree(svc);\n\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n}\n\n/*\n *\tDelete a service from the service list\n */\nstatic int ip_vs_del_service(struct ip_vs_service *svc)\n{\n\tif (svc == NULL)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Unhash it from the service table\n\t */\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\tip_vs_svc_unhash(svc);\n\n\t/*\n\t * Wait until all the svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t__ip_vs_del_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\treturn 0;\n}\n\n\n/*\n *\tFlush all the virtual services\n */\nstatic int ip_vs_flush(void)\n{\n\tint idx;\n\tstruct ip_vs_service *svc, *nxt;\n\n\t/*\n\t * Flush the service table hashed by <protocol,addr,port>\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt, &ip_vs_svc_table[idx], s_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\t/*\n\t * Flush the service table hashed by fwmark\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt,\n\t\t\t\t\t &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *\tZero counters in a service or all services\n */\nstatic int ip_vs_zero_service(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tip_vs_zero_stats(&dest->stats);\n\t}\n\tip_vs_zero_stats(&svc->stats);\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\treturn 0;\n}\n\nstatic int ip_vs_zero_all(void)\n{\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tip_vs_zero_stats(&ip_vs_stats);\n\treturn 0;\n}\n\n\nstatic int\nproc_do_defense_mode(ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val = *valp;\n\tint rc;\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (*valp != val)) {\n\t\tif ((*valp < 0) || (*valp > 3)) {\n\t\t\t/* Restore the correct value */\n\t\t\t*valp = val;\n\t\t} else {\n\t\t\tupdate_defense_level();\n\t\t}\n\t}\n\treturn rc;\n}\n\n\nstatic int\nproc_do_sync_threshold(ctl_table *table, int write,\n\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val[2];\n\tint rc;\n\n\t/* backup the value first */\n\tmemcpy(val, valp, sizeof(val));\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (valp[0] < 0 || valp[1] < 0 || valp[0] >= valp[1])) {\n\t\t/* Restore the correct value */\n\t\tmemcpy(valp, val, sizeof(val));\n\t}\n\treturn rc;\n}\n\n\n/*\n *\tIPVS sysctl table (under the /proc/sys/net/ipv4/vs/)\n */\n\nstatic struct ctl_table vs_vars[] = {\n\t{\n\t\t.procname\t= \"amemthresh\",\n\t\t.data\t\t= &sysctl_ip_vs_amemthresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_IP_VS_DEBUG\n\t{\n\t\t.procname\t= \"debug_level\",\n\t\t.data\t\t= &sysctl_ip_vs_debug_level,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"am_droprate\",\n\t\t.data\t\t= &sysctl_ip_vs_am_droprate,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"drop_entry\",\n\t\t.data\t\t= &sysctl_ip_vs_drop_entry,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"drop_packet\",\n\t\t.data\t\t= &sysctl_ip_vs_drop_packet,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"secure_tcp\",\n\t\t.data\t\t= &sysctl_ip_vs_secure_tcp,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n#if 0\n\t{\n\t\t.procname\t= \"timeout_established\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_ESTABLISHED],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synsent\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYN_SENT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synrecv\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYN_RECV],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_finwait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_FIN_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_timewait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_TIME_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_close\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_CLOSE],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_closewait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_CLOSE_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_lastack\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_LAST_ACK],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_listen\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_LISTEN],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synack\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYNACK],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_udp\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_UDP],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_icmp\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_ICMP],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"cache_bypass\",\n\t\t.data\t\t= &sysctl_ip_vs_cache_bypass,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_nodest_conn\",\n\t\t.data\t\t= &sysctl_ip_vs_expire_nodest_conn,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_quiescent_template\",\n\t\t.data\t\t= &sysctl_ip_vs_expire_quiescent_template,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sync_threshold\",\n\t\t.data\t\t= &sysctl_ip_vs_sync_threshold,\n\t\t.maxlen\t\t= sizeof(sysctl_ip_vs_sync_threshold),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_sync_threshold,\n\t},\n\t{\n\t\t.procname\t= \"nat_icmp_send\",\n\t\t.data\t\t= &sysctl_ip_vs_nat_icmp_send,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nconst struct ctl_path net_vs_ctl_path[] = {\n\t{ .procname = \"net\", },\n\t{ .procname = \"ipv4\", },\n\t{ .procname = \"vs\", },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(net_vs_ctl_path);\n\nstatic struct ctl_table_header * sysctl_header;\n\n#ifdef CONFIG_PROC_FS\n\nstruct ip_vs_iter {\n\tstruct list_head *table;\n\tint bucket;\n};\n\n/*\n *\tWrite the contents of the VS rule table to a PROCfs file.\n *\t(It is kept just for backward compatibility)\n */\nstatic inline const char *ip_vs_fwd_name(unsigned flags)\n{\n\tswitch (flags & IP_VS_CONN_F_FWD_MASK) {\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\treturn \"Local\";\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\treturn \"Tunnel\";\n\tcase IP_VS_CONN_F_DROUTE:\n\t\treturn \"Route\";\n\tdefault:\n\t\treturn \"Masq\";\n\t}\n}\n\n\n/* Get the Nth entry in the two lists */\nstatic struct ip_vs_service *ip_vs_info_array(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_vs_iter *iter = seq->private;\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\t/* look in hash by protocol */\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tif (pos-- == 0){\n\t\t\t\titer->table = ip_vs_svc_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* keep looking in fwmark */\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tif (pos-- == 0) {\n\t\t\t\titer->table = ip_vs_svc_fwm_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ip_vs_info_seq_start(struct seq_file *seq, loff_t *pos)\n__acquires(__ip_vs_svc_lock)\n{\n\n\tread_lock_bh(&__ip_vs_svc_lock);\n\treturn *pos ? ip_vs_info_array(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\n\nstatic void *ip_vs_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct list_head *e;\n\tstruct ip_vs_iter *iter;\n\tstruct ip_vs_service *svc;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip_vs_info_array(seq,0);\n\n\tsvc = v;\n\titer = seq->private;\n\n\tif (iter->table == ip_vs_svc_table) {\n\t\t/* next service in table hashed by protocol */\n\t\tif ((e = svc->s_list.next) != &ip_vs_svc_table[iter->bucket])\n\t\t\treturn list_entry(e, struct ip_vs_service, s_list);\n\n\n\t\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\t\tlist_for_each_entry(svc,&ip_vs_svc_table[iter->bucket],\n\t\t\t\t\t    s_list) {\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\n\t\titer->table = ip_vs_svc_fwm_table;\n\t\titer->bucket = -1;\n\t\tgoto scan_fwmark;\n\t}\n\n\t/* next service in hashed by fwmark */\n\tif ((e = svc->f_list.next) != &ip_vs_svc_fwm_table[iter->bucket])\n\t\treturn list_entry(e, struct ip_vs_service, f_list);\n\n scan_fwmark:\n\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[iter->bucket],\n\t\t\t\t    f_list)\n\t\t\treturn svc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ip_vs_info_seq_stop(struct seq_file *seq, void *v)\n__releases(__ip_vs_svc_lock)\n{\n\tread_unlock_bh(&__ip_vs_svc_lock);\n}\n\n\nstatic int ip_vs_info_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t\"IP Virtual Server version %d.%d.%d (size=%d)\\n\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tseq_puts(seq,\n\t\t\t \"Prot LocalAddress:Port Scheduler Flags\\n\");\n\t\tseq_puts(seq,\n\t\t\t \"  -> RemoteAddress:Port Forward Weight ActiveConn InActConn\\n\");\n\t} else {\n\t\tconst struct ip_vs_service *svc = v;\n\t\tconst struct ip_vs_iter *iter = seq->private;\n\t\tconst struct ip_vs_dest *dest;\n\n\t\tif (iter->table == ip_vs_svc_table) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (svc->af == AF_INET6)\n\t\t\t\tseq_printf(seq, \"%s  [%pI6]:%04X %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   &svc->addr.in6,\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   svc->scheduler->name);\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq, \"%s  %08X:%04X %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   ntohl(svc->addr.ip),\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   svc->scheduler->name);\n\t\t} else {\n\t\t\tseq_printf(seq, \"FWM  %08X %s \",\n\t\t\t\t   svc->fwmark, svc->scheduler->name);\n\t\t}\n\n\t\tif (svc->flags & IP_VS_SVC_F_PERSISTENT)\n\t\t\tseq_printf(seq, \"persistent %d %08X\\n\",\n\t\t\t\tsvc->timeout,\n\t\t\t\tntohl(svc->netmask));\n\t\telse\n\t\t\tseq_putc(seq, '\\n');\n\n\t\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (dest->af == AF_INET6)\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> [%pI6]:%04X\"\n\t\t\t\t\t   \"      %-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   &dest->addr.in6,\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> %08X:%04X      \"\n\t\t\t\t\t   \"%-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   ntohl(dest->addr.ip),\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_info_seq_ops = {\n\t.start = ip_vs_info_seq_start,\n\t.next  = ip_vs_info_seq_next,\n\t.stop  = ip_vs_info_seq_stop,\n\t.show  = ip_vs_info_seq_show,\n};\n\nstatic int ip_vs_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_private(file, &ip_vs_info_seq_ops,\n\t\t\tsizeof(struct ip_vs_iter));\n}\n\nstatic const struct file_operations ip_vs_info_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ip_vs_info_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\n\n#endif\n\nstruct ip_vs_stats ip_vs_stats = {\n\t.lock = __SPIN_LOCK_UNLOCKED(ip_vs_stats.lock),\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int ip_vs_stats_show(struct seq_file *seq, void *v)\n{\n\n/*               01234567 01234567 01234567 0123456701234567 0123456701234567 */\n\tseq_puts(seq,\n\t\t \"   Total Incoming Outgoing         Incoming         Outgoing\\n\");\n\tseq_printf(seq,\n\t\t   \"   Conns  Packets  Packets            Bytes            Bytes\\n\");\n\n\tspin_lock_bh(&ip_vs_stats.lock);\n\tseq_printf(seq, \"%8X %8X %8X %16LX %16LX\\n\\n\", ip_vs_stats.ustats.conns,\n\t\t   ip_vs_stats.ustats.inpkts, ip_vs_stats.ustats.outpkts,\n\t\t   (unsigned long long) ip_vs_stats.ustats.inbytes,\n\t\t   (unsigned long long) ip_vs_stats.ustats.outbytes);\n\n/*                 01234567 01234567 01234567 0123456701234567 0123456701234567 */\n\tseq_puts(seq,\n\t\t   \" Conns/s   Pkts/s   Pkts/s          Bytes/s          Bytes/s\\n\");\n\tseq_printf(seq,\"%8X %8X %8X %16X %16X\\n\",\n\t\t\tip_vs_stats.ustats.cps,\n\t\t\tip_vs_stats.ustats.inpps,\n\t\t\tip_vs_stats.ustats.outpps,\n\t\t\tip_vs_stats.ustats.inbps,\n\t\t\tip_vs_stats.ustats.outbps);\n\tspin_unlock_bh(&ip_vs_stats.lock);\n\n\treturn 0;\n}\n\nstatic int ip_vs_stats_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ip_vs_stats_show, NULL);\n}\n\nstatic const struct file_operations ip_vs_stats_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ip_vs_stats_seq_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\n#endif\n\n/*\n *\tSet timeout values for tcp tcpfin udp in the timeout_table.\n */\nstatic int ip_vs_set_timeout(struct ip_vs_timeout_user *u)\n{\n\tIP_VS_DBG(2, \"Setting timeout tcp:%d tcpfin:%d udp:%d\\n\",\n\t\t  u->tcp_timeout,\n\t\t  u->tcp_fin_timeout,\n\t\t  u->udp_timeout);\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tif (u->tcp_timeout) {\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_ESTABLISHED]\n\t\t\t= u->tcp_timeout * HZ;\n\t}\n\n\tif (u->tcp_fin_timeout) {\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_FIN_WAIT]\n\t\t\t= u->tcp_fin_timeout * HZ;\n\t}\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tif (u->udp_timeout) {\n\t\tip_vs_protocol_udp.timeout_table[IP_VS_UDP_S_NORMAL]\n\t\t\t= u->udp_timeout * HZ;\n\t}\n#endif\n\treturn 0;\n}\n\n\n#define SET_CMDID(cmd)\t\t(cmd - IP_VS_BASE_CTL)\n#define SERVICE_ARG_LEN\t\t(sizeof(struct ip_vs_service_user))\n#define SVCDEST_ARG_LEN\t\t(sizeof(struct ip_vs_service_user) +\t\\\n\t\t\t\t sizeof(struct ip_vs_dest_user))\n#define TIMEOUT_ARG_LEN\t\t(sizeof(struct ip_vs_timeout_user))\n#define DAEMON_ARG_LEN\t\t(sizeof(struct ip_vs_daemon_user))\n#define MAX_ARG_LEN\t\tSVCDEST_ARG_LEN\n\nstatic const unsigned char set_arglen[SET_CMDID(IP_VS_SO_SET_MAX)+1] = {\n\t[SET_CMDID(IP_VS_SO_SET_ADD)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_EDIT)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_DEL)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_FLUSH)]\t\t= 0,\n\t[SET_CMDID(IP_VS_SO_SET_ADDDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_DELDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_EDITDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_TIMEOUT)]\t= TIMEOUT_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_STARTDAEMON)]\t= DAEMON_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_STOPDAEMON)]\t= DAEMON_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_ZERO)]\t\t= SERVICE_ARG_LEN,\n};\n\nstatic void ip_vs_copy_usvc_compat(struct ip_vs_service_user_kern *usvc,\n\t\t\t\t  struct ip_vs_service_user *usvc_compat)\n{\n\tusvc->af\t\t= AF_INET;\n\tusvc->protocol\t\t= usvc_compat->protocol;\n\tusvc->addr.ip\t\t= usvc_compat->addr;\n\tusvc->port\t\t= usvc_compat->port;\n\tusvc->fwmark\t\t= usvc_compat->fwmark;\n\n\t/* Deep copy of sched_name is not needed here */\n\tusvc->sched_name\t= usvc_compat->sched_name;\n\n\tusvc->flags\t\t= usvc_compat->flags;\n\tusvc->timeout\t\t= usvc_compat->timeout;\n\tusvc->netmask\t\t= usvc_compat->netmask;\n}\n\nstatic void ip_vs_copy_udest_compat(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t   struct ip_vs_dest_user *udest_compat)\n{\n\tudest->addr.ip\t\t= udest_compat->addr;\n\tudest->port\t\t= udest_compat->port;\n\tudest->conn_flags\t= udest_compat->conn_flags;\n\tudest->weight\t\t= udest_compat->weight;\n\tudest->u_threshold\t= udest_compat->u_threshold;\n\tudest->l_threshold\t= udest_compat->l_threshold;\n}\n\nstatic int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n\n\nstatic void\nip_vs_copy_stats(struct ip_vs_stats_user *dst, struct ip_vs_stats *src)\n{\n\tspin_lock_bh(&src->lock);\n\tmemcpy(dst, &src->ustats, sizeof(*dst));\n\tspin_unlock_bh(&src->lock);\n}\n\nstatic void\nip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)\n{\n\tdst->protocol = src->protocol;\n\tdst->addr = src->addr.ip;\n\tdst->port = src->port;\n\tdst->fwmark = src->fwmark;\n\tstrlcpy(dst->sched_name, src->scheduler->name, sizeof(dst->sched_name));\n\tdst->flags = src->flags;\n\tdst->timeout = src->timeout / HZ;\n\tdst->netmask = src->netmask;\n\tdst->num_dests = src->num_dests;\n\tip_vs_copy_stats(&dst->stats, &src->stats);\n}\n\nstatic inline int\n__ip_vs_get_service_entries(const struct ip_vs_get_services *get,\n\t\t\t    struct ip_vs_get_services __user *uptr)\n{\n\tint idx, count=0;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_service_entry entry;\n\tint ret = 0;\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\t/* Only expose IPv4 entries to old interface */\n\t\t\tif (svc->af != AF_INET)\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\t/* Only expose IPv4 entries to old interface */\n\t\t\tif (svc->af != AF_INET)\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n  out:\n\treturn ret;\n}\n\nstatic inline int\n__ip_vs_get_dest_entries(const struct ip_vs_get_dests *get,\n\t\t\t struct ip_vs_get_dests __user *uptr)\n{\n\tstruct ip_vs_service *svc;\n\tunion nf_inet_addr addr = { .ip = get->addr };\n\tint ret = 0;\n\n\tif (get->fwmark)\n\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, get->fwmark);\n\telse\n\t\tsvc = __ip_vs_service_get(AF_INET, get->protocol, &addr,\n\t\t\t\t\t  get->port);\n\n\tif (svc) {\n\t\tint count = 0;\n\t\tstruct ip_vs_dest *dest;\n\t\tstruct ip_vs_dest_entry entry;\n\n\t\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\t\tif (count >= get->num_dests)\n\t\t\t\tbreak;\n\n\t\t\tentry.addr = dest->addr.ip;\n\t\t\tentry.port = dest->port;\n\t\t\tentry.conn_flags = atomic_read(&dest->conn_flags);\n\t\t\tentry.weight = atomic_read(&dest->weight);\n\t\t\tentry.u_threshold = dest->u_threshold;\n\t\t\tentry.l_threshold = dest->l_threshold;\n\t\t\tentry.activeconns = atomic_read(&dest->activeconns);\n\t\t\tentry.inactconns = atomic_read(&dest->inactconns);\n\t\t\tentry.persistconns = atomic_read(&dest->persistconns);\n\t\t\tip_vs_copy_stats(&entry.stats, &dest->stats);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tip_vs_service_put(svc);\n\t} else\n\t\tret = -ESRCH;\n\treturn ret;\n}\n\nstatic inline void\n__ip_vs_get_timeouts(struct ip_vs_timeout_user *u)\n{\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tu->tcp_timeout =\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_ESTABLISHED] / HZ;\n\tu->tcp_fin_timeout =\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_FIN_WAIT] / HZ;\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tu->udp_timeout =\n\t\tip_vs_protocol_udp.timeout_table[IP_VS_UDP_S_NORMAL] / HZ;\n#endif\n}\n\n\n#define GET_CMDID(cmd)\t\t(cmd - IP_VS_BASE_CTL)\n#define GET_INFO_ARG_LEN\t(sizeof(struct ip_vs_getinfo))\n#define GET_SERVICES_ARG_LEN\t(sizeof(struct ip_vs_get_services))\n#define GET_SERVICE_ARG_LEN\t(sizeof(struct ip_vs_service_entry))\n#define GET_DESTS_ARG_LEN\t(sizeof(struct ip_vs_get_dests))\n#define GET_TIMEOUT_ARG_LEN\t(sizeof(struct ip_vs_timeout_user))\n#define GET_DAEMON_ARG_LEN\t(sizeof(struct ip_vs_daemon_user) * 2)\n\nstatic const unsigned char get_arglen[GET_CMDID(IP_VS_SO_GET_MAX)+1] = {\n\t[GET_CMDID(IP_VS_SO_GET_VERSION)]\t= 64,\n\t[GET_CMDID(IP_VS_SO_GET_INFO)]\t\t= GET_INFO_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_SERVICES)]\t= GET_SERVICES_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_SERVICE)]\t= GET_SERVICE_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_DESTS)]\t\t= GET_DESTS_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_TIMEOUT)]\t= GET_TIMEOUT_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_DAEMON)]\t= GET_DAEMON_ARG_LEN,\n};\n\nstatic int\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n\n\nstatic struct nf_sockopt_ops ip_vs_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= IP_VS_BASE_CTL,\n\t.set_optmax\t= IP_VS_SO_SET_MAX+1,\n\t.set\t\t= do_ip_vs_set_ctl,\n\t.get_optmin\t= IP_VS_BASE_CTL,\n\t.get_optmax\t= IP_VS_SO_GET_MAX+1,\n\t.get\t\t= do_ip_vs_get_ctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n/*\n * Generic Netlink interface\n */\n\n/* IPVS genetlink family */\nstatic struct genl_family ip_vs_genl_family = {\n\t.id\t\t= GENL_ID_GENERATE,\n\t.hdrsize\t= 0,\n\t.name\t\t= IPVS_GENL_NAME,\n\t.version\t= IPVS_GENL_VERSION,\n\t.maxattr\t= IPVS_CMD_MAX,\n};\n\n/* Policy used for first-level command attributes */\nstatic const struct nla_policy ip_vs_cmd_policy[IPVS_CMD_ATTR_MAX + 1] = {\n\t[IPVS_CMD_ATTR_SERVICE]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DEST]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DAEMON]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_UDP]\t= { .type = NLA_U32 },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_DAEMON */\nstatic const struct nla_policy ip_vs_daemon_policy[IPVS_DAEMON_ATTR_MAX + 1] = {\n\t[IPVS_DAEMON_ATTR_STATE]\t= { .type = NLA_U32 },\n\t[IPVS_DAEMON_ATTR_MCAST_IFN]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_IFNAME_MAXLEN },\n\t[IPVS_DAEMON_ATTR_SYNC_ID]\t= { .type = NLA_U32 },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_SERVICE */\nstatic const struct nla_policy ip_vs_svc_policy[IPVS_SVC_ATTR_MAX + 1] = {\n\t[IPVS_SVC_ATTR_AF]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_PROTOCOL]\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_SVC_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_FWMARK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_SCHED_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_SCHEDNAME_MAXLEN },\n\t[IPVS_SVC_ATTR_FLAGS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(struct ip_vs_flags) },\n\t[IPVS_SVC_ATTR_TIMEOUT]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_NETMASK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_DEST */\nstatic const struct nla_policy ip_vs_dest_policy[IPVS_DEST_ATTR_MAX + 1] = {\n\t[IPVS_DEST_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_DEST_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_DEST_ATTR_FWD_METHOD]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_U_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_L_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_ACTIVE_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_INACT_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_PERSIST_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int ip_vs_genl_fill_stats(struct sk_buff *skb, int container_type,\n\t\t\t\t struct ip_vs_stats *stats)\n{\n\tstruct nlattr *nl_stats = nla_nest_start(skb, container_type);\n\tif (!nl_stats)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_bh(&stats->lock);\n\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_CONNS, stats->ustats.conns);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INPKTS, stats->ustats.inpkts);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTPKTS, stats->ustats.outpkts);\n\tNLA_PUT_U64(skb, IPVS_STATS_ATTR_INBYTES, stats->ustats.inbytes);\n\tNLA_PUT_U64(skb, IPVS_STATS_ATTR_OUTBYTES, stats->ustats.outbytes);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_CPS, stats->ustats.cps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INPPS, stats->ustats.inpps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTPPS, stats->ustats.outpps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INBPS, stats->ustats.inbps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTBPS, stats->ustats.outbps);\n\n\tspin_unlock_bh(&stats->lock);\n\n\tnla_nest_end(skb, nl_stats);\n\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&stats->lock);\n\tnla_nest_cancel(skb, nl_stats);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_fill_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc)\n{\n\tstruct nlattr *nl_service;\n\tstruct ip_vs_flags flags = { .flags = svc->flags,\n\t\t\t\t     .mask = ~0 };\n\n\tnl_service = nla_nest_start(skb, IPVS_CMD_ATTR_SERVICE);\n\tif (!nl_service)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_AF, svc->af);\n\n\tif (svc->fwmark) {\n\t\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_FWMARK, svc->fwmark);\n\t} else {\n\t\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_PROTOCOL, svc->protocol);\n\t\tNLA_PUT(skb, IPVS_SVC_ATTR_ADDR, sizeof(svc->addr), &svc->addr);\n\t\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_PORT, svc->port);\n\t}\n\n\tNLA_PUT_STRING(skb, IPVS_SVC_ATTR_SCHED_NAME, svc->scheduler->name);\n\tNLA_PUT(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &flags);\n\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_TIMEOUT, svc->timeout / HZ);\n\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_NETMASK, svc->netmask);\n\n\tif (ip_vs_genl_fill_stats(skb, IPVS_SVC_ATTR_STATS, &svc->stats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_service);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_service);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_SERVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_service(skb, svc) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_services(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tint idx = 0, i;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\n\tmutex_lock(&__ip_vs_mutex);\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[i], s_list) {\n\t\t\tif (++idx <= start)\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[i], f_list) {\n\t\t\tif (++idx <= start)\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&__ip_vs_mutex);\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_parse_service(struct ip_vs_service_user_kern *usvc,\n\t\t\t\t    struct nlattr *nla, int full_entry)\n{\n\tstruct nlattr *attrs[IPVS_SVC_ATTR_MAX + 1];\n\tstruct nlattr *nla_af, *nla_port, *nla_fwmark, *nla_protocol, *nla_addr;\n\n\t/* Parse mandatory identifying service fields first */\n\tif (nla == NULL ||\n\t    nla_parse_nested(attrs, IPVS_SVC_ATTR_MAX, nla, ip_vs_svc_policy))\n\t\treturn -EINVAL;\n\n\tnla_af\t\t= attrs[IPVS_SVC_ATTR_AF];\n\tnla_protocol\t= attrs[IPVS_SVC_ATTR_PROTOCOL];\n\tnla_addr\t= attrs[IPVS_SVC_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_SVC_ATTR_PORT];\n\tnla_fwmark\t= attrs[IPVS_SVC_ATTR_FWMARK];\n\n\tif (!(nla_af && (nla_fwmark || (nla_port && nla_protocol && nla_addr))))\n\t\treturn -EINVAL;\n\n\tmemset(usvc, 0, sizeof(*usvc));\n\n\tusvc->af = nla_get_u16(nla_af);\n#ifdef CONFIG_IP_VS_IPV6\n\tif (usvc->af != AF_INET && usvc->af != AF_INET6)\n#else\n\tif (usvc->af != AF_INET)\n#endif\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_fwmark) {\n\t\tusvc->protocol = IPPROTO_TCP;\n\t\tusvc->fwmark = nla_get_u32(nla_fwmark);\n\t} else {\n\t\tusvc->protocol = nla_get_u16(nla_protocol);\n\t\tnla_memcpy(&usvc->addr, nla_addr, sizeof(usvc->addr));\n\t\tusvc->port = nla_get_u16(nla_port);\n\t\tusvc->fwmark = 0;\n\t}\n\n\t/* If a full entry was requested, check for the additional fields */\n\tif (full_entry) {\n\t\tstruct nlattr *nla_sched, *nla_flags, *nla_timeout,\n\t\t\t      *nla_netmask;\n\t\tstruct ip_vs_flags flags;\n\t\tstruct ip_vs_service *svc;\n\n\t\tnla_sched = attrs[IPVS_SVC_ATTR_SCHED_NAME];\n\t\tnla_flags = attrs[IPVS_SVC_ATTR_FLAGS];\n\t\tnla_timeout = attrs[IPVS_SVC_ATTR_TIMEOUT];\n\t\tnla_netmask = attrs[IPVS_SVC_ATTR_NETMASK];\n\n\t\tif (!(nla_sched && nla_flags && nla_timeout && nla_netmask))\n\t\t\treturn -EINVAL;\n\n\t\tnla_memcpy(&flags, nla_flags, sizeof(flags));\n\n\t\t/* prefill flags from service if it already exists */\n\t\tif (usvc->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(usvc->af, usvc->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(usvc->af, usvc->protocol,\n\t\t\t\t\t\t  &usvc->addr, usvc->port);\n\t\tif (svc) {\n\t\t\tusvc->flags = svc->flags;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tusvc->flags = 0;\n\n\t\t/* set new flags from userland */\n\t\tusvc->flags = (usvc->flags & ~flags.mask) |\n\t\t\t      (flags.flags & flags.mask);\n\t\tusvc->sched_name = nla_data(nla_sched);\n\t\tusvc->timeout = nla_get_u32(nla_timeout);\n\t\tusvc->netmask = nla_get_u32(nla_netmask);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ip_vs_service *ip_vs_genl_find_service(struct nlattr *nla)\n{\n\tstruct ip_vs_service_user_kern usvc;\n\tint ret;\n\n\tret = ip_vs_genl_parse_service(&usvc, nla, 0);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (usvc.fwmark)\n\t\treturn __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\telse\n\t\treturn __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t   &usvc.addr, usvc.port);\n}\n\nstatic int ip_vs_genl_fill_dest(struct sk_buff *skb, struct ip_vs_dest *dest)\n{\n\tstruct nlattr *nl_dest;\n\n\tnl_dest = nla_nest_start(skb, IPVS_CMD_ATTR_DEST);\n\tif (!nl_dest)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT(skb, IPVS_DEST_ATTR_ADDR, sizeof(dest->addr), &dest->addr);\n\tNLA_PUT_U16(skb, IPVS_DEST_ATTR_PORT, dest->port);\n\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_FWD_METHOD,\n\t\t    atomic_read(&dest->conn_flags) & IP_VS_CONN_F_FWD_MASK);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_WEIGHT, atomic_read(&dest->weight));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_U_THRESH, dest->u_threshold);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_L_THRESH, dest->l_threshold);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_ACTIVE_CONNS,\n\t\t    atomic_read(&dest->activeconns));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_INACT_CONNS,\n\t\t    atomic_read(&dest->inactconns));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_PERSIST_CONNS,\n\t\t    atomic_read(&dest->persistconns));\n\n\tif (ip_vs_genl_fill_stats(skb, IPVS_DEST_ATTR_STATS, &dest->stats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_dest);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_dest);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dest(struct sk_buff *skb, struct ip_vs_dest *dest,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DEST);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_dest(skb, dest) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dests(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest *dest;\n\tstruct nlattr *attrs[IPVS_CMD_ATTR_MAX + 1];\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\t/* Try to find the service for which to dump destinations */\n\tif (nlmsg_parse(cb->nlh, GENL_HDRLEN, attrs,\n\t\t\tIPVS_CMD_ATTR_MAX, ip_vs_cmd_policy))\n\t\tgoto out_err;\n\n\tsvc = ip_vs_genl_find_service(attrs[IPVS_CMD_ATTR_SERVICE]);\n\tif (IS_ERR(svc) || svc == NULL)\n\t\tgoto out_err;\n\n\t/* Dump the destinations */\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (ip_vs_genl_dump_dest(skb, dest, cb) < 0) {\n\t\t\tidx--;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\nnla_put_failure:\n\tcb->args[0] = idx;\n\tip_vs_service_put(svc);\n\nout_err:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_parse_dest(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t struct nlattr *nla, int full_entry)\n{\n\tstruct nlattr *attrs[IPVS_DEST_ATTR_MAX + 1];\n\tstruct nlattr *nla_addr, *nla_port;\n\n\t/* Parse mandatory identifying destination fields first */\n\tif (nla == NULL ||\n\t    nla_parse_nested(attrs, IPVS_DEST_ATTR_MAX, nla, ip_vs_dest_policy))\n\t\treturn -EINVAL;\n\n\tnla_addr\t= attrs[IPVS_DEST_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_DEST_ATTR_PORT];\n\n\tif (!(nla_addr && nla_port))\n\t\treturn -EINVAL;\n\n\tmemset(udest, 0, sizeof(*udest));\n\n\tnla_memcpy(&udest->addr, nla_addr, sizeof(udest->addr));\n\tudest->port = nla_get_u16(nla_port);\n\n\t/* If a full entry was requested, check for the additional fields */\n\tif (full_entry) {\n\t\tstruct nlattr *nla_fwd, *nla_weight, *nla_u_thresh,\n\t\t\t      *nla_l_thresh;\n\n\t\tnla_fwd\t\t= attrs[IPVS_DEST_ATTR_FWD_METHOD];\n\t\tnla_weight\t= attrs[IPVS_DEST_ATTR_WEIGHT];\n\t\tnla_u_thresh\t= attrs[IPVS_DEST_ATTR_U_THRESH];\n\t\tnla_l_thresh\t= attrs[IPVS_DEST_ATTR_L_THRESH];\n\n\t\tif (!(nla_fwd && nla_weight && nla_u_thresh && nla_l_thresh))\n\t\t\treturn -EINVAL;\n\n\t\tudest->conn_flags = nla_get_u32(nla_fwd)\n\t\t\t\t    & IP_VS_CONN_F_FWD_MASK;\n\t\tudest->weight = nla_get_u32(nla_weight);\n\t\tudest->u_threshold = nla_get_u32(nla_u_thresh);\n\t\tudest->l_threshold = nla_get_u32(nla_l_thresh);\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_vs_genl_fill_daemon(struct sk_buff *skb, __be32 state,\n\t\t\t\t  const char *mcast_ifn, __be32 syncid)\n{\n\tstruct nlattr *nl_daemon;\n\n\tnl_daemon = nla_nest_start(skb, IPVS_CMD_ATTR_DAEMON);\n\tif (!nl_daemon)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_STATE, state);\n\tNLA_PUT_STRING(skb, IPVS_DAEMON_ATTR_MCAST_IFN, mcast_ifn);\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_SYNC_ID, syncid);\n\n\tnla_nest_end(skb, nl_daemon);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_daemon);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemon(struct sk_buff *skb, __be32 state,\n\t\t\t\t  const char *mcast_ifn, __be32 syncid,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DAEMON);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_daemon(skb, state, mcast_ifn, syncid))\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemons(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tmutex_lock(&__ip_vs_mutex);\n\tif ((ip_vs_sync_state & IP_VS_STATE_MASTER) && !cb->args[0]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_MASTER,\n\t\t\t\t\t   ip_vs_master_mcast_ifn,\n\t\t\t\t\t   ip_vs_master_syncid, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[0] = 1;\n\t}\n\n\tif ((ip_vs_sync_state & IP_VS_STATE_BACKUP) && !cb->args[1]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_BACKUP,\n\t\t\t\t\t   ip_vs_backup_mcast_ifn,\n\t\t\t\t\t   ip_vs_backup_syncid, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[1] = 1;\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_new_daemon(struct nlattr **attrs)\n{\n\tif (!(attrs[IPVS_DAEMON_ATTR_STATE] &&\n\t      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&\n\t      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))\n\t\treturn -EINVAL;\n\n\treturn start_sync_thread(nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),\n\t\t\t\t nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),\n\t\t\t\t nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));\n}\n\nstatic int ip_vs_genl_del_daemon(struct nlattr **attrs)\n{\n\tif (!attrs[IPVS_DAEMON_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\treturn stop_sync_thread(nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\n}\n\nstatic int ip_vs_genl_set_config(struct nlattr **attrs)\n{\n\tstruct ip_vs_timeout_user t;\n\n\t__ip_vs_get_timeouts(&t);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\n\t\tt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\n\t\tt.tcp_fin_timeout =\n\t\t\tnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\n\t\tt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\n\n\treturn ip_vs_set_timeout(&t);\n}\n\nstatic int ip_vs_genl_set_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ip_vs_service *svc = NULL;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_dest_user_kern udest;\n\tint ret = 0, cmd;\n\tint need_full_svc = 0, need_full_dest = 0;\n\n\tcmd = info->genlhdr->cmd;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\tif (cmd == IPVS_CMD_FLUSH) {\n\t\tret = ip_vs_flush();\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_SET_CONFIG) {\n\t\tret = ip_vs_genl_set_config(info->attrs);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_NEW_DAEMON ||\n\t\t   cmd == IPVS_CMD_DEL_DAEMON) {\n\n\t\tstruct nlattr *daemon_attrs[IPVS_DAEMON_ATTR_MAX + 1];\n\n\t\tif (!info->attrs[IPVS_CMD_ATTR_DAEMON] ||\n\t\t    nla_parse_nested(daemon_attrs, IPVS_DAEMON_ATTR_MAX,\n\t\t\t\t     info->attrs[IPVS_CMD_ATTR_DAEMON],\n\t\t\t\t     ip_vs_daemon_policy)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmd == IPVS_CMD_NEW_DAEMON)\n\t\t\tret = ip_vs_genl_new_daemon(daemon_attrs);\n\t\telse\n\t\t\tret = ip_vs_genl_del_daemon(daemon_attrs);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_ZERO &&\n\t\t   !info->attrs[IPVS_CMD_ATTR_SERVICE]) {\n\t\tret = ip_vs_zero_all();\n\t\tgoto out;\n\t}\n\n\t/* All following commands require a service argument, so check if we\n\t * received a valid one. We need a full service specification when\n\t * adding / editing a service. Only identifying members otherwise. */\n\tif (cmd == IPVS_CMD_NEW_SERVICE || cmd == IPVS_CMD_SET_SERVICE)\n\t\tneed_full_svc = 1;\n\n\tret = ip_vs_genl_parse_service(&usvc,\n\t\t\t\t       info->attrs[IPVS_CMD_ATTR_SERVICE],\n\t\t\t\t       need_full_svc);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\t/* Unless we're adding a new service, the service must already exist */\n\tif ((cmd != IPVS_CMD_NEW_SERVICE) && (svc == NULL)) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\t/* Destination commands require a valid destination argument. For\n\t * adding / editing a destination, we need a full destination\n\t * specification. */\n\tif (cmd == IPVS_CMD_NEW_DEST || cmd == IPVS_CMD_SET_DEST ||\n\t    cmd == IPVS_CMD_DEL_DEST) {\n\t\tif (cmd != IPVS_CMD_DEL_DEST)\n\t\t\tneed_full_dest = 1;\n\n\t\tret = ip_vs_genl_parse_dest(&udest,\n\t\t\t\t\t    info->attrs[IPVS_CMD_ATTR_DEST],\n\t\t\t\t\t    need_full_dest);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_NEW_SERVICE:\n\t\tif (svc == NULL)\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\telse\n\t\t\tret = -EEXIST;\n\t\tbreak;\n\tcase IPVS_CMD_SET_SERVICE:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_SERVICE:\n\t\tret = ip_vs_del_service(svc);\n\t\tbreak;\n\tcase IPVS_CMD_NEW_DEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_SET_DEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_DEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\nstatic int ip_vs_genl_get_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *reply;\n\tint ret, cmd, reply_cmd;\n\n\tcmd = info->genlhdr->cmd;\n\n\tif (cmd == IPVS_CMD_GET_SERVICE)\n\t\treply_cmd = IPVS_CMD_NEW_SERVICE;\n\telse if (cmd == IPVS_CMD_GET_INFO)\n\t\treply_cmd = IPVS_CMD_SET_INFO;\n\telse if (cmd == IPVS_CMD_GET_CONFIG)\n\t\treply_cmd = IPVS_CMD_SET_CONFIG;\n\telse {\n\t\tpr_err(\"unknown Generic Netlink command\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\treply = genlmsg_put_reply(msg, info, &ip_vs_genl_family, 0, reply_cmd);\n\tif (reply == NULL)\n\t\tgoto nla_put_failure;\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service *svc;\n\n\t\tsvc = ip_vs_genl_find_service(info->attrs[IPVS_CMD_ATTR_SERVICE]);\n\t\tif (IS_ERR(svc)) {\n\t\t\tret = PTR_ERR(svc);\n\t\t\tgoto out_err;\n\t\t} else if (svc) {\n\t\t\tret = ip_vs_genl_fill_service(msg, svc);\n\t\t\tip_vs_service_put(svc);\n\t\t\tif (ret)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tret = -ESRCH;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_CONFIG:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP, t.tcp_timeout);\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,\n\t\t\t    t.tcp_fin_timeout);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_UDP, t.udp_timeout);\n#endif\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_INFO:\n\t\tNLA_PUT_U32(msg, IPVS_INFO_ATTR_VERSION, IP_VS_VERSION_CODE);\n\t\tNLA_PUT_U32(msg, IPVS_INFO_ATTR_CONN_TAB_SIZE,\n\t\t\t    IP_VS_CONN_TAB_SIZE);\n\t\tbreak;\n\t}\n\n\tgenlmsg_end(msg, reply);\n\tret = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tpr_err(\"not enough space in Netlink message\\n\");\n\tret = -EMSGSIZE;\n\nout_err:\n\tnlmsg_free(msg);\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\n\nstatic struct genl_ops ip_vs_genl_ops[] __read_mostly = {\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t\t.dumpit\t= ip_vs_genl_dump_services,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.dumpit\t= ip_vs_genl_dump_dests,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.dumpit\t= ip_vs_genl_dump_daemons,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_CONFIG,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_CONFIG,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_INFO,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_ZERO,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_FLUSH,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n};\n\nstatic int __init ip_vs_genl_register(void)\n{\n\treturn genl_register_family_with_ops(&ip_vs_genl_family,\n\t\tip_vs_genl_ops, ARRAY_SIZE(ip_vs_genl_ops));\n}\n\nstatic void ip_vs_genl_unregister(void)\n{\n\tgenl_unregister_family(&ip_vs_genl_family);\n}\n\n/* End of Generic Netlink interface definitions */\n\n\nint __init ip_vs_control_init(void)\n{\n\tint ret;\n\tint idx;\n\n\tEnterFunction(2);\n\n\tret = nf_register_sockopt(&ip_vs_sockopts);\n\tif (ret) {\n\t\tpr_err(\"cannot register sockopt.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ip_vs_genl_register();\n\tif (ret) {\n\t\tpr_err(\"cannot register Generic Netlink interface.\\n\");\n\t\tnf_unregister_sockopt(&ip_vs_sockopts);\n\t\treturn ret;\n\t}\n\n\tproc_net_fops_create(&init_net, \"ip_vs\", 0, &ip_vs_info_fops);\n\tproc_net_fops_create(&init_net, \"ip_vs_stats\",0, &ip_vs_stats_fops);\n\n\tsysctl_header = register_sysctl_paths(net_vs_ctl_path, vs_vars);\n\n\t/* Initialize ip_vs_svc_table, ip_vs_svc_fwm_table, ip_vs_rtable */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_svc_table[idx]);\n\t\tINIT_LIST_HEAD(&ip_vs_svc_fwm_table[idx]);\n\t}\n\tfor(idx = 0; idx < IP_VS_RTAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_rtable[idx]);\n\t}\n\n\tip_vs_new_estimator(&ip_vs_stats);\n\n\t/* Hook the defense timer */\n\tschedule_delayed_work(&defense_work, DEFENSE_TIMER_PERIOD);\n\n\tLeaveFunction(2);\n\treturn 0;\n}\n\n\nvoid ip_vs_control_cleanup(void)\n{\n\tEnterFunction(2);\n\tip_vs_trash_cleanup();\n\tcancel_rearming_delayed_work(&defense_work);\n\tcancel_work_sync(&defense_work.work);\n\tip_vs_kill_estimator(&ip_vs_stats);\n\tunregister_sysctl_table(sysctl_header);\n\tproc_net_remove(&init_net, \"ip_vs_stats\");\n\tproc_net_remove(&init_net, \"ip_vs\");\n\tip_vs_genl_unregister();\n\tnf_unregister_sockopt(&ip_vs_sockopts);\n\tLeaveFunction(2);\n}\n"], "fixing_code": ["/*\n * IPVS         An implementation of the IP virtual server support for the\n *              LINUX operating system.  IPVS is now implemented as a module\n *              over the NetFilter framework. IPVS can be used to build a\n *              high-performance and highly available server based on a\n *              cluster of servers.\n *\n * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>\n *              Peter Kese <peter.kese@ijs.si>\n *              Julian Anastasov <ja@ssi.bg>\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Changes:\n *\n */\n\n#define KMSG_COMPONENT \"IPVS\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/workqueue.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/mutex.h>\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#ifdef CONFIG_IP_VS_IPV6\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#endif\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\n#include <asm/uaccess.h>\n\n#include <net/ip_vs.h>\n\n/* semaphore for IPVS sockopts. And, [gs]etsockopt may sleep. */\nstatic DEFINE_MUTEX(__ip_vs_mutex);\n\n/* lock for service table */\nstatic DEFINE_RWLOCK(__ip_vs_svc_lock);\n\n/* lock for table with the real services */\nstatic DEFINE_RWLOCK(__ip_vs_rs_lock);\n\n/* lock for state and timeout tables */\nstatic DEFINE_RWLOCK(__ip_vs_securetcp_lock);\n\n/* lock for drop entry handling */\nstatic DEFINE_SPINLOCK(__ip_vs_dropentry_lock);\n\n/* lock for drop packet handling */\nstatic DEFINE_SPINLOCK(__ip_vs_droppacket_lock);\n\n/* 1/rate drop and drop-entry variables */\nint ip_vs_drop_rate = 0;\nint ip_vs_drop_counter = 0;\nstatic atomic_t ip_vs_dropentry = ATOMIC_INIT(0);\n\n/* number of virtual services */\nstatic int ip_vs_num_services = 0;\n\n/* sysctl variables */\nstatic int sysctl_ip_vs_drop_entry = 0;\nstatic int sysctl_ip_vs_drop_packet = 0;\nstatic int sysctl_ip_vs_secure_tcp = 0;\nstatic int sysctl_ip_vs_amemthresh = 1024;\nstatic int sysctl_ip_vs_am_droprate = 10;\nint sysctl_ip_vs_cache_bypass = 0;\nint sysctl_ip_vs_expire_nodest_conn = 0;\nint sysctl_ip_vs_expire_quiescent_template = 0;\nint sysctl_ip_vs_sync_threshold[2] = { 3, 50 };\nint sysctl_ip_vs_nat_icmp_send = 0;\n\n\n#ifdef CONFIG_IP_VS_DEBUG\nstatic int sysctl_ip_vs_debug_level = 0;\n\nint ip_vs_get_debug_level(void)\n{\n\treturn sysctl_ip_vs_debug_level;\n}\n#endif\n\n#ifdef CONFIG_IP_VS_IPV6\n/* Taken from rt6_fill_node() in net/ipv6/route.c, is there a better way? */\nstatic int __ip_vs_addr_is_local_v6(const struct in6_addr *addr)\n{\n\tstruct rt6_info *rt;\n\tstruct flowi fl = {\n\t\t.oif = 0,\n\t\t.nl_u = {\n\t\t\t.ip6_u = {\n\t\t\t\t.daddr = *addr,\n\t\t\t\t.saddr = { .s6_addr32 = {0, 0, 0, 0} }, } },\n\t};\n\n\trt = (struct rt6_info *)ip6_route_output(&init_net, NULL, &fl);\n\tif (rt && rt->rt6i_dev && (rt->rt6i_dev->flags & IFF_LOOPBACK))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n#endif\n/*\n *\tupdate_defense_level is called from keventd and from sysctl,\n *\tso it needs to protect itself from softirqs\n */\nstatic void update_defense_level(void)\n{\n\tstruct sysinfo i;\n\tstatic int old_secure_tcp = 0;\n\tint availmem;\n\tint nomem;\n\tint to_change = -1;\n\n\t/* we only count free and buffered memory (in pages) */\n\tsi_meminfo(&i);\n\tavailmem = i.freeram + i.bufferram;\n\t/* however in linux 2.5 the i.bufferram is total page cache size,\n\t   we need adjust it */\n\t/* si_swapinfo(&i); */\n\t/* availmem = availmem - (i.totalswap - i.freeswap); */\n\n\tnomem = (availmem < sysctl_ip_vs_amemthresh);\n\n\tlocal_bh_disable();\n\n\t/* drop_entry */\n\tspin_lock(&__ip_vs_dropentry_lock);\n\tswitch (sysctl_ip_vs_drop_entry) {\n\tcase 0:\n\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\t\tsysctl_ip_vs_drop_entry = 2;\n\t\t} else {\n\t\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\t} else {\n\t\t\tatomic_set(&ip_vs_dropentry, 0);\n\t\t\tsysctl_ip_vs_drop_entry = 1;\n\t\t};\n\t\tbreak;\n\tcase 3:\n\t\tatomic_set(&ip_vs_dropentry, 1);\n\t\tbreak;\n\t}\n\tspin_unlock(&__ip_vs_dropentry_lock);\n\n\t/* drop_packet */\n\tspin_lock(&__ip_vs_droppacket_lock);\n\tswitch (sysctl_ip_vs_drop_packet) {\n\tcase 0:\n\t\tip_vs_drop_rate = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tip_vs_drop_rate = ip_vs_drop_counter\n\t\t\t\t= sysctl_ip_vs_amemthresh /\n\t\t\t\t(sysctl_ip_vs_amemthresh-availmem);\n\t\t\tsysctl_ip_vs_drop_packet = 2;\n\t\t} else {\n\t\t\tip_vs_drop_rate = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tip_vs_drop_rate = ip_vs_drop_counter\n\t\t\t\t= sysctl_ip_vs_amemthresh /\n\t\t\t\t(sysctl_ip_vs_amemthresh-availmem);\n\t\t} else {\n\t\t\tip_vs_drop_rate = 0;\n\t\t\tsysctl_ip_vs_drop_packet = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tip_vs_drop_rate = sysctl_ip_vs_am_droprate;\n\t\tbreak;\n\t}\n\tspin_unlock(&__ip_vs_droppacket_lock);\n\n\t/* secure_tcp */\n\twrite_lock(&__ip_vs_securetcp_lock);\n\tswitch (sysctl_ip_vs_secure_tcp) {\n\tcase 0:\n\t\tif (old_secure_tcp >= 2)\n\t\t\tto_change = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (nomem) {\n\t\t\tif (old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t\tsysctl_ip_vs_secure_tcp = 2;\n\t\t} else {\n\t\t\tif (old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (nomem) {\n\t\t\tif (old_secure_tcp < 2)\n\t\t\t\tto_change = 1;\n\t\t} else {\n\t\t\tif (old_secure_tcp >= 2)\n\t\t\t\tto_change = 0;\n\t\t\tsysctl_ip_vs_secure_tcp = 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (old_secure_tcp < 2)\n\t\t\tto_change = 1;\n\t\tbreak;\n\t}\n\told_secure_tcp = sysctl_ip_vs_secure_tcp;\n\tif (to_change >= 0)\n\t\tip_vs_protocol_timeout_change(sysctl_ip_vs_secure_tcp>1);\n\twrite_unlock(&__ip_vs_securetcp_lock);\n\n\tlocal_bh_enable();\n}\n\n\n/*\n *\tTimer for checking the defense\n */\n#define DEFENSE_TIMER_PERIOD\t1*HZ\nstatic void defense_work_handler(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(defense_work, defense_work_handler);\n\nstatic void defense_work_handler(struct work_struct *work)\n{\n\tupdate_defense_level();\n\tif (atomic_read(&ip_vs_dropentry))\n\t\tip_vs_random_dropentry();\n\n\tschedule_delayed_work(&defense_work, DEFENSE_TIMER_PERIOD);\n}\n\nint\nip_vs_use_count_inc(void)\n{\n\treturn try_module_get(THIS_MODULE);\n}\n\nvoid\nip_vs_use_count_dec(void)\n{\n\tmodule_put(THIS_MODULE);\n}\n\n\n/*\n *\tHash table: for virtual service lookups\n */\n#define IP_VS_SVC_TAB_BITS 8\n#define IP_VS_SVC_TAB_SIZE (1 << IP_VS_SVC_TAB_BITS)\n#define IP_VS_SVC_TAB_MASK (IP_VS_SVC_TAB_SIZE - 1)\n\n/* the service table hashed by <protocol, addr, port> */\nstatic struct list_head ip_vs_svc_table[IP_VS_SVC_TAB_SIZE];\n/* the service table hashed by fwmark */\nstatic struct list_head ip_vs_svc_fwm_table[IP_VS_SVC_TAB_SIZE];\n\n/*\n *\tHash table: for real service lookups\n */\n#define IP_VS_RTAB_BITS 4\n#define IP_VS_RTAB_SIZE (1 << IP_VS_RTAB_BITS)\n#define IP_VS_RTAB_MASK (IP_VS_RTAB_SIZE - 1)\n\nstatic struct list_head ip_vs_rtable[IP_VS_RTAB_SIZE];\n\n/*\n *\tTrash for destinations\n */\nstatic LIST_HEAD(ip_vs_dest_trash);\n\n/*\n *\tFTP & NULL virtual service counters\n */\nstatic atomic_t ip_vs_ftpsvc_counter = ATOMIC_INIT(0);\nstatic atomic_t ip_vs_nullsvc_counter = ATOMIC_INIT(0);\n\n\n/*\n *\tReturns hash value for virtual service\n */\nstatic __inline__ unsigned\nip_vs_svc_hashkey(int af, unsigned proto, const union nf_inet_addr *addr,\n\t\t  __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (proto^ntohl(addr_fold)^(porth>>IP_VS_SVC_TAB_BITS)^porth)\n\t\t& IP_VS_SVC_TAB_MASK;\n}\n\n/*\n *\tReturns hash value of fwmark for virtual service lookup\n */\nstatic __inline__ unsigned ip_vs_svc_fwm_hashkey(__u32 fwmark)\n{\n\treturn fwmark & IP_VS_SVC_TAB_MASK;\n}\n\n/*\n *\tHashes a service in the ip_vs_svc_table by <proto,addr,port>\n *\tor in the ip_vs_svc_fwm_table by fwmark.\n *\tShould be called with locked tables.\n */\nstatic int ip_vs_svc_hash(struct ip_vs_service *svc)\n{\n\tunsigned hash;\n\n\tif (svc->flags & IP_VS_SVC_F_HASHED) {\n\t\tpr_err(\"%s(): request for already hashed, called from %pF\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t/*\n\t\t *  Hash it by <protocol,addr,port> in ip_vs_svc_table\n\t\t */\n\t\thash = ip_vs_svc_hashkey(svc->af, svc->protocol, &svc->addr,\n\t\t\t\t\t svc->port);\n\t\tlist_add(&svc->s_list, &ip_vs_svc_table[hash]);\n\t} else {\n\t\t/*\n\t\t *  Hash it by fwmark in ip_vs_svc_fwm_table\n\t\t */\n\t\thash = ip_vs_svc_fwm_hashkey(svc->fwmark);\n\t\tlist_add(&svc->f_list, &ip_vs_svc_fwm_table[hash]);\n\t}\n\n\tsvc->flags |= IP_VS_SVC_F_HASHED;\n\t/* increase its refcnt because it is referenced by the svc table */\n\tatomic_inc(&svc->refcnt);\n\treturn 1;\n}\n\n\n/*\n *\tUnhashes a service from ip_vs_svc_table/ip_vs_svc_fwm_table.\n *\tShould be called with locked tables.\n */\nstatic int ip_vs_svc_unhash(struct ip_vs_service *svc)\n{\n\tif (!(svc->flags & IP_VS_SVC_F_HASHED)) {\n\t\tpr_err(\"%s(): request for unhash flagged, called from %pF\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t/* Remove it from the ip_vs_svc_table table */\n\t\tlist_del(&svc->s_list);\n\t} else {\n\t\t/* Remove it from the ip_vs_svc_fwm_table table */\n\t\tlist_del(&svc->f_list);\n\t}\n\n\tsvc->flags &= ~IP_VS_SVC_F_HASHED;\n\tatomic_dec(&svc->refcnt);\n\treturn 1;\n}\n\n\n/*\n *\tGet service by {proto,addr,port} in the service table.\n */\nstatic inline struct ip_vs_service *\n__ip_vs_service_get(int af, __u16 protocol, const union nf_inet_addr *vaddr,\n\t\t    __be16 vport)\n{\n\tunsigned hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for \"full\" addressed entries */\n\thash = ip_vs_svc_hashkey(af, protocol, vaddr, vport);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_table[hash], s_list){\n\t\tif ((svc->af == af)\n\t\t    && ip_vs_addr_equal(af, &svc->addr, vaddr)\n\t\t    && (svc->port == vport)\n\t\t    && (svc->protocol == protocol)) {\n\t\t\t/* HIT */\n\t\t\tatomic_inc(&svc->usecnt);\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n *\tGet service by {fwmark} in the service table.\n */\nstatic inline struct ip_vs_service *\n__ip_vs_svc_fwm_get(int af, __u32 fwmark)\n{\n\tunsigned hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for fwmark addressed entries */\n\thash = ip_vs_svc_fwm_hashkey(fwmark);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[hash], f_list) {\n\t\tif (svc->fwmark == fwmark && svc->af == af) {\n\t\t\t/* HIT */\n\t\t\tatomic_inc(&svc->usecnt);\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct ip_vs_service *\nip_vs_service_get(int af, __u32 fwmark, __u16 protocol,\n\t\t  const union nf_inet_addr *vaddr, __be16 vport)\n{\n\tstruct ip_vs_service *svc;\n\n\tread_lock(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tCheck the table hashed by fwmark first\n\t */\n\tif (fwmark && (svc = __ip_vs_svc_fwm_get(af, fwmark)))\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the table hashed by <protocol,addr,port>\n\t *\tfor \"full\" addressed entries\n\t */\n\tsvc = __ip_vs_service_get(af, protocol, vaddr, vport);\n\n\tif (svc == NULL\n\t    && protocol == IPPROTO_TCP\n\t    && atomic_read(&ip_vs_ftpsvc_counter)\n\t    && (vport == FTPDATA || ntohs(vport) >= PROT_SOCK)) {\n\t\t/*\n\t\t * Check if ftp service entry exists, the packet\n\t\t * might belong to FTP data connections.\n\t\t */\n\t\tsvc = __ip_vs_service_get(af, protocol, vaddr, FTPPORT);\n\t}\n\n\tif (svc == NULL\n\t    && atomic_read(&ip_vs_nullsvc_counter)) {\n\t\t/*\n\t\t * Check if the catch-all port (port zero) exists\n\t\t */\n\t\tsvc = __ip_vs_service_get(af, protocol, vaddr, 0);\n\t}\n\n  out:\n\tread_unlock(&__ip_vs_svc_lock);\n\n\tIP_VS_DBG_BUF(9, \"lookup service: fwm %u %s %s:%u %s\\n\",\n\t\t      fwmark, ip_vs_proto_name(protocol),\n\t\t      IP_VS_DBG_ADDR(af, vaddr), ntohs(vport),\n\t\t      svc ? \"hit\" : \"not hit\");\n\n\treturn svc;\n}\n\n\nstatic inline void\n__ip_vs_bind_svc(struct ip_vs_dest *dest, struct ip_vs_service *svc)\n{\n\tatomic_inc(&svc->refcnt);\n\tdest->svc = svc;\n}\n\nstatic inline void\n__ip_vs_unbind_svc(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_service *svc = dest->svc;\n\n\tdest->svc = NULL;\n\tif (atomic_dec_and_test(&svc->refcnt))\n\t\tkfree(svc);\n}\n\n\n/*\n *\tReturns hash value for real service\n */\nstatic inline unsigned ip_vs_rs_hashkey(int af,\n\t\t\t\t\t    const union nf_inet_addr *addr,\n\t\t\t\t\t    __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\n\t\t& IP_VS_RTAB_MASK;\n}\n\n/*\n *\tHashes ip_vs_dest in ip_vs_rtable by <proto,addr,port>.\n *\tshould be called with locked tables.\n */\nstatic int ip_vs_rs_hash(struct ip_vs_dest *dest)\n{\n\tunsigned hash;\n\n\tif (!list_empty(&dest->d_list)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tHash by proto,addr,port,\n\t *\twhich are the parameters of the real service.\n\t */\n\thash = ip_vs_rs_hashkey(dest->af, &dest->addr, dest->port);\n\n\tlist_add(&dest->d_list, &ip_vs_rtable[hash]);\n\n\treturn 1;\n}\n\n/*\n *\tUNhashes ip_vs_dest from ip_vs_rtable.\n *\tshould be called with locked tables.\n */\nstatic int ip_vs_rs_unhash(struct ip_vs_dest *dest)\n{\n\t/*\n\t * Remove it from the ip_vs_rtable table.\n\t */\n\tif (!list_empty(&dest->d_list)) {\n\t\tlist_del(&dest->d_list);\n\t\tINIT_LIST_HEAD(&dest->d_list);\n\t}\n\n\treturn 1;\n}\n\n/*\n *\tLookup real service by <proto,addr,port> in the real service table.\n */\nstruct ip_vs_dest *\nip_vs_lookup_real_service(int af, __u16 protocol,\n\t\t\t  const union nf_inet_addr *daddr,\n\t\t\t  __be16 dport)\n{\n\tunsigned hash;\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t *\tCheck for \"full\" addressed entries\n\t *\tReturn the first found entry\n\t */\n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\tread_lock(&__ip_vs_rs_lock);\n\tlist_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {\n\t\tif ((dest->af == af)\n\t\t    && ip_vs_addr_equal(af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)\n\t\t    && ((dest->protocol == protocol) ||\n\t\t\tdest->vfwmark)) {\n\t\t\t/* HIT */\n\t\t\tread_unlock(&__ip_vs_rs_lock);\n\t\t\treturn dest;\n\t\t}\n\t}\n\tread_unlock(&__ip_vs_rs_lock);\n\n\treturn NULL;\n}\n\n/*\n *\tLookup destination by {addr,port} in the given service\n */\nstatic struct ip_vs_dest *\nip_vs_lookup_dest(struct ip_vs_service *svc, const union nf_inet_addr *daddr,\n\t\t  __be16 dport)\n{\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t * Find the destination for the given service\n\t */\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tif ((dest->af == svc->af)\n\t\t    && ip_vs_addr_equal(svc->af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)) {\n\t\t\t/* HIT */\n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Find destination by {daddr,dport,vaddr,protocol}\n * Cretaed to be used in ip_vs_process_message() in\n * the backup synchronization daemon. It finds the\n * destination to be bound to the received connection\n * on the backup.\n *\n * ip_vs_lookup_real_service() looked promissing, but\n * seems not working as expected.\n */\nstruct ip_vs_dest *ip_vs_find_dest(int af, const union nf_inet_addr *daddr,\n\t\t\t\t   __be16 dport,\n\t\t\t\t   const union nf_inet_addr *vaddr,\n\t\t\t\t   __be16 vport, __u16 protocol)\n{\n\tstruct ip_vs_dest *dest;\n\tstruct ip_vs_service *svc;\n\n\tsvc = ip_vs_service_get(af, 0, protocol, vaddr, vport);\n\tif (!svc)\n\t\treturn NULL;\n\tdest = ip_vs_lookup_dest(svc, daddr, dport);\n\tif (dest)\n\t\tatomic_inc(&dest->refcnt);\n\tip_vs_service_put(svc);\n\treturn dest;\n}\n\n/*\n *  Lookup dest by {svc,addr,port} in the destination trash.\n *  The destination trash is used to hold the destinations that are removed\n *  from the service table but are still referenced by some conn entries.\n *  The reason to add the destination trash is when the dest is temporary\n *  down (either by administrator or by monitor program), the dest can be\n *  picked back from the trash, the remaining connections to the dest can\n *  continue, and the counting information of the dest is also useful for\n *  scheduling.\n */\nstatic struct ip_vs_dest *\nip_vs_trash_get_dest(struct ip_vs_service *svc, const union nf_inet_addr *daddr,\n\t\t     __be16 dport)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\n\t/*\n\t * Find the destination in trash\n\t */\n\tlist_for_each_entry_safe(dest, nxt, &ip_vs_dest_trash, n_list) {\n\t\tIP_VS_DBG_BUF(3, \"Destination %u/%s:%u still in trash, \"\n\t\t\t      \"dest->refcnt=%d\\n\",\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      atomic_read(&dest->refcnt));\n\t\tif (dest->af == svc->af &&\n\t\t    ip_vs_addr_equal(svc->af, &dest->addr, daddr) &&\n\t\t    dest->port == dport &&\n\t\t    dest->vfwmark == svc->fwmark &&\n\t\t    dest->protocol == svc->protocol &&\n\t\t    (svc->fwmark ||\n\t\t     (ip_vs_addr_equal(svc->af, &dest->vaddr, &svc->addr) &&\n\t\t      dest->vport == svc->port))) {\n\t\t\t/* HIT */\n\t\t\treturn dest;\n\t\t}\n\n\t\t/*\n\t\t * Try to purge the destination from trash if not referenced\n\t\t */\n\t\tif (atomic_read(&dest->refcnt) == 1) {\n\t\t\tIP_VS_DBG_BUF(3, \"Removing destination %u/%s:%u \"\n\t\t\t\t      \"from trash\\n\",\n\t\t\t\t      dest->vfwmark,\n\t\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->addr),\n\t\t\t\t      ntohs(dest->port));\n\t\t\tlist_del(&dest->n_list);\n\t\t\tip_vs_dst_reset(dest);\n\t\t\t__ip_vs_unbind_svc(dest);\n\t\t\tkfree(dest);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n *  Clean up all the destinations in the trash\n *  Called by the ip_vs_control_cleanup()\n *\n *  When the ip_vs_control_clearup is activated by ipvs module exit,\n *  the service tables must have been flushed and all the connections\n *  are expired, and the refcnt of each destination in the trash must\n *  be 1, so we simply release them here.\n */\nstatic void ip_vs_trash_cleanup(void)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\n\tlist_for_each_entry_safe(dest, nxt, &ip_vs_dest_trash, n_list) {\n\t\tlist_del(&dest->n_list);\n\t\tip_vs_dst_reset(dest);\n\t\t__ip_vs_unbind_svc(dest);\n\t\tkfree(dest);\n\t}\n}\n\n\nstatic void\nip_vs_zero_stats(struct ip_vs_stats *stats)\n{\n\tspin_lock_bh(&stats->lock);\n\n\tmemset(&stats->ustats, 0, sizeof(stats->ustats));\n\tip_vs_zero_estimator(stats);\n\n\tspin_unlock_bh(&stats->lock);\n}\n\n/*\n *\tUpdate a destination in the given service\n */\nstatic void\n__ip_vs_update_dest(struct ip_vs_service *svc,\n\t\t    struct ip_vs_dest *dest, struct ip_vs_dest_user_kern *udest)\n{\n\tint conn_flags;\n\n\t/* set the weight and the flags */\n\tatomic_set(&dest->weight, udest->weight);\n\tconn_flags = udest->conn_flags | IP_VS_CONN_F_INACTIVE;\n\n\t/* check if local node and update the flags */\n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6) {\n\t\tif (__ip_vs_addr_is_local_v6(&udest->addr.in6)) {\n\t\t\tconn_flags = (conn_flags & ~IP_VS_CONN_F_FWD_MASK)\n\t\t\t\t| IP_VS_CONN_F_LOCALNODE;\n\t\t}\n\t} else\n#endif\n\t\tif (inet_addr_type(&init_net, udest->addr.ip) == RTN_LOCAL) {\n\t\t\tconn_flags = (conn_flags & ~IP_VS_CONN_F_FWD_MASK)\n\t\t\t\t| IP_VS_CONN_F_LOCALNODE;\n\t\t}\n\n\t/* set the IP_VS_CONN_F_NOOUTPUT flag if not masquerading/NAT */\n\tif ((conn_flags & IP_VS_CONN_F_FWD_MASK) != 0) {\n\t\tconn_flags |= IP_VS_CONN_F_NOOUTPUT;\n\t} else {\n\t\t/*\n\t\t *    Put the real service in ip_vs_rtable if not present.\n\t\t *    For now only for NAT!\n\t\t */\n\t\twrite_lock_bh(&__ip_vs_rs_lock);\n\t\tip_vs_rs_hash(dest);\n\t\twrite_unlock_bh(&__ip_vs_rs_lock);\n\t}\n\tatomic_set(&dest->conn_flags, conn_flags);\n\n\t/* bind the service */\n\tif (!dest->svc) {\n\t\t__ip_vs_bind_svc(dest, svc);\n\t} else {\n\t\tif (dest->svc != svc) {\n\t\t\t__ip_vs_unbind_svc(dest);\n\t\t\tip_vs_zero_stats(&dest->stats);\n\t\t\t__ip_vs_bind_svc(dest, svc);\n\t\t}\n\t}\n\n\t/* set the dest status flags */\n\tdest->flags |= IP_VS_DEST_F_AVAILABLE;\n\n\tif (udest->u_threshold == 0 || udest->u_threshold > dest->u_threshold)\n\t\tdest->flags &= ~IP_VS_DEST_F_OVERLOAD;\n\tdest->u_threshold = udest->u_threshold;\n\tdest->l_threshold = udest->l_threshold;\n}\n\n\n/*\n *\tCreate a destination for the given service\n */\nstatic int\nip_vs_new_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest,\n\t       struct ip_vs_dest **dest_p)\n{\n\tstruct ip_vs_dest *dest;\n\tunsigned atype;\n\n\tEnterFunction(2);\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (svc->af == AF_INET6) {\n\t\tatype = ipv6_addr_type(&udest->addr.in6);\n\t\tif ((!(atype & IPV6_ADDR_UNICAST) ||\n\t\t\tatype & IPV6_ADDR_LINKLOCAL) &&\n\t\t\t!__ip_vs_addr_is_local_v6(&udest->addr.in6))\n\t\t\treturn -EINVAL;\n\t} else\n#endif\n\t{\n\t\tatype = inet_addr_type(&init_net, udest->addr.ip);\n\t\tif (atype != RTN_LOCAL && atype != RTN_UNICAST)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdest = kzalloc(sizeof(struct ip_vs_dest), GFP_ATOMIC);\n\tif (dest == NULL) {\n\t\tpr_err(\"%s(): no memory.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdest->af = svc->af;\n\tdest->protocol = svc->protocol;\n\tdest->vaddr = svc->addr;\n\tdest->vport = svc->port;\n\tdest->vfwmark = svc->fwmark;\n\tip_vs_addr_copy(svc->af, &dest->addr, &udest->addr);\n\tdest->port = udest->port;\n\n\tatomic_set(&dest->activeconns, 0);\n\tatomic_set(&dest->inactconns, 0);\n\tatomic_set(&dest->persistconns, 0);\n\tatomic_set(&dest->refcnt, 0);\n\n\tINIT_LIST_HEAD(&dest->d_list);\n\tspin_lock_init(&dest->dst_lock);\n\tspin_lock_init(&dest->stats.lock);\n\t__ip_vs_update_dest(svc, dest, udest);\n\tip_vs_new_estimator(&dest->stats);\n\n\t*dest_p = dest;\n\n\tLeaveFunction(2);\n\treturn 0;\n}\n\n\n/*\n *\tAdd a destination into an existing service\n */\nstatic int\nip_vs_add_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\tint ret;\n\n\tEnterFunction(2);\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tip_vs_addr_copy(svc->af, &daddr, &udest->addr);\n\n\t/*\n\t * Check if the dest already exists in the list\n\t */\n\tdest = ip_vs_lookup_dest(svc, &daddr, dport);\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t/*\n\t * Check if the dest already exists in the trash and\n\t * is from the same service\n\t */\n\tdest = ip_vs_trash_get_dest(svc, &daddr, dport);\n\n\tif (dest != NULL) {\n\t\tIP_VS_DBG_BUF(3, \"Get destination %s:%u from trash, \"\n\t\t\t      \"dest->refcnt=%d, service %u/%s:%u\\n\",\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &daddr), ntohs(dport),\n\t\t\t      atomic_read(&dest->refcnt),\n\t\t\t      dest->vfwmark,\n\t\t\t      IP_VS_DBG_ADDR(svc->af, &dest->vaddr),\n\t\t\t      ntohs(dest->vport));\n\n\t\t__ip_vs_update_dest(svc, dest, udest);\n\n\t\t/*\n\t\t * Get the destination from the trash\n\t\t */\n\t\tlist_del(&dest->n_list);\n\n\t\tip_vs_new_estimator(&dest->stats);\n\n\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t\t/*\n\t\t * Wait until all other svc users go away.\n\t\t */\n\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t\tlist_add(&dest->n_list, &svc->destinations);\n\t\tsvc->num_dests++;\n\n\t\t/* call the update_service function of its scheduler */\n\t\tif (svc->scheduler->update_service)\n\t\t\tsvc->scheduler->update_service(svc);\n\n\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate and initialize the dest structure\n\t */\n\tret = ip_vs_new_dest(svc, udest, &dest);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Add the dest entry into the list\n\t */\n\tatomic_inc(&dest->refcnt);\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t * Wait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\tlist_add(&dest->n_list, &svc->destinations);\n\tsvc->num_dests++;\n\n\t/* call the update_service function of its scheduler */\n\tif (svc->scheduler->update_service)\n\t\tsvc->scheduler->update_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tEdit a destination in the given service\n */\nstatic int\nip_vs_edit_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\tunion nf_inet_addr daddr;\n\t__be16 dport = udest->port;\n\n\tEnterFunction(2);\n\n\tif (udest->weight < 0) {\n\t\tpr_err(\"%s(): server weight less than zero\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tif (udest->l_threshold > udest->u_threshold) {\n\t\tpr_err(\"%s(): lower threshold is higher than upper threshold\\n\",\n\t\t\t__func__);\n\t\treturn -ERANGE;\n\t}\n\n\tip_vs_addr_copy(svc->af, &daddr, &udest->addr);\n\n\t/*\n\t *  Lookup the destination list\n\t */\n\tdest = ip_vs_lookup_dest(svc, &daddr, dport);\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): dest doesn't exist\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\t__ip_vs_update_dest(svc, dest, udest);\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/* Wait until all other svc users go away */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/* call the update_service, because server weight may be changed */\n\tif (svc->scheduler->update_service)\n\t\tsvc->scheduler->update_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tDelete a destination (must be already unlinked from the service)\n */\nstatic void __ip_vs_del_dest(struct ip_vs_dest *dest)\n{\n\tip_vs_kill_estimator(&dest->stats);\n\n\t/*\n\t *  Remove it from the d-linked list with the real services.\n\t */\n\twrite_lock_bh(&__ip_vs_rs_lock);\n\tip_vs_rs_unhash(dest);\n\twrite_unlock_bh(&__ip_vs_rs_lock);\n\n\t/*\n\t *  Decrease the refcnt of the dest, and free the dest\n\t *  if nobody refers to it (refcnt=0). Otherwise, throw\n\t *  the destination into the trash.\n\t */\n\tif (atomic_dec_and_test(&dest->refcnt)) {\n\t\tip_vs_dst_reset(dest);\n\t\t/* simply decrease svc->refcnt here, let the caller check\n\t\t   and release the service if nobody refers to it.\n\t\t   Only user context can release destination and service,\n\t\t   and only one user context can update virtual service at a\n\t\t   time, so the operation here is OK */\n\t\tatomic_dec(&dest->svc->refcnt);\n\t\tkfree(dest);\n\t} else {\n\t\tIP_VS_DBG_BUF(3, \"Moving dest %s:%u into trash, \"\n\t\t\t      \"dest->refcnt=%d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(dest->af, &dest->addr),\n\t\t\t      ntohs(dest->port),\n\t\t\t      atomic_read(&dest->refcnt));\n\t\tlist_add(&dest->n_list, &ip_vs_dest_trash);\n\t\tatomic_inc(&dest->refcnt);\n\t}\n}\n\n\n/*\n *\tUnlink a destination from the given service\n */\nstatic void __ip_vs_unlink_dest(struct ip_vs_service *svc,\n\t\t\t\tstruct ip_vs_dest *dest,\n\t\t\t\tint svcupd)\n{\n\tdest->flags &= ~IP_VS_DEST_F_AVAILABLE;\n\n\t/*\n\t *  Remove it from the d-linked destination list.\n\t */\n\tlist_del(&dest->n_list);\n\tsvc->num_dests--;\n\n\t/*\n\t *  Call the update_service function of its scheduler\n\t */\n\tif (svcupd && svc->scheduler->update_service)\n\t\t\tsvc->scheduler->update_service(svc);\n}\n\n\n/*\n *\tDelete a destination server in the given service\n */\nstatic int\nip_vs_del_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)\n{\n\tstruct ip_vs_dest *dest;\n\t__be16 dport = udest->port;\n\n\tEnterFunction(2);\n\n\tdest = ip_vs_lookup_dest(svc, &udest->addr, dport);\n\n\tif (dest == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): destination not found!\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tWait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/*\n\t *\tUnlink dest from the service\n\t */\n\t__ip_vs_unlink_dest(svc, dest, 1);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t *\tDelete the destination\n\t */\n\t__ip_vs_del_dest(dest);\n\n\tLeaveFunction(2);\n\n\treturn 0;\n}\n\n\n/*\n *\tAdd a service into the service hash table\n */\nstatic int\nip_vs_add_service(struct ip_vs_service_user_kern *u,\n\t\t  struct ip_vs_service **svc_p)\n{\n\tint ret = 0;\n\tstruct ip_vs_scheduler *sched = NULL;\n\tstruct ip_vs_service *svc = NULL;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\t/* Lookup the scheduler by 'u->sched_name' */\n\tsched = ip_vs_scheduler_get(u->sched_name);\n\tif (sched == NULL) {\n\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\", u->sched_name);\n\t\tret = -ENOENT;\n\t\tgoto out_mod_dec;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6 && (u->netmask < 1 || u->netmask > 128)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n#endif\n\n\tsvc = kzalloc(sizeof(struct ip_vs_service), GFP_ATOMIC);\n\tif (svc == NULL) {\n\t\tIP_VS_DBG(1, \"%s(): no memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t/* I'm the first user of the service */\n\tatomic_set(&svc->usecnt, 1);\n\tatomic_set(&svc->refcnt, 0);\n\n\tsvc->af = u->af;\n\tsvc->protocol = u->protocol;\n\tip_vs_addr_copy(svc->af, &svc->addr, &u->addr);\n\tsvc->port = u->port;\n\tsvc->fwmark = u->fwmark;\n\tsvc->flags = u->flags;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\tINIT_LIST_HEAD(&svc->destinations);\n\trwlock_init(&svc->sched_lock);\n\tspin_lock_init(&svc->stats.lock);\n\n\t/* Bind the scheduler */\n\tret = ip_vs_bind_scheduler(svc, sched);\n\tif (ret)\n\t\tgoto out_err;\n\tsched = NULL;\n\n\t/* Update the virtual service counters */\n\tif (svc->port == FTPPORT)\n\t\tatomic_inc(&ip_vs_ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_inc(&ip_vs_nullsvc_counter);\n\n\tip_vs_new_estimator(&svc->stats);\n\n\t/* Count only IPv4 services for old get/setsockopt interface */\n\tif (svc->af == AF_INET)\n\t\tip_vs_num_services++;\n\n\t/* Hash the service into the service table */\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\tip_vs_svc_hash(svc);\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\t*svc_p = svc;\n\treturn 0;\n\n  out_err:\n\tif (svc != NULL) {\n\t\tif (svc->scheduler)\n\t\t\tip_vs_unbind_scheduler(svc);\n\t\tif (svc->inc) {\n\t\t\tlocal_bh_disable();\n\t\t\tip_vs_app_inc_put(svc->inc);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t\tkfree(svc);\n\t}\n\tip_vs_scheduler_put(sched);\n\n  out_mod_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n\n\n/*\n *\tEdit a service and bind it with a new scheduler\n */\nstatic int\nip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)\n{\n\tstruct ip_vs_scheduler *sched, *old_sched;\n\tint ret = 0;\n\n\t/*\n\t * Lookup the scheduler, by 'u->sched_name'\n\t */\n\tsched = ip_vs_scheduler_get(u->sched_name);\n\tif (sched == NULL) {\n\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\", u->sched_name);\n\t\treturn -ENOENT;\n\t}\n\told_sched = sched;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6 && (u->netmask < 1 || u->netmask > 128)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t * Wait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t/*\n\t * Set the flags and timeout value\n\t */\n\tsvc->flags = u->flags | IP_VS_SVC_F_HASHED;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\told_sched = svc->scheduler;\n\tif (sched != old_sched) {\n\t\t/*\n\t\t * Unbind the old scheduler\n\t\t */\n\t\tif ((ret = ip_vs_unbind_scheduler(svc))) {\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Bind the new scheduler\n\t\t */\n\t\tif ((ret = ip_vs_bind_scheduler(svc, sched))) {\n\t\t\t/*\n\t\t\t * If ip_vs_bind_scheduler fails, restore the old\n\t\t\t * scheduler.\n\t\t\t * The main reason of failure is out of memory.\n\t\t\t *\n\t\t\t * The question is if the old scheduler can be\n\t\t\t * restored all the time. TODO: if it cannot be\n\t\t\t * restored some time, we must delete the service,\n\t\t\t * otherwise the system may crash.\n\t\t\t */\n\t\t\tip_vs_bind_scheduler(svc, old_sched);\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n  out_unlock:\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n#ifdef CONFIG_IP_VS_IPV6\n  out:\n#endif\n\n\tif (old_sched)\n\t\tip_vs_scheduler_put(old_sched);\n\n\treturn ret;\n}\n\n\n/*\n *\tDelete a service from the service list\n *\t- The service must be unlinked, unlocked and not referenced!\n *\t- We are called under _bh lock\n */\nstatic void __ip_vs_del_service(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\tstruct ip_vs_scheduler *old_sched;\n\n\t/* Count only IPv4 services for old get/setsockopt interface */\n\tif (svc->af == AF_INET)\n\t\tip_vs_num_services--;\n\n\tip_vs_kill_estimator(&svc->stats);\n\n\t/* Unbind scheduler */\n\told_sched = svc->scheduler;\n\tip_vs_unbind_scheduler(svc);\n\tif (old_sched)\n\t\tip_vs_scheduler_put(old_sched);\n\n\t/* Unbind app inc */\n\tif (svc->inc) {\n\t\tip_vs_app_inc_put(svc->inc);\n\t\tsvc->inc = NULL;\n\t}\n\n\t/*\n\t *    Unlink the whole destination list\n\t */\n\tlist_for_each_entry_safe(dest, nxt, &svc->destinations, n_list) {\n\t\t__ip_vs_unlink_dest(svc, dest, 0);\n\t\t__ip_vs_del_dest(dest);\n\t}\n\n\t/*\n\t *    Update the virtual service counters\n\t */\n\tif (svc->port == FTPPORT)\n\t\tatomic_dec(&ip_vs_ftpsvc_counter);\n\telse if (svc->port == 0)\n\t\tatomic_dec(&ip_vs_nullsvc_counter);\n\n\t/*\n\t *    Free the service if nobody refers to it\n\t */\n\tif (atomic_read(&svc->refcnt) == 0)\n\t\tkfree(svc);\n\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n}\n\n/*\n *\tDelete a service from the service list\n */\nstatic int ip_vs_del_service(struct ip_vs_service *svc)\n{\n\tif (svc == NULL)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Unhash it from the service table\n\t */\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\tip_vs_svc_unhash(svc);\n\n\t/*\n\t * Wait until all the svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 1);\n\n\t__ip_vs_del_service(svc);\n\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\n\treturn 0;\n}\n\n\n/*\n *\tFlush all the virtual services\n */\nstatic int ip_vs_flush(void)\n{\n\tint idx;\n\tstruct ip_vs_service *svc, *nxt;\n\n\t/*\n\t * Flush the service table hashed by <protocol,addr,port>\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt, &ip_vs_svc_table[idx], s_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\t/*\n\t * Flush the service table hashed by fwmark\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt,\n\t\t\t\t\t &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *\tZero counters in a service or all services\n */\nstatic int ip_vs_zero_service(struct ip_vs_service *svc)\n{\n\tstruct ip_vs_dest *dest;\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tip_vs_zero_stats(&dest->stats);\n\t}\n\tip_vs_zero_stats(&svc->stats);\n\twrite_unlock_bh(&__ip_vs_svc_lock);\n\treturn 0;\n}\n\nstatic int ip_vs_zero_all(void)\n{\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tip_vs_zero_service(svc);\n\t\t}\n\t}\n\n\tip_vs_zero_stats(&ip_vs_stats);\n\treturn 0;\n}\n\n\nstatic int\nproc_do_defense_mode(ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val = *valp;\n\tint rc;\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (*valp != val)) {\n\t\tif ((*valp < 0) || (*valp > 3)) {\n\t\t\t/* Restore the correct value */\n\t\t\t*valp = val;\n\t\t} else {\n\t\t\tupdate_defense_level();\n\t\t}\n\t}\n\treturn rc;\n}\n\n\nstatic int\nproc_do_sync_threshold(ctl_table *table, int write,\n\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val[2];\n\tint rc;\n\n\t/* backup the value first */\n\tmemcpy(val, valp, sizeof(val));\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (valp[0] < 0 || valp[1] < 0 || valp[0] >= valp[1])) {\n\t\t/* Restore the correct value */\n\t\tmemcpy(valp, val, sizeof(val));\n\t}\n\treturn rc;\n}\n\n\n/*\n *\tIPVS sysctl table (under the /proc/sys/net/ipv4/vs/)\n */\n\nstatic struct ctl_table vs_vars[] = {\n\t{\n\t\t.procname\t= \"amemthresh\",\n\t\t.data\t\t= &sysctl_ip_vs_amemthresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_IP_VS_DEBUG\n\t{\n\t\t.procname\t= \"debug_level\",\n\t\t.data\t\t= &sysctl_ip_vs_debug_level,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"am_droprate\",\n\t\t.data\t\t= &sysctl_ip_vs_am_droprate,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"drop_entry\",\n\t\t.data\t\t= &sysctl_ip_vs_drop_entry,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"drop_packet\",\n\t\t.data\t\t= &sysctl_ip_vs_drop_packet,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n\t{\n\t\t.procname\t= \"secure_tcp\",\n\t\t.data\t\t= &sysctl_ip_vs_secure_tcp,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_defense_mode,\n\t},\n#if 0\n\t{\n\t\t.procname\t= \"timeout_established\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_ESTABLISHED],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synsent\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYN_SENT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synrecv\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYN_RECV],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_finwait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_FIN_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_timewait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_TIME_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_close\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_CLOSE],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_closewait\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_CLOSE_WAIT],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_lastack\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_LAST_ACK],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_listen\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_LISTEN],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_synack\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_SYNACK],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_udp\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_UDP],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"timeout_icmp\",\n\t\t.data\t= &vs_timeout_table_dos.timeout[IP_VS_S_ICMP],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"cache_bypass\",\n\t\t.data\t\t= &sysctl_ip_vs_cache_bypass,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_nodest_conn\",\n\t\t.data\t\t= &sysctl_ip_vs_expire_nodest_conn,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"expire_quiescent_template\",\n\t\t.data\t\t= &sysctl_ip_vs_expire_quiescent_template,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sync_threshold\",\n\t\t.data\t\t= &sysctl_ip_vs_sync_threshold,\n\t\t.maxlen\t\t= sizeof(sysctl_ip_vs_sync_threshold),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_sync_threshold,\n\t},\n\t{\n\t\t.procname\t= \"nat_icmp_send\",\n\t\t.data\t\t= &sysctl_ip_vs_nat_icmp_send,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nconst struct ctl_path net_vs_ctl_path[] = {\n\t{ .procname = \"net\", },\n\t{ .procname = \"ipv4\", },\n\t{ .procname = \"vs\", },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(net_vs_ctl_path);\n\nstatic struct ctl_table_header * sysctl_header;\n\n#ifdef CONFIG_PROC_FS\n\nstruct ip_vs_iter {\n\tstruct list_head *table;\n\tint bucket;\n};\n\n/*\n *\tWrite the contents of the VS rule table to a PROCfs file.\n *\t(It is kept just for backward compatibility)\n */\nstatic inline const char *ip_vs_fwd_name(unsigned flags)\n{\n\tswitch (flags & IP_VS_CONN_F_FWD_MASK) {\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\treturn \"Local\";\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\treturn \"Tunnel\";\n\tcase IP_VS_CONN_F_DROUTE:\n\t\treturn \"Route\";\n\tdefault:\n\t\treturn \"Masq\";\n\t}\n}\n\n\n/* Get the Nth entry in the two lists */\nstatic struct ip_vs_service *ip_vs_info_array(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_vs_iter *iter = seq->private;\n\tint idx;\n\tstruct ip_vs_service *svc;\n\n\t/* look in hash by protocol */\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\tif (pos-- == 0){\n\t\t\t\titer->table = ip_vs_svc_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* keep looking in fwmark */\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\tif (pos-- == 0) {\n\t\t\t\titer->table = ip_vs_svc_fwm_table;\n\t\t\t\titer->bucket = idx;\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ip_vs_info_seq_start(struct seq_file *seq, loff_t *pos)\n__acquires(__ip_vs_svc_lock)\n{\n\n\tread_lock_bh(&__ip_vs_svc_lock);\n\treturn *pos ? ip_vs_info_array(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\n\nstatic void *ip_vs_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct list_head *e;\n\tstruct ip_vs_iter *iter;\n\tstruct ip_vs_service *svc;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip_vs_info_array(seq,0);\n\n\tsvc = v;\n\titer = seq->private;\n\n\tif (iter->table == ip_vs_svc_table) {\n\t\t/* next service in table hashed by protocol */\n\t\tif ((e = svc->s_list.next) != &ip_vs_svc_table[iter->bucket])\n\t\t\treturn list_entry(e, struct ip_vs_service, s_list);\n\n\n\t\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\t\tlist_for_each_entry(svc,&ip_vs_svc_table[iter->bucket],\n\t\t\t\t\t    s_list) {\n\t\t\t\treturn svc;\n\t\t\t}\n\t\t}\n\n\t\titer->table = ip_vs_svc_fwm_table;\n\t\titer->bucket = -1;\n\t\tgoto scan_fwmark;\n\t}\n\n\t/* next service in hashed by fwmark */\n\tif ((e = svc->f_list.next) != &ip_vs_svc_fwm_table[iter->bucket])\n\t\treturn list_entry(e, struct ip_vs_service, f_list);\n\n scan_fwmark:\n\twhile (++iter->bucket < IP_VS_SVC_TAB_SIZE) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[iter->bucket],\n\t\t\t\t    f_list)\n\t\t\treturn svc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ip_vs_info_seq_stop(struct seq_file *seq, void *v)\n__releases(__ip_vs_svc_lock)\n{\n\tread_unlock_bh(&__ip_vs_svc_lock);\n}\n\n\nstatic int ip_vs_info_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t\"IP Virtual Server version %d.%d.%d (size=%d)\\n\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tseq_puts(seq,\n\t\t\t \"Prot LocalAddress:Port Scheduler Flags\\n\");\n\t\tseq_puts(seq,\n\t\t\t \"  -> RemoteAddress:Port Forward Weight ActiveConn InActConn\\n\");\n\t} else {\n\t\tconst struct ip_vs_service *svc = v;\n\t\tconst struct ip_vs_iter *iter = seq->private;\n\t\tconst struct ip_vs_dest *dest;\n\n\t\tif (iter->table == ip_vs_svc_table) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (svc->af == AF_INET6)\n\t\t\t\tseq_printf(seq, \"%s  [%pI6]:%04X %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   &svc->addr.in6,\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   svc->scheduler->name);\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq, \"%s  %08X:%04X %s \",\n\t\t\t\t\t   ip_vs_proto_name(svc->protocol),\n\t\t\t\t\t   ntohl(svc->addr.ip),\n\t\t\t\t\t   ntohs(svc->port),\n\t\t\t\t\t   svc->scheduler->name);\n\t\t} else {\n\t\t\tseq_printf(seq, \"FWM  %08X %s \",\n\t\t\t\t   svc->fwmark, svc->scheduler->name);\n\t\t}\n\n\t\tif (svc->flags & IP_VS_SVC_F_PERSISTENT)\n\t\t\tseq_printf(seq, \"persistent %d %08X\\n\",\n\t\t\t\tsvc->timeout,\n\t\t\t\tntohl(svc->netmask));\n\t\telse\n\t\t\tseq_putc(seq, '\\n');\n\n\t\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n#ifdef CONFIG_IP_VS_IPV6\n\t\t\tif (dest->af == AF_INET6)\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> [%pI6]:%04X\"\n\t\t\t\t\t   \"      %-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   &dest->addr.in6,\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\t\t\telse\n#endif\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"  -> %08X:%04X      \"\n\t\t\t\t\t   \"%-7s %-6d %-10d %-10d\\n\",\n\t\t\t\t\t   ntohl(dest->addr.ip),\n\t\t\t\t\t   ntohs(dest->port),\n\t\t\t\t\t   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),\n\t\t\t\t\t   atomic_read(&dest->weight),\n\t\t\t\t\t   atomic_read(&dest->activeconns),\n\t\t\t\t\t   atomic_read(&dest->inactconns));\n\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip_vs_info_seq_ops = {\n\t.start = ip_vs_info_seq_start,\n\t.next  = ip_vs_info_seq_next,\n\t.stop  = ip_vs_info_seq_stop,\n\t.show  = ip_vs_info_seq_show,\n};\n\nstatic int ip_vs_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_private(file, &ip_vs_info_seq_ops,\n\t\t\tsizeof(struct ip_vs_iter));\n}\n\nstatic const struct file_operations ip_vs_info_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ip_vs_info_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\n\n#endif\n\nstruct ip_vs_stats ip_vs_stats = {\n\t.lock = __SPIN_LOCK_UNLOCKED(ip_vs_stats.lock),\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int ip_vs_stats_show(struct seq_file *seq, void *v)\n{\n\n/*               01234567 01234567 01234567 0123456701234567 0123456701234567 */\n\tseq_puts(seq,\n\t\t \"   Total Incoming Outgoing         Incoming         Outgoing\\n\");\n\tseq_printf(seq,\n\t\t   \"   Conns  Packets  Packets            Bytes            Bytes\\n\");\n\n\tspin_lock_bh(&ip_vs_stats.lock);\n\tseq_printf(seq, \"%8X %8X %8X %16LX %16LX\\n\\n\", ip_vs_stats.ustats.conns,\n\t\t   ip_vs_stats.ustats.inpkts, ip_vs_stats.ustats.outpkts,\n\t\t   (unsigned long long) ip_vs_stats.ustats.inbytes,\n\t\t   (unsigned long long) ip_vs_stats.ustats.outbytes);\n\n/*                 01234567 01234567 01234567 0123456701234567 0123456701234567 */\n\tseq_puts(seq,\n\t\t   \" Conns/s   Pkts/s   Pkts/s          Bytes/s          Bytes/s\\n\");\n\tseq_printf(seq,\"%8X %8X %8X %16X %16X\\n\",\n\t\t\tip_vs_stats.ustats.cps,\n\t\t\tip_vs_stats.ustats.inpps,\n\t\t\tip_vs_stats.ustats.outpps,\n\t\t\tip_vs_stats.ustats.inbps,\n\t\t\tip_vs_stats.ustats.outbps);\n\tspin_unlock_bh(&ip_vs_stats.lock);\n\n\treturn 0;\n}\n\nstatic int ip_vs_stats_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ip_vs_stats_show, NULL);\n}\n\nstatic const struct file_operations ip_vs_stats_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ip_vs_stats_seq_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\n#endif\n\n/*\n *\tSet timeout values for tcp tcpfin udp in the timeout_table.\n */\nstatic int ip_vs_set_timeout(struct ip_vs_timeout_user *u)\n{\n\tIP_VS_DBG(2, \"Setting timeout tcp:%d tcpfin:%d udp:%d\\n\",\n\t\t  u->tcp_timeout,\n\t\t  u->tcp_fin_timeout,\n\t\t  u->udp_timeout);\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tif (u->tcp_timeout) {\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_ESTABLISHED]\n\t\t\t= u->tcp_timeout * HZ;\n\t}\n\n\tif (u->tcp_fin_timeout) {\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_FIN_WAIT]\n\t\t\t= u->tcp_fin_timeout * HZ;\n\t}\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tif (u->udp_timeout) {\n\t\tip_vs_protocol_udp.timeout_table[IP_VS_UDP_S_NORMAL]\n\t\t\t= u->udp_timeout * HZ;\n\t}\n#endif\n\treturn 0;\n}\n\n\n#define SET_CMDID(cmd)\t\t(cmd - IP_VS_BASE_CTL)\n#define SERVICE_ARG_LEN\t\t(sizeof(struct ip_vs_service_user))\n#define SVCDEST_ARG_LEN\t\t(sizeof(struct ip_vs_service_user) +\t\\\n\t\t\t\t sizeof(struct ip_vs_dest_user))\n#define TIMEOUT_ARG_LEN\t\t(sizeof(struct ip_vs_timeout_user))\n#define DAEMON_ARG_LEN\t\t(sizeof(struct ip_vs_daemon_user))\n#define MAX_ARG_LEN\t\tSVCDEST_ARG_LEN\n\nstatic const unsigned char set_arglen[SET_CMDID(IP_VS_SO_SET_MAX)+1] = {\n\t[SET_CMDID(IP_VS_SO_SET_ADD)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_EDIT)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_DEL)]\t\t= SERVICE_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_FLUSH)]\t\t= 0,\n\t[SET_CMDID(IP_VS_SO_SET_ADDDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_DELDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_EDITDEST)]\t= SVCDEST_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_TIMEOUT)]\t= TIMEOUT_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_STARTDAEMON)]\t= DAEMON_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_STOPDAEMON)]\t= DAEMON_ARG_LEN,\n\t[SET_CMDID(IP_VS_SO_SET_ZERO)]\t\t= SERVICE_ARG_LEN,\n};\n\nstatic void ip_vs_copy_usvc_compat(struct ip_vs_service_user_kern *usvc,\n\t\t\t\t  struct ip_vs_service_user *usvc_compat)\n{\n\tusvc->af\t\t= AF_INET;\n\tusvc->protocol\t\t= usvc_compat->protocol;\n\tusvc->addr.ip\t\t= usvc_compat->addr;\n\tusvc->port\t\t= usvc_compat->port;\n\tusvc->fwmark\t\t= usvc_compat->fwmark;\n\n\t/* Deep copy of sched_name is not needed here */\n\tusvc->sched_name\t= usvc_compat->sched_name;\n\n\tusvc->flags\t\t= usvc_compat->flags;\n\tusvc->timeout\t\t= usvc_compat->timeout;\n\tusvc->netmask\t\t= usvc_compat->netmask;\n}\n\nstatic void ip_vs_copy_udest_compat(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t   struct ip_vs_dest_user *udest_compat)\n{\n\tudest->addr.ip\t\t= udest_compat->addr;\n\tudest->port\t\t= udest_compat->port;\n\tudest->conn_flags\t= udest_compat->conn_flags;\n\tudest->weight\t\t= udest_compat->weight;\n\tudest->u_threshold\t= udest_compat->u_threshold;\n\tudest->l_threshold\t= udest_compat->l_threshold;\n}\n\nstatic int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n\n\nstatic void\nip_vs_copy_stats(struct ip_vs_stats_user *dst, struct ip_vs_stats *src)\n{\n\tspin_lock_bh(&src->lock);\n\tmemcpy(dst, &src->ustats, sizeof(*dst));\n\tspin_unlock_bh(&src->lock);\n}\n\nstatic void\nip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)\n{\n\tdst->protocol = src->protocol;\n\tdst->addr = src->addr.ip;\n\tdst->port = src->port;\n\tdst->fwmark = src->fwmark;\n\tstrlcpy(dst->sched_name, src->scheduler->name, sizeof(dst->sched_name));\n\tdst->flags = src->flags;\n\tdst->timeout = src->timeout / HZ;\n\tdst->netmask = src->netmask;\n\tdst->num_dests = src->num_dests;\n\tip_vs_copy_stats(&dst->stats, &src->stats);\n}\n\nstatic inline int\n__ip_vs_get_service_entries(const struct ip_vs_get_services *get,\n\t\t\t    struct ip_vs_get_services __user *uptr)\n{\n\tint idx, count=0;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_service_entry entry;\n\tint ret = 0;\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[idx], s_list) {\n\t\t\t/* Only expose IPv4 entries to old interface */\n\t\t\tif (svc->af != AF_INET)\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\t/* Only expose IPv4 entries to old interface */\n\t\t\tif (svc->af != AF_INET)\n\t\t\t\tcontinue;\n\n\t\t\tif (count >= get->num_services)\n\t\t\t\tgoto out;\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tip_vs_copy_service(&entry, svc);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n  out:\n\treturn ret;\n}\n\nstatic inline int\n__ip_vs_get_dest_entries(const struct ip_vs_get_dests *get,\n\t\t\t struct ip_vs_get_dests __user *uptr)\n{\n\tstruct ip_vs_service *svc;\n\tunion nf_inet_addr addr = { .ip = get->addr };\n\tint ret = 0;\n\n\tif (get->fwmark)\n\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, get->fwmark);\n\telse\n\t\tsvc = __ip_vs_service_get(AF_INET, get->protocol, &addr,\n\t\t\t\t\t  get->port);\n\n\tif (svc) {\n\t\tint count = 0;\n\t\tstruct ip_vs_dest *dest;\n\t\tstruct ip_vs_dest_entry entry;\n\n\t\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\t\tif (count >= get->num_dests)\n\t\t\t\tbreak;\n\n\t\t\tentry.addr = dest->addr.ip;\n\t\t\tentry.port = dest->port;\n\t\t\tentry.conn_flags = atomic_read(&dest->conn_flags);\n\t\t\tentry.weight = atomic_read(&dest->weight);\n\t\t\tentry.u_threshold = dest->u_threshold;\n\t\t\tentry.l_threshold = dest->l_threshold;\n\t\t\tentry.activeconns = atomic_read(&dest->activeconns);\n\t\t\tentry.inactconns = atomic_read(&dest->inactconns);\n\t\t\tentry.persistconns = atomic_read(&dest->persistconns);\n\t\t\tip_vs_copy_stats(&entry.stats, &dest->stats);\n\t\t\tif (copy_to_user(&uptr->entrytable[count],\n\t\t\t\t\t &entry, sizeof(entry))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tip_vs_service_put(svc);\n\t} else\n\t\tret = -ESRCH;\n\treturn ret;\n}\n\nstatic inline void\n__ip_vs_get_timeouts(struct ip_vs_timeout_user *u)\n{\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tu->tcp_timeout =\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_ESTABLISHED] / HZ;\n\tu->tcp_fin_timeout =\n\t\tip_vs_protocol_tcp.timeout_table[IP_VS_TCP_S_FIN_WAIT] / HZ;\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tu->udp_timeout =\n\t\tip_vs_protocol_udp.timeout_table[IP_VS_UDP_S_NORMAL] / HZ;\n#endif\n}\n\n\n#define GET_CMDID(cmd)\t\t(cmd - IP_VS_BASE_CTL)\n#define GET_INFO_ARG_LEN\t(sizeof(struct ip_vs_getinfo))\n#define GET_SERVICES_ARG_LEN\t(sizeof(struct ip_vs_get_services))\n#define GET_SERVICE_ARG_LEN\t(sizeof(struct ip_vs_service_entry))\n#define GET_DESTS_ARG_LEN\t(sizeof(struct ip_vs_get_dests))\n#define GET_TIMEOUT_ARG_LEN\t(sizeof(struct ip_vs_timeout_user))\n#define GET_DAEMON_ARG_LEN\t(sizeof(struct ip_vs_daemon_user) * 2)\n\nstatic const unsigned char get_arglen[GET_CMDID(IP_VS_SO_GET_MAX)+1] = {\n\t[GET_CMDID(IP_VS_SO_GET_VERSION)]\t= 64,\n\t[GET_CMDID(IP_VS_SO_GET_INFO)]\t\t= GET_INFO_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_SERVICES)]\t= GET_SERVICES_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_SERVICE)]\t= GET_SERVICE_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_DESTS)]\t\t= GET_DESTS_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_TIMEOUT)]\t= GET_TIMEOUT_ARG_LEN,\n\t[GET_CMDID(IP_VS_SO_GET_DAEMON)]\t= GET_DAEMON_ARG_LEN,\n};\n\nstatic int\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n\n\nstatic struct nf_sockopt_ops ip_vs_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= IP_VS_BASE_CTL,\n\t.set_optmax\t= IP_VS_SO_SET_MAX+1,\n\t.set\t\t= do_ip_vs_set_ctl,\n\t.get_optmin\t= IP_VS_BASE_CTL,\n\t.get_optmax\t= IP_VS_SO_GET_MAX+1,\n\t.get\t\t= do_ip_vs_get_ctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n/*\n * Generic Netlink interface\n */\n\n/* IPVS genetlink family */\nstatic struct genl_family ip_vs_genl_family = {\n\t.id\t\t= GENL_ID_GENERATE,\n\t.hdrsize\t= 0,\n\t.name\t\t= IPVS_GENL_NAME,\n\t.version\t= IPVS_GENL_VERSION,\n\t.maxattr\t= IPVS_CMD_MAX,\n};\n\n/* Policy used for first-level command attributes */\nstatic const struct nla_policy ip_vs_cmd_policy[IPVS_CMD_ATTR_MAX + 1] = {\n\t[IPVS_CMD_ATTR_SERVICE]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DEST]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_DAEMON]\t\t= { .type = NLA_NESTED },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]\t= { .type = NLA_U32 },\n\t[IPVS_CMD_ATTR_TIMEOUT_UDP]\t= { .type = NLA_U32 },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_DAEMON */\nstatic const struct nla_policy ip_vs_daemon_policy[IPVS_DAEMON_ATTR_MAX + 1] = {\n\t[IPVS_DAEMON_ATTR_STATE]\t= { .type = NLA_U32 },\n\t[IPVS_DAEMON_ATTR_MCAST_IFN]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_IFNAME_MAXLEN },\n\t[IPVS_DAEMON_ATTR_SYNC_ID]\t= { .type = NLA_U32 },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_SERVICE */\nstatic const struct nla_policy ip_vs_svc_policy[IPVS_SVC_ATTR_MAX + 1] = {\n\t[IPVS_SVC_ATTR_AF]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_PROTOCOL]\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_SVC_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_SVC_ATTR_FWMARK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_SCHED_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len = IP_VS_SCHEDNAME_MAXLEN },\n\t[IPVS_SVC_ATTR_FLAGS]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(struct ip_vs_flags) },\n\t[IPVS_SVC_ATTR_TIMEOUT]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_NETMASK]\t\t= { .type = NLA_U32 },\n\t[IPVS_SVC_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n};\n\n/* Policy used for attributes in nested attribute IPVS_CMD_ATTR_DEST */\nstatic const struct nla_policy ip_vs_dest_policy[IPVS_DEST_ATTR_MAX + 1] = {\n\t[IPVS_DEST_ATTR_ADDR]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(union nf_inet_addr) },\n\t[IPVS_DEST_ATTR_PORT]\t\t= { .type = NLA_U16 },\n\t[IPVS_DEST_ATTR_FWD_METHOD]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_U_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_L_THRESH]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_ACTIVE_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_INACT_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_PERSIST_CONNS]\t= { .type = NLA_U32 },\n\t[IPVS_DEST_ATTR_STATS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int ip_vs_genl_fill_stats(struct sk_buff *skb, int container_type,\n\t\t\t\t struct ip_vs_stats *stats)\n{\n\tstruct nlattr *nl_stats = nla_nest_start(skb, container_type);\n\tif (!nl_stats)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_bh(&stats->lock);\n\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_CONNS, stats->ustats.conns);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INPKTS, stats->ustats.inpkts);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTPKTS, stats->ustats.outpkts);\n\tNLA_PUT_U64(skb, IPVS_STATS_ATTR_INBYTES, stats->ustats.inbytes);\n\tNLA_PUT_U64(skb, IPVS_STATS_ATTR_OUTBYTES, stats->ustats.outbytes);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_CPS, stats->ustats.cps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INPPS, stats->ustats.inpps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTPPS, stats->ustats.outpps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_INBPS, stats->ustats.inbps);\n\tNLA_PUT_U32(skb, IPVS_STATS_ATTR_OUTBPS, stats->ustats.outbps);\n\n\tspin_unlock_bh(&stats->lock);\n\n\tnla_nest_end(skb, nl_stats);\n\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&stats->lock);\n\tnla_nest_cancel(skb, nl_stats);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_fill_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc)\n{\n\tstruct nlattr *nl_service;\n\tstruct ip_vs_flags flags = { .flags = svc->flags,\n\t\t\t\t     .mask = ~0 };\n\n\tnl_service = nla_nest_start(skb, IPVS_CMD_ATTR_SERVICE);\n\tif (!nl_service)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_AF, svc->af);\n\n\tif (svc->fwmark) {\n\t\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_FWMARK, svc->fwmark);\n\t} else {\n\t\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_PROTOCOL, svc->protocol);\n\t\tNLA_PUT(skb, IPVS_SVC_ATTR_ADDR, sizeof(svc->addr), &svc->addr);\n\t\tNLA_PUT_U16(skb, IPVS_SVC_ATTR_PORT, svc->port);\n\t}\n\n\tNLA_PUT_STRING(skb, IPVS_SVC_ATTR_SCHED_NAME, svc->scheduler->name);\n\tNLA_PUT(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &flags);\n\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_TIMEOUT, svc->timeout / HZ);\n\tNLA_PUT_U32(skb, IPVS_SVC_ATTR_NETMASK, svc->netmask);\n\n\tif (ip_vs_genl_fill_stats(skb, IPVS_SVC_ATTR_STATS, &svc->stats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_service);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_service);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_service(struct sk_buff *skb,\n\t\t\t\t   struct ip_vs_service *svc,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_SERVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_service(skb, svc) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_services(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tint idx = 0, i;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\n\tmutex_lock(&__ip_vs_mutex);\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_table[i], s_list) {\n\t\t\tif (++idx <= start)\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < IP_VS_SVC_TAB_SIZE; i++) {\n\t\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[i], f_list) {\n\t\t\tif (++idx <= start)\n\t\t\t\tcontinue;\n\t\t\tif (ip_vs_genl_dump_service(skb, svc, cb) < 0) {\n\t\t\t\tidx--;\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&__ip_vs_mutex);\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_parse_service(struct ip_vs_service_user_kern *usvc,\n\t\t\t\t    struct nlattr *nla, int full_entry)\n{\n\tstruct nlattr *attrs[IPVS_SVC_ATTR_MAX + 1];\n\tstruct nlattr *nla_af, *nla_port, *nla_fwmark, *nla_protocol, *nla_addr;\n\n\t/* Parse mandatory identifying service fields first */\n\tif (nla == NULL ||\n\t    nla_parse_nested(attrs, IPVS_SVC_ATTR_MAX, nla, ip_vs_svc_policy))\n\t\treturn -EINVAL;\n\n\tnla_af\t\t= attrs[IPVS_SVC_ATTR_AF];\n\tnla_protocol\t= attrs[IPVS_SVC_ATTR_PROTOCOL];\n\tnla_addr\t= attrs[IPVS_SVC_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_SVC_ATTR_PORT];\n\tnla_fwmark\t= attrs[IPVS_SVC_ATTR_FWMARK];\n\n\tif (!(nla_af && (nla_fwmark || (nla_port && nla_protocol && nla_addr))))\n\t\treturn -EINVAL;\n\n\tmemset(usvc, 0, sizeof(*usvc));\n\n\tusvc->af = nla_get_u16(nla_af);\n#ifdef CONFIG_IP_VS_IPV6\n\tif (usvc->af != AF_INET && usvc->af != AF_INET6)\n#else\n\tif (usvc->af != AF_INET)\n#endif\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_fwmark) {\n\t\tusvc->protocol = IPPROTO_TCP;\n\t\tusvc->fwmark = nla_get_u32(nla_fwmark);\n\t} else {\n\t\tusvc->protocol = nla_get_u16(nla_protocol);\n\t\tnla_memcpy(&usvc->addr, nla_addr, sizeof(usvc->addr));\n\t\tusvc->port = nla_get_u16(nla_port);\n\t\tusvc->fwmark = 0;\n\t}\n\n\t/* If a full entry was requested, check for the additional fields */\n\tif (full_entry) {\n\t\tstruct nlattr *nla_sched, *nla_flags, *nla_timeout,\n\t\t\t      *nla_netmask;\n\t\tstruct ip_vs_flags flags;\n\t\tstruct ip_vs_service *svc;\n\n\t\tnla_sched = attrs[IPVS_SVC_ATTR_SCHED_NAME];\n\t\tnla_flags = attrs[IPVS_SVC_ATTR_FLAGS];\n\t\tnla_timeout = attrs[IPVS_SVC_ATTR_TIMEOUT];\n\t\tnla_netmask = attrs[IPVS_SVC_ATTR_NETMASK];\n\n\t\tif (!(nla_sched && nla_flags && nla_timeout && nla_netmask))\n\t\t\treturn -EINVAL;\n\n\t\tnla_memcpy(&flags, nla_flags, sizeof(flags));\n\n\t\t/* prefill flags from service if it already exists */\n\t\tif (usvc->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(usvc->af, usvc->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(usvc->af, usvc->protocol,\n\t\t\t\t\t\t  &usvc->addr, usvc->port);\n\t\tif (svc) {\n\t\t\tusvc->flags = svc->flags;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tusvc->flags = 0;\n\n\t\t/* set new flags from userland */\n\t\tusvc->flags = (usvc->flags & ~flags.mask) |\n\t\t\t      (flags.flags & flags.mask);\n\t\tusvc->sched_name = nla_data(nla_sched);\n\t\tusvc->timeout = nla_get_u32(nla_timeout);\n\t\tusvc->netmask = nla_get_u32(nla_netmask);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ip_vs_service *ip_vs_genl_find_service(struct nlattr *nla)\n{\n\tstruct ip_vs_service_user_kern usvc;\n\tint ret;\n\n\tret = ip_vs_genl_parse_service(&usvc, nla, 0);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (usvc.fwmark)\n\t\treturn __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\telse\n\t\treturn __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t   &usvc.addr, usvc.port);\n}\n\nstatic int ip_vs_genl_fill_dest(struct sk_buff *skb, struct ip_vs_dest *dest)\n{\n\tstruct nlattr *nl_dest;\n\n\tnl_dest = nla_nest_start(skb, IPVS_CMD_ATTR_DEST);\n\tif (!nl_dest)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT(skb, IPVS_DEST_ATTR_ADDR, sizeof(dest->addr), &dest->addr);\n\tNLA_PUT_U16(skb, IPVS_DEST_ATTR_PORT, dest->port);\n\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_FWD_METHOD,\n\t\t    atomic_read(&dest->conn_flags) & IP_VS_CONN_F_FWD_MASK);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_WEIGHT, atomic_read(&dest->weight));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_U_THRESH, dest->u_threshold);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_L_THRESH, dest->l_threshold);\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_ACTIVE_CONNS,\n\t\t    atomic_read(&dest->activeconns));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_INACT_CONNS,\n\t\t    atomic_read(&dest->inactconns));\n\tNLA_PUT_U32(skb, IPVS_DEST_ATTR_PERSIST_CONNS,\n\t\t    atomic_read(&dest->persistconns));\n\n\tif (ip_vs_genl_fill_stats(skb, IPVS_DEST_ATTR_STATS, &dest->stats))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nl_dest);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_dest);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dest(struct sk_buff *skb, struct ip_vs_dest *dest,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DEST);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_dest(skb, dest) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_dests(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tint start = cb->args[0];\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest *dest;\n\tstruct nlattr *attrs[IPVS_CMD_ATTR_MAX + 1];\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\t/* Try to find the service for which to dump destinations */\n\tif (nlmsg_parse(cb->nlh, GENL_HDRLEN, attrs,\n\t\t\tIPVS_CMD_ATTR_MAX, ip_vs_cmd_policy))\n\t\tgoto out_err;\n\n\tsvc = ip_vs_genl_find_service(attrs[IPVS_CMD_ATTR_SERVICE]);\n\tif (IS_ERR(svc) || svc == NULL)\n\t\tgoto out_err;\n\n\t/* Dump the destinations */\n\tlist_for_each_entry(dest, &svc->destinations, n_list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (ip_vs_genl_dump_dest(skb, dest, cb) < 0) {\n\t\t\tidx--;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\nnla_put_failure:\n\tcb->args[0] = idx;\n\tip_vs_service_put(svc);\n\nout_err:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_parse_dest(struct ip_vs_dest_user_kern *udest,\n\t\t\t\t struct nlattr *nla, int full_entry)\n{\n\tstruct nlattr *attrs[IPVS_DEST_ATTR_MAX + 1];\n\tstruct nlattr *nla_addr, *nla_port;\n\n\t/* Parse mandatory identifying destination fields first */\n\tif (nla == NULL ||\n\t    nla_parse_nested(attrs, IPVS_DEST_ATTR_MAX, nla, ip_vs_dest_policy))\n\t\treturn -EINVAL;\n\n\tnla_addr\t= attrs[IPVS_DEST_ATTR_ADDR];\n\tnla_port\t= attrs[IPVS_DEST_ATTR_PORT];\n\n\tif (!(nla_addr && nla_port))\n\t\treturn -EINVAL;\n\n\tmemset(udest, 0, sizeof(*udest));\n\n\tnla_memcpy(&udest->addr, nla_addr, sizeof(udest->addr));\n\tudest->port = nla_get_u16(nla_port);\n\n\t/* If a full entry was requested, check for the additional fields */\n\tif (full_entry) {\n\t\tstruct nlattr *nla_fwd, *nla_weight, *nla_u_thresh,\n\t\t\t      *nla_l_thresh;\n\n\t\tnla_fwd\t\t= attrs[IPVS_DEST_ATTR_FWD_METHOD];\n\t\tnla_weight\t= attrs[IPVS_DEST_ATTR_WEIGHT];\n\t\tnla_u_thresh\t= attrs[IPVS_DEST_ATTR_U_THRESH];\n\t\tnla_l_thresh\t= attrs[IPVS_DEST_ATTR_L_THRESH];\n\n\t\tif (!(nla_fwd && nla_weight && nla_u_thresh && nla_l_thresh))\n\t\t\treturn -EINVAL;\n\n\t\tudest->conn_flags = nla_get_u32(nla_fwd)\n\t\t\t\t    & IP_VS_CONN_F_FWD_MASK;\n\t\tudest->weight = nla_get_u32(nla_weight);\n\t\tudest->u_threshold = nla_get_u32(nla_u_thresh);\n\t\tudest->l_threshold = nla_get_u32(nla_l_thresh);\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_vs_genl_fill_daemon(struct sk_buff *skb, __be32 state,\n\t\t\t\t  const char *mcast_ifn, __be32 syncid)\n{\n\tstruct nlattr *nl_daemon;\n\n\tnl_daemon = nla_nest_start(skb, IPVS_CMD_ATTR_DAEMON);\n\tif (!nl_daemon)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_STATE, state);\n\tNLA_PUT_STRING(skb, IPVS_DAEMON_ATTR_MCAST_IFN, mcast_ifn);\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_SYNC_ID, syncid);\n\n\tnla_nest_end(skb, nl_daemon);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_daemon);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemon(struct sk_buff *skb, __be32 state,\n\t\t\t\t  const char *mcast_ifn, __be32 syncid,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tvoid *hdr;\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t\t\t  &ip_vs_genl_family, NLM_F_MULTI,\n\t\t\t  IPVS_CMD_NEW_DAEMON);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (ip_vs_genl_fill_daemon(skb, state, mcast_ifn, syncid))\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ip_vs_genl_dump_daemons(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tmutex_lock(&__ip_vs_mutex);\n\tif ((ip_vs_sync_state & IP_VS_STATE_MASTER) && !cb->args[0]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_MASTER,\n\t\t\t\t\t   ip_vs_master_mcast_ifn,\n\t\t\t\t\t   ip_vs_master_syncid, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[0] = 1;\n\t}\n\n\tif ((ip_vs_sync_state & IP_VS_STATE_BACKUP) && !cb->args[1]) {\n\t\tif (ip_vs_genl_dump_daemon(skb, IP_VS_STATE_BACKUP,\n\t\t\t\t\t   ip_vs_backup_mcast_ifn,\n\t\t\t\t\t   ip_vs_backup_syncid, cb) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tcb->args[1] = 1;\n\t}\n\nnla_put_failure:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn skb->len;\n}\n\nstatic int ip_vs_genl_new_daemon(struct nlattr **attrs)\n{\n\tif (!(attrs[IPVS_DAEMON_ATTR_STATE] &&\n\t      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&\n\t      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))\n\t\treturn -EINVAL;\n\n\treturn start_sync_thread(nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),\n\t\t\t\t nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),\n\t\t\t\t nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));\n}\n\nstatic int ip_vs_genl_del_daemon(struct nlattr **attrs)\n{\n\tif (!attrs[IPVS_DAEMON_ATTR_STATE])\n\t\treturn -EINVAL;\n\n\treturn stop_sync_thread(nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));\n}\n\nstatic int ip_vs_genl_set_config(struct nlattr **attrs)\n{\n\tstruct ip_vs_timeout_user t;\n\n\t__ip_vs_get_timeouts(&t);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP])\n\t\tt.tcp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN])\n\t\tt.tcp_fin_timeout =\n\t\t\tnla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]);\n\n\tif (attrs[IPVS_CMD_ATTR_TIMEOUT_UDP])\n\t\tt.udp_timeout = nla_get_u32(attrs[IPVS_CMD_ATTR_TIMEOUT_UDP]);\n\n\treturn ip_vs_set_timeout(&t);\n}\n\nstatic int ip_vs_genl_set_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ip_vs_service *svc = NULL;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_dest_user_kern udest;\n\tint ret = 0, cmd;\n\tint need_full_svc = 0, need_full_dest = 0;\n\n\tcmd = info->genlhdr->cmd;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\tif (cmd == IPVS_CMD_FLUSH) {\n\t\tret = ip_vs_flush();\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_SET_CONFIG) {\n\t\tret = ip_vs_genl_set_config(info->attrs);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_NEW_DAEMON ||\n\t\t   cmd == IPVS_CMD_DEL_DAEMON) {\n\n\t\tstruct nlattr *daemon_attrs[IPVS_DAEMON_ATTR_MAX + 1];\n\n\t\tif (!info->attrs[IPVS_CMD_ATTR_DAEMON] ||\n\t\t    nla_parse_nested(daemon_attrs, IPVS_DAEMON_ATTR_MAX,\n\t\t\t\t     info->attrs[IPVS_CMD_ATTR_DAEMON],\n\t\t\t\t     ip_vs_daemon_policy)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmd == IPVS_CMD_NEW_DAEMON)\n\t\t\tret = ip_vs_genl_new_daemon(daemon_attrs);\n\t\telse\n\t\t\tret = ip_vs_genl_del_daemon(daemon_attrs);\n\t\tgoto out;\n\t} else if (cmd == IPVS_CMD_ZERO &&\n\t\t   !info->attrs[IPVS_CMD_ATTR_SERVICE]) {\n\t\tret = ip_vs_zero_all();\n\t\tgoto out;\n\t}\n\n\t/* All following commands require a service argument, so check if we\n\t * received a valid one. We need a full service specification when\n\t * adding / editing a service. Only identifying members otherwise. */\n\tif (cmd == IPVS_CMD_NEW_SERVICE || cmd == IPVS_CMD_SET_SERVICE)\n\t\tneed_full_svc = 1;\n\n\tret = ip_vs_genl_parse_service(&usvc,\n\t\t\t\t       info->attrs[IPVS_CMD_ATTR_SERVICE],\n\t\t\t\t       need_full_svc);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\t/* Unless we're adding a new service, the service must already exist */\n\tif ((cmd != IPVS_CMD_NEW_SERVICE) && (svc == NULL)) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\t/* Destination commands require a valid destination argument. For\n\t * adding / editing a destination, we need a full destination\n\t * specification. */\n\tif (cmd == IPVS_CMD_NEW_DEST || cmd == IPVS_CMD_SET_DEST ||\n\t    cmd == IPVS_CMD_DEL_DEST) {\n\t\tif (cmd != IPVS_CMD_DEL_DEST)\n\t\t\tneed_full_dest = 1;\n\n\t\tret = ip_vs_genl_parse_dest(&udest,\n\t\t\t\t\t    info->attrs[IPVS_CMD_ATTR_DEST],\n\t\t\t\t\t    need_full_dest);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_NEW_SERVICE:\n\t\tif (svc == NULL)\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\telse\n\t\t\tret = -EEXIST;\n\t\tbreak;\n\tcase IPVS_CMD_SET_SERVICE:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_SERVICE:\n\t\tret = ip_vs_del_service(svc);\n\t\tbreak;\n\tcase IPVS_CMD_NEW_DEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_SET_DEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_DEL_DEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tcase IPVS_CMD_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\nstatic int ip_vs_genl_get_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *reply;\n\tint ret, cmd, reply_cmd;\n\n\tcmd = info->genlhdr->cmd;\n\n\tif (cmd == IPVS_CMD_GET_SERVICE)\n\t\treply_cmd = IPVS_CMD_NEW_SERVICE;\n\telse if (cmd == IPVS_CMD_GET_INFO)\n\t\treply_cmd = IPVS_CMD_SET_INFO;\n\telse if (cmd == IPVS_CMD_GET_CONFIG)\n\t\treply_cmd = IPVS_CMD_SET_CONFIG;\n\telse {\n\t\tpr_err(\"unknown Generic Netlink command\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&__ip_vs_mutex);\n\n\treply = genlmsg_put_reply(msg, info, &ip_vs_genl_family, 0, reply_cmd);\n\tif (reply == NULL)\n\t\tgoto nla_put_failure;\n\n\tswitch (cmd) {\n\tcase IPVS_CMD_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service *svc;\n\n\t\tsvc = ip_vs_genl_find_service(info->attrs[IPVS_CMD_ATTR_SERVICE]);\n\t\tif (IS_ERR(svc)) {\n\t\t\tret = PTR_ERR(svc);\n\t\t\tgoto out_err;\n\t\t} else if (svc) {\n\t\t\tret = ip_vs_genl_fill_service(msg, svc);\n\t\t\tip_vs_service_put(svc);\n\t\t\tif (ret)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tret = -ESRCH;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_CONFIG:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP, t.tcp_timeout);\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,\n\t\t\t    t.tcp_fin_timeout);\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\t\tNLA_PUT_U32(msg, IPVS_CMD_ATTR_TIMEOUT_UDP, t.udp_timeout);\n#endif\n\n\t\tbreak;\n\t}\n\n\tcase IPVS_CMD_GET_INFO:\n\t\tNLA_PUT_U32(msg, IPVS_INFO_ATTR_VERSION, IP_VS_VERSION_CODE);\n\t\tNLA_PUT_U32(msg, IPVS_INFO_ATTR_CONN_TAB_SIZE,\n\t\t\t    IP_VS_CONN_TAB_SIZE);\n\t\tbreak;\n\t}\n\n\tgenlmsg_end(msg, reply);\n\tret = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tpr_err(\"not enough space in Netlink message\\n\");\n\tret = -EMSGSIZE;\n\nout_err:\n\tnlmsg_free(msg);\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\n\treturn ret;\n}\n\n\nstatic struct genl_ops ip_vs_genl_ops[] __read_mostly = {\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_SERVICE,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t\t.dumpit\t= ip_vs_genl_dump_services,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DEST,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.dumpit\t= ip_vs_genl_dump_dests,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_NEW_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_DEL_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_DAEMON,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.dumpit\t= ip_vs_genl_dump_daemons,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_SET_CONFIG,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_CONFIG,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_GET_INFO,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_get_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_ZERO,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ip_vs_cmd_policy,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n\t{\n\t\t.cmd\t= IPVS_CMD_FLUSH,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.doit\t= ip_vs_genl_set_cmd,\n\t},\n};\n\nstatic int __init ip_vs_genl_register(void)\n{\n\treturn genl_register_family_with_ops(&ip_vs_genl_family,\n\t\tip_vs_genl_ops, ARRAY_SIZE(ip_vs_genl_ops));\n}\n\nstatic void ip_vs_genl_unregister(void)\n{\n\tgenl_unregister_family(&ip_vs_genl_family);\n}\n\n/* End of Generic Netlink interface definitions */\n\n\nint __init ip_vs_control_init(void)\n{\n\tint ret;\n\tint idx;\n\n\tEnterFunction(2);\n\n\tret = nf_register_sockopt(&ip_vs_sockopts);\n\tif (ret) {\n\t\tpr_err(\"cannot register sockopt.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ip_vs_genl_register();\n\tif (ret) {\n\t\tpr_err(\"cannot register Generic Netlink interface.\\n\");\n\t\tnf_unregister_sockopt(&ip_vs_sockopts);\n\t\treturn ret;\n\t}\n\n\tproc_net_fops_create(&init_net, \"ip_vs\", 0, &ip_vs_info_fops);\n\tproc_net_fops_create(&init_net, \"ip_vs_stats\",0, &ip_vs_stats_fops);\n\n\tsysctl_header = register_sysctl_paths(net_vs_ctl_path, vs_vars);\n\n\t/* Initialize ip_vs_svc_table, ip_vs_svc_fwm_table, ip_vs_rtable */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_svc_table[idx]);\n\t\tINIT_LIST_HEAD(&ip_vs_svc_fwm_table[idx]);\n\t}\n\tfor(idx = 0; idx < IP_VS_RTAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_rtable[idx]);\n\t}\n\n\tip_vs_new_estimator(&ip_vs_stats);\n\n\t/* Hook the defense timer */\n\tschedule_delayed_work(&defense_work, DEFENSE_TIMER_PERIOD);\n\n\tLeaveFunction(2);\n\treturn 0;\n}\n\n\nvoid ip_vs_control_cleanup(void)\n{\n\tEnterFunction(2);\n\tip_vs_trash_cleanup();\n\tcancel_rearming_delayed_work(&defense_work);\n\tcancel_work_sync(&defense_work.work);\n\tip_vs_kill_estimator(&ip_vs_stats);\n\tunregister_sysctl_table(sysctl_header);\n\tproc_net_remove(&init_net, \"ip_vs_stats\");\n\tproc_net_remove(&init_net, \"ip_vs\");\n\tip_vs_genl_unregister();\n\tnf_unregister_sockopt(&ip_vs_sockopts);\n\tLeaveFunction(2);\n}\n"], "filenames": ["net/netfilter/ipvs/ip_vs_ctl.c"], "buggy_code_start_loc": [2079], "buggy_code_end_loc": [2366], "fixing_code_start_loc": [2080], "fixing_code_end_loc": [2378], "type": "CWE-119", "message": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "other": {"cve": {"id": "CVE-2013-4588", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-20T13:19:42.040", "lastModified": "2023-02-13T04:48:07.037", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function."}, {"lang": "es", "value": "M\u00faltiples desbordamientos basados en pila en net/netfilter/ipvs/ip_vs_ctl.c en el kernel de Linux anterior a la versi\u00f3n 2.6.33, cuando es usado CONFIG_IP_VS, permite a usuarios locales obtener privilegios mediante el aprovechamiento de capacidades CAP_NET_ADMIN para (1) una llamada de sistema getsockopt, relacionada con la funci\u00f3n do_ip_vs_get_ctl, o (2) una llamada de sistema a setsockopt, relacionada con la funci\u00f3n do_ip_vs_set_ctl."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.33", "matchCriteriaId": "A01490AB-675E-4BA1-916D-F2A0D6CB27FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=04bcef2a83f40c6db24222b27a52892cba39dffb", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/15/12", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/63744", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2064-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2065-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1030800", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb"}}