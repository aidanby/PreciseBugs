{"buggy_code": ["# -*- coding: utf-8 -*-\n'''\nExecute chef in server or solo mode\n'''\n\n# Import Python libs\nimport logging\nimport os\nimport tempfile\n\n# Import Salt libs\nimport salt.utils\nimport salt.utils.decorators as decorators\n\nlog = logging.getLogger(__name__)\n\n\ndef __virtual__():\n    '''\n    Only load if chef is installed\n    '''\n    if not salt.utils.which('chef-client'):\n        return False\n    return True\n\n\ndef _default_logfile(exe_name):\n    '''\n    Retrieve the logfile name\n    '''\n    if salt.utils.is_windows():\n        logfile_tmp = tempfile.NamedTemporaryFile(dir=os.environ['TMP'],\n                                                  prefix=exe_name,\n                                                  suffix='.log',\n                                                  delete=False)\n        logfile = logfile_tmp.name\n        logfile_tmp.close()\n    else:\n        logfile = salt.utils.path_join(\n            '/var/log',\n            '{0}.log'.format(exe_name)\n        )\n\n    return logfile\n\n\n@decorators.which('chef-client')\ndef client(whyrun=False,\n           localmode=False,\n           logfile=_default_logfile('chef-client'),\n           **kwargs):\n    '''\n    Execute a chef client run and return a dict with the stderr, stdout,\n    return code, and pid.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' chef.client server=https://localhost\n\n    server\n        The chef server URL\n\n    client_key\n        Set the client key file location\n\n    config\n        The configuration file to use\n\n    config-file-jail\n        Directory under which config files are allowed to be loaded\n        (no client.rb or knife.rb outside this path will be loaded).\n\n    environment\n        Set the Chef Environment on the node\n\n    group\n        Group to set privilege to\n\n    json-attributes\n        Load attributes from a JSON file or URL\n\n    localmode\n        Point chef-client at local repository if True\n\n    log_level\n        Set the log level (debug, info, warn, error, fatal)\n\n    logfile\n        Set the log file location\n\n    node-name\n        The node name for this client\n\n    override-runlist\n        Replace current run list with specified items for a single run\n\n    pid\n        Set the PID file location, defaults to /tmp/chef-client.pid\n\n    run-lock-timeout\n        Set maximum duration to wait for another client run to finish,\n        default is indefinitely.\n\n    runlist\n        Permanently replace current run list with specified items\n\n    user\n        User to set privilege to\n\n    validation_key\n        Set the validation key file location, used for registering new clients\n\n    whyrun\n        Enable whyrun mode when set to True\n\n    '''\n    args = ['chef-client',\n            '--no-color',\n            '--once',\n            '--logfile \"{0}\"'.format(logfile),\n            '--format doc']\n\n    if whyrun:\n        args.append('--why-run')\n\n    if localmode:\n        args.append('--local-mode')\n\n    return _exec_cmd(*args, **kwargs)\n\n\n@decorators.which('chef-solo')\ndef solo(whyrun=False,\n         logfile=_default_logfile('chef-solo'),\n         **kwargs):\n    '''\n    Execute a chef solo run and return a dict with the stderr, stdout,\n    return code, and pid.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' chef.solo override-runlist=test\n\n    config\n        The configuration file to use\n\n    environment\n        Set the Chef Environment on the node\n\n    group\n        Group to set privilege to\n\n    json-attributes\n        Load attributes from a JSON file or URL\n\n    log_level\n        Set the log level (debug, info, warn, error, fatal)\n\n    logfile\n        Set the log file location\n\n    node-name\n        The node name for this client\n\n    override-runlist\n        Replace current run list with specified items for a single run\n\n    recipe-url\n        Pull down a remote gzipped tarball of recipes and untar it to\n        the cookbook cache\n\n    run-lock-timeout\n        Set maximum duration to wait for another client run to finish,\n        default is indefinitely.\n\n    user\n        User to set privilege to\n\n    whyrun\n        Enable whyrun mode when set to True\n    '''\n    args = ['chef-solo',\n            '--no-color',\n            '--logfile \"{0}\"'.format(logfile),\n            '--format doc']\n\n    args = ['chef-solo', '--no-color', '--logfile {0}'.format(logfile)]\n\n    if whyrun:\n        args.append('--why-run')\n\n    return _exec_cmd(*args, **kwargs)\n\n\ndef _exec_cmd(*args, **kwargs):\n\n    # Compile the command arguments\n    cmd_args = ' '.join(args)\n    cmd_kwargs = ''.join([\n         ' --{0} {1}'.format(k, v)\n         for k, v in kwargs.items() if not k.startswith('__')]\n    )\n    cmd_exec = '{0}{1}'.format(cmd_args, cmd_kwargs)\n    log.debug('Chef command: {0}'.format(cmd_exec))\n\n    return __salt__['cmd.run_all'](cmd_exec, python_shell=False)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n'''\nExecute chef in server or solo mode\n'''\n\n# Import Python libs\nimport logging\nimport os\nimport tempfile\n\n# Import Salt libs\nimport salt.utils\nimport salt.utils.decorators as decorators\n\nlog = logging.getLogger(__name__)\n\n\ndef __virtual__():\n    '''\n    Only load if chef is installed\n    '''\n    if not salt.utils.which('chef-client'):\n        return False\n    return True\n\n\ndef _default_logfile(exe_name):\n    '''\n    Retrieve the logfile name\n    '''\n    if salt.utils.is_windows():\n        tmp_dir = os.path.join(__opts__['cachedir'], 'tmp')\n        if not os.path.isdir(tmp_dir):\n            os.mkdir(tmp_dir)\n        logfile_tmp = tempfile.NamedTemporaryFile(dir=tmp_dir,\n                                                  prefix=exe_name,\n                                                  suffix='.log',\n                                                  delete=False)\n        logfile = logfile_tmp.name\n        logfile_tmp.close()\n    else:\n        logfile = salt.utils.path_join(\n            '/var/log',\n            '{0}.log'.format(exe_name)\n        )\n\n    return logfile\n\n\n@decorators.which('chef-client')\ndef client(whyrun=False,\n           localmode=False,\n           logfile=_default_logfile('chef-client'),\n           **kwargs):\n    '''\n    Execute a chef client run and return a dict with the stderr, stdout,\n    return code, and pid.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' chef.client server=https://localhost\n\n    server\n        The chef server URL\n\n    client_key\n        Set the client key file location\n\n    config\n        The configuration file to use\n\n    config-file-jail\n        Directory under which config files are allowed to be loaded\n        (no client.rb or knife.rb outside this path will be loaded).\n\n    environment\n        Set the Chef Environment on the node\n\n    group\n        Group to set privilege to\n\n    json-attributes\n        Load attributes from a JSON file or URL\n\n    localmode\n        Point chef-client at local repository if True\n\n    log_level\n        Set the log level (debug, info, warn, error, fatal)\n\n    logfile\n        Set the log file location\n\n    node-name\n        The node name for this client\n\n    override-runlist\n        Replace current run list with specified items for a single run\n\n    pid\n        Set the PID file location, defaults to /tmp/chef-client.pid\n\n    run-lock-timeout\n        Set maximum duration to wait for another client run to finish,\n        default is indefinitely.\n\n    runlist\n        Permanently replace current run list with specified items\n\n    user\n        User to set privilege to\n\n    validation_key\n        Set the validation key file location, used for registering new clients\n\n    whyrun\n        Enable whyrun mode when set to True\n\n    '''\n    args = ['chef-client',\n            '--no-color',\n            '--once',\n            '--logfile \"{0}\"'.format(logfile),\n            '--format doc']\n\n    if whyrun:\n        args.append('--why-run')\n\n    if localmode:\n        args.append('--local-mode')\n\n    return _exec_cmd(*args, **kwargs)\n\n\n@decorators.which('chef-solo')\ndef solo(whyrun=False,\n         logfile=_default_logfile('chef-solo'),\n         **kwargs):\n    '''\n    Execute a chef solo run and return a dict with the stderr, stdout,\n    return code, and pid.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' chef.solo override-runlist=test\n\n    config\n        The configuration file to use\n\n    environment\n        Set the Chef Environment on the node\n\n    group\n        Group to set privilege to\n\n    json-attributes\n        Load attributes from a JSON file or URL\n\n    log_level\n        Set the log level (debug, info, warn, error, fatal)\n\n    logfile\n        Set the log file location\n\n    node-name\n        The node name for this client\n\n    override-runlist\n        Replace current run list with specified items for a single run\n\n    recipe-url\n        Pull down a remote gzipped tarball of recipes and untar it to\n        the cookbook cache\n\n    run-lock-timeout\n        Set maximum duration to wait for another client run to finish,\n        default is indefinitely.\n\n    user\n        User to set privilege to\n\n    whyrun\n        Enable whyrun mode when set to True\n    '''\n    args = ['chef-solo',\n            '--no-color',\n            '--logfile \"{0}\"'.format(logfile),\n            '--format doc']\n\n    args = ['chef-solo', '--no-color', '--logfile {0}'.format(logfile)]\n\n    if whyrun:\n        args.append('--why-run')\n\n    return _exec_cmd(*args, **kwargs)\n\n\ndef _exec_cmd(*args, **kwargs):\n\n    # Compile the command arguments\n    cmd_args = ' '.join(args)\n    cmd_kwargs = ''.join([\n         ' --{0} {1}'.format(k, v)\n         for k, v in kwargs.items() if not k.startswith('__')]\n    )\n    cmd_exec = '{0}{1}'.format(cmd_args, cmd_kwargs)\n    log.debug('Chef command: {0}'.format(cmd_exec))\n\n    return __salt__['cmd.run_all'](cmd_exec, python_shell=False)\n"], "filenames": ["salt/modules/chef.py"], "buggy_code_start_loc": [32], "buggy_code_end_loc": [33], "fixing_code_start_loc": [32], "fixing_code_end_loc": [36], "type": "CWE-19", "message": "modules/chef.py in SaltStack before 2014.7.4 does not properly handle files in /tmp.", "other": {"cve": {"id": "CVE-2015-1839", "sourceIdentifier": "secalert@redhat.com", "published": "2017-04-13T14:59:00.760", "lastModified": "2017-04-19T19:36:03.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "modules/chef.py in SaltStack before 2014.7.4 does not properly handle files in /tmp."}, {"lang": "es", "value": "modules/chef.py en SaltStack en versiones anteriores a 2014.7.4 no maneja correctamente archivos en /tmp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:saltstack:salt:*:*:*:*:*:*:*:*", "versionEndIncluding": "2014.7.3", "matchCriteriaId": "AABB487A-AC69-46DA-97AC-7467DC67A05D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-January/175568.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1212788", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://docs.saltstack.com/en/latest/topics/releases/2014.7.4.html", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/saltstack/salt/commit/22d2f7a1ec93300c34e8c42d14ec39d51e610b5c", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/saltstack/salt/commit/b49d0d4b5ca5c6f31f03e2caf97cef1088eeed81", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saltstack/salt/commit/22d2f7a1ec93300c34e8c42d14ec39d51e610b5c"}}