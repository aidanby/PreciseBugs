{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/fastcgi/fastcgi-transport.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/server/fastcgi/fastcgi-server.h\"\n#include \"hphp/runtime/server/http-protocol.h\"\n#include \"hphp/runtime/server/transport.h\"\n\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/io/IOBufQueue.h>\n\nnamespace HPHP {\n\nusing folly::IOBuf;\nusing folly::IOBufQueue;\nusing folly::io::Cursor;\n\n///////////////////////////////////////////////////////////////////////////////\n\n/*\n * The logic used here for reading POST data buffers is mostly borrowed from\n * proxygen server. Currently the RequestBodyReadLimit is not supported by\n * FastCGI so we don't ever pause ingress and POST data is always received\n * during VM execution.\n *\n * NB: locking is important when accessing m_bodyQueue as the session will\n *     also write into that structure via onBody.\n */\nconst void *FastCGITransport::getPostData(size_t& size) {\n  // the API contract is that you can call getPostData repeatedly until\n  // you call getMorePostData\n  if (m_firstBody) {\n    CHECK(m_currBody);\n    size = m_currBody->length();\n    return m_currBody->data();\n  }\n  return getMorePostData(size);\n}\n\nconst void *FastCGITransport::getMorePostData(size_t& size) {\n  // session will terminate the request if we don't receive data in\n  // this much time\n  long maxWait = RuntimeOption::ConnectionTimeoutSeconds;\n  if (maxWait <= 0) {\n    maxWait = 50; // this was the default read timeout in LibEventServer\n  }\n\n  Lock lock(this);\n  while (m_bodyQueue.empty() && !m_bodyComplete) {\n    wait(maxWait);\n  }\n\n  // For chunk encodings, we way receive an EOM with no data, such that\n  // hasMorePostData returns true (because client is not yet complete),\n  // client sends EOM, getMorePostData should return 0/nullptr\n  size = 0;\n  if (!m_bodyQueue.empty()) {\n    // this is the first body if it wasn't set and buf is unset\n    m_firstBody = !(m_firstBody && m_currBody);\n    m_currBody = m_bodyQueue.pop_front();\n\n    CHECK(m_currBody && m_currBody->length() > 0);\n    size = m_currBody->length();\n    return m_currBody->data();\n  }\n\n  return nullptr;\n}\n\nbool FastCGITransport::hasMorePostData() {\n  Lock lock(this);\n  return !m_bodyComplete || !m_bodyQueue.empty();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// takes an unmangled header name\nstd::string FastCGITransport::getHeader(const char* name) {\n  std::string key(\"HTTP_\");\n  for (auto p = name; *p; ++p) {\n    key += (*p == '-') ? '_' : toupper(*p);\n  }\n\n  if (m_requestParams.count(key)) {\n    return m_requestParams[key];\n  }\n\n  // Special headers that are not prefixed with HTTP_\n  if (strcasecmp(name, \"Authorization\") == 0) {\n    return getParamTyped<std::string>(\"Authorization\");\n  }\n\n  if (strcasecmp(name, \"Content-Length\") == 0) {\n    return getParamTyped<std::string>(\"CONTENT_LENGTH\");\n  }\n\n  if (strcasecmp(name, \"Content-Type\") == 0) {\n    return getParamTyped<std::string>(\"CONTENT_TYPE\");\n  }\n\n  return \"\";\n}\n\nvoid FastCGITransport::getHeaders(HeaderMap& headers) {\n  for (auto& pair : m_requestParams) {\n    auto key = unmangleHeader(pair.first);\n    if (!key.empty()) {\n      headers[key] = { pair.second };\n    }\n  }\n}\n\nvoid FastCGITransport::getTransportParams(HeaderMap& serverParams) {\n  for (auto& pair : m_requestParams) {\n    serverParams[pair.first] = { pair.second };\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::addHeaderImpl(const char* name, const char* value) {\n  CHECK(!m_headersSent);\n\n  m_responseHeaders[name].emplace_back(value);\n}\n\nvoid FastCGITransport::removeHeaderImpl(const char* name) {\n  CHECK(!m_headersSent);\n\n  m_responseHeaders.erase(name);\n}\n\nvoid FastCGITransport::sendResponseHeaders(IOBufQueue& queue, int code) {\n  auto appender = [&](folly::StringPiece sp) mutable { queue.append(sp); };\n  if (code != 200) {\n    auto info = getResponseInfo();\n    auto reason = !info.empty() ? info : HttpProtocol::GetReasonString(code);\n\n    folly::format(\"Status: {} {}\\r\\n\", code, reason)(appender);\n  }\n\n  for (auto& header : m_responseHeaders) {\n    for (auto& value : header.second) {\n      folly::format(\"{}: {}\\r\\n\", header.first, value)(appender);\n    }\n  }\n\n  queue.append(\"\\r\\n\", 2);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::sendImpl(const void *data, int size, int code,\n                                bool chunked, bool eom) {\n  if (!m_headersSent) {\n    m_headersSent = true;\n    sendResponseHeaders(m_txBuf, code);\n  }\n\n  m_txBuf.append(data, size);\n  m_session->onStdOut(m_txBuf.move()); // session will handle locking\n\n  if (eom) {\n    onSendEndImpl();\n  }\n}\n\nvoid FastCGITransport::onSendEndImpl() {\n  // Don't send onComplete() more than once (required because of the eom flag\n  // on sendImpl).\n  if (m_sendEnded) {\n    return;\n  }\n\n  m_sendEnded = true;\n  // NB: onSendEnd() is only sent when the VM is finished with the transport.\n  //     at this point we are free to do whatever we'd like with the transport.\n  m_session->onComplete();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::onBody(std::unique_ptr<folly::IOBuf> chain) {\n  Lock lock(this);\n  m_bodyQueue.append(std::move(chain));\n  notify(); // wake-up the VM\n}\n\nvoid FastCGITransport::onBodyComplete() {\n  Lock lock(this);\n  m_bodyComplete = true;\n  notify(); // wake-up the VM\n}\n\nvoid FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n\n  m_requestParams[key] = value;\n}\n\nvoid FastCGITransport::onHeadersComplete() {\n  m_scriptName   = getParamTyped<std::string>(\"SCRIPT_FILENAME\");\n  m_docRoot      = getParamTyped<std::string>(\"DOCUMENT_ROOT\");\n  m_pathTrans    = getParamTyped<std::string>(\"PATH_TRANSLATED\");\n  m_serverObject = getParamTyped<std::string>(\"SCRIPT_NAME\");\n\n  if (!m_docRoot.empty() && *m_docRoot.rbegin() != '/') {\n    m_docRoot += '/';\n  }\n\n  if (m_scriptName.empty() || RuntimeOption::ServerFixPathInfo) {\n    // According to php-fpm, some servers don't set SCRIPT_FILENAME. In\n    // this case, it uses PATH_TRANSLATED.\n    // Added runtime option to change m_scriptFilename to s_pathTran\n    // which will allow mod_fastcgi and mod_action to work correctly.\n    m_scriptName = getPathTranslated();\n  }\n\n  [&] { // do a check for mod_proxy_fcgi and remove the extra portions of\n        // the string\n    if (!strncmp(m_scriptName.c_str(), \"proxy:\", sizeof(\"proxy:\") - 1)) {\n      folly::StringPiece newName {m_scriptName};\n\n      // remove the proxy:type + :// from the start.\n      auto proxyPos = newName.find(\"://\");\n      if (proxyPos == std::string::npos) return; // invalid mod_proxy\n\n      newName.advance(proxyPos + sizeof(\"://\"));\n\n      // remove everything before the first / which is host:port\n      auto slashPos = newName.find('/');\n      if (slashPos == std::string::npos) {\n        m_scriptName.clear(); // empty path\n        return;\n      }\n      newName.advance(slashPos);\n\n      // remove everything after the first ?\n      auto questionPos = newName.find('?');\n      if (questionPos != std::string::npos) {\n        newName.subtract(newName.size() - questionPos);\n      }\n\n      m_scriptName = newName.str();\n    }\n  }();\n\n  // RequestURI needs script_filename and path_translated to not include\n  // the document root\n  if (!m_scriptName.empty()) {\n    if (m_scriptName.find(m_docRoot) == 0) {\n      m_scriptName.erase(0, m_docRoot.length());\n    } else {\n      // if the document root isn't in the url set document root to /\n      m_docRoot = \"/\";\n    }\n  }\n\n  // XXX: This was originally done before remapping scriptName but that seemed\n  // wrong as the value of docRoot may change. I haven't been able to confirm\n  // that this is correct either.\n  if (m_pathTrans.find(m_docRoot) == 0) {\n    m_pathTrans.erase(0, m_docRoot.length());\n  }\n\n  auto qs = getParamTyped<std::string>(\"QUERY_STRING\");\n  if (!qs.empty()) {\n    m_serverObject += \"?\";\n    m_serverObject += qs;\n  }\n\n  // Treat everything apart from GET and HEAD as a post to be like php-src.\n  auto const ex = getExtendedMethod();\n  if (!strcmp(ex, \"GET\")) {\n    m_method = Method::GET;\n  } else if (!strcmp(ex, \"HEAD\")) {\n    m_method = Method::HEAD;\n  } else {\n    m_method = Method::POST;\n  }\n\n  // IIS sets this value but sets it to off when SSL is off.\n  if (m_requestParams.count(\"HTTPS\") && !m_requestParams[\"HTTPS\"].empty() &&\n      strcasecmp(m_requestParams[\"HTTPS\"].c_str(), \"OFF\")) {\n    setSSL();\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstd::string FastCGITransport::unmangleHeader(const std::string& name) const {\n  if (name == \"Authorization\") {\n    return name; // Already unmangled\n  }\n\n  if (name == \"CONTENT_LENGTH\") {\n    return \"Content-Length\";\n  }\n\n  if (name == \"CONTENT_TYPE\") {\n    return \"Content-Type\";\n  }\n\n  if (strncasecmp(name.c_str(), \"HTTP_\", 5)) {\n    return \"\";\n  }\n\n  std::string ret;\n  bool is_upper = true;\n  for (auto const& c : folly::StringPiece(name, 5)) {\n    if (c == '_') {\n      ret += '-';\n      is_upper = true;\n    } else {\n      ret += is_upper ? toupper(c) : tolower(c);\n      is_upper = false;\n    }\n  }\n  return ret;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/fastcgi/fastcgi-transport.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/server/fastcgi/fastcgi-server.h\"\n#include \"hphp/runtime/server/http-protocol.h\"\n#include \"hphp/runtime/server/transport.h\"\n\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/io/IOBufQueue.h>\n\nnamespace HPHP {\n\nusing folly::IOBuf;\nusing folly::IOBufQueue;\nusing folly::io::Cursor;\n\n///////////////////////////////////////////////////////////////////////////////\n\n/*\n * The logic used here for reading POST data buffers is mostly borrowed from\n * proxygen server. Currently the RequestBodyReadLimit is not supported by\n * FastCGI so we don't ever pause ingress and POST data is always received\n * during VM execution.\n *\n * NB: locking is important when accessing m_bodyQueue as the session will\n *     also write into that structure via onBody.\n */\nconst void *FastCGITransport::getPostData(size_t& size) {\n  // the API contract is that you can call getPostData repeatedly until\n  // you call getMorePostData\n  if (m_firstBody) {\n    CHECK(m_currBody);\n    size = m_currBody->length();\n    return m_currBody->data();\n  }\n  return getMorePostData(size);\n}\n\nconst void *FastCGITransport::getMorePostData(size_t& size) {\n  // session will terminate the request if we don't receive data in\n  // this much time\n  long maxWait = RuntimeOption::ConnectionTimeoutSeconds;\n  if (maxWait <= 0) {\n    maxWait = 50; // this was the default read timeout in LibEventServer\n  }\n\n  Lock lock(this);\n  while (m_bodyQueue.empty() && !m_bodyComplete) {\n    wait(maxWait);\n  }\n\n  // For chunk encodings, we way receive an EOM with no data, such that\n  // hasMorePostData returns true (because client is not yet complete),\n  // client sends EOM, getMorePostData should return 0/nullptr\n  size = 0;\n  if (!m_bodyQueue.empty()) {\n    // this is the first body if it wasn't set and buf is unset\n    m_firstBody = !(m_firstBody && m_currBody);\n    m_currBody = m_bodyQueue.pop_front();\n\n    CHECK(m_currBody && m_currBody->length() > 0);\n    size = m_currBody->length();\n    return m_currBody->data();\n  }\n\n  return nullptr;\n}\n\nbool FastCGITransport::hasMorePostData() {\n  Lock lock(this);\n  return !m_bodyComplete || !m_bodyQueue.empty();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// takes an unmangled header name\nstd::string FastCGITransport::getHeader(const char* name) {\n  std::string key(\"HTTP_\");\n  for (auto p = name; *p; ++p) {\n    key += (*p == '-') ? '_' : toupper(*p);\n  }\n\n  if (m_requestParams.count(key)) {\n    return m_requestParams[key];\n  }\n\n  // Special headers that are not prefixed with HTTP_\n  if (strcasecmp(name, \"Authorization\") == 0) {\n    return getParamTyped<std::string>(\"Authorization\");\n  }\n\n  if (strcasecmp(name, \"Content-Length\") == 0) {\n    return getParamTyped<std::string>(\"CONTENT_LENGTH\");\n  }\n\n  if (strcasecmp(name, \"Content-Type\") == 0) {\n    return getParamTyped<std::string>(\"CONTENT_TYPE\");\n  }\n\n  return \"\";\n}\n\nvoid FastCGITransport::getHeaders(HeaderMap& headers) {\n  for (auto& pair : m_requestParams) {\n    auto key = unmangleHeader(pair.first);\n    if (!key.empty()) {\n      headers[key] = { pair.second };\n    }\n  }\n}\n\nvoid FastCGITransport::getTransportParams(HeaderMap& serverParams) {\n  for (auto& pair : m_requestParams) {\n    serverParams[pair.first] = { pair.second };\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::addHeaderImpl(const char* name, const char* value) {\n  CHECK(!m_headersSent);\n\n  m_responseHeaders[name].emplace_back(value);\n}\n\nvoid FastCGITransport::removeHeaderImpl(const char* name) {\n  CHECK(!m_headersSent);\n\n  m_responseHeaders.erase(name);\n}\n\nvoid FastCGITransport::sendResponseHeaders(IOBufQueue& queue, int code) {\n  auto appender = [&](folly::StringPiece sp) mutable { queue.append(sp); };\n  if (code != 200) {\n    auto info = getResponseInfo();\n    auto reason = !info.empty() ? info : HttpProtocol::GetReasonString(code);\n\n    folly::format(\"Status: {} {}\\r\\n\", code, reason)(appender);\n  }\n\n  for (auto& header : m_responseHeaders) {\n    for (auto& value : header.second) {\n      folly::format(\"{}: {}\\r\\n\", header.first, value)(appender);\n    }\n  }\n\n  queue.append(\"\\r\\n\", 2);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::sendImpl(const void *data, int size, int code,\n                                bool chunked, bool eom) {\n  if (!m_headersSent) {\n    m_headersSent = true;\n    sendResponseHeaders(m_txBuf, code);\n  }\n\n  m_txBuf.append(data, size);\n  m_session->onStdOut(m_txBuf.move()); // session will handle locking\n\n  if (eom) {\n    onSendEndImpl();\n  }\n}\n\nvoid FastCGITransport::onSendEndImpl() {\n  // Don't send onComplete() more than once (required because of the eom flag\n  // on sendImpl).\n  if (m_sendEnded) {\n    return;\n  }\n\n  m_sendEnded = true;\n  // NB: onSendEnd() is only sent when the VM is finished with the transport.\n  //     at this point we are free to do whatever we'd like with the transport.\n  m_session->onComplete();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid FastCGITransport::onBody(std::unique_ptr<folly::IOBuf> chain) {\n  Lock lock(this);\n  m_bodyQueue.append(std::move(chain));\n  notify(); // wake-up the VM\n}\n\nvoid FastCGITransport::onBodyComplete() {\n  Lock lock(this);\n  m_bodyComplete = true;\n  notify(); // wake-up the VM\n}\n\nvoid FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n\n  // Don't allow requests to inject an HTTP_PROXY environment variable by\n  // sending a Proxy header.\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n\n  m_requestParams[key] = value;\n}\n\nvoid FastCGITransport::onHeadersComplete() {\n  m_scriptName   = getParamTyped<std::string>(\"SCRIPT_FILENAME\");\n  m_docRoot      = getParamTyped<std::string>(\"DOCUMENT_ROOT\");\n  m_pathTrans    = getParamTyped<std::string>(\"PATH_TRANSLATED\");\n  m_serverObject = getParamTyped<std::string>(\"SCRIPT_NAME\");\n\n  if (!m_docRoot.empty() && *m_docRoot.rbegin() != '/') {\n    m_docRoot += '/';\n  }\n\n  if (m_scriptName.empty() || RuntimeOption::ServerFixPathInfo) {\n    // According to php-fpm, some servers don't set SCRIPT_FILENAME. In\n    // this case, it uses PATH_TRANSLATED.\n    // Added runtime option to change m_scriptFilename to s_pathTran\n    // which will allow mod_fastcgi and mod_action to work correctly.\n    m_scriptName = getPathTranslated();\n  }\n\n  [&] { // do a check for mod_proxy_fcgi and remove the extra portions of\n        // the string\n    if (!strncmp(m_scriptName.c_str(), \"proxy:\", sizeof(\"proxy:\") - 1)) {\n      folly::StringPiece newName {m_scriptName};\n\n      // remove the proxy:type + :// from the start.\n      auto proxyPos = newName.find(\"://\");\n      if (proxyPos == std::string::npos) return; // invalid mod_proxy\n\n      newName.advance(proxyPos + sizeof(\"://\"));\n\n      // remove everything before the first / which is host:port\n      auto slashPos = newName.find('/');\n      if (slashPos == std::string::npos) {\n        m_scriptName.clear(); // empty path\n        return;\n      }\n      newName.advance(slashPos);\n\n      // remove everything after the first ?\n      auto questionPos = newName.find('?');\n      if (questionPos != std::string::npos) {\n        newName.subtract(newName.size() - questionPos);\n      }\n\n      m_scriptName = newName.str();\n    }\n  }();\n\n  // RequestURI needs script_filename and path_translated to not include\n  // the document root\n  if (!m_scriptName.empty()) {\n    if (m_scriptName.find(m_docRoot) == 0) {\n      m_scriptName.erase(0, m_docRoot.length());\n    } else {\n      // if the document root isn't in the url set document root to /\n      m_docRoot = \"/\";\n    }\n  }\n\n  // XXX: This was originally done before remapping scriptName but that seemed\n  // wrong as the value of docRoot may change. I haven't been able to confirm\n  // that this is correct either.\n  if (m_pathTrans.find(m_docRoot) == 0) {\n    m_pathTrans.erase(0, m_docRoot.length());\n  }\n\n  auto qs = getParamTyped<std::string>(\"QUERY_STRING\");\n  if (!qs.empty()) {\n    m_serverObject += \"?\";\n    m_serverObject += qs;\n  }\n\n  // Treat everything apart from GET and HEAD as a post to be like php-src.\n  auto const ex = getExtendedMethod();\n  if (!strcmp(ex, \"GET\")) {\n    m_method = Method::GET;\n  } else if (!strcmp(ex, \"HEAD\")) {\n    m_method = Method::HEAD;\n  } else {\n    m_method = Method::POST;\n  }\n\n  // IIS sets this value but sets it to off when SSL is off.\n  if (m_requestParams.count(\"HTTPS\") && !m_requestParams[\"HTTPS\"].empty() &&\n      strcasecmp(m_requestParams[\"HTTPS\"].c_str(), \"OFF\")) {\n    setSSL();\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstd::string FastCGITransport::unmangleHeader(const std::string& name) const {\n  if (name == \"Authorization\") {\n    return name; // Already unmangled\n  }\n\n  if (name == \"CONTENT_LENGTH\") {\n    return \"Content-Length\";\n  }\n\n  if (name == \"CONTENT_TYPE\") {\n    return \"Content-Type\";\n  }\n\n  if (strncasecmp(name.c_str(), \"HTTP_\", 5)) {\n    return \"\";\n  }\n\n  std::string ret;\n  bool is_upper = true;\n  for (auto const& c : folly::StringPiece(name, 5)) {\n    if (c == '_') {\n      ret += '-';\n      is_upper = true;\n    } else {\n      ret += is_upper ? toupper(c) : tolower(c);\n      is_upper = false;\n    }\n  }\n  return ret;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "filenames": ["hphp/runtime/server/fastcgi/fastcgi-transport.cpp"], "buggy_code_start_loc": [214], "buggy_code_end_loc": [214], "fixing_code_start_loc": [215], "fixing_code_end_loc": [219], "type": "CWE-665", "message": "HHVM does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. This issue affects HHVM versions prior to 3.9.6, all versions between 3.10.0 and 3.12.4 (inclusive), and all versions between 3.13.0 and 3.14.2 (inclusive).", "other": {"cve": {"id": "CVE-2016-1000109", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-19T13:15:10.900", "lastModified": "2020-03-06T18:45:52.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HHVM does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. This issue affects HHVM versions prior to 3.9.6, all versions between 3.10.0 and 3.12.4 (inclusive), and all versions between 3.13.0 and 3.14.2 (inclusive)."}, {"lang": "es", "value": "HHVM no intenta abordar los conflictos de espacio de nombres de RFC 3875 section versi\u00f3n 4.1.18 y, por lo tanto, no protege las aplicaciones CGI de la presencia de datos de clientes no confiables en la variable de entorno HTTP_PROXY, lo que podr\u00eda permitir a atacantes remotos redireccionar el tr\u00e1fico HTTP saliente de una aplicaci\u00f3n CGI hacia un servidor proxy arbitrario por medio de un encabezado Proxy dise\u00f1ado en una petici\u00f3n HTTP, tambi\u00e9n se conoce como un problema \"httpoxy\". Este problema afecta a las versiones HHVM anteriores a 3.9.6, todas las versiones entre 3.10.0 y 3.12.4 (inclusive), y todas las versiones entre 3.13.0 y 3.14.2 (inclusive)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.9.6", "matchCriteriaId": "A60E75B9-EE8F-44ED-8E49-044B7AE45F0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.10.0", "versionEndIncluding": "3.12.4", "matchCriteriaId": "903C1991-8D3D-42FA-B53F-067A890F2119"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13.0", "versionEndIncluding": "3.14.2", "matchCriteriaId": "62F812F3-F2B5-4AC7-A8D8-9A56B2333ABC"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/423b4b719afd5ef4e6e19d8447fbf7b6bc0d0a25", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://httpoxy.org/", "source": "cve@mitre.org", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2016-1000109", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/423b4b719afd5ef4e6e19d8447fbf7b6bc0d0a25"}}