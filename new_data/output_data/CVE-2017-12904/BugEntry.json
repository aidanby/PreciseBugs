{"buggy_code": ["#include <config.h>\n#include <view.h>\n#include <controller.h>\n#include <configparser.h>\n#include <configcontainer.h>\n#include <exceptions.h>\n#include <downloadthread.h>\n#include <colormanager.h>\n#include <logger.h>\n#include <utils.h>\n#include <strprintf.h>\n#include <stflpp.h>\n#include <exception.h>\n#include <formatstring.h>\n#include <regexmanager.h>\n#include <rss_parser.h>\n#include <remote_api.h>\n#include <oldreader_api.h>\n#include <feedhq_api.h>\n#include <ttrss_api.h>\n#include <newsblur_api.h>\n#include <ocnews_api.h>\n#include <xlicense.h>\n\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <fstream>\n#include <cerrno>\n#include <algorithm>\n#include <functional>\n#include <mutex>\n\n#include <sys/time.h>\n#include <ctime>\n#include <cassert>\n#include <signal.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <sys/utsname.h>\n#include <langinfo.h>\n#include <libgen.h>\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pwd.h>\n\n#include <ncurses.h>\n\n#include <libxml/xmlversion.h>\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <libxml/xmlsave.h>\n#include <libxml/uri.h>\n#include <curl/curl.h>\n\nnamespace newsbeuter {\n\n#define LOCK_SUFFIX \".lock\"\n\nstd::string lock_file;\n\nint ctrl_c_hit = 0;\n\nvoid ctrl_c_action(int sig) {\n\tLOG(level::DEBUG,\"caught signal %d\",sig);\n\tif (SIGINT == sig) {\n\t\tctrl_c_hit = 1;\n\t} else {\n\t\tstfl::reset();\n\t\tutils::remove_fs_lock(lock_file);\n\t\t::exit(EXIT_FAILURE);\n\t}\n}\n\nvoid ignore_signal(int sig) {\n\tLOG(level::WARN, \"caught signal %d but ignored it\", sig);\n}\n\nvoid omg_a_child_died(int /* sig */) {\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1,&stat,WNOHANG)) > 0) { }\n\t::signal(SIGCHLD, omg_a_child_died); /* in case of unreliable signals */\n}\n\ncontroller::controller() : v(0), urlcfg(0), rsscache(0), url_file(\"urls\"), cache_file(\"cache.db\"), config_file(\"config\"), queue_file(\"queue\"), refresh_on_start(false), api(0) {\n}\n\n\n/**\n * \\brief Try to setup XDG style dirs.\n *\n * returns false, if that fails\n */\nbool controller::setup_dirs_xdg(const char *env_home, bool silent) {\n\tconst char *env_xdg_config;\n\tconst char *env_xdg_data;\n\tstd::string xdg_config_dir;\n\tstd::string xdg_data_dir;\n\n\tenv_xdg_config = ::getenv(\"XDG_CONFIG_HOME\");\n\tif (env_xdg_config) {\n\t\txdg_config_dir = env_xdg_config;\n\t} else {\n\t\txdg_config_dir = env_home;\n\t\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_config_dir.append(\".config\");\n\t}\n\n\tenv_xdg_data = ::getenv(\"XDG_DATA_HOME\");\n\tif (env_xdg_data) {\n\t\txdg_data_dir = env_xdg_data;\n\t} else {\n\t\txdg_data_dir = env_home;\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\".local\");\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\"share\");\n\t}\n\n\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_config_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_data_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\tbool config_dir_exists = 0 == access(xdg_config_dir.c_str(), R_OK | X_OK);\n\n\tif (!config_dir_exists) {\n\t\tif (!silent) {\n\t\t\tstd::cerr\n\t\t\t\t<< strprintf::fmt(\n\t\t\t\t\t   _(\"XDG: configuration directory '%s' not accessible, \"\n\t\t\t\t\t\t \"using '%s' instead.\"),\n\t\t\t\t\t   xdg_config_dir,\n\t\t\t\t\t   config_dir)\n\t\t\t\t<< std::endl;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/* Invariant: config dir exists.\n\t *\n\t * At this point, we're confident we'll be using XDG. We don't check if\n\t * data dir exists, because if it doesn't we'll create it. */\n\n\tconfig_dir = xdg_config_dir;\n\n\t// create data directory if it doesn't exist\n\tutils::mkdir_parents(xdg_data_dir, 0700);\n\n\t/* in config */\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\n\t/* in data */\n\tcache_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tqueue_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tsearchfile = strprintf::fmt(\"%s%shistory.search\", xdg_data_dir, NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = strprintf::fmt(\"%s%shistory.cmdline\", xdg_data_dir, NEWSBEUTER_PATH_SEP);\n\n\treturn true;\n}\n\nvoid controller::setup_dirs(bool silent) {\n\tconst char * env_home;\n\tif (!(env_home = ::getenv(\"HOME\"))) {\n\t\tstruct passwd * spw = ::getpwuid(::getuid());\n\t\tif (spw) {\n\t\t\tenv_home = spw->pw_dir;\n\t\t} else {\n\t\t\tstd::cerr << _(\"Fatal error: couldn't determine home directory!\") << std::endl;\n\t\t\tstd::cerr << strprintf::fmt(_(\"Please set the HOME environment variable or add a valid user for UID %u!\"), ::getuid()) << std::endl;\n\t\t\t::exit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tconfig_dir = env_home;\n\tconfig_dir.append(NEWSBEUTER_PATH_SEP);\n\tconfig_dir.append(NEWSBEUTER_CONFIG_SUBDIR);\n\n\tif (setup_dirs_xdg(env_home, silent))\n\t\treturn;\n\n\tmkdir(config_dir.c_str(),0700); // create configuration directory if it doesn't exist\n\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tcache_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\tqueue_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\n\tsearchfile = strprintf::fmt(\"%s%shistory.search\", config_dir, NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = strprintf::fmt(\"%s%shistory.cmdline\", config_dir, NEWSBEUTER_PATH_SEP);\n}\n\ncontroller::~controller() {\n\tdelete rsscache;\n\tdelete urlcfg;\n\tdelete api;\n\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (auto feed : feeds) {\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\t\tfeed->clear_items();\n\t}\n\tfeeds.clear();\n}\n\nvoid controller::set_view(view * vv) {\n\tv = vv;\n}\n\nvoid controller::run(int argc, char * argv[]) {\n\tint c;\n\n\t::signal(SIGINT, ctrl_c_action);\n\t::signal(SIGPIPE, ignore_signal);\n\t::signal(SIGHUP, ctrl_c_action);\n\t::signal(SIGCHLD, omg_a_child_died);\n\n\tbool do_import = false, do_export = false, cachefile_given_on_cmdline = false, do_vacuum = false;\n\tstd::string importfile;\n\tbool do_read_import = false, do_read_export = false;\n\tstd::string readinfofile;\n\tunsigned int show_version = 0;\n\n\tbool silent = false;\n\tbool execute_cmds = false;\n\n\tstatic const char getopt_str[] = \"i:erhqu:c:C:d:l:vVoxXI:E:\";\n\tstatic const struct option longopts[] = {\n\t\t{\"cache-file\"      , required_argument, 0, 'c'},\n\t\t{\"config-file\"     , required_argument, 0, 'C'},\n\t\t{\"execute\"         , required_argument, 0, 'x'},\n\t\t{\"export-to-file\"  , required_argument, 0, 'E'},\n\t\t{\"export-to-opml\"  , no_argument      , 0, 'e'},\n\t\t{\"help\"            , no_argument      , 0, 'h'},\n\t\t{\"import-from-file\", required_argument, 0, 'I'},\n\t\t{\"import-from-opml\", required_argument, 0, 'i'},\n\t\t{\"log-file\"        , required_argument, 0, 'd'},\n\t\t{\"log-level\"       , required_argument, 0, 'l'},\n\t\t{\"quiet\"           , no_argument      , 0, 'q'},\n\t\t{\"refresh-on-start\", no_argument      , 0, 'r'},\n\t\t{\"url-file\"        , required_argument, 0, 'u'},\n\t\t{\"vacuum\"          , no_argument      , 0, 'X'},\n\t\t{\"version\"         , no_argument      , 0, 'v'},\n\t\t{0                 , 0                , 0,  0 }\n\t};\n\n\t/* First of all, let's check for options that imply silencing of the\n\t * output: import, export, command execution and, well, quiet mode */\n\twhile ((c = ::getopt_long(argc, argv, getopt_str, longopts, nullptr)) != -1) {\n\t\tif (strchr(\"iexq\", c) != nullptr) {\n\t\t\tsilent = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsetup_dirs(silent);\n\n\t/* Now that silencing's set up, let's rewind to the beginning of argv and\n\t * process the options */\n\toptind = 1;\n\n\twhile ((c = ::getopt_long(argc, argv, getopt_str, longopts, nullptr)) != -1) {\n\t\tswitch (c) {\n\t\tcase ':': /* fall-through */\n\t\tcase '?': /* missing option */\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (do_export)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_import = true;\n\t\t\timportfile = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trefresh_on_start = true;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (do_import)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_export = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\turl_file = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcache_file = optarg;\n\t\t\tlock_file = std::string(cache_file) + LOCK_SUFFIX;\n\t\t\tcachefile_given_on_cmdline = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfig_file = optarg;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tdo_vacuum = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\tcase 'V':\n\t\t\tshow_version++;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\texecute_cmds = true;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tlogger::getInstance().set_logfile(optarg);\n\t\t\tbreak;\n\t\tcase 'l': {\n\t\t\tlevel l = static_cast<level>(atoi(optarg));\n\t\t\tif (l > level::NONE && l <= level::DEBUG) {\n\t\t\t\tlogger::getInstance().set_loglevel(l);\n\t\t\t} else {\n\t\t\t\tstd::cerr << strprintf::fmt(_(\"%s: %d: invalid loglevel value\"), argv[0], l) << std::endl;\n\t\t\t\t::std::exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (do_read_export)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_read_import = true;\n\t\t\treadinfofile = optarg;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tif (do_read_import)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_read_export = true;\n\t\t\treadinfofile = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << strprintf::fmt(_(\"%s: unknown option - %c\"), argv[0], static_cast<char>(c)) << std::endl;\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\n\tif (show_version) {\n\t\tversion_information(argv[0], show_version);\n\t}\n\n\tif (do_import) {\n\t\tLOG(level::INFO,\"Importing OPML file from %s\",importfile);\n\t\turlcfg = new file_urlreader(url_file);\n\t\turlcfg->reload();\n\t\timport_opml(importfile);\n\t\treturn;\n\t}\n\n\n\tLOG(level::INFO, \"nl_langinfo(CODESET): %s\", nl_langinfo(CODESET));\n\n\tif (!do_export) {\n\n\t\tif (!silent)\n\t\t\tstd::cout << strprintf::fmt(_(\"Starting %s %s...\"), PROGRAM_NAME, PROGRAM_VERSION) << std::endl;\n\n\t\tpid_t pid;\n\t\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\t\tif (pid > 0) {\n\t\t\t\tLOG(level::ERROR,\"an instance is already running: pid = %u\",pid);\n\t\t\t} else {\n\t\t\t\tLOG(level::ERROR,\"something went wrong with the lock: %s\", strerror(errno));\n\t\t\t}\n\t\t\tif (!execute_cmds) {\n\t\t\t\tstd::cout << strprintf::fmt(_(\"Error: an instance of %s is already running (PID: %u)\"), PROGRAM_NAME, pid) << std::endl;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!silent)\n\t\tstd::cout << _(\"Loading configuration...\");\n\tstd::cout.flush();\n\n\tcfg.register_commands(cfgparser);\n\tcolorman.register_commands(cfgparser);\n\n\tkeymap keys(KM_NEWSBEUTER);\n\tcfgparser.register_handler(\"bind-key\",&keys);\n\tcfgparser.register_handler(\"unbind-key\",&keys);\n\tcfgparser.register_handler(\"macro\", &keys);\n\n\tcfgparser.register_handler(\"ignore-article\",&ign);\n\tcfgparser.register_handler(\"always-download\",&ign);\n\tcfgparser.register_handler(\"reset-unread-on-update\",&ign);\n\n\tcfgparser.register_handler(\"define-filter\",&filters);\n\tcfgparser.register_handler(\"highlight\", &rxman);\n\tcfgparser.register_handler(\"highlight-article\", &rxman);\n\n\ttry {\n\t\tcfgparser.parse(\"/etc/\" PROGRAM_NAME \"/config\");\n\t\tcfgparser.parse(config_file);\n\t} catch (const configexception& ex) {\n\t\tLOG(level::ERROR,\"an exception occurred while parsing the configuration file: %s\",ex.what());\n\t\tstd::cout << ex.what() << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tupdate_config();\n\n\tif (!silent)\n\t\tstd::cout << _(\"done.\") << std::endl;\n\n\t// create cache object\n\tstd::string cachefilepath = cfg.get_configvalue(\"cache-file\");\n\tif (cachefilepath.length() > 0 && !cachefile_given_on_cmdline) {\n\t\tcache_file = cachefilepath.c_str();\n\n\t\t// ok, we got another cache file path via the configuration\n\t\t// that means we need to remove the old lock file, assemble\n\t\t// the new lock file's name, and then try to lock it.\n\t\tutils::remove_fs_lock(lock_file);\n\t\tlock_file = std::string(cache_file) + LOCK_SUFFIX;\n\n\t\tpid_t pid;\n\t\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\t\tif (pid > 0) {\n\t\t\t\tLOG(level::ERROR,\"an instance is already running: pid = %u\",pid);\n\t\t\t} else {\n\t\t\t\tLOG(level::ERROR,\"something went wrong with the lock: %s\", strerror(errno));\n\t\t\t}\n\t\t\tstd::cout << strprintf::fmt(_(\"Error: an instance of %s is already running (PID: %u)\"), PROGRAM_NAME, pid) << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!silent) {\n\t\tstd::cout << _(\"Opening cache...\");\n\t\tstd::cout.flush();\n\t}\n\ttry {\n\t\trsscache = new cache(cache_file,&cfg);\n\t} catch (const dbexception& e) {\n\t\tstd::cerr << strprintf::fmt(_(\"Error: opening the cache file `%s' failed: %s\"), cache_file, e.what()) << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\t::exit(EXIT_FAILURE);\n\t}\n\n\tif (!silent) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\n\n\tstd::string type = cfg.get_configvalue(\"urls-source\");\n\tif (type == \"local\") {\n\t\turlcfg = new file_urlreader(url_file);\n\t} else if (type == \"opml\") {\n\t\turlcfg = new opml_urlreader(&cfg);\n\t} else if (type == \"oldreader\") {\n\t\tapi = new oldreader_api(&cfg);\n\t\turlcfg = new oldreader_urlreader(&cfg, url_file, api);\n\t} else if (type == \"ttrss\") {\n\t\tapi = new ttrss_api(&cfg);\n\t\turlcfg = new ttrss_urlreader(url_file, api);\n\t} else if (type == \"newsblur\") {\n\t\tapi = new newsblur_api(&cfg);\n\t\turlcfg = new newsblur_urlreader(url_file, api);\n\t} else if (type == \"feedhq\") {\n\t\tapi = new feedhq_api(&cfg);\n\t\turlcfg = new feedhq_urlreader(&cfg, url_file, api);\n\t} else if (type == \"ocnews\") {\n\t\tapi = new ocnews_api(&cfg);\n\t\turlcfg = new ocnews_urlreader(url_file, api);\n\t} else {\n\t\tLOG(level::ERROR,\"unknown urls-source `%s'\", urlcfg->get_source());\n\t}\n\n\tif (!do_export && !silent) {\n\t\tstd::cout << strprintf::fmt(_(\"Loading URLs from %s...\"), urlcfg->get_source());\n\t\tstd::cout.flush();\n\t}\n\tif (api) {\n\t\tif (!api->authenticate()) {\n\t\t\tstd::cout << \"Authentication failed.\" << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t}\n\t}\n\turlcfg->reload();\n\tif (!do_export && !silent) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\tif (urlcfg->get_urls().size() == 0) {\n\t\tLOG(level::ERROR,\"no URLs configured.\");\n\t\tstd::string msg;\n\t\tif (type == \"local\") {\n\t\t\tmsg = strprintf::fmt(_(\"Error: no URLs configured. Please fill the file %s with RSS feed URLs or import an OPML file.\"), url_file);\n\t\t} else if (type == \"opml\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like the OPML feed you subscribed contains no feeds. Please fill it with feeds, and try again.\"));\n\t\t} else if (type == \"oldreader\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your The Old Reader account. Please do so, and try again.\"));\n\t\t} else if (type == \"ttrss\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your Tiny Tiny RSS account. Please do so, and try again.\"));\n\t\t} else if (type == \"newsblur\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your NewsBlur account. Please do so, and try again.\"));\n\t\t} else {\n\t\t\tassert(0); // shouldn't happen\n\t\t}\n\t\tstd::cout << msg << std::endl << std::endl;\n\t\tusage(argv[0]);\n\t}\n\n\tif (!do_export && !do_vacuum && !silent)\n\t\tstd::cout << _(\"Loading articles from cache...\");\n\tif (do_vacuum)\n\t\tstd::cout << _(\"Opening cache...\");\n\tstd::cout.flush();\n\n\n\tif (do_vacuum) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\tstd::cout << _(\"Cleaning up cache thoroughly...\");\n\t\tstd::cout.flush();\n\t\trsscache->do_vacuum();\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tunsigned int i=0;\n\tfor (auto url : urlcfg->get_urls()) {\n\t\ttry {\n\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\tstd::shared_ptr<rss_feed> feed = rsscache->internalize_rssfeed(url, ignore_disp ? &ign : nullptr);\n\t\t\tfeed->set_tags(urlcfg->get_tags(url));\n\t\t\tfeed->set_order(i);\n\t\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\t\tfeeds.push_back(feed);\n\t\t} catch(const dbexception& e) {\n\t\t\tstd::cout << _(\"Error while loading feeds from database: \") << e.what() << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t} catch(const std::string& str) {\n\t\t\tstd::cout << strprintf::fmt(_(\"Error while loading feed '%s': %s\"), url, str) << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n\n\tstd::vector<std::string> tags = urlcfg->get_alltags();\n\n\tif (!do_export && !silent)\n\t\tstd::cout << _(\"done.\") << std::endl;\n\n\t// if configured, we fill all query feeds with some data; no need to sort it, it will be refilled when actually opening it.\n\tif (cfg.get_configvalue_as_bool(\"prepopulate-query-feeds\")) {\n\t\tstd::cout << _(\"Prepopulating query feeds...\");\n\t\tstd::cout.flush();\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tfor (auto feed : feeds) {\n\t\t\tif (feed->rssurl().substr(0,6) == \"query:\") {\n\t\t\t\tfeed->update_items(get_all_feeds_unlocked());\n\t\t\t}\n\t\t}\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\tsort_feeds();\n\n\tif (do_export) {\n\t\texport_opml();\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tif (do_read_import) {\n\t\tLOG(level::INFO,\"Importing read information file from %s\",readinfofile);\n\t\tstd::cout << _(\"Importing list of read articles...\");\n\t\tstd::cout.flush();\n\t\timport_read_information(readinfofile);\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\treturn;\n\t}\n\n\tif (do_read_export) {\n\t\tLOG(level::INFO,\"Exporting read information file to %s\",readinfofile);\n\t\tstd::cout << _(\"Exporting list of read articles...\");\n\t\tstd::cout.flush();\n\t\texport_read_information(readinfofile);\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\treturn;\n\t}\n\n\t// hand over the important objects to the view\n\tv->set_config_container(&cfg);\n\tv->set_keymap(&keys);\n\tv->set_tags(tags);\n\n\tif (execute_cmds) {\n\t\texecute_commands(argv, optind);\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\t// if the user wants to refresh on startup via configuration file, then do so,\n\t// but only if -r hasn't been supplied.\n\tif (!refresh_on_start && cfg.get_configvalue_as_bool(\"refresh-on-startup\")) {\n\t\trefresh_on_start = true;\n\t}\n\n\tformaction::load_histories(searchfile, cmdlinefile);\n\n\t// run the view\n\tv->run();\n\n\tunsigned int history_limit = cfg.get_configvalue_as_int(\"history-limit\");\n\tLOG(level::DEBUG, \"controller::run: history-limit = %u\", history_limit);\n\tformaction::save_histories(searchfile, cmdlinefile, history_limit);\n\n\tif (!silent) {\n\t\tstd::cout << _(\"Cleaning up cache...\");\n\t\tstd::cout.flush();\n\t}\n\ttry {\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\trsscache->cleanup_cache(feeds);\n\t\tif (!silent) {\n\t\t\tstd::cout << _(\"done.\") << std::endl;\n\t\t}\n\t} catch (const dbexception& e) {\n\t\tLOG(level::USERERROR, \"Cleaning up cache failed: %s\", e.what());\n\t\tif (!silent) {\n\t\t\tstd::cout << _(\"failed: \") << e.what() << std::endl;\n\t\t}\n\t}\n\n\tutils::remove_fs_lock(lock_file);\n}\n\nvoid controller::update_feedlist() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tv->set_feedlist(feeds);\n}\n\nvoid controller::update_visible_feeds() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tv->update_visible_feeds(feeds);\n}\n\nvoid controller::mark_all_read(const std::string& feedurl) {\n\ttry {\n\t\trsscache->mark_all_read(feedurl);\n\t} catch (const dbexception& e) {\n\t\tv->show_error(strprintf::fmt(_(\"Error: couldn't mark all feeds read: %s\"), e.what()));\n\t\treturn;\n\t}\n\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (const auto& feed : feeds) {\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\n\t\tif (feedurl.length() > 0 && feed->rssurl() != feedurl)\n\t\t\tcontinue;\n\n\t\tif (feed->total_item_count() > 0) {\n\t\t\tif (api) {\n\t\t\t\tapi->mark_all_read(feed->rssurl());\n\t\t\t}\n\t\t\tfor (auto item : feed->items()) {\n\t\t\t\titem->set_unread_nowrite(false);\n\t\t\t}\n\t\t}\n\n\t\t// no point in going on - there is only one feed with a given URL\n\t\tif (feedurl.length() > 0) break;\n\t}\n}\n\nvoid controller::mark_article_read(const std::string& guid, bool read) {\n\tif (api) {\n\t\tapi->mark_article_read(guid, read);\n\t}\n}\n\nvoid controller::mark_all_read(unsigned int pos) {\n\tif (pos < feeds.size()) {\n\t\tscope_measure m(\"controller::mark_all_read\");\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tstd::shared_ptr<rss_feed> feed = feeds[pos];\n\t\tif (feed->rssurl().substr(0,6) == \"query:\") {\n\t\t\trsscache->mark_all_read(feed);\n\t\t} else {\n\t\t\trsscache->mark_all_read(feed->rssurl());\n\t\t\tif (api) {\n\t\t\t\tapi->mark_all_read(feed->rssurl());\n\t\t\t}\n\t\t}\n\t\tm.stopover(\"after rsscache->mark_all_read, before iteration over items\");\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\t\tstd::vector<std::shared_ptr<rss_item>>& items = feed->items();\n\t\tif (items.size() > 0) {\n\t\t\tbool notify = items[0]->feedurl() != feed->rssurl();\n\t\t\tLOG(level::DEBUG, \"controller::mark_all_read: notify = %s\", notify ? \"yes\" : \"no\");\n\t\t\tfor (auto item : items) {\n\t\t\t\titem->set_unread_nowrite_notify(false, notify);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid controller::reload(unsigned int pos, unsigned int max, bool unattended, curl_handle *easyhandle) {\n\tLOG(level::DEBUG, \"controller::reload: pos = %u max = %u\", pos, max);\n\tif (pos < feeds.size()) {\n\t\tstd::shared_ptr<rss_feed> oldfeed = feeds[pos];\n\t\tstd::string errmsg;\n\t\tif (!unattended)\n\t\t\tv->set_status(strprintf::fmt(_(\"%sLoading %s...\"), prepare_message(pos+1, max), utils::censor_url(oldfeed->rssurl())));\n\n\t\tbool ignore_dl = (cfg.get_configvalue(\"ignore-mode\") == \"download\");\n\n\t\trss_parser parser(oldfeed->rssurl(), rsscache, &cfg, ignore_dl ? &ign : nullptr, api);\n\t\tparser.set_easyhandle(easyhandle);\n\t\tLOG(level::DEBUG, \"controller::reload: created parser\");\n\t\ttry {\n\t\t\toldfeed->set_status(dl_status::DURING_DOWNLOAD);\n\t\t\tstd::shared_ptr<rss_feed> newfeed = parser.parse();\n\t\t\tif (newfeed->total_item_count() > 0) {\n\t\t\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\t\t\tsave_feed(newfeed, pos);\n\n\t\t\t\tnewfeed->clear_items();\n\n\t\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\t\tstd::shared_ptr<rss_feed> feed = rsscache->internalize_rssfeed(oldfeed->rssurl(), ignore_disp ? &ign : nullptr);\n\t\t\t\tfeed->set_tags(urlcfg->get_tags(oldfeed->rssurl()));\n\t\t\t\tfeed->set_order(oldfeed->get_order());\n\t\t\t\tfeeds[pos] = feed;\n\t\t\t\tenqueue_items(feed);\n\n\t\t\t\toldfeed->clear_items();\n\n\t\t\t\tv->notify_itemlist_change(feeds[pos]);\n\t\t\t\tif (!unattended) {\n\t\t\t\t\tv->set_feedlist(feeds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG(level::DEBUG, \"controller::reload: feed is empty\");\n\t\t\t}\n\t\t\toldfeed->set_status(dl_status::SUCCESS);\n\t\t\tv->set_status(\"\");\n\t\t} catch (const dbexception& e) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), e.what());\n\t\t} catch (const std::string& emsg) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), emsg);\n\t\t} catch (rsspp::exception& e) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), e.what());\n\t\t}\n\t\tif (errmsg != \"\") {\n\t\t\toldfeed->set_status(dl_status::DL_ERROR);\n\t\t\tv->set_status(errmsg);\n\t\t\tLOG(level::USERERROR, \"%s\", errmsg);\n\t\t}\n\t} else {\n\t\tv->show_error(_(\"Error: invalid feed!\"));\n\t}\n}\n\nstd::shared_ptr<rss_feed> controller::get_feed(unsigned int pos) {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tif (pos >= feeds.size()) {\n\t\tthrow std::out_of_range(_(\"invalid feed index (bug)\"));\n\t}\n\tstd::shared_ptr<rss_feed> feed = feeds[pos];\n\treturn feed;\n}\n\nvoid controller::reload_indexes(const std::vector<int>& indexes, bool unattended) {\n\tscope_measure m1(\"controller::reload_indexes\");\n\tunsigned int unread_feeds, unread_articles;\n\tcompute_unread_numbers(unread_feeds, unread_articles);\n\n\tunsigned long size;\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tsize = feeds.size();\n\t}\n\n\tfor (auto idx : indexes) {\n\t\tthis->reload(idx, size, unattended);\n\t}\n\n\tunsigned int unread_feeds2, unread_articles2;\n\tcompute_unread_numbers(unread_feeds2, unread_articles2);\n\tbool notify_always = cfg.get_configvalue_as_bool(\"notify-always\");\n\tif (notify_always || unread_feeds2 != unread_feeds || unread_articles2 != unread_articles) {\n\t\tfmtstr_formatter fmt;\n\t\tfmt.register_fmt('f', std::to_string(unread_feeds2));\n\t\tfmt.register_fmt('n', std::to_string(unread_articles2));\n\t\tfmt.register_fmt('d', std::to_string(unread_articles2 - unread_articles));\n\t\tfmt.register_fmt('D', std::to_string(unread_feeds2 - unread_feeds));\n\t\tthis->notify(fmt.do_format(cfg.get_configvalue(\"notify-format\")));\n\t}\n\tif (!unattended)\n\t\tv->set_status(\"\");\n}\n\nvoid controller::reload_range(unsigned int start, unsigned int end, unsigned int size, bool unattended) {\n\n\tstd::vector<unsigned int> v;\n\tfor (unsigned int i=start; i<=end; ++i)\n\t\tv.push_back(i);\n\n\tauto extract = [](std::string& s, const std::string& url) {\n\t\tsize_t p = url.find(\"//\");\n\t\tp = (p == std::string::npos) ? 0 : p+2;\n\t\tstd::string suff(url.substr(p));\n\t\tp = suff.find('/');\n\t\ts = suff.substr(0, p);\n\t};\n\n\tstd::sort(v.begin(), v.end(), [&](unsigned int a, unsigned int b) {\n\t\tstd::string domain1, domain2;\n\t\textract(domain1, feeds[a]->rssurl());\n\t\textract(domain2, feeds[b]->rssurl());\n\t\tstd::reverse(domain1.begin(), domain1.end());\n\t\tstd::reverse(domain2.begin(), domain2.end());\n\t\treturn domain1 < domain2;\n\t});\n\n\tcurl_handle easyhandle;\n\n\tfor (auto i : v) {\n\t\tLOG(level::DEBUG, \"controller::reload_range: reloading feed #%u\", i);\n\t\tthis->reload(i, size, unattended, &easyhandle);\n\t}\n}\n\nvoid controller::reload_all(bool unattended) {\n\tunsigned int unread_feeds, unread_articles;\n\tcompute_unread_numbers(unread_feeds, unread_articles);\n\tunsigned int num_threads = cfg.get_configvalue_as_int(\"reload-threads\");\n\ttime_t t1, t2, dt;\n\n\tunsigned int size;\n\n\t{\n\t\tstd::lock_guard<std::mutex> feedlock(feeds_mutex);\n\t\tfor (auto feed : feeds) {\n\t\t\tfeed->reset_status();\n\t\t}\n\t\tsize = feeds.size();\n\t}\n\n\tif (num_threads < 1)\n\t\tnum_threads = 1;\n\n\tif (num_threads > size) {\n\t\tnum_threads = size;\n\t}\n\n\n\tt1 = time(nullptr);\n\n\tLOG(level::DEBUG,\"controller::reload_all: starting with reload all...\");\n\tif (num_threads <= 1) {\n\t\tthis->reload_range(0, size-1, size, unattended);\n\t} else {\n\t\tstd::vector<std::pair<unsigned int, unsigned int>> partitions = utils::partition_indexes(0, size-1, num_threads);\n\t\tstd::vector<std::thread> threads;\n\t\tLOG(level::DEBUG, \"controller::reload_all: starting reload threads...\");\n\t\tfor (unsigned int i=0; i<num_threads-1; i++) {\n\t\t\tthreads.push_back(std::thread(reloadrangethread(this, partitions[i].first, partitions[i].second, size, unattended)));\n\t\t}\n\t\tLOG(level::DEBUG, \"controller::reload_all: starting my own reload...\");\n\t\tthis->reload_range(partitions[num_threads-1].first, partitions[num_threads-1].second, size, unattended);\n\t\tLOG(level::DEBUG, \"controller::reload_all: joining other threads...\");\n\t\tfor (size_t i=0; i<threads.size(); i++) {\n\t\t\tthreads[i].join();\n\t\t}\n\t}\n\n\t// refresh query feeds (update and sort)\n\tLOG(level::DEBUG, \"controller::reload_all: refresh query feeds\");\n\tfor (auto feed : feeds) {\n\t\tv->prepare_query_feed(feed);\n\t}\n\tv->force_redraw();\n\n\tsort_feeds();\n\tupdate_feedlist();\n\n\tt2 = time(nullptr);\n\tdt = t2 - t1;\n\tLOG(level::INFO, \"controller::reload_all: reload took %d seconds\", dt);\n\n\tunsigned int unread_feeds2, unread_articles2;\n\tcompute_unread_numbers(unread_feeds2, unread_articles2);\n\tbool notify_always = cfg.get_configvalue_as_bool(\"notify-always\");\n\tif (notify_always || unread_feeds2 > unread_feeds || unread_articles2 > unread_articles) {\n\t\tint article_count = unread_articles2 - unread_articles;\n\t\tint feed_count = unread_feeds2 - unread_feeds;\n\n\t\tLOG(level::DEBUG, \"unread article count: %d\", article_count);\n\t\tLOG(level::DEBUG, \"unread feed count: %d\", feed_count);\n\n\t\tfmtstr_formatter fmt;\n\t\tfmt.register_fmt('f', std::to_string(unread_feeds2));\n\t\tfmt.register_fmt('n', std::to_string(unread_articles2));\n\t\tfmt.register_fmt('d', std::to_string(article_count >= 0 ? article_count : 0));\n\t\tfmt.register_fmt('D', std::to_string(feed_count >= 0 ? feed_count : 0));\n\t\tthis->notify(fmt.do_format(cfg.get_configvalue(\"notify-format\")));\n\t}\n}\n\nvoid controller::notify(const std::string& msg) {\n\tif (cfg.get_configvalue_as_bool(\"notify-screen\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying screen\");\n\t\tstd::cout << \"\\033^\" << msg << \"\\033\\\\\";\n\t\tstd::cout.flush();\n\t}\n\tif (cfg.get_configvalue_as_bool(\"notify-xterm\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying xterm\");\n\t\tstd::cout << \"\\033]2;\" << msg << \"\\033\\\\\";\n\t\tstd::cout.flush();\n\t}\n\tif (cfg.get_configvalue_as_bool(\"notify-beep\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying beep\");\n\t\t::beep();\n\t}\n\tif (cfg.get_configvalue(\"notify-program\").length() > 0) {\n\t\tstd::string prog = cfg.get_configvalue(\"notify-program\");\n\t\tLOG(level::DEBUG, \"controller:notify: notifying external program `%s'\", prog);\n\t\tutils::run_command(prog, msg);\n\t}\n}\n\nvoid controller::compute_unread_numbers(unsigned int& unread_feeds, unsigned int& unread_articles) {\n\tunread_feeds = 0;\n\tunread_articles = 0;\n\tfor (auto feed : feeds) {\n\t\tunsigned int items = feed->unread_item_count();\n\t\tif (items > 0) {\n\t\t\t++unread_feeds;\n\t\t\tunread_articles += items;\n\t\t}\n\t}\n}\n\nbool controller::trylock_reload_mutex() {\n\tif (reload_mutex.try_lock()) {\n\t\tLOG(level::DEBUG, \"controller::trylock_reload_mutex succeeded\");\n\t\treturn true;\n\t}\n\tLOG(level::DEBUG, \"controller::trylock_reload_mutex failed\");\n\treturn false;\n}\n\nvoid controller::start_reload_all_thread(std::vector<int> * indexes) {\n\tLOG(level::INFO,\"starting reload all thread\");\n\tstd::thread t(downloadthread(this, indexes));\n\tt.detach();\n}\n\nvoid controller::version_information(const char * argv0, unsigned int level) {\n\tif (level<=1) {\n\t\tstd::cout << PROGRAM_NAME << \" \" << PROGRAM_VERSION << \" - \" << PROGRAM_URL << std::endl;\n\t\tstd::cout << \"Copyright (C) 2006-2015 Andreas Krennmair\" << std::endl;\n\t\tstd::cout << \"Copyright (C) 2015-2017 Alexander Batischev\" << std::endl;\n\t\tstd::cout << \"Copyright (C) 2006-2017 Newsbeuter contributors\" << std::endl;\n\t\tstd::cout << std::endl;\n\n\t\tstd::cout << _(\"newsbeuter is free software and licensed under the MIT/X Consortium License.\") << std::endl;\n\t\tstd::cout << strprintf::fmt(_(\"Type `%s -vv' for more information.\"), argv0) << std::endl << std::endl;\n\n\t\tstruct utsname xuts;\n\t\tuname(&xuts);\n\t\tstd::cout << PROGRAM_NAME << \" \" << PROGRAM_VERSION << std::endl;\n\t\tstd::cout << \"System: \" << xuts.sysname << \" \" << xuts.release << \" (\" << xuts.machine << \")\" << std::endl;\n#if defined(__GNUC__) && defined(__VERSION__)\n\t\tstd::cout << \"Compiler: g++ \" << __VERSION__ << std::endl;\n#endif\n\t\tstd::cout << \"ncurses: \" << curses_version() << \" (compiled with \" << NCURSES_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"libcurl: \" << curl_version()  << \" (compiled with \" << LIBCURL_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"SQLite: \" << sqlite3_libversion() << \" (compiled with \" << SQLITE_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"libxml2: compiled with \" << LIBXML_DOTTED_VERSION << std::endl << std::endl;\n\t} else {\n\t\tstd::cout << LICENSE_str << std::endl;\n\t}\n\n\t::exit(EXIT_SUCCESS);\n}\n\nvoid controller::usage(char * argv0) {\n\tauto msg =\n\t    strprintf::fmt(_(\"%s %s\\nusage: %s [-i <file>|-e] [-u <urlfile>] \"\n\t    \"[-c <cachefile>] [-x <command> ...] [-h]\\n\"),\n\t    PROGRAM_NAME,\n\t    PROGRAM_VERSION,\n\t    argv0);\n\tstd::cout << msg;\n\n\tstruct arg {\n\t\tconst char name;\n\t\tconst std::string longname;\n\t\tconst std::string params;\n\t\tconst std::string desc;\n\t};\n\n\tstatic const std::vector<arg> args = {\n\t\t{ 'e', \"export-to-opml\"  , \"\"                , _s(\"export OPML feed to stdout\") }                                                 ,\n\t\t{ 'r', \"refresh-on-start\", \"\"                , _s(\"refresh feeds on start\") }                                                     ,\n\t\t{ 'i', \"import-from-opml\", _s(\"<file>\")      , _s(\"import OPML file\") }                                                           ,\n\t\t{ 'u', \"url-file\"        , _s(\"<urlfile>\")   , _s(\"read RSS feed URLs from <urlfile>\") }                                          ,\n\t\t{ 'c', \"cache-file\"      , _s(\"<cachefile>\") , _s(\"use <cachefile> as cache file\") }                                              ,\n\t\t{ 'C', \"config-file\"     , _s(\"<configfile>\"), _s(\"read configuration from <configfile>\") }                                       ,\n\t\t{ 'X', \"vacuum\"          , \"\"                , _s(\"compact the cache\") }                                                  ,\n\t\t{ 'x', \"execute\"         , _s(\"<command>...\"), _s(\"execute list of commands\") }                                                   ,\n\t\t{ 'q', \"quiet\"           , \"\"                , _s(\"quiet startup\") }                                                              ,\n\t\t{ 'v', \"version\"         , \"\"                , _s(\"get version information\") }                                                    ,\n\t\t{ 'l', \"log-level\"       , _s(\"<loglevel>\")  , _s(\"write a log with a certain loglevel (valid values: 1 to 6)\") }                 ,\n\t\t{ 'd', \"log-file\"        , _s(\"<logfile>\")   , _s(\"use <logfile> as output log file\") }                                           ,\n\t\t{ 'E', \"export-to-file\"  , _s(\"<file>\")      , _s(\"export list of read articles to <file>\") }                                     ,\n\t\t{ 'I', \"import-from-file\", _s(\"<file>\")      , _s(\"import list of read articles from <file>\") }                                   ,\n\t\t{ 'h', \"help\"            , \"\"                , _s(\"this help\") }\n\t};\n\n\tfor (const auto & a : args) {\n\t\tstd::string longcolumn(\"-\");\n\t\tlongcolumn += a.name;\n\t\tlongcolumn += \", --\" + a.longname;\n\t\tlongcolumn += a.params.size() > 0 ? \"=\" + a.params : \"\";\n\t\tstd::cout << \"\\t\" << longcolumn;\n\t\tfor (unsigned int j = 0; j < utils::gentabs(longcolumn); j++) {\n\t\t\tstd::cout << \"\\t\";\n\t\t}\n\t\tstd::cout << a.desc << std::endl;\n\t}\n\n\t::exit(EXIT_FAILURE);\n}\n\nvoid controller::import_opml(const std::string& filename) {\n\txmlDoc * doc = xmlReadFile(filename.c_str(), nullptr, 0);\n\tif (doc == nullptr) {\n\t\tstd::cout\n\t\t\t<< strprintf::fmt(_(\"An error occurred while parsing %s.\"), filename)\n\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\txmlNode * root = xmlDocGetRootElement(doc);\n\n\tfor (xmlNode * node = root->children; node != nullptr; node = node->next) {\n\t\tif (strcmp((const char *)node->name, \"body\")==0) {\n\t\t\tLOG(level::DEBUG, \"import_opml: found body\");\n\t\t\trec_find_rss_outlines(node->children, \"\");\n\t\t\turlcfg->write_config();\n\t\t}\n\t}\n\n\txmlFreeDoc(doc);\n\tstd::cout << strprintf::fmt(_(\"Import of %s finished.\"), filename) << std::endl;\n}\n\nvoid controller::export_opml() {\n\txmlDocPtr root = xmlNewDoc((const xmlChar *)\"1.0\");\n\txmlNodePtr opml_node = xmlNewDocNode(root, nullptr, (const xmlChar *)\"opml\", nullptr);\n\txmlSetProp(opml_node, (const xmlChar *)\"version\", (const xmlChar *)\"1.0\");\n\txmlDocSetRootElement(root, opml_node);\n\n\txmlNodePtr head = xmlNewTextChild(opml_node, nullptr, (const xmlChar *)\"head\", nullptr);\n\txmlNewTextChild(head, nullptr, (const xmlChar *)\"title\", (const xmlChar *)PROGRAM_NAME \" - Exported Feeds\");\n\txmlNodePtr body = xmlNewTextChild(opml_node, nullptr, (const xmlChar *)\"body\", nullptr);\n\n\tfor (auto feed : feeds) {\n\t\tif (!utils::is_special_url(feed->rssurl())) {\n\t\t\tstd::string rssurl = feed->rssurl();\n\t\t\tstd::string link = feed->link();\n\t\t\tstd::string title = feed->title();\n\n\t\t\txmlNodePtr outline = xmlNewTextChild(body, nullptr, (const xmlChar *)\"outline\", nullptr);\n\t\t\txmlSetProp(outline, (const xmlChar *)\"type\", (const xmlChar *)\"rss\");\n\t\t\txmlSetProp(outline, (const xmlChar *)\"xmlUrl\", (const xmlChar *)rssurl.c_str());\n\t\t\txmlSetProp(outline, (const xmlChar *)\"htmlUrl\", (const xmlChar *)link.c_str());\n\t\t\txmlSetProp(outline, (const xmlChar *)\"title\", (const xmlChar *)title.c_str());\n\t\t}\n\t}\n\n\txmlSaveCtxtPtr savectx = xmlSaveToFd(1, nullptr, 1);\n\txmlSaveDoc(savectx, root);\n\txmlSaveClose(savectx);\n\n\txmlFreeNode(opml_node);\n}\n\nvoid controller::rec_find_rss_outlines(xmlNode * node, std::string tag) {\n\twhile (node) {\n\t\tstd::string newtag = tag;\n\n\n\t\tif (strcmp((const char *)node->name, \"outline\")==0) {\n\t\t\tchar * url = (char *)xmlGetProp(node, (const xmlChar *)\"xmlUrl\");\n\t\t\tif (!url) {\n\t\t\t\turl = (char *)xmlGetProp(node, (const xmlChar *)\"url\");\n\t\t\t}\n\n\t\t\tif (url) {\n\t\t\t\tLOG(level::DEBUG,\"OPML import: found RSS outline with url = %s\",url);\n\n\t\t\t\tstd::string nurl = std::string(url);\n\n\t\t\t\t// Liferea uses a pipe to signal feeds read from the output of\n\t\t\t\t// a program in its OPMLs. Convert them to our syntax.\n\t\t\t\tif (*url == '|') {\n\t\t\t\t\tnurl = strprintf::fmt(\"exec:%s\", url+1);\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: liferea-style url %s converted to %s\", url, nurl);\n\t\t\t\t}\n\n\t\t\t\t// Handle OPML filters.\n\t\t\t\tchar * filtercmd = (char *)xmlGetProp(node, (const xmlChar *)\"filtercmd\");\n\t\t\t\tif (filtercmd) {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: adding filter command %s to url %s\", filtercmd, nurl);\n\t\t\t\t\tnurl.insert(0, strprintf::fmt(\"filter:%s:\", filtercmd));\n\t\t\t\t\txmlFree(filtercmd);\n\t\t\t\t}\n\n\t\t\t\txmlFree(url);\n\t\t\t\t// Filters and scripts may have arguments, so, quote them when needed.\n\t\t\t\turl = (char*) xmlStrdup((const xmlChar*)utils::quote_if_necessary(nurl).c_str());\n\t\t\t\tassert(url);\n\n\t\t\t\tbool found = false;\n\n\t\t\t\tLOG(level::DEBUG, \"OPML import: size = %u\", urlcfg->get_urls().size());\n\t\t\t\tif (urlcfg->get_urls().size() > 0) {\n\t\t\t\t\tfor (auto u : urlcfg->get_urls()) {\n\t\t\t\t\t\tif (u == url) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found) {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: added url = %s\",url);\n\t\t\t\t\turlcfg->get_urls().push_back(std::string(url));\n\t\t\t\t\tif (tag.length() > 0) {\n\t\t\t\t\t\tLOG(level::DEBUG, \"OPML import: appending tag %s to url %s\", tag, url);\n\t\t\t\t\t\turlcfg->get_tags(url).push_back(tag);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: url = %s is already in list\",url);\n\t\t\t\t}\n\t\t\t\txmlFree(url);\n\t\t\t} else {\n\t\t\t\tchar * text = (char *)xmlGetProp(node, (const xmlChar *)\"text\");\n\t\t\t\tif (!text)\n\t\t\t\t\ttext = (char *)xmlGetProp(node, (const xmlChar *)\"title\");\n\t\t\t\tif (text) {\n\t\t\t\t\tif (newtag.length() > 0) {\n\t\t\t\t\t\tnewtag.append(\"/\");\n\t\t\t\t\t}\n\t\t\t\t\tnewtag.append(text);\n\t\t\t\t\txmlFree(text);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trec_find_rss_outlines(node->children, newtag);\n\n\t\tnode = node->next;\n\t}\n}\n\n\n\nstd::vector<std::shared_ptr<rss_item>> controller::search_for_items(const std::string& query, std::shared_ptr<rss_feed> feed) {\n\tstd::vector<std::shared_ptr<rss_item>> items;\n\tLOG(level::DEBUG, \"controller::search_for_items: setting feed pointers\");\n\tif (feed != nullptr && feed->rssurl().substr(0,6) == \"query:\") {\n\t\tfor (auto item : feed->items()) {\n\t\t\tif (!item->deleted()\n\t\t\t\t&& (item->title().find(query) != std::string::npos\n\t\t\t\t    || item->description().find(query) != std::string::npos))\n\t\t\t{\n\t\t\t\tstd::shared_ptr<rss_item> newitem(new rss_item(nullptr));\n\t\t\t\tnewitem->set_guid(item->guid());\n\t\t\t\tnewitem->set_title(item->title());\n\t\t\t\tnewitem->set_author(item->author());\n\t\t\t\tnewitem->set_link(item->link());\n\n\t\t\t\tnewitem->set_pubDate(item->pubDate_timestamp());\n\n\t\t\t\tnewitem->set_size(item->size());\n\t\t\t\tnewitem->set_unread(item->unread());\n\t\t\t\tnewitem->set_feedurl(item->feedurl());\n\n\t\t\t\tnewitem->set_enclosure_url(item->enclosure_url());\n\t\t\t\tnewitem->set_enclosure_type(item->enclosure_type());\n\t\t\t\tnewitem->set_enqueued(item->enqueued());\n\t\t\t\tnewitem->set_flags(item->flags());\n\t\t\t\tnewitem->set_base(item->get_base());\n\n\t\t\t\tnewitem->set_feedptr(item->get_feedptr());\n\t\t\t\tnewitem->set_cache(get_cache());\n\n\t\t\t\titems.push_back(newitem);\n\t\t\t}\n\t\t}\n\t} else {\n\t\titems = rsscache->search_for_items(query, (feed != nullptr ? feed->rssurl() : \"\"));\n\t\tfor (auto item : items) {\n\t\t\titem->set_feedptr(get_feed_by_url(item->feedurl()));\n\t\t}\n\t}\n\treturn items;\n}\n\nstd::shared_ptr<rss_feed> controller::get_feed_by_url(const std::string& feedurl) {\n\tfor (auto feed : feeds) {\n\t\tif (feedurl == feed->rssurl())\n\t\t\treturn feed;\n\t}\n\tLOG(level::ERROR, \"controller:get_feed_by_url failed for %s\", feedurl);\n\treturn std::shared_ptr<rss_feed>();\n}\n\nbool controller::is_valid_podcast_type(const std::string& /* mimetype */) {\n\treturn true;\n}\n\nvoid controller::enqueue_url(const std::string& url, std::shared_ptr<rss_feed> feed) {\n\tbool url_found = false;\n\tstd::fstream f;\n\tf.open(queue_file.c_str(), std::fstream::in);\n\tif (f.is_open()) {\n\t\tdo {\n\t\t\tstd::string line;\n\t\t\tgetline(f, line);\n\t\t\tif (!f.eof() && line.length() > 0) {\n\t\t\t\tstd::vector<std::string> fields = utils::tokenize_quoted(line);\n\t\t\t\tif (!fields.empty() && fields[0] == url) {\n\t\t\t\t\turl_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!f.eof());\n\t\tf.close();\n\t}\n\tif (!url_found) {\n\t\tf.open(queue_file.c_str(), std::fstream::app | std::fstream::out);\n\t\tstd::string filename = generate_enqueue_filename(url, feed);\n\t\tf << url << \" \" << stfl::quote(filename) << std::endl;\n\t\tf.close();\n\t}\n}\n\nvoid controller::reload_urls_file() {\n\turlcfg->reload();\n\tstd::vector<std::shared_ptr<rss_feed>> new_feeds;\n\tunsigned int i = 0;\n\n\tfor (auto url : urlcfg->get_urls()) {\n\t\tbool found = false;\n\t\tfor (auto feed : feeds) {\n\t\t\tif (url == feed->rssurl()) {\n\t\t\t\tfound = true;\n\t\t\t\tfeed->set_tags(urlcfg->get_tags(url));\n\t\t\t\tfeed->set_order(i);\n\t\t\t\tnew_feeds.push_back(feed);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\ttry {\n\t\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\t\tstd::shared_ptr<rss_feed> new_feed = rsscache->internalize_rssfeed(url, ignore_disp ? &ign : nullptr);\n\t\t\t\tnew_feed->set_tags(urlcfg->get_tags(url));\n\t\t\t\tnew_feed->set_order(i);\n\t\t\t\tnew_feeds.push_back(new_feed);\n\t\t\t} catch(const dbexception& e) {\n\t\t\t\tLOG(level::ERROR, \"controller::reload_urls_file: caught exception: %s\", e.what());\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tv->set_tags(urlcfg->get_alltags());\n\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tfeeds = new_feeds;\n\t}\n\n\tsort_feeds();\n\n\tupdate_feedlist();\n}\n\nvoid controller::edit_urls_file() {\n\tconst char * editor;\n\n\teditor = getenv(\"VISUAL\");\n\tif (!editor)\n\t\teditor = getenv(\"EDITOR\");\n\tif (!editor)\n\t\teditor = \"vi\";\n\n\tstd::string cmdline = strprintf::fmt(\"%s \\\"%s\\\"\", editor, utils::replace_all(url_file,\"\\\"\",\"\\\\\\\"\"));\n\n\tv->push_empty_formaction();\n\tstfl::reset();\n\n\tutils::run_interactively(cmdline, \"controller::edit_urls_file\");\n\n\tv->pop_current_formaction();\n\n\treload_urls_file();\n}\n\n/* When passing an argument to a shell script, empty string should be\n * represented as '' (two quote marks), otherwise shell won't be able to tell\n * that the parameter is empty */\nstd::string quote_empty(const std::string& input) {\n\tif (input.empty()) {\n\t\treturn \"''\";\n\t} else {\n\t\treturn input;\n\t}\n}\n\nstd::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}\n\nvoid controller::execute_commands(char ** argv, unsigned int i) {\n\tif (v->formaction_stack_size() > 0)\n\t\tv->pop_current_formaction();\n\tfor (; argv[i]; ++i) {\n\t\tLOG(level::DEBUG, \"controller::execute_commands: executing `%s'\", argv[i]);\n\t\tstd::string cmd(argv[i]);\n\t\tif (cmd == \"reload\") {\n\t\t\treload_all(true);\n\t\t} else if (cmd == \"print-unread\") {\n\t\t\tstd::cout << strprintf::fmt(_(\"%u unread articles\"), rsscache->get_unread_count()) << std::endl;\n\t\t} else {\n\t\t\tstd::cerr << strprintf::fmt(_(\"%s: %s: unknown command\"), argv[0], argv[i]) << std::endl;\n\t\t\t::std::exit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nstd::string controller::write_temporary_item(std::shared_ptr<rss_item> item) {\n\tchar filename[_POSIX_PATH_MAX];\n\tsnprintf(filename, sizeof(filename), \"/tmp/newsbeuter-article.XXXXXX\");\n\tint fd = mkstemp(filename);\n\tif (fd != -1) {\n\t\twrite_item(item, filename);\n\t\tclose(fd);\n\t\treturn std::string(filename);\n\t} else {\n\t\treturn \"\";\n\t}\n}\n\nvoid controller::write_item(std::shared_ptr<rss_item> item, const std::string& filename) {\n\tstd::fstream f;\n\tf.open(filename.c_str(),std::fstream::out);\n\tif (!f.is_open())\n\t\tthrow exception(errno);\n\n\twrite_item(item, f);\n}\n\nvoid controller::write_item(std::shared_ptr<rss_item> item, std::ostream& ostr) {\n\tstd::vector<std::pair<LineType, std::string>> lines;\n\tstd::vector<linkpair> links; // not used\n\n\tstd::string title(_(\"Title: \"));\n\ttitle.append(item->title());\n\tlines.push_back(std::make_pair(LineType::wrappable, title));\n\n\tstd::string author(_(\"Author: \"));\n\tauthor.append(item->author());\n\tlines.push_back(std::make_pair(LineType::wrappable, author));\n\n\tstd::string date(_(\"Date: \"));\n\tdate.append(item->pubDate());\n\tlines.push_back(std::make_pair(LineType::wrappable, date));\n\n\tstd::string link(_(\"Link: \"));\n\tlink.append(item->link());\n\tlines.push_back(std::make_pair(LineType::softwrappable, link));\n\n\tif (item->enclosure_url() != \"\") {\n\t\tstd::string dlurl(_(\"Podcast Download URL: \"));\n\t\tdlurl.append(item->enclosure_url());\n\t\tlines.push_back(std::make_pair(LineType::softwrappable, dlurl));\n\t}\n\n\tlines.push_back(std::make_pair(LineType::wrappable, std::string(\"\")));\n\n\thtmlrenderer rnd(true);\n\trnd.render(item->description(), lines, links, item->feedurl());\n\ttextformatter txtfmt;\n\ttxtfmt.add_lines(lines);\n\n\tunsigned int width = cfg.get_configvalue_as_int(\"text-width\");\n\tif (width == 0)\n\t\twidth = 80;\n\tostr << txtfmt.format_text_plain(width) << std::endl;\n}\n\nvoid controller::mark_deleted(const std::string& guid, bool b) {\n\trsscache->mark_item_deleted(guid, b);\n}\n\nstd::string controller::prepare_message(unsigned int pos, unsigned int max) {\n\tif (max > 0) {\n\t\treturn strprintf::fmt(\"(%u/%u) \", pos, max);\n\t}\n\treturn \"\";\n}\n\nvoid controller::save_feed(std::shared_ptr<rss_feed> feed, unsigned int pos) {\n\tif (!feed->is_empty()) {\n\t\tLOG(level::DEBUG, \"controller::save_feed: feed is nonempty, saving\");\n\t\trsscache->externalize_rssfeed(feed, ign.matches_resetunread(feed->rssurl()));\n\t\tLOG(level::DEBUG, \"controller::save_feed: after externalize_rssfeed\");\n\n\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\tfeed = rsscache->internalize_rssfeed(feed->rssurl(), ignore_disp ? &ign : nullptr);\n\t\tLOG(level::DEBUG, \"controller::save_feed: after internalize_rssfeed\");\n\t\tfeed->set_tags(urlcfg->get_tags(feed->rssurl()));\n\t\t{\n\t\t\tunsigned int order = feeds[pos]->get_order();\n\t\t\tstd::lock_guard<std::mutex> itemlock(feeds[pos]->item_mutex);\n\t\t\tfeeds[pos]->clear_items();\n\t\t\tfeed->set_order(order);\n\t\t}\n\t\tfeeds[pos] = feed;\n\t\tv->notify_itemlist_change(feeds[pos]);\n\t} else {\n\t\tLOG(level::DEBUG, \"controller::save_feed: feed is empty, not saving\");\n\t}\n}\n\nvoid controller::enqueue_items(std::shared_ptr<rss_feed> feed) {\n\tif (!cfg.get_configvalue_as_bool(\"podcast-auto-enqueue\"))\n\t\treturn;\n\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\tfor (auto item : feed->items()) {\n\t\tif (!item->enqueued() && item->enclosure_url().length() > 0) {\n\t\t\tLOG(level::DEBUG, \"controller::enqueue_items: enclosure_url = `%s' enclosure_type = `%s'\", item->enclosure_url(), item->enclosure_type());\n\t\t\tif (is_valid_podcast_type(item->enclosure_type()) && utils::is_http_url(item->enclosure_url())) {\n\t\t\t\tLOG(level::INFO, \"controller::enqueue_items: enqueuing `%s'\", item->enclosure_url());\n\t\t\t\tenqueue_url(item->enclosure_url(), feed);\n\t\t\t\titem->set_enqueued(true);\n\t\t\t\trsscache->update_rssitem_unread_and_enqueued(item, feed->rssurl());\n\t\t\t}\n\t\t}\n\t}\n}\n\nstd::string controller::generate_enqueue_filename(const std::string& url, std::shared_ptr<rss_feed> feed) {\n\tstd::string dlformat = cfg.get_configvalue(\"download-path\");\n\tif (dlformat[dlformat.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tdlformat.append(NEWSBEUTER_PATH_SEP);\n\n\tfmtstr_formatter fmt;\n\tfmt.register_fmt('n', feed->title());\n\tfmt.register_fmt('h', get_hostname_from_url(url));\n\n\tstd::string dlpath = fmt.do_format(dlformat);\n\n\tchar buf[2048];\n\tsnprintf(buf, sizeof(buf), \"%s\", url.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tdlpath.append(lbuf);\n\t} else {\n\t\tdlpath.append(base);\n\t}\n\treturn dlpath;\n}\n\nstd::string controller::get_hostname_from_url(const std::string& url) {\n\txmlURIPtr uri = xmlParseURI(url.c_str());\n\tstd::string hostname;\n\tif (uri) {\n\t\thostname = uri->server;\n\t\txmlFreeURI(uri);\n\t}\n\treturn hostname;\n}\n\nvoid controller::import_read_information(const std::string& readinfofile) {\n\tstd::vector<std::string> guids;\n\n\tstd::ifstream f(readinfofile.c_str());\n\tstd::string line;\n\tgetline(f,line);\n\tif (!f.is_open()) {\n\t\treturn;\n\t}\n\twhile (f.is_open() && !f.eof()) {\n\t\tguids.push_back(line);\n\t\tgetline(f, line);\n\t}\n\trsscache->mark_items_read_by_guid(guids);\n}\n\nvoid controller::export_read_information(const std::string& readinfofile) {\n\tstd::vector<std::string> guids = rsscache->get_read_item_guids();\n\n\tstd::fstream f;\n\tf.open(readinfofile.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto guid : guids) {\n\t\t\tf << guid << std::endl;\n\t\t}\n\t}\n}\n\nvoid controller::sort_feeds() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tstd::vector<std::string> sortmethod_info = utils::tokenize(cfg.get_configvalue(\"feed-sort-order\"), \"-\");\n\tstd::string sortmethod = sortmethod_info[0];\n\tstd::string direction = \"desc\";\n\tif (sortmethod_info.size() > 1)\n\t\tdirection = sortmethod_info[1];\n\tif (sortmethod == \"none\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->get_order() < b->get_order();\n\t\t});\n\t} else if (sortmethod == \"firsttag\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\tif (a->get_firsttag().length() == 0 || b->get_firsttag().length() == 0) {\n\t\t\t\treturn a->get_firsttag().length() > b->get_firsttag().length();\n\t\t\t}\n\t\t\treturn strcasecmp(a->get_firsttag().c_str(), b->get_firsttag().c_str()) < 0;\n\t\t});\n\t} else if (sortmethod == \"title\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn strcasecmp(a->title().c_str(), b->title().c_str()) < 0;\n\t\t});\n\t} else if (sortmethod == \"articlecount\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->total_item_count() < b->total_item_count();\n\t\t});\n\t} else if (sortmethod == \"unreadarticlecount\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->unread_item_count() < b->unread_item_count();\n\t\t});\n\t}\n\tif (direction == \"asc\") {\n\t\tstd::reverse(feeds.begin(), feeds.end());\n\t}\n}\n\nvoid controller::update_config() {\n\tv->set_regexmanager(&rxman);\n\tv->update_bindings();\n\n\tif (colorman.colors_loaded()) {\n\t\tv->set_colors(colorman.get_fgcolors(), colorman.get_bgcolors(), colorman.get_attributes());\n\t\tv->apply_colors_to_all_formactions();\n\t}\n\n\tif (cfg.get_configvalue(\"error-log\").length() > 0) {\n\t\tlogger::getInstance().set_errorlogfile(cfg.get_configvalue(\"error-log\"));\n\t}\n\n}\n\nvoid controller::load_configfile(const std::string& filename) {\n\tif (cfgparser.parse(filename, true)) {\n\t\tupdate_config();\n\t} else {\n\t\tv->show_error(strprintf::fmt(_(\"Error: couldn't open configuration file `%s'!\"), filename));\n\t}\n}\n\nvoid controller::dump_config(const std::string& filename) {\n\tstd::vector<std::string> configlines;\n\tcfg.dump_config(configlines);\n\tif (v) {\n\t\tv->get_keys()->dump_config(configlines);\n\t}\n\tign.dump_config(configlines);\n\tfilters.dump_config(configlines);\n\tcolorman.dump_config(configlines);\n\trxman.dump_config(configlines);\n\tstd::fstream f;\n\tf.open(filename.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto line : configlines) {\n\t\t\tf << line << std::endl;\n\t\t}\n\t}\n}\n\nunsigned int controller::get_pos_of_next_unread(unsigned int pos) {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (pos++; pos < feeds.size(); pos++) {\n\t\tif (feeds[pos]->unread_item_count() > 0)\n\t\t\tbreak;\n\t}\n\treturn pos;\n}\n\nvoid controller::update_flags(std::shared_ptr<rss_item> item) {\n\tif (api) {\n\t\tapi->update_article_flags(item->oldflags(), item->flags(), item->guid());\n\t}\n\titem->update_flags();\n}\n\nstd::vector<std::shared_ptr<rss_feed>> controller::get_all_feeds() {\n\tstd::vector<std::shared_ptr<rss_feed>> tmpfeeds;\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\ttmpfeeds = feeds;\n\t}\n\treturn tmpfeeds;\n}\n\nstd::vector<std::shared_ptr<rss_feed>> controller::get_all_feeds_unlocked() {\n\treturn feeds;\n}\n\n\nunsigned int controller::get_feed_count_per_tag(const std::string& tag) {\n\tunsigned int count = 0;\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\n\tfor (auto feed : feeds) {\n\t\tif (feed->matches_tag(tag)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n}\n"], "fixing_code": ["#include <config.h>\n#include <view.h>\n#include <controller.h>\n#include <configparser.h>\n#include <configcontainer.h>\n#include <exceptions.h>\n#include <downloadthread.h>\n#include <colormanager.h>\n#include <logger.h>\n#include <utils.h>\n#include <strprintf.h>\n#include <stflpp.h>\n#include <exception.h>\n#include <formatstring.h>\n#include <regexmanager.h>\n#include <rss_parser.h>\n#include <remote_api.h>\n#include <oldreader_api.h>\n#include <feedhq_api.h>\n#include <ttrss_api.h>\n#include <newsblur_api.h>\n#include <ocnews_api.h>\n#include <xlicense.h>\n\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <fstream>\n#include <cerrno>\n#include <algorithm>\n#include <functional>\n#include <mutex>\n\n#include <sys/time.h>\n#include <ctime>\n#include <cassert>\n#include <signal.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <sys/utsname.h>\n#include <langinfo.h>\n#include <libgen.h>\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pwd.h>\n\n#include <ncurses.h>\n\n#include <libxml/xmlversion.h>\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <libxml/xmlsave.h>\n#include <libxml/uri.h>\n#include <curl/curl.h>\n\nnamespace newsbeuter {\n\n#define LOCK_SUFFIX \".lock\"\n\nstd::string lock_file;\n\nint ctrl_c_hit = 0;\n\nvoid ctrl_c_action(int sig) {\n\tLOG(level::DEBUG,\"caught signal %d\",sig);\n\tif (SIGINT == sig) {\n\t\tctrl_c_hit = 1;\n\t} else {\n\t\tstfl::reset();\n\t\tutils::remove_fs_lock(lock_file);\n\t\t::exit(EXIT_FAILURE);\n\t}\n}\n\nvoid ignore_signal(int sig) {\n\tLOG(level::WARN, \"caught signal %d but ignored it\", sig);\n}\n\nvoid omg_a_child_died(int /* sig */) {\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1,&stat,WNOHANG)) > 0) { }\n\t::signal(SIGCHLD, omg_a_child_died); /* in case of unreliable signals */\n}\n\ncontroller::controller() : v(0), urlcfg(0), rsscache(0), url_file(\"urls\"), cache_file(\"cache.db\"), config_file(\"config\"), queue_file(\"queue\"), refresh_on_start(false), api(0) {\n}\n\n\n/**\n * \\brief Try to setup XDG style dirs.\n *\n * returns false, if that fails\n */\nbool controller::setup_dirs_xdg(const char *env_home, bool silent) {\n\tconst char *env_xdg_config;\n\tconst char *env_xdg_data;\n\tstd::string xdg_config_dir;\n\tstd::string xdg_data_dir;\n\n\tenv_xdg_config = ::getenv(\"XDG_CONFIG_HOME\");\n\tif (env_xdg_config) {\n\t\txdg_config_dir = env_xdg_config;\n\t} else {\n\t\txdg_config_dir = env_home;\n\t\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_config_dir.append(\".config\");\n\t}\n\n\tenv_xdg_data = ::getenv(\"XDG_DATA_HOME\");\n\tif (env_xdg_data) {\n\t\txdg_data_dir = env_xdg_data;\n\t} else {\n\t\txdg_data_dir = env_home;\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\".local\");\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\"share\");\n\t}\n\n\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_config_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_data_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\tbool config_dir_exists = 0 == access(xdg_config_dir.c_str(), R_OK | X_OK);\n\n\tif (!config_dir_exists) {\n\t\tif (!silent) {\n\t\t\tstd::cerr\n\t\t\t\t<< strprintf::fmt(\n\t\t\t\t\t   _(\"XDG: configuration directory '%s' not accessible, \"\n\t\t\t\t\t\t \"using '%s' instead.\"),\n\t\t\t\t\t   xdg_config_dir,\n\t\t\t\t\t   config_dir)\n\t\t\t\t<< std::endl;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/* Invariant: config dir exists.\n\t *\n\t * At this point, we're confident we'll be using XDG. We don't check if\n\t * data dir exists, because if it doesn't we'll create it. */\n\n\tconfig_dir = xdg_config_dir;\n\n\t// create data directory if it doesn't exist\n\tutils::mkdir_parents(xdg_data_dir, 0700);\n\n\t/* in config */\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\n\t/* in data */\n\tcache_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tqueue_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tsearchfile = strprintf::fmt(\"%s%shistory.search\", xdg_data_dir, NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = strprintf::fmt(\"%s%shistory.cmdline\", xdg_data_dir, NEWSBEUTER_PATH_SEP);\n\n\treturn true;\n}\n\nvoid controller::setup_dirs(bool silent) {\n\tconst char * env_home;\n\tif (!(env_home = ::getenv(\"HOME\"))) {\n\t\tstruct passwd * spw = ::getpwuid(::getuid());\n\t\tif (spw) {\n\t\t\tenv_home = spw->pw_dir;\n\t\t} else {\n\t\t\tstd::cerr << _(\"Fatal error: couldn't determine home directory!\") << std::endl;\n\t\t\tstd::cerr << strprintf::fmt(_(\"Please set the HOME environment variable or add a valid user for UID %u!\"), ::getuid()) << std::endl;\n\t\t\t::exit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tconfig_dir = env_home;\n\tconfig_dir.append(NEWSBEUTER_PATH_SEP);\n\tconfig_dir.append(NEWSBEUTER_CONFIG_SUBDIR);\n\n\tif (setup_dirs_xdg(env_home, silent))\n\t\treturn;\n\n\tmkdir(config_dir.c_str(),0700); // create configuration directory if it doesn't exist\n\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tcache_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\tqueue_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\n\tsearchfile = strprintf::fmt(\"%s%shistory.search\", config_dir, NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = strprintf::fmt(\"%s%shistory.cmdline\", config_dir, NEWSBEUTER_PATH_SEP);\n}\n\ncontroller::~controller() {\n\tdelete rsscache;\n\tdelete urlcfg;\n\tdelete api;\n\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (auto feed : feeds) {\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\t\tfeed->clear_items();\n\t}\n\tfeeds.clear();\n}\n\nvoid controller::set_view(view * vv) {\n\tv = vv;\n}\n\nvoid controller::run(int argc, char * argv[]) {\n\tint c;\n\n\t::signal(SIGINT, ctrl_c_action);\n\t::signal(SIGPIPE, ignore_signal);\n\t::signal(SIGHUP, ctrl_c_action);\n\t::signal(SIGCHLD, omg_a_child_died);\n\n\tbool do_import = false, do_export = false, cachefile_given_on_cmdline = false, do_vacuum = false;\n\tstd::string importfile;\n\tbool do_read_import = false, do_read_export = false;\n\tstd::string readinfofile;\n\tunsigned int show_version = 0;\n\n\tbool silent = false;\n\tbool execute_cmds = false;\n\n\tstatic const char getopt_str[] = \"i:erhqu:c:C:d:l:vVoxXI:E:\";\n\tstatic const struct option longopts[] = {\n\t\t{\"cache-file\"      , required_argument, 0, 'c'},\n\t\t{\"config-file\"     , required_argument, 0, 'C'},\n\t\t{\"execute\"         , required_argument, 0, 'x'},\n\t\t{\"export-to-file\"  , required_argument, 0, 'E'},\n\t\t{\"export-to-opml\"  , no_argument      , 0, 'e'},\n\t\t{\"help\"            , no_argument      , 0, 'h'},\n\t\t{\"import-from-file\", required_argument, 0, 'I'},\n\t\t{\"import-from-opml\", required_argument, 0, 'i'},\n\t\t{\"log-file\"        , required_argument, 0, 'd'},\n\t\t{\"log-level\"       , required_argument, 0, 'l'},\n\t\t{\"quiet\"           , no_argument      , 0, 'q'},\n\t\t{\"refresh-on-start\", no_argument      , 0, 'r'},\n\t\t{\"url-file\"        , required_argument, 0, 'u'},\n\t\t{\"vacuum\"          , no_argument      , 0, 'X'},\n\t\t{\"version\"         , no_argument      , 0, 'v'},\n\t\t{0                 , 0                , 0,  0 }\n\t};\n\n\t/* First of all, let's check for options that imply silencing of the\n\t * output: import, export, command execution and, well, quiet mode */\n\twhile ((c = ::getopt_long(argc, argv, getopt_str, longopts, nullptr)) != -1) {\n\t\tif (strchr(\"iexq\", c) != nullptr) {\n\t\t\tsilent = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsetup_dirs(silent);\n\n\t/* Now that silencing's set up, let's rewind to the beginning of argv and\n\t * process the options */\n\toptind = 1;\n\n\twhile ((c = ::getopt_long(argc, argv, getopt_str, longopts, nullptr)) != -1) {\n\t\tswitch (c) {\n\t\tcase ':': /* fall-through */\n\t\tcase '?': /* missing option */\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (do_export)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_import = true;\n\t\t\timportfile = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trefresh_on_start = true;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (do_import)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_export = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\turl_file = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcache_file = optarg;\n\t\t\tlock_file = std::string(cache_file) + LOCK_SUFFIX;\n\t\t\tcachefile_given_on_cmdline = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfig_file = optarg;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tdo_vacuum = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\tcase 'V':\n\t\t\tshow_version++;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\texecute_cmds = true;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tlogger::getInstance().set_logfile(optarg);\n\t\t\tbreak;\n\t\tcase 'l': {\n\t\t\tlevel l = static_cast<level>(atoi(optarg));\n\t\t\tif (l > level::NONE && l <= level::DEBUG) {\n\t\t\t\tlogger::getInstance().set_loglevel(l);\n\t\t\t} else {\n\t\t\t\tstd::cerr << strprintf::fmt(_(\"%s: %d: invalid loglevel value\"), argv[0], l) << std::endl;\n\t\t\t\t::std::exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (do_read_export)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_read_import = true;\n\t\t\treadinfofile = optarg;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tif (do_read_import)\n\t\t\t\tusage(argv[0]);\n\t\t\tdo_read_export = true;\n\t\t\treadinfofile = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << strprintf::fmt(_(\"%s: unknown option - %c\"), argv[0], static_cast<char>(c)) << std::endl;\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\n\tif (show_version) {\n\t\tversion_information(argv[0], show_version);\n\t}\n\n\tif (do_import) {\n\t\tLOG(level::INFO,\"Importing OPML file from %s\",importfile);\n\t\turlcfg = new file_urlreader(url_file);\n\t\turlcfg->reload();\n\t\timport_opml(importfile);\n\t\treturn;\n\t}\n\n\n\tLOG(level::INFO, \"nl_langinfo(CODESET): %s\", nl_langinfo(CODESET));\n\n\tif (!do_export) {\n\n\t\tif (!silent)\n\t\t\tstd::cout << strprintf::fmt(_(\"Starting %s %s...\"), PROGRAM_NAME, PROGRAM_VERSION) << std::endl;\n\n\t\tpid_t pid;\n\t\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\t\tif (pid > 0) {\n\t\t\t\tLOG(level::ERROR,\"an instance is already running: pid = %u\",pid);\n\t\t\t} else {\n\t\t\t\tLOG(level::ERROR,\"something went wrong with the lock: %s\", strerror(errno));\n\t\t\t}\n\t\t\tif (!execute_cmds) {\n\t\t\t\tstd::cout << strprintf::fmt(_(\"Error: an instance of %s is already running (PID: %u)\"), PROGRAM_NAME, pid) << std::endl;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!silent)\n\t\tstd::cout << _(\"Loading configuration...\");\n\tstd::cout.flush();\n\n\tcfg.register_commands(cfgparser);\n\tcolorman.register_commands(cfgparser);\n\n\tkeymap keys(KM_NEWSBEUTER);\n\tcfgparser.register_handler(\"bind-key\",&keys);\n\tcfgparser.register_handler(\"unbind-key\",&keys);\n\tcfgparser.register_handler(\"macro\", &keys);\n\n\tcfgparser.register_handler(\"ignore-article\",&ign);\n\tcfgparser.register_handler(\"always-download\",&ign);\n\tcfgparser.register_handler(\"reset-unread-on-update\",&ign);\n\n\tcfgparser.register_handler(\"define-filter\",&filters);\n\tcfgparser.register_handler(\"highlight\", &rxman);\n\tcfgparser.register_handler(\"highlight-article\", &rxman);\n\n\ttry {\n\t\tcfgparser.parse(\"/etc/\" PROGRAM_NAME \"/config\");\n\t\tcfgparser.parse(config_file);\n\t} catch (const configexception& ex) {\n\t\tLOG(level::ERROR,\"an exception occurred while parsing the configuration file: %s\",ex.what());\n\t\tstd::cout << ex.what() << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tupdate_config();\n\n\tif (!silent)\n\t\tstd::cout << _(\"done.\") << std::endl;\n\n\t// create cache object\n\tstd::string cachefilepath = cfg.get_configvalue(\"cache-file\");\n\tif (cachefilepath.length() > 0 && !cachefile_given_on_cmdline) {\n\t\tcache_file = cachefilepath.c_str();\n\n\t\t// ok, we got another cache file path via the configuration\n\t\t// that means we need to remove the old lock file, assemble\n\t\t// the new lock file's name, and then try to lock it.\n\t\tutils::remove_fs_lock(lock_file);\n\t\tlock_file = std::string(cache_file) + LOCK_SUFFIX;\n\n\t\tpid_t pid;\n\t\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\t\tif (pid > 0) {\n\t\t\t\tLOG(level::ERROR,\"an instance is already running: pid = %u\",pid);\n\t\t\t} else {\n\t\t\t\tLOG(level::ERROR,\"something went wrong with the lock: %s\", strerror(errno));\n\t\t\t}\n\t\t\tstd::cout << strprintf::fmt(_(\"Error: an instance of %s is already running (PID: %u)\"), PROGRAM_NAME, pid) << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!silent) {\n\t\tstd::cout << _(\"Opening cache...\");\n\t\tstd::cout.flush();\n\t}\n\ttry {\n\t\trsscache = new cache(cache_file,&cfg);\n\t} catch (const dbexception& e) {\n\t\tstd::cerr << strprintf::fmt(_(\"Error: opening the cache file `%s' failed: %s\"), cache_file, e.what()) << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\t::exit(EXIT_FAILURE);\n\t}\n\n\tif (!silent) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\n\n\tstd::string type = cfg.get_configvalue(\"urls-source\");\n\tif (type == \"local\") {\n\t\turlcfg = new file_urlreader(url_file);\n\t} else if (type == \"opml\") {\n\t\turlcfg = new opml_urlreader(&cfg);\n\t} else if (type == \"oldreader\") {\n\t\tapi = new oldreader_api(&cfg);\n\t\turlcfg = new oldreader_urlreader(&cfg, url_file, api);\n\t} else if (type == \"ttrss\") {\n\t\tapi = new ttrss_api(&cfg);\n\t\turlcfg = new ttrss_urlreader(url_file, api);\n\t} else if (type == \"newsblur\") {\n\t\tapi = new newsblur_api(&cfg);\n\t\turlcfg = new newsblur_urlreader(url_file, api);\n\t} else if (type == \"feedhq\") {\n\t\tapi = new feedhq_api(&cfg);\n\t\turlcfg = new feedhq_urlreader(&cfg, url_file, api);\n\t} else if (type == \"ocnews\") {\n\t\tapi = new ocnews_api(&cfg);\n\t\turlcfg = new ocnews_urlreader(url_file, api);\n\t} else {\n\t\tLOG(level::ERROR,\"unknown urls-source `%s'\", urlcfg->get_source());\n\t}\n\n\tif (!do_export && !silent) {\n\t\tstd::cout << strprintf::fmt(_(\"Loading URLs from %s...\"), urlcfg->get_source());\n\t\tstd::cout.flush();\n\t}\n\tif (api) {\n\t\tif (!api->authenticate()) {\n\t\t\tstd::cout << \"Authentication failed.\" << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t}\n\t}\n\turlcfg->reload();\n\tif (!do_export && !silent) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\tif (urlcfg->get_urls().size() == 0) {\n\t\tLOG(level::ERROR,\"no URLs configured.\");\n\t\tstd::string msg;\n\t\tif (type == \"local\") {\n\t\t\tmsg = strprintf::fmt(_(\"Error: no URLs configured. Please fill the file %s with RSS feed URLs or import an OPML file.\"), url_file);\n\t\t} else if (type == \"opml\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like the OPML feed you subscribed contains no feeds. Please fill it with feeds, and try again.\"));\n\t\t} else if (type == \"oldreader\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your The Old Reader account. Please do so, and try again.\"));\n\t\t} else if (type == \"ttrss\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your Tiny Tiny RSS account. Please do so, and try again.\"));\n\t\t} else if (type == \"newsblur\") {\n\t\t\tmsg = strprintf::fmt(_(\"It looks like you haven't configured any feeds in your NewsBlur account. Please do so, and try again.\"));\n\t\t} else {\n\t\t\tassert(0); // shouldn't happen\n\t\t}\n\t\tstd::cout << msg << std::endl << std::endl;\n\t\tusage(argv[0]);\n\t}\n\n\tif (!do_export && !do_vacuum && !silent)\n\t\tstd::cout << _(\"Loading articles from cache...\");\n\tif (do_vacuum)\n\t\tstd::cout << _(\"Opening cache...\");\n\tstd::cout.flush();\n\n\n\tif (do_vacuum) {\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\tstd::cout << _(\"Cleaning up cache thoroughly...\");\n\t\tstd::cout.flush();\n\t\trsscache->do_vacuum();\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tunsigned int i=0;\n\tfor (auto url : urlcfg->get_urls()) {\n\t\ttry {\n\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\tstd::shared_ptr<rss_feed> feed = rsscache->internalize_rssfeed(url, ignore_disp ? &ign : nullptr);\n\t\t\tfeed->set_tags(urlcfg->get_tags(url));\n\t\t\tfeed->set_order(i);\n\t\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\t\tfeeds.push_back(feed);\n\t\t} catch(const dbexception& e) {\n\t\t\tstd::cout << _(\"Error while loading feeds from database: \") << e.what() << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t} catch(const std::string& str) {\n\t\t\tstd::cout << strprintf::fmt(_(\"Error while loading feed '%s': %s\"), url, str) << std::endl;\n\t\t\tutils::remove_fs_lock(lock_file);\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n\n\tstd::vector<std::string> tags = urlcfg->get_alltags();\n\n\tif (!do_export && !silent)\n\t\tstd::cout << _(\"done.\") << std::endl;\n\n\t// if configured, we fill all query feeds with some data; no need to sort it, it will be refilled when actually opening it.\n\tif (cfg.get_configvalue_as_bool(\"prepopulate-query-feeds\")) {\n\t\tstd::cout << _(\"Prepopulating query feeds...\");\n\t\tstd::cout.flush();\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tfor (auto feed : feeds) {\n\t\t\tif (feed->rssurl().substr(0,6) == \"query:\") {\n\t\t\t\tfeed->update_items(get_all_feeds_unlocked());\n\t\t\t}\n\t\t}\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t}\n\n\tsort_feeds();\n\n\tif (do_export) {\n\t\texport_opml();\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\tif (do_read_import) {\n\t\tLOG(level::INFO,\"Importing read information file from %s\",readinfofile);\n\t\tstd::cout << _(\"Importing list of read articles...\");\n\t\tstd::cout.flush();\n\t\timport_read_information(readinfofile);\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\treturn;\n\t}\n\n\tif (do_read_export) {\n\t\tLOG(level::INFO,\"Exporting read information file to %s\",readinfofile);\n\t\tstd::cout << _(\"Exporting list of read articles...\");\n\t\tstd::cout.flush();\n\t\texport_read_information(readinfofile);\n\t\tstd::cout << _(\"done.\") << std::endl;\n\t\treturn;\n\t}\n\n\t// hand over the important objects to the view\n\tv->set_config_container(&cfg);\n\tv->set_keymap(&keys);\n\tv->set_tags(tags);\n\n\tif (execute_cmds) {\n\t\texecute_commands(argv, optind);\n\t\tutils::remove_fs_lock(lock_file);\n\t\treturn;\n\t}\n\n\t// if the user wants to refresh on startup via configuration file, then do so,\n\t// but only if -r hasn't been supplied.\n\tif (!refresh_on_start && cfg.get_configvalue_as_bool(\"refresh-on-startup\")) {\n\t\trefresh_on_start = true;\n\t}\n\n\tformaction::load_histories(searchfile, cmdlinefile);\n\n\t// run the view\n\tv->run();\n\n\tunsigned int history_limit = cfg.get_configvalue_as_int(\"history-limit\");\n\tLOG(level::DEBUG, \"controller::run: history-limit = %u\", history_limit);\n\tformaction::save_histories(searchfile, cmdlinefile, history_limit);\n\n\tif (!silent) {\n\t\tstd::cout << _(\"Cleaning up cache...\");\n\t\tstd::cout.flush();\n\t}\n\ttry {\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\trsscache->cleanup_cache(feeds);\n\t\tif (!silent) {\n\t\t\tstd::cout << _(\"done.\") << std::endl;\n\t\t}\n\t} catch (const dbexception& e) {\n\t\tLOG(level::USERERROR, \"Cleaning up cache failed: %s\", e.what());\n\t\tif (!silent) {\n\t\t\tstd::cout << _(\"failed: \") << e.what() << std::endl;\n\t\t}\n\t}\n\n\tutils::remove_fs_lock(lock_file);\n}\n\nvoid controller::update_feedlist() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tv->set_feedlist(feeds);\n}\n\nvoid controller::update_visible_feeds() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tv->update_visible_feeds(feeds);\n}\n\nvoid controller::mark_all_read(const std::string& feedurl) {\n\ttry {\n\t\trsscache->mark_all_read(feedurl);\n\t} catch (const dbexception& e) {\n\t\tv->show_error(strprintf::fmt(_(\"Error: couldn't mark all feeds read: %s\"), e.what()));\n\t\treturn;\n\t}\n\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (const auto& feed : feeds) {\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\n\t\tif (feedurl.length() > 0 && feed->rssurl() != feedurl)\n\t\t\tcontinue;\n\n\t\tif (feed->total_item_count() > 0) {\n\t\t\tif (api) {\n\t\t\t\tapi->mark_all_read(feed->rssurl());\n\t\t\t}\n\t\t\tfor (auto item : feed->items()) {\n\t\t\t\titem->set_unread_nowrite(false);\n\t\t\t}\n\t\t}\n\n\t\t// no point in going on - there is only one feed with a given URL\n\t\tif (feedurl.length() > 0) break;\n\t}\n}\n\nvoid controller::mark_article_read(const std::string& guid, bool read) {\n\tif (api) {\n\t\tapi->mark_article_read(guid, read);\n\t}\n}\n\nvoid controller::mark_all_read(unsigned int pos) {\n\tif (pos < feeds.size()) {\n\t\tscope_measure m(\"controller::mark_all_read\");\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tstd::shared_ptr<rss_feed> feed = feeds[pos];\n\t\tif (feed->rssurl().substr(0,6) == \"query:\") {\n\t\t\trsscache->mark_all_read(feed);\n\t\t} else {\n\t\t\trsscache->mark_all_read(feed->rssurl());\n\t\t\tif (api) {\n\t\t\t\tapi->mark_all_read(feed->rssurl());\n\t\t\t}\n\t\t}\n\t\tm.stopover(\"after rsscache->mark_all_read, before iteration over items\");\n\t\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\t\tstd::vector<std::shared_ptr<rss_item>>& items = feed->items();\n\t\tif (items.size() > 0) {\n\t\t\tbool notify = items[0]->feedurl() != feed->rssurl();\n\t\t\tLOG(level::DEBUG, \"controller::mark_all_read: notify = %s\", notify ? \"yes\" : \"no\");\n\t\t\tfor (auto item : items) {\n\t\t\t\titem->set_unread_nowrite_notify(false, notify);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid controller::reload(unsigned int pos, unsigned int max, bool unattended, curl_handle *easyhandle) {\n\tLOG(level::DEBUG, \"controller::reload: pos = %u max = %u\", pos, max);\n\tif (pos < feeds.size()) {\n\t\tstd::shared_ptr<rss_feed> oldfeed = feeds[pos];\n\t\tstd::string errmsg;\n\t\tif (!unattended)\n\t\t\tv->set_status(strprintf::fmt(_(\"%sLoading %s...\"), prepare_message(pos+1, max), utils::censor_url(oldfeed->rssurl())));\n\n\t\tbool ignore_dl = (cfg.get_configvalue(\"ignore-mode\") == \"download\");\n\n\t\trss_parser parser(oldfeed->rssurl(), rsscache, &cfg, ignore_dl ? &ign : nullptr, api);\n\t\tparser.set_easyhandle(easyhandle);\n\t\tLOG(level::DEBUG, \"controller::reload: created parser\");\n\t\ttry {\n\t\t\toldfeed->set_status(dl_status::DURING_DOWNLOAD);\n\t\t\tstd::shared_ptr<rss_feed> newfeed = parser.parse();\n\t\t\tif (newfeed->total_item_count() > 0) {\n\t\t\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\t\t\tsave_feed(newfeed, pos);\n\n\t\t\t\tnewfeed->clear_items();\n\n\t\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\t\tstd::shared_ptr<rss_feed> feed = rsscache->internalize_rssfeed(oldfeed->rssurl(), ignore_disp ? &ign : nullptr);\n\t\t\t\tfeed->set_tags(urlcfg->get_tags(oldfeed->rssurl()));\n\t\t\t\tfeed->set_order(oldfeed->get_order());\n\t\t\t\tfeeds[pos] = feed;\n\t\t\t\tenqueue_items(feed);\n\n\t\t\t\toldfeed->clear_items();\n\n\t\t\t\tv->notify_itemlist_change(feeds[pos]);\n\t\t\t\tif (!unattended) {\n\t\t\t\t\tv->set_feedlist(feeds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG(level::DEBUG, \"controller::reload: feed is empty\");\n\t\t\t}\n\t\t\toldfeed->set_status(dl_status::SUCCESS);\n\t\t\tv->set_status(\"\");\n\t\t} catch (const dbexception& e) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), e.what());\n\t\t} catch (const std::string& emsg) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), emsg);\n\t\t} catch (rsspp::exception& e) {\n\t\t\terrmsg = strprintf::fmt(_(\"Error while retrieving %s: %s\"), utils::censor_url(oldfeed->rssurl()), e.what());\n\t\t}\n\t\tif (errmsg != \"\") {\n\t\t\toldfeed->set_status(dl_status::DL_ERROR);\n\t\t\tv->set_status(errmsg);\n\t\t\tLOG(level::USERERROR, \"%s\", errmsg);\n\t\t}\n\t} else {\n\t\tv->show_error(_(\"Error: invalid feed!\"));\n\t}\n}\n\nstd::shared_ptr<rss_feed> controller::get_feed(unsigned int pos) {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tif (pos >= feeds.size()) {\n\t\tthrow std::out_of_range(_(\"invalid feed index (bug)\"));\n\t}\n\tstd::shared_ptr<rss_feed> feed = feeds[pos];\n\treturn feed;\n}\n\nvoid controller::reload_indexes(const std::vector<int>& indexes, bool unattended) {\n\tscope_measure m1(\"controller::reload_indexes\");\n\tunsigned int unread_feeds, unread_articles;\n\tcompute_unread_numbers(unread_feeds, unread_articles);\n\n\tunsigned long size;\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tsize = feeds.size();\n\t}\n\n\tfor (auto idx : indexes) {\n\t\tthis->reload(idx, size, unattended);\n\t}\n\n\tunsigned int unread_feeds2, unread_articles2;\n\tcompute_unread_numbers(unread_feeds2, unread_articles2);\n\tbool notify_always = cfg.get_configvalue_as_bool(\"notify-always\");\n\tif (notify_always || unread_feeds2 != unread_feeds || unread_articles2 != unread_articles) {\n\t\tfmtstr_formatter fmt;\n\t\tfmt.register_fmt('f', std::to_string(unread_feeds2));\n\t\tfmt.register_fmt('n', std::to_string(unread_articles2));\n\t\tfmt.register_fmt('d', std::to_string(unread_articles2 - unread_articles));\n\t\tfmt.register_fmt('D', std::to_string(unread_feeds2 - unread_feeds));\n\t\tthis->notify(fmt.do_format(cfg.get_configvalue(\"notify-format\")));\n\t}\n\tif (!unattended)\n\t\tv->set_status(\"\");\n}\n\nvoid controller::reload_range(unsigned int start, unsigned int end, unsigned int size, bool unattended) {\n\n\tstd::vector<unsigned int> v;\n\tfor (unsigned int i=start; i<=end; ++i)\n\t\tv.push_back(i);\n\n\tauto extract = [](std::string& s, const std::string& url) {\n\t\tsize_t p = url.find(\"//\");\n\t\tp = (p == std::string::npos) ? 0 : p+2;\n\t\tstd::string suff(url.substr(p));\n\t\tp = suff.find('/');\n\t\ts = suff.substr(0, p);\n\t};\n\n\tstd::sort(v.begin(), v.end(), [&](unsigned int a, unsigned int b) {\n\t\tstd::string domain1, domain2;\n\t\textract(domain1, feeds[a]->rssurl());\n\t\textract(domain2, feeds[b]->rssurl());\n\t\tstd::reverse(domain1.begin(), domain1.end());\n\t\tstd::reverse(domain2.begin(), domain2.end());\n\t\treturn domain1 < domain2;\n\t});\n\n\tcurl_handle easyhandle;\n\n\tfor (auto i : v) {\n\t\tLOG(level::DEBUG, \"controller::reload_range: reloading feed #%u\", i);\n\t\tthis->reload(i, size, unattended, &easyhandle);\n\t}\n}\n\nvoid controller::reload_all(bool unattended) {\n\tunsigned int unread_feeds, unread_articles;\n\tcompute_unread_numbers(unread_feeds, unread_articles);\n\tunsigned int num_threads = cfg.get_configvalue_as_int(\"reload-threads\");\n\ttime_t t1, t2, dt;\n\n\tunsigned int size;\n\n\t{\n\t\tstd::lock_guard<std::mutex> feedlock(feeds_mutex);\n\t\tfor (auto feed : feeds) {\n\t\t\tfeed->reset_status();\n\t\t}\n\t\tsize = feeds.size();\n\t}\n\n\tif (num_threads < 1)\n\t\tnum_threads = 1;\n\n\tif (num_threads > size) {\n\t\tnum_threads = size;\n\t}\n\n\n\tt1 = time(nullptr);\n\n\tLOG(level::DEBUG,\"controller::reload_all: starting with reload all...\");\n\tif (num_threads <= 1) {\n\t\tthis->reload_range(0, size-1, size, unattended);\n\t} else {\n\t\tstd::vector<std::pair<unsigned int, unsigned int>> partitions = utils::partition_indexes(0, size-1, num_threads);\n\t\tstd::vector<std::thread> threads;\n\t\tLOG(level::DEBUG, \"controller::reload_all: starting reload threads...\");\n\t\tfor (unsigned int i=0; i<num_threads-1; i++) {\n\t\t\tthreads.push_back(std::thread(reloadrangethread(this, partitions[i].first, partitions[i].second, size, unattended)));\n\t\t}\n\t\tLOG(level::DEBUG, \"controller::reload_all: starting my own reload...\");\n\t\tthis->reload_range(partitions[num_threads-1].first, partitions[num_threads-1].second, size, unattended);\n\t\tLOG(level::DEBUG, \"controller::reload_all: joining other threads...\");\n\t\tfor (size_t i=0; i<threads.size(); i++) {\n\t\t\tthreads[i].join();\n\t\t}\n\t}\n\n\t// refresh query feeds (update and sort)\n\tLOG(level::DEBUG, \"controller::reload_all: refresh query feeds\");\n\tfor (auto feed : feeds) {\n\t\tv->prepare_query_feed(feed);\n\t}\n\tv->force_redraw();\n\n\tsort_feeds();\n\tupdate_feedlist();\n\n\tt2 = time(nullptr);\n\tdt = t2 - t1;\n\tLOG(level::INFO, \"controller::reload_all: reload took %d seconds\", dt);\n\n\tunsigned int unread_feeds2, unread_articles2;\n\tcompute_unread_numbers(unread_feeds2, unread_articles2);\n\tbool notify_always = cfg.get_configvalue_as_bool(\"notify-always\");\n\tif (notify_always || unread_feeds2 > unread_feeds || unread_articles2 > unread_articles) {\n\t\tint article_count = unread_articles2 - unread_articles;\n\t\tint feed_count = unread_feeds2 - unread_feeds;\n\n\t\tLOG(level::DEBUG, \"unread article count: %d\", article_count);\n\t\tLOG(level::DEBUG, \"unread feed count: %d\", feed_count);\n\n\t\tfmtstr_formatter fmt;\n\t\tfmt.register_fmt('f', std::to_string(unread_feeds2));\n\t\tfmt.register_fmt('n', std::to_string(unread_articles2));\n\t\tfmt.register_fmt('d', std::to_string(article_count >= 0 ? article_count : 0));\n\t\tfmt.register_fmt('D', std::to_string(feed_count >= 0 ? feed_count : 0));\n\t\tthis->notify(fmt.do_format(cfg.get_configvalue(\"notify-format\")));\n\t}\n}\n\nvoid controller::notify(const std::string& msg) {\n\tif (cfg.get_configvalue_as_bool(\"notify-screen\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying screen\");\n\t\tstd::cout << \"\\033^\" << msg << \"\\033\\\\\";\n\t\tstd::cout.flush();\n\t}\n\tif (cfg.get_configvalue_as_bool(\"notify-xterm\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying xterm\");\n\t\tstd::cout << \"\\033]2;\" << msg << \"\\033\\\\\";\n\t\tstd::cout.flush();\n\t}\n\tif (cfg.get_configvalue_as_bool(\"notify-beep\")) {\n\t\tLOG(level::DEBUG, \"controller:notify: notifying beep\");\n\t\t::beep();\n\t}\n\tif (cfg.get_configvalue(\"notify-program\").length() > 0) {\n\t\tstd::string prog = cfg.get_configvalue(\"notify-program\");\n\t\tLOG(level::DEBUG, \"controller:notify: notifying external program `%s'\", prog);\n\t\tutils::run_command(prog, msg);\n\t}\n}\n\nvoid controller::compute_unread_numbers(unsigned int& unread_feeds, unsigned int& unread_articles) {\n\tunread_feeds = 0;\n\tunread_articles = 0;\n\tfor (auto feed : feeds) {\n\t\tunsigned int items = feed->unread_item_count();\n\t\tif (items > 0) {\n\t\t\t++unread_feeds;\n\t\t\tunread_articles += items;\n\t\t}\n\t}\n}\n\nbool controller::trylock_reload_mutex() {\n\tif (reload_mutex.try_lock()) {\n\t\tLOG(level::DEBUG, \"controller::trylock_reload_mutex succeeded\");\n\t\treturn true;\n\t}\n\tLOG(level::DEBUG, \"controller::trylock_reload_mutex failed\");\n\treturn false;\n}\n\nvoid controller::start_reload_all_thread(std::vector<int> * indexes) {\n\tLOG(level::INFO,\"starting reload all thread\");\n\tstd::thread t(downloadthread(this, indexes));\n\tt.detach();\n}\n\nvoid controller::version_information(const char * argv0, unsigned int level) {\n\tif (level<=1) {\n\t\tstd::cout << PROGRAM_NAME << \" \" << PROGRAM_VERSION << \" - \" << PROGRAM_URL << std::endl;\n\t\tstd::cout << \"Copyright (C) 2006-2015 Andreas Krennmair\" << std::endl;\n\t\tstd::cout << \"Copyright (C) 2015-2017 Alexander Batischev\" << std::endl;\n\t\tstd::cout << \"Copyright (C) 2006-2017 Newsbeuter contributors\" << std::endl;\n\t\tstd::cout << std::endl;\n\n\t\tstd::cout << _(\"newsbeuter is free software and licensed under the MIT/X Consortium License.\") << std::endl;\n\t\tstd::cout << strprintf::fmt(_(\"Type `%s -vv' for more information.\"), argv0) << std::endl << std::endl;\n\n\t\tstruct utsname xuts;\n\t\tuname(&xuts);\n\t\tstd::cout << PROGRAM_NAME << \" \" << PROGRAM_VERSION << std::endl;\n\t\tstd::cout << \"System: \" << xuts.sysname << \" \" << xuts.release << \" (\" << xuts.machine << \")\" << std::endl;\n#if defined(__GNUC__) && defined(__VERSION__)\n\t\tstd::cout << \"Compiler: g++ \" << __VERSION__ << std::endl;\n#endif\n\t\tstd::cout << \"ncurses: \" << curses_version() << \" (compiled with \" << NCURSES_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"libcurl: \" << curl_version()  << \" (compiled with \" << LIBCURL_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"SQLite: \" << sqlite3_libversion() << \" (compiled with \" << SQLITE_VERSION << \")\" << std::endl;\n\t\tstd::cout << \"libxml2: compiled with \" << LIBXML_DOTTED_VERSION << std::endl << std::endl;\n\t} else {\n\t\tstd::cout << LICENSE_str << std::endl;\n\t}\n\n\t::exit(EXIT_SUCCESS);\n}\n\nvoid controller::usage(char * argv0) {\n\tauto msg =\n\t    strprintf::fmt(_(\"%s %s\\nusage: %s [-i <file>|-e] [-u <urlfile>] \"\n\t    \"[-c <cachefile>] [-x <command> ...] [-h]\\n\"),\n\t    PROGRAM_NAME,\n\t    PROGRAM_VERSION,\n\t    argv0);\n\tstd::cout << msg;\n\n\tstruct arg {\n\t\tconst char name;\n\t\tconst std::string longname;\n\t\tconst std::string params;\n\t\tconst std::string desc;\n\t};\n\n\tstatic const std::vector<arg> args = {\n\t\t{ 'e', \"export-to-opml\"  , \"\"                , _s(\"export OPML feed to stdout\") }                                                 ,\n\t\t{ 'r', \"refresh-on-start\", \"\"                , _s(\"refresh feeds on start\") }                                                     ,\n\t\t{ 'i', \"import-from-opml\", _s(\"<file>\")      , _s(\"import OPML file\") }                                                           ,\n\t\t{ 'u', \"url-file\"        , _s(\"<urlfile>\")   , _s(\"read RSS feed URLs from <urlfile>\") }                                          ,\n\t\t{ 'c', \"cache-file\"      , _s(\"<cachefile>\") , _s(\"use <cachefile> as cache file\") }                                              ,\n\t\t{ 'C', \"config-file\"     , _s(\"<configfile>\"), _s(\"read configuration from <configfile>\") }                                       ,\n\t\t{ 'X', \"vacuum\"          , \"\"                , _s(\"compact the cache\") }                                                  ,\n\t\t{ 'x', \"execute\"         , _s(\"<command>...\"), _s(\"execute list of commands\") }                                                   ,\n\t\t{ 'q', \"quiet\"           , \"\"                , _s(\"quiet startup\") }                                                              ,\n\t\t{ 'v', \"version\"         , \"\"                , _s(\"get version information\") }                                                    ,\n\t\t{ 'l', \"log-level\"       , _s(\"<loglevel>\")  , _s(\"write a log with a certain loglevel (valid values: 1 to 6)\") }                 ,\n\t\t{ 'd', \"log-file\"        , _s(\"<logfile>\")   , _s(\"use <logfile> as output log file\") }                                           ,\n\t\t{ 'E', \"export-to-file\"  , _s(\"<file>\")      , _s(\"export list of read articles to <file>\") }                                     ,\n\t\t{ 'I', \"import-from-file\", _s(\"<file>\")      , _s(\"import list of read articles from <file>\") }                                   ,\n\t\t{ 'h', \"help\"            , \"\"                , _s(\"this help\") }\n\t};\n\n\tfor (const auto & a : args) {\n\t\tstd::string longcolumn(\"-\");\n\t\tlongcolumn += a.name;\n\t\tlongcolumn += \", --\" + a.longname;\n\t\tlongcolumn += a.params.size() > 0 ? \"=\" + a.params : \"\";\n\t\tstd::cout << \"\\t\" << longcolumn;\n\t\tfor (unsigned int j = 0; j < utils::gentabs(longcolumn); j++) {\n\t\t\tstd::cout << \"\\t\";\n\t\t}\n\t\tstd::cout << a.desc << std::endl;\n\t}\n\n\t::exit(EXIT_FAILURE);\n}\n\nvoid controller::import_opml(const std::string& filename) {\n\txmlDoc * doc = xmlReadFile(filename.c_str(), nullptr, 0);\n\tif (doc == nullptr) {\n\t\tstd::cout\n\t\t\t<< strprintf::fmt(_(\"An error occurred while parsing %s.\"), filename)\n\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\txmlNode * root = xmlDocGetRootElement(doc);\n\n\tfor (xmlNode * node = root->children; node != nullptr; node = node->next) {\n\t\tif (strcmp((const char *)node->name, \"body\")==0) {\n\t\t\tLOG(level::DEBUG, \"import_opml: found body\");\n\t\t\trec_find_rss_outlines(node->children, \"\");\n\t\t\turlcfg->write_config();\n\t\t}\n\t}\n\n\txmlFreeDoc(doc);\n\tstd::cout << strprintf::fmt(_(\"Import of %s finished.\"), filename) << std::endl;\n}\n\nvoid controller::export_opml() {\n\txmlDocPtr root = xmlNewDoc((const xmlChar *)\"1.0\");\n\txmlNodePtr opml_node = xmlNewDocNode(root, nullptr, (const xmlChar *)\"opml\", nullptr);\n\txmlSetProp(opml_node, (const xmlChar *)\"version\", (const xmlChar *)\"1.0\");\n\txmlDocSetRootElement(root, opml_node);\n\n\txmlNodePtr head = xmlNewTextChild(opml_node, nullptr, (const xmlChar *)\"head\", nullptr);\n\txmlNewTextChild(head, nullptr, (const xmlChar *)\"title\", (const xmlChar *)PROGRAM_NAME \" - Exported Feeds\");\n\txmlNodePtr body = xmlNewTextChild(opml_node, nullptr, (const xmlChar *)\"body\", nullptr);\n\n\tfor (auto feed : feeds) {\n\t\tif (!utils::is_special_url(feed->rssurl())) {\n\t\t\tstd::string rssurl = feed->rssurl();\n\t\t\tstd::string link = feed->link();\n\t\t\tstd::string title = feed->title();\n\n\t\t\txmlNodePtr outline = xmlNewTextChild(body, nullptr, (const xmlChar *)\"outline\", nullptr);\n\t\t\txmlSetProp(outline, (const xmlChar *)\"type\", (const xmlChar *)\"rss\");\n\t\t\txmlSetProp(outline, (const xmlChar *)\"xmlUrl\", (const xmlChar *)rssurl.c_str());\n\t\t\txmlSetProp(outline, (const xmlChar *)\"htmlUrl\", (const xmlChar *)link.c_str());\n\t\t\txmlSetProp(outline, (const xmlChar *)\"title\", (const xmlChar *)title.c_str());\n\t\t}\n\t}\n\n\txmlSaveCtxtPtr savectx = xmlSaveToFd(1, nullptr, 1);\n\txmlSaveDoc(savectx, root);\n\txmlSaveClose(savectx);\n\n\txmlFreeNode(opml_node);\n}\n\nvoid controller::rec_find_rss_outlines(xmlNode * node, std::string tag) {\n\twhile (node) {\n\t\tstd::string newtag = tag;\n\n\n\t\tif (strcmp((const char *)node->name, \"outline\")==0) {\n\t\t\tchar * url = (char *)xmlGetProp(node, (const xmlChar *)\"xmlUrl\");\n\t\t\tif (!url) {\n\t\t\t\turl = (char *)xmlGetProp(node, (const xmlChar *)\"url\");\n\t\t\t}\n\n\t\t\tif (url) {\n\t\t\t\tLOG(level::DEBUG,\"OPML import: found RSS outline with url = %s\",url);\n\n\t\t\t\tstd::string nurl = std::string(url);\n\n\t\t\t\t// Liferea uses a pipe to signal feeds read from the output of\n\t\t\t\t// a program in its OPMLs. Convert them to our syntax.\n\t\t\t\tif (*url == '|') {\n\t\t\t\t\tnurl = strprintf::fmt(\"exec:%s\", url+1);\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: liferea-style url %s converted to %s\", url, nurl);\n\t\t\t\t}\n\n\t\t\t\t// Handle OPML filters.\n\t\t\t\tchar * filtercmd = (char *)xmlGetProp(node, (const xmlChar *)\"filtercmd\");\n\t\t\t\tif (filtercmd) {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: adding filter command %s to url %s\", filtercmd, nurl);\n\t\t\t\t\tnurl.insert(0, strprintf::fmt(\"filter:%s:\", filtercmd));\n\t\t\t\t\txmlFree(filtercmd);\n\t\t\t\t}\n\n\t\t\t\txmlFree(url);\n\t\t\t\t// Filters and scripts may have arguments, so, quote them when needed.\n\t\t\t\turl = (char*) xmlStrdup((const xmlChar*)utils::quote_if_necessary(nurl).c_str());\n\t\t\t\tassert(url);\n\n\t\t\t\tbool found = false;\n\n\t\t\t\tLOG(level::DEBUG, \"OPML import: size = %u\", urlcfg->get_urls().size());\n\t\t\t\tif (urlcfg->get_urls().size() > 0) {\n\t\t\t\t\tfor (auto u : urlcfg->get_urls()) {\n\t\t\t\t\t\tif (u == url) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found) {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: added url = %s\",url);\n\t\t\t\t\turlcfg->get_urls().push_back(std::string(url));\n\t\t\t\t\tif (tag.length() > 0) {\n\t\t\t\t\t\tLOG(level::DEBUG, \"OPML import: appending tag %s to url %s\", tag, url);\n\t\t\t\t\t\turlcfg->get_tags(url).push_back(tag);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG(level::DEBUG,\"OPML import: url = %s is already in list\",url);\n\t\t\t\t}\n\t\t\t\txmlFree(url);\n\t\t\t} else {\n\t\t\t\tchar * text = (char *)xmlGetProp(node, (const xmlChar *)\"text\");\n\t\t\t\tif (!text)\n\t\t\t\t\ttext = (char *)xmlGetProp(node, (const xmlChar *)\"title\");\n\t\t\t\tif (text) {\n\t\t\t\t\tif (newtag.length() > 0) {\n\t\t\t\t\t\tnewtag.append(\"/\");\n\t\t\t\t\t}\n\t\t\t\t\tnewtag.append(text);\n\t\t\t\t\txmlFree(text);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trec_find_rss_outlines(node->children, newtag);\n\n\t\tnode = node->next;\n\t}\n}\n\n\n\nstd::vector<std::shared_ptr<rss_item>> controller::search_for_items(const std::string& query, std::shared_ptr<rss_feed> feed) {\n\tstd::vector<std::shared_ptr<rss_item>> items;\n\tLOG(level::DEBUG, \"controller::search_for_items: setting feed pointers\");\n\tif (feed != nullptr && feed->rssurl().substr(0,6) == \"query:\") {\n\t\tfor (auto item : feed->items()) {\n\t\t\tif (!item->deleted()\n\t\t\t\t&& (item->title().find(query) != std::string::npos\n\t\t\t\t    || item->description().find(query) != std::string::npos))\n\t\t\t{\n\t\t\t\tstd::shared_ptr<rss_item> newitem(new rss_item(nullptr));\n\t\t\t\tnewitem->set_guid(item->guid());\n\t\t\t\tnewitem->set_title(item->title());\n\t\t\t\tnewitem->set_author(item->author());\n\t\t\t\tnewitem->set_link(item->link());\n\n\t\t\t\tnewitem->set_pubDate(item->pubDate_timestamp());\n\n\t\t\t\tnewitem->set_size(item->size());\n\t\t\t\tnewitem->set_unread(item->unread());\n\t\t\t\tnewitem->set_feedurl(item->feedurl());\n\n\t\t\t\tnewitem->set_enclosure_url(item->enclosure_url());\n\t\t\t\tnewitem->set_enclosure_type(item->enclosure_type());\n\t\t\t\tnewitem->set_enqueued(item->enqueued());\n\t\t\t\tnewitem->set_flags(item->flags());\n\t\t\t\tnewitem->set_base(item->get_base());\n\n\t\t\t\tnewitem->set_feedptr(item->get_feedptr());\n\t\t\t\tnewitem->set_cache(get_cache());\n\n\t\t\t\titems.push_back(newitem);\n\t\t\t}\n\t\t}\n\t} else {\n\t\titems = rsscache->search_for_items(query, (feed != nullptr ? feed->rssurl() : \"\"));\n\t\tfor (auto item : items) {\n\t\t\titem->set_feedptr(get_feed_by_url(item->feedurl()));\n\t\t}\n\t}\n\treturn items;\n}\n\nstd::shared_ptr<rss_feed> controller::get_feed_by_url(const std::string& feedurl) {\n\tfor (auto feed : feeds) {\n\t\tif (feedurl == feed->rssurl())\n\t\t\treturn feed;\n\t}\n\tLOG(level::ERROR, \"controller:get_feed_by_url failed for %s\", feedurl);\n\treturn std::shared_ptr<rss_feed>();\n}\n\nbool controller::is_valid_podcast_type(const std::string& /* mimetype */) {\n\treturn true;\n}\n\nvoid controller::enqueue_url(const std::string& url, std::shared_ptr<rss_feed> feed) {\n\tbool url_found = false;\n\tstd::fstream f;\n\tf.open(queue_file.c_str(), std::fstream::in);\n\tif (f.is_open()) {\n\t\tdo {\n\t\t\tstd::string line;\n\t\t\tgetline(f, line);\n\t\t\tif (!f.eof() && line.length() > 0) {\n\t\t\t\tstd::vector<std::string> fields = utils::tokenize_quoted(line);\n\t\t\t\tif (!fields.empty() && fields[0] == url) {\n\t\t\t\t\turl_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!f.eof());\n\t\tf.close();\n\t}\n\tif (!url_found) {\n\t\tf.open(queue_file.c_str(), std::fstream::app | std::fstream::out);\n\t\tstd::string filename = generate_enqueue_filename(url, feed);\n\t\tf << url << \" \" << stfl::quote(filename) << std::endl;\n\t\tf.close();\n\t}\n}\n\nvoid controller::reload_urls_file() {\n\turlcfg->reload();\n\tstd::vector<std::shared_ptr<rss_feed>> new_feeds;\n\tunsigned int i = 0;\n\n\tfor (auto url : urlcfg->get_urls()) {\n\t\tbool found = false;\n\t\tfor (auto feed : feeds) {\n\t\t\tif (url == feed->rssurl()) {\n\t\t\t\tfound = true;\n\t\t\t\tfeed->set_tags(urlcfg->get_tags(url));\n\t\t\t\tfeed->set_order(i);\n\t\t\t\tnew_feeds.push_back(feed);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\ttry {\n\t\t\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\t\t\tstd::shared_ptr<rss_feed> new_feed = rsscache->internalize_rssfeed(url, ignore_disp ? &ign : nullptr);\n\t\t\t\tnew_feed->set_tags(urlcfg->get_tags(url));\n\t\t\t\tnew_feed->set_order(i);\n\t\t\t\tnew_feeds.push_back(new_feed);\n\t\t\t} catch(const dbexception& e) {\n\t\t\t\tLOG(level::ERROR, \"controller::reload_urls_file: caught exception: %s\", e.what());\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tv->set_tags(urlcfg->get_alltags());\n\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\tfeeds = new_feeds;\n\t}\n\n\tsort_feeds();\n\n\tupdate_feedlist();\n}\n\nvoid controller::edit_urls_file() {\n\tconst char * editor;\n\n\teditor = getenv(\"VISUAL\");\n\tif (!editor)\n\t\teditor = getenv(\"EDITOR\");\n\tif (!editor)\n\t\teditor = \"vi\";\n\n\tstd::string cmdline = strprintf::fmt(\"%s \\\"%s\\\"\", editor, utils::replace_all(url_file,\"\\\"\",\"\\\\\\\"\"));\n\n\tv->push_empty_formaction();\n\tstfl::reset();\n\n\tutils::run_interactively(cmdline, \"controller::edit_urls_file\");\n\n\tv->pop_current_formaction();\n\n\treload_urls_file();\n}\n\n/* When passing an argument to a shell script, empty string should be\n * represented as '' (two quote marks), otherwise shell won't be able to tell\n * that the parameter is empty */\nstd::string quote_empty(const std::string& input) {\n\tif (input.empty()) {\n\t\treturn \"''\";\n\t} else {\n\t\treturn input;\n\t}\n}\n\nstd::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}\n\nvoid controller::execute_commands(char ** argv, unsigned int i) {\n\tif (v->formaction_stack_size() > 0)\n\t\tv->pop_current_formaction();\n\tfor (; argv[i]; ++i) {\n\t\tLOG(level::DEBUG, \"controller::execute_commands: executing `%s'\", argv[i]);\n\t\tstd::string cmd(argv[i]);\n\t\tif (cmd == \"reload\") {\n\t\t\treload_all(true);\n\t\t} else if (cmd == \"print-unread\") {\n\t\t\tstd::cout << strprintf::fmt(_(\"%u unread articles\"), rsscache->get_unread_count()) << std::endl;\n\t\t} else {\n\t\t\tstd::cerr << strprintf::fmt(_(\"%s: %s: unknown command\"), argv[0], argv[i]) << std::endl;\n\t\t\t::std::exit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nstd::string controller::write_temporary_item(std::shared_ptr<rss_item> item) {\n\tchar filename[_POSIX_PATH_MAX];\n\tsnprintf(filename, sizeof(filename), \"/tmp/newsbeuter-article.XXXXXX\");\n\tint fd = mkstemp(filename);\n\tif (fd != -1) {\n\t\twrite_item(item, filename);\n\t\tclose(fd);\n\t\treturn std::string(filename);\n\t} else {\n\t\treturn \"\";\n\t}\n}\n\nvoid controller::write_item(std::shared_ptr<rss_item> item, const std::string& filename) {\n\tstd::fstream f;\n\tf.open(filename.c_str(),std::fstream::out);\n\tif (!f.is_open())\n\t\tthrow exception(errno);\n\n\twrite_item(item, f);\n}\n\nvoid controller::write_item(std::shared_ptr<rss_item> item, std::ostream& ostr) {\n\tstd::vector<std::pair<LineType, std::string>> lines;\n\tstd::vector<linkpair> links; // not used\n\n\tstd::string title(_(\"Title: \"));\n\ttitle.append(item->title());\n\tlines.push_back(std::make_pair(LineType::wrappable, title));\n\n\tstd::string author(_(\"Author: \"));\n\tauthor.append(item->author());\n\tlines.push_back(std::make_pair(LineType::wrappable, author));\n\n\tstd::string date(_(\"Date: \"));\n\tdate.append(item->pubDate());\n\tlines.push_back(std::make_pair(LineType::wrappable, date));\n\n\tstd::string link(_(\"Link: \"));\n\tlink.append(item->link());\n\tlines.push_back(std::make_pair(LineType::softwrappable, link));\n\n\tif (item->enclosure_url() != \"\") {\n\t\tstd::string dlurl(_(\"Podcast Download URL: \"));\n\t\tdlurl.append(item->enclosure_url());\n\t\tlines.push_back(std::make_pair(LineType::softwrappable, dlurl));\n\t}\n\n\tlines.push_back(std::make_pair(LineType::wrappable, std::string(\"\")));\n\n\thtmlrenderer rnd(true);\n\trnd.render(item->description(), lines, links, item->feedurl());\n\ttextformatter txtfmt;\n\ttxtfmt.add_lines(lines);\n\n\tunsigned int width = cfg.get_configvalue_as_int(\"text-width\");\n\tif (width == 0)\n\t\twidth = 80;\n\tostr << txtfmt.format_text_plain(width) << std::endl;\n}\n\nvoid controller::mark_deleted(const std::string& guid, bool b) {\n\trsscache->mark_item_deleted(guid, b);\n}\n\nstd::string controller::prepare_message(unsigned int pos, unsigned int max) {\n\tif (max > 0) {\n\t\treturn strprintf::fmt(\"(%u/%u) \", pos, max);\n\t}\n\treturn \"\";\n}\n\nvoid controller::save_feed(std::shared_ptr<rss_feed> feed, unsigned int pos) {\n\tif (!feed->is_empty()) {\n\t\tLOG(level::DEBUG, \"controller::save_feed: feed is nonempty, saving\");\n\t\trsscache->externalize_rssfeed(feed, ign.matches_resetunread(feed->rssurl()));\n\t\tLOG(level::DEBUG, \"controller::save_feed: after externalize_rssfeed\");\n\n\t\tbool ignore_disp = (cfg.get_configvalue(\"ignore-mode\") == \"display\");\n\t\tfeed = rsscache->internalize_rssfeed(feed->rssurl(), ignore_disp ? &ign : nullptr);\n\t\tLOG(level::DEBUG, \"controller::save_feed: after internalize_rssfeed\");\n\t\tfeed->set_tags(urlcfg->get_tags(feed->rssurl()));\n\t\t{\n\t\t\tunsigned int order = feeds[pos]->get_order();\n\t\t\tstd::lock_guard<std::mutex> itemlock(feeds[pos]->item_mutex);\n\t\t\tfeeds[pos]->clear_items();\n\t\t\tfeed->set_order(order);\n\t\t}\n\t\tfeeds[pos] = feed;\n\t\tv->notify_itemlist_change(feeds[pos]);\n\t} else {\n\t\tLOG(level::DEBUG, \"controller::save_feed: feed is empty, not saving\");\n\t}\n}\n\nvoid controller::enqueue_items(std::shared_ptr<rss_feed> feed) {\n\tif (!cfg.get_configvalue_as_bool(\"podcast-auto-enqueue\"))\n\t\treturn;\n\tstd::lock_guard<std::mutex> lock(feed->item_mutex);\n\tfor (auto item : feed->items()) {\n\t\tif (!item->enqueued() && item->enclosure_url().length() > 0) {\n\t\t\tLOG(level::DEBUG, \"controller::enqueue_items: enclosure_url = `%s' enclosure_type = `%s'\", item->enclosure_url(), item->enclosure_type());\n\t\t\tif (is_valid_podcast_type(item->enclosure_type()) && utils::is_http_url(item->enclosure_url())) {\n\t\t\t\tLOG(level::INFO, \"controller::enqueue_items: enqueuing `%s'\", item->enclosure_url());\n\t\t\t\tenqueue_url(item->enclosure_url(), feed);\n\t\t\t\titem->set_enqueued(true);\n\t\t\t\trsscache->update_rssitem_unread_and_enqueued(item, feed->rssurl());\n\t\t\t}\n\t\t}\n\t}\n}\n\nstd::string controller::generate_enqueue_filename(const std::string& url, std::shared_ptr<rss_feed> feed) {\n\tstd::string dlformat = cfg.get_configvalue(\"download-path\");\n\tif (dlformat[dlformat.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tdlformat.append(NEWSBEUTER_PATH_SEP);\n\n\tfmtstr_formatter fmt;\n\tfmt.register_fmt('n', feed->title());\n\tfmt.register_fmt('h', get_hostname_from_url(url));\n\n\tstd::string dlpath = fmt.do_format(dlformat);\n\n\tchar buf[2048];\n\tsnprintf(buf, sizeof(buf), \"%s\", url.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tdlpath.append(lbuf);\n\t} else {\n\t\tdlpath.append(base);\n\t}\n\treturn dlpath;\n}\n\nstd::string controller::get_hostname_from_url(const std::string& url) {\n\txmlURIPtr uri = xmlParseURI(url.c_str());\n\tstd::string hostname;\n\tif (uri) {\n\t\thostname = uri->server;\n\t\txmlFreeURI(uri);\n\t}\n\treturn hostname;\n}\n\nvoid controller::import_read_information(const std::string& readinfofile) {\n\tstd::vector<std::string> guids;\n\n\tstd::ifstream f(readinfofile.c_str());\n\tstd::string line;\n\tgetline(f,line);\n\tif (!f.is_open()) {\n\t\treturn;\n\t}\n\twhile (f.is_open() && !f.eof()) {\n\t\tguids.push_back(line);\n\t\tgetline(f, line);\n\t}\n\trsscache->mark_items_read_by_guid(guids);\n}\n\nvoid controller::export_read_information(const std::string& readinfofile) {\n\tstd::vector<std::string> guids = rsscache->get_read_item_guids();\n\n\tstd::fstream f;\n\tf.open(readinfofile.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto guid : guids) {\n\t\t\tf << guid << std::endl;\n\t\t}\n\t}\n}\n\nvoid controller::sort_feeds() {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tstd::vector<std::string> sortmethod_info = utils::tokenize(cfg.get_configvalue(\"feed-sort-order\"), \"-\");\n\tstd::string sortmethod = sortmethod_info[0];\n\tstd::string direction = \"desc\";\n\tif (sortmethod_info.size() > 1)\n\t\tdirection = sortmethod_info[1];\n\tif (sortmethod == \"none\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->get_order() < b->get_order();\n\t\t});\n\t} else if (sortmethod == \"firsttag\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\tif (a->get_firsttag().length() == 0 || b->get_firsttag().length() == 0) {\n\t\t\t\treturn a->get_firsttag().length() > b->get_firsttag().length();\n\t\t\t}\n\t\t\treturn strcasecmp(a->get_firsttag().c_str(), b->get_firsttag().c_str()) < 0;\n\t\t});\n\t} else if (sortmethod == \"title\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn strcasecmp(a->title().c_str(), b->title().c_str()) < 0;\n\t\t});\n\t} else if (sortmethod == \"articlecount\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->total_item_count() < b->total_item_count();\n\t\t});\n\t} else if (sortmethod == \"unreadarticlecount\") {\n\t\tstd::stable_sort(feeds.begin(), feeds.end(), [](std::shared_ptr<rss_feed> a, std::shared_ptr<rss_feed> b) {\n\t\t\treturn a->unread_item_count() < b->unread_item_count();\n\t\t});\n\t}\n\tif (direction == \"asc\") {\n\t\tstd::reverse(feeds.begin(), feeds.end());\n\t}\n}\n\nvoid controller::update_config() {\n\tv->set_regexmanager(&rxman);\n\tv->update_bindings();\n\n\tif (colorman.colors_loaded()) {\n\t\tv->set_colors(colorman.get_fgcolors(), colorman.get_bgcolors(), colorman.get_attributes());\n\t\tv->apply_colors_to_all_formactions();\n\t}\n\n\tif (cfg.get_configvalue(\"error-log\").length() > 0) {\n\t\tlogger::getInstance().set_errorlogfile(cfg.get_configvalue(\"error-log\"));\n\t}\n\n}\n\nvoid controller::load_configfile(const std::string& filename) {\n\tif (cfgparser.parse(filename, true)) {\n\t\tupdate_config();\n\t} else {\n\t\tv->show_error(strprintf::fmt(_(\"Error: couldn't open configuration file `%s'!\"), filename));\n\t}\n}\n\nvoid controller::dump_config(const std::string& filename) {\n\tstd::vector<std::string> configlines;\n\tcfg.dump_config(configlines);\n\tif (v) {\n\t\tv->get_keys()->dump_config(configlines);\n\t}\n\tign.dump_config(configlines);\n\tfilters.dump_config(configlines);\n\tcolorman.dump_config(configlines);\n\trxman.dump_config(configlines);\n\tstd::fstream f;\n\tf.open(filename.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto line : configlines) {\n\t\t\tf << line << std::endl;\n\t\t}\n\t}\n}\n\nunsigned int controller::get_pos_of_next_unread(unsigned int pos) {\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\tfor (pos++; pos < feeds.size(); pos++) {\n\t\tif (feeds[pos]->unread_item_count() > 0)\n\t\t\tbreak;\n\t}\n\treturn pos;\n}\n\nvoid controller::update_flags(std::shared_ptr<rss_item> item) {\n\tif (api) {\n\t\tapi->update_article_flags(item->oldflags(), item->flags(), item->guid());\n\t}\n\titem->update_flags();\n}\n\nstd::vector<std::shared_ptr<rss_feed>> controller::get_all_feeds() {\n\tstd::vector<std::shared_ptr<rss_feed>> tmpfeeds;\n\t{\n\t\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\t\ttmpfeeds = feeds;\n\t}\n\treturn tmpfeeds;\n}\n\nstd::vector<std::shared_ptr<rss_feed>> controller::get_all_feeds_unlocked() {\n\treturn feeds;\n}\n\n\nunsigned int controller::get_feed_count_per_tag(const std::string& tag) {\n\tunsigned int count = 0;\n\tstd::lock_guard<std::mutex> feedslock(feeds_mutex);\n\n\tfor (auto feed : feeds) {\n\t\tif (feed->matches_tag(tag)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n}\n"], "filenames": ["src/controller.cpp"], "buggy_code_start_loc": [1347], "buggy_code_end_loc": [1353], "fixing_code_start_loc": [1347], "fixing_code_end_loc": [1353], "type": "CWE-943", "message": "Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL.", "other": {"cve": {"id": "CVE-2017-12904", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-23T14:29:00.393", "lastModified": "2020-10-21T20:15:13.083", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL."}, {"lang": "es", "value": "Una neutralizaci\u00f3n incorrecta de elementos especiales en un comando del sistema operativo en la funci\u00f3n de marcado de Newsbeuter en sus versiones de la 0.7 hasta la 2.9 permite que atacantes remotos realicen una ejecuci\u00f3n de c\u00f3digo asistidos por usuarios mediante la manipulaci\u00f3n de un elemento RSS que incluya c\u00f3digo shell en su t\u00edtulo y/o URL."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-943"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "684B7199-9344-4DBA-90AD-DEDEC056F213"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8:*:*:*:*:*:*:*", "matchCriteriaId": "45CD698E-70A1-43A0-B828-3DBD519DDDF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "379E21B5-D427-45EC-B674-9BCC8A47CA76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "EB0B1B93-8E8C-4A77-98F8-CE5BFED550DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "1C907407-E178-43BF-A433-9BC73EB7FD5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "DB3A20C1-1FB7-43C8-A78E-FBEBB4E888AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "A3F963DE-447B-4D6C-A508-C4449C67F1C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B7BAF663-30D1-4584-A0B0-CF02D2646877"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "50AD4B86-FED2-4469-BBD7-B698A7C1B4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "62E8E19D-024A-4F73-B66F-87741325BC35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A34C699-1E62-4A54-B929-0C187299ABD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5E5E120-42BD-4846-9C6B-D51804C902A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.2:*:*:*:*:*:*:*", "matchCriteriaId": "BFC168D9-75AB-43DD-A1F6-103F14AD9995"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9FA4C1C6-33AD-420C-ABA3-F7254A51BDDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "2EC3FE66-8689-4F61-9035-00DAD02A1527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.5:*:*:*:*:*:*:*", "matchCriteriaId": "0FADF671-B5B0-4634-AA18-15551363293B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8E8DC0AC-DA20-4A93-9561-C2D906D0D1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.7:*:*:*:*:*:*:*", "matchCriteriaId": "DD6A06A3-2A06-4DDC-851A-6B27B7BB7F24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.8:*:*:*:*:*:*:*", "matchCriteriaId": "A5CDB422-35D4-42E5-A897-3C12C6E16E51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.9:*:*:*:*:*:*:*", "matchCriteriaId": "8ECF398D-94EA-4628-99A2-35B698579B96"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3947", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/akrennmair/newsbeuter/commit/96e9506ae9e252c548665152d1b8968297128307", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/akrennmair/newsbeuter/issues/591", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/newsbeuter/iFqSE7Vz-DE", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4585-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/akrennmair/newsbeuter/commit/96e9506ae9e252c548665152d1b8968297128307"}}