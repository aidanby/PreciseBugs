{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <linux/input.h>\n\n#include \"sd-messages.h\"\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"logind-button.h\"\n#include \"missing_input.h\"\n#include \"string-util.h\"\n#include \"util.h\"\n\n#define CONST_MAX4(a, b, c, d) CONST_MAX(CONST_MAX(a, b), CONST_MAX(c, d))\n\n#define ULONG_BITS (sizeof(unsigned long)*8)\n\nstatic bool bitset_get(const unsigned long *bits, unsigned i) {\n        return (bits[i / ULONG_BITS] >> (i % ULONG_BITS)) & 1UL;\n}\n\nstatic void bitset_put(unsigned long *bits, unsigned i) {\n        bits[i / ULONG_BITS] |= (unsigned long) 1 << (i % ULONG_BITS);\n}\n\nButton* button_new(Manager *m, const char *name) {\n        Button *b;\n\n        assert(m);\n        assert(name);\n\n        b = new0(Button, 1);\n        if (!b)\n                return NULL;\n\n        b->name = strdup(name);\n        if (!b->name)\n                return mfree(b);\n\n        if (hashmap_put(m->buttons, b->name, b) < 0) {\n                free(b->name);\n                return mfree(b);\n        }\n\n        b->manager = m;\n        b->fd = -1;\n\n        return b;\n}\n\nvoid button_free(Button *b) {\n        assert(b);\n\n        hashmap_remove(b->manager->buttons, b->name);\n\n        sd_event_source_unref(b->io_event_source);\n        sd_event_source_unref(b->check_event_source);\n\n        if (b->fd >= 0)\n                /* If the device has been unplugged close() returns\n                 * ENODEV, let's ignore this, hence we don't use\n                 * safe_close() */\n                (void) close(b->fd);\n\n        free(b->name);\n        free(b->seat);\n        free(b);\n}\n\nint button_set_seat(Button *b, const char *sn) {\n        char *s;\n\n        assert(b);\n        assert(sn);\n\n        s = strdup(sn);\n        if (!s)\n                return -ENOMEM;\n\n        free(b->seat);\n        b->seat = s;\n\n        return 0;\n}\n\nstatic void button_lid_switch_handle_action(Manager *manager, bool is_edge) {\n        HandleAction handle_action;\n\n        assert(manager);\n\n        /* If we are docked or on external power, handle the lid switch\n         * differently */\n        if (manager_is_docked_or_external_displays(manager))\n                handle_action = manager->handle_lid_switch_docked;\n        else if (manager->handle_lid_switch_ep != _HANDLE_ACTION_INVALID &&\n                 manager_is_on_external_power())\n                handle_action = manager->handle_lid_switch_ep;\n        else\n                handle_action = manager->handle_lid_switch;\n\n        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge);\n}\n\nstatic int button_recheck(sd_event_source *e, void *userdata) {\n        Button *b = userdata;\n\n        assert(b);\n        assert(b->lid_closed);\n\n        button_lid_switch_handle_action(b->manager, false);\n        return 1;\n}\n\nstatic int button_install_check_event_source(Button *b) {\n        int r;\n        assert(b);\n\n        /* Install a post handler, so that we keep rechecking as long as the lid is closed. */\n\n        if (b->check_event_source)\n                return 0;\n\n        r = sd_event_add_post(b->manager->event, &b->check_event_source, button_recheck, b);\n        if (r < 0)\n                return r;\n\n        return sd_event_source_set_priority(b->check_event_source, SD_EVENT_PRIORITY_IDLE+1);\n}\n\nstatic int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *userdata) {\n        Button *b = userdata;\n        struct input_event ev;\n        ssize_t l;\n\n        assert(s);\n        assert(fd == b->fd);\n        assert(b);\n\n        l = read(b->fd, &ev, sizeof(ev));\n        if (l < 0)\n                return errno != EAGAIN ? -errno : 0;\n        if ((size_t) l < sizeof(ev))\n                return -EIO;\n\n        if (ev.type == EV_KEY && ev.value > 0) {\n\n                switch (ev.code) {\n\n                case KEY_POWER:\n                case KEY_POWER2:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Power key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_POWER_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);\n                        break;\n\n                /* The kernel is a bit confused here:\n\n                   KEY_SLEEP   = suspend-to-ram, which everybody else calls \"suspend\"\n                   KEY_SUSPEND = suspend-to-disk, which everybody else calls \"hibernate\"\n                */\n\n                case KEY_SLEEP:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Suspend key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SUSPEND_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);\n                        break;\n\n                case KEY_SUSPEND:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Hibernate key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_HIBERNATE_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);\n                        break;\n                }\n\n        } else if (ev.type == EV_SW && ev.value > 0) {\n\n                if (ev.code == SW_LID) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Lid closed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_LID_CLOSED_STR);\n\n                        b->lid_closed = true;\n                        button_lid_switch_handle_action(b->manager, true);\n                        button_install_check_event_source(b);\n\n                } else if (ev.code == SW_DOCK) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"System docked.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SYSTEM_DOCKED_STR);\n\n                        b->docked = true;\n                }\n\n        } else if (ev.type == EV_SW && ev.value == 0) {\n\n                if (ev.code == SW_LID) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Lid opened.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_LID_OPENED_STR);\n\n                        b->lid_closed = false;\n                        b->check_event_source = sd_event_source_unref(b->check_event_source);\n\n                } else if (ev.code == SW_DOCK) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"System undocked.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SYSTEM_UNDOCKED_STR);\n\n                        b->docked = false;\n                }\n        }\n\n        return 0;\n}\n\nstatic int button_suitable(Button *b) {\n        unsigned long types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1];\n\n        assert(b);\n        assert(b->fd);\n\n        if (ioctl(b->fd, EVIOCGBIT(EV_SYN, sizeof(types)), types) < 0)\n                return -errno;\n\n        if (bitset_get(types, EV_KEY)) {\n                unsigned long keys[CONST_MAX4(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND)/ULONG_BITS+1];\n\n                if (ioctl(b->fd, EVIOCGBIT(EV_KEY, sizeof(keys)), keys) < 0)\n                        return -errno;\n\n                if (bitset_get(keys, KEY_POWER) ||\n                    bitset_get(keys, KEY_POWER2) ||\n                    bitset_get(keys, KEY_SLEEP) ||\n                    bitset_get(keys, KEY_SUSPEND))\n                        return true;\n        }\n\n        if (bitset_get(types, EV_SW)) {\n                unsigned long switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1];\n\n                if (ioctl(b->fd, EVIOCGBIT(EV_SW, sizeof(switches)), switches) < 0)\n                        return -errno;\n\n                if (bitset_get(switches, SW_LID) ||\n                    bitset_get(switches, SW_DOCK))\n                        return true;\n        }\n\n        return false;\n}\n\nstatic int button_set_mask(Button *b) {\n        unsigned long\n                types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1] = {},\n                keys[CONST_MAX4(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND)/ULONG_BITS+1] = {},\n                switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};\n        struct input_mask mask;\n\n        assert(b);\n        assert(b->fd >= 0);\n\n        bitset_put(types, EV_KEY);\n        bitset_put(types, EV_SW);\n\n        mask = (struct input_mask) {\n                .type = EV_SYN,\n                .codes_size = sizeof(types),\n                .codes_ptr = PTR_TO_UINT64(types),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                /* Log only at debug level if the kernel doesn't do EVIOCSMASK yet */\n                return log_full_errno(IN_SET(errno, ENOTTY, EOPNOTSUPP, EINVAL) ? LOG_DEBUG : LOG_WARNING,\n                                      errno, \"Failed to set EV_SYN event mask on /dev/input/%s: %m\", b->name);\n\n        bitset_put(keys, KEY_POWER);\n        bitset_put(keys, KEY_POWER2);\n        bitset_put(keys, KEY_SLEEP);\n        bitset_put(keys, KEY_SUSPEND);\n\n        mask = (struct input_mask) {\n                .type = EV_KEY,\n                .codes_size = sizeof(keys),\n                .codes_ptr = PTR_TO_UINT64(keys),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                return log_warning_errno(errno, \"Failed to set EV_KEY event mask on /dev/input/%s: %m\", b->name);\n\n        bitset_put(switches, SW_LID);\n        bitset_put(switches, SW_DOCK);\n\n        mask = (struct input_mask) {\n                .type = EV_SW,\n                .codes_size = sizeof(switches),\n                .codes_ptr = PTR_TO_UINT64(switches),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                return log_warning_errno(errno, \"Failed to set EV_SW event mask on /dev/input/%s: %m\", b->name);\n\n        return 0;\n}\n\nint button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}\n\nint button_check_switches(Button *b) {\n        unsigned long switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};\n        assert(b);\n\n        if (b->fd < 0)\n                return -EINVAL;\n\n        if (ioctl(b->fd, EVIOCGSW(sizeof(switches)), switches) < 0)\n                return -errno;\n\n        b->lid_closed = bitset_get(switches, SW_LID);\n        b->docked = bitset_get(switches, SW_DOCK);\n\n        if (b->lid_closed)\n                button_install_check_event_source(b);\n\n        return 0;\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <linux/input.h>\n\n#include \"sd-messages.h\"\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"logind-button.h\"\n#include \"missing_input.h\"\n#include \"string-util.h\"\n#include \"util.h\"\n\n#define CONST_MAX4(a, b, c, d) CONST_MAX(CONST_MAX(a, b), CONST_MAX(c, d))\n\n#define ULONG_BITS (sizeof(unsigned long)*8)\n\nstatic bool bitset_get(const unsigned long *bits, unsigned i) {\n        return (bits[i / ULONG_BITS] >> (i % ULONG_BITS)) & 1UL;\n}\n\nstatic void bitset_put(unsigned long *bits, unsigned i) {\n        bits[i / ULONG_BITS] |= (unsigned long) 1 << (i % ULONG_BITS);\n}\n\nButton* button_new(Manager *m, const char *name) {\n        Button *b;\n\n        assert(m);\n        assert(name);\n\n        b = new0(Button, 1);\n        if (!b)\n                return NULL;\n\n        b->name = strdup(name);\n        if (!b->name)\n                return mfree(b);\n\n        if (hashmap_put(m->buttons, b->name, b) < 0) {\n                free(b->name);\n                return mfree(b);\n        }\n\n        b->manager = m;\n        b->fd = -1;\n\n        return b;\n}\n\nvoid button_free(Button *b) {\n        assert(b);\n\n        hashmap_remove(b->manager->buttons, b->name);\n\n        sd_event_source_unref(b->io_event_source);\n        sd_event_source_unref(b->check_event_source);\n\n        if (b->fd >= 0)\n                /* If the device has been unplugged close() returns\n                 * ENODEV, let's ignore this, hence we don't use\n                 * safe_close() */\n                (void) close(b->fd);\n\n        free(b->name);\n        free(b->seat);\n        free(b);\n}\n\nint button_set_seat(Button *b, const char *sn) {\n        char *s;\n\n        assert(b);\n        assert(sn);\n\n        s = strdup(sn);\n        if (!s)\n                return -ENOMEM;\n\n        free(b->seat);\n        b->seat = s;\n\n        return 0;\n}\n\nstatic void button_lid_switch_handle_action(Manager *manager, bool is_edge) {\n        HandleAction handle_action;\n\n        assert(manager);\n\n        /* If we are docked or on external power, handle the lid switch\n         * differently */\n        if (manager_is_docked_or_external_displays(manager))\n                handle_action = manager->handle_lid_switch_docked;\n        else if (manager->handle_lid_switch_ep != _HANDLE_ACTION_INVALID &&\n                 manager_is_on_external_power())\n                handle_action = manager->handle_lid_switch_ep;\n        else\n                handle_action = manager->handle_lid_switch;\n\n        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge);\n}\n\nstatic int button_recheck(sd_event_source *e, void *userdata) {\n        Button *b = userdata;\n\n        assert(b);\n        assert(b->lid_closed);\n\n        button_lid_switch_handle_action(b->manager, false);\n        return 1;\n}\n\nstatic int button_install_check_event_source(Button *b) {\n        int r;\n        assert(b);\n\n        /* Install a post handler, so that we keep rechecking as long as the lid is closed. */\n\n        if (b->check_event_source)\n                return 0;\n\n        r = sd_event_add_post(b->manager->event, &b->check_event_source, button_recheck, b);\n        if (r < 0)\n                return r;\n\n        return sd_event_source_set_priority(b->check_event_source, SD_EVENT_PRIORITY_IDLE+1);\n}\n\nstatic int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *userdata) {\n        Button *b = userdata;\n        struct input_event ev;\n        ssize_t l;\n\n        assert(s);\n        assert(fd == b->fd);\n        assert(b);\n\n        l = read(b->fd, &ev, sizeof(ev));\n        if (l < 0)\n                return errno != EAGAIN ? -errno : 0;\n        if ((size_t) l < sizeof(ev))\n                return -EIO;\n\n        if (ev.type == EV_KEY && ev.value > 0) {\n\n                switch (ev.code) {\n\n                case KEY_POWER:\n                case KEY_POWER2:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Power key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_POWER_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);\n                        break;\n\n                /* The kernel is a bit confused here:\n\n                   KEY_SLEEP   = suspend-to-ram, which everybody else calls \"suspend\"\n                   KEY_SUSPEND = suspend-to-disk, which everybody else calls \"hibernate\"\n                */\n\n                case KEY_SLEEP:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Suspend key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SUSPEND_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);\n                        break;\n\n                case KEY_SUSPEND:\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Hibernate key pressed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_HIBERNATE_KEY_STR);\n\n                        manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);\n                        break;\n                }\n\n        } else if (ev.type == EV_SW && ev.value > 0) {\n\n                if (ev.code == SW_LID) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Lid closed.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_LID_CLOSED_STR);\n\n                        b->lid_closed = true;\n                        button_lid_switch_handle_action(b->manager, true);\n                        button_install_check_event_source(b);\n\n                } else if (ev.code == SW_DOCK) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"System docked.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SYSTEM_DOCKED_STR);\n\n                        b->docked = true;\n                }\n\n        } else if (ev.type == EV_SW && ev.value == 0) {\n\n                if (ev.code == SW_LID) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"Lid opened.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_LID_OPENED_STR);\n\n                        b->lid_closed = false;\n                        b->check_event_source = sd_event_source_unref(b->check_event_source);\n\n                } else if (ev.code == SW_DOCK) {\n                        log_struct(LOG_INFO,\n                                   LOG_MESSAGE(\"System undocked.\"),\n                                   \"MESSAGE_ID=\" SD_MESSAGE_SYSTEM_UNDOCKED_STR);\n\n                        b->docked = false;\n                }\n        }\n\n        return 0;\n}\n\nstatic int button_suitable(Button *b) {\n        unsigned long types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1];\n\n        assert(b);\n        assert(b->fd);\n\n        if (ioctl(b->fd, EVIOCGBIT(EV_SYN, sizeof(types)), types) < 0)\n                return -errno;\n\n        if (bitset_get(types, EV_KEY)) {\n                unsigned long keys[CONST_MAX4(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND)/ULONG_BITS+1];\n\n                if (ioctl(b->fd, EVIOCGBIT(EV_KEY, sizeof(keys)), keys) < 0)\n                        return -errno;\n\n                if (bitset_get(keys, KEY_POWER) ||\n                    bitset_get(keys, KEY_POWER2) ||\n                    bitset_get(keys, KEY_SLEEP) ||\n                    bitset_get(keys, KEY_SUSPEND))\n                        return true;\n        }\n\n        if (bitset_get(types, EV_SW)) {\n                unsigned long switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1];\n\n                if (ioctl(b->fd, EVIOCGBIT(EV_SW, sizeof(switches)), switches) < 0)\n                        return -errno;\n\n                if (bitset_get(switches, SW_LID) ||\n                    bitset_get(switches, SW_DOCK))\n                        return true;\n        }\n\n        return false;\n}\n\nstatic int button_set_mask(Button *b) {\n        unsigned long\n                types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1] = {},\n                keys[CONST_MAX4(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND)/ULONG_BITS+1] = {},\n                switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};\n        struct input_mask mask;\n\n        assert(b);\n        assert(b->fd >= 0);\n\n        bitset_put(types, EV_KEY);\n        bitset_put(types, EV_SW);\n\n        mask = (struct input_mask) {\n                .type = EV_SYN,\n                .codes_size = sizeof(types),\n                .codes_ptr = PTR_TO_UINT64(types),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                /* Log only at debug level if the kernel doesn't do EVIOCSMASK yet */\n                return log_full_errno(IN_SET(errno, ENOTTY, EOPNOTSUPP, EINVAL) ? LOG_DEBUG : LOG_WARNING,\n                                      errno, \"Failed to set EV_SYN event mask on /dev/input/%s: %m\", b->name);\n\n        bitset_put(keys, KEY_POWER);\n        bitset_put(keys, KEY_POWER2);\n        bitset_put(keys, KEY_SLEEP);\n        bitset_put(keys, KEY_SUSPEND);\n\n        mask = (struct input_mask) {\n                .type = EV_KEY,\n                .codes_size = sizeof(keys),\n                .codes_ptr = PTR_TO_UINT64(keys),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                return log_warning_errno(errno, \"Failed to set EV_KEY event mask on /dev/input/%s: %m\", b->name);\n\n        bitset_put(switches, SW_LID);\n        bitset_put(switches, SW_DOCK);\n\n        mask = (struct input_mask) {\n                .type = EV_SW,\n                .codes_size = sizeof(switches),\n                .codes_ptr = PTR_TO_UINT64(switches),\n        };\n\n        if (ioctl(b->fd, EVIOCSMASK, &mask) < 0)\n                return log_warning_errno(errno, \"Failed to set EV_SW event mask on /dev/input/%s: %m\", b->name);\n\n        return 0;\n}\n\nint button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n        \n        b->io_event_source = sd_event_source_unref(b->io_event_source);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}\n\nint button_check_switches(Button *b) {\n        unsigned long switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};\n        assert(b);\n\n        if (b->fd < 0)\n                return -EINVAL;\n\n        if (ioctl(b->fd, EVIOCGSW(sizeof(switches)), switches) < 0)\n                return -errno;\n\n        b->lid_closed = bitset_get(switches, SW_LID);\n        b->docked = bitset_get(switches, SW_DOCK);\n\n        if (b->lid_closed)\n                button_install_check_event_source(b);\n\n        return 0;\n}\n"], "filenames": ["src/login/logind-button.c"], "buggy_code_start_loc": [344], "buggy_code_end_loc": [345], "fixing_code_start_loc": [344], "fixing_code_end_loc": [346], "type": "CWE-401", "message": "An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.", "other": {"cve": {"id": "CVE-2019-20386", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-21T06:15:11.827", "lastModified": "2022-01-28T21:27:15.853", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur."}, {"lang": "es", "value": "Se detect\u00f3 un problema en la funci\u00f3n button_open en el archivo login/logind-button.c en systemd versiones anteriores a 243. Cuando se ejecuta el comando de activaci\u00f3n udevadm, puede presentarse una p\u00e9rdida de memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.4, "baseSeverity": "LOW"}, "exploitabilityScore": 0.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionEndExcluding": "243", "matchCriteriaId": "DC6B51EF-3387-492E-80C6-5C08DB04F146"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00014.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HZPCOMW5X6IZZXASCDD2CNW2DLF3YADC/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200210-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4269-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad"}}