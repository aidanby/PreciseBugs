{"buggy_code": ["<?php\n/*********************************************************************\n    class.email.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\ninclude_once INCLUDE_DIR.'class.role.php';\ninclude_once(INCLUDE_DIR.'class.dept.php');\ninclude_once(INCLUDE_DIR.'class.mailfetch.php');\n\nclass Email extends VerySimpleModel {\n    static $meta = array(\n        'table' => EMAIL_TABLE,\n        'pk' => array('email_id'),\n        'joins' => array(\n            'priority' => array(\n                'constraint' => array('priority_id' => 'Priority.priority_id'),\n                'null' => true,\n            ),\n            'dept' => array(\n                'constraint' => array('dept_id' => 'Dept.id'),\n                'null' => true,\n            ),\n            'topic' => array(\n                'constraint' => array('topic_id' => 'Topic.topic_id'),\n                'null' => true,\n            ),\n        )\n    );\n\n    const PERM_BANLIST = 'emails.banlist';\n\n    static protected $perms = array(\n            self::PERM_BANLIST => array(\n                'title' =>\n                /* @trans */ 'Banlist',\n                'desc'  =>\n                /* @trans */ 'Ability to add/remove emails from banlist via ticket interface',\n                'primary' => true,\n            ));\n\n\n    var $address;\n    var $mail_proto;\n\n    function getId() {\n        return $this->email_id;\n    }\n\n    function __toString() {\n        if ($this->name)\n            return sprintf('%s <%s>', $this->name, $this->email);\n\n        return $this->email;\n    }\n\n\n    function __onload() {\n        $this->mail_proto = $this->get('mail_protocol');\n        if ($this->mail_encryption == 'SSL')\n            $this->mail_proto .= \"/\".$this->mail_encryption;\n\n        $this->address=$this->name?($this->name.' <'.$this->email.'>'):$this->email;\n    }\n\n    function getEmail() {\n        return $this->email;\n    }\n\n    function getAddress() {\n        return $this->address;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getPriorityId() {\n        return $this->priority_id;\n    }\n\n    function getDeptId() {\n        return $this->dept_id;\n    }\n\n    function getDept() {\n        return $this->dept;\n    }\n\n    function getTopicId() {\n        return $this->topic_id;\n    }\n\n    function getTopic() {\n        return $this->topic;\n    }\n\n    function autoRespond() {\n        return !$this->noautoresp;\n    }\n\n    function getPasswd() {\n        if (!$this->userpass)\n            return '';\n        return Crypto::decrypt($this->userpass, SECRET_SALT, $this->userid);\n    }\n\n    function getSMTPPasswd() {\n        if (!$this->smtp_userpass)\n            return '';\n        return Crypto::decrypt($this->smtp_userpass, SECRET_SALT, $this->smtp_userid);\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        $base = $this->getHashtable();\n        $base['mail_proto'] = $this->mail_protocol;\n        if ($this->mail_encryption != 'NONE')\n          $base['mail_proto'] .= \"/{$this->mail_encryption}\";\n        return $base;\n    }\n\n    function getMailAccountInfo() {\n\n        /*NOTE: Do not change any of the tags - otherwise mail fetching will fail */\n        $info = array(\n                //Mail server info\n                'host'  => $this->mail_host,\n                'port'  => $this->mail_port,\n                'protocol'  => $this->mail_protocol,\n                'encryption' => $this->mail_encryption,\n                'username'  => $this->userid,\n                'password' => Crypto::decrypt($this->userpass, SECRET_SALT, $this->userid),\n                //osTicket specific\n                'email_id'  => $this->getId(), //Required for email routing to work.\n                'max_fetch' => $this->mail_fetchmax,\n                'folder' => $this->mail_folder,\n                'delete_mail' => $this->mail_delete,\n                'archive_folder' => $this->mail_archivefolder\n        );\n\n        return $info;\n    }\n\n    function isSMTPEnabled() {\n\n        return (\n                $this->smtp_active\n                    && ($info=$this->getSMTPInfo())\n                    && (!$info['auth'] || $info['password'])\n                );\n    }\n\n    function allowSpoofing() {\n        return ($this->smtp_spoofing);\n    }\n\n    function getSMTPInfo() {\n        $smtpcreds = $this->smtp_auth_creds;\n        $username = $smtpcreds ? $this->smtp_userid : $this->userid;\n        $passwd = $smtpcreds ? $this->smtp_userpass : $this->userpass;\n\n        $info = array (\n                'host' => $this->smtp_host,\n                'port' => $this->smtp_port,\n                'auth' => (bool) $this->smtp_auth,\n                'username' => $username,\n                'password' => Crypto::decrypt($passwd, SECRET_SALT, $username)\n                );\n\n        return $info;\n    }\n\n    function send($to, $subject, $message, $attachments=null, $options=null, $cc=array()) {\n\n        $mailer = new Mailer($this);\n        if($attachments)\n            $mailer->addAttachments($attachments);\n\n        return $mailer->send($to, $subject, $message, $options, $cc);\n    }\n\n    function sendAutoReply($to, $subject, $message, $attachments=null, $options=array()) {\n        $options+= array('autoreply' => true);\n        return $this->send($to, $subject, $message, $attachments, $options);\n    }\n\n    function sendAlert($to, $subject, $message, $attachments=null, $options=array()) {\n        $options+= array('notice' => true);\n        return $this->send($to, $subject, $message, $attachments, $options);\n    }\n\n   function delete() {\n        global $cfg;\n        //Make sure we are not trying to delete default emails.\n        if(!$cfg || $this->getId()==$cfg->getDefaultEmailId() || $this->getId()==$cfg->getAlertEmailId()) //double...double check.\n            return 0;\n\n        if (!parent::delete())\n            return false;\n\n        $type = array('type' => 'deleted');\n        Signal::send('object.deleted', $this, $type);\n\n        Dept::objects()\n            ->filter(array('email_id' => $this->getId()))\n            ->update(array(\n                'email_id' => $cfg->getDefaultEmailId()\n            ));\n\n        Dept::objects()\n            ->filter(array('autoresp_email_id' => $this->getId()))\n            ->update(array(\n                'autoresp_email_id' => 0,\n            ));\n\n        return true;\n    }\n\n\n    /******* Static functions ************/\n\n   static function getIdByEmail($email) {\n        $qs = static::objects()->filter(Q::any(array(\n                        'email'  => $email,\n                        'userid' => $email\n                        )))\n            ->values_flat('email_id');\n\n        $row = $qs->first();\n        return $row ? $row[0] : false;\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        $inst->created = SqlFunction::NOW();\n        return $inst;\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    function update($vars, &$errors=false) {\n        global $cfg;\n\n        // very basic checks\n        $vars['cpasswd']=$this->getPasswd(); //Current decrypted password.\n        $vars['smtp_cpasswd']=$this->getSMTPPasswd(); // Current decrypted SMTP password.\n        $vars['name']=Format::striptags(trim($vars['name']));\n        $vars['email']=trim($vars['email']);\n        $vars['mail_folder']=Format::striptags(trim($vars['mail_folder']));\n\n        $id = isset($this->email_id) ? $this->getId() : 0;\n        if($id && $id!=$vars['id'])\n            $errors['err']=__('Get technical help!')\n                .' '.__('Internal error occurred');\n\n        if(!$vars['email'] || !Validator::is_email($vars['email'])) {\n            $errors['email']=__('Valid email required');\n        }elseif(($eid=Email::getIdByEmail($vars['email'])) && $eid!=$id) {\n            $errors['email']=__('Email already exists');\n        }elseif($cfg && !strcasecmp($cfg->getAdminEmail(), $vars['email'])) {\n            $errors['email']=__('Email already used as admin email!');\n        }elseif(Staff::getIdByEmail($vars['email'])) { //make sure the email doesn't belong to any of the staff\n            $errors['email']=__('Email in use by an agent');\n        }\n\n        if(!$vars['name'])\n            $errors['name']=__('Email name required');\n\n        $dept = Dept::lookup($vars['dept_id']);\n        if($dept && !$dept->isActive())\n          $errors['dept_id'] = '';\n\n        $topic = Topic::lookup($vars['topic_id']);\n        if($topic && !$topic->isActive())\n          $errors['topic_id'] = '';\n\n        // Validate Credentials\n        if ($vars['mail_active'] || ($vars['smtp_active'] && $vars['smtp_auth']\n                && !$vars['smtp_auth_creds']))\n            $errors = self::validateCredentials($vars['userid'], $vars['passwd'], $id, $errors, false);\n\n        if ($vars['smtp_active'] && $vars['smtp_auth'] && $vars['smtp_auth_creds'])\n            $errors = self::validateCredentials($vars['smtp_userid'], $vars['smtp_passwd'], $id, $errors, true);\n\n        list($vars['mail_protocol'], $encryption) = explode('/', $vars['mail_proto']);\n        $vars['mail_encryption'] = $encryption ?: 'NONE';\n\n        if($vars['mail_active']) {\n            //Check pop/imapinfo only when enabled.\n            if(!function_exists('imap_open'))\n                $errors['mail_active']= __(\"IMAP doesn't exist. PHP must be compiled with IMAP enabled.\");\n            if(!$vars['mail_host'])\n                $errors['mail_host']=__('Host name required');\n            if(!$vars['mail_port'])\n                $errors['mail_port']=__('Port required');\n            if(!$vars['mail_protocol'])\n                $errors['mail_protocol']=__('Select protocol');\n            if(!$vars['mail_fetchfreq'] || !is_numeric($vars['mail_fetchfreq']))\n                $errors['mail_fetchfreq']=__('Fetch interval required');\n            if(!$vars['mail_fetchmax'] || !is_numeric($vars['mail_fetchmax']))\n                $errors['mail_fetchmax']=__('Maximum emails required');\n\n            if($vars['mail_protocol'] == 'POP' && !empty($vars['mail_folder']))\n                $errors['mail_folder'] = __('POP mail servers do not support folders');\n\n            if(!isset($vars['postfetch']))\n                $errors['postfetch']=__('Indicate what to do with fetched emails');\n            elseif(!strcasecmp($vars['postfetch'],'archive')) {\n                if ($vars['mail_protocol'] == 'POP')\n                    $errors['postfetch'] =  __('POP mail servers do not support folders');\n                elseif (!$vars['mail_archivefolder'])\n                    $errors['postfetch'] = __('Valid folder required');\n            }\n        }\n\n        if($vars['smtp_active']) {\n            if(!$vars['smtp_host'])\n                $errors['smtp_host']=__('Host name required');\n            if(!$vars['smtp_port'])\n                $errors['smtp_port']=__('Port required');\n        }\n\n        //abort on errors\n        if ($errors)\n            return false;\n\n        if(!$errors && ($vars['mail_host'] && $vars['userid'])) {\n            $existing = static::objects()\n                ->filter(array(\n                    'mail_host' => $vars['mail_host'],\n                    'userid' => $vars['userid']\n                ));\n\n            if ($id)\n                $existing->exclude(array('email_id' => $id));\n\n            if ($existing->exists())\n                $errors['userid']=$errors['host']=__('Host/userid combination already in use.');\n        }\n\n        $passwd = $vars['passwd'] ?: $vars['cpasswd'];\n        if(!$errors && $vars['mail_active']) {\n            //note: password is unencrypted at this point...MailFetcher expect plain text.\n            $fetcher = new MailFetcher(\n                    array(\n                        'host'  => $vars['mail_host'],\n                        'port'  => $vars['mail_port'],\n                        'folder' => $vars['mail_folder'],\n                        'username'  => $vars['userid'],\n                        'password'  => $passwd,\n                        'protocol'  => $vars['mail_protocol'],\n                        'encryption' => $vars['mail_encryption'])\n                    );\n            if(!$fetcher->connect()) {\n                //$errors['err']='Invalid login. Check '.Format::htmlchars($vars['mail_protocol']).' settings';\n                $errors['err']=sprintf(__('Invalid login. Check %s settings'),Format::htmlchars($vars['mail_protocol']));\n                $errors['mail']='<br>'.$fetcher->getLastError();\n            } elseif ($vars['mail_folder'] && !$fetcher->checkMailbox($vars['mail_folder'],true)) {\n                 $errors['mail_folder']=sprintf(__('Invalid or unknown mail folder! >> %s'),$fetcher->getLastError());\n                 if(!$errors['mail'])\n                     $errors['mail']=__('Invalid or unknown mail folder!');\n            }elseif($vars['mail_archivefolder'] && !$fetcher->checkMailbox($vars['mail_archivefolder'],true)) {\n                 //$errors['postfetch']='Invalid or unknown mail folder! >> '.$fetcher->getLastError().'';\n                 $errors['postfetch']=sprintf(__('Invalid or unknown mail folder! >> %s'),$fetcher->getLastError());\n                 if(!$errors['mail'])\n                     $errors['mail']=__('Invalid or unknown archive folder!');\n            }\n        }\n\n        $smtppasswd = $vars['smtp_passwd'] ?: $vars['smtp_cpasswd'];\n        if(!$errors && $vars['smtp_active']) { //Check SMTP login only.\n            $smtpcreds = $vars['smtp_auth_creds'];\n            require_once 'Mail.php'; // PEAR Mail package\n            $smtp = mail::factory('smtp',\n                    array ('host' => $vars['smtp_host'],\n                           'port' => $vars['smtp_port'],\n                           'auth' => (bool) $vars['smtp_auth'],\n                           'username' => $smtpcreds ? $vars['smtp_userid'] : $vars['userid'],\n                           'password' => $smtpcreds ? $smtppasswd : $passwd,\n                           'timeout'  =>20,\n                           'debug' => false,\n                           ));\n            $mail = $smtp->connect();\n            if(PEAR::isError($mail)) {\n                $errors['err']=__('Unable to log in. Check SMTP settings.');\n                $errors['smtp']='<br>'.$mail->getMessage();\n            }else{\n                $smtp->disconnect(); //Thank you, sir!\n            }\n        }\n\n        if($errors) return false;\n\n        $this->mail_errors = 0;\n        $this->mail_lastfetch = null;\n        $this->email = $vars['email'];\n        $this->name = Format::striptags($vars['name']);\n        $this->dept_id = $vars['dept_id'];\n        $this->priority_id = $vars['priority_id'];\n        $this->topic_id = $vars['topic_id'];\n        $this->noautoresp = $vars['noautoresp'];\n        $this->userid = $vars['userid'];\n        $this->mail_active = $vars['mail_active'];\n        $this->mail_host = $vars['mail_host'];\n        $this->mail_folder = $vars['mail_folder'] ?: null;\n        $this->mail_protocol = $vars['mail_protocol'] ?: 'POP';\n        $this->mail_encryption = $vars['mail_encryption'];\n        $this->mail_port = $vars['mail_port'] ?: 0;\n        $this->mail_fetchfreq = $vars['mail_fetchfreq'] ?: 0;\n        $this->mail_fetchmax = $vars['mail_fetchmax'] ?: 0;\n        $this->smtp_active = $vars['smtp_active'];\n        $this->smtp_host = $vars['smtp_host'];\n        $this->smtp_port = $vars['smtp_port'] ?: 0;\n        $this->smtp_auth = $vars['smtp_auth'];\n        $this->smtp_auth_creds = isset($vars['smtp_auth_creds']) ? 1 : 0;\n        $this->smtp_userid = $vars['smtp_userid'];\n        $this->smtp_spoofing = $vars['smtp_spoofing'];\n        $this->notes = Format::sanitize($vars['notes']);\n\n        //Post fetch email handling...\n        if ($vars['postfetch'] && !strcasecmp($vars['postfetch'],'delete')) {\n            $this->mail_delete = 1;\n            $this->mail_archivefolder = null;\n        }\n        elseif($vars['postfetch'] && !strcasecmp($vars['postfetch'],'archive') && $vars['mail_archivefolder']) {\n            $this->mail_delete = 0;\n            $this->mail_archivefolder = $vars['mail_archivefolder'];\n        }\n        else {\n            $this->mail_delete = 0;\n            $this->mail_archivefolder = null;\n        }\n\n        if ($vars['passwd']) //New password - encrypt.\n            $this->userpass = Crypto::encrypt($vars['passwd'],SECRET_SALT, $vars['userid']);\n\n        if ($vars['smtp_passwd']) // New SMTP password - encrypt.\n            $this->smtp_userpass = Crypto::encrypt($vars['smtp_passwd'], SECRET_SALT, $vars['smtp_userid']);\n\n        if ($this->save())\n            return true;\n\n        if ($id) { //update\n            $errors['err']=sprintf(__('Unable to update %s.'), __('this email'))\n               .' '.__('Internal error occurred');\n        }\n        else {\n            $errors['err']=sprintf(__('Unable to add %s.'), __('this email'))\n               .' '.__('Internal error occurred');\n        }\n\n        return false;\n    }\n\n    static function validateCredentials(?string $username=null, ?string $password=null, ?int $id=null, &$errors, $smtp=false) {\n        if (!$username)\n            $errors[$smtp ? 'smtp_userid' : 'userid'] = __('Username missing');\n\n        if (!$id && !$password)\n            $errors[$smtp ? 'smtp_passwd' : 'passwd'] = __('Password Required');\n        elseif ($password && $username\n                && !Crypto::encrypt($password, SECRET_SALT, $username))\n            $errors[$smtp ? 'smtp_passwd' : 'passwd'] = sprintf('%s - %s', __('Unable to encrypt password'), __('Get technical help!'));\n\n        return $errors;\n    }\n\n    static function getPermissions() {\n        return self::$perms;\n    }\n\n    static function getAddresses($options=array(), $flat=true) {\n        $objects = static::objects();\n        if ($options['smtp'])\n            $objects = $objects->filter(array('smtp_active'=>true));\n\n        if ($options['depts'])\n            $objects = $objects->filter(array('dept_id__in'=>$options['depts']));\n\n        if (!$flat)\n            return $objects;\n\n        $addresses = array();\n        foreach ($objects->values_flat('email_id', 'email') as $row) {\n            list($id, $email) = $row;\n            $addresses[$id] = $email;\n        }\n        return $addresses;\n    }\n}\nRolePermission::register(/* @trans */ 'Miscellaneous', Email::getPermissions());\n?>\n"], "fixing_code": ["<?php\n/*********************************************************************\n    class.email.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\ninclude_once INCLUDE_DIR.'class.role.php';\ninclude_once(INCLUDE_DIR.'class.dept.php');\ninclude_once(INCLUDE_DIR.'class.mailfetch.php');\n\nclass Email extends VerySimpleModel {\n    static $meta = array(\n        'table' => EMAIL_TABLE,\n        'pk' => array('email_id'),\n        'joins' => array(\n            'priority' => array(\n                'constraint' => array('priority_id' => 'Priority.priority_id'),\n                'null' => true,\n            ),\n            'dept' => array(\n                'constraint' => array('dept_id' => 'Dept.id'),\n                'null' => true,\n            ),\n            'topic' => array(\n                'constraint' => array('topic_id' => 'Topic.topic_id'),\n                'null' => true,\n            ),\n        )\n    );\n\n    const PERM_BANLIST = 'emails.banlist';\n\n    static protected $perms = array(\n            self::PERM_BANLIST => array(\n                'title' =>\n                /* @trans */ 'Banlist',\n                'desc'  =>\n                /* @trans */ 'Ability to add/remove emails from banlist via ticket interface',\n                'primary' => true,\n            ));\n\n\n    var $address;\n    var $mail_proto;\n\n    function getId() {\n        return $this->email_id;\n    }\n\n    function __toString() {\n        if ($this->name)\n            return sprintf('%s <%s>', $this->name, $this->email);\n\n        return $this->email;\n    }\n\n\n    function __onload() {\n        $this->mail_proto = $this->get('mail_protocol');\n        if ($this->mail_encryption == 'SSL')\n            $this->mail_proto .= \"/\".$this->mail_encryption;\n\n        $this->address=$this->name?($this->name.' <'.$this->email.'>'):$this->email;\n    }\n\n    function getEmail() {\n        return $this->email;\n    }\n\n    function getAddress() {\n        return $this->address;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getPriorityId() {\n        return $this->priority_id;\n    }\n\n    function getDeptId() {\n        return $this->dept_id;\n    }\n\n    function getDept() {\n        return $this->dept;\n    }\n\n    function getTopicId() {\n        return $this->topic_id;\n    }\n\n    function getTopic() {\n        return $this->topic;\n    }\n\n    function autoRespond() {\n        return !$this->noautoresp;\n    }\n\n    function getPasswd() {\n        if (!$this->userpass)\n            return '';\n        return Crypto::decrypt($this->userpass, SECRET_SALT, $this->userid);\n    }\n\n    function getSMTPPasswd() {\n        if (!$this->smtp_userpass)\n            return '';\n        return Crypto::decrypt($this->smtp_userpass, SECRET_SALT, $this->smtp_userid);\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        $base = $this->getHashtable();\n        $base['mail_proto'] = $this->mail_protocol;\n        if ($this->mail_encryption != 'NONE')\n          $base['mail_proto'] .= \"/{$this->mail_encryption}\";\n        return $base;\n    }\n\n    function getMailAccountInfo() {\n\n        /*NOTE: Do not change any of the tags - otherwise mail fetching will fail */\n        $info = array(\n                //Mail server info\n                'host'  => $this->mail_host,\n                'port'  => $this->mail_port,\n                'protocol'  => $this->mail_protocol,\n                'encryption' => $this->mail_encryption,\n                'username'  => $this->userid,\n                'password' => Crypto::decrypt($this->userpass, SECRET_SALT, $this->userid),\n                //osTicket specific\n                'email_id'  => $this->getId(), //Required for email routing to work.\n                'max_fetch' => $this->mail_fetchmax,\n                'folder' => $this->mail_folder,\n                'delete_mail' => $this->mail_delete,\n                'archive_folder' => $this->mail_archivefolder\n        );\n\n        return $info;\n    }\n\n    function isSMTPEnabled() {\n\n        return (\n                $this->smtp_active\n                    && ($info=$this->getSMTPInfo())\n                    && (!$info['auth'] || $info['password'])\n                );\n    }\n\n    function allowSpoofing() {\n        return ($this->smtp_spoofing);\n    }\n\n    function getSMTPInfo() {\n        $smtpcreds = $this->smtp_auth_creds;\n        $username = $smtpcreds ? $this->smtp_userid : $this->userid;\n        $passwd = $smtpcreds ? $this->smtp_userpass : $this->userpass;\n\n        $info = array (\n                'host' => $this->smtp_host,\n                'port' => $this->smtp_port,\n                'auth' => (bool) $this->smtp_auth,\n                'username' => $username,\n                'password' => Crypto::decrypt($passwd, SECRET_SALT, $username)\n                );\n\n        return $info;\n    }\n\n    function send($to, $subject, $message, $attachments=null, $options=null, $cc=array()) {\n\n        $mailer = new Mailer($this);\n        if($attachments)\n            $mailer->addAttachments($attachments);\n\n        return $mailer->send($to, $subject, $message, $options, $cc);\n    }\n\n    function sendAutoReply($to, $subject, $message, $attachments=null, $options=array()) {\n        $options+= array('autoreply' => true);\n        return $this->send($to, $subject, $message, $attachments, $options);\n    }\n\n    function sendAlert($to, $subject, $message, $attachments=null, $options=array()) {\n        $options+= array('notice' => true);\n        return $this->send($to, $subject, $message, $attachments, $options);\n    }\n\n   function delete() {\n        global $cfg;\n        //Make sure we are not trying to delete default emails.\n        if(!$cfg || $this->getId()==$cfg->getDefaultEmailId() || $this->getId()==$cfg->getAlertEmailId()) //double...double check.\n            return 0;\n\n        if (!parent::delete())\n            return false;\n\n        $type = array('type' => 'deleted');\n        Signal::send('object.deleted', $this, $type);\n\n        Dept::objects()\n            ->filter(array('email_id' => $this->getId()))\n            ->update(array(\n                'email_id' => $cfg->getDefaultEmailId()\n            ));\n\n        Dept::objects()\n            ->filter(array('autoresp_email_id' => $this->getId()))\n            ->update(array(\n                'autoresp_email_id' => 0,\n            ));\n\n        return true;\n    }\n\n\n    /******* Static functions ************/\n\n   static function getIdByEmail($email) {\n        $qs = static::objects()->filter(Q::any(array(\n                        'email'  => $email,\n                        'userid' => $email\n                        )))\n            ->values_flat('email_id');\n\n        $row = $qs->first();\n        return $row ? $row[0] : false;\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        $inst->created = SqlFunction::NOW();\n        return $inst;\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    function update($vars, &$errors=false) {\n        global $cfg;\n\n        // very basic checks\n        $vars['cpasswd']=$this->getPasswd(); //Current decrypted password.\n        $vars['smtp_cpasswd']=$this->getSMTPPasswd(); // Current decrypted SMTP password.\n        $vars['name']=Format::striptags(trim($vars['name']));\n        $vars['email']=trim($vars['email']);\n        $vars['mail_folder']=Format::striptags(trim($vars['mail_folder']));\n\n        $id = isset($this->email_id) ? $this->getId() : 0;\n        if($id && $id!=$vars['id'])\n            $errors['err']=__('Get technical help!')\n                .' '.__('Internal error occurred');\n\n        if(!$vars['email'] || !Validator::is_email($vars['email'])) {\n            $errors['email']=__('Valid email required');\n        }elseif(($eid=Email::getIdByEmail($vars['email'])) && $eid!=$id) {\n            $errors['email']=__('Email already exists');\n        }elseif($cfg && !strcasecmp($cfg->getAdminEmail(), $vars['email'])) {\n            $errors['email']=__('Email already used as admin email!');\n        }elseif(Staff::getIdByEmail($vars['email'])) { //make sure the email doesn't belong to any of the staff\n            $errors['email']=__('Email in use by an agent');\n        }\n\n        if(!$vars['name'])\n            $errors['name']=__('Email name required');\n\n        $dept = Dept::lookup($vars['dept_id']);\n        if($dept && !$dept->isActive())\n          $errors['dept_id'] = '';\n\n        $topic = Topic::lookup($vars['topic_id']);\n        if($topic && !$topic->isActive())\n          $errors['topic_id'] = '';\n\n        // Validate Credentials\n        if ($vars['mail_active'] || ($vars['smtp_active'] && $vars['smtp_auth']\n                && !$vars['smtp_auth_creds']))\n            $errors = self::validateCredentials($vars['userid'], $vars['passwd'], $id, $errors, false);\n\n        if ($vars['smtp_active'] && $vars['smtp_auth'] && $vars['smtp_auth_creds'])\n            $errors = self::validateCredentials($vars['smtp_userid'], $vars['smtp_passwd'], $id, $errors, true);\n\n        list($vars['mail_protocol'], $encryption) = explode('/', $vars['mail_proto']);\n        $vars['mail_encryption'] = $encryption ?: 'NONE';\n\n        if($vars['mail_active']) {\n            //Check pop/imapinfo only when enabled.\n            if(!function_exists('imap_open'))\n                $errors['mail_active']= __(\"IMAP doesn't exist. PHP must be compiled with IMAP enabled.\");\n            if(!$vars['mail_host'])\n                $errors['mail_host']=__('Host name required');\n            if(!$vars['mail_port'])\n                $errors['mail_port']=__('Port required');\n            if(!$vars['mail_protocol'])\n                $errors['mail_protocol']=__('Select protocol');\n            if(!$vars['mail_fetchfreq'] || !is_numeric($vars['mail_fetchfreq']))\n                $errors['mail_fetchfreq']=__('Fetch interval required');\n            if(!$vars['mail_fetchmax'] || !is_numeric($vars['mail_fetchmax']))\n                $errors['mail_fetchmax']=__('Maximum emails required');\n\n            if($vars['mail_protocol'] == 'POP' && !empty($vars['mail_folder']))\n                $errors['mail_folder'] = __('POP mail servers do not support folders');\n\n            if(!isset($vars['postfetch']))\n                $errors['postfetch']=__('Indicate what to do with fetched emails');\n            elseif(!strcasecmp($vars['postfetch'],'archive')) {\n                if ($vars['mail_protocol'] == 'POP')\n                    $errors['postfetch'] =  __('POP mail servers do not support folders');\n                elseif (!$vars['mail_archivefolder'])\n                    $errors['postfetch'] = __('Valid folder required');\n            }\n        }\n\n        if($vars['smtp_active']) {\n            if(!$vars['smtp_host'])\n                $errors['smtp_host']=__('Host name required');\n            if(!$vars['smtp_port'])\n                $errors['smtp_port']=__('Port required');\n        }\n\n        //abort on errors\n        if ($errors)\n            return false;\n\n        if(!$errors && ($vars['mail_host'] && $vars['userid'])) {\n            $existing = static::objects()\n                ->filter(array(\n                    'mail_host' => $vars['mail_host'],\n                    'userid' => $vars['userid']\n                ));\n\n            if ($id)\n                $existing->exclude(array('email_id' => $id));\n\n            if ($existing->exists())\n                $errors['userid']=$errors['host']=__('Host/userid combination already in use.');\n        }\n\n        $passwd = $vars['passwd'] ?: $vars['cpasswd'];\n        if(!$errors && $vars['mail_active']) {\n            //note: password is unencrypted at this point...MailFetcher expect plain text.\n            $fetcher = new MailFetcher(\n                    array(\n                        'host'  => $vars['mail_host'],\n                        'port'  => $vars['mail_port'],\n                        'folder' => $vars['mail_folder'],\n                        'username'  => $vars['userid'],\n                        'password'  => $passwd,\n                        'protocol'  => $vars['mail_protocol'],\n                        'encryption' => $vars['mail_encryption'])\n                    );\n            if(!$fetcher->connect()) {\n                //$errors['err']='Invalid login. Check '.Format::htmlchars($vars['mail_protocol']).' settings';\n                $errors['err']=sprintf(__('Invalid login. Check %s settings'),Format::htmlchars($vars['mail_protocol']));\n                $errors['mail']='<br>'.$fetcher->getLastError();\n            } elseif ($vars['mail_folder'] && !$fetcher->checkMailbox($vars['mail_folder'],true)) {\n                 $errors['mail_folder']=sprintf(__('Invalid or unknown mail folder! >> %s'),$fetcher->getLastError());\n                 if(!$errors['mail'])\n                     $errors['mail']=__('Invalid or unknown mail folder!');\n            }elseif($vars['mail_archivefolder'] && !$fetcher->checkMailbox($vars['mail_archivefolder'],true)) {\n                 //$errors['postfetch']='Invalid or unknown mail folder! >> '.$fetcher->getLastError().'';\n                 $errors['postfetch']=sprintf(__('Invalid or unknown mail folder! >> %s'),$fetcher->getLastError());\n                 if(!$errors['mail'])\n                     $errors['mail']=__('Invalid or unknown archive folder!');\n            }\n        }\n\n        $smtppasswd = $vars['smtp_passwd'] ?: $vars['smtp_cpasswd'];\n        if(!$errors && $vars['smtp_active']) { //Check SMTP login only.\n            $smtpcreds = $vars['smtp_auth_creds'];\n            require_once 'Mail.php'; // PEAR Mail package\n            $smtp = mail::factory('smtp',\n                    array ('host' => $vars['smtp_host'],\n                           'port' => $vars['smtp_port'],\n                           'auth' => (bool) $vars['smtp_auth'],\n                           'username' => $smtpcreds ? $vars['smtp_userid'] : $vars['userid'],\n                           'password' => $smtpcreds ? $smtppasswd : $passwd,\n                           'timeout'  =>20,\n                           'debug' => false,\n                           ));\n            $mail = $smtp->connect();\n            if(PEAR::isError($mail)) {\n                $errors['err']=__('Unable to log in. Check SMTP settings.');\n                $errors['smtp']='<br>'.$mail->getMessage();\n            }else{\n                $smtp->disconnect(); //Thank you, sir!\n            }\n        }\n\n        if($errors) return false;\n\n        $this->mail_errors = 0;\n        $this->mail_lastfetch = null;\n        $this->email = Format::sanitize($vars['email']);\n        $this->name = Format::striptags($vars['name']);\n        $this->dept_id = (int) $vars['dept_id'];\n        $this->priority_id = (int) (isset($vars['priority_id']) ? $vars['priority_id'] : 0);\n        $this->topic_id = (int) $vars['topic_id'];\n        $this->noautoresp = (int) $vars['noautoresp'];\n        $this->userid = $vars['userid'];\n        $this->mail_active = $vars['mail_active'];\n        $this->mail_host = $vars['mail_host'];\n        $this->mail_folder = $vars['mail_folder'] ?: null;\n        $this->mail_protocol = $vars['mail_protocol'] ?: 'POP';\n        $this->mail_encryption = $vars['mail_encryption'];\n        $this->mail_port = $vars['mail_port'] ?: 0;\n        $this->mail_fetchfreq = $vars['mail_fetchfreq'] ?: 0;\n        $this->mail_fetchmax = $vars['mail_fetchmax'] ?: 0;\n        $this->smtp_active = $vars['smtp_active'];\n        $this->smtp_host = $vars['smtp_host'];\n        $this->smtp_port = $vars['smtp_port'] ?: 0;\n        $this->smtp_auth = $vars['smtp_auth'];\n        $this->smtp_auth_creds = isset($vars['smtp_auth_creds']) ? 1 : 0;\n        $this->smtp_userid = $vars['smtp_userid'];\n        $this->smtp_spoofing = $vars['smtp_spoofing'];\n        $this->notes = Format::sanitize($vars['notes']);\n\n        //Post fetch email handling...\n        if ($vars['postfetch'] && !strcasecmp($vars['postfetch'],'delete')) {\n            $this->mail_delete = 1;\n            $this->mail_archivefolder = null;\n        }\n        elseif($vars['postfetch'] && !strcasecmp($vars['postfetch'],'archive') && $vars['mail_archivefolder']) {\n            $this->mail_delete = 0;\n            $this->mail_archivefolder = $vars['mail_archivefolder'];\n        }\n        else {\n            $this->mail_delete = 0;\n            $this->mail_archivefolder = null;\n        }\n\n        if ($vars['passwd']) //New password - encrypt.\n            $this->userpass = Crypto::encrypt($vars['passwd'],SECRET_SALT, $vars['userid']);\n\n        if ($vars['smtp_passwd']) // New SMTP password - encrypt.\n            $this->smtp_userpass = Crypto::encrypt($vars['smtp_passwd'], SECRET_SALT, $vars['smtp_userid']);\n\n        if ($this->save())\n            return true;\n\n        if ($id) { //update\n            $errors['err']=sprintf(__('Unable to update %s.'), __('this email'))\n               .' '.__('Internal error occurred');\n        }\n        else {\n            $errors['err']=sprintf(__('Unable to add %s.'), __('this email'))\n               .' '.__('Internal error occurred');\n        }\n\n        return false;\n    }\n\n    static function validateCredentials(?string $username=null, ?string $password=null, ?int $id=null, &$errors, $smtp=false) {\n        if (!$username)\n            $errors[$smtp ? 'smtp_userid' : 'userid'] = __('Username missing');\n\n        if (!$id && !$password)\n            $errors[$smtp ? 'smtp_passwd' : 'passwd'] = __('Password Required');\n        elseif ($password && $username\n                && !Crypto::encrypt($password, SECRET_SALT, $username))\n            $errors[$smtp ? 'smtp_passwd' : 'passwd'] = sprintf('%s - %s', __('Unable to encrypt password'), __('Get technical help!'));\n\n        return $errors;\n    }\n\n    static function getPermissions() {\n        return self::$perms;\n    }\n\n    static function getAddresses($options=array(), $flat=true) {\n        $objects = static::objects();\n        if ($options['smtp'])\n            $objects = $objects->filter(array('smtp_active'=>true));\n\n        if ($options['depts'])\n            $objects = $objects->filter(array('dept_id__in'=>$options['depts']));\n\n        if (!$flat)\n            return $objects;\n\n        $addresses = array();\n        foreach ($objects->values_flat('email_id', 'email') as $row) {\n            list($id, $email) = $row;\n            $addresses[$id] = $email;\n        }\n        return $addresses;\n    }\n}\nRolePermission::register(/* @trans */ 'Miscellaneous', Email::getPermissions());\n?>\n"], "filenames": ["include/class.email.php"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [417], "fixing_code_start_loc": [411], "fixing_code_end_loc": [417], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository osticket/osticket prior to v1.16.6.", "other": {"cve": {"id": "CVE-2023-1316", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-10T16:15:10.697", "lastModified": "2023-03-13T03:46:22.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository osticket/osticket prior to v1.16.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enhancesoft:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.6", "matchCriteriaId": "2B613AD0-4A4B-4AE9-8971-66464AEE67B6"}]}]}], "references": [{"url": "https://github.com/osticket/osticket/commit/091ddba965132d26bdbeb004fcc44bd8fd056b71", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/c6353bab-c382-47f6-937b-56d253f2e8d3", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osticket/osticket/commit/091ddba965132d26bdbeb004fcc44bd8fd056b71"}}