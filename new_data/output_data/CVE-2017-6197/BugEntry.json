{"buggy_code": ["# Uncrustify 0.64_d\n\n# This section made by hand\nnl_if_brace                     = remove\nmod_full_brace_if               = force\n\nnewlines                        = auto\ninput_tab_size                  = 8\noutput_tab_size                 = 8\nsp_arith                        = Force\nsp_assign                       = Force\nsp_after_ptr_star               = Remove\nsp_after_ptr_star_func          = Remove\nsp_before_ptr_star_func         = Force\nsp_before_ptr_star              = Remove\nsp_after_cast                   = Force\nsp_func_call_user_paren         = Remove\nsp_func_call_paren              = Force\nset func_call_user Elf_\n\n# auto detected, move customize above this line\nstring_escape_char              = 92\nstring_escape_char2             = 0\nstring_replace_tab_chars        = false\ntok_split_gte                   = false\ndisable_processing_cmt          = \"\"\nenable_processing_cmt           = \"\"\nenable_digraphs                 = false\nutf8_bom                        = ignore\nutf8_byte                       = false\nutf8_force                      = false\nindent_columns                  = 8\nindent_continue                 = 0\nindent_with_tabs                = 1\nindent_cmt_with_tabs            = false\nindent_align_string             = false\nindent_xml_string               = 0\nindent_brace                    = 0\nindent_braces                   = false\nindent_braces_no_func           = false\nindent_braces_no_class          = false\nindent_braces_no_struct         = false\nindent_brace_parent             = false\nindent_paren_open_brace         = false\nindent_cs_delegate_brace        = false\nindent_namespace                = false\nindent_namespace_single_indent  = false\nindent_namespace_level          = 0\nindent_namespace_limit          = 0\nindent_extern                   = false\nindent_class                    = false\nindent_class_colon              = false\nindent_class_on_colon           = false\nindent_constr_colon             = false\nindent_ctor_init_leading        = 2\nindent_ctor_init                = 0\nindent_else_if                  = false\nindent_var_def_blk              = 0\nindent_var_def_cont             = false\nindent_shift                    = false\nindent_func_def_force_col1      = false\nindent_func_call_param          = true\nindent_func_def_param           = false\nindent_func_proto_param         = false\nindent_func_class_param         = false\nindent_func_ctor_var_param      = false\nindent_template_param           = false\nindent_func_param_double        = false\nindent_func_const               = 0\nindent_func_throw               = 0\nindent_member                   = 0\nindent_sing_line_comments       = 0\nindent_relative_single_line_comments = false\nindent_switch_case              = 0\nindent_case_shift               = 0\nindent_case_brace               = 0\nindent_col1_comment             = false\nindent_label                    = 1 \nindent_access_spec              = 1\nindent_access_spec_body         = false\nindent_paren_nl                 = false\nindent_paren_close              = 0\nindent_comma_paren              = false\nindent_bool_paren               = false\nindent_first_bool_expr          = false\nindent_square_nl                = false\nindent_preserve_sql             = false\nindent_align_assign             = true\nindent_oc_block                 = false\nindent_oc_block_msg             = 0\nindent_oc_msg_colon             = 0\nindent_oc_msg_prioritize_first_colon = true\nindent_oc_block_msg_xcode_style = false\nindent_oc_block_msg_from_keyword = false\nindent_oc_block_msg_from_colon  = false\nindent_oc_block_msg_from_caret  = false\nindent_oc_block_msg_from_brace  = false\nindent_min_vbrace_open          = 0\nindent_vbrace_open_on_tabstop   = false\nindent_token_after_brace        = true\nindent_cpp_lambda_body          = false\n\nsp_cpp_lambda_assign            = ignore\nsp_cpp_lambda_paren             = ignore\nsp_assign_default               = force\nsp_before_assign                = force\nsp_after_assign                 = force\nsp_enum_paren                   = ignore\nsp_enum_assign                  = ignore\nsp_enum_before_assign           = ignore\nsp_enum_after_assign            = ignore\nsp_pp_concat                    = add\nsp_pp_stringify                 = ignore\nsp_before_pp_stringify          = ignore\nsp_bool                         = force\nsp_compare                      = force\nsp_inside_paren                 = remove\nsp_paren_paren                  = remove\nsp_cparen_oparen                = ignore\nsp_balance_nested_parens        = false\nsp_paren_brace                  = ignore\nsp_before_ptr_star              = add\nsp_before_unnamed_ptr_star      = ignore\nsp_between_ptr_star             = remove\nsp_after_ptr_star_qualifier     = ignore\nsp_ptr_star_paren               = ignore\nsp_before_byref                 = ignore\nsp_before_unnamed_byref         = ignore\nsp_after_byref                  = ignore\nsp_after_byref_func             = ignore\nsp_before_byref_func            = ignore\nsp_after_type                   = force\nsp_before_template_paren        = ignore\nsp_template_angle               = ignore\nsp_before_angle                 = ignore\nsp_inside_angle                 = ignore\nsp_after_angle                  = ignore\nsp_angle_paren                  = ignore\nsp_angle_paren_empty            = ignore\nsp_angle_word                   = ignore\nsp_angle_shift                  = add\nsp_permit_cpp11_shift           = false\nsp_before_sparen                = ignore\nsp_inside_sparen                = remove\nsp_inside_sparen_close          = ignore\nsp_inside_sparen_open           = ignore\nsp_after_sparen                 = ignore\nsp_sparen_brace                 = ignore\nsp_invariant_paren              = ignore\nsp_after_invariant_paren        = ignore\nsp_special_semi                 = ignore\nsp_before_semi                  = remove\nsp_before_semi_for              = ignore\nsp_before_semi_for_empty        = ignore\nsp_after_semi                   = add\nsp_after_semi_for               = force\nsp_after_semi_for_empty         = remove\nsp_before_square                = ignore\nsp_before_squares               = remove\nsp_inside_square                = remove\nsp_after_comma                  = ignore\nsp_before_comma                 = remove\nsp_after_mdatype_commas         = ignore\nsp_before_mdatype_commas        = ignore\nsp_between_mdatype_commas       = ignore\nsp_paren_comma                  = force\nsp_before_ellipsis              = ignore\nsp_after_class_colon            = ignore\nsp_before_class_colon           = ignore\nsp_after_constr_colon           = ignore\nsp_before_constr_colon          = ignore\nsp_before_case_colon            = remove\nsp_after_operator               = ignore\nsp_after_operator_sym           = ignore\nsp_after_operator_sym_empty     = ignore\nsp_inside_paren_cast            = ignore\nsp_cpp_cast_paren               = ignore\nsp_sizeof_paren                 = ignore\nsp_after_tag                    = ignore\nsp_inside_braces_enum           = ignore\nsp_inside_braces_struct         = ignore\nsp_inside_braces                = ignore\nsp_inside_braces_empty          = remove\nsp_type_func                    = ignore\nsp_func_proto_paren             = ignore\nsp_func_proto_paren_empty       = ignore\nsp_func_def_paren               = ignore\nsp_func_def_paren_empty         = ignore\nsp_inside_fparens               = ignore\nsp_inside_fparen                = ignore\nsp_inside_tparen                = ignore\nsp_after_tparen_close           = ignore\nsp_square_fparen                = ignore\nsp_fparen_brace                 = ignore\nsp_fparen_dbrace                = ignore\nsp_func_call_paren_empty        = ignore\nsp_func_class_paren             = ignore\nsp_func_class_paren_empty       = ignore\nsp_return_paren                 = ignore\nsp_attribute_paren              = ignore\nsp_defined_paren                = ignore\nsp_throw_paren                  = ignore\nsp_after_throw                  = ignore\nsp_catch_paren                  = ignore\nsp_version_paren                = ignore\nsp_scope_paren                  = ignore\nsp_super_paren                  = remove\nsp_this_paren                   = remove\nsp_macro                        = ignore\nsp_macro_func                   = ignore\nsp_else_brace                   = force\nsp_brace_else                   = ignore\nsp_brace_typedef                = ignore\nsp_catch_brace                  = ignore\nsp_brace_catch                  = ignore\nsp_finally_brace                = ignore\nsp_brace_finally                = ignore\nsp_try_brace                    = ignore\nsp_getset_brace                 = ignore\nsp_word_brace                   = add\nsp_word_brace_ns                = add\nsp_before_dc                    = ignore\nsp_after_dc                     = ignore\nsp_d_array_colon                = ignore\nsp_not                          = remove\nsp_inv                          = remove\nsp_addr                         = remove\nsp_member                       = remove\nsp_deref                        = remove\nsp_sign                         = remove\nsp_incdec                       = remove\nsp_before_nl_cont               = add\nsp_after_oc_scope               = ignore\nsp_after_oc_colon               = ignore\nsp_before_oc_colon              = ignore\nsp_after_oc_dict_colon          = ignore\nsp_before_oc_dict_colon         = ignore\nsp_after_send_oc_colon          = ignore\nsp_before_send_oc_colon         = ignore\nsp_after_oc_type                = ignore\nsp_after_oc_return_type         = ignore\nsp_after_oc_at_sel              = ignore\nsp_after_oc_at_sel_parens       = ignore\nsp_inside_oc_at_sel_parens      = ignore\nsp_before_oc_block_caret        = ignore\nsp_after_oc_block_caret         = ignore\nsp_after_oc_msg_receiver        = ignore\nsp_after_oc_property            = ignore\nsp_cond_colon                   = ignore\nsp_cond_colon_before            = ignore\nsp_cond_colon_after             = ignore\nsp_cond_question                = ignore\nsp_cond_question_before         = ignore\nsp_cond_question_after          = ignore\nsp_cond_ternary_short           = ignore\nsp_case_label                   = remove\nsp_range                        = ignore\nsp_after_for_colon              = ignore\nsp_before_for_colon             = ignore\nsp_extern_paren                 = ignore\nsp_cmt_cpp_start                = ignore\nsp_cmt_cpp_doxygen              = false\nsp_cmt_cpp_qttr                 = false\nsp_endif_cmt                    = ignore\nsp_after_new                    = ignore\nsp_between_new_paren            = ignore\nsp_before_tr_emb_cmt            = ignore\nsp_num_before_tr_emb_cmt        = 0\nsp_annotation_paren             = ignore\nsp_skip_vbrace_tokens           = false\nalign_keep_tabs                 = false\nalign_with_tabs                 = false\nalign_on_tabstop                = false\nalign_number_left               = false\nalign_keep_extra_space          = false\nalign_func_params               = false\nalign_same_func_call_params     = false\nalign_var_def_span              = 0\nalign_var_def_star_style        = 0\nalign_var_def_amp_style         = 0\nalign_var_def_thresh            = 0\nalign_var_def_gap               = 0\nalign_var_def_colon             = false\nalign_var_def_attribute         = false\nalign_var_def_inline            = false\nalign_assign_span               = 0\nalign_assign_thresh             = 0\nalign_enum_equ_span             = 0\nalign_enum_equ_thresh           = 0\nalign_var_class_span            = 0\nalign_var_class_thresh          = 0\nalign_var_class_gap             = 0\nalign_var_struct_span           = 0\nalign_var_struct_thresh         = 0\nalign_var_struct_gap            = 0\nalign_struct_init_span          = 0\nalign_typedef_gap               = 0\nalign_typedef_span              = 0\nalign_typedef_func              = 0\nalign_typedef_star_style        = 0\nalign_typedef_amp_style         = 0\nalign_right_cmt_span            = 0\nalign_right_cmt_mix             = false\nalign_right_cmt_gap             = 0\nalign_right_cmt_at_col          = 0\nalign_func_proto_span           = 0\nalign_func_proto_gap            = 0\nalign_on_operator               = false\nalign_mix_var_proto             = false\nalign_single_line_func          = false\nalign_single_line_brace         = false\nalign_single_line_brace_gap     = 0\nalign_oc_msg_spec_span          = 0\nalign_nl_cont                   = false\nalign_pp_define_together        = false\nalign_pp_define_gap             = 0\nalign_pp_define_span            = 0\nalign_left_shift                = true\nalign_asm_colon                 = false\nalign_oc_msg_colon_span         = 0\nalign_oc_msg_colon_first        = false\nalign_oc_decl_colon             = false\nnl_collapse_empty_body          = true\nnl_assign_leave_one_liners      = false\nnl_class_leave_one_liners       = false\nnl_enum_leave_one_liners        = false\nnl_getset_leave_one_liners      = false\nnl_func_leave_one_liners        = false\nnl_cpp_lambda_leave_one_liners  = false\nnl_if_leave_one_liners          = false\nnl_while_leave_one_liners       = false\nnl_oc_msg_leave_one_liner       = false\nnl_oc_block_brace               = ignore\nnl_start_of_file                = ignore\nnl_start_of_file_min            = 0\nnl_end_of_file                  = ignore\nnl_end_of_file_min              = 0\nnl_assign_brace                 = ignore\nnl_assign_square                = ignore\nnl_after_square_assign          = ignore\nnl_func_var_def_blk             = 0\nnl_typedef_blk_start            = 0\nnl_typedef_blk_end              = 0\nnl_typedef_blk_in               = 0\nnl_var_def_blk_start            = 0\nnl_var_def_blk_end              = 0\nnl_var_def_blk_in               = 0\nnl_fcall_brace                  = ignore\nnl_enum_brace                   = ignore\nnl_struct_brace                 = ignore\nnl_union_brace                  = ignore\nnl_brace_else                   = Remove\nnl_elseif_brace                 = Remove\nnl_else_brace                   = Remove\nnl_else_if                      = Remove\nnl_brace_finally                = ignore\nnl_finally_brace                = ignore\nnl_try_brace                    = ignore\nnl_getset_brace                 = ignore\nnl_for_brace                    = ignore\nnl_catch_brace                  = ignore\nnl_brace_catch                  = ignore\nnl_brace_square                 = ignore\nnl_brace_fparen                 = ignore\nnl_while_brace                  = ignore\nnl_scope_brace                  = ignore\nnl_unittest_brace               = ignore\nnl_version_brace                = ignore\nnl_using_brace                  = ignore\nnl_brace_brace                  = ignore\nnl_do_brace                     = Remove\nnl_brace_while                  = ignore\nnl_switch_brace                 = ignore\nnl_synchronized_brace           = ignore\nnl_multi_line_cond              = false\nnl_multi_line_define            = false\nnl_before_case                  = false\nnl_before_throw                 = ignore\nnl_after_case                   = false\nnl_case_colon_brace             = ignore\nnl_namespace_brace              = ignore\nnl_template_class               = ignore\nnl_class_brace                  = ignore\nnl_class_init_args              = ignore\nnl_constr_init_args             = ignore\nnl_enum_own_lines               = ignore\nnl_func_type_name               = ignore\nnl_func_type_name_class         = ignore\nnl_func_class_scope             = ignore\nnl_func_scope_name              = ignore\nnl_func_proto_type_name         = ignore\nnl_func_paren                   = ignore\nnl_func_def_paren               = ignore\nnl_func_decl_start              = ignore\nnl_func_def_start               = ignore\nnl_func_decl_start_single       = ignore\nnl_func_def_start_single        = ignore\nnl_func_decl_start_multi_line   = false\nnl_func_def_start_multi_line    = false\nnl_func_decl_args               = ignore\nnl_func_def_args                = ignore\nnl_func_decl_args_multi_line    = false\nnl_func_def_args_multi_line     = false\nnl_func_decl_end                = ignore\nnl_func_def_end                 = ignore\nnl_func_decl_end_single         = ignore\nnl_func_def_end_single          = ignore\nnl_func_decl_end_multi_line     = false\nnl_func_def_end_multi_line      = false\nnl_func_decl_empty              = ignore\nnl_func_def_empty               = ignore\nnl_func_call_start_multi_line   = false\nnl_func_call_args_multi_line    = false\nnl_func_call_end_multi_line     = false\nnl_oc_msg_args                  = false\nnl_fdef_brace                   = ignore\nnl_cpp_ldef_brace               = ignore\nnl_return_expr                  = Ignore\nnl_after_semicolon              = false\nnl_paren_dbrace_open            = ignore\nnl_after_brace_open             = true\nnl_after_brace_open_cmt         = false\nnl_after_vbrace_open            = false\nnl_after_vbrace_open_empty      = false\nnl_after_brace_close            = false\nnl_after_vbrace_close           = false\nnl_brace_struct_var             = ignore\nnl_define_macro                 = false\nnl_squeeze_ifdef                = false\nnl_squeeze_ifdef_top_level      = false\nnl_before_if                    = ignore\nnl_after_if                     = ignore\nnl_before_for                   = ignore\nnl_after_for                    = ignore\nnl_before_while                 = ignore\nnl_after_while                  = ignore\nnl_before_switch                = ignore\nnl_after_switch                 = ignore\nnl_before_synchronized          = ignore\nnl_after_synchronized           = ignore\nnl_before_do                    = ignore\nnl_after_do                     = ignore\nnl_ds_struct_enum_cmt           = false\nnl_ds_struct_enum_close_brace   = false\nnl_before_func_class_def        = 0\nnl_before_func_class_proto      = 0\nnl_class_colon                  = ignore\nnl_constr_colon                 = ignore\nnl_create_if_one_liner          = false\nnl_create_for_one_liner         = false\nnl_create_while_one_liner       = false\nnl_split_if_one_liner           = false\nnl_split_for_one_liner          = false\nnl_split_while_one_liner        = false\npos_arith                       = ignore\npos_assign                      = ignore\npos_bool                        = ignore\npos_compare                     = ignore\npos_conditional                 = ignore\npos_comma                       = ignore\npos_enum_comma                  = ignore\npos_class_comma                 = ignore\npos_constr_comma                = ignore\npos_class_colon                 = ignore\npos_constr_colon                = ignore\n# 240 is too much.. but sometimes uncrustify doesnt wraps the code as we like\n# so lets just respect original code width\ncode_width                      = 240\nls_for_split_full               = false\nls_func_split_full              = false\nls_code_width                   = false\nnl_max                          = 0\nnl_after_func_proto             = 0\nnl_after_func_proto_group       = 0\nnl_after_func_class_proto       = 0\nnl_after_func_class_proto_group = 0\nnl_before_func_body_def         = 0\nnl_before_func_body_proto       = 0\nnl_after_func_body              = 0\nnl_after_func_body_class        = 0\nnl_after_func_body_one_liner    = 0\nnl_before_block_comment         = 0\nnl_before_c_comment             = 0\nnl_before_cpp_comment           = 0\nnl_after_multiline_comment      = false\nnl_after_label_colon            = force\nnl_after_struct                 = 0\nnl_before_class                 = 0\nnl_after_class                  = 0\nnl_before_access_spec           = 0\nnl_after_access_spec            = 0\nnl_comment_func_def             = 0\nnl_after_try_catch_finally      = 0\nnl_around_cs_property           = 0\nnl_between_get_set              = 0\nnl_property_brace               = ignore\neat_blanks_after_open_brace     = false\neat_blanks_before_close_brace   = false\nnl_remove_extra_newlines        = 0\nnl_before_return                = false\nnl_after_return                 = false\nnl_after_annotation             = ignore\nnl_between_annotation           = ignore\nmod_full_brace_do               = ignore\nmod_full_brace_for              = ignore\nmod_full_brace_function         = ignore\nmod_full_brace_if_chain         = false\nmod_full_brace_if_chain_only    = false\nmod_full_brace_nl               = 0\nmod_full_brace_while            = ignore\nmod_full_brace_using            = ignore\nmod_paren_on_return             = ignore\nmod_pawn_semicolon              = false\nmod_full_paren_if_bool          = false\nmod_remove_extra_semicolon      = false\nmod_add_long_function_closebrace_comment = 0\nmod_add_long_namespace_closebrace_comment = 0\nmod_add_long_class_closebrace_comment = 0\nmod_add_long_switch_closebrace_comment = 0\nmod_add_long_ifdef_endif_comment = 0\nmod_add_long_ifdef_else_comment = 0\nmod_sort_import                 = false\nmod_sort_using                  = false\nmod_sort_include                = false\nmod_move_case_break             = false\nmod_case_brace                  = ignore\nmod_remove_empty_return         = false\nmod_sort_oc_properties          = false\nmod_sort_oc_property_thread_safe_weight = 0\nmod_sort_oc_property_readwrite_weight = 0\nmod_sort_oc_property_reference_weight = 0\nmod_sort_oc_property_getter_weight = 0\nmod_sort_oc_property_setter_weight = 0\nmod_sort_oc_property_nullability_weight = 0\ncmt_width                       = 0\ncmt_reflow_mode                 = 0\ncmt_convert_tab_to_spaces       = false\ncmt_indent_multi                = true\ncmt_c_group                     = false\ncmt_c_nl_start                  = false\ncmt_c_nl_end                    = false\ncmt_cpp_group                   = false\ncmt_cpp_nl_start                = false\ncmt_cpp_nl_end                  = false\ncmt_cpp_to_c                    = false\ncmt_star_cont                   = false\ncmt_sp_before_star_cont         = 0\ncmt_sp_after_star_cont          = 0\ncmt_multi_check_last            = true\ncmt_multi_first_len_minimum     = 4\ncmt_insert_file_header          = \"\"\ncmt_insert_file_footer          = \"\"\ncmt_insert_func_header          = \"\"\ncmt_insert_class_header         = \"\"\ncmt_insert_oc_msg_header        = \"\"\ncmt_insert_before_preproc       = false\ncmt_insert_before_inlines       = true\ncmt_insert_before_ctor_dtor     = false\npp_indent                       = force\n# spaces before #if \npp_indent_at_level              = false\npp_indent_count                 = 0\n#\npp_space                        = remove\npp_space_count                  = 0\npp_indent_region                = 0\npp_region_indent_code           = true\npp_indent_if                    = 0\npp_if_indent_code               = false\npp_define_at_level              = true\nuse_indent_func_call_param      = true\nuse_indent_continue_only_once   = false\nuse_options_overriding_for_qt_macros = true\nwarn_level_tabs_found_in_verbatim_string_literals = 2\n", "/* radare - LGPL - Copyright 2011-2016 - pancake */\n\n#include <r_cons.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"dex/dex.h\"\n#define r_hash_adler32 __adler32\n#include \"../../hash/adler32.c\"\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_dex;\n\n#define DEBUG_PRINTF 0\n\n#if DEBUG_PRINTF\n#define dprintf eprintf\n#else\n#define dprintf if (0)eprintf\n#endif\n\nstatic bool dexdump = false;\nstatic Sdb *mdb = NULL;\nstatic Sdb *cdb = NULL; // TODO: remove if it is not used\n\nstatic char *getstr(RBinDexObj *bin, int idx) {\n\tut8 buf[6];\n\tut64 len;\n\tint uleblen;\n\tif (!bin || idx < 0 || idx >= bin->header.strings_size ||\n\t\t!bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->strings[idx] >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf)) < 1) {\n\t\treturn NULL;\n\t}\n\tuleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;\n\tif (!uleblen || uleblen >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (!len || len >= bin->size) {\n\t\treturn NULL;\n\t}\n\t// TODO: improve this ugly fix\n\tchar c = 'a';\n\twhile (c) {\n\t\tut64 offset = bin->strings[idx] + uleblen + len;\n\t\tif (offset >= bin->size || offset < len) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_buf_read_at (bin->b, offset, (ut8*)&c, 1);\n\t\tlen++;\n\t}\n\tif ((int)len > 0 && len < R_BIN_SIZEOF_STRINGS) {\n\t\tchar *str = calloc (1, len + 1);\n\t\tif (str) {\n\t\t\tr_buf_read_at (bin->b, (bin->strings[idx]) + uleblen,\n\t\t\t\t\t\t(ut8 *)str, len);\n\t\t\tstr[len] = 0;\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int countOnes(ut32 val) {\n\tint count = 0;\n\tval = val - ((val >> 1) & 0x55555555);\n\tval = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n\tcount = (((val + (val >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n\treturn count;\n}\n\ntypedef enum {\n\tkAccessForClass  = 0,\n\tkAccessForMethod = 1,\n\tkAccessForField  = 2,\n\tkAccessForMAX\n} AccessFor;\n\nstatic char *createAccessFlagStr(ut32 flags, AccessFor forWhat) {\n\t#define NUM_FLAGS 18\n\tstatic const char* kAccessStrings[kAccessForMAX][NUM_FLAGS] = {\n\t\t{\n\t\t\t/* class, inner class */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"?\",                /* 0x0040 */\n\t\t\t\"?\",                /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"INTERFACE\",        /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"ANNOTATION\",       /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"VERIFIED\",         /* 0x10000 */\n\t\t\t\"OPTIMIZED\",        /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* method */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"SYNCHRONIZED\",     /* 0x0020 */\n\t\t\t\"BRIDGE\",           /* 0x0040 */\n\t\t\t\"VARARGS\",          /* 0x0080 */\n\t\t\t\"NATIVE\",           /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"STRICT\",           /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"?\",                /* 0x4000 */\n\t\t\t\"MIRANDA\",          /* 0x8000 */\n\t\t\t\"CONSTRUCTOR\",      /* 0x10000 */\n\t\t\t\"DECLARED_SYNCHRONIZED\", /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* field */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"VOLATILE\",         /* 0x0040 */\n\t\t\t\"TRANSIENT\",        /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"?\",                /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"?\",                /* 0x10000 */\n\t\t\t\"?\",                /* 0x20000 */\n\t\t},\n\t};\n\tconst int kLongest = 21;\n\tint i, count;\n\tchar* str;\n\tchar* cp;\n\tcount = countOnes(flags);\n\t// XXX check if this allocation is safe what if all the arithmetic\n\t// produces a huge number????\n\tcp = str = (char*) malloc (count * (kLongest + 1) + 1);\n\tfor (i = 0; i < NUM_FLAGS; i++) {\n\t\tif (flags & 0x01) {\n\t\t\tconst char* accessStr = kAccessStrings[forWhat][i];\n\t\t\tint len = strlen(accessStr);\n\t\t\tif (cp != str) {\n\t\t\t\t*cp++ = ' ';\n\t\t\t}\n\t\t\tmemcpy(cp, accessStr, len);\n\t\t\tcp += len;\n\t\t}\n\t\tflags >>= 1;\n\t}\n\t*cp = '\\0';\n\treturn str;\n}\n\nstatic char *dex_type_descriptor(RBinDexObj *bin, int type_idx) {\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, bin->types[type_idx].descriptor_id);\n}\n\nstatic char *dex_method_signature(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, type_id, list_size;\n\tchar *r, *return_type = NULL, *signature = NULL, *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint pos = 0, i, size = 1;\n\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\treturn NULL;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->protos[proto_id].return_type_id;\n\tif (type_id >= bin->header.types_size ) {\n\t\treturn NULL;\n\t}\n\treturn_type = getstr (bin, bin->types[type_id].descriptor_id);\n\tif (!return_type) {\n\t\treturn NULL;\n\t}\n\tif (!params_off) {\n\t\treturn r_str_newf (\"()%s\", return_type);;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX again list_size is user controlled huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tint buff_len = 0;\n\t\tif (params_off + 4 + (i * 2) >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + params_off + 4 + (i * 2));\n\t\tif (type_idx < 0 ||\n\t\t    type_idx >=\n\t\t\t    bin->header.types_size || type_idx >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff_len = strlen (buff);\n\t\tsize += buff_len + 1;\n\t\tsignature = realloc (signature, size);\n\t\tstrcpy (signature + pos, buff);\n\t\tpos += buff_len;\n\t\tsignature[pos] = '\\0';\n\t}\n\tr = r_str_newf (\"(%s)%s\", signature, return_type);\n\tfree (buff);\n\tfree (signature);\n\treturn r;\n}\n\nstatic RList *dex_method_signature2(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, list_size;\n\tchar *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint i;\n\n\tRList *params = r_list_newf (free);\n\tif (!params) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\tgoto out_error;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\tgoto out_error;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (!params_off) {\n\t\treturn params;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX list_size tainted it may produce huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tut64 of = params_off + 4 + (i * 2);\n\t\tif (of >= bin->size || of < params_off) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + of);\n\t\tif (type_idx >= bin->header.types_size ||\n\t\t    type_idx > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (params, buff);\n\t}\n\treturn params;\nout_error:\n\tr_list_free (params);\n\treturn NULL;\n}\n\n// TODO: fix this, now has more registers that it should\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L312\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L141\nstatic void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg >= regsz) {\n\t\t//return; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n\nstatic int check (RBinFile *arch);\nstatic int check_bytes (const ut8 *buf, ut64 length);\n\nstatic Sdb *get_sdb (RBinObject *o) {\n\tif (!o || !o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_dex_obj_t *bin = (struct r_bin_dex_obj_t *) o->bin_obj;\n\tif (bin->kv) {\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\n\tif (!arch || !arch->o) {\n\t\treturn false;\n\t}\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true: false;\n}\n\nstatic ut64 baddr(RBinFile *arch) {\n\treturn 0;\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\tif (!buf || length < 8) {\n\t\treturn false;\n\t}\n\t// Non-extended opcode dex file\n\tif (!memcmp (buf, \"dex\\n035\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Extended (jumnbo) opcode dex file, ICS+ only (sdk level 14+)\n\tif (!memcmp (buf, \"dex\\n036\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M3 (Nov-Dec 07)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M5 (Feb-Mar 08)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Default fall through, should still be a dex file\n\tif (!memcmp (buf, \"dex\\n\", 4)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tRBinHash *h;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = arch->file? strdup (arch->file): NULL;\n\tret->type = strdup (\"DEX CLASS\");\n\tret->has_va = false;\n\tret->bclass = r_bin_dex_get_version (arch->o->bin_obj);\n\tret->rclass = strdup (\"class\");\n\tret->os = strdup (\"linux\");\n\tret->subsystem = strdup (\"any\");\n\tret->machine = strdup (\"Dalvik VM\");\n\th = &ret->sum[0];\n\th->type = \"sha1\";\n\th->len = 20;\n\th->addr = 12;\n\th->from = 12;\n\th->to = arch->buf->length-32;\n\tmemcpy (h->buf, arch->buf->buf+12, 20);\n\th = &ret->sum[1];\n\th->type = \"adler32\";\n\th->len = 4;\n\th->addr = 0x8;\n\th->from = 12;\n\th->to = arch->buf->length-h->from;\n\th = &ret->sum[2];\n\th->type = 0;\n\tmemcpy (h->buf, arch->buf->buf + 8, 4);\n\t{\n\t\tut32 *fc = (ut32 *)(arch->buf->buf + 8);\n\t\tut32  cc = __adler32 (arch->buf->buf + 12, arch->buf->length - 12);\n\t\tif (*fc != cc) {\n\t\t\teprintf (\"# adler32 checksum doesn't match. Type this to fix it:\\n\");\n\t\t\teprintf (\"wx `#sha1 $s-32 @32` @12 ; wx `#adler32 $s-12 @12` @8\\n\");\n\t\t}\n\t}\n\tret->arch = strdup (\"dalvik\");\n\tret->lang = \"dalvik\";\n\tret->bits = 32;\n\tret->big_endian = 0;\n\tret->dbg_info = 0; //1 | 4 | 8; /* Stripped | LineNums | Syms */\n\treturn ret;\n}\n\nstatic RList *strings(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = NULL;\n\tRBinString *ptr = NULL;\n\tRList *ret = NULL;\n\tint i, len;\n\tut8 buf[6];\n\tut64 off;\n\tif (!arch || !arch->o) {\n\t\treturn NULL;\n\t}\n\tbin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;\n\tif (!bin || !bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->header.strings_size > bin->size) {\n\t\tbin->strings = NULL;\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->header.strings_size; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinString))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->strings[i] > bin->size || bin->strings[i] + 6 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tr_buf_read_at (bin->b, bin->strings[i], (ut8*)&buf, 6);\n\t\tlen = dex_read_uleb128 (buf);\n\n\t\tif (len > 1 && len < R_BIN_SIZEOF_STRINGS) {\n\t\t\tptr->string = malloc (len + 1);\n\t\t\tif (!ptr->string) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\toff = bin->strings[i] + dex_uleb128_len (buf);\n\t\t\tif (off + len >= bin->size || off + len < len) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off, (ut8*)ptr->string, len);\n\t\t\tptr->string[len] = 0;\n\t\t\tptr->vaddr = ptr->paddr = bin->strings[i];\n\t\t\tptr->size = len;\n\t\t\tptr->length = len;\n\t\t\tptr->ordinal = i+1;\n\t\t\tr_list_append (ret, ptr);\n\t\t} else {\n\t\t\tfree (ptr);\n\t\t}\n\t}\n\treturn ret;\nout_error:\n\tr_list_free (ret);\n\tfree (ptr);\n\treturn NULL;\n}\n\nstatic char *dex_method_name(RBinDexObj *bin, int idx) {\n\tif (idx < 0 || idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[idx].class_id;\n\tif (cid < 0 || cid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\tint tid = bin->methods[idx].name_id;\n\tif (tid < 0 || tid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name_byid(RBinDexObj *bin, int cid) {\n\tint tid;\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {\n\treturn dex_class_name_byid (bin, c->class_id);\n}\n\nstatic char *dex_field_name(RBinDexObj *bin, int fid) {\n\tint cid, tid, type_id;\n\tif (!bin || !bin->fields) {\n\t\treturn NULL;\n\t}\n\tif (fid < 0 || fid >= bin->header.fields_size) {\n\t\treturn NULL;\n\t}\n\tcid = bin->fields[fid].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->fields[fid].type_id;\n\tif (type_id < 0 || type_id >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->fields[fid].name_id;\n\treturn r_str_newf (\"%s->%s %s\", getstr (bin, bin->types[cid].descriptor_id),\n\t\tgetstr (bin, tid), getstr (bin, bin->types[type_id].descriptor_id));\n}\n\nstatic char *dex_method_fullname(RBinDexObj *bin, int method_idx) {\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[method_idx].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\tchar *name = dex_method_name (bin, method_idx);\n\tchar *class_name = dex_class_name_byid (bin, cid);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\tchar *signature = dex_method_signature (bin, method_idx);\n\tchar *flagname = r_str_newf (\"%s.%s%s\", class_name, name, signature);\n\tfree (name);\n\tfree (class_name);\n\tfree (signature);\n\treturn flagname;\n}\n\nstatic ut64 dex_get_type_offset(RBinFile *arch, int type_idx) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin || !bin->types) {\n\t\treturn 0;\n\t}\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn 0;\n\t}\n\treturn bin->header.types_offset + type_idx * 0x04; //&bin->types[type_idx];\n}\n\nstatic void __r_bin_class_free(RBinClass *p) {\n\tr_list_free (p->methods);\n\tr_list_free (p->fields);\n\tr_bin_class_free (p);\n}\n\nstatic char *dex_class_super_name(RBinDexObj *bin, RBinDexClass *c) {\n\tint cid, tid;\n\tif (!bin || !c || !bin->types) {\n\t\treturn NULL;\n\t}\n\tcid = c->super_class;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic const ut8 *parse_dex_class_fields(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 fields_count,\n\t\t\t\t\t  bool is_sfield) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut64 lastIndex = 0;\n\tut8 ff[sizeof (DexField)] = {0};\n\tint total, i, tid;\n\tDexField field;\n\tconst char* type_str;\n\tfor (i = 0; i < fields_count; i++) {\n\t\tut64 fieldIndex, accessFlags;\n\t\t\n\t\tp = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex\n\t\tp = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags\n\t\tfieldIndex += lastIndex;\n\t\ttotal = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);\n\t\tif (total >= bin->size || total < bin->header.fields_offset) {\n\t\t\tbreak;\t\n\t\t}\n\t\tif (r_buf_read_at (binfile->buf, total, ff,\n\t\t\t\tsizeof (DexField)) != sizeof (DexField)) {\n\t\t\tbreak;\n\t\t}\n\t\tfield.class_id = r_read_le16 (ff);\n\t\tfield.type_id = r_read_le16 (ff + 2);\n\t\tfield.name_id = r_read_le32 (ff + 4);\n\t\tchar *fieldName = getstr (bin, field.name_id);\n\t\tif (field.type_id >= bin->header.types_size) {\n\t\t\tbreak;\n\t\t}\n\t\ttid = bin->types[field.type_id].descriptor_id;\n\t\ttype_str = getstr (bin, tid);\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (is_sfield) {\n\t\t\tsym->name = r_str_newf (\"%s.sfield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"STATIC\");\n\t\t} else {\n\t\t\tsym->name = r_str_newf (\"%s.ifield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t}\n\t\tsym->name = r_str_replace (sym->name, \"method.\", \"\", 0);\n\t\t//sym->name = r_str_replace (sym->name, \";\", \"\", 0);\n\t\tsym->paddr = sym->vaddr = total;\n\t\tsym->ordinal = (*sym_count)++;\n\t\t\n\t\tif (dexdump) {\n\t\t\tconst char *accessStr = createAccessFlagStr (\n\t\t\t\taccessFlags, kAccessForField);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i,\n\t\t\t\t\t cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", fieldName);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", type_str);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)accessFlags, accessStr);\n\t\t}\n\n\t\tr_list_append (bin->methods_list, sym);\n\t\tr_list_append (cls->fields, sym);\n\n\t\tlastIndex = fieldIndex;\n\t}\n\treturn p;\n}\n\n// TODO: refactor this method\n// XXX it needs a lot of love!!!\nstatic const ut8 *parse_dex_class_method(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 DM, int *methods,\n\t\t\t\t\t  bool is_direct) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut8 ff2[16] = {0};\n\tut8 ff3[8] = {0};\n\tint i;\n\tut64 omi = 0;\n\tbool catchAll;\n\tut16 regsz, ins_size, outs_size, tries_size;\n\tut16 handler_off, start_addr, insn_count;\n\tut32 debug_info_off, insns_size;\n\tconst ut8 *encoded_method_addr;\n\tfor (i = 0; i < DM; i++) {\n\t\tencoded_method_addr = p;\n\t\tchar *method_name, *flag_name;\n\t\tut64 MI, MA, MC;\n\t\tp = r_uleb128 (p, p_end - p, &MI);\n\t\tMI += omi;\n\t\tomi = MI;\n\t\tp = r_uleb128 (p, p_end - p, &MA);\n\t\tp = r_uleb128 (p, p_end - p, &MC);\n\t\t// TODO: MOVE CHECKS OUTSIDE!\n\t\tif (MI < bin->header.method_size) {\n\t\t\tif (methods) {\n\t\t\t\tmethods[MI] = 1;\n\t\t\t}\n\t\t}\n\t\tmethod_name = dex_method_name (bin, MI);\n\t\tchar *signature = dex_method_signature (bin, MI);\n\t\tif (!method_name) {\n\t\t\tmethod_name = strdup (\"unknown\");\n\t\t}\n\t\tflag_name = r_str_newf (\"%s.method.%s%s\", cls->name,\n\t\t\t\t\tmethod_name, signature);\n\t\tif (!flag_name) {\n\t\t\tR_FREE (method_name);\n\t\t\tR_FREE (signature);\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: check size\n\t\t// ut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\tut64 v2, handler_type, handler_addr;\n\t\tint t;\n\t\tif (MC > 0) { \n\t\t\t// TODO: parse debug info\n\t\t\t// XXX why binfile->buf->base???\n\t\t\tif (MC + 16 >= bin->size || MC + 16 < MC) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (r_buf_read_at (binfile->buf,\n\t\t\t\t\t   binfile->buf->base + MC, ff2,\n\t\t\t\t\t   16) < 1) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregsz = r_read_le16 (ff2);\n\t\t\tins_size = r_read_le16 (ff2 + 2);\n\t\t\touts_size = r_read_le16 (ff2 + 4);\n\t\t\ttries_size = r_read_le16 (ff2 + 6);\n\t\t\tdebug_info_off = r_read_le32 (ff2 + 8);\n\t\t\tinsns_size = r_read_le32 (ff2 + 12);\n\t\t\tint padd = 0;\n\t\t\tif (tries_size > 0 && insns_size % 2) {\n\t\t\t\tpadd = 2;\n\t\t\t}\n\t\t\tt = 16 + 2 * insns_size + padd;\n\t\t}\n\t\tif (dexdump) {\n\t\t\tconst char* accessStr = createAccessFlagStr (MA, kAccessForMethod);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", method_name);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", signature);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)MA, accessStr);\n\t\t}\n\n\t\tif (MC > 0) {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\"      code          -\\n\");\n\t\t\t\trbin->cb_printf (\"      registers     : %d\\n\", regsz);\n\t\t\t\trbin->cb_printf (\"      ins           : %d\\n\", ins_size);\n\t\t\t\trbin->cb_printf (\"      outs          : %d\\n\", outs_size);\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      insns size    : %d 16-bit code \"\n\t\t\t\t\t\"units\\n\",\n\t\t\t\t\tinsns_size);\n\t\t\t}\n\t\t\tif (tries_size > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      catches       : %d\\n\", tries_size);\n\t\t\t\t}\n\t\t\t\tint j, m = 0;\n\t\t\t\t//XXX bucle controlled by tainted variable it could produces huge loop\n\t\t\t\tfor (j = 0; j < tries_size; ++j) {\n\t\t\t\t\tut64 offset = MC + t + j * 8;\n\t\t\t\t\tif (offset >= bin->size || offset < MC) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_buf_read_at (\n\t\t\t\t\t\t    binfile->buf,\n\t\t\t\t\t\t    binfile->buf->base + offset,\n\t\t\t\t\t\t    ff3, 8) < 1) {\n\t\t\t\t\t\t// free (method_name);\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstart_addr = r_read_le32 (ff3);\n\t\t\t\t\tinsn_count = r_read_le16 (ff3 + 4);\n\t\t\t\t\thandler_off = r_read_le16 (ff3 + 6);\n\t\t\t\t\tchar* s = NULL;\n\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\"        0x%04x - \"\n\t\t\t\t\t\t\t\"0x%04x\\n\",\n\t\t\t\t\t\t\tstart_addr,\n\t\t\t\t\t\t\t(start_addr +\n\t\t\t\t\t\t\t insn_count));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst ut8 *p3, *p3_end;\n\t\t\t\t\t//XXX tries_size is tainted and oob here\n\t\t\t\t\tint off = MC + t + tries_size * 8 + handler_off;\n\t\t\t\t\tif (off >= bin->size || off < tries_size) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp3 = r_buf_get_at (binfile->buf, off, NULL);\n\t\t\t\t\tp3_end = p3 + binfile->buf->length - off;\n\t\t\t\t\tst64 size = r_sleb128 (&p3, p3_end);\n\n\t\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\tcatchAll = true;\n\t\t\t\t\t\tsize = -size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcatchAll = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (m = 0; m < size; m++) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_type);\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_addr);\n\n\t\t\t\t\t\tif (handler_type > 0 &&\n\t\t\t\t\t\t    handler_type <\n\t\t\t\t\t\t\t    bin->header.types_size) {\n\t\t\t\t\t\t\ts = getstr (bin, bin->types[handler_type].descriptor_id);\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          %s \"\n\t\t\t\t\t\t\t\t\t\"-> 0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\t\"(error) -> \"\n\t\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (catchAll) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &v2);\n\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\"<any> -> \"\n\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\tv2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"      catches       : \"\n\t\t\t\t\t\t\"(none)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      code          : (none)\\n\");\n\t\t\t}\n\t\t}\n\t\tif (*flag_name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = flag_name;\n\t\t\t// is_direct is no longer used\n\t\t\t// if method has code *addr points to code\n\t\t\t// otherwise it points to the encoded method\n\t\t\tif (MC > 0) { \n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->paddr = MC;// + 0x10;\n\t\t\t\tsym->vaddr = MC;// + 0x10;\n\t\t\t} else {\n\t\t\t\tsym->type = r_str_const (\"METH\");\n\t\t\t\tsym->paddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t\tsym->vaddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t}\n\t\t\tif ((MA & 0x1) == 0x1) {\n\t\t\t\tsym->bind = r_str_const (\"GLOBAL\");\n\t\t\t} else {\n\t\t\t\tsym->bind = r_str_const (\"LOCAL\");\n\t\t\t}\n\t\t\tsym->ordinal = (*sym_count)++;\n\t\t\tif (MC > 0) {\n\t\t\t\tif (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {\n\t\t\t\t\tR_FREE (sym);\n\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//ut16 regsz = r_read_le16 (ff2);\n\t\t\t\t//ut16 ins_size = r_read_le16 (ff2 + 2);\n\t\t\t\t//ut16 outs_size = r_read_le16 (ff2 + 4);\n\t\t\t\tut16 tries_size = r_read_le16 (ff2 + 6);\n\t\t\t\t//ut32 debug_info_off = r_read_le32 (ff2 + 8);\n\t\t\t\tut32 insns_size = r_read_le32 (ff2 + 12);\n\t\t\t\tut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\t\t\tif (tries_size > 0) {\n\t\t\t\t\t//prolog_size += 2 + 8*tries_size; // we need to parse all so the catch info...\n\t\t\t\t}\n\t\t\t\t// TODO: prolog_size\n\t\t\t\tsym->paddr = MC + prolog_size;// + 0x10;\n\t\t\t\tsym->vaddr = MC + prolog_size;// + 0x10;\n\t\t\t\t//if (is_direct) {\n\t\t\t\tsym->size = insns_size * 2;\n\t\t\t\t//}\n\t\t\t\t//eprintf(\"%s (0x%x-0x%x) size=%d\\nregsz=%d\\ninsns_size=%d\\nouts_size=%d\\ntries_size=%d\\ninsns_size=%d\\n\", flag_name, sym->vaddr, sym->vaddr+sym->size, prolog_size, regsz, ins_size, outs_size, tries_size, insns_size);\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\n\t\t\t\tif (bin->code_from > sym->paddr) {\n\t\t\t\t\tbin->code_from = sym->paddr;\n\t\t\t\t}\n\t\t\t\tif (bin->code_to < sym->paddr) {\n\t\t\t\t\tbin->code_to = sym->paddr;\n\t\t\t\t}\n\n\t\t\t\tif (!mdb) {\n\t\t\t\t\tmdb = sdb_new0 ();\n\t\t\t\t}\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", MI), sym->paddr, 0);\n\t\t\t\t// -----------------\n\t\t\t\t// WORK IN PROGRESS\n\t\t\t\t// -----------------\n\t\t\t\tif (0) {\n\t\t\t\t\tif (MA & 0x10000) { //ACC_CONSTRUCTOR\n\t\t\t\t\t\tif (!cdb) {\n\t\t\t\t\t\t\tcdb = sdb_new0 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsdb_num_set (cdb, sdb_fmt (0, \"%d\", c->class_id), sym->paddr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->size = 0;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\t\t\t}\n\t\t\tif (MC > 0 && debug_info_off > 0 && bin->header.data_offset < debug_info_off &&\n\t\t\t\tdebug_info_off < bin->header.data_offset + bin->header.data_size) {\n\t\t\t\tdex_parse_debug_item (binfile, bin, c, MI, MA, sym->paddr, ins_size, \n\t\t\t\t\tinsns_size, cls->name, regsz, debug_info_off);\n\t\t\t} else if (MC > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      positions     :\\n\");\n\t\t\t\t\trbin->cb_printf (\"      locals        :\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (flag_name);\n\t\t}\n\t\tR_FREE (signature);\n\t\tR_FREE (method_name);\n\t}\n\treturn p;\n}\n\nstatic void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32(p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}\n\nstatic bool is_class_idx_in_code_classes(RBinDexObj *bin, int class_idx) {\n\tint i;\n\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\tif (class_idx == bin->classes[i].class_id) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}\n\nstatic RList* imports(RBinFile *arch) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin && bin->imports_list) {\n\t\treturn bin->imports_list;\n\t}\n\tdex_loadcode (arch, bin);\n\treturn bin->imports_list;\n}\n\nstatic RList *methods(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->methods_list;\n}\n\nstatic RList *classes(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->classes_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->classes_list;\n}\n\nstatic int already_entry(RList *entries, ut64 vaddr) {\n\tRBinAddr *e;\n\tRListIter *iter;\n\tr_list_foreach (entries, iter, e) {\n\t\tif (e->vaddr == vaddr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tRListIter *iter;\n\tRBinDexObj *bin;\n\tRBinSymbol *m;\n\tRBinAddr *ptr;\n\tRList *ret;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tret = r_list_newf ((RListFree)free);\n\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\n\t// STEP 1. \".onCreate(Landroid/os/Bundle;)V\"\n\tr_list_foreach (bin->methods_list, iter, m) {\n\t\tif (strlen (m->name) > 30 && m->bind && \n\t\t\t!strcmp(m->bind, \"GLOBAL\") &&\n\t\t    !strcmp (m->name + strlen (m->name) - 31,\n\t\t\t     \".onCreate(Landroid/os/Bundle;)V\")) {\n\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// STEP 2. \".main([Ljava/lang/String;)V\"\n\tif (r_list_empty (ret)) {\n\t\tr_list_foreach (bin->methods_list, iter, m) {\n\t\t\tif (strlen (m->name) > 26 &&\n\t\t\t    !strcmp (m->name + strlen (m->name) - 27,\n\t\t\t\t     \".main([Ljava/lang/String;)V\")) {\n\t\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t// STEP 3. NOTHING FOUND POINT TO CODE_INIT\n\tif (r_list_empty (ret)) {\n\t\tif (!already_entry (ret, bin->code_from)) {\n\t\t\tptr = R_NEW0 (RBinAddr);\n\t\t\tif (ptr) {\n\t\t\t\tptr->paddr = ptr->vaddr = bin->code_from;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ut64 offset_of_method_idx(RBinFile *arch, struct r_bin_dex_obj_t *dex, int idx) {\n\tut64 off = dex->header.method_offset + idx;\n\toff = sdb_num_get (mdb, sdb_fmt (0, \"method.%d\", idx), 0);\n\treturn (ut64) off;\n}\n\n// TODO: change all return type for all getoffset\nstatic int getoffset(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\t// TODO: ADD CHECK\n\t\treturn offset_of_method_idx (arch, dex, idx);\n\tcase 'o': // objects\n\t\tbreak;\n\tcase 's': // strings\n\t\tif (dex->header.strings_size > idx) {\n\t\t\tif (dex->strings) return dex->strings[idx];\n\t\t}\n\t\tbreak;\n\tcase 't': // type\n\t\treturn dex_get_type_offset (arch, idx);\n\tcase 'c': // class\n\t\treturn dex_get_type_offset (arch, idx);\n\t\t//return sdb_num_get (cdb, sdb_fmt (0, \"%d\", idx), 0);\n\t}\n\treturn -1;\n}\n\nstatic char *getname(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\treturn dex_method_fullname (dex, idx);\n\tcase 'c': // classes\n\t\treturn dex_class_name_byid (dex, idx);\n\tcase 'f': // fields\n\t\treturn dex_field_name (dex, idx);\n\t}\n\treturn NULL;\n}\n\nstatic RList *sections(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tRList *ml = methods (arch);\n\tRBinSection *ptr = NULL;\n\tint ns, fsymsz = 0;\n\tRList *ret = NULL;\n\tRListIter *iter;\n\tRBinSymbol *m;\n\tint fsym = 0;\n\n\tr_list_foreach (ml, iter, m) {\n\t\tif (!fsym || m->paddr < fsym) {\n\t\t\tfsym = m->paddr;\n\t\t}\n\t\tns = m->paddr + m->size;\n\t\tif (ns > arch->buf->length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ns > fsymsz) {\n\t\t\tfsymsz = ns;\n\t\t}\n\t}\n\tif (!fsym) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"header\");\n\t\tptr->size = ptr->vsize = sizeof (struct dex_header_t);\n\t\tptr->paddr= ptr->vaddr = 0;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"constpool\");\n\t\t//ptr->size = ptr->vsize = fsym;\n\t\tptr->paddr= ptr->vaddr = sizeof (struct dex_header_t);\n\t\tptr->size = bin->code_from - ptr->vaddr; // fix size\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"code\");\n\t\tptr->vaddr = ptr->paddr = bin->code_from; //ptr->vaddr = fsym;\n\t\tptr->size = bin->code_to - ptr->paddr;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\t//ut64 sz = arch ? r_buf_size (arch->buf): 0;\n\t\tstrcpy (ptr->name, \"data\");\n\t\tptr->paddr = ptr->vaddr = fsymsz+fsym;\n\t\tif (ptr->vaddr > arch->buf->length) {\n\t\t\tptr->paddr = ptr->vaddr = bin->code_to;\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t} else {\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t\t// hacky workaround\n\t\t\t//dprintf (\"Hack\\n\");\n\t\t\t//ptr->size = ptr->vsize = 1024;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP; //|2;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic void header(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tstruct r_bin_t *rbin = arch->rbin;\n\n\trbin->cb_printf (\"DEX file header:\\n\");\n\trbin->cb_printf (\"magic               : 'dex\\\\n035\\\\0'\\n\");\n\trbin->cb_printf (\"checksum            : %x\\n\", bin->header.checksum);\n\trbin->cb_printf (\"signature           : %02x%02x...%02x%02x\\n\", bin->header.signature[0], bin->header.signature[1], bin->header.signature[18], bin->header.signature[19]);\n\trbin->cb_printf (\"file_size           : %d\\n\", bin->header.size);\n\trbin->cb_printf (\"header_size         : %d\\n\", bin->header.header_size);\n\trbin->cb_printf (\"link_size           : %d\\n\", bin->header.linksection_size);\n\trbin->cb_printf (\"link_off            : %d (0x%06x)\\n\", bin->header.linksection_offset, bin->header.linksection_offset);\n\trbin->cb_printf (\"string_ids_size     : %d\\n\", bin->header.strings_size);\n\trbin->cb_printf (\"string_ids_off      : %d (0x%06x)\\n\", bin->header.strings_offset, bin->header.strings_offset);\n\trbin->cb_printf (\"type_ids_size       : %d\\n\", bin->header.types_size);\n\trbin->cb_printf (\"type_ids_off        : %d (0x%06x)\\n\", bin->header.types_offset, bin->header.types_offset);\n\trbin->cb_printf (\"proto_ids_size       : %d\\n\", bin->header.prototypes_size);\n\trbin->cb_printf (\"proto_ids_off        : %d (0x%06x)\\n\", bin->header.prototypes_offset, bin->header.prototypes_offset);\n\trbin->cb_printf (\"field_ids_size      : %d\\n\", bin->header.fields_size);\n\trbin->cb_printf (\"field_ids_off       : %d (0x%06x)\\n\", bin->header.fields_offset, bin->header.fields_offset);\n\trbin->cb_printf (\"method_ids_size     : %d\\n\", bin->header.method_size);\n\trbin->cb_printf (\"method_ids_off      : %d (0x%06x)\\n\", bin->header.method_offset, bin->header.method_offset);\n\trbin->cb_printf (\"class_defs_size     : %d\\n\", bin->header.class_size);\n\trbin->cb_printf (\"class_defs_off      : %d (0x%06x)\\n\", bin->header.class_offset, bin->header.class_offset);\n\trbin->cb_printf (\"data_size           : %d\\n\", bin->header.data_size);\n\trbin->cb_printf (\"data_off            : %d (0x%06x)\\n\\n\", bin->header.data_offset, bin->header.data_offset);\n\n\t// TODO: print information stored in the RBIN not this ugly fix\n\tdexdump = true;\n\tbin->methods_list = NULL;\n\tdex_loadcode (arch, bin);\n\tdexdump = false;\n}\n\nstatic ut64 size(RBinFile *arch) {\n\tint ret;\n\tut32 off = 0, len = 0;\n\tut8 u32s[sizeof (ut32)] = {0};\n\n\tret = r_buf_read_at (arch->buf, 108, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\toff = r_read_le32 (u32s);\n\tret = r_buf_read_at (arch->buf, 104, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\tlen = r_read_le32 (u32s);\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_dex = {\n\t.name = \"dex\",\n\t.desc = \"dex format bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.entries = entries,\n\t.classes = classes,\n\t.sections = sections,\n\t.symbols = methods,\n\t.imports = imports,\n\t.strings = strings,\n\t.info = &info,\n\t.header = &header,\n\t.size = &size,\n\t.get_offset = &getoffset,\n\t.get_name = &getname,\n\t.dbginfo = &r_bin_dbginfo_dex,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dex,\n\t.version = R2_VERSION\n};\n#endif\n", "#ifndef R_ENDIAN_H\n#define R_ENDIAN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Endian agnostic functions working on single byte. */\n\nstatic inline ut8 r_read_ble8(const void *src) {\n\treturn *(ut8 *)src;\n}\n\nstatic inline ut8 r_read_at_ble8(const void *src, size_t offset) {\n\treturn r_read_ble8 (((const ut8*)src) + offset);\n}\n\nstatic inline void r_write_ble8(void *dest, ut8 val) {\n\t*(ut8 *)dest = val;\n}\n\nstatic inline void r_write_at_ble8(void *dest, ut8 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_ble8 (d, val);\n}\n\n/* Big Endian functions. */\n\nstatic inline ut8 r_read_be8(const void *src) {\n\treturn r_read_ble8 (src);\n}\n\nstatic inline ut8 r_read_at_be8(const void *src, size_t offset) {\n\treturn r_read_at_ble8 (src, offset);\n}\n\nstatic inline void r_write_be8(void *dest, ut8 val) {\n\tr_write_ble8 (dest, val);\n}\n\nstatic inline void r_write_at_be8(void *dest, ut8 val, size_t offset) {\n\tr_write_at_ble8 (dest, val, offset);\n}\n\nstatic inline ut16 r_read_be16(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[0]) << 8) | (((ut16)s[1]) << 0);\n}\n\nstatic inline ut16 r_read_at_be16(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be16 (s);\n}\n\nstatic inline void r_write_be16(void *dest, ut16 val) {\n\tr_write_be8 (dest, val >> 8);\n\tr_write_at_be8 (dest, val >> 0, sizeof (ut8));\n}\n\nstatic inline void r_write_at_be16(void *dest, ut16 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be16 (d, val);\n}\n\nstatic inline ut32 r_read_be32(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[0]) << 24) | (((ut32)s[1]) << 16) |\n\t\t(((ut32)s[2]) << 8) | (((ut32)s[3]) << 0);\n}\n\nstatic inline ut32 r_read_at_be32(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be32 (s);\n}\n\nstatic inline void r_write_be32(void *dest, ut32 val) {\n\tr_write_be16 (dest, val >> 16);\n\tr_write_at_be16 (dest, val >> 0, sizeof (ut16));\n}\n\nstatic inline void r_write_be24(void *_dest, ut32 val) {\n\tut8 *dest = (ut8*)_dest;\n\tr_write_be8 (dest++, val >> 16);\n\tr_write_be8 (dest++, val >> 8);\n\tr_write_be8 (dest, val >> 0);\n}\n\nstatic inline void r_write_at_be32(void *dest, ut32 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be32 (d, val);\n}\n\nstatic inline ut64 r_read_be64(const void *src) {\n\tut64 val = ((ut64)(r_read_be32 (src))) << 32;\n\tval |= r_read_at_be32 (src, sizeof (ut32));\n\treturn val;\n}\n\nstatic inline ut64 r_read_at_be64(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be64 (s);\n}\n\nstatic inline void r_write_be64(void *dest, ut64 val) {\n\tr_write_be32 (dest, val >> 32);\n\tr_write_at_be32 (dest, val >> 0, sizeof (ut32));\n}\n\nstatic inline void r_write_at_be64(void *dest, ut64 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be64 (d, val);\n}\n\n/* Little Endian functions. */\n\nstatic inline ut8 r_read_le8(const void *src) {\n\treturn r_read_ble8 (src);\n}\n\nstatic inline ut8 r_read_at_le8(const void *src, size_t offset) {\n\treturn r_read_at_ble8 (src, offset);\n}\n\nstatic inline void r_write_le8(void *dest, ut8 val) {\n\tr_write_ble8 (dest, val);\n}\n\nstatic inline void r_write_at_le8(void *dest, ut8 val, size_t offset) {\n\tr_write_at_ble8 (dest, val, offset);\n}\n\nstatic inline ut16 r_read_le16(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}\n\nstatic inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}\n\nstatic inline void r_write_le16(void *dest, ut16 val) {\n\tr_write_le8 (dest, val >> 0);\n\tr_write_at_le8 (dest, val >> 8, sizeof (ut8));\n}\n\nstatic inline void r_write_at_le16(void *dest, ut16 val, size_t offset) {\n\tut8 *d = (ut8 *)dest + offset;\n\tr_write_le16 (d, val);\n}\n\nstatic inline void r_write_le24(void *_dest, ut32 val) {\n\tut8* dest = (ut8*)_dest;\n\tr_write_le8 (dest++, val >> 0);\n\tr_write_le8 (dest++, val >> 8);\n\tr_write_le8 (dest,   val >> 16);\n}\n\nstatic inline ut32 r_read_le32(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}\n\nstatic inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}\n\nstatic inline void r_write_le32(void *dest, ut32 val) {\n\tr_write_le16 (dest, val >> 0);\n\tr_write_at_le16 (dest, val >> 16, sizeof (ut16));\n}\n\nstatic inline void r_write_at_le32(void *dest, ut32 val, size_t offset) {\n\tut8 *d = ((ut8*)dest) + offset;\n\tr_write_le32 (d, val);\n}\n\nstatic inline ut64 r_read_le64(const void *src) {\n\tut64 val = ((ut64)(r_read_at_le32 (src, sizeof (ut32)))) <<  32;\n\tval |= r_read_le32 (src);\n\treturn val;\n}\n\nstatic inline ut64 r_read_at_le64(const void *src, size_t offset) {\n\tconst ut8 *s = ((const ut8*)src) + offset;\n\treturn r_read_le64 (s);\n}\n\nstatic inline void r_write_le64(void *dest, ut64 val) {\n\tr_write_le32 (dest, val >> 0);\n\tr_write_at_le32 (dest, val >> 32, sizeof (ut32));\n}\n\nstatic inline void r_write_at_le64(void *dest, ut64 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_le64 (d, val);\n}\n\n/* Helper functions */\n\nstatic inline ut16 r_read_ble16(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be16 (src): r_read_le16 (src);\n}\n\nstatic inline ut32 r_read_ble32(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be32 (src): r_read_le32 (src);\n}\n\nstatic inline ut64 r_read_ble64(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be64 (src): r_read_le64 (src);\n}\n\nstatic inline ut64 r_read_ble(const void *src, bool big_endian, int size) {\n\tswitch (size) {\n\tcase 8:\n\t\treturn (ut64) ((ut8*)src)[0];\n\tcase 16:\n\t\treturn r_read_ble16 (src, big_endian);\n\tcase 32:\n\t\treturn r_read_ble32 (src, big_endian);\n\tcase 64:\n\t\treturn r_read_ble64 (src, big_endian);\n\tdefault:\n\t\treturn UT64_MAX;\n\t}\n}\n\nstatic inline void r_write_ble16(void *dest, ut16 val, bool big_endian) {\n\tbig_endian? r_write_be16 (dest, val): r_write_le16 (dest, val);\n}\n\nstatic inline void r_write_ble24(void *dest, ut32 val, bool big_endian) {\n\tbig_endian? r_write_be24 (dest, val): r_write_le24 (dest, val);\n}\n\nstatic inline void r_write_ble32(void *dest, ut32 val, bool big_endian) {\n\tbig_endian? r_write_be32 (dest, val): r_write_le32 (dest, val);\n}\n\nstatic inline void r_write_ble64(void *dest, ut64 val, bool big_endian) {\n\tbig_endian? r_write_be64 (dest, val): r_write_le64 (dest, val);\n}\n\nstatic inline void r_write_ble(void *dst, ut64 val, bool big_endian, int size) {\n\tswitch (size) {\n\tcase 8:\n\t\t((ut8*)dst)[0] = (ut8) val;\n\t\tbreak;\n\tcase 16:\n\t\tr_write_ble16 (dst, (ut16) val, big_endian);\n\t\tbreak;\n\tcase 24:\n\t\tr_write_ble24 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 32:\n\t\tr_write_ble32 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 64:\n\t\tr_write_ble64 (dst, val, big_endian);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n// TODO: find better names and write vapis\n#define ut8p_b(x) ((x)[0])\n#define ut8p_bw(x) ((x)[0]|((x)[1]<<8))\n#define ut8p_bd(x) ((x)[0]|((x)[1]<<8)|((x)[2]<<16)|((x)[3]<<24))\n#define ut8p_bq(x) ((x)[0]|((x)[1]<<8)|((x)[2]<<16)|((x)[3]<<24)|((x)[4]<<32)|((x)[5]<<40)|((x)[6]<<48)|((x)[7]<<56))\n#define ut8p_lw(x) ((x)[1]|((x)[0]<<8))\n#define ut8p_ld(x) ((x)[3]|((x)[2]<<8)|((x)[1]<<16)|((x)[0]<<24))\n#define ut8p_lq(x) ((x)[7]|((x)[6]<<8)|((x)[5]<<16)|((x)[4]<<24)|((x)[3]<<32)|((x)[2]<<40)|((x)[1]<<48)|((x)[0]<<56))\n\n/*swap*/\nstatic inline ut16 r_swap_ut16(ut16 val) {\n\treturn (val << 8) | (val >> 8 );\n}\n\nstatic inline st16 r_swap_st16(st16 val) {\n\tval = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | (val >> 16);\n}\n\nstatic inline ut32 r_swap_ut32(ut32 val) {\n\tval = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | (val >> 16);\n}\n\nstatic inline st32 r_swap_st32(st32 val) {\n\tval = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | ((val >> 16) & 0xFFFF);\n}\n\nstatic inline ut64 r_swap_ut64(ut64 val) {\n\tval = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL );\n\tval = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL );\n\treturn (val << 32) | (val >> 32);\n}\n\nstatic inline st64 r_swap_st64(st64 val) {\n\tval = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL );\n\tval = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL );\n\treturn (val << 32) | ((val >> 32) & 0xFFFFFFFFULL);\n}\n\n/* Some \"secured\" functions, to do basic operation (mul, sub, add...) on integers */\nstatic inline int UT64_ADD(ut64 *r, ut64 a, ut64 b) {\n\tif (UT64_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT64_MUL(ut64 *r, ut64 a, ut64 b) {\n\tif (a && UT64_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT64_SUB(ut64 *r, ut64 a, ut64 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_ADD(ut32 *r, ut32 a, ut32 b) {\n\tif (UT32_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_MUL(ut32 *r, ut32 a, ut32 b) {\n\tif (a && UT32_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_SUB(ut32 *r, ut32 a, ut32 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_ADD(ut16 *r, ut16 a, ut16 b) {\n\tif (UT16_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_MUL(ut16 *r, ut16 a, ut16 b) {\n\tif (a && UT16_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_SUB(ut16 *r, ut16 a, ut16 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_ADD(ut8 *r, ut8 a, ut8 b) {\n\tif (UT8_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_MUL(ut8 *r, ut8 a, ut8 b) {\n\tif (a && UT8_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_SUB(ut8 *r, ut8 a, ut8 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "fixing_code": ["# Uncrustify 0.64_d\n\n# This section made by hand\nnl_if_brace                     = remove\nmod_full_brace_if               = force\n\nnewlines                        = auto\ninput_tab_size                  = 8\noutput_tab_size                 = 8\nsp_arith                        = Force\nsp_assign                       = Force\nsp_after_ptr_star               = Remove\nsp_after_ptr_star_func          = Remove\nsp_before_ptr_star_func         = Force\nsp_before_ptr_star              = Remove\nsp_after_cast                   = Force\nsp_func_call_user_paren         = Remove\nsp_func_call_paren              = Force\nset func_call_user Elf_\n\n# auto detected, move customize above this line\nstring_escape_char              = 92\nstring_escape_char2             = 0\nstring_replace_tab_chars        = false\ntok_split_gte                   = false\ndisable_processing_cmt          = \"\"\nenable_processing_cmt           = \"\"\nenable_digraphs                 = false\nutf8_bom                        = ignore\nutf8_byte                       = false\nutf8_force                      = false\nindent_columns                  = 8\nindent_continue                 = 0\nindent_with_tabs                = 1\nindent_cmt_with_tabs            = false\nindent_align_string             = false\nindent_xml_string               = 0\nindent_brace                    = 0\nindent_braces                   = false\nindent_braces_no_func           = false\nindent_braces_no_class          = false\nindent_braces_no_struct         = false\nindent_brace_parent             = false\nindent_paren_open_brace         = false\nindent_cs_delegate_brace        = false\nindent_namespace                = false\nindent_namespace_single_indent  = false\nindent_namespace_level          = 0\nindent_namespace_limit          = 0\nindent_extern                   = false\nindent_class                    = false\nindent_class_colon              = false\nindent_class_on_colon           = false\nindent_constr_colon             = false\nindent_ctor_init_leading        = 2\nindent_ctor_init                = 0\nindent_else_if                  = false\nindent_var_def_blk              = 0\nindent_var_def_cont             = false\nindent_shift                    = false\nindent_func_def_force_col1      = false\nindent_func_call_param          = true\nindent_func_def_param           = false\nindent_func_proto_param         = false\nindent_func_class_param         = false\nindent_func_ctor_var_param      = false\nindent_template_param           = false\nindent_func_param_double        = false\nindent_func_const               = 0\nindent_func_throw               = 0\nindent_member                   = 0\nindent_sing_line_comments       = 0\nindent_relative_single_line_comments = false\nindent_switch_case              = 0\nindent_case_shift               = 0\nindent_case_brace               = 0\nindent_col1_comment             = false\nindent_label                    = 1 \nindent_access_spec              = 1\nindent_access_spec_body         = false\nindent_paren_nl                 = false\nindent_paren_close              = 0\nindent_comma_paren              = false\nindent_bool_paren               = false\nindent_first_bool_expr          = false\nindent_square_nl                = false\nindent_preserve_sql             = false\nindent_align_assign             = true\nindent_oc_block                 = false\nindent_oc_block_msg             = 0\nindent_oc_msg_colon             = 0\nindent_oc_msg_prioritize_first_colon = true\nindent_oc_block_msg_xcode_style = false\nindent_oc_block_msg_from_keyword = false\nindent_oc_block_msg_from_colon  = false\nindent_oc_block_msg_from_caret  = false\nindent_oc_block_msg_from_brace  = false\nindent_min_vbrace_open          = 0\nindent_vbrace_open_on_tabstop   = false\nindent_token_after_brace        = true\nindent_cpp_lambda_body          = false\n\nsp_cpp_lambda_assign            = ignore\nsp_cpp_lambda_paren             = ignore\nsp_assign_default               = force\nsp_before_assign                = force\nsp_after_assign                 = force\nsp_enum_paren                   = ignore\nsp_enum_assign                  = ignore\nsp_enum_before_assign           = ignore\nsp_enum_after_assign            = ignore\nsp_pp_concat                    = add\nsp_pp_stringify                 = ignore\nsp_before_pp_stringify          = ignore\nsp_bool                         = force\nsp_compare                      = force\nsp_inside_paren                 = remove\nsp_paren_paren                  = remove\nsp_cparen_oparen                = ignore\nsp_balance_nested_parens        = false\nsp_paren_brace                  = ignore\nsp_before_ptr_star              = add\nsp_before_unnamed_ptr_star      = ignore\nsp_between_ptr_star             = remove\nsp_after_ptr_star_qualifier     = ignore\nsp_ptr_star_paren               = ignore\nsp_before_byref                 = ignore\nsp_before_unnamed_byref         = ignore\nsp_after_byref                  = ignore\nsp_after_byref_func             = ignore\nsp_before_byref_func            = ignore\nsp_after_type                   = force\nsp_before_template_paren        = ignore\nsp_template_angle               = ignore\nsp_before_angle                 = ignore\nsp_inside_angle                 = ignore\nsp_after_angle                  = ignore\nsp_angle_paren                  = ignore\nsp_angle_paren_empty            = ignore\nsp_angle_word                   = ignore\nsp_angle_shift                  = add\nsp_permit_cpp11_shift           = false\nsp_before_sparen                = ignore\nsp_inside_sparen                = remove\nsp_inside_sparen_close          = ignore\nsp_inside_sparen_open           = ignore\nsp_after_sparen                 = ignore\nsp_sparen_brace                 = ignore\nsp_invariant_paren              = ignore\nsp_after_invariant_paren        = ignore\nsp_special_semi                 = ignore\nsp_before_semi                  = remove\nsp_before_semi_for              = ignore\nsp_before_semi_for_empty        = ignore\nsp_after_semi                   = add\nsp_after_semi_for               = force\nsp_after_semi_for_empty         = remove\nsp_before_square                = ignore\nsp_before_squares               = remove\nsp_inside_square                = remove\nsp_after_comma                  = ignore\nsp_before_comma                 = remove\nsp_after_mdatype_commas         = ignore\nsp_before_mdatype_commas        = ignore\nsp_between_mdatype_commas       = ignore\nsp_paren_comma                  = force\nsp_before_ellipsis              = ignore\nsp_after_class_colon            = ignore\nsp_before_class_colon           = ignore\nsp_after_constr_colon           = ignore\nsp_before_constr_colon          = ignore\nsp_before_case_colon            = remove\nsp_after_operator               = ignore\nsp_after_operator_sym           = ignore\nsp_after_operator_sym_empty     = ignore\nsp_inside_paren_cast            = ignore\nsp_cpp_cast_paren               = ignore\nsp_sizeof_paren                 = ignore\nsp_after_tag                    = ignore\nsp_inside_braces_enum           = ignore\nsp_inside_braces_struct         = ignore\nsp_inside_braces                = ignore\nsp_inside_braces_empty          = remove\nsp_type_func                    = ignore\nsp_func_proto_paren             = ignore\nsp_func_proto_paren_empty       = ignore\nsp_func_def_paren               = ignore\nsp_func_def_paren_empty         = ignore\nsp_inside_fparens               = ignore\nsp_inside_fparen                = ignore\nsp_inside_tparen                = ignore\nsp_after_tparen_close           = ignore\nsp_square_fparen                = ignore\nsp_fparen_brace                 = ignore\nsp_fparen_dbrace                = ignore\nsp_func_call_paren_empty        = ignore\nsp_func_class_paren             = ignore\nsp_func_class_paren_empty       = ignore\nsp_return_paren                 = ignore\nsp_attribute_paren              = ignore\nsp_defined_paren                = ignore\nsp_throw_paren                  = ignore\nsp_after_throw                  = ignore\nsp_catch_paren                  = ignore\nsp_version_paren                = ignore\nsp_scope_paren                  = ignore\nsp_super_paren                  = remove\nsp_this_paren                   = remove\nsp_macro                        = ignore\nsp_macro_func                   = ignore\nsp_else_brace                   = force\nsp_brace_else                   = ignore\nsp_brace_typedef                = ignore\nsp_catch_brace                  = ignore\nsp_brace_catch                  = ignore\nsp_finally_brace                = ignore\nsp_brace_finally                = ignore\nsp_try_brace                    = ignore\nsp_getset_brace                 = ignore\nsp_word_brace                   = add\nsp_word_brace_ns                = add\nsp_before_dc                    = ignore\nsp_after_dc                     = ignore\nsp_d_array_colon                = ignore\nsp_not                          = remove\nsp_inv                          = remove\nsp_addr                         = remove\nsp_member                       = remove\nsp_deref                        = remove\nsp_sign                         = remove\nsp_incdec                       = remove\nsp_before_nl_cont               = add\nsp_after_oc_scope               = ignore\nsp_after_oc_colon               = ignore\nsp_before_oc_colon              = ignore\nsp_after_oc_dict_colon          = ignore\nsp_before_oc_dict_colon         = ignore\nsp_after_send_oc_colon          = ignore\nsp_before_send_oc_colon         = ignore\nsp_after_oc_type                = ignore\nsp_after_oc_return_type         = ignore\nsp_after_oc_at_sel              = ignore\nsp_after_oc_at_sel_parens       = ignore\nsp_inside_oc_at_sel_parens      = ignore\nsp_before_oc_block_caret        = ignore\nsp_after_oc_block_caret         = ignore\nsp_after_oc_msg_receiver        = ignore\nsp_after_oc_property            = ignore\nsp_cond_colon                   = ignore\nsp_cond_colon_before            = ignore\nsp_cond_colon_after             = ignore\nsp_cond_question                = ignore\nsp_cond_question_before         = ignore\nsp_cond_question_after          = ignore\nsp_cond_ternary_short           = ignore\nsp_case_label                   = remove\nsp_range                        = ignore\nsp_after_for_colon              = ignore\nsp_before_for_colon             = ignore\nsp_extern_paren                 = ignore\nsp_cmt_cpp_start                = ignore\nsp_cmt_cpp_doxygen              = false\nsp_cmt_cpp_qttr                 = false\nsp_endif_cmt                    = ignore\nsp_after_new                    = ignore\nsp_between_new_paren            = ignore\nsp_before_tr_emb_cmt            = ignore\nsp_num_before_tr_emb_cmt        = 0\nsp_annotation_paren             = ignore\nsp_skip_vbrace_tokens           = false\nalign_keep_tabs                 = false\nalign_with_tabs                 = false\nalign_on_tabstop                = false\nalign_number_left               = false\nalign_keep_extra_space          = false\nalign_func_params               = false\nalign_same_func_call_params     = false\nalign_var_def_span              = 0\nalign_var_def_star_style        = 0\nalign_var_def_amp_style         = 0\nalign_var_def_thresh            = 0\nalign_var_def_gap               = 0\nalign_var_def_colon             = false\nalign_var_def_attribute         = false\nalign_var_def_inline            = false\nalign_assign_span               = 0\nalign_assign_thresh             = 0\nalign_enum_equ_span             = 0\nalign_enum_equ_thresh           = 0\nalign_var_class_span            = 0\nalign_var_class_thresh          = 0\nalign_var_class_gap             = 0\nalign_var_struct_span           = 0\nalign_var_struct_thresh         = 0\nalign_var_struct_gap            = 0\nalign_struct_init_span          = 0\nalign_typedef_gap               = 0\nalign_typedef_span              = 0\nalign_typedef_func              = 0\nalign_typedef_star_style        = 0\nalign_typedef_amp_style         = 0\nalign_right_cmt_span            = 0\nalign_right_cmt_mix             = false\nalign_right_cmt_gap             = 0\nalign_right_cmt_at_col          = 0\nalign_func_proto_span           = 0\nalign_func_proto_gap            = 0\nalign_on_operator               = false\nalign_mix_var_proto             = false\nalign_single_line_func          = false\nalign_single_line_brace         = false\nalign_single_line_brace_gap     = 0\nalign_oc_msg_spec_span          = 0\nalign_nl_cont                   = false\nalign_pp_define_together        = false\nalign_pp_define_gap             = 0\nalign_pp_define_span            = 0\nalign_left_shift                = true\nalign_asm_colon                 = false\nalign_oc_msg_colon_span         = 0\nalign_oc_msg_colon_first        = false\nalign_oc_decl_colon             = false\nnl_collapse_empty_body          = true\nnl_assign_leave_one_liners      = false\nnl_class_leave_one_liners       = false\nnl_enum_leave_one_liners        = false\nnl_getset_leave_one_liners      = false\nnl_func_leave_one_liners        = false\nnl_cpp_lambda_leave_one_liners  = false\nnl_if_leave_one_liners          = false\nnl_while_leave_one_liners       = false\nnl_oc_msg_leave_one_liner       = false\nnl_oc_block_brace               = ignore\nnl_start_of_file                = ignore\nnl_start_of_file_min            = 0\nnl_end_of_file                  = ignore\nnl_end_of_file_min              = 0\nnl_assign_brace                 = ignore\nnl_assign_square                = ignore\nnl_after_square_assign          = ignore\nnl_func_var_def_blk             = 0\nnl_typedef_blk_start            = 0\nnl_typedef_blk_end              = 0\nnl_typedef_blk_in               = 0\nnl_var_def_blk_start            = 0\nnl_var_def_blk_end              = 0\nnl_var_def_blk_in               = 0\nnl_fcall_brace                  = ignore\nnl_enum_brace                   = ignore\nnl_struct_brace                 = ignore\nnl_union_brace                  = ignore\nnl_brace_else                   = Remove\nnl_elseif_brace                 = Remove\nnl_else_brace                   = Remove\nnl_else_if                      = Remove\nnl_brace_finally                = ignore\nnl_finally_brace                = ignore\nnl_try_brace                    = ignore\nnl_getset_brace                 = ignore\nnl_for_brace                    = ignore\nnl_catch_brace                  = ignore\nnl_brace_catch                  = ignore\nnl_brace_square                 = ignore\nnl_brace_fparen                 = ignore\nnl_while_brace                  = ignore\nnl_scope_brace                  = ignore\nnl_unittest_brace               = ignore\nnl_version_brace                = ignore\nnl_using_brace                  = ignore\nnl_brace_brace                  = ignore\nnl_do_brace                     = Remove\nnl_brace_while                  = ignore\nnl_switch_brace                 = ignore\nnl_synchronized_brace           = ignore\nnl_multi_line_cond              = false\nnl_multi_line_define            = false\nnl_before_case                  = false\nnl_before_throw                 = ignore\nnl_after_case                   = false\nnl_case_colon_brace             = ignore\nnl_namespace_brace              = ignore\nnl_template_class               = ignore\nnl_class_brace                  = ignore\nnl_class_init_args              = ignore\nnl_constr_init_args             = ignore\nnl_enum_own_lines               = ignore\nnl_func_type_name               = ignore\nnl_func_type_name_class         = ignore\nnl_func_class_scope             = ignore\nnl_func_scope_name              = ignore\nnl_func_proto_type_name         = ignore\nnl_func_paren                   = ignore\nnl_func_def_paren               = ignore\nnl_func_decl_start              = ignore\nnl_func_def_start               = ignore\nnl_func_decl_start_single       = ignore\nnl_func_def_start_single        = ignore\nnl_func_decl_start_multi_line   = false\nnl_func_def_start_multi_line    = false\nnl_func_decl_args               = ignore\nnl_func_def_args                = ignore\nnl_func_decl_args_multi_line    = false\nnl_func_def_args_multi_line     = false\nnl_func_decl_end                = ignore\nnl_func_def_end                 = ignore\nnl_func_decl_end_single         = ignore\nnl_func_def_end_single          = ignore\nnl_func_decl_end_multi_line     = false\nnl_func_def_end_multi_line      = false\nnl_func_decl_empty              = ignore\nnl_func_def_empty               = ignore\nnl_func_call_start_multi_line   = false\nnl_func_call_args_multi_line    = false\nnl_func_call_end_multi_line     = false\nnl_oc_msg_args                  = false\nnl_fdef_brace                   = ignore\nnl_cpp_ldef_brace               = ignore\nnl_return_expr                  = Ignore\nnl_after_semicolon              = false\nnl_paren_dbrace_open            = ignore\nnl_after_brace_open             = true\nnl_after_brace_open_cmt         = false\nnl_after_vbrace_open            = false\nnl_after_vbrace_open_empty      = false\nnl_after_brace_close            = false\nnl_after_vbrace_close           = false\nnl_brace_struct_var             = ignore\nnl_define_macro                 = false\nnl_squeeze_ifdef                = false\nnl_squeeze_ifdef_top_level      = false\nnl_before_if                    = ignore\nnl_after_if                     = ignore\nnl_before_for                   = ignore\nnl_after_for                    = ignore\nnl_before_while                 = ignore\nnl_after_while                  = ignore\nnl_before_switch                = ignore\nnl_after_switch                 = ignore\nnl_before_synchronized          = ignore\nnl_after_synchronized           = ignore\nnl_before_do                    = ignore\nnl_after_do                     = ignore\nnl_ds_struct_enum_cmt           = false\nnl_ds_struct_enum_close_brace   = false\nnl_before_func_class_def        = 0\nnl_before_func_class_proto      = 0\nnl_class_colon                  = ignore\nnl_constr_colon                 = ignore\nnl_create_if_one_liner          = false\nnl_create_for_one_liner         = false\nnl_create_while_one_liner       = false\nnl_split_if_one_liner           = false\nnl_split_for_one_liner          = false\nnl_split_while_one_liner        = false\npos_arith                       = ignore\npos_assign                      = ignore\npos_bool                        = ignore\npos_compare                     = ignore\npos_conditional                 = ignore\npos_comma                       = ignore\npos_enum_comma                  = ignore\npos_class_comma                 = ignore\npos_constr_comma                = ignore\npos_class_colon                 = ignore\npos_constr_colon                = ignore\n# 240 is too much.. but sometimes uncrustify doesnt wraps the code as we like\n# so lets just respect original code width\ncode_width                      = 240\nls_for_split_full               = false\nls_func_split_full              = false\nls_code_width                   = false\nnl_max                          = 0\nnl_after_func_proto             = 0\nnl_after_func_proto_group       = 0\nnl_after_func_class_proto       = 0\nnl_after_func_class_proto_group = 0\nnl_before_func_body_def         = 0\nnl_before_func_body_proto       = 0\nnl_after_func_body              = 0\nnl_after_func_body_class        = 0\nnl_after_func_body_one_liner    = 0\nnl_before_block_comment         = 0\nnl_before_c_comment             = 0\nnl_before_cpp_comment           = 0\nnl_after_multiline_comment      = false\nnl_after_label_colon            = true\nnl_after_struct                 = 0\nnl_before_class                 = 0\nnl_after_class                  = 0\nnl_before_access_spec           = 0\nnl_after_access_spec            = 0\nnl_comment_func_def             = 0\nnl_after_try_catch_finally      = 0\nnl_around_cs_property           = 0\nnl_between_get_set              = 0\nnl_property_brace               = ignore\neat_blanks_after_open_brace     = false\neat_blanks_before_close_brace   = false\nnl_remove_extra_newlines        = 0\nnl_before_return                = false\nnl_after_return                 = false\nnl_after_annotation             = ignore\nnl_between_annotation           = ignore\nmod_full_brace_do               = ignore\nmod_full_brace_for              = ignore\nmod_full_brace_function         = ignore\nmod_full_brace_if_chain         = false\nmod_full_brace_if_chain_only    = false\nmod_full_brace_nl               = 0\nmod_full_brace_while            = ignore\nmod_full_brace_using            = ignore\nmod_paren_on_return             = ignore\nmod_pawn_semicolon              = false\nmod_full_paren_if_bool          = false\nmod_remove_extra_semicolon      = false\nmod_add_long_function_closebrace_comment = 0\nmod_add_long_namespace_closebrace_comment = 0\nmod_add_long_class_closebrace_comment = 0\nmod_add_long_switch_closebrace_comment = 0\nmod_add_long_ifdef_endif_comment = 0\nmod_add_long_ifdef_else_comment = 0\nmod_sort_import                 = false\nmod_sort_using                  = false\nmod_sort_include                = false\nmod_move_case_break             = false\nmod_case_brace                  = ignore\nmod_remove_empty_return         = false\nmod_sort_oc_properties          = false\nmod_sort_oc_property_thread_safe_weight = 0\nmod_sort_oc_property_readwrite_weight = 0\nmod_sort_oc_property_reference_weight = 0\nmod_sort_oc_property_getter_weight = 0\nmod_sort_oc_property_setter_weight = 0\nmod_sort_oc_property_nullability_weight = 0\ncmt_width                       = 0\ncmt_reflow_mode                 = 0\ncmt_convert_tab_to_spaces       = false\ncmt_indent_multi                = true\ncmt_c_group                     = false\ncmt_c_nl_start                  = false\ncmt_c_nl_end                    = false\ncmt_cpp_group                   = false\ncmt_cpp_nl_start                = false\ncmt_cpp_nl_end                  = false\ncmt_cpp_to_c                    = false\ncmt_star_cont                   = false\ncmt_sp_before_star_cont         = 0\ncmt_sp_after_star_cont          = 0\ncmt_multi_check_last            = true\ncmt_multi_first_len_minimum     = 4\ncmt_insert_file_header          = \"\"\ncmt_insert_file_footer          = \"\"\ncmt_insert_func_header          = \"\"\ncmt_insert_class_header         = \"\"\ncmt_insert_oc_msg_header        = \"\"\ncmt_insert_before_preproc       = false\ncmt_insert_before_inlines       = true\ncmt_insert_before_ctor_dtor     = false\npp_indent                       = force\n# spaces before #if \npp_indent_at_level              = false\npp_indent_count                 = 0\n#\npp_space                        = remove\npp_space_count                  = 0\npp_indent_region                = 0\npp_region_indent_code           = true\npp_indent_if                    = 0\npp_if_indent_code               = false\npp_define_at_level              = true\nuse_indent_func_call_param      = true\nuse_indent_continue_only_once   = false\nuse_options_overriding_for_qt_macros = true\nwarn_level_tabs_found_in_verbatim_string_literals = 2\n", "/* radare - LGPL - Copyright 2011-2016 - pancake */\n\n#include <r_cons.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"dex/dex.h\"\n#define r_hash_adler32 __adler32\n#include \"../../hash/adler32.c\"\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_dex;\n\n#define DEBUG_PRINTF 0\n\n#if DEBUG_PRINTF\n#define dprintf eprintf\n#else\n#define dprintf if (0)eprintf\n#endif\n\nstatic bool dexdump = false;\nstatic Sdb *mdb = NULL;\nstatic Sdb *cdb = NULL; // TODO: remove if it is not used\n\nstatic char *getstr(RBinDexObj *bin, int idx) {\n\tut8 buf[6];\n\tut64 len;\n\tint uleblen;\n\tif (!bin || idx < 0 || idx >= bin->header.strings_size ||\n\t\t!bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->strings[idx] >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf)) < 1) {\n\t\treturn NULL;\n\t}\n\tuleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;\n\tif (!uleblen || uleblen >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (!len || len >= bin->size) {\n\t\treturn NULL;\n\t}\n\t// TODO: improve this ugly fix\n\tchar c = 'a';\n\twhile (c) {\n\t\tut64 offset = bin->strings[idx] + uleblen + len;\n\t\tif (offset >= bin->size || offset < len) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_buf_read_at (bin->b, offset, (ut8*)&c, 1);\n\t\tlen++;\n\t}\n\tif ((int)len > 0 && len < R_BIN_SIZEOF_STRINGS) {\n\t\tchar *str = calloc (1, len + 1);\n\t\tif (str) {\n\t\t\tr_buf_read_at (bin->b, (bin->strings[idx]) + uleblen,\n\t\t\t\t\t\t(ut8 *)str, len);\n\t\t\tstr[len] = 0;\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int countOnes(ut32 val) {\n\tint count = 0;\n\tval = val - ((val >> 1) & 0x55555555);\n\tval = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n\tcount = (((val + (val >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n\treturn count;\n}\n\ntypedef enum {\n\tkAccessForClass  = 0,\n\tkAccessForMethod = 1,\n\tkAccessForField  = 2,\n\tkAccessForMAX\n} AccessFor;\n\nstatic char *createAccessFlagStr(ut32 flags, AccessFor forWhat) {\n\t#define NUM_FLAGS 18\n\tstatic const char* kAccessStrings[kAccessForMAX][NUM_FLAGS] = {\n\t\t{\n\t\t\t/* class, inner class */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"?\",                /* 0x0040 */\n\t\t\t\"?\",                /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"INTERFACE\",        /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"ANNOTATION\",       /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"VERIFIED\",         /* 0x10000 */\n\t\t\t\"OPTIMIZED\",        /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* method */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"SYNCHRONIZED\",     /* 0x0020 */\n\t\t\t\"BRIDGE\",           /* 0x0040 */\n\t\t\t\"VARARGS\",          /* 0x0080 */\n\t\t\t\"NATIVE\",           /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"STRICT\",           /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"?\",                /* 0x4000 */\n\t\t\t\"MIRANDA\",          /* 0x8000 */\n\t\t\t\"CONSTRUCTOR\",      /* 0x10000 */\n\t\t\t\"DECLARED_SYNCHRONIZED\", /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* field */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"VOLATILE\",         /* 0x0040 */\n\t\t\t\"TRANSIENT\",        /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"?\",                /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"?\",                /* 0x10000 */\n\t\t\t\"?\",                /* 0x20000 */\n\t\t},\n\t};\n\tconst int kLongest = 21;\n\tint i, count;\n\tchar* str;\n\tchar* cp;\n\tcount = countOnes(flags);\n\t// XXX check if this allocation is safe what if all the arithmetic\n\t// produces a huge number????\n\tcp = str = (char*) malloc (count * (kLongest + 1) + 1);\n\tfor (i = 0; i < NUM_FLAGS; i++) {\n\t\tif (flags & 0x01) {\n\t\t\tconst char* accessStr = kAccessStrings[forWhat][i];\n\t\t\tint len = strlen(accessStr);\n\t\t\tif (cp != str) {\n\t\t\t\t*cp++ = ' ';\n\t\t\t}\n\t\t\tmemcpy(cp, accessStr, len);\n\t\t\tcp += len;\n\t\t}\n\t\tflags >>= 1;\n\t}\n\t*cp = '\\0';\n\treturn str;\n}\n\nstatic char *dex_type_descriptor(RBinDexObj *bin, int type_idx) {\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, bin->types[type_idx].descriptor_id);\n}\n\nstatic char *dex_method_signature(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, type_id, list_size;\n\tchar *r, *return_type = NULL, *signature = NULL, *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint pos = 0, i, size = 1;\n\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\treturn NULL;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->protos[proto_id].return_type_id;\n\tif (type_id >= bin->header.types_size ) {\n\t\treturn NULL;\n\t}\n\treturn_type = getstr (bin, bin->types[type_id].descriptor_id);\n\tif (!return_type) {\n\t\treturn NULL;\n\t}\n\tif (!params_off) {\n\t\treturn r_str_newf (\"()%s\", return_type);;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX again list_size is user controlled huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tint buff_len = 0;\n\t\tif (params_off + 4 + (i * 2) >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + params_off + 4 + (i * 2));\n\t\tif (type_idx < 0 ||\n\t\t    type_idx >=\n\t\t\t    bin->header.types_size || type_idx >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff_len = strlen (buff);\n\t\tsize += buff_len + 1;\n\t\tsignature = realloc (signature, size);\n\t\tstrcpy (signature + pos, buff);\n\t\tpos += buff_len;\n\t\tsignature[pos] = '\\0';\n\t}\n\tr = r_str_newf (\"(%s)%s\", signature, return_type);\n\tfree (buff);\n\tfree (signature);\n\treturn r;\n}\n\nstatic RList *dex_method_signature2(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, list_size;\n\tchar *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint i;\n\n\tRList *params = r_list_newf (free);\n\tif (!params) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\tgoto out_error;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\tgoto out_error;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (!params_off) {\n\t\treturn params;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX list_size tainted it may produce huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tut64 of = params_off + 4 + (i * 2);\n\t\tif (of >= bin->size || of < params_off) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + of);\n\t\tif (type_idx >= bin->header.types_size ||\n\t\t    type_idx > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (params, buff);\n\t}\n\treturn params;\nout_error:\n\tr_list_free (params);\n\treturn NULL;\n}\n\n// TODO: fix this, now has more registers that it should\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L312\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L141\nstatic void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg >= regsz) {\n\t\t//return; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n\nstatic int check (RBinFile *arch);\nstatic int check_bytes (const ut8 *buf, ut64 length);\n\nstatic Sdb *get_sdb (RBinObject *o) {\n\tif (!o || !o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_dex_obj_t *bin = (struct r_bin_dex_obj_t *) o->bin_obj;\n\tif (bin->kv) {\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\n\tif (!arch || !arch->o) {\n\t\treturn false;\n\t}\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true: false;\n}\n\nstatic ut64 baddr(RBinFile *arch) {\n\treturn 0;\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\tif (!buf || length < 8) {\n\t\treturn false;\n\t}\n\t// Non-extended opcode dex file\n\tif (!memcmp (buf, \"dex\\n035\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Extended (jumnbo) opcode dex file, ICS+ only (sdk level 14+)\n\tif (!memcmp (buf, \"dex\\n036\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M3 (Nov-Dec 07)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M5 (Feb-Mar 08)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Default fall through, should still be a dex file\n\tif (!memcmp (buf, \"dex\\n\", 4)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tRBinHash *h;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = arch->file? strdup (arch->file): NULL;\n\tret->type = strdup (\"DEX CLASS\");\n\tret->has_va = false;\n\tret->bclass = r_bin_dex_get_version (arch->o->bin_obj);\n\tret->rclass = strdup (\"class\");\n\tret->os = strdup (\"linux\");\n\tret->subsystem = strdup (\"any\");\n\tret->machine = strdup (\"Dalvik VM\");\n\th = &ret->sum[0];\n\th->type = \"sha1\";\n\th->len = 20;\n\th->addr = 12;\n\th->from = 12;\n\th->to = arch->buf->length-32;\n\tmemcpy (h->buf, arch->buf->buf+12, 20);\n\th = &ret->sum[1];\n\th->type = \"adler32\";\n\th->len = 4;\n\th->addr = 0x8;\n\th->from = 12;\n\th->to = arch->buf->length-h->from;\n\th = &ret->sum[2];\n\th->type = 0;\n\tmemcpy (h->buf, arch->buf->buf + 8, 4);\n\t{\n\t\tut32 *fc = (ut32 *)(arch->buf->buf + 8);\n\t\tut32  cc = __adler32 (arch->buf->buf + 12, arch->buf->length - 12);\n\t\tif (*fc != cc) {\n\t\t\teprintf (\"# adler32 checksum doesn't match. Type this to fix it:\\n\");\n\t\t\teprintf (\"wx `#sha1 $s-32 @32` @12 ; wx `#adler32 $s-12 @12` @8\\n\");\n\t\t}\n\t}\n\tret->arch = strdup (\"dalvik\");\n\tret->lang = \"dalvik\";\n\tret->bits = 32;\n\tret->big_endian = 0;\n\tret->dbg_info = 0; //1 | 4 | 8; /* Stripped | LineNums | Syms */\n\treturn ret;\n}\n\nstatic RList *strings(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = NULL;\n\tRBinString *ptr = NULL;\n\tRList *ret = NULL;\n\tint i, len;\n\tut8 buf[6];\n\tut64 off;\n\tif (!arch || !arch->o) {\n\t\treturn NULL;\n\t}\n\tbin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;\n\tif (!bin || !bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->header.strings_size > bin->size) {\n\t\tbin->strings = NULL;\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->header.strings_size; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinString))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->strings[i] > bin->size || bin->strings[i] + 6 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tr_buf_read_at (bin->b, bin->strings[i], (ut8*)&buf, 6);\n\t\tlen = dex_read_uleb128 (buf);\n\n\t\tif (len > 1 && len < R_BIN_SIZEOF_STRINGS) {\n\t\t\tptr->string = malloc (len + 1);\n\t\t\tif (!ptr->string) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\toff = bin->strings[i] + dex_uleb128_len (buf);\n\t\t\tif (off + len >= bin->size || off + len < len) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off, (ut8*)ptr->string, len);\n\t\t\tptr->string[len] = 0;\n\t\t\tptr->vaddr = ptr->paddr = bin->strings[i];\n\t\t\tptr->size = len;\n\t\t\tptr->length = len;\n\t\t\tptr->ordinal = i+1;\n\t\t\tr_list_append (ret, ptr);\n\t\t} else {\n\t\t\tfree (ptr);\n\t\t}\n\t}\n\treturn ret;\nout_error:\n\tr_list_free (ret);\n\tfree (ptr);\n\treturn NULL;\n}\n\nstatic char *dex_method_name(RBinDexObj *bin, int idx) {\n\tif (idx < 0 || idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[idx].class_id;\n\tif (cid < 0 || cid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\tint tid = bin->methods[idx].name_id;\n\tif (tid < 0 || tid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name_byid(RBinDexObj *bin, int cid) {\n\tint tid;\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {\n\treturn dex_class_name_byid (bin, c->class_id);\n}\n\nstatic char *dex_field_name(RBinDexObj *bin, int fid) {\n\tint cid, tid, type_id;\n\tif (!bin || !bin->fields) {\n\t\treturn NULL;\n\t}\n\tif (fid < 0 || fid >= bin->header.fields_size) {\n\t\treturn NULL;\n\t}\n\tcid = bin->fields[fid].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->fields[fid].type_id;\n\tif (type_id < 0 || type_id >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->fields[fid].name_id;\n\treturn r_str_newf (\"%s->%s %s\", getstr (bin, bin->types[cid].descriptor_id),\n\t\tgetstr (bin, tid), getstr (bin, bin->types[type_id].descriptor_id));\n}\n\nstatic char *dex_method_fullname(RBinDexObj *bin, int method_idx) {\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[method_idx].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\tchar *name = dex_method_name (bin, method_idx);\n\tchar *class_name = dex_class_name_byid (bin, cid);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\tchar *signature = dex_method_signature (bin, method_idx);\n\tchar *flagname = r_str_newf (\"%s.%s%s\", class_name, name, signature);\n\tfree (name);\n\tfree (class_name);\n\tfree (signature);\n\treturn flagname;\n}\n\nstatic ut64 dex_get_type_offset(RBinFile *arch, int type_idx) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin || !bin->types) {\n\t\treturn 0;\n\t}\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn 0;\n\t}\n\treturn bin->header.types_offset + type_idx * 0x04; //&bin->types[type_idx];\n}\n\nstatic void __r_bin_class_free(RBinClass *p) {\n\tr_list_free (p->methods);\n\tr_list_free (p->fields);\n\tr_bin_class_free (p);\n}\n\nstatic char *dex_class_super_name(RBinDexObj *bin, RBinDexClass *c) {\n\tint cid, tid;\n\tif (!bin || !c || !bin->types) {\n\t\treturn NULL;\n\t}\n\tcid = c->super_class;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic const ut8 *parse_dex_class_fields(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 fields_count,\n\t\t\t\t\t  bool is_sfield) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut64 lastIndex = 0;\n\tut8 ff[sizeof (DexField)] = {0};\n\tint total, i, tid;\n\tDexField field;\n\tconst char* type_str;\n\tfor (i = 0; i < fields_count; i++) {\n\t\tut64 fieldIndex, accessFlags;\n\t\t\n\t\tp = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex\n\t\tp = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags\n\t\tfieldIndex += lastIndex;\n\t\ttotal = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);\n\t\tif (total >= bin->size || total < bin->header.fields_offset) {\n\t\t\tbreak;\t\n\t\t}\n\t\tif (r_buf_read_at (binfile->buf, total, ff,\n\t\t\t\tsizeof (DexField)) != sizeof (DexField)) {\n\t\t\tbreak;\n\t\t}\n\t\tfield.class_id = r_read_le16 (ff);\n\t\tfield.type_id = r_read_le16 (ff + 2);\n\t\tfield.name_id = r_read_le32 (ff + 4);\n\t\tchar *fieldName = getstr (bin, field.name_id);\n\t\tif (field.type_id >= bin->header.types_size) {\n\t\t\tbreak;\n\t\t}\n\t\ttid = bin->types[field.type_id].descriptor_id;\n\t\ttype_str = getstr (bin, tid);\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (is_sfield) {\n\t\t\tsym->name = r_str_newf (\"%s.sfield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"STATIC\");\n\t\t} else {\n\t\t\tsym->name = r_str_newf (\"%s.ifield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t}\n\t\tsym->name = r_str_replace (sym->name, \"method.\", \"\", 0);\n\t\t//sym->name = r_str_replace (sym->name, \";\", \"\", 0);\n\t\tsym->paddr = sym->vaddr = total;\n\t\tsym->ordinal = (*sym_count)++;\n\t\t\n\t\tif (dexdump) {\n\t\t\tconst char *accessStr = createAccessFlagStr (\n\t\t\t\taccessFlags, kAccessForField);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i,\n\t\t\t\t\t cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", fieldName);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", type_str);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)accessFlags, accessStr);\n\t\t}\n\n\t\tr_list_append (bin->methods_list, sym);\n\t\tr_list_append (cls->fields, sym);\n\n\t\tlastIndex = fieldIndex;\n\t}\n\treturn p;\n}\n\n// TODO: refactor this method\n// XXX it needs a lot of love!!!\nstatic const ut8 *parse_dex_class_method(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 DM, int *methods,\n\t\t\t\t\t  bool is_direct) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut8 ff2[16] = {0};\n\tut8 ff3[8] = {0};\n\tint i;\n\tut64 omi = 0;\n\tbool catchAll;\n\tut16 regsz, ins_size, outs_size, tries_size;\n\tut16 handler_off, start_addr, insn_count;\n\tut32 debug_info_off, insns_size;\n\tconst ut8 *encoded_method_addr;\n\tfor (i = 0; i < DM; i++) {\n\t\tencoded_method_addr = p;\n\t\tchar *method_name, *flag_name;\n\t\tut64 MI, MA, MC;\n\t\tp = r_uleb128 (p, p_end - p, &MI);\n\t\tMI += omi;\n\t\tomi = MI;\n\t\tp = r_uleb128 (p, p_end - p, &MA);\n\t\tp = r_uleb128 (p, p_end - p, &MC);\n\t\t// TODO: MOVE CHECKS OUTSIDE!\n\t\tif (MI < bin->header.method_size) {\n\t\t\tif (methods) {\n\t\t\t\tmethods[MI] = 1;\n\t\t\t}\n\t\t}\n\t\tmethod_name = dex_method_name (bin, MI);\n\t\tchar *signature = dex_method_signature (bin, MI);\n\t\tif (!method_name) {\n\t\t\tmethod_name = strdup (\"unknown\");\n\t\t}\n\t\tflag_name = r_str_newf (\"%s.method.%s%s\", cls->name,\n\t\t\t\t\tmethod_name, signature);\n\t\tif (!flag_name) {\n\t\t\tR_FREE (method_name);\n\t\t\tR_FREE (signature);\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: check size\n\t\t// ut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\tut64 v2, handler_type, handler_addr;\n\t\tint t;\n\t\tif (MC > 0) { \n\t\t\t// TODO: parse debug info\n\t\t\t// XXX why binfile->buf->base???\n\t\t\tif (MC + 16 >= bin->size || MC + 16 < MC) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (r_buf_read_at (binfile->buf,\n\t\t\t\t\t   binfile->buf->base + MC, ff2,\n\t\t\t\t\t   16) < 1) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregsz = r_read_le16 (ff2);\n\t\t\tins_size = r_read_le16 (ff2 + 2);\n\t\t\touts_size = r_read_le16 (ff2 + 4);\n\t\t\ttries_size = r_read_le16 (ff2 + 6);\n\t\t\tdebug_info_off = r_read_le32 (ff2 + 8);\n\t\t\tinsns_size = r_read_le32 (ff2 + 12);\n\t\t\tint padd = 0;\n\t\t\tif (tries_size > 0 && insns_size % 2) {\n\t\t\t\tpadd = 2;\n\t\t\t}\n\t\t\tt = 16 + 2 * insns_size + padd;\n\t\t}\n\t\tif (dexdump) {\n\t\t\tconst char* accessStr = createAccessFlagStr (MA, kAccessForMethod);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", method_name);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", signature);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)MA, accessStr);\n\t\t}\n\n\t\tif (MC > 0) {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\"      code          -\\n\");\n\t\t\t\trbin->cb_printf (\"      registers     : %d\\n\", regsz);\n\t\t\t\trbin->cb_printf (\"      ins           : %d\\n\", ins_size);\n\t\t\t\trbin->cb_printf (\"      outs          : %d\\n\", outs_size);\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      insns size    : %d 16-bit code \"\n\t\t\t\t\t\"units\\n\",\n\t\t\t\t\tinsns_size);\n\t\t\t}\n\t\t\tif (tries_size > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      catches       : %d\\n\", tries_size);\n\t\t\t\t}\n\t\t\t\tint j, m = 0;\n\t\t\t\t//XXX bucle controlled by tainted variable it could produces huge loop\n\t\t\t\tfor (j = 0; j < tries_size; ++j) {\n\t\t\t\t\tut64 offset = MC + t + j * 8;\n\t\t\t\t\tif (offset >= bin->size || offset < MC) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_buf_read_at (\n\t\t\t\t\t\t    binfile->buf,\n\t\t\t\t\t\t    binfile->buf->base + offset,\n\t\t\t\t\t\t    ff3, 8) < 1) {\n\t\t\t\t\t\t// free (method_name);\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstart_addr = r_read_le32 (ff3);\n\t\t\t\t\tinsn_count = r_read_le16 (ff3 + 4);\n\t\t\t\t\thandler_off = r_read_le16 (ff3 + 6);\n\t\t\t\t\tchar* s = NULL;\n\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\"        0x%04x - \"\n\t\t\t\t\t\t\t\"0x%04x\\n\",\n\t\t\t\t\t\t\tstart_addr,\n\t\t\t\t\t\t\t(start_addr +\n\t\t\t\t\t\t\t insn_count));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst ut8 *p3, *p3_end;\n\t\t\t\t\t//XXX tries_size is tainted and oob here\n\t\t\t\t\tint off = MC + t + tries_size * 8 + handler_off;\n\t\t\t\t\tif (off >= bin->size || off < tries_size) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp3 = r_buf_get_at (binfile->buf, off, NULL);\n\t\t\t\t\tp3_end = p3 + binfile->buf->length - off;\n\t\t\t\t\tst64 size = r_sleb128 (&p3, p3_end);\n\n\t\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\tcatchAll = true;\n\t\t\t\t\t\tsize = -size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcatchAll = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (m = 0; m < size; m++) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_type);\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_addr);\n\n\t\t\t\t\t\tif (handler_type > 0 &&\n\t\t\t\t\t\t    handler_type <\n\t\t\t\t\t\t\t    bin->header.types_size) {\n\t\t\t\t\t\t\ts = getstr (bin, bin->types[handler_type].descriptor_id);\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          %s \"\n\t\t\t\t\t\t\t\t\t\"-> 0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\t\"(error) -> \"\n\t\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (catchAll) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &v2);\n\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\"<any> -> \"\n\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\tv2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"      catches       : \"\n\t\t\t\t\t\t\"(none)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      code          : (none)\\n\");\n\t\t\t}\n\t\t}\n\t\tif (*flag_name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = flag_name;\n\t\t\t// is_direct is no longer used\n\t\t\t// if method has code *addr points to code\n\t\t\t// otherwise it points to the encoded method\n\t\t\tif (MC > 0) { \n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->paddr = MC;// + 0x10;\n\t\t\t\tsym->vaddr = MC;// + 0x10;\n\t\t\t} else {\n\t\t\t\tsym->type = r_str_const (\"METH\");\n\t\t\t\tsym->paddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t\tsym->vaddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t}\n\t\t\tif ((MA & 0x1) == 0x1) {\n\t\t\t\tsym->bind = r_str_const (\"GLOBAL\");\n\t\t\t} else {\n\t\t\t\tsym->bind = r_str_const (\"LOCAL\");\n\t\t\t}\n\t\t\tsym->ordinal = (*sym_count)++;\n\t\t\tif (MC > 0) {\n\t\t\t\tif (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {\n\t\t\t\t\tR_FREE (sym);\n\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//ut16 regsz = r_read_le16 (ff2);\n\t\t\t\t//ut16 ins_size = r_read_le16 (ff2 + 2);\n\t\t\t\t//ut16 outs_size = r_read_le16 (ff2 + 4);\n\t\t\t\tut16 tries_size = r_read_le16 (ff2 + 6);\n\t\t\t\t//ut32 debug_info_off = r_read_le32 (ff2 + 8);\n\t\t\t\tut32 insns_size = r_read_le32 (ff2 + 12);\n\t\t\t\tut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\t\t\tif (tries_size > 0) {\n\t\t\t\t\t//prolog_size += 2 + 8*tries_size; // we need to parse all so the catch info...\n\t\t\t\t}\n\t\t\t\t// TODO: prolog_size\n\t\t\t\tsym->paddr = MC + prolog_size;// + 0x10;\n\t\t\t\tsym->vaddr = MC + prolog_size;// + 0x10;\n\t\t\t\t//if (is_direct) {\n\t\t\t\tsym->size = insns_size * 2;\n\t\t\t\t//}\n\t\t\t\t//eprintf(\"%s (0x%x-0x%x) size=%d\\nregsz=%d\\ninsns_size=%d\\nouts_size=%d\\ntries_size=%d\\ninsns_size=%d\\n\", flag_name, sym->vaddr, sym->vaddr+sym->size, prolog_size, regsz, ins_size, outs_size, tries_size, insns_size);\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\n\t\t\t\tif (bin->code_from > sym->paddr) {\n\t\t\t\t\tbin->code_from = sym->paddr;\n\t\t\t\t}\n\t\t\t\tif (bin->code_to < sym->paddr) {\n\t\t\t\t\tbin->code_to = sym->paddr;\n\t\t\t\t}\n\n\t\t\t\tif (!mdb) {\n\t\t\t\t\tmdb = sdb_new0 ();\n\t\t\t\t}\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", MI), sym->paddr, 0);\n\t\t\t\t// -----------------\n\t\t\t\t// WORK IN PROGRESS\n\t\t\t\t// -----------------\n\t\t\t\tif (0) {\n\t\t\t\t\tif (MA & 0x10000) { //ACC_CONSTRUCTOR\n\t\t\t\t\t\tif (!cdb) {\n\t\t\t\t\t\t\tcdb = sdb_new0 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsdb_num_set (cdb, sdb_fmt (0, \"%d\", c->class_id), sym->paddr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->size = 0;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\t\t\t}\n\t\t\tif (MC > 0 && debug_info_off > 0 && bin->header.data_offset < debug_info_off &&\n\t\t\t\tdebug_info_off < bin->header.data_offset + bin->header.data_size) {\n\t\t\t\tdex_parse_debug_item (binfile, bin, c, MI, MA, sym->paddr, ins_size, \n\t\t\t\t\tinsns_size, cls->name, regsz, debug_info_off);\n\t\t\t} else if (MC > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      positions     :\\n\");\n\t\t\t\t\trbin->cb_printf (\"      locals        :\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (flag_name);\n\t\t}\n\t\tR_FREE (signature);\n\t\tR_FREE (method_name);\n\t}\n\treturn p;\n}\n\nstatic void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}\n\nstatic bool is_class_idx_in_code_classes(RBinDexObj *bin, int class_idx) {\n\tint i;\n\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\tif (class_idx == bin->classes[i].class_id) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}\n\nstatic RList* imports(RBinFile *arch) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin && bin->imports_list) {\n\t\treturn bin->imports_list;\n\t}\n\tdex_loadcode (arch, bin);\n\treturn bin->imports_list;\n}\n\nstatic RList *methods(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->methods_list;\n}\n\nstatic RList *classes(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->classes_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->classes_list;\n}\n\nstatic int already_entry(RList *entries, ut64 vaddr) {\n\tRBinAddr *e;\n\tRListIter *iter;\n\tr_list_foreach (entries, iter, e) {\n\t\tif (e->vaddr == vaddr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tRListIter *iter;\n\tRBinDexObj *bin;\n\tRBinSymbol *m;\n\tRBinAddr *ptr;\n\tRList *ret;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tret = r_list_newf ((RListFree)free);\n\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\n\t// STEP 1. \".onCreate(Landroid/os/Bundle;)V\"\n\tr_list_foreach (bin->methods_list, iter, m) {\n\t\tif (strlen (m->name) > 30 && m->bind && \n\t\t\t!strcmp(m->bind, \"GLOBAL\") &&\n\t\t    !strcmp (m->name + strlen (m->name) - 31,\n\t\t\t     \".onCreate(Landroid/os/Bundle;)V\")) {\n\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// STEP 2. \".main([Ljava/lang/String;)V\"\n\tif (r_list_empty (ret)) {\n\t\tr_list_foreach (bin->methods_list, iter, m) {\n\t\t\tif (strlen (m->name) > 26 &&\n\t\t\t    !strcmp (m->name + strlen (m->name) - 27,\n\t\t\t\t     \".main([Ljava/lang/String;)V\")) {\n\t\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t// STEP 3. NOTHING FOUND POINT TO CODE_INIT\n\tif (r_list_empty (ret)) {\n\t\tif (!already_entry (ret, bin->code_from)) {\n\t\t\tptr = R_NEW0 (RBinAddr);\n\t\t\tif (ptr) {\n\t\t\t\tptr->paddr = ptr->vaddr = bin->code_from;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ut64 offset_of_method_idx(RBinFile *arch, struct r_bin_dex_obj_t *dex, int idx) {\n\tut64 off = dex->header.method_offset + idx;\n\toff = sdb_num_get (mdb, sdb_fmt (0, \"method.%d\", idx), 0);\n\treturn (ut64) off;\n}\n\n// TODO: change all return type for all getoffset\nstatic int getoffset(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\t// TODO: ADD CHECK\n\t\treturn offset_of_method_idx (arch, dex, idx);\n\tcase 'o': // objects\n\t\tbreak;\n\tcase 's': // strings\n\t\tif (dex->header.strings_size > idx) {\n\t\t\tif (dex->strings) return dex->strings[idx];\n\t\t}\n\t\tbreak;\n\tcase 't': // type\n\t\treturn dex_get_type_offset (arch, idx);\n\tcase 'c': // class\n\t\treturn dex_get_type_offset (arch, idx);\n\t\t//return sdb_num_get (cdb, sdb_fmt (0, \"%d\", idx), 0);\n\t}\n\treturn -1;\n}\n\nstatic char *getname(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\treturn dex_method_fullname (dex, idx);\n\tcase 'c': // classes\n\t\treturn dex_class_name_byid (dex, idx);\n\tcase 'f': // fields\n\t\treturn dex_field_name (dex, idx);\n\t}\n\treturn NULL;\n}\n\nstatic RList *sections(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tRList *ml = methods (arch);\n\tRBinSection *ptr = NULL;\n\tint ns, fsymsz = 0;\n\tRList *ret = NULL;\n\tRListIter *iter;\n\tRBinSymbol *m;\n\tint fsym = 0;\n\n\tr_list_foreach (ml, iter, m) {\n\t\tif (!fsym || m->paddr < fsym) {\n\t\t\tfsym = m->paddr;\n\t\t}\n\t\tns = m->paddr + m->size;\n\t\tif (ns > arch->buf->length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ns > fsymsz) {\n\t\t\tfsymsz = ns;\n\t\t}\n\t}\n\tif (!fsym) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"header\");\n\t\tptr->size = ptr->vsize = sizeof (struct dex_header_t);\n\t\tptr->paddr= ptr->vaddr = 0;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"constpool\");\n\t\t//ptr->size = ptr->vsize = fsym;\n\t\tptr->paddr= ptr->vaddr = sizeof (struct dex_header_t);\n\t\tptr->size = bin->code_from - ptr->vaddr; // fix size\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"code\");\n\t\tptr->vaddr = ptr->paddr = bin->code_from; //ptr->vaddr = fsym;\n\t\tptr->size = bin->code_to - ptr->paddr;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\t//ut64 sz = arch ? r_buf_size (arch->buf): 0;\n\t\tstrcpy (ptr->name, \"data\");\n\t\tptr->paddr = ptr->vaddr = fsymsz+fsym;\n\t\tif (ptr->vaddr > arch->buf->length) {\n\t\t\tptr->paddr = ptr->vaddr = bin->code_to;\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t} else {\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t\t// hacky workaround\n\t\t\t//dprintf (\"Hack\\n\");\n\t\t\t//ptr->size = ptr->vsize = 1024;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP; //|2;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic void header(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tstruct r_bin_t *rbin = arch->rbin;\n\n\trbin->cb_printf (\"DEX file header:\\n\");\n\trbin->cb_printf (\"magic               : 'dex\\\\n035\\\\0'\\n\");\n\trbin->cb_printf (\"checksum            : %x\\n\", bin->header.checksum);\n\trbin->cb_printf (\"signature           : %02x%02x...%02x%02x\\n\", bin->header.signature[0], bin->header.signature[1], bin->header.signature[18], bin->header.signature[19]);\n\trbin->cb_printf (\"file_size           : %d\\n\", bin->header.size);\n\trbin->cb_printf (\"header_size         : %d\\n\", bin->header.header_size);\n\trbin->cb_printf (\"link_size           : %d\\n\", bin->header.linksection_size);\n\trbin->cb_printf (\"link_off            : %d (0x%06x)\\n\", bin->header.linksection_offset, bin->header.linksection_offset);\n\trbin->cb_printf (\"string_ids_size     : %d\\n\", bin->header.strings_size);\n\trbin->cb_printf (\"string_ids_off      : %d (0x%06x)\\n\", bin->header.strings_offset, bin->header.strings_offset);\n\trbin->cb_printf (\"type_ids_size       : %d\\n\", bin->header.types_size);\n\trbin->cb_printf (\"type_ids_off        : %d (0x%06x)\\n\", bin->header.types_offset, bin->header.types_offset);\n\trbin->cb_printf (\"proto_ids_size       : %d\\n\", bin->header.prototypes_size);\n\trbin->cb_printf (\"proto_ids_off        : %d (0x%06x)\\n\", bin->header.prototypes_offset, bin->header.prototypes_offset);\n\trbin->cb_printf (\"field_ids_size      : %d\\n\", bin->header.fields_size);\n\trbin->cb_printf (\"field_ids_off       : %d (0x%06x)\\n\", bin->header.fields_offset, bin->header.fields_offset);\n\trbin->cb_printf (\"method_ids_size     : %d\\n\", bin->header.method_size);\n\trbin->cb_printf (\"method_ids_off      : %d (0x%06x)\\n\", bin->header.method_offset, bin->header.method_offset);\n\trbin->cb_printf (\"class_defs_size     : %d\\n\", bin->header.class_size);\n\trbin->cb_printf (\"class_defs_off      : %d (0x%06x)\\n\", bin->header.class_offset, bin->header.class_offset);\n\trbin->cb_printf (\"data_size           : %d\\n\", bin->header.data_size);\n\trbin->cb_printf (\"data_off            : %d (0x%06x)\\n\\n\", bin->header.data_offset, bin->header.data_offset);\n\n\t// TODO: print information stored in the RBIN not this ugly fix\n\tdexdump = true;\n\tbin->methods_list = NULL;\n\tdex_loadcode (arch, bin);\n\tdexdump = false;\n}\n\nstatic ut64 size(RBinFile *arch) {\n\tint ret;\n\tut32 off = 0, len = 0;\n\tut8 u32s[sizeof (ut32)] = {0};\n\n\tret = r_buf_read_at (arch->buf, 108, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\toff = r_read_le32 (u32s);\n\tret = r_buf_read_at (arch->buf, 104, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\tlen = r_read_le32 (u32s);\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_dex = {\n\t.name = \"dex\",\n\t.desc = \"dex format bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.entries = entries,\n\t.classes = classes,\n\t.sections = sections,\n\t.symbols = methods,\n\t.imports = imports,\n\t.strings = strings,\n\t.info = &info,\n\t.header = &header,\n\t.size = &size,\n\t.get_offset = &getoffset,\n\t.get_name = &getname,\n\t.dbginfo = &r_bin_dbginfo_dex,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dex,\n\t.version = R2_VERSION\n};\n#endif\n", "#ifndef R_ENDIAN_H\n#define R_ENDIAN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Endian agnostic functions working on single byte. */\n\nstatic inline ut8 r_read_ble8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn *(ut8 *)src;\n}\n\nstatic inline ut8 r_read_at_ble8(const void *src, size_t offset) {\n\treturn r_read_ble8 (((const ut8*)src) + offset);\n}\n\nstatic inline void r_write_ble8(void *dest, ut8 val) {\n\t*(ut8 *)dest = val;\n}\n\nstatic inline void r_write_at_ble8(void *dest, ut8 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_ble8 (d, val);\n}\n\n/* Big Endian functions. */\n\nstatic inline ut8 r_read_be8(const void *src) {\n\treturn r_read_ble8 (src);\n}\n\nstatic inline ut8 r_read_at_be8(const void *src, size_t offset) {\n\treturn r_read_at_ble8 (src, offset);\n}\n\nstatic inline void r_write_be8(void *dest, ut8 val) {\n\tr_write_ble8 (dest, val);\n}\n\nstatic inline void r_write_at_be8(void *dest, ut8 val, size_t offset) {\n\tr_write_at_ble8 (dest, val, offset);\n}\n\nstatic inline ut16 r_read_be16(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[0]) << 8) | (((ut16)s[1]) << 0);\n}\n\nstatic inline ut16 r_read_at_be16(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be16 (s);\n}\n\nstatic inline void r_write_be16(void *dest, ut16 val) {\n\tr_write_be8 (dest, val >> 8);\n\tr_write_at_be8 (dest, val >> 0, sizeof (ut8));\n}\n\nstatic inline void r_write_at_be16(void *dest, ut16 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be16 (d, val);\n}\n\nstatic inline ut32 r_read_be32(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[0]) << 24) | (((ut32)s[1]) << 16) |\n\t\t(((ut32)s[2]) << 8) | (((ut32)s[3]) << 0);\n}\n\nstatic inline ut32 r_read_at_be32(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be32 (s);\n}\n\nstatic inline void r_write_be32(void *dest, ut32 val) {\n\tr_write_be16 (dest, val >> 16);\n\tr_write_at_be16 (dest, val >> 0, sizeof (ut16));\n}\n\nstatic inline void r_write_be24(void *_dest, ut32 val) {\n\tut8 *dest = (ut8*)_dest;\n\tr_write_be8 (dest++, val >> 16);\n\tr_write_be8 (dest++, val >> 8);\n\tr_write_be8 (dest, val >> 0);\n}\n\nstatic inline void r_write_at_be32(void *dest, ut32 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be32 (d, val);\n}\n\nstatic inline ut64 r_read_be64(const void *src) {\n\tut64 val = ((ut64)(r_read_be32 (src))) << 32;\n\tval |= r_read_at_be32 (src, sizeof (ut32));\n\treturn val;\n}\n\nstatic inline ut64 r_read_at_be64(const void *src, size_t offset) {\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_be64 (s);\n}\n\nstatic inline void r_write_be64(void *dest, ut64 val) {\n\tr_write_be32 (dest, val >> 32);\n\tr_write_at_be32 (dest, val >> 0, sizeof (ut32));\n}\n\nstatic inline void r_write_at_be64(void *dest, ut64 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_be64 (d, val);\n}\n\n/* Little Endian functions. */\n\nstatic inline ut8 r_read_le8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn r_read_ble8 (src);\n}\n\nstatic inline ut8 r_read_at_le8(const void *src, size_t offset) {\n\treturn r_read_at_ble8 (src, offset);\n}\n\nstatic inline void r_write_le8(void *dest, ut8 val) {\n\tr_write_ble8 (dest, val);\n}\n\nstatic inline void r_write_at_le8(void *dest, ut8 val, size_t offset) {\n\tr_write_at_ble8 (dest, val, offset);\n}\n\nstatic inline ut16 r_read_le16(const void *src) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}\n\nstatic inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}\n\nstatic inline void r_write_le16(void *dest, ut16 val) {\n\tr_write_le8 (dest, val >> 0);\n\tr_write_at_le8 (dest, val >> 8, sizeof (ut8));\n}\n\nstatic inline void r_write_at_le16(void *dest, ut16 val, size_t offset) {\n\tut8 *d = (ut8 *)dest + offset;\n\tr_write_le16 (d, val);\n}\n\nstatic inline void r_write_le24(void *_dest, ut32 val) {\n\tut8* dest = (ut8*)_dest;\n\tr_write_le8 (dest++, val >> 0);\n\tr_write_le8 (dest++, val >> 8);\n\tr_write_le8 (dest,   val >> 16);\n}\n\nstatic inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}\n\nstatic inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}\n\nstatic inline void r_write_le32(void *dest, ut32 val) {\n\tr_write_le16 (dest, val >> 0);\n\tr_write_at_le16 (dest, val >> 16, sizeof (ut16));\n}\n\nstatic inline void r_write_at_le32(void *dest, ut32 val, size_t offset) {\n\tut8 *d = ((ut8*)dest) + offset;\n\tr_write_le32 (d, val);\n}\n\nstatic inline ut64 r_read_le64(const void *src) {\n\tut64 val = ((ut64)(r_read_at_le32 (src, sizeof (ut32)))) <<  32;\n\tval |= r_read_le32 (src);\n\treturn val;\n}\n\nstatic inline ut64 r_read_at_le64(const void *src, size_t offset) {\n\tconst ut8 *s = ((const ut8*)src) + offset;\n\treturn r_read_le64 (s);\n}\n\nstatic inline void r_write_le64(void *dest, ut64 val) {\n\tr_write_le32 (dest, val >> 0);\n\tr_write_at_le32 (dest, val >> 32, sizeof (ut32));\n}\n\nstatic inline void r_write_at_le64(void *dest, ut64 val, size_t offset) {\n\tut8 *d = (ut8*)dest + offset;\n\tr_write_le64 (d, val);\n}\n\n/* Helper functions */\n\nstatic inline ut16 r_read_ble16(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be16 (src): r_read_le16 (src);\n}\n\nstatic inline ut32 r_read_ble32(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be32 (src): r_read_le32 (src);\n}\n\nstatic inline ut64 r_read_ble64(const void *src, bool big_endian) {\n\treturn big_endian? r_read_be64 (src): r_read_le64 (src);\n}\n\nstatic inline ut64 r_read_ble(const void *src, bool big_endian, int size) {\n\tswitch (size) {\n\tcase 8:\n\t\treturn (ut64) ((ut8*)src)[0];\n\tcase 16:\n\t\treturn r_read_ble16 (src, big_endian);\n\tcase 32:\n\t\treturn r_read_ble32 (src, big_endian);\n\tcase 64:\n\t\treturn r_read_ble64 (src, big_endian);\n\tdefault:\n\t\treturn UT64_MAX;\n\t}\n}\n\nstatic inline void r_write_ble16(void *dest, ut16 val, bool big_endian) {\n\tbig_endian? r_write_be16 (dest, val): r_write_le16 (dest, val);\n}\n\nstatic inline void r_write_ble24(void *dest, ut32 val, bool big_endian) {\n\tbig_endian? r_write_be24 (dest, val): r_write_le24 (dest, val);\n}\n\nstatic inline void r_write_ble32(void *dest, ut32 val, bool big_endian) {\n\tbig_endian? r_write_be32 (dest, val): r_write_le32 (dest, val);\n}\n\nstatic inline void r_write_ble64(void *dest, ut64 val, bool big_endian) {\n\tbig_endian? r_write_be64 (dest, val): r_write_le64 (dest, val);\n}\n\nstatic inline void r_write_ble(void *dst, ut64 val, bool big_endian, int size) {\n\tswitch (size) {\n\tcase 8:\n\t\t((ut8*)dst)[0] = (ut8) val;\n\t\tbreak;\n\tcase 16:\n\t\tr_write_ble16 (dst, (ut16) val, big_endian);\n\t\tbreak;\n\tcase 24:\n\t\tr_write_ble24 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 32:\n\t\tr_write_ble32 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 64:\n\t\tr_write_ble64 (dst, val, big_endian);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n// TODO: find better names and write vapis\n#define ut8p_b(x) ((x)[0])\n#define ut8p_bw(x) ((x)[0]|((x)[1]<<8))\n#define ut8p_bd(x) ((x)[0]|((x)[1]<<8)|((x)[2]<<16)|((x)[3]<<24))\n#define ut8p_bq(x) ((x)[0]|((x)[1]<<8)|((x)[2]<<16)|((x)[3]<<24)|((x)[4]<<32)|((x)[5]<<40)|((x)[6]<<48)|((x)[7]<<56))\n#define ut8p_lw(x) ((x)[1]|((x)[0]<<8))\n#define ut8p_ld(x) ((x)[3]|((x)[2]<<8)|((x)[1]<<16)|((x)[0]<<24))\n#define ut8p_lq(x) ((x)[7]|((x)[6]<<8)|((x)[5]<<16)|((x)[4]<<24)|((x)[3]<<32)|((x)[2]<<40)|((x)[1]<<48)|((x)[0]<<56))\n\n/*swap*/\nstatic inline ut16 r_swap_ut16(ut16 val) {\n\treturn (val << 8) | (val >> 8 );\n}\n\nstatic inline st16 r_swap_st16(st16 val) {\n\tval = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | (val >> 16);\n}\n\nstatic inline ut32 r_swap_ut32(ut32 val) {\n\tval = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | (val >> 16);\n}\n\nstatic inline st32 r_swap_st32(st32 val) {\n\tval = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF );\n\treturn (val << 16) | ((val >> 16) & 0xFFFF);\n}\n\nstatic inline ut64 r_swap_ut64(ut64 val) {\n\tval = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL );\n\tval = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL );\n\treturn (val << 32) | (val >> 32);\n}\n\nstatic inline st64 r_swap_st64(st64 val) {\n\tval = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL );\n\tval = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL );\n\treturn (val << 32) | ((val >> 32) & 0xFFFFFFFFULL);\n}\n\n/* Some \"secured\" functions, to do basic operation (mul, sub, add...) on integers */\nstatic inline int UT64_ADD(ut64 *r, ut64 a, ut64 b) {\n\tif (UT64_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT64_MUL(ut64 *r, ut64 a, ut64 b) {\n\tif (a && UT64_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT64_SUB(ut64 *r, ut64 a, ut64 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_ADD(ut32 *r, ut32 a, ut32 b) {\n\tif (UT32_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_MUL(ut32 *r, ut32 a, ut32 b) {\n\tif (a && UT32_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT32_SUB(ut32 *r, ut32 a, ut32 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_ADD(ut16 *r, ut16 a, ut16 b) {\n\tif (UT16_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_MUL(ut16 *r, ut16 a, ut16 b) {\n\tif (a && UT16_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT16_SUB(ut16 *r, ut16 a, ut16 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_ADD(ut8 *r, ut8 a, ut8 b) {\n\tif (UT8_MAX - a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a + b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_MUL(ut8 *r, ut8 a, ut8 b) {\n\tif (a && UT8_MAX / a < b) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a * b;\n\t}\n\treturn 1;\n}\n\nstatic inline int UT8_SUB(ut8 *r, ut8 a, ut8 b) {\n\tif (b > a) {\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\t*r = a - b;\n\t}\n\treturn 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "filenames": ["doc/uncrustify.cfg", "libr/bin/p/bin_dex.c", "libr/include/r_endian.h"], "buggy_code_start_loc": [486, 1325, 10], "buggy_code_end_loc": [487, 1326, 428], "fixing_code_start_loc": [486, 1325, 11], "fixing_code_end_loc": [487, 1326, 448], "type": "CWE-476", "message": "The r_read_* functions in libr/include/r_endian.h in radare2 1.2.1 allow remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted binary file, as demonstrated by the r_read_le32 function.", "other": {"cve": {"id": "CVE-2017-6197", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-24T04:59:00.217", "lastModified": "2017-03-02T02:59:02.977", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The r_read_* functions in libr/include/r_endian.h in radare2 1.2.1 allow remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted binary file, as demonstrated by the r_read_le32 function."}, {"lang": "es", "value": "Las funciones r_read_* en libr/include/r_endian.h en radare2 1.2.1 permiten a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo binario manipulado, como se demuestra por la funci\u00f3n r_read_le32."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1E2BB74D-D369-43D4-9EDB-3F0DD27091B0"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96433", "source": "cve@mitre.org"}, {"url": "https://github.com/radare/radare2/commit/1ea23bd6040441a21fbcfba69dce9a01af03f989", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/radare/radare2/issues/6816", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/1ea23bd6040441a21fbcfba69dce9a01af03f989"}}