{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_class\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_enum\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_type\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t\temsg(_(e_at_end_of_file));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    if (RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n    --no_wait_return;\n    update_screen(UPD_CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc_RedrawingDisabled = FALSE;\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return() for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc_RedrawingDisabled = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL && lines_ga.ga_len > current_line)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc_RedrawingDisabled)\n    {\n\tif (RedrawingDisabled > 0)\n\t    --RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return() we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw(void)\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION;\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(e_exception_not_caught_str),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP;\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW;\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, 0);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tsave_pending_end_reg_executing = pending_end_reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n    int\t\tmay_have_range;\n#ifdef FEAT_EVAL\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n    int\t\tdid_append_cmd = FALSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    int vim9script = in_vim9script();\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    // Handle \":export\" - it functions almost like a command modifier.\n    // \":export var Name: type\"\n    // \":export def Name(...\"\n    // etc.\n    if (vim9script && checkforcmd_noparen(&ea.cmd, \"export\", 6))\n\tis_export = TRUE;\n#endif\n\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n#ifdef FEAT_EVAL\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n#else\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n#endif\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n#endif\n\n    ea.cmd = cmd;\n\n#ifdef FEAT_EVAL\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\tgoto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\terrormsg = ex_range_without_command(&ea);\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(e_not_an_editor_command));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t\tdid_append_cmd = TRUE;\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(e_command_not_allowed_in_rvim);\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    errormsg = _(e_no_range_allowed);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\n    {\n\terrormsg = _(e_no_bang_allowed);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(e_backwards_range_given);\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invalid_argument);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(e_use_w_or_w_gt_gt);\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea, FALSE);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n' && !(ea.argt & EX_EXPR_ARG))\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalid_register_name);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits_quoted(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_positive_count_required);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    if (ea.line2 >= LONG_MAX - (n - 1))\n\t\tea.line2 = LONG_MAX;  // avoid overflow\n\t    else\n\t\tea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_characters_str, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argument_required);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_horizontal:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if ((ea.argt & EX_XFILE)\n\t    && expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\tgoto doend;\n\n#ifdef FEAT_EVAL\n    if (is_export && (ea.argt & EX_EXPORT) == 0)\n    {\n\temsg(_(e_invalid_command_after_export));\n\tgoto doend;\n    }\n#endif\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // A command will reset \"is_export\" when exporting an item.  If it is still\n    // set something went wrong or the command was never executed.\n    if (!ea.skip && is_export)\n    {\n\tif (errormsg == NULL)\n\t    errormsg = _(e_export_with_invalid_argument);\n\tis_export = FALSE;\n    }\n\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (sourcing_a_script(&ea)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif ((sourcing || !KeyTyped) && !did_append_cmd)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n    is_export = FALSE;\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n    pending_end_reg_executing = save_pending_end_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Handle a range without a command.\n * Returns an error message on failure.\n */\n    char *\nex_range_without_command(exarg_T *eap)\n{\n    char *errormsg = NULL;\n\n    if ((*eap->cmd == '|' || (exmode_active && eap->line1 != eap->line2))\n#ifdef FEAT_EVAL\n\t    && !in_vim9script()\n#endif\n       )\n    {\n\teap->cmdidx = CMD_print;\n\teap->argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\tif ((errormsg = invalid_range(eap)) == NULL)\n\t{\n\t    correct_range(eap);\n\t    ex_print(eap);\n\t}\n    }\n    else if (eap->addr_count != 0)\n    {\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t{\n\t    // With '-' in 'cpoptions' a line number past the file is an\n\t    // error, otherwise put it at the end of the file.\n\t    if (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\teap->line2 = -1;\n\t    else\n\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t}\n\n\tif (eap->line2 < 0)\n\t    errormsg = _(e_invalid_range);\n\telse\n\t{\n\t    if (eap->line2 == 0)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    return errormsg;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\" or \".\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !ASCII_ISALPHA((*pp)[i]) && (*pp)[i] != '_'\n\t\t\t && (!noparen || ((*pp)[i] != '(' && (*pp)[i] != '.')))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\" or \".\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script)\n\t    {\n\t\tif (has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n#ifdef FEAT_EVAL\n\t\tif (eap->cmd[0] == '#' && eap->cmd[1] == '{'\n\t\t\t\t\t\t\t && eap->cmd[2] != '{')\n\t\t    *errormsg = _(e_cannot_use_hash_curly_to_start_comment);\n#endif\n\t    }\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmdmods[].\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t    case 'h':\tif (checkforcmd_noparen(&eap->cmd, \"horizontal\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_HOR;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t\t\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\t\t//  longer, in case it was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose > 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose - 1;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    size_t  len = STRLEN(IObuff);\n    char_u  *s = cmd;\n    char_u  *d;\n\n    if (len > IOSIZE - 100)\n    {\n\t// Not enough space, truncate and put in \"...\".\n\td = IObuff + IOSIZE - 100;\n\td -= mb_head_off(IObuff, d);\n\tSTRCPY(d, \"...\");\n    }\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n#endif\n\n/*\n * Return TRUE and set \"*idx\" if \"p\" points to a one letter command.\n * If not in Vim9 script:\n * - The 'k' command can directly be followed by any character.\n * - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n *\t    but :sre[wind] is another command, as are :scr[iptnames],\n *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n */\n    static int\none_letter_cmd(char_u *p, cmdidx_T *idx)\n{\n    if (in_vim9script())\n\treturn FALSE;\n    if (*p == 'k')\n    {\n\t*idx = CMD_k;\n\treturn TRUE;\n    }\n    if (p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\t*idx = CMD_substitute;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if \"cmd\" starts with \"123->\", a number followed by a method\n * call.\n */\n    int\nnumber_method(char_u *cmd)\n{\n    char_u *p = skipdigits(cmd);\n\n    return p > cmd && (p = skipwhite(p))[0] == '-' && p[1] == '>';\n}\n#endif\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL)\n\t       || (p[0] == '0' && p[1] == 'z'))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || (eap->cmd[0] == '$'\n\t\t\t\t  && eap->cmd[1] != '\\'' && eap->cmd[1] != '\"')\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // '$\"string\"->func()' is an expression.\n\t\t\t    // \"$'string'->func()\" is an expression.\n\t\t\t || (eap->cmd[0] == '$'\n\t\t\t     && (eap->cmd[1] == '\\'' || eap->cmd[1] == '\"'))\n\t\t\t    // '0z1234->func()' is an expression.\n\t\t\t || (eap->cmd[0] == '0' && eap->cmd[1] == 'z')\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if ((p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.'\n\t\t\t\t     && (ASCII_ISALPHA(p[1]) || p[1] == '_'))))\n\t\t\t// g:[key] is an expression\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0)\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    // Not \"redir => var\" (when skipping).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| (eap->skip && IS_WHITE_OR_NUL(\n\t\t\t\t\t\t      *(skipwhite(p) + oplen)))\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize trying to use a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_var;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// 1234->func() is a method call\n\tif (number_method(eap->cmd))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// \"g:\", \"s:\" and \"l:\" are always assumed to be a variable, thus start\n\t// an expression.  A global/substitute/list command needs to use a\n\t// longer name.\n\tif (vim_strchr((char_u *)\"gsl\", *p) != NULL && p[1] == ':')\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] != NUL && p[0] == p[1]\n\t\t\t\t\t\t   && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     */\n    p = eap->cmd;\n    if (one_letter_cmd(p, &eap->cmdidx))\n    {\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\t// The \"d\" command can directly be followed by 'l' or 'p' flag, when\n\t// not in Vim9 script.\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(e_command_table_needs_to_be_updated_run_make_cmdidxs);\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL && cmdnames[eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// :Print and :mode are not supported in Vim9 script.\n\t// Some commands cannot be shortened in Vim9 script.\n\tif (vim9 && eap->cmdidx != CMD_SIZE)\n\t{\n\t    if (eap->cmdidx == CMD_mode || eap->cmdidx == CMD_Print)\n\t\teap->cmdidx = CMD_SIZE;\n\t    else if ((cmdnames[eap->cmdidx].cmd_argt & EX_WHOLE)\n\t\t\t  && len < (int)STRLEN(cmdnames[eap->cmdidx].cmd_name))\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), eap->cmd);\n\t\teap->cmdidx = CMD_SIZE;\n\t    }\n\t}\n\n\t// Do not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" in legacy script, for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4 && !vim9)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"horizontal\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"legacy\", 3, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n    {\"vim9cmd\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.flags = 0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T\tea;\n    char_u\t*name;\n    char_u\t*p;\n    int\t\tvim9script = in_vim9script();\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    name = argvars[0].vval.v_string;\n    if (name == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tvim9script = tv_get_bool(&argvars[1]);\n\tcmdmod.cmod_flags &= ~(CMOD_VIM9CMD | CMOD_LEGACY);\n\tcmdmod.cmod_flags |= vim9script ? CMOD_VIM9CMD : CMOD_LEGACY;\n    }\n\n    while (*name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    ++emsg_silent;  // don't complain about using \"en\" in Vim9 script\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    --emsg_silent;\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\tgoto theend;\n\n    if (vim9script)\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    goto theend;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\ntheend:\n    cmdmod.cmod_flags = save_cmod_flags;\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    if (!one_letter_cmd(cmd, &idx))\n\tfor (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t\tidx = (cmdidx_T)((int)idx + 1))\n\t    if (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t\tbreak;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd_start,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    char_u\t*cmd = cmd_start;\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    char_u *p = cmd;\n\n\t    // a quote is only valid at the start or after a separator\n\t    while (p > cmd_start)\n\t    {\n\t\t--p;\n\t\tif (!VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    if (cmd > cmd_start && !VIM_ISWHITE(*p) && *p != ',' && *p != ';')\n\t\tbreak;\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_no_range_allowed));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1'\n\t\tn = 1;\n\t    else\n\t    {\n\t\t// \"number\", \"+number\" or \"-number\"\n\t\tn = getdigits(&cmd);\n\t\tif (n == MAXLNUM)\n\t\t{\n\t\t    emsg(_(e_line_number_out_of_range));\n\t\t    goto error;\n\t\t}\n\t    }\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing: need to adjust for lines in a\n\t\t// closed fold after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t\t\t\t\t && address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t{\n\t\t    if (n >= LONG_MAX - lnum)\n\t\t    {\n\t\t\temsg(_(e_line_number_out_of_range));\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum += n;\n\t\t}\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(\"Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\");\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(e_sorry_command_is_not_available_in_this_version);\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t{\n\t\t    if (eap->addr_count == 0)\n\t\t\treturn _(e_no_errors);\n\t\t    return _(e_invalid_range);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + (size_t)i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t    errormsgp, &escaped, TRUE);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n * If \"keep_backslash\" is TRUE do not remove any backslash.\n */\n    void\nseparate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"'/'#': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n\t\t    && !in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t// remove the '\\'\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_characters_str, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n    if (in_vim9script())\n\tcomment_char = '#';\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(e_nr_more_file_to_edit,\n\t\t\t   e_nr_more_files_to_edit , n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(e_cannot_find_color_scheme_str), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(UPD_CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * Do preparations for \"qall\" and \"wqall\".\n * Returns FAIL when quitting should be aborted.\n */\n    int\nbefore_quit_all(exarg_T *eap)\n{\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn FAIL;\n    }\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n    if (before_quit_all(eap) == FAIL)\n\treturn;\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (is_aucmd_win(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn;\n    }\n    if (window_layout_locked(CMD_close))\n\treturn;\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n# ifdef FEAT_TERMINAL\n\t    if (term_job_running(buf->b_term))\n\t    {\n\t\tif (term_confirm_stop(buf) == FAIL)\n\t\t    return;\n\t\t// Manually kill the terminal here because this command will\n\t\t// hide it otherwise.\n\t\tfree_terminal(buf);\n\t\tneed_hide = FALSE;\n\t    }\n\t    else\n# endif\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tdialog_changed(buf, FALSE);\n\t\tif (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\t    return;\n\t\tneed_hide = FALSE;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invalid_value_for_argument_str,\n\t\t\t\t\t\t\t\t     eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (first_tabpage->tp_next == NULL)\n    {\n\temsg(_(e_cannot_close_last_tab_page));\n\treturn;\n    }\n\n    if (window_layout_locked(CMD_tabclose))\n\treturn;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg != NULL)\n\treturn;\n\n    tp = find_tabpage(tab_number);\n    if (tp == NULL)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (tp != curtab)\n    {\n\ttabpage_close_other(tp, eap->forceit);\n\treturn;\n    }\n    else if (!text_locked() && !curbuf_locked())\n\ttabpage_close(eap->forceit);\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (first_tabpage->tp_next == NULL)\n    {\n\tmsg(_(\"Already only one tab page\"));\n\treturn;\n    }\n\n    if (window_layout_locked(CMD_tabonly))\n\treturn;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg != NULL)\n\treturn;\n\n    goto_tabpage(tab_number);\n    // Repeat this up to a 1000 times, because autocommands may\n    // mess up the lists.\n    for (done = 0; done < 1000; ++done)\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_topframe != topframe)\n\t    {\n\t\ttabpage_close_other(tp, eap->forceit);\n\t\t// if we failed to close it quit\n\t\tif (valid_tabpage(tp))\n\t\t    done = 1000;\n\t\t// start over, \"tp\" is now invalid\n\t\tbreak;\n\t    }\n\tif (first_tabpage->tp_next == NULL)\n\t    break;\n    }\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    if (window_layout_locked(CMD_tabclose))\n\treturn;\n\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    if (window_layout_locked(CMD_only))\n\treturn;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twin_T   *wp;\n\tint\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (eap->skip)\n\treturn;\n\n    if (window_layout_locked(CMD_hide))\n\treturn;\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    if (eap->addr_count == 0)\n\twin_close(curwin, FALSE);\t// don't free buffer\n    else\n    {\n\tint\twinnr = 0;\n\twin_T\t*win;\n\n\tFOR_ALL_WINDOWS(win)\n\t{\n\t    winnr++;\n\t    if (winnr == eap->line2)\n\t\tbreak;\n\t}\n\tif (win == NULL)\n\t    win = lastwin;\n\twin_close(win, FALSE);\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (check_restricted())\n\treturn;\n\n    if (!eap->forceit)\n\tautowrite_all();\n    apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n    windgoto((int)Rows - 1, 0);\n    out_char('\\n');\n    out_flush();\n    stoptermcap();\n    out_flush();\t\t// needed for SUN to restore xterm buffer\n    mch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n    ui_suspend();\t\t// call machine specific function\n    maketitle();\n    resettitle();\t\t// force updating the title\n    starttermcap();\n    scroll_start();\t\t// scroll screen before redrawing\n    redraw_later_clear();\n    shell_resized();\t// may have resized window\n    apply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_empty_buffer));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.  Also for other commands that can't\n * appear at the toplevel.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = ex_errmsg(e_invalid_command_str, eap->cmd);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n    char_u\t*fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tchar_u\t*file_to_find = NULL;\n\tchar\t*search_ctx = NULL;\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname,\n\t\t\t\t\t  &file_to_find, &search_ctx);\n\tvim_free(file_to_find);\n\tvim_findfile_cleanup(search_ctx);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\ntheend:\n    vim_free(fname);\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screen_mode_setting_not_supported));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win(n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win(n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n    char_u\t*fname;\n    int\t\tcount;\n    char_u\t*file_to_find = NULL;\n    char\t*search_ctx = NULL;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t   TRUE, curbuf->b_ffname, &file_to_find, &search_ctx);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it appears\n\t// several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t  FALSE, curbuf->b_ffname, &file_to_find, &search_ctx);\n\t}\n    }\n    VIM_CLEAR(file_to_find);\n    vim_findfile_cleanup(search_ctx);\n\n    if (fname == NULL)\n\treturn;\n\n    eap->arg = fname;\n    do_exedit(eap, NULL);\n    vim_free(fname);\n}\n\n/*\n * \":open\" simulation: for now works just like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    // make a copy of the line, when searching for a mark it might be\n\t    // flushed\n\t    char_u *line = vim_strsave(ml_get_curline());\n\n\t    regmatch.rm_ic = p_ic;\n\t    if (vim_regexec(&regmatch, line, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);\n\t    else\n\t\temsg(_(e_no_match));\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(line);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tint save_RedrawingDisabled = RedrawingDisabled;\n\t\tRedrawingDisabled = 0;\n\t\tint save_nwr = no_wait_return;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tint save_ms = msg_scroll;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\tint save_he = hold_gui_events;\n\t\thold_gui_events = 0;\n#endif\n\t\tset_must_redraw(UPD_CLEAR);\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = save_RedrawingDisabled;\n\t\tno_wait_return = save_nwr;\n\t\tmsg_scroll = save_ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = save_he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit a new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"textlock\" or \"curbuf_lock\" is set.\n\t// Only \":edit\" or \":script\" can bring us here, others are stopped\n\t// earlier.\n\tif (*eap->arg != NUL && text_or_buf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n\tn = curwin->w_arg_idx_invalid;\n\tcheck_arg_idx(curwin);\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n    {\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n\treturn;\n    }\n\n    if (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browseFile;\n\n\tbrowseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\tNULL, NULL, NULL, curbuf);\n\tif (browseFile != NULL)\n\t{\n\t    i = readfile(browseFile, NULL,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t    vim_free(browseFile);\n\t}\n\telse\n\t    i = OK;\n    }\n    else\n#endif\n\tif (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n    if (i != OK)\n    {\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    semsg(_(e_cant_open_file_str), eap->arg);\n    }\n    else\n    {\n\tif (empty && exmode_active)\n\t{\n\t    // Delete the empty line that remains.  Historically ex does\n\t    // this but vi doesn't.\n\t    if (eap->line2 == 0)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t    {\n\t\tml_delete(lnum);\n\t\tif (curwin->w_cursor.lnum > 1\n\t\t\t&& curwin->w_cursor.lnum >= lnum)\n\t\t    --curwin->w_cursor.lnum;\n\t\tdeleted_lines_mark(lnum, 1L);\n\t    }\n\t}\n\tredraw_curbuf_later(UPD_VALID);\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    last_chdir_reason = NULL;\n    shorten_fnames(TRUE);\n}\n\n/*\n * Trigger DirChangedPre for \"acmd_fname\" with directory \"new_dir\".\n */\n    void\ntrigger_DirChangedPre(char_u *acmd_fname, char_u *new_dir)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"directory\", new_dir);\n    dict_set_items_ro(v_event);\n#endif\n    apply_autocmds(EVENT_DIRCHANGEDPRE, acmd_fname, new_dir, FALSE, curbuf);\n#ifdef FEAT_EVAL\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    char_u\t*acmd_fname = NULL;\n    char_u\t**pp;\n    char_u\t*tofree;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(e_cannot_change_directory_buffer_is_modified_add_bang_to_override));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(e_no_previous_directory));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n\n    // For UNIX \":cd\" means: go to home directory.\n    // On other systems too if 'cdhome' is set.\n#if defined(UNIX) || defined(VMS)\n    if (*new_dir == NUL)\n#else\n    if (*new_dir == NUL && p_cdh)\n#endif\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n    dir_differs = pdir == NULL\n\t\t\t    || pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (dir_differs)\n    {\n\tif (scope == CDSCOPE_WINDOW)\n\t    acmd_fname = (char_u *)\"window\";\n\telse if (scope == CDSCOPE_TABPAGE)\n\t    acmd_fname = (char_u *)\"tabpage\";\n\telse\n\t    acmd_fname = (char_u *)\"global\";\n\ttrigger_DirChangedPre(acmd_fname, new_dir);\n\n\tif (vim_chdir(new_dir))\n\t{\n\t    emsg(_(e_command_failed));\n\t    vim_free(pdir);\n\t    return FALSE;\n\t}\n    }\n\n    if (scope == CDSCOPE_WINDOW)\n\tpp = &curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tpp = &curtab->tp_prevdir;\n    else\n\tpp = &prev_dir;\n    tofree = *pp;  // new_dir may use this\n    *pp = pdir;\n\n    post_chdir(scope);\n\n    if (dir_differs)\n\tapply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE, curbuf);\n    vim_free(tofree);\n    return TRUE;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory unless 'cdhome' is set\n    if (*new_dir == NUL && !p_cdh)\n    {\n\tex_pwd(NULL);\n\treturn;\n    }\n#endif\n\n    cdscope_T\tscope = CDSCOPE_GLOBAL;\n\n    if (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\tscope = CDSCOPE_WINDOW;\n    else if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\tscope = CDSCOPE_TABPAGE;\n\n    if (changedir_func(new_dir, eap->forceit, scope))\n    {\n\t// Echo the new current directory if the command was typed.\n\tif (KeyTyped || p_verbose >= 5)\n\t    ex_pwd(eap);\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (last_chdir_reason != NULL)\n\t\tcontext = last_chdir_reason;\n\t    else if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(e_directory_unknown));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invalid_argument_str), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n\tcursor_sleep();\n    else\n\tcursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n\tcursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invalid_argument_str), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(e_winsize_requires_two_number_arguments));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invalid_argument));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(e_obtaining_window_position_not_implemented_for_this_platform));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(e_winpos_requires_two_number_arguments));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    int\tsave_efr = exec_from_reg;\n\n    exec_from_reg = TRUE;\n\n    /*\n     * Execute from the typeahead buffer.\n     * Continue until the stuff buffer is empty and all added characters\n     * have been consumed.\n     */\n    while (!stuff_empty() || typebuf.tb_len > prev_len)\n\t(void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n    exec_from_reg = save_efr;\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(e_cannot_use_redir_inside_execute));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invalid_argument_str), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw, with clear for \":redraw!\".\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    redraw_cmd(eap->forceit);\n}\n\n/*\n * \":redraw\": force redraw, with clear if \"clear\" is TRUE.\n */\n    void\nredraw_cmd(int clear)\n{\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    validate_cursor();\n    update_topline();\n    update_screen(clear ? UPD_CLEAR : VIsual_active ? UPD_INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n\n    // After drawing the statusline screen_attr may still be set.\n    screen_stop_highlight();\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    // When invoked from a callback or autocmd the command line may be active.\n    if (State & MODE_CMDLINE)\n\tredrawcmdline();\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    if (msg_scrolled && (State & MODE_CMDLINE))\n\treturn;  // redraw later\n\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    if (State & MODE_CMDLINE)\n\tredraw_statuslines();\n    else\n\tupdate_screen(VIsual_active ? UPD_INVERTED : 0);\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(e_cannot_create_directory_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_str_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(e_str_exists_add_bang_to_override), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(e_cannot_open_str_for_writing_2), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n    {\n\temsg(_(e_argument_required));\n\treturn;\n    }\n\n    if (eap->arg[1] != NUL)\t// more than one character?\n    {\n\tsemsg(_(e_trailing_characters_str), eap->arg);\n\treturn;\n    }\n\n    pos = curwin->w_cursor;\t\t// save curwin->w_cursor\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_WHITE | BL_FIX);\n    if (setmark(*eap->arg) == FAIL)\t// set mark\n\temsg(_(e_argument_must_be_letter_or_forward_backward_quote));\n    curwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n    sst->save_pending_end_reg_executing = pending_end_reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    pending_end_reg_executing = sst->save_pending_end_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_not_allowed_here));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(e_recursive_use_of_normal_too_deep));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & MODE_INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_characters_str, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(UPD_VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<script>\",\t\t// script file name\n#define SPEC_SCRIPT (SPEC_STACK + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_SCRIPT + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<script>\" to current script name\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped,\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n    int\t\tempty_is_error)\t// empty result is considered an error\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(e_hashsmall_is_not_available_without_the_eval_feature);\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(e_no_alternate_file_name_to_substitute_for_hash);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_buffer_number_to_substitute_for_abuf);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\t\tresult = estack_sfile(ESTACK_SFILE);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_call_stack_to_substitute_for_stack);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_SCRIPT:\t// script file name\n\t\tresult = estack_sfile(ESTACK_SCRIPT);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_script_file_name_to_substitute_for_script);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_slnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_sflnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_using_sid_not_in_script_context);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (empty_is_error)\n\t{\n\t    if (valid != VALID_HEAD + VALID_PATH)\n\t\t*errormsg = _(e_empty_file_name_for_percent_or_hash_only_works_with_ph);\n\t    else\n\t\t*errormsg = _(e_evaluates_to_an_empty_string);\n\t}\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL, TRUE);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\",\n\t\t\t\t\t\t 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t     0L, (char_u *)\"popup\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\",\n\t\t\t\t\t  0L, (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t    0L, (char_u *)\"extend\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (did_filetype)\n\treturn;\n\n    char_u *arg = eap->arg;\n    if (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\targ += 9;\n\n    set_option_value_give_err((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n    if (arg != eap->arg)\n\tdid_filetype = FALSE;\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(UPD_SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n", "\" Tests for various functions.\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\n\" Must be done first, since the alternate buffer must be unset.\nfunc Test_00_bufexists()\n  call assert_equal(0, bufexists('does_not_exist'))\n  call assert_equal(1, bufexists(bufnr('%')))\n  call assert_equal(0, bufexists(0))\n  new Xfoo\n  let bn = bufnr('%')\n  call assert_equal(1, bufexists(bn))\n  call assert_equal(1, bufexists('Xfoo'))\n  call assert_equal(1, bufexists(getcwd() . '/Xfoo'))\n  call assert_equal(1, bufexists(0))\n  bw\n  call assert_equal(0, bufexists(bn))\n  call assert_equal(0, bufexists('Xfoo'))\nendfunc\n\nfunc Test_has()\n  call assert_equal(1, has('eval'))\n  call assert_equal(1, has('eval', 1))\n\n  if has('unix')\n    call assert_equal(1, or(has('ttyin'), 1))\n    call assert_equal(0, and(has('ttyout'), 0))\n    call assert_equal(1, has('multi_byte_encoding'))\n    call assert_equal(0, has(':tearoff'))\n  endif\n  call assert_equal(1, has('vcon', 1))\n  call assert_equal(1, has('mouse_gpm_enabled', 1))\n\n  call assert_equal(has('gui_win32') && has('menu'), has(':tearoff'))\n\n  call assert_equal(0, has('nonexistent'))\n  call assert_equal(0, has('nonexistent', 1))\n\n  \" Will we ever have patch 9999?\n  let ver = 'patch-' .. v:version / 100 .. '.' .. v:version % 100 .. '.9999'\n  call assert_equal(0, has(ver))\n\n  \" There actually isn't a patch 9.0.0, but this is more consistent.\n  call assert_equal(1, has('patch-9.0.0'))\nendfunc\n\nfunc Test_empty()\n  call assert_equal(1, empty(''))\n  call assert_equal(0, empty('a'))\n\n  call assert_equal(1, empty(0))\n  call assert_equal(1, empty(-0))\n  call assert_equal(0, empty(1))\n  call assert_equal(0, empty(-1))\n\n  call assert_equal(1, empty(0.0))\n  call assert_equal(1, empty(-0.0))\n  call assert_equal(0, empty(1.0))\n  call assert_equal(0, empty(-1.0))\n  call assert_equal(0, empty(1.0/0.0))\n  call assert_equal(0, empty(0.0/0.0))\n\n  call assert_equal(1, empty([]))\n  call assert_equal(0, empty(['a']))\n\n  call assert_equal(1, empty({}))\n  call assert_equal(0, empty({'a':1}))\n\n  call assert_equal(1, empty(v:null))\n  call assert_equal(1, empty(v:none))\n  call assert_equal(1, empty(v:false))\n  call assert_equal(0, empty(v:true))\n\n  if has('channel')\n    call assert_equal(1, empty(test_null_channel()))\n  endif\n  if has('job')\n    call assert_equal(1, empty(test_null_job()))\n  endif\n\n  call assert_equal(0, empty(function('Test_empty')))\n  call assert_equal(0, empty(function('Test_empty', [0])))\n\n  call assert_fails(\"call empty(test_void())\", ['E340:', 'E685:'])\n  call assert_fails(\"call empty(test_unknown())\", ['E340:', 'E685:'])\nendfunc\n\nfunc Test_err_teapot()\n  call assert_fails('call err_teapot()', \"E418: I'm a teapot\")\n  call assert_fails('call err_teapot(0)', \"E418: I'm a teapot\")\n  call assert_fails('call err_teapot(v:false)', \"E418: I'm a teapot\")\n\n  call assert_fails('call err_teapot(\"1\")', \"E503: Coffee is currently not available\")\n  call assert_fails('call err_teapot(v:true)', \"E503: Coffee is currently not available\")\n  let expr = 1\n  call assert_fails('call err_teapot(expr)', \"E503: Coffee is currently not available\")\nendfunc\n\nfunc Test_test_void()\n  call assert_fails('echo 1 == test_void()', 'E1031:')\n  call assert_fails('echo 1.0 == test_void()', 'E1031:')\n  call assert_fails('let x = json_encode(test_void())', ['E340:', 'E685:'])\n  call assert_fails('let x = copy(test_void())', ['E340:', 'E685:'])\n  call assert_fails('let x = copy([test_void()])', 'E1031:')\nendfunc\n\nfunc Test_islocked()\n  call assert_fails('call islocked(99)', 'E475:')\n  call assert_fails('call islocked(\"s: x\")', 'E488:')\nendfunc\n\nfunc Test_len()\n  call assert_equal(1, len(0))\n  call assert_equal(2, len(12))\n\n  call assert_equal(0, len(''))\n  call assert_equal(2, len('ab'))\n\n  call assert_equal(0, len([]))\n  call assert_equal(0, len(test_null_list()))\n  call assert_equal(2, len([2, 1]))\n\n  call assert_equal(0, len({}))\n  call assert_equal(0, len(test_null_dict()))\n  call assert_equal(2, len({'a': 1, 'b': 2}))\n\n  call assert_fails('call len(v:none)', 'E701:')\n  call assert_fails('call len({-> 0})', 'E701:')\nendfunc\n\nfunc Test_max()\n  call assert_equal(0, max([]))\n  call assert_equal(2, max([2]))\n  call assert_equal(2, max([1, 2]))\n  call assert_equal(2, max([1, 2, v:null]))\n\n  call assert_equal(0, max({}))\n  call assert_equal(2, max({'a':1, 'b':2}))\n\n  call assert_fails('call max(1)', 'E712:')\n  call assert_fails('call max(v:none)', 'E712:')\n\n  \" check we only get one error\n  call assert_fails('call max([#{}, [1]])', ['E728:', 'E728:'])\n  call assert_fails('call max(#{a: {}, b: [1]})', ['E728:', 'E728:'])\nendfunc\n\nfunc Test_min()\n  call assert_equal(0, min([]))\n  call assert_equal(2, min([2]))\n  call assert_equal(1, min([1, 2]))\n  call assert_equal(0, min([1, 2, v:null]))\n\n  call assert_equal(0, min({}))\n  call assert_equal(1, min({'a':1, 'b':2}))\n\n  call assert_fails('call min(1)', 'E712:')\n  call assert_fails('call min(v:none)', 'E712:')\n  call assert_fails('call min([1, {}])', 'E728:')\n\n  \" check we only get one error\n  call assert_fails('call min([[1], #{}])', ['E745:', 'E745:'])\n  call assert_fails('call min(#{a: [1], b: #{}})', ['E745:', 'E745:'])\nendfunc\n\nfunc Test_strwidth()\n  for aw in ['single', 'double']\n    exe 'set ambiwidth=' . aw\n    call assert_equal(0, strwidth(''))\n    call assert_equal(1, strwidth(\"\\t\"))\n    call assert_equal(3, strwidth('Vim'))\n    call assert_equal(4, strwidth(1234))\n    call assert_equal(5, strwidth(-1234))\n\n    call assert_equal(2, strwidth('\ud83d\ude09'))\n    call assert_equal(17, strwidth('E\u0125o\u015dan\u011do \u0109iu\u0135a\u016dde'))\n    call assert_equal((aw == 'single') ? 6 : 7, strwidth('Stra\u00dfe'))\n\n    call assert_fails('call strwidth({->0})', 'E729:')\n    call assert_fails('call strwidth([])', 'E730:')\n    call assert_fails('call strwidth({})', 'E731:')\n  endfor\n\n  call assert_equal(3, strwidth(1.2))\n  call v9.CheckDefAndScriptFailure(['echo strwidth(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\n\n  set ambiwidth&\nendfunc\n\nfunc Test_str2nr()\n  call assert_equal(0, str2nr(''))\n  call assert_equal(1, str2nr('1'))\n  call assert_equal(1, str2nr(' 1 '))\n\n  call assert_equal(1, str2nr('+1'))\n  call assert_equal(1, str2nr('+ 1'))\n  call assert_equal(1, str2nr(' + 1 '))\n\n  call assert_equal(-1, str2nr('-1'))\n  call assert_equal(-1, str2nr('- 1'))\n  call assert_equal(-1, str2nr(' - 1 '))\n\n  call assert_equal(123456789, str2nr('123456789'))\n  call assert_equal(-123456789, str2nr('-123456789'))\n\n  call assert_equal(5, str2nr('101', 2))\n  call assert_equal(5, '0b101'->str2nr(2))\n  call assert_equal(5, str2nr('0B101', 2))\n  call assert_equal(-5, str2nr('-101', 2))\n  call assert_equal(-5, str2nr('-0b101', 2))\n  call assert_equal(-5, str2nr('-0B101', 2))\n\n  call assert_equal(65, str2nr('101', 8))\n  call assert_equal(65, str2nr('0101', 8))\n  call assert_equal(-65, str2nr('-101', 8))\n  call assert_equal(-65, str2nr('-0101', 8))\n  call assert_equal(65, str2nr('0o101', 8))\n  call assert_equal(65, str2nr('0O0101', 8))\n  call assert_equal(-65, str2nr('-0O101', 8))\n  call assert_equal(-65, str2nr('-0o0101', 8))\n\n  call assert_equal(11259375, str2nr('abcdef', 16))\n  call assert_equal(11259375, str2nr('ABCDEF', 16))\n  call assert_equal(-11259375, str2nr('-ABCDEF', 16))\n  call assert_equal(11259375, str2nr('0xabcdef', 16))\n  call assert_equal(11259375, str2nr('0Xabcdef', 16))\n  call assert_equal(11259375, str2nr('0XABCDEF', 16))\n  call assert_equal(-11259375, str2nr('-0xABCDEF', 16))\n\n  call assert_equal(1, str2nr(\"1'000'000\", 10, 0))\n  call assert_equal(256, str2nr(\"1'0000'0000\", 2, 1))\n  call assert_equal(262144, str2nr(\"1'000'000\", 8, 1))\n  call assert_equal(1000000, str2nr(\"1'000'000\", 10, 1))\n  call assert_equal(1000, str2nr(\"1'000''000\", 10, 1))\n  call assert_equal(65536, str2nr(\"1'00'00\", 16, 1))\n\n  call assert_equal(0, str2nr('0x10'))\n  call assert_equal(0, str2nr('0b10'))\n  call assert_equal(0, str2nr('0o10'))\n  call assert_equal(1, str2nr('12', 2))\n  call assert_equal(1, str2nr('18', 8))\n  call assert_equal(1, str2nr('1g', 16))\n\n  call assert_equal(0, str2nr(v:null))\n  call assert_equal(0, str2nr(v:none))\n\n  call assert_fails('call str2nr([])', 'E730:')\n  call assert_fails('call str2nr({->2})', 'E729:')\n  call assert_equal(1, str2nr(1.2))\n  call v9.CheckDefAndScriptFailure(['echo str2nr(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\n  call assert_fails('call str2nr(10, [])', 'E745:')\nendfunc\n\nfunc Test_strftime()\n  CheckFunction strftime\n\n  \" Format of strftime() depends on system. We assume\n  \" that basic formats tested here are available and\n  \" identical on all systems which support strftime().\n  \"\n  \" The 2nd parameter of strftime() is a local time, so the output day\n  \" of strftime() can be 17 or 18, depending on timezone.\n  call assert_match('^2017-01-1[78]$', strftime('%Y-%m-%d', 1484695512))\n  \"\n  call assert_match('^\\d\\d\\d\\d-\\(0\\d\\|1[012]\\)-\\([012]\\d\\|3[01]\\) \\([01]\\d\\|2[0-3]\\):[0-5]\\d:\\([0-5]\\d\\|60\\)$', '%Y-%m-%d %H:%M:%S'->strftime())\n\n  call assert_fails('call strftime([])', 'E730:')\n  call assert_fails('call strftime(\"%Y\", [])', 'E745:')\n\n  \" Check that the time changes after we change the timezone\n  \" Save previous timezone value, if any\n  if exists('$TZ')\n    let tz = $TZ\n  endif\n\n  \" Force EST and then UTC, save the current hour (24-hour clock) for each\n  let $TZ = 'EST' | let est = strftime('%H')\n  let $TZ = 'UTC' | let utc = strftime('%H')\n\n  \" Those hours should be two bytes long, and should not be the same; if they\n  \" are, a tzset(3) call may have failed somewhere\n  call assert_equal(strlen(est), 2)\n  call assert_equal(strlen(utc), 2)\n  \" TODO: this fails on MS-Windows\n  if has('unix')\n    call assert_notequal(est, utc)\n  endif\n\n  \" If we cached a timezone value, put it back, otherwise clear it\n  if exists('tz')\n    let $TZ = tz\n  else\n    unlet $TZ\n  endif\nendfunc\n\nfunc Test_strptime()\n  CheckFunction strptime\n\n  if exists('$TZ')\n    let tz = $TZ\n  endif\n  let $TZ = 'UTC'\n\n  call assert_equal(1484653763, strptime('%Y-%m-%d %T', '2017-01-17 11:49:23'))\n\n  \" Force DST and check that it's considered\n  let $TZ = 'WINTER0SUMMER,J1,J365'\n  call assert_equal(1484653763 - 3600, strptime('%Y-%m-%d %T', '2017-01-17 11:49:23'))\n\n  call assert_fails('call strptime()', 'E119:')\n  call assert_fails('call strptime(\"xxx\")', 'E119:')\n  call assert_equal(0, strptime(\"%Y\", ''))\n  call assert_equal(0, strptime(\"%Y\", \"xxx\"))\n\n  if exists('tz')\n    let $TZ = tz\n  else\n    unlet $TZ\n  endif\nendfunc\n\nfunc Test_resolve_unix()\n  CheckUnix\n\n  \" Xlink1 -> Xlink2\n  \" Xlink2 -> Xlink3\n  silent !ln -s -f Xlink2 Xlink1\n  silent !ln -s -f Xlink3 Xlink2\n  call assert_equal('Xlink3', resolve('Xlink1'))\n  call assert_equal('./Xlink3', resolve('./Xlink1'))\n  call assert_equal('Xlink3/', resolve('Xlink2/'))\n  \" FIXME: these tests result in things like \"Xlink2/\" instead of \"Xlink3/\"?!\n  \"call assert_equal('Xlink3/', resolve('Xlink1/'))\n  \"call assert_equal('./Xlink3/', resolve('./Xlink1/'))\n  \"call assert_equal(getcwd() . '/Xlink3/', resolve(getcwd() . '/Xlink1/'))\n  call assert_equal(getcwd() . '/Xlink3', resolve(getcwd() . '/Xlink1'))\n\n  \" Test resolve() with a symlink cycle.\n  \" Xlink1 -> Xlink2\n  \" Xlink2 -> Xlink3\n  \" Xlink3 -> Xlink1\n  silent !ln -s -f Xlink1 Xlink3\n  call assert_fails('call resolve(\"Xlink1\")',   'E655:')\n  call assert_fails('call resolve(\"./Xlink1\")', 'E655:')\n  call assert_fails('call resolve(\"Xlink2\")',   'E655:')\n  call assert_fails('call resolve(\"Xlink3\")',   'E655:')\n  call delete('Xlink1')\n  call delete('Xlink2')\n  call delete('Xlink3')\n\n  silent !ln -s -f Xresolvedir//Xfile Xresolvelink\n  call assert_equal('Xresolvedir/Xfile', resolve('Xresolvelink'))\n  call delete('Xresolvelink')\n\n  silent !ln -s -f Xlink2/ Xlink1\n  call assert_equal('Xlink2', 'Xlink1'->resolve())\n  call assert_equal('Xlink2/', resolve('Xlink1/'))\n  call delete('Xlink1')\n\n  silent !ln -s -f ./Xlink2 Xlink1\n  call assert_equal('Xlink2', resolve('Xlink1'))\n  call assert_equal('./Xlink2', resolve('./Xlink1'))\n  call delete('Xlink1')\n\n  call assert_equal('/', resolve('/'))\nendfunc\n\nfunc s:normalize_fname(fname)\n  let ret = substitute(a:fname, '\\', '/', 'g')\n  let ret = substitute(ret, '//', '/', 'g')\n  return ret->tolower()\nendfunc\n\nfunc Test_resolve_win32()\n  CheckMSWindows\n\n  \" test for shortcut file\n  if executable('cscript')\n    new Xresfile\n    wq\n    let lines =<< trim END\n\tSet fs = CreateObject(\"Scripting.FileSystemObject\")\n\tSet ws = WScript.CreateObject(\"WScript.Shell\")\n\tSet shortcut = ws.CreateShortcut(\"Xlink.lnk\")\n\tshortcut.TargetPath = fs.BuildPath(ws.CurrentDirectory, \"Xresfile\")\n\tshortcut.Save\n    END\n    call writefile(lines, 'link.vbs')\n    silent !cscript link.vbs\n    call delete('link.vbs')\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink.lnk')))\n    call delete('Xresfile')\n\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink.lnk')))\n    call delete('Xlink.lnk')\n  else\n    echomsg 'skipped test for shortcut file'\n  endif\n\n  \" remove files\n  call delete('Xlink')\n  call delete('Xdir', 'd')\n  call delete('Xresfile')\n\n  \" test for symbolic link to a file\n  new Xresfile\n  wq\n  call assert_equal('Xresfile', resolve('Xresfile'))\n  silent !mklink Xlink Xresfile\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for symbolic link to a file'\n  endif\n  call delete('Xresfile')\n\n  \" test for junction to a directory\n  call mkdir('Xdir')\n  silent !mklink /J Xlink Xdir\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n\n    call delete('Xdir', 'd')\n\n    \" test for junction already removed\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xlink'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for junction to a directory'\n    call delete('Xdir', 'd')\n  endif\n\n  \" test for symbolic link to a directory\n  call mkdir('Xdir')\n  silent !mklink /D Xlink Xdir\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n\n    call delete('Xdir', 'd')\n\n    \" test for symbolic link already removed\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xlink'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for symbolic link to a directory'\n    call delete('Xdir', 'd')\n  endif\n\n  \" test for buffer name\n  new Xbuffile\n  wq\n  silent !mklink Xlink Xbuffile\n  if !v:shell_error\n    edit Xlink\n    call assert_equal('Xlink', bufname('%'))\n    call delete('Xlink')\n    bw!\n  else\n    echomsg 'skipped test for buffer name'\n  endif\n  call delete('Xbuffile')\n\n  \" test for reparse point\n  call mkdir('Xdir')\n  call assert_equal('Xdir', resolve('Xdir'))\n  silent !mklink /D Xdirlink Xdir\n  if !v:shell_error\n    w Xdir/text.txt\n    call assert_equal('Xdir/text.txt', resolve('Xdir/text.txt'))\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir\\text.txt'), s:normalize_fname(resolve('Xdirlink\\text.txt')))\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve('Xdirlink')))\n    call delete('Xdirlink')\n  else\n    echomsg 'skipped test for reparse point'\n  endif\n\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_simplify()\n  call assert_equal('',            simplify(''))\n  call assert_equal('/',           simplify('/'))\n  call assert_equal('/',           simplify('/.'))\n  call assert_equal('/',           simplify('/..'))\n  call assert_equal('/...',        simplify('/...'))\n  call assert_equal('//path',      simplify('//path'))\n  if has('unix')\n    call assert_equal('/path',       simplify('///path'))\n    call assert_equal('/path',       simplify('////path'))\n  endif\n\n  call assert_equal('./dir/file',  './dir/file'->simplify())\n  call assert_equal('./dir/file',  simplify('.///dir//file'))\n  call assert_equal('./dir/file',  simplify('./dir/./file'))\n  call assert_equal('./file',      simplify('./dir/../file'))\n  call assert_equal('../dir/file', simplify('dir/../../dir/file'))\n  call assert_equal('./file',      simplify('dir/.././file'))\n  call assert_equal('../dir',      simplify('./../dir'))\n  call assert_equal('..',          simplify('../testdir/..'))\n  call mkdir('Xsimpdir')\n  call assert_equal('.',           simplify('Xsimpdir/../.'))\n  call delete('Xsimpdir', 'd')\n\n  call assert_fails('call simplify({->0})', 'E729:')\n  call assert_fails('call simplify([])', 'E730:')\n  call assert_fails('call simplify({})', 'E731:')\n  call assert_equal('1.2', simplify(1.2))\n  call v9.CheckDefAndScriptFailure(['echo simplify(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\nendfunc\n\nfunc Test_pathshorten()\n  call assert_equal('', pathshorten(''))\n  call assert_equal('foo', pathshorten('foo'))\n  call assert_equal('/foo', '/foo'->pathshorten())\n  call assert_equal('f/', pathshorten('foo/'))\n  call assert_equal('f/bar', pathshorten('foo/bar'))\n  call assert_equal('f/b/foobar', 'foo/bar/foobar'->pathshorten())\n  call assert_equal('/f/b/foobar', pathshorten('/foo/bar/foobar'))\n  call assert_equal('.f/bar', pathshorten('.foo/bar'))\n  call assert_equal('~f/bar', pathshorten('~foo/bar'))\n  call assert_equal('~.f/bar', pathshorten('~.foo/bar'))\n  call assert_equal('.~f/bar', pathshorten('.~foo/bar'))\n  call assert_equal('~/f/bar', pathshorten('~/foo/bar'))\n  call assert_fails('call pathshorten([])', 'E730:')\n\n  \" test pathshorten with optional variable to set preferred size of shortening\n  call assert_equal('', pathshorten('', 2))\n  call assert_equal('foo', pathshorten('foo', 2))\n  call assert_equal('/foo', pathshorten('/foo', 2))\n  call assert_equal('fo/', pathshorten('foo/', 2))\n  call assert_equal('fo/bar', pathshorten('foo/bar', 2))\n  call assert_equal('fo/ba/foobar', pathshorten('foo/bar/foobar', 2))\n  call assert_equal('/fo/ba/foobar', pathshorten('/foo/bar/foobar', 2))\n  call assert_equal('.fo/bar', pathshorten('.foo/bar', 2))\n  call assert_equal('~fo/bar', pathshorten('~foo/bar', 2))\n  call assert_equal('~.fo/bar', pathshorten('~.foo/bar', 2))\n  call assert_equal('.~fo/bar', pathshorten('.~foo/bar', 2))\n  call assert_equal('~/fo/bar', pathshorten('~/foo/bar', 2))\n  call assert_fails('call pathshorten([],2)', 'E730:')\n  call assert_notequal('~/fo/bar', pathshorten('~/foo/bar', 3))\n  call assert_equal('~/foo/bar', pathshorten('~/foo/bar', 3))\n  call assert_equal('~/f/bar', pathshorten('~/foo/bar', 0))\nendfunc\n\nfunc Test_strpart()\n  call assert_equal('de', strpart('abcdefg', 3, 2))\n  call assert_equal('ab', strpart('abcdefg', -2, 4))\n  call assert_equal('abcdefg', 'abcdefg'->strpart(-2))\n  call assert_equal('fg', strpart('abcdefg', 5, 4))\n  call assert_equal('defg', strpart('abcdefg', 3))\n  call assert_equal('', strpart('abcdefg', 10))\n  call assert_fails(\"let s=strpart('abcdef', [])\", 'E745:')\n\n  call assert_equal('l\u00e9p', strpart('\u00e9l\u00e9phant', 2, 4))\n  call assert_equal('l\u00e9phant', strpart('\u00e9l\u00e9phant', 2))\n\n  call assert_equal('\u00e9', strpart('\u00e9l\u00e9phant', 0, 1, 1))\n  call assert_equal('\u00e9p', strpart('\u00e9l\u00e9phant', 3, 2, v:true))\n  call assert_equal('o\u0301', strpart('co\u0301mposed', 1, 1, 1))\nendfunc\n\nfunc Test_tolower()\n  call assert_equal(\"\", tolower(\"\"))\n\n  \" Test with all printable ASCII characters.\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',\n          \\ tolower(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))\n\n  \" Test with a few uppercase diacritics.\n  call assert_equal(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\", tolower(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\"))\n  call assert_equal(\"b\u1e03\u1e07\", tolower(\"B\u1e02\u1e06\"))\n  call assert_equal(\"c\u00e7\u0107\u0109\u010b\u010d\", tolower(\"C\u00c7\u0106\u0108\u010a\u010c\"))\n  call assert_equal(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\", tolower(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\"))\n  call assert_equal(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\", tolower(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\"))\n  call assert_equal(\"f\u1e1f \", tolower(\"F\u1e1e \"))\n  call assert_equal(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\", tolower(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\"))\n  call assert_equal(\"h\u0125\u0127\u1e23\u1e27\u1e29\", tolower(\"H\u0124\u0126\u1e22\u1e26\u1e28\"))\n  call assert_equal(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012fi\u01d0\u1ec9\", tolower(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\"))\n  call assert_equal(\"j\u0135\", tolower(\"J\u0134\"))\n  call assert_equal(\"k\u0137\u01e9\u1e31\u1e35\", tolower(\"K\u0136\u01e8\u1e30\u1e34\"))\n  call assert_equal(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\", tolower(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\"))\n  call assert_equal(\"m\u1e3f\u1e41\", tolower(\"M\u1e3e\u1e40\"))\n  call assert_equal(\"n\u00f1\u0144\u0146\u0148\u1e45\u1e49\", tolower(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\"))\n  call assert_equal(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\", tolower(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\"))\n  call assert_equal(\"p\u1e55\u1e57\", tolower(\"P\u1e54\u1e56\"))\n  call assert_equal(\"q\", tolower(\"Q\"))\n  call assert_equal(\"r\u0155\u0157\u0159\u1e59\u1e5f\", tolower(\"R\u0154\u0156\u0158\u1e58\u1e5e\"))\n  call assert_equal(\"s\u015b\u015d\u015f\u0161\u1e61\", tolower(\"S\u015a\u015c\u015e\u0160\u1e60\"))\n  call assert_equal(\"t\u0163\u0165\u0167\u1e6b\u1e6f\", tolower(\"T\u0162\u0164\u0166\u1e6a\u1e6e\"))\n  call assert_equal(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\", tolower(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\"))\n  call assert_equal(\"v\u1e7d\", tolower(\"V\u1e7c\"))\n  call assert_equal(\"w\u0175\u1e81\u1e83\u1e85\u1e87\", tolower(\"W\u0174\u1e80\u1e82\u1e84\u1e86\"))\n  call assert_equal(\"x\u1e8b\u1e8d\", tolower(\"X\u1e8a\u1e8c\"))\n  call assert_equal(\"y\u00fd\u0177\u00ff\u1e8f\u1ef3\u1ef7\u1ef9\", tolower(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\"))\n  call assert_equal(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\", tolower(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\"))\n\n  \" Test with a few lowercase diacritics, which should remain unchanged.\n  call assert_equal(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\", tolower(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\"))\n  call assert_equal(\"b\u1e03\u1e07\", tolower(\"b\u1e03\u1e07\"))\n  call assert_equal(\"c\u00e7\u0107\u0109\u010b\u010d\", tolower(\"c\u00e7\u0107\u0109\u010b\u010d\"))\n  call assert_equal(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\", tolower(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\"))\n  call assert_equal(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\", tolower(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\"))\n  call assert_equal(\"f\u1e1f\", tolower(\"f\u1e1f\"))\n  call assert_equal(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\", tolower(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\"))\n  call assert_equal(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\", tolower(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\"))\n  call assert_equal(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\", tolower(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\"))\n  call assert_equal(\"j\u0135\u01f0\", tolower(\"j\u0135\u01f0\"))\n  call assert_equal(\"k\u0137\u01e9\u1e31\u1e35\", tolower(\"k\u0137\u01e9\u1e31\u1e35\"))\n  call assert_equal(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\", tolower(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\"))\n  call assert_equal(\"m\u1e3f\u1e41 \", tolower(\"m\u1e3f\u1e41 \"))\n  call assert_equal(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\", tolower(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\"))\n  call assert_equal(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\", tolower(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\"))\n  call assert_equal(\"p\u1e55\u1e57\", tolower(\"p\u1e55\u1e57\"))\n  call assert_equal(\"q\", tolower(\"q\"))\n  call assert_equal(\"r\u0155\u0157\u0159\u1e59\u1e5f\", tolower(\"r\u0155\u0157\u0159\u1e59\u1e5f\"))\n  call assert_equal(\"s\u015b\u015d\u015f\u0161\u1e61\", tolower(\"s\u015b\u015d\u015f\u0161\u1e61\"))\n  call assert_equal(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\", tolower(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\"))\n  call assert_equal(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\", tolower(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\"))\n  call assert_equal(\"v\u1e7d\", tolower(\"v\u1e7d\"))\n  call assert_equal(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\", tolower(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\"))\n  call assert_equal(\"\u1e8b\u1e8d\", tolower(\"\u1e8b\u1e8d\"))\n  call assert_equal(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\", tolower(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\"))\n  call assert_equal(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\", tolower(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\"))\n\n  \" According to https://twitter.com/jifa/status/625776454479970304\n  \" \u023a (U+023A) and \u023e (U+023E) are the *only* code points to increase\n  \" in length (2 to 3 bytes) when lowercased. So let's test them.\n  call assert_equal(\"\u2c65 \u2c66\", tolower(\"\u023a \u023e\"))\n\n  \" This call to tolower with invalid utf8 sequence used to cause access to\n  \" invalid memory.\n  call tolower(\"\\xC0\\x80\\xC0\")\n  call tolower(\"123\\xC0\\x80\\xC0\")\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(\"abc\", tolower(\"ABC\"))\n  let &encoding = save_enc\nendfunc\n\nfunc Test_toupper()\n  call assert_equal(\"\", toupper(\"\"))\n\n  \" Test with all printable ASCII characters.\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~',\n          \\ toupper(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))\n\n  \" Test with a few lowercase diacritics.\n  call assert_equal(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\", \"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\"->toupper())\n  call assert_equal(\"B\u1e02\u1e06\", toupper(\"b\u1e03\u1e07\"))\n  call assert_equal(\"C\u00c7\u0106\u0108\u010a\u010c\", toupper(\"c\u00e7\u0107\u0109\u010b\u010d\"))\n  call assert_equal(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\", toupper(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\"))\n  call assert_equal(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\", toupper(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\"))\n  call assert_equal(\"F\u1e1e\", toupper(\"f\u1e1f\"))\n  call assert_equal(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\", toupper(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\"))\n  call assert_equal(\"H\u0124\u0126\u1e22\u1e26\u1e28\u1e96\", toupper(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\"))\n  call assert_equal(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u01cf\u1ec8\", toupper(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\"))\n  call assert_equal(\"J\u0134\u01f0\", toupper(\"j\u0135\u01f0\"))\n  call assert_equal(\"K\u0136\u01e8\u1e30\u1e34\", toupper(\"k\u0137\u01e9\u1e31\u1e35\"))\n  call assert_equal(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\", toupper(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\"))\n  call assert_equal(\"M\u1e3e\u1e40 \", toupper(\"m\u1e3f\u1e41 \"))\n  call assert_equal(\"N\u00d1\u0143\u0145\u0147\u0149\u1e44\u1e48\", toupper(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\"))\n  call assert_equal(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\", toupper(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\"))\n  call assert_equal(\"P\u1e54\u1e56\", toupper(\"p\u1e55\u1e57\"))\n  call assert_equal(\"Q\", toupper(\"q\"))\n  call assert_equal(\"R\u0154\u0156\u0158\u1e58\u1e5e\", toupper(\"r\u0155\u0157\u0159\u1e59\u1e5f\"))\n  call assert_equal(\"S\u015a\u015c\u015e\u0160\u1e60\", toupper(\"s\u015b\u015d\u015f\u0161\u1e61\"))\n  call assert_equal(\"T\u0162\u0164\u0166\u1e6a\u1e6e\u1e97\", toupper(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\"))\n  call assert_equal(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\", toupper(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\"))\n  call assert_equal(\"V\u1e7c\", toupper(\"v\u1e7d\"))\n  call assert_equal(\"W\u0174\u1e80\u1e82\u1e84\u1e86\u1e98\", toupper(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\"))\n  call assert_equal(\"\u1e8a\u1e8c\", toupper(\"\u1e8b\u1e8d\"))\n  call assert_equal(\"Y\u00dd\u0178\u0176\u1e8e\u1e99\u1ef2\u1ef6\u1ef8\", toupper(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\"))\n  call assert_equal(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\", toupper(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\"))\n\n  \" Test that uppercase diacritics, which should remain unchanged.\n  call assert_equal(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\", toupper(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\"))\n  call assert_equal(\"B\u1e02\u1e06\", toupper(\"B\u1e02\u1e06\"))\n  call assert_equal(\"C\u00c7\u0106\u0108\u010a\u010c\", toupper(\"C\u00c7\u0106\u0108\u010a\u010c\"))\n  call assert_equal(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\", toupper(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\"))\n  call assert_equal(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\", toupper(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\"))\n  call assert_equal(\"F\u1e1e \", toupper(\"F\u1e1e \"))\n  call assert_equal(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\", toupper(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\"))\n  call assert_equal(\"H\u0124\u0126\u1e22\u1e26\u1e28\", toupper(\"H\u0124\u0126\u1e22\u1e26\u1e28\"))\n  call assert_equal(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\", toupper(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\"))\n  call assert_equal(\"J\u0134\", toupper(\"J\u0134\"))\n  call assert_equal(\"K\u0136\u01e8\u1e30\u1e34\", toupper(\"K\u0136\u01e8\u1e30\u1e34\"))\n  call assert_equal(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\", toupper(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\"))\n  call assert_equal(\"M\u1e3e\u1e40\", toupper(\"M\u1e3e\u1e40\"))\n  call assert_equal(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\", toupper(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\"))\n  call assert_equal(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\", toupper(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\"))\n  call assert_equal(\"P\u1e54\u1e56\", toupper(\"P\u1e54\u1e56\"))\n  call assert_equal(\"Q\", toupper(\"Q\"))\n  call assert_equal(\"R\u0154\u0156\u0158\u1e58\u1e5e\", toupper(\"R\u0154\u0156\u0158\u1e58\u1e5e\"))\n  call assert_equal(\"S\u015a\u015c\u015e\u0160\u1e60\", toupper(\"S\u015a\u015c\u015e\u0160\u1e60\"))\n  call assert_equal(\"T\u0162\u0164\u0166\u1e6a\u1e6e\", toupper(\"T\u0162\u0164\u0166\u1e6a\u1e6e\"))\n  call assert_equal(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\", toupper(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\"))\n  call assert_equal(\"V\u1e7c\", toupper(\"V\u1e7c\"))\n  call assert_equal(\"W\u0174\u1e80\u1e82\u1e84\u1e86\", toupper(\"W\u0174\u1e80\u1e82\u1e84\u1e86\"))\n  call assert_equal(\"X\u1e8a\u1e8c\", toupper(\"X\u1e8a\u1e8c\"))\n  call assert_equal(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\", toupper(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\"))\n  call assert_equal(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\", toupper(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\"))\n\n  call assert_equal(\"\u023a \u023e\", toupper(\"\u2c65 \u2c66\"))\n\n  \" This call to toupper with invalid utf8 sequence used to cause access to\n  \" invalid memory.\n  call toupper(\"\\xC0\\x80\\xC0\")\n  call toupper(\"123\\xC0\\x80\\xC0\")\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(\"ABC\", toupper(\"abc\"))\n  let &encoding = save_enc\nendfunc\n\nfunc Test_tr()\n  call assert_equal('foo', tr('bar', 'bar', 'foo'))\n  call assert_equal('zxy', 'cab'->tr('abc', 'xyz'))\n  call assert_fails(\"let s=tr([], 'abc', 'def')\", 'E730:')\n  call assert_fails(\"let s=tr('abc', [], 'def')\", 'E730:')\n  call assert_fails(\"let s=tr('abc', 'abc', [])\", 'E730:')\n  call assert_fails(\"let s=tr('abcd', 'abcd', 'def')\", 'E475:')\n  set encoding=latin1\n  call assert_fails(\"let s=tr('abcd', 'abcd', 'def')\", 'E475:')\n  call assert_equal('hEllO', tr('hello', 'eo', 'EO'))\n  call assert_equal('hello', tr('hello', 'xy', 'ab'))\n  call assert_fails('call tr(\"abc\", \"123\", \"\u2081\u2082\")', 'E475:')\n  set encoding=utf8\nendfunc\n\n\" Tests for the mode() function\nlet current_modes = ''\nfunc Save_mode()\n  let g:current_modes = mode(0) . '-' . mode(1)\n  return ''\nendfunc\n\n\" Test for the mode() function\nfunc Test_mode()\n  new\n  call append(0, [\"Blue Ball Black\", \"Brown Band Bowl\", \"\"])\n\n  \" Only complete from the current buffer.\n  set complete=.\n\n  inoremap <F2> <C-R>=Save_mode()<CR>\n  xnoremap <F2> <Cmd>call Save_mode()<CR>\n\n  normal! 3G\n  exe \"normal i\\<F2>\\<Esc>\"\n  call assert_equal('i-i', g:current_modes)\n  \" i_CTRL-P: Multiple matches\n  exe \"normal i\\<C-G>uBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-P: Single match\n  exe \"normal iBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X\n  exe \"normal iBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ix', g:current_modes)\n  \" i_CTRL-X CTRL-P: Multiple matches\n  exe \"normal iBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P: Single match\n  exe \"normal iBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal iBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: Multiple matches\n  exe \"normal i\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: Single match\n  exe \"normal iBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-P: No match\n  exe \"normal iCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P: No match\n  exe \"normal iCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: No match\n  exe \"normal iabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n\n  exe \"normal R\\<F2>\\<Esc>\"\n  call assert_equal('R-R', g:current_modes)\n  \" R_CTRL-P: Multiple matches\n  exe \"normal RBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-P: Single match\n  exe \"normal RBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X\n  exe \"normal RBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rx', g:current_modes)\n  \" R_CTRL-X CTRL-P: Multiple matches\n  exe \"normal RBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P: Single match\n  exe \"normal RBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal RBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: Multiple matches\n  exe \"normal R\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: Single match\n  exe \"normal RBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-P: No match\n  exe \"normal RCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P: No match\n  exe \"normal RCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: No match\n  exe \"normal Rabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n\n  exe \"normal gR\\<F2>\\<Esc>\"\n  call assert_equal('R-Rv', g:current_modes)\n  \" gR_CTRL-P: Multiple matches\n  exe \"normal gRBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-P: Single match\n  exe \"normal gRBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X\n  exe \"normal gRBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvx', g:current_modes)\n  \" gR_CTRL-X CTRL-P: Multiple matches\n  exe \"normal gRBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P: Single match\n  exe \"normal gRBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal gRBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: Multiple matches\n  exe \"normal gR\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: Single match\n  exe \"normal gRBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-P: No match\n  exe \"normal gRCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P: No match\n  exe \"normal gRCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: No match\n  exe \"normal gRabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n\n  call assert_equal('n', 0->mode())\n  call assert_equal('n', 1->mode())\n\n  \" i_CTRL-O\n  exe \"normal i\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niI\", g:current_modes)\n\n  \" R_CTRL-O\n  exe \"normal R\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niR\", g:current_modes)\n\n  \" gR_CTRL-O\n  exe \"normal gR\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niV\", g:current_modes)\n\n  \" How to test operator-pending mode?\n\n  call feedkeys(\"v\", 'xt')\n  call assert_equal('v', mode())\n  call assert_equal('v', mode(1))\n  call feedkeys(\"\\<Esc>V\", 'xt')\n  call assert_equal('V', mode())\n  call assert_equal('V', mode(1))\n  call feedkeys(\"\\<Esc>\\<C-V>\", 'xt')\n  call assert_equal(\"\\<C-V>\", mode())\n  call assert_equal(\"\\<C-V>\", mode(1))\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  call feedkeys(\"gh\", 'xt')\n  call assert_equal('s', mode())\n  call assert_equal('s', mode(1))\n  call feedkeys(\"\\<Esc>gH\", 'xt')\n  call assert_equal('S', mode())\n  call assert_equal('S', mode(1))\n  call feedkeys(\"\\<Esc>g\\<C-H>\", 'xt')\n  call assert_equal(\"\\<C-S>\", mode())\n  call assert_equal(\"\\<C-S>\", mode(1))\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  \" v_CTRL-O\n  exe \"normal gh\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"v-vs\", g:current_modes)\n  exe \"normal gH\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"V-Vs\", g:current_modes)\n  exe \"normal g\\<C-H>\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"\\<C-V>-\\<C-V>s\", g:current_modes)\n\n  call feedkeys(\":echo \\<C-R>=Save_mode()\\<C-U>\\<CR>\", 'xt')\n  call assert_equal('c-c', g:current_modes)\n  call feedkeys(\"gQecho \\<C-R>=Save_mode()\\<CR>\\<CR>vi\\<CR>\", 'xt')\n  call assert_equal('c-cv', g:current_modes)\n  call feedkeys(\"Qcall Save_mode()\\<CR>vi\\<CR>\", 'xt')\n  call assert_equal('c-ce', g:current_modes)\n  \" How to test Ex mode?\n\n  \" Test mode in operatorfunc (it used to be Operator-pending).\n  set operatorfunc=OperatorFunc\n  function OperatorFunc(_)\n    call Save_mode()\n  endfunction\n  execute \"normal! g@l\\<Esc>\"\n  call assert_equal('n-n', g:current_modes)\n  execute \"normal! i\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niI', g:current_modes)\n  execute \"normal! R\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niR', g:current_modes)\n  execute \"normal! gR\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niV', g:current_modes)\n\n  if has('terminal')\n    term\n    call feedkeys(\"\\<C-W>N\", 'xt')\n    call assert_equal('n', mode())\n    call assert_equal('nt', mode(1))\n    call feedkeys(\"aexit\\<CR>\", 'xt')\n  endif\n\n  bwipe!\n  iunmap <F2>\n  xunmap <F2>\n  set complete&\n  set operatorfunc&\n  delfunction OperatorFunc\nendfunc\n\n\" Test for append()\nfunc Test_append()\n  enew!\n  split\n  call assert_equal(0, append(1, []))\n  call assert_equal(0, append(1, test_null_list()))\n  call assert_equal(0, append(0, [\"foo\"]))\n  call assert_equal(0, append(1, []))\n  call assert_equal(0, append(1, test_null_list()))\n  call assert_equal(0, append(8, []))\n  call assert_equal(0, append(9, test_null_list()))\n  call assert_equal(['foo', ''], getline(1, '$'))\n  split\n  only\n  undo\n  undo\n\n  \" Using $ instead of '$' must give an error\n  call assert_fails(\"call append($, 'foobar')\", 'E116:')\n\n  call assert_fails(\"call append({}, '')\", ['E728:', 'E728:'])\nendfunc\n\n\" Test for setline()\nfunc Test_setline()\n  new\n  call setline(0, [\"foo\"])\n  call setline(0, [])\n  call setline(0, test_null_list())\n  call setline(1, [\"bar\"])\n  call setline(1, [])\n  call setline(1, test_null_list())\n  call setline(2, [])\n  call setline(2, test_null_list())\n  call setline(3, [])\n  call setline(3, test_null_list())\n  call setline(2, [\"baz\"])\n  call assert_equal(['bar', 'baz'], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_getbufvar()\n  let bnr = bufnr('%')\n  let b:var_num = '1234'\n  let def_num = '5678'\n  call assert_equal('1234', getbufvar(bnr, 'var_num'))\n  call assert_equal('1234', getbufvar(bnr, 'var_num', def_num))\n\n  let bd = getbufvar(bnr, '')\n  call assert_equal('1234', bd['var_num'])\n  call assert_true(exists(\"bd['changedtick']\"))\n  call assert_equal(2, len(bd))\n\n  let bd2 = getbufvar(bnr, '', def_num)\n  call assert_equal(bd, bd2)\n\n  unlet b:var_num\n  call assert_equal(def_num, getbufvar(bnr, 'var_num', def_num))\n  call assert_equal('', getbufvar(bnr, 'var_num'))\n\n  let bd = getbufvar(bnr, '')\n  call assert_equal(1, len(bd))\n  let bd = getbufvar(bnr, '',def_num)\n  call assert_equal(1, len(bd))\n\n  call assert_equal('', getbufvar(9999, ''))\n  call assert_equal(def_num, getbufvar(9999, '', def_num))\n  unlet def_num\n\n  call assert_equal(0, getbufvar(bnr, '&autoindent'))\n  call assert_equal(0, getbufvar(bnr, '&autoindent', 1))\n\n  \" Set and get a buffer-local variable\n  call setbufvar(bnr, 'bufvar_test', ['one', 'two'])\n  call assert_equal(['one', 'two'], getbufvar(bnr, 'bufvar_test'))\n\n  \" Open new window with forced option values\n  set fileformats=unix,dos\n  new ++ff=dos ++bin ++enc=iso-8859-2\n  call assert_equal('dos', getbufvar(bufnr('%'), '&fileformat'))\n  call assert_equal(1, getbufvar(bufnr('%'), '&bin'))\n  call assert_equal('iso-8859-2', getbufvar(bufnr('%'), '&fenc'))\n  close\n\n  \" Get the b: dict.\n  let b:testvar = 'one'\n  new\n  let b:testvar = 'two'\n  let thebuf = bufnr()\n  wincmd w\n  call assert_equal('two', getbufvar(thebuf, 'testvar'))\n  call assert_equal('two', getbufvar(thebuf, '').testvar)\n  bwipe!\n\n  set fileformats&\nendfunc\n\nfunc Test_last_buffer_nr()\n  call assert_equal(bufnr('$'), last_buffer_nr())\nendfunc\n\nfunc Test_stridx()\n  call assert_equal(-1, stridx('', 'l'))\n  call assert_equal(0,  stridx('', ''))\n  call assert_equal(0,  'hello'->stridx(''))\n  call assert_equal(-1, stridx('hello', 'L'))\n  call assert_equal(2,  stridx('hello', 'l', -1))\n  call assert_equal(2,  stridx('hello', 'l', 0))\n  call assert_equal(2,  'hello'->stridx('l', 1))\n  call assert_equal(3,  stridx('hello', 'l', 3))\n  call assert_equal(-1, stridx('hello', 'l', 4))\n  call assert_equal(-1, stridx('hello', 'l', 10))\n  call assert_equal(2,  stridx('hello', 'll'))\n  call assert_equal(-1, stridx('hello', 'hello world'))\n  call assert_fails(\"let n=stridx('hello', [])\", 'E730:')\n  call assert_fails(\"let n=stridx([], 'l')\", 'E730:')\nendfunc\n\nfunc Test_strridx()\n  call assert_equal(-1, strridx('', 'l'))\n  call assert_equal(0,  strridx('', ''))\n  call assert_equal(5,  strridx('hello', ''))\n  call assert_equal(-1, strridx('hello', 'L'))\n  call assert_equal(3,  'hello'->strridx('l'))\n  call assert_equal(3,  strridx('hello', 'l', 10))\n  call assert_equal(3,  strridx('hello', 'l', 3))\n  call assert_equal(2,  strridx('hello', 'l', 2))\n  call assert_equal(-1, strridx('hello', 'l', 1))\n  call assert_equal(-1, strridx('hello', 'l', 0))\n  call assert_equal(-1, strridx('hello', 'l', -1))\n  call assert_equal(2,  strridx('hello', 'll'))\n  call assert_equal(-1, strridx('hello', 'hello world'))\n  call assert_fails(\"let n=strridx('hello', [])\", 'E730:')\n  call assert_fails(\"let n=strridx([], 'l')\", 'E730:')\nendfunc\n\nfunc Test_match_func()\n  call assert_equal(4,  match('testing', 'ing'))\n  call assert_equal(4,  'testing'->match('ing', 2))\n  call assert_equal(-1, match('testing', 'ing', 5))\n  call assert_equal(-1, match('testing', 'ing', 8))\n  call assert_equal(1, match(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(-1, match(['vim', 'testing', 'execute'], 'img'))\n  call assert_fails(\"let x=match('vim', [])\", 'E730:')\n  call assert_equal(3, match(['a', 'b', 'c', 'a'], 'a', 1))\n  call assert_equal(-1, match(['a', 'b', 'c', 'a'], 'a', 5))\n  call assert_equal(4,  match('testing', 'ing', -1))\n  call assert_fails(\"let x=match('testing', 'ing', 0, [])\", 'E745:')\n  call assert_equal(-1, match(test_null_list(), 2))\n  call assert_equal(-1, match('abc', '\\\\%('))\nendfunc\n\nfunc Test_matchend()\n  call assert_equal(7,  matchend('testing', 'ing'))\n  call assert_equal(7,  'testing'->matchend('ing', 2))\n  call assert_equal(-1, matchend('testing', 'ing', 5))\n  call assert_equal(-1, matchend('testing', 'ing', 8))\n  call assert_equal(match(['vim', 'testing', 'execute'], 'ing'), matchend(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(match(['vim', 'testing', 'execute'], 'img'), matchend(['vim', 'testing', 'execute'], 'img'))\nendfunc\n\nfunc Test_matchlist()\n  call assert_equal(['acd', 'a', '', 'c', 'd', '', '', '', '', ''],  matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)'))\n  call assert_equal(['d', '', '', '', 'd', '', '', '', '', ''],  'acd'->matchlist('\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)', 2))\n  call assert_equal([],  matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)', 4))\nendfunc\n\nfunc Test_matchstr()\n  call assert_equal('ing',  matchstr('testing', 'ing'))\n  call assert_equal('ing',  'testing'->matchstr('ing', 2))\n  call assert_equal('', matchstr('testing', 'ing', 5))\n  call assert_equal('', matchstr('testing', 'ing', 8))\n  call assert_equal('testing', matchstr(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal('', matchstr(['vim', 'testing', 'execute'], 'img'))\nendfunc\n\nfunc Test_matchstrpos()\n  call assert_equal(['ing', 4, 7], matchstrpos('testing', 'ing'))\n  call assert_equal(['ing', 4, 7], 'testing'->matchstrpos('ing', 2))\n  call assert_equal(['', -1, -1], matchstrpos('testing', 'ing', 5))\n  call assert_equal(['', -1, -1], matchstrpos('testing', 'ing', 8))\n  call assert_equal(['ing', 1, 4, 7], matchstrpos(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(['', -1, -1, -1], matchstrpos(['vim', 'testing', 'execute'], 'img'))\n  call assert_equal(['', -1, -1], matchstrpos(test_null_list(), '\\a'))\nendfunc\n\nfunc Test_nextnonblank_prevnonblank()\n  new\ninsert\nThis\n\n\nis\n\na\nTest\n.\n  call assert_equal(0, nextnonblank(-1))\n  call assert_equal(0, nextnonblank(0))\n  call assert_equal(1, nextnonblank(1))\n  call assert_equal(4, 2->nextnonblank())\n  call assert_equal(4, nextnonblank(3))\n  call assert_equal(4, nextnonblank(4))\n  call assert_equal(6, nextnonblank(5))\n  call assert_equal(6, nextnonblank(6))\n  call assert_equal(7, nextnonblank(7))\n  call assert_equal(0, 8->nextnonblank())\n\n  call assert_equal(0, prevnonblank(-1))\n  call assert_equal(0, prevnonblank(0))\n  call assert_equal(1, 1->prevnonblank())\n  call assert_equal(1, prevnonblank(2))\n  call assert_equal(1, prevnonblank(3))\n  call assert_equal(4, prevnonblank(4))\n  call assert_equal(4, 5->prevnonblank())\n  call assert_equal(6, prevnonblank(6))\n  call assert_equal(7, prevnonblank(7))\n  call assert_equal(0, prevnonblank(8))\n  bw!\nendfunc\n\nfunc Test_byte2line_line2byte()\n  new\n  set endofline\n  call setline(1, ['a', 'bc', 'd'])\n\n  set fileformat=unix\n  call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],\n  \\                 map(range(-1, 8), 'byte2line(v:val)'))\n  call assert_equal([-1, -1, 1, 3, 6, 8, -1],\n  \\                 map(range(-1, 5), 'line2byte(v:val)'))\n\n  set fileformat=mac\n  call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],\n  \\                 map(range(-1, 8), 'v:val->byte2line()'))\n  call assert_equal([-1, -1, 1, 3, 6, 8, -1],\n  \\                 map(range(-1, 5), 'v:val->line2byte()'))\n\n  set fileformat=dos\n  call assert_equal([-1, -1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, -1],\n  \\                 map(range(-1, 11), 'byte2line(v:val)'))\n  call assert_equal([-1, -1, 1, 4, 8, 11, -1],\n  \\                 map(range(-1, 5), 'line2byte(v:val)'))\n\n  bw!\n  set noendofline nofixendofline\n  normal a-\n  for ff in [\"unix\", \"mac\", \"dos\"]\n    let &fileformat = ff\n    call assert_equal(1, line2byte(1))\n    call assert_equal(2, line2byte(2))  \" line2byte(line(\"$\") + 1) is the buffer size plus one (as per :help line2byte).\n  endfor\n\n  set endofline& fixendofline& fileformat&\n  bw!\nendfunc\n\n\" Test for byteidx() using a character index\nfunc Test_byteidx()\n  let a = '.\u00e9.' \" one char of two bytes\n  call assert_equal(0, byteidx(a, 0))\n  call assert_equal(1, byteidx(a, 1))\n  call assert_equal(3, byteidx(a, 2))\n  call assert_equal(4, byteidx(a, 3))\n  call assert_equal(-1, byteidx(a, 4))\n\n  let b = '.e\u0301.' \" normal e with composing char\n  call assert_equal(0, b->byteidx(0))\n  call assert_equal(1, b->byteidx(1))\n  call assert_equal(4, b->byteidx(2))\n  call assert_equal(5, b->byteidx(3))\n  call assert_equal(-1, b->byteidx(4))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidx(str, 0))\n  call assert_equal(1, byteidx(str, 1))\n  call assert_equal(6, byteidx(str, 2))\n  call assert_equal(7, byteidx(str, 3))\n  call assert_equal(12, byteidx(str, 4))\n  call assert_equal(-1, byteidx(str, 5))\n\n  \" empty string\n  call assert_equal(0, byteidx('', 0))\n  call assert_equal(-1, byteidx('', 1))\n\n  \" error cases\n  call assert_fails(\"call byteidx([], 0)\", 'E730:')\n  call assert_fails(\"call byteidx('abc', [])\", 'E745:')\n  call assert_fails(\"call byteidx('abc', 0, {})\", ['E728:', 'E728:'])\n  call assert_fails(\"call byteidx('abc', 0, -1)\", ['E1023:', 'E1023:'])\nendfunc\n\n\" Test for byteidxcomp() using a character index\nfunc Test_byteidxcomp()\n  let a = '.\u00e9.' \" one char of two bytes\n  call assert_equal(0, byteidxcomp(a, 0))\n  call assert_equal(1, byteidxcomp(a, 1))\n  call assert_equal(3, byteidxcomp(a, 2))\n  call assert_equal(4, byteidxcomp(a, 3))\n  call assert_equal(-1, byteidxcomp(a, 4))\n\n  let b = '.e\u0301.' \" normal e with composing char\n  call assert_equal(0, b->byteidxcomp(0))\n  call assert_equal(1, b->byteidxcomp(1))\n  call assert_equal(2, b->byteidxcomp(2))\n  call assert_equal(4, b->byteidxcomp(3))\n  call assert_equal(5, b->byteidxcomp(4))\n  call assert_equal(-1, b->byteidxcomp(5))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidxcomp(str, 0))\n  call assert_equal(1, byteidxcomp(str, 1))\n  call assert_equal(2, byteidxcomp(str, 2))\n  call assert_equal(4, byteidxcomp(str, 3))\n  call assert_equal(6, byteidxcomp(str, 4))\n  call assert_equal(7, byteidxcomp(str, 5))\n  call assert_equal(8, byteidxcomp(str, 6))\n  call assert_equal(10, byteidxcomp(str, 7))\n  call assert_equal(12, byteidxcomp(str, 8))\n  call assert_equal(-1, byteidxcomp(str, 9))\n\n  \" empty string\n  call assert_equal(0, byteidxcomp('', 0))\n  call assert_equal(-1, byteidxcomp('', 1))\n\n  \" error cases\n  call assert_fails(\"call byteidxcomp([], 0)\", 'E730:')\n  call assert_fails(\"call byteidxcomp('abc', [])\", 'E745:')\n  call assert_fails(\"call byteidxcomp('abc', 0, {})\", ['E728:', 'E728:'])\n  call assert_fails(\"call byteidxcomp('abc', 0, -1)\", ['E1023:', 'E1023:'])\nendfunc\n\n\" Test for byteidx() using a UTF-16 index\nfunc Test_byteidx_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(3)\n    call assert_equal(i, byteidx(str, i, v:true))\n  endfor\n  call assert_equal(3, byteidx(str, 3, v:true))\n  call assert_equal(-1, byteidx(str, 4, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(3, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(6, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" string with two byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(1, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(5, byteidx(str, 4, v:true))\n  call assert_equal(9, byteidx(str, 5, v:true))\n  call assert_equal(10, byteidx(str, 6, v:true))\n  call assert_equal(-1, byteidx(str, 7, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(4, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(8, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(6, byteidx(str, 2, v:true))\n  call assert_equal(7, byteidx(str, 3, v:true))\n  call assert_equal(12, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" empty string\n  call assert_equal(0, byteidx('', 0, v:true))\n  call assert_equal(-1, byteidx('', 1, v:true))\n\n  \" error cases\n  call assert_fails('call byteidx(str, 0, [])', 'E745:')\nendfunc\n\n\" Test for byteidxcomp() using a UTF-16 index\nfunc Test_byteidxcomp_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(3)\n    call assert_equal(i, byteidxcomp(str, i, v:true))\n  endfor\n  call assert_equal(3, byteidxcomp(str, 3, v:true))\n  call assert_equal(-1, byteidxcomp(str, 4, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(3, byteidxcomp(str, 2, v:true))\n  call assert_equal(5, byteidxcomp(str, 3, v:true))\n  call assert_equal(6, byteidxcomp(str, 4, v:true))\n  call assert_equal(-1, byteidxcomp(str, 5, v:true))\n\n  \" string with two byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(1, byteidxcomp(str, 2, v:true))\n  call assert_equal(5, byteidxcomp(str, 3, v:true))\n  call assert_equal(5, byteidxcomp(str, 4, v:true))\n  call assert_equal(9, byteidxcomp(str, 5, v:true))\n  call assert_equal(10, byteidxcomp(str, 6, v:true))\n  call assert_equal(-1, byteidxcomp(str, 7, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(2, byteidxcomp(str, 2, v:true))\n  call assert_equal(4, byteidxcomp(str, 3, v:true))\n  call assert_equal(5, byteidxcomp(str, 4, v:true))\n  call assert_equal(6, byteidxcomp(str, 5, v:true))\n  call assert_equal(8, byteidxcomp(str, 6, v:true))\n  call assert_equal(-1, byteidxcomp(str, 7, v:true))\n  call assert_fails('call byteidxcomp(str, 0, [])', 'E745:')\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(2, byteidxcomp(str, 2, v:true))\n  call assert_equal(4, byteidxcomp(str, 3, v:true))\n  call assert_equal(6, byteidxcomp(str, 4, v:true))\n  call assert_equal(7, byteidxcomp(str, 5, v:true))\n  call assert_equal(8, byteidxcomp(str, 6, v:true))\n  call assert_equal(10, byteidxcomp(str, 7, v:true))\n  call assert_equal(12, byteidxcomp(str, 8, v:true))\n  call assert_equal(-1, byteidxcomp(str, 9, v:true))\n\n  \" empty string\n  call assert_equal(0, byteidxcomp('', 0, v:true))\n  call assert_equal(-1, byteidxcomp('', 1, v:true))\n\n  \" error cases\n  call assert_fails('call byteidxcomp(str, 0, [])', 'E745:')\nendfunc\n\n\" Test for charidx() using a byte index\nfunc Test_charidx()\n  let a = 'xa\u0301b\u0301y'\n  call assert_equal(0, charidx(a, 0))\n  call assert_equal(1, charidx(a, 3))\n  call assert_equal(2, charidx(a, 4))\n  call assert_equal(3, charidx(a, 7))\n  call assert_equal(4, charidx(a, 8))\n  call assert_equal(-1, charidx(a, 9))\n  call assert_equal(-1, charidx(a, -1))\n\n  \" count composing characters\n  call assert_equal(0, a->charidx(0, 1))\n  call assert_equal(2, a->charidx(2, 1))\n  call assert_equal(3, a->charidx(4, 1))\n  call assert_equal(5, a->charidx(7, 1))\n  call assert_equal(6, a->charidx(8, 1))\n  call assert_equal(-1, a->charidx(9, 1))\n\n  \" empty string\n  call assert_equal(0, charidx('', 0))\n  call assert_equal(-1, charidx('', 1))\n  call assert_equal(0, charidx('', 0, 1))\n  call assert_equal(-1, charidx('', 1, 1))\n\n  \" error cases\n  call assert_equal(0, charidx(test_null_string(), 0))\n  call assert_equal(-1, charidx(test_null_string(), 1))\n  call assert_fails('let x = charidx([], 1)', 'E1174:')\n  call assert_fails('let x = charidx(\"abc\", [])', 'E1210:')\n  call assert_fails('let x = charidx(\"abc\", 1, [])', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, -1)', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, 2)', 'E1212:')\nendfunc\n\n\" Test for charidx() using a UTF-16 index\nfunc Test_charidx_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(4)\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(-1, charidx(str, 4, v:false, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, charidx(str, 0, v:false, v:true))\n  call assert_equal(1, charidx(str, 1, v:false, v:true))\n  call assert_equal(2, charidx(str, 2, v:false, v:true))\n  call assert_equal(3, charidx(str, 3, v:false, v:true))\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n\n  \" string with four byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, charidx(str, 0, v:false, v:true))\n  call assert_equal(1, charidx(str, 1, v:false, v:true))\n  call assert_equal(1, charidx(str, 2, v:false, v:true))\n  call assert_equal(2, charidx(str, 3, v:false, v:true))\n  call assert_equal(2, charidx(str, 4, v:false, v:true))\n  call assert_equal(3, charidx(str, 5, v:false, v:true))\n  call assert_equal(4, charidx(str, 6, v:false, v:true))\n  call assert_equal(-1, charidx(str, 7, v:false, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, charidx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(6, charidx(str, 6, v:true, v:true))\n  call assert_equal(-1, charidx(str, 7, v:true, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, charidx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(8, charidx(str, 8, v:true, v:true))\n  call assert_equal(-1, charidx(str, 9, v:true, v:true))\n\n  \" empty string\n  call assert_equal(0, charidx('', 0, v:false, v:true))\n  call assert_equal(-1, charidx('', 1, v:false, v:true))\n  call assert_equal(0, charidx('', 0, v:true, v:true))\n  call assert_equal(-1, charidx('', 1, v:true, v:true))\n\n  \" error cases\n  call assert_equal(0, charidx('', 0, v:false, v:true))\n  call assert_equal(-1, charidx('', 1, v:false, v:true))\n  call assert_equal(0, charidx('', 0, v:true, v:true))\n  call assert_equal(-1, charidx('', 1, v:true, v:true))\n  call assert_equal(0, charidx(test_null_string(), 0, v:false, v:true))\n  call assert_equal(-1, charidx(test_null_string(), 1, v:false, v:true))\n  call assert_fails('let x = charidx(\"abc\", 1, v:false, [])', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, v:true, [])', 'E1212:')\nendfunc\n\n\" Test for utf16idx() using a byte index\nfunc Test_utf16idx_from_byteidx()\n  \" UTF-16 index of a string with single byte characters\n  let str = \"abc\"\n  for i in range(4)\n    call assert_equal(i, utf16idx(str, i))\n  endfor\n  call assert_equal(-1, utf16idx(str, 4))\n\n  \" UTF-16 index of a string with two byte characters\n  let str = 'a\u00a9\u00a9b'\n  call assert_equal(0, str->utf16idx(0))\n  call assert_equal(1, str->utf16idx(1))\n  call assert_equal(1, str->utf16idx(2))\n  call assert_equal(2, str->utf16idx(3))\n  call assert_equal(2, str->utf16idx(4))\n  call assert_equal(3, str->utf16idx(5))\n  call assert_equal(4, str->utf16idx(6))\n  call assert_equal(-1, str->utf16idx(7))\n\n  \" UTF-16 index of a string with four byte characters\n  let str = 'a\ud83d\ude0a\ud83d\ude0ab'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(1, utf16idx(str, 4))\n  call assert_equal(3, utf16idx(str, 5))\n  call assert_equal(3, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(3, utf16idx(str, 8))\n  call assert_equal(5, utf16idx(str, 9))\n  call assert_equal(6, utf16idx(str, 10))\n  call assert_equal(-1, utf16idx(str, 11))\n\n  \" UTF-16 index of a string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(2, utf16idx(str, 4))\n  call assert_equal(3, utf16idx(str, 5))\n  call assert_equal(3, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(4, utf16idx(str, 8))\n  call assert_equal(-1, utf16idx(str, 9))\n  call assert_equal(0, utf16idx(str, 0, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:true))\n  call assert_equal(2, utf16idx(str, 2, v:true))\n  call assert_equal(2, utf16idx(str, 3, v:true))\n  call assert_equal(3, utf16idx(str, 4, v:true))\n  call assert_equal(4, utf16idx(str, 5, v:true))\n  call assert_equal(5, utf16idx(str, 6, v:true))\n  call assert_equal(5, utf16idx(str, 7, v:true))\n  call assert_equal(6, utf16idx(str, 8, v:true))\n  call assert_equal(-1, utf16idx(str, 9, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(1, utf16idx(str, 4))\n  call assert_equal(1, utf16idx(str, 5))\n  call assert_equal(2, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(3, utf16idx(str, 8))\n  call assert_equal(3, utf16idx(str, 9))\n  call assert_equal(3, utf16idx(str, 10))\n  call assert_equal(3, utf16idx(str, 11))\n  call assert_equal(4, utf16idx(str, 12))\n  call assert_equal(-1, utf16idx(str, 13))\n  call assert_equal(0, utf16idx(str, 0, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:true))\n  call assert_equal(2, utf16idx(str, 2, v:true))\n  call assert_equal(2, utf16idx(str, 3, v:true))\n  call assert_equal(3, utf16idx(str, 4, v:true))\n  call assert_equal(3, utf16idx(str, 5, v:true))\n  call assert_equal(4, utf16idx(str, 6, v:true))\n  call assert_equal(5, utf16idx(str, 7, v:true))\n  call assert_equal(6, utf16idx(str, 8, v:true))\n  call assert_equal(6, utf16idx(str, 9, v:true))\n  call assert_equal(7, utf16idx(str, 10, v:true))\n  call assert_equal(7, utf16idx(str, 11, v:true))\n  call assert_equal(8, utf16idx(str, 12, v:true))\n  call assert_equal(-1, utf16idx(str, 13, v:true))\n\n  \" empty string\n  call assert_equal(0, utf16idx('', 0))\n  call assert_equal(-1, utf16idx('', 1))\n  call assert_equal(0, utf16idx('', 0, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:true))\n\n  \" error cases\n  call assert_equal(0, utf16idx(\"\", 0))\n  call assert_equal(-1, utf16idx(\"\", 1))\n  call assert_equal(-1, utf16idx(\"abc\", -1))\n  call assert_equal(0, utf16idx(test_null_string(), 0))\n  call assert_equal(-1, utf16idx(test_null_string(), 1))\n  call assert_fails('let l = utf16idx([], 0)', 'E1174:')\n  call assert_fails('let l = utf16idx(\"ab\", [])', 'E1210:')\n  call assert_fails('let l = utf16idx(\"ab\", 0, [])', 'E1212:')\nendfunc\n\n\" Test for utf16idx() using a character index\nfunc Test_utf16idx_from_charidx()\n  let str = \"abc\"\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(3, utf16idx(str, 3, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 4, v:false, v:true))\n\n  \" UTF-16 index of a string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n\n  \" UTF-16 index of a string with four byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, utf16idx(str, 0, v:false, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:false, v:true))\n  call assert_equal(3, utf16idx(str, 2, v:false, v:true))\n  call assert_equal(5, utf16idx(str, 3, v:false, v:true))\n  call assert_equal(6, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n\n  \" UTF-16 index of a string with composing characters\n  let str = '-a\u0301-b\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, utf16idx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(6, utf16idx(str, 6, v:true, v:true))\n  call assert_equal(-1, utf16idx(str, 7, v:true, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, utf16idx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(8, utf16idx(str, 8, v:true, v:true))\n  call assert_equal(-1, utf16idx(str, 9, v:true, v:true))\n\n  \" empty string\n  call assert_equal(0, utf16idx('', 0, v:false, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:false, v:true))\n  call assert_equal(0, utf16idx('', 0, v:true, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:true, v:true))\n\n  \" error cases\n  call assert_equal(0, utf16idx(test_null_string(), 0, v:true, v:true))\n  call assert_equal(-1, utf16idx(test_null_string(), 1, v:true, v:true))\n  call assert_fails('let l = utf16idx(\"ab\", 0, v:false, [])', 'E1212:')\nendfunc\n\n\" Test for strutf16len()\nfunc Test_strutf16len()\n  call assert_equal(3, strutf16len('abc'))\n  call assert_equal(3, 'abc'->strutf16len(v:true))\n  call assert_equal(4, strutf16len('a\u00a9\u00a9b'))\n  call assert_equal(4, strutf16len('a\u00a9\u00a9b', v:true))\n  call assert_equal(6, strutf16len('a\ud83d\ude0a\ud83d\ude0ab'))\n  call assert_equal(6, strutf16len('a\ud83d\ude0a\ud83d\ude0ab', v:true))\n  call assert_equal(4, strutf16len('-a\u0301-b\u0301'))\n  call assert_equal(6, strutf16len('-a\u0301-b\u0301', v:true))\n  call assert_equal(4, strutf16len('-a\u0328\u0301-a\u0328\u0301'))\n  call assert_equal(8, strutf16len('-a\u0328\u0301-a\u0328\u0301', v:true))\n  call assert_equal(0, strutf16len(''))\n\n  \" error cases\n  call assert_fails('let l = strutf16len([])', 'E1174:')\n  call assert_fails('let l = strutf16len(\"a\", [])', 'E1212:')\n  call assert_equal(0, strutf16len(test_null_string()))\nendfunc\n\nfunc Test_count()\n  let l = ['a', 'a', 'A', 'b']\n  call assert_equal(2, count(l, 'a'))\n  call assert_equal(1, count(l, 'A'))\n  call assert_equal(1, count(l, 'b'))\n  call assert_equal(0, count(l, 'B'))\n\n  call assert_equal(2, count(l, 'a', 0))\n  call assert_equal(1, count(l, 'A', 0))\n  call assert_equal(1, count(l, 'b', 0))\n  call assert_equal(0, count(l, 'B', 0))\n\n  call assert_equal(3, count(l, 'a', 1))\n  call assert_equal(3, count(l, 'A', 1))\n  call assert_equal(1, count(l, 'b', 1))\n  call assert_equal(1, count(l, 'B', 1))\n  call assert_equal(0, count(l, 'c', 1))\n\n  call assert_equal(1, count(l, 'a', 0, 1))\n  call assert_equal(2, count(l, 'a', 1, 1))\n  call assert_fails('call count(l, \"a\", 0, 10)', 'E684:')\n  call assert_fails('call count(l, \"a\", [])', 'E745:')\n\n  let d = {1: 'a', 2: 'a', 3: 'A', 4: 'b'}\n  call assert_equal(2, count(d, 'a'))\n  call assert_equal(1, count(d, 'A'))\n  call assert_equal(1, count(d, 'b'))\n  call assert_equal(0, count(d, 'B'))\n\n  call assert_equal(2, count(d, 'a', 0))\n  call assert_equal(1, count(d, 'A', 0))\n  call assert_equal(1, count(d, 'b', 0))\n  call assert_equal(0, count(d, 'B', 0))\n\n  call assert_equal(3, count(d, 'a', 1))\n  call assert_equal(3, count(d, 'A', 1))\n  call assert_equal(1, count(d, 'b', 1))\n  call assert_equal(1, count(d, 'B', 1))\n  call assert_equal(0, count(d, 'c', 1))\n\n  call assert_fails('call count(d, \"a\", 0, 1)', 'E474:')\n\n  call assert_equal(0, count(\"foo\", \"bar\"))\n  call assert_equal(1, count(\"foo\", \"oo\"))\n  call assert_equal(2, count(\"foo\", \"o\"))\n  call assert_equal(0, count(\"foo\", \"O\"))\n  call assert_equal(2, count(\"foo\", \"O\", 1))\n  call assert_equal(2, count(\"fooooo\", \"oo\"))\n  call assert_equal(0, count(\"foo\", \"\"))\n\n  call assert_fails('call count(0, 0)', 'E706:')\n  call assert_fails('call count(\"\", \"\", {})', ['E728:', 'E728:'])\nendfunc\n\nfunc Test_changenr()\n  new Xchangenr\n  call assert_equal(0, changenr())\n  norm ifoo\n  call assert_equal(1, changenr())\n  set undolevels=10\n  norm Sbar\n  call assert_equal(2, changenr())\n  undo\n  call assert_equal(1, changenr())\n  redo\n  call assert_equal(2, changenr())\n  bw!\n  set undolevels&\nendfunc\n\nfunc Test_filewritable()\n  new Xfilewritable\n  write!\n  call assert_equal(1, filewritable('Xfilewritable'))\n\n  call assert_notequal(0, setfperm('Xfilewritable', 'r--r-----'))\n  call assert_equal(0, filewritable('Xfilewritable'))\n\n  call assert_notequal(0, setfperm('Xfilewritable', 'rw-r-----'))\n  call assert_equal(1, 'Xfilewritable'->filewritable())\n\n  call assert_equal(0, filewritable('doesnotexist'))\n\n  call mkdir('Xwritedir', 'D')\n  call assert_equal(2, filewritable('Xwritedir'))\n\n  call delete('Xfilewritable')\n  bw!\nendfunc\n\nfunc Test_Executable()\n  if has('win32')\n    call assert_equal(1, executable('notepad'))\n    call assert_equal(1, 'notepad.exe'->executable())\n    call assert_equal(0, executable('notepad.exe.exe'))\n    call assert_equal(0, executable('shell32.dll'))\n    call assert_equal(0, executable('win.ini'))\n\n    \" get \"notepad\" path and remove the leading drive and sep. (ex. 'C:\\')\n    let notepadcmd = exepath('notepad.exe')\n    let driveroot = notepadcmd[:2]\n    let notepadcmd = notepadcmd[3:]\n    new\n    \" check that the relative path works in /\n    execute 'lcd' driveroot\n    call assert_equal(1, executable(notepadcmd))\n    call assert_equal(driveroot .. notepadcmd, notepadcmd->exepath())\n    bwipe\n\n    \" create \"notepad.bat\"\n    call mkdir('Xnotedir')\n    let notepadbat = fnamemodify('Xnotedir/notepad.bat', ':p')\n    call writefile([], notepadbat)\n    new\n    \" check that the path and the pathext order is valid\n    lcd Xnotedir\n    let [pathext, $PATHEXT] = [$PATHEXT, '.com;.exe;.bat;.cmd']\n    call assert_equal(notepadbat, exepath('notepad'))\n    let $PATHEXT = pathext\n    \" check for symbolic link\n    execute 'silent !mklink np.bat \"' .. notepadbat .. '\"'\n    call assert_equal(1, executable('./np.bat'))\n    call assert_equal(1, executable('./np'))\n    bwipe\n    eval 'Xnotedir'->delete('rf')\n  elseif has('unix')\n    call assert_equal(1, 'cat'->executable())\n    call assert_equal(0, executable('nodogshere'))\n\n    \" get \"cat\" path and remove the leading /\n    let catcmd = exepath('cat')[1:]\n    new\n    \" check that the relative path works in /\n    lcd /\n    call assert_equal(1, executable(catcmd))\n    let result = catcmd->exepath()\n    \" when using chroot looking for sbin/cat can return bin/cat, that is OK\n    if catcmd =~ '\\<sbin\\>' && result =~ '\\<bin\\>'\n      call assert_equal('/' .. substitute(catcmd, '\\<sbin\\>', 'bin', ''), result)\n    else\n      \" /bin/cat and /usr/bin/cat may be hard linked, we could get either\n      let result = substitute(result, '/usr/bin/cat', '/bin/cat', '')\n      let catcmd = substitute(catcmd, 'usr/bin/cat', 'bin/cat', '')\n      call assert_equal('/' .. catcmd, result)\n    endif\n    bwipe\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_executable_windows_store_apps()\n  CheckMSWindows\n\n  \" Windows Store apps install some 'decoy' .exe that require some careful\n  \" handling as they behave similarly to symlinks.\n  let app_dir = expand(\"$LOCALAPPDATA\\\\Microsoft\\\\WindowsApps\")\n  if !isdirectory(app_dir)\n    return\n  endif\n\n  let save_path = $PATH\n  let $PATH = app_dir\n  \" Ensure executable() finds all the app .exes\n  for entry in readdir(app_dir)\n    if entry =~ '\\.exe$'\n      call assert_true(executable(entry))\n    endif\n  endfor\n\n  let $PATH = save_path\nendfunc\n\nfunc Test_executable_longname()\n  CheckMSWindows\n\n  \" Create a temporary .bat file with 205 characters in the name.\n  \" Maximum length of a filename (including the path) on MS-Windows is 259\n  \" characters.\n  \" See https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation\n  let len = 259 - getcwd()->len() - 6\n  if len > 200\n    let len = 200\n  endif\n\n  let fname = 'X' . repeat('\u3042', len) . '.bat'\n  call writefile([], fname)\n  call assert_equal(1, executable(fname))\n  call delete(fname)\nendfunc\n\nfunc Test_hostname()\n  let hostname_vim = hostname()\n  if has('unix')\n    let hostname_system = systemlist('uname -n')[0]\n    call assert_equal(hostname_vim, hostname_system)\n  endif\nendfunc\n\nfunc Test_getpid()\n  \" getpid() always returns the same value within a vim instance.\n  call assert_equal(getpid(), getpid())\n  if has('unix')\n    call assert_equal(systemlist('echo $PPID')[0], string(getpid()))\n  endif\nendfunc\n\nfunc Test_hlexists()\n  call assert_equal(0, hlexists('does_not_exist'))\n  call assert_equal(0, 'Number'->hlexists())\n  call assert_equal(0, highlight_exists('does_not_exist'))\n  call assert_equal(0, highlight_exists('Number'))\n  syntax on\n  call assert_equal(0, hlexists('does_not_exist'))\n  call assert_equal(1, hlexists('Number'))\n  call assert_equal(0, highlight_exists('does_not_exist'))\n  call assert_equal(1, highlight_exists('Number'))\n  syntax off\nendfunc\n\n\" Test for the col() function\nfunc Test_col()\n  new\n  call setline(1, 'abcdef')\n  norm gg4|mx6|mY2|\n  call assert_equal(2, col('.'))\n  call assert_equal(7, col('$'))\n  call assert_equal(2, col('v'))\n  call assert_equal(4, col(\"'x\"))\n  call assert_equal(6, col(\"'Y\"))\n  call assert_equal(2, [1, 2]->col())\n  call assert_equal(7, col([1, '$']))\n\n  call assert_equal(0, col(''))\n  call assert_equal(0, col('x'))\n  call assert_equal(0, col([2, '$']))\n  call assert_equal(0, col([1, 100]))\n  call assert_equal(0, col([1]))\n  call assert_equal(0, col(test_null_list()))\n  call assert_fails('let c = col({})', 'E1222:')\n  call assert_fails('let c = col(\".\", [])', 'E1210:')\n\n  \" test for getting the visual start column\n  func T()\n    let g:Vcol = col('v')\n    return ''\n  endfunc\n  let g:Vcol = 0\n  xmap <expr> <F2> T()\n  exe \"normal gg3|ve\\<F2>\"\n  call assert_equal(3, g:Vcol)\n  xunmap <F2>\n  delfunc T\n\n  \" Test for the visual line start and end marks '< and '>\n  call setline(1, ['one', 'one two', 'one two three'])\n  \"normal! ggVG\n  call feedkeys(\"ggVG\\<Esc>\", 'xt')\n  call assert_equal(1, col(\"'<\"))\n  call assert_equal(14, col(\"'>\"))\n  \" Delete the last line of the visually selected region\n  $d\n  call assert_notequal(14, col(\"'>\"))\n\n  \" Test with 'virtualedit'\n  set virtualedit=all\n  call cursor(1, 10)\n  call assert_equal(4, col('.'))\n  set virtualedit&\n\n  \" Test for getting the column number in another window\n  let winid = win_getid()\n  new\n  call win_execute(winid, 'normal 1G$')\n  call assert_equal(3, col('.', winid))\n  call win_execute(winid, 'normal 2G')\n  call assert_equal(8, col('$', winid))\n  call assert_equal(0, col('.', 5001))\n\n  bw!\nendfunc\n\n\" Test for input()\nfunc Test_input_func()\n  \" Test for prompt with multiple lines\n  redir => v\n  call feedkeys(\":let c = input(\\\"A\\\\nB\\\\nC\\\\n? \\\")\\<CR>B\\<CR>\", 'xt')\n  redir END\n  call assert_equal(\"B\", c)\n  call assert_equal(['A', 'B', 'C'], split(v, \"\\n\"))\n\n  \" Test for default value\n  call feedkeys(\":let c = input('color? ', 'red')\\<CR>\\<CR>\", 'xt')\n  call assert_equal('red', c)\n\n  \" Test for completion at the input prompt\n  func! Tcomplete(arglead, cmdline, pos)\n    return \"item1\\nitem2\\nitem3\"\n  endfunc\n  call feedkeys(\":let c = input('Q? ', '', 'custom,Tcomplete')\\<CR>\"\n        \\ .. \"\\<C-A>\\<CR>\", 'xt')\n  delfunc Tcomplete\n  call assert_equal('item1 item2 item3', c)\n\n  \" Test for using special characters as default input\n  call feedkeys(\":let c = input('name? ', \\\"x\\\\<BS>y\\\")\\<CR>\\<CR>\", 'xt')\n  call assert_equal('y', c)\n\n  \" Test for using text with composing characters as default input\n  call feedkeys(\":let c = input('name? ', \\\"a\u0303\u0333\\\")\\<CR>\\<CR>\", 'xt')\n  call assert_equal('a\u0303\u0333', c)\n\n  \" Test for using <CR> as default input\n  call feedkeys(\":let c = input('name? ', \\\"\\\\<CR>\\\")\\<CR>x\\<CR>\", 'xt')\n  call assert_equal(' x', c)\n\n  call assert_fails(\"call input('F:', '', 'invalid')\", 'E180:')\n  call assert_fails(\"call input('F:', '', [])\", 'E730:')\nendfunc\n\n\" Test for the inputdialog() function\nfunc Test_inputdialog()\n  set timeout timeoutlen=10\n  if has('gui_running')\n    call assert_fails('let v=inputdialog([], \"xx\")', 'E730:')\n    call assert_fails('let v=inputdialog(\"Q\", [])', 'E730:')\n  else\n    call feedkeys(\":let v=inputdialog('Q:', 'xx', 'yy')\\<CR>\\<CR>\", 'xt')\n    call assert_equal('xx', v)\n    call feedkeys(\":let v=inputdialog('Q:', 'xx', 'yy')\\<CR>\\<Esc>\", 'xt')\n    call assert_equal('yy', v)\n  endif\n  set timeout& timeoutlen&\nendfunc\n\n\" Test for inputlist()\nfunc Test_inputlist()\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>1\\<cr>\", 'tx')\n  call assert_equal(1, c)\n  call feedkeys(\":let c = ['Select color:', '1. red', '2. green', '3. blue']->inputlist()\\<cr>2\\<cr>\", 'tx')\n  call assert_equal(2, c)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>3\\<cr>\", 'tx')\n  call assert_equal(3, c)\n\n  \" CR to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<cr>\", 'tx')\n  call assert_equal(0, c)\n\n  \" Esc to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<Esc>\", 'tx')\n  call assert_equal(0, c)\n\n  \" q to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>q\", 'tx')\n  call assert_equal(0, c)\n\n  \" Cancel after inputting a number\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>5q\", 'tx')\n  call assert_equal(0, c)\n\n  \" Use backspace to delete characters in the prompt\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>1\\<BS>3\\<BS>2\\<cr>\", 'tx')\n  call assert_equal(2, c)\n\n  \" Use mouse to make a selection\n  call test_setmouse(&lines - 3, 2)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<LeftMouse>\", 'tx')\n  call assert_equal(1, c)\n  \" Mouse click outside of the list\n  call test_setmouse(&lines - 6, 2)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<LeftMouse>\", 'tx')\n  call assert_equal(-2, c)\n\n  call assert_fails('call inputlist(\"\")', 'E686:')\n  call assert_fails('call inputlist(test_null_list())', 'E686:')\nendfunc\n\nfunc Test_range_inputlist()\n  \" flush out any garbage left in the buffer\n  while getchar(0)\n  endwhile\n\n  call feedkeys(\":let result = inputlist(range(10))\\<CR>1\\<CR>\", 'x')\n  call assert_equal(1, result)\n  call feedkeys(\":let result = inputlist(range(3, 10))\\<CR>1\\<CR>\", 'x')\n  call assert_equal(1, result)\n\n  unlet result\nendfunc\n\nfunc Test_balloon_show()\n  CheckFeature balloon_eval\n\n  \" This won't do anything but must not crash either.\n  call balloon_show('hi!')\n  if !has('gui_running')\n    call balloon_show(range(3))\n    call balloon_show([])\n  endif\nendfunc\n\nfunc Test_setbufvar_options()\n  \" This tests that aucmd_prepbuf() and aucmd_restbuf() properly restore the\n  \" window layout and cursor position.\n  call assert_equal(1, winnr('$'))\n  split dummy_preview\n  resize 2\n  set winfixheight winfixwidth\n  let prev_id = win_getid()\n\n  wincmd j\n  let wh = winheight(0)\n  let dummy_buf = bufnr('dummy_buf1', v:true)\n  call setbufvar(dummy_buf, '&buftype', 'nofile')\n  execute 'belowright vertical split #' . dummy_buf\n  call assert_equal(wh, winheight(0))\n  let dum1_id = win_getid()\n  call setline(1, 'foo')\n  normal! V$\n  call assert_equal(4, col('.'))\n  call setbufvar('dummy_preview', '&buftype', 'nofile')\n  call assert_equal(4, col('.'))\n\n  wincmd h\n  let wh = winheight(0)\n  call setline(1, 'foo')\n  normal! V$\n  call assert_equal(4, col('.'))\n  let dummy_buf = bufnr('dummy_buf2', v:true)\n  eval 'nofile'->setbufvar(dummy_buf, '&buftype')\n  call assert_equal(4, col('.'))\n  execute 'belowright vertical split #' . dummy_buf\n  call assert_equal(wh, winheight(0))\n\n  bwipe!\n  call win_gotoid(prev_id)\n  bwipe!\n  call win_gotoid(dum1_id)\n  bwipe!\nendfunc\n\nfunc Test_setbufvar_keep_window_title()\n  CheckRunVimInTerminal\n  if !has('title') || empty(&t_ts)\n    throw \"Skipped: can't get/set title\"\n  endif\n\n  let lines =<< trim END\n      set title\n      edit Xa.txt\n      let g:buf = bufadd('Xb.txt')\n      inoremap <F2> <C-R>=setbufvar(g:buf, '&autoindent', 1) ?? ''<CR>\n  END\n  call writefile(lines, 'Xsetbufvar', 'D')\n  let buf = RunVimInTerminal('-S Xsetbufvar', {})\n  call WaitForAssert({-> assert_match('Xa.txt', term_gettitle(buf))}, 1000)\n\n  call term_sendkeys(buf, \"i\\<F2>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call TermWait(buf)\n  call assert_match('Xa.txt', term_gettitle(buf))\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redo_in_nested_functions()\n  nnoremap g. :set opfunc=Operator<CR>g@\n  function Operator( type, ... )\n     let @x = 'XXX'\n     execute 'normal! g`[' . (a:type ==# 'line' ? 'V' : 'v') . 'g`]' . '\"xp'\n  endfunction\n\n  function! Apply()\n      5,6normal! .\n  endfunction\n\n  new\n  call setline(1, repeat(['some \"quoted\" text', 'more \"quoted\" text'], 3))\n  1normal g.i\"\n  call assert_equal('some \"XXX\" text', getline(1))\n  3,4normal .\n  call assert_equal('some \"XXX\" text', getline(3))\n  call assert_equal('more \"XXX\" text', getline(4))\n  call Apply()\n  call assert_equal('some \"XXX\" text', getline(5))\n  call assert_equal('more \"XXX\" text', getline(6))\n  bwipe!\n\n  nunmap g.\n  delfunc Operator\n  delfunc Apply\nendfunc\n\nfunc Test_trim()\n  call assert_equal(\"Testing\", trim(\"  \\t\\r\\r\\x0BTesting  \\t\\n\\r\\n\\t\\x0B\\x0B\"))\n  call assert_equal(\"Testing\", \"  \\t  \\r\\r\\n\\n\\x0BTesting  \\t\\n\\r\\n\\t\\x0B\\x0B\"->trim())\n  call assert_equal(\"RESERVE\", trim(\"xyz \\twwRESERVEzyww \\t\\t\", \" wxyz\\t\"))\n  call assert_equal(\"wRE    \\tSERVEzyww\", trim(\"wRE    \\tSERVEzyww\"))\n  call assert_equal(\"abcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\"))\n  call assert_equal(\"\\tabcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\", \" \"))\n  call assert_equal(\" \\tabcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\", \"abx\"))\n  call assert_equal(\"RESERVE\", trim(\"\u4f60RESERVE\u597d\", \"\u4f60\u597d\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\", trim(\"\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60\", \"\u4f60\u597d\"))\n  call assert_equal(\"\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60\", trim(\" \\n\\r\\r   \u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", ))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    \u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", \" \u4f60\u597d\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    tteesstttt\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B ttestt\", \" \u4f60\u597dtes\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    tteesstttt\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B ttestt\", \"   \u4f60\u4f60\u4f60\u597d\u597d\u597dtttsses\"))\n  call assert_equal(\"\u7559\u4e0b\", trim(\"\u8fd9\u4e9b\u4e9b\u4e0d\u8981\u8fd9\u4e9b\u7559\u4e0b\u8fd9\u4e9b\", \"\u8fd9\u4e9b\u4e0d\u8981\"))\n  call assert_equal(\"\", trim(\"\", \"\"))\n  call assert_equal(\"a\", trim(\"a\", \"\"))\n  call assert_equal(\"\", trim(\"\", \"a\"))\n\n  call assert_equal(\"vim\", trim(\"  vim  \", \" \", 0))\n  call assert_equal(\"vim  \", trim(\"  vim  \", \" \", 1))\n  call assert_equal(\"  vim\", trim(\"  vim  \", \" \", 2))\n  call assert_fails('eval trim(\"  vim  \", \" \", [])', 'E745:')\n  call assert_fails('eval trim(\"  vim  \", \" \", -1)', 'E475:')\n  call assert_fails('eval trim(\"  vim  \", \" \", 3)', 'E475:')\n  call assert_fails('eval trim(\"  vim  \", 0)', 'E1174:')\n\n  let chars = join(map(range(1, 0x20) + [0xa0], {n -> n->nr2char()}), '')\n  call assert_equal(\"x\", trim(chars . \"x\" . chars))\n\n  call assert_fails('let c=trim([])', 'E730:')\nendfunc\n\n\" Test for reg_recording() and reg_executing()\nfunc Test_reg_executing_and_recording()\n  let s:reg_stat = ''\n  func s:save_reg_stat()\n    let s:reg_stat = reg_recording() . ':' . reg_executing()\n    return ''\n  endfunc\n\n  new\n  call s:save_reg_stat()\n  call assert_equal(':', s:reg_stat)\n  call feedkeys(\"qa\\\"=s:save_reg_stat()\\<CR>pq\", 'xt')\n  call assert_equal('a:', s:reg_stat)\n  call feedkeys(\"@a\", 'xt')\n  call assert_equal(':a', s:reg_stat)\n  call feedkeys(\"qb@aq\", 'xt')\n  call assert_equal('b:a', s:reg_stat)\n  call feedkeys(\"q\\\"\\\"=s:save_reg_stat()\\<CR>pq\", 'xt')\n  call assert_equal('\":', s:reg_stat)\n\n  \" :normal command saves and restores reg_executing\n  let s:reg_stat = ''\n  let @q = \":call TestFunc()\\<CR>:call s:save_reg_stat()\\<CR>\"\n  func TestFunc() abort\n    normal! ia\n  endfunc\n  call feedkeys(\"@q\", 'xt')\n  call assert_equal(':q', s:reg_stat)\n  delfunc TestFunc\n\n  \" getchar() command saves and restores reg_executing\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:regs += [reg_executing()]\n    let g:typed = getchar(0)\n    let g:regs += [reg_executing()]\n  endfunc\n  call feedkeys(\"@qy\", 'xt')\n  call assert_equal(char2nr(\"y\"), g:typed)\n  call assert_equal(['q', 'q'], g:regs)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed\n  unlet g:regs\n\n  \" input() command saves and restores reg_executing\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:regs += [reg_executing()]\n    let g:typed = '?'->input()\n    let g:regs += [reg_executing()]\n  endfunc\n  call feedkeys(\"@qy\\<CR>\", 'xt')\n  call assert_equal(\"y\", g:typed)\n  call assert_equal(['q', 'q'], g:regs)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed\n  unlet g:regs\n\n  bwipe!\n  delfunc s:save_reg_stat\n  unlet s:reg_stat\nendfunc\n\nfunc Test_inputsecret()\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed1 = ''\n  let g:typed2 = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:typed1 = '?'->inputsecret()\n    let g:typed2 = inputsecret('password: ')\n  endfunc\n  call feedkeys(\"@qsomething\\<CR>else\\<CR>\", 'xt')\n  call assert_equal(\"something\", g:typed1)\n  call assert_equal(\"else\", g:typed2)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed1\n  unlet g:typed2\nendfunc\n\nfunc Test_getchar()\n  call feedkeys('a', '')\n  call assert_equal(char2nr('a'), getchar())\n  call assert_equal(0, getchar(0))\n  call assert_equal(0, getchar(1))\n\n  call feedkeys('a', '')\n  call assert_equal('a', getcharstr())\n  call assert_equal('', getcharstr(0))\n  call assert_equal('', getcharstr(1))\n\n  call feedkeys(\"\\<M-F2>\", '')\n  call assert_equal(\"\\<M-F2>\", getchar(0))\n  call assert_equal(0, getchar(0))\n\n  call setline(1, 'xxxx')\n  call test_setmouse(1, 3)\n  let v:mouse_win = 9\n  let v:mouse_winid = 9\n  let v:mouse_lnum = 9\n  let v:mouse_col = 9\n  call feedkeys(\"\\<S-LeftMouse>\", '')\n  call assert_equal(\"\\<S-LeftMouse>\", getchar())\n  call assert_equal(1, v:mouse_win)\n  call assert_equal(win_getid(1), v:mouse_winid)\n  call assert_equal(1, v:mouse_lnum)\n  call assert_equal(3, v:mouse_col)\n  enew!\nendfunc\n\nfunc Test_libcall_libcallnr()\n  CheckFeature libcall\n\n  if has('win32')\n    let libc = 'msvcrt.dll'\n  elseif has('mac')\n    let libc = 'libSystem.B.dylib'\n  elseif executable('ldd')\n    let libc = matchstr(split(system('ldd ' . GetVimProg())), '/libc\\.so\\>')\n  endif\n  if get(l:, 'libc', '') ==# ''\n    \" On Unix, libc.so can be in various places.\n    if has('linux')\n      \" There is not documented but regarding the 1st argument of glibc's\n      \" dlopen an empty string and nullptr are equivalent, so using an empty\n      \" string for the 1st argument of libcall allows to call functions.\n      let libc = ''\n    elseif has('sun')\n      \" Set the path to libc.so according to the architecture.\n      let test_bits = system('file ' . GetVimProg())\n      let test_arch = system('uname -p')\n      if test_bits =~ '64-bit' && test_arch =~ 'sparc'\n        let libc = '/usr/lib/sparcv9/libc.so'\n      elseif test_bits =~ '64-bit' && test_arch =~ 'i386'\n        let libc = '/usr/lib/amd64/libc.so'\n      else\n        let libc = '/usr/lib/libc.so'\n      endif\n    else\n      \" Unfortunately skip this test until a good way is found.\n      return\n    endif\n  endif\n\n  if has('win32')\n    call assert_equal($USERPROFILE, 'USERPROFILE'->libcall(libc, 'getenv'))\n  else\n    call assert_equal($HOME, 'HOME'->libcall(libc, 'getenv'))\n  endif\n\n  \" If function returns NULL, libcall() should return an empty string.\n  call assert_equal('', libcall(libc, 'getenv', 'X_ENV_DOES_NOT_EXIT'))\n\n  \" Test libcallnr() with string and integer argument.\n  call assert_equal(4, 'abcd'->libcallnr(libc, 'strlen'))\n  call assert_equal(char2nr('A'), char2nr('a')->libcallnr(libc, 'toupper'))\n\n  call assert_fails(\"call libcall(libc, 'Xdoesnotexist_', '')\", ['', 'E364:'])\n  call assert_fails(\"call libcallnr(libc, 'Xdoesnotexist_', '')\", ['', 'E364:'])\n\n  call assert_fails(\"call libcall('Xdoesnotexist_', 'getenv', 'HOME')\", ['', 'E364:'])\n  call assert_fails(\"call libcallnr('Xdoesnotexist_', 'strlen', 'abcd')\", ['', 'E364:'])\nendfunc\n\nsandbox function Fsandbox()\n  normal ix\nendfunc\n\nfunc Test_func_sandbox()\n  sandbox let F = {-> 'hello'}\n  call assert_equal('hello', F())\n\n  sandbox let F = {-> \"normal ix\\<Esc>\"->execute()}\n  call assert_fails('call F()', 'E48:')\n  unlet F\n\n  call assert_fails('call Fsandbox()', 'E48:')\n  delfunc Fsandbox\n\n  \" From a sandbox try to set a predefined variable (which cannot be modified\n  \" from a sandbox)\n  call assert_fails('sandbox let v:lnum = 10', 'E794:')\nendfunc\n\nfunc EditAnotherFile()\n  let word = expand('<cword>')\n  edit Xfuncrange2\nendfunc\n\nfunc Test_func_range_with_edit()\n  \" Define a function that edits another buffer, then call it with a range that\n  \" is invalid in that buffer.\n  call writefile(['just one line'], 'Xfuncrange2', 'D')\n  new\n  eval 10->range()->setline(1)\n  write Xfuncrange1\n  call assert_fails('5,8call EditAnotherFile()', 'E16:')\n\n  call delete('Xfuncrange1')\n  bwipe!\nendfunc\n\nfunc Test_func_exists_on_reload()\n  call writefile(['func ExistingFunction()', 'echo \"yes\"', 'endfunc'], 'Xfuncexists', 'D')\n  call assert_equal(0, exists('*ExistingFunction'))\n  source Xfuncexists\n  call assert_equal(1, '*ExistingFunction'->exists())\n  \" Redefining a function when reloading a script is OK.\n  source Xfuncexists\n  call assert_equal(1, exists('*ExistingFunction'))\n\n  \" But redefining in another script is not OK.\n  call writefile(['func ExistingFunction()', 'echo \"yes\"', 'endfunc'], 'Xfuncexists2', 'D')\n  call assert_fails('source Xfuncexists2', 'E122:')\n\n  \" Defining a new function from the cmdline should fail if the function is\n  \" already defined\n  call assert_fails('call feedkeys(\":func ExistingFunction()\\<CR>\", \"xt\")', 'E122:')\n\n  delfunc ExistingFunction\n  call assert_equal(0, exists('*ExistingFunction'))\n  call writefile([\n\t\\ 'func ExistingFunction()', 'echo \"yes\"', 'endfunc',\n\t\\ 'func ExistingFunction()', 'echo \"no\"', 'endfunc',\n\t\\ ], 'Xfuncexists')\n  call assert_fails('source Xfuncexists', 'E122:')\n  call assert_equal(1, exists('*ExistingFunction'))\n\n  delfunc ExistingFunction\nendfunc\n\n\" Test confirm({msg} [, {choices} [, {default} [, {type}]]])\nfunc Test_confirm()\n  CheckUnix\n  CheckNotGui\n\n  call feedkeys('o', 'L')\n  let a = confirm('Press O to proceed')\n  call assert_equal(1, a)\n\n  call feedkeys('y', 'L')\n  let a = 'Are you sure?'->confirm(\"&Yes\\n&No\")\n  call assert_equal(1, a)\n\n  call feedkeys('n', 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(2, a)\n\n  \" confirm() should return 0 when pressing CTRL-C.\n  call feedkeys(\"\\<C-C>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(0, a)\n\n  \" <Esc> requires another character to avoid it being seen as the start of an\n  \" escape sequence.  Zero should be harmless.\n  eval \"\\<Esc>0\"->feedkeys('L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(0, a)\n\n  \" Default choice is returned when pressing <CR>.\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(1, a)\n\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\", 2)\n  call assert_equal(2, a)\n\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\", 0)\n  call assert_equal(0, a)\n\n  \" Test with the {type} 4th argument\n  for type in ['Error', 'Question', 'Info', 'Warning', 'Generic']\n    call feedkeys('y', 'L')\n    let a = confirm('Are you sure?', \"&Yes\\n&No\\n\", 1, type)\n    call assert_equal(1, a)\n  endfor\n\n  call assert_fails('call confirm([])', 'E730:')\n  call assert_fails('call confirm(\"Are you sure?\", [])', 'E730:')\n  call assert_fails('call confirm(\"Are you sure?\", \"&Yes\\n&No\\n\", [])', 'E745:')\n  call assert_fails('call confirm(\"Are you sure?\", \"&Yes\\n&No\\n\", 0, [])', 'E730:')\nendfunc\n\nfunc Test_platform_name()\n  \" The system matches at most only one name.\n  let names = ['amiga', 'bsd', 'hpux', 'linux', 'mac', 'qnx', 'sun', 'vms', 'win32', 'win32unix']\n  call assert_inrange(0, 1, len(filter(copy(names), 'has(v:val)')))\n\n  \" Is Unix?\n  call assert_equal(has('bsd'), has('bsd') && has('unix'))\n  call assert_equal(has('hpux'), has('hpux') && has('unix'))\n  call assert_equal(has('linux'), has('linux') && has('unix'))\n  call assert_equal(has('mac'), has('mac') && has('unix'))\n  call assert_equal(has('qnx'), has('qnx') && has('unix'))\n  call assert_equal(has('sun'), has('sun') && has('unix'))\n  call assert_equal(has('win32'), has('win32') && !has('unix'))\n  call assert_equal(has('win32unix'), has('win32unix') && has('unix'))\n\n  if has('unix') && executable('uname')\n    let uname = system('uname')\n    \" GNU userland on BSD kernels (e.g., GNU/kFreeBSD) don't have BSD defined\n    call assert_equal(uname =~? '\\%(GNU/k\\w\\+\\)\\@<!BSD\\|DragonFly', has('bsd'))\n    call assert_equal(uname =~? 'HP-UX', has('hpux'))\n    call assert_equal(uname =~? 'Linux', has('linux'))\n    call assert_equal(uname =~? 'Darwin', has('mac'))\n    call assert_equal(uname =~? 'QNX', has('qnx'))\n    call assert_equal(uname =~? 'SunOS', has('sun'))\n    call assert_equal(uname =~? 'CYGWIN\\|MSYS', has('win32unix'))\n  endif\nendfunc\n\nfunc Test_readdir()\n  call mkdir('Xreaddir', 'R')\n  call writefile([], 'Xreaddir/foo.txt')\n  call writefile([], 'Xreaddir/bar.txt')\n  call mkdir('Xreaddir/dir')\n\n  \" All results\n  let files = readdir('Xreaddir')\n  call assert_equal(['bar.txt', 'dir', 'foo.txt'], sort(files))\n\n  \" Only results containing \"f\"\n  let files = 'Xreaddir'->readdir({ x -> stridx(x, 'f') != -1 })\n  call assert_equal(['foo.txt'], sort(files))\n\n  \" Only .txt files\n  let files = readdir('Xreaddir', { x -> x =~ '.txt$' })\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Only .txt files with string\n  let files = readdir('Xreaddir', 'v:val =~ \".txt$\"')\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Limit to 1 result.\n  let l = []\n  let files = readdir('Xreaddir', {x -> len(add(l, x)) == 2 ? -1 : 1})\n  call assert_equal(1, len(files))\n\n  \" Nested readdir() must not crash\n  let files = readdir('Xreaddir', 'readdir(\"Xreaddir\", \"1\") != []')\n  call sort(files)->assert_equal(['bar.txt', 'dir', 'foo.txt'])\nendfunc\n\nfunc Test_readdirex()\n  call mkdir('Xexdir', 'R')\n  call writefile(['foo'], 'Xexdir/foo.txt')\n  call writefile(['barbar'], 'Xexdir/bar.txt')\n  call mkdir('Xexdir/dir')\n\n  \" All results\n  let files = readdirex('Xexdir')->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'dir', 'foo.txt'], sort(files))\n  let sizes = readdirex('Xexdir')->map({-> v:val.size})\n  call assert_equal([0, 4, 7], sort(sizes))\n\n  \" Only results containing \"f\"\n  let files = 'Xexdir'->readdirex({ e -> stridx(e.name, 'f') != -1 })\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['foo.txt'], sort(files))\n\n  \" Only .txt files\n  let files = readdirex('Xexdir', { e -> e.name =~ '.txt$' })\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Only .txt files with string\n  let files = readdirex('Xexdir', 'v:val.name =~ \".txt$\"')\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Limit to 1 result.\n  let l = []\n  let files = readdirex('Xexdir', {e -> len(add(l, e.name)) == 2 ? -1 : 1})\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(1, len(files))\n\n  \" Nested readdirex() must not crash\n  let files = readdirex('Xexdir', 'readdirex(\"Xexdir\", \"1\") != []')\n\t\t\t  \\ ->map({-> v:val.name})\n  call sort(files)->assert_equal(['bar.txt', 'dir', 'foo.txt'])\n\n  \" report broken link correctly\n  if has(\"unix\")\n    call writefile([], 'Xexdir/abc.txt')\n    call system(\"ln -s Xexdir/abc.txt Xexdir/link\")\n    call delete('Xexdir/abc.txt')\n    let files = readdirex('Xexdir', 'readdirex(\"Xexdir\", \"1\") != []')\n\t\t\t  \\ ->map({-> v:val.name .. '_' .. v:val.type})\n    call sort(files)->assert_equal(\n        \\ ['bar.txt_file', 'dir_dir', 'foo.txt_file', 'link_link'])\n  endif\n\n  call assert_fails('call readdirex(\"doesnotexist\")', 'E484:')\nendfunc\n\nfunc Test_readdirex_sort()\n  CheckUnix\n  \" Skip tests on Mac OS X and Cygwin (does not allow several files with different casing)\n  if has(\"osxdarwin\") || has(\"osx\") || has(\"macunix\") || has(\"win32unix\")\n    throw 'Skipped: Test_readdirex_sort on systems that do not allow this using the default filesystem'\n  endif\n  let _collate = v:collate\n  call mkdir('Xsortdir2', 'R')\n  call writefile(['1'], 'Xsortdir2/README.txt')\n  call writefile(['2'], 'Xsortdir2/Readme.txt')\n  call writefile(['3'], 'Xsortdir2/readme.txt')\n\n  \" 1) default\n  let files = readdirex('Xsortdir2')->map({-> v:val.name})\n  let default = copy(files)\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], files, 'sort using default')\n\n  \" 2) no sorting\n  let files = readdirex('Xsortdir2', 1, #{sort: 'none'})->map({-> v:val.name})\n  let unsorted = copy(files)\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], sort(files), 'unsorted')\n  call assert_fails(\"call readdirex('Xsortdir2', 1, #{slort: 'none'})\", 'E857: Dictionary key \"sort\" required')\n\n  \" 3) sort by case (same as default)\n  let files = readdirex('Xsortdir2', 1, #{sort: 'case'})->map({-> v:val.name})\n  call assert_equal(default, files, 'sort by case')\n\n  \" 4) sort by ignoring case\n  let files = readdirex('Xsortdir2', 1, #{sort: 'icase'})->map({-> v:val.name})\n  call assert_equal(unsorted->sort('i'), files, 'sort by icase')\n\n  \" 5) Default Collation\n  let collate = v:collate\n  lang collate C\n  let files = readdirex('Xsortdir2', 1, #{sort: 'collate'})->map({-> v:val.name})\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], files, 'sort by C collation')\n\n  \" 6) Collation de_DE\n  \" Switch locale, this may not work on the CI system, if the locale isn't\n  \" available\n  try\n    lang collate de_DE\n    let files = readdirex('Xsortdir2', 1, #{sort: 'collate'})->map({-> v:val.name})\n    call assert_equal(['readme.txt', 'Readme.txt', 'README.txt'], files, 'sort by de_DE collation')\n  catch\n    throw 'Skipped: de_DE collation is not available'\n\n  finally\n    exe 'lang collate' collate\n  endtry\nendfunc\n\nfunc Test_readdir_sort()\n  \" some more cases for testing sorting for readdirex\n  let dir = 'Xsortdir3'\n  call mkdir(dir, 'R')\n  call writefile(['1'], dir .. '/README.txt')\n  call writefile(['2'], dir .. '/Readm.txt')\n  call writefile(['3'], dir .. '/read.txt')\n  call writefile(['4'], dir .. '/Z.txt')\n  call writefile(['5'], dir .. '/a.txt')\n  call writefile(['6'], dir .. '/b.txt')\n\n  \" 1) default\n  let files = readdir(dir)\n  let default = copy(files)\n  call assert_equal(default->sort(), files, 'sort using default')\n\n  \" 2) sort by case (same as default)\n  let files = readdir(dir, '1', #{sort: 'case'})\n  call assert_equal(default, files, 'sort using default')\n\n  \" 3) sort by ignoring case\n  let files = readdir(dir, '1', #{sort: 'icase'})\n  call assert_equal(default->sort('i'), files, 'sort by ignoring case')\n\n  \" 4) collation\n  let collate = v:collate\n  lang collate C\n  let files = readdir(dir, 1, #{sort: 'collate'})\n  call assert_equal(default->sort(), files, 'sort by C collation')\n  exe \"lang collate\" collate\n\n  \" 5) Errors\n  call assert_fails('call readdir(dir, 1, 1)', 'E1206:')\n  call assert_fails('call readdir(dir, 1, #{sorta: 1})')\n  call assert_fails('call readdir(dir, 1, test_null_dict())', 'E1297:')\n  call assert_fails('call readdirex(dir, 1, 1)', 'E1206:')\n  call assert_fails('call readdirex(dir, 1, #{sorta: 1})')\n  call assert_fails('call readdirex(dir, 1, test_null_dict())', 'E1297:')\n\n  \" 6) ignore other values in dict\n  let files = readdir(dir, '1', #{sort: 'c'})\n  call assert_equal(default, files, 'sort using default2')\n\n  \" Cleanup\n  exe \"lang collate\" collate\nendfunc\n\nfunc Test_delete_rf()\n  call mkdir('Xrfdir')\n  call writefile([], 'Xrfdir/foo.txt')\n  call writefile([], 'Xrfdir/bar.txt')\n  call mkdir('Xrfdir/[a-1]')  \" issue #696\n  call writefile([], 'Xrfdir/[a-1]/foo.txt')\n  call writefile([], 'Xrfdir/[a-1]/bar.txt')\n  call assert_true(filereadable('Xrfdir/foo.txt'))\n  call assert_true('Xrfdir/[a-1]/foo.txt'->filereadable())\n\n  call assert_equal(0, delete('Xrfdir', 'rf'))\n  call assert_false(filereadable('Xrfdir/foo.txt'))\n  call assert_false(filereadable('Xrfdir/[a-1]/foo.txt'))\n\n  if has('unix')\n    call mkdir('Xrfdir/Xdir2', 'p')\n    silent !chmod 555 Xrfdir\n    call assert_equal(-1, delete('Xrfdir/Xdir2', 'rf'))\n    call assert_equal(-1, delete('Xrfdir', 'rf'))\n    silent !chmod 755 Xrfdir\n    call assert_equal(0, delete('Xrfdir', 'rf'))\n  endif\nendfunc\n\nfunc Test_call()\n  call assert_equal(3, call('len', [123]))\n  call assert_equal(3, 'len'->call([123]))\n  call assert_fails(\"call call('len', 123)\", 'E1211:')\n  call assert_equal(0, call('', []))\n  call assert_equal(0, call('len', test_null_list()))\n\n  function Mylen() dict\n     return len(self.data)\n  endfunction\n  let mydict = {'data': [0, 1, 2, 3], 'len': function(\"Mylen\")}\n  eval mydict.len->call([], mydict)->assert_equal(4)\n  call assert_fails(\"call call('Mylen', [], 0)\", 'E1206:')\n  call assert_fails('call foo', 'E107:')\n\n  \" These once caused a crash.\n  call call(test_null_function(), [])\n  call call(test_null_partial(), [])\n  call assert_fails('call test_null_function()()', 'E1192:')\n  call assert_fails('call test_null_partial()()', 'E117:')\n\n  let lines =<< trim END\n      let Time = 'localtime'\n      call Time()\n  END\n  call v9.CheckScriptFailure(lines, 'E1085:')\nendfunc\n\nfunc Test_char2nr()\n  call assert_equal(12354, char2nr('\u3042', 1))\n  call assert_equal(120, 'x'->char2nr())\n  set encoding=latin1\n  call assert_equal(120, 'x'->char2nr())\n  set encoding=utf-8\nendfunc\n\nfunc Test_charclass()\n  call assert_equal(0, charclass(' '))\n  call assert_equal(1, charclass('.'))\n  call assert_equal(2, charclass('x'))\n  call assert_equal(3, charclass(\"\\u203c\"))\n  \" this used to crash vim\n  call assert_equal(0, \"xxx\"[-1]->charclass())\nendfunc\n\nfunc Test_eventhandler()\n  call assert_equal(0, eventhandler())\nendfunc\n\nfunc Test_bufadd_bufload()\n  call assert_equal(0, bufexists('someName'))\n  let buf = bufadd('someName')\n  call assert_notequal(0, buf)\n  call assert_equal(1, bufexists('someName'))\n  call assert_equal(0, getbufvar(buf, '&buflisted'))\n  call assert_equal(0, bufloaded(buf))\n  call bufload(buf)\n  call assert_equal(1, bufloaded(buf))\n  call assert_equal([''], getbufline(buf, 1, '$'))\n\n  let curbuf = bufnr('')\n  eval ['some', 'text']->writefile('XotherName')\n  let buf = 'XotherName'->bufadd()\n  call assert_notequal(0, buf)\n  eval 'XotherName'->bufexists()->assert_equal(1)\n  call assert_equal(0, getbufvar(buf, '&buflisted'))\n  call assert_equal(0, bufloaded(buf))\n  eval buf->bufload()\n  call assert_equal(1, bufloaded(buf))\n  call assert_equal(['some', 'text'], getbufline(buf, 1, '$'))\n  call assert_equal(curbuf, bufnr(''))\n\n  let buf1 = bufadd('')\n  let buf2 = bufadd('')\n  call assert_notequal(0, buf1)\n  call assert_notequal(0, buf2)\n  call assert_notequal(buf1, buf2)\n  call assert_equal(1, bufexists(buf1))\n  call assert_equal(1, bufexists(buf2))\n  call assert_equal(0, bufloaded(buf1))\n  exe 'bwipe ' .. buf1\n  call assert_equal(0, bufexists(buf1))\n  call assert_equal(1, bufexists(buf2))\n  exe 'bwipe ' .. buf2\n  call assert_equal(0, bufexists(buf2))\n\n  \" When 'buftype' is \"nofile\" then bufload() does not read the file.\n  \" Other values too.\n  for val in [['nofile', 0],\n            \\ ['nowrite', 1],\n            \\ ['acwrite', 1],\n            \\ ['quickfix', 0],\n            \\ ['help', 1],\n            \\ ['terminal', 0],\n            \\ ['prompt', 0],\n            \\ ['popup', 0],\n            \\ ]\n    bwipe! XotherName\n    let buf = bufadd('XotherName')\n    call setbufvar(buf, '&bt', val[0])\n    call bufload(buf)\n    call assert_equal(val[1] ? ['some', 'text'] : [''], getbufline(buf, 1, '$'), val[0])\n  endfor\n\n  bwipe someName\n  bwipe XotherName\n  call assert_equal(0, bufexists('someName'))\n  call delete('XotherName')\nendfunc\n\nfunc Test_state()\n  CheckRunVimInTerminal\n\n  let getstate = \":echo 'state: ' .. g:state .. '; mode: ' .. g:mode\\<CR>\"\n\n  let lines =<< trim END\n\tcall setline(1, ['one', 'two', 'three'])\n\tmap ;; gg\n\tset complete=.\n\tfunc RunTimer()\n\t  call timer_start(10, {id -> execute('let g:state = state()') .. execute('let g:mode = mode()')})\n\tendfunc\n\tau Filetype foobar let g:state = state()|let g:mode = mode()\n  END\n  call writefile(lines, 'XState')\n  let buf = RunVimInTerminal('-S XState', #{rows: 6})\n\n  \" Using a \":\" command Vim is busy, thus \"S\" is returned\n  call term_sendkeys(buf, \":echo 'state: ' .. state() .. '; mode: ' .. mode()\\<CR>\")\n  call WaitForAssert({-> assert_match('state: S; mode: n', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":\\<CR>\")\n\n  \" Using a timer callback\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: c; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Halfway a mapping\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>;\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \";\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: mSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" A operator is pending\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>y\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"y\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: oSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" A register was specified\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>\\\"r\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"yy\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: oSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Insert mode completion (bit slower on Mac)\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>Got\\<C-N>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: aSc; mode: i', term_getline(buf, 6))}, 1000)\n\n  \" Autocommand executing\n  call term_sendkeys(buf, \":set filetype=foobar\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: xS; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Todo: \"w\" - waiting for ch_evalexpr()\n\n  \" messages scrolled\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>:echo \\\"one\\\\ntwo\\\\nthree\\\"\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"\\<CR>\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: Scs; mode: r', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XState')\nendfunc\n\nfunc Test_range()\n  \" destructuring\n  let [x, y] = range(2)\n  call assert_equal([0, 1], [x, y])\n\n  \" index\n  call assert_equal(4, range(1, 10)[3])\n\n  \" add()\n  call assert_equal([0, 1, 2, 3], add(range(3), 3))\n  call assert_equal([0, 1, 2, [0, 1, 2]], add([0, 1, 2], range(3)))\n  call assert_equal([0, 1, 2, [0, 1, 2]], add(range(3), range(3)))\n\n  \" append()\n  new\n  call append('.', range(5))\n  call assert_equal(['', '0', '1', '2', '3', '4'], getline(1, '$'))\n  bwipe!\n\n  \" appendbufline()\n  new\n  call appendbufline(bufnr(''), '.', range(5))\n  call assert_equal(['0', '1', '2', '3', '4', ''], getline(1, '$'))\n  bwipe!\n\n  \" call()\n  func TwoArgs(a, b)\n    return [a:a, a:b]\n  endfunc\n  call assert_equal([0, 1], call('TwoArgs', range(2)))\n\n  \" col()\n  new\n  call setline(1, ['foo', 'bar'])\n  call assert_equal(2, col(range(1, 2)))\n  bwipe!\n\n  \" complete()\n  execute \"normal! a\\<C-r>=[complete(col('.'), range(10)), ''][1]\\<CR>\"\n  \" complete_info()\n  execute \"normal! a\\<C-r>=[complete(col('.'), range(10)), ''][1]\\<CR>\\<C-r>=[complete_info(range(5)), ''][1]\\<CR>\"\n\n  \" copy()\n  call assert_equal([1, 2, 3], copy(range(1, 3)))\n\n  \" count()\n  call assert_equal(0, count(range(0), 3))\n  call assert_equal(0, count(range(2), 3))\n  call assert_equal(1, count(range(5), 3))\n\n  \" cursor()\n  new\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  call cursor(range(1, 2))\n  call assert_equal([2, 1], [col('.'), line('.')])\n  bwipe!\n\n  \" deepcopy()\n  call assert_equal([1, 2, 3], deepcopy(range(1, 3)))\n\n  \" empty()\n  call assert_true(empty(range(0)))\n  call assert_false(empty(range(2)))\n\n  \" execute()\n  new\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  call execute(range(3))\n  call assert_equal(2, line('.'))\n  bwipe!\n\n  \" extend()\n  call assert_equal([1, 2, 3, 4], extend([1], range(2, 4)))\n  call assert_equal([1, 2, 3, 4], extend(range(1, 1), range(2, 4)))\n  call assert_equal([1, 2, 3, 4], extend(range(1, 1), [2, 3, 4]))\n\n  \" filter()\n  call assert_equal([1, 3], filter(range(5), 'v:val % 2'))\n  call assert_equal([1, 5, 7, 11, 13], filter(filter(range(15), 'v:val % 2'), 'v:val % 3'))\n\n  \" funcref()\n  call assert_equal([0, 1], funcref('TwoArgs', range(2))())\n\n  \" function()\n  call assert_equal([0, 1], function('TwoArgs', range(2))())\n\n  \" garbagecollect()\n  let thelist = [1, range(2), 3]\n  let otherlist = range(3)\n  call test_garbagecollect_now()\n\n  \" get()\n  call assert_equal(4, get(range(1, 10), 3))\n  call assert_equal(-1, get(range(1, 10), 42, -1))\n\n  \" index()\n  call assert_equal(1, index(range(1, 5), 2))\n  call assert_fails(\"echo index([1, 2], 1, [])\", 'E745:')\n\n  \" insert()\n  call assert_equal([42, 1, 2, 3, 4, 5], insert(range(1, 5), 42))\n  call assert_equal([42, 1, 2, 3, 4, 5], insert(range(1, 5), 42, 0))\n  call assert_equal([1, 42, 2, 3, 4, 5], insert(range(1, 5), 42, 1))\n  call assert_equal([1, 2, 3, 4, 42, 5], insert(range(1, 5), 42, 4))\n  call assert_equal([1, 2, 3, 4, 42, 5], insert(range(1, 5), 42, -1))\n  call assert_equal([1, 2, 3, 4, 5, 42], insert(range(1, 5), 42, 5))\n\n  \" join()\n  call assert_equal('0 1 2 3 4', join(range(5)))\n\n  \" json_encode()\n  call assert_equal('[0,1,2,3]', json_encode(range(4)))\n\n  \" len()\n  call assert_equal(0, len(range(0)))\n  call assert_equal(2, len(range(2)))\n  call assert_equal(5, len(range(0, 12, 3)))\n  call assert_equal(4, len(range(3, 0, -1)))\n\n  \" list2str()\n  call assert_equal('ABC', list2str(range(65, 67)))\n  call assert_fails('let s = list2str(5)', 'E1211:')\n\n  \" lock()\n  let thelist = range(5)\n  lockvar thelist\n\n  \" map()\n  call assert_equal([0, 2, 4, 6, 8], map(range(5), 'v:val * 2'))\n  call assert_equal([3, 5, 7, 9, 11], map(map(range(5), 'v:val * 2'), 'v:val + 3'))\n  call assert_equal([2, 6], map(filter(range(5), 'v:val % 2'), 'v:val * 2'))\n  call assert_equal([2, 4, 8], filter(map(range(5), 'v:val * 2'), 'v:val % 3'))\n\n  \" match()\n  call assert_equal(3, match(range(5), 3))\n\n  \" matchaddpos()\n  highlight MyGreenGroup ctermbg=green guibg=green\n  call matchaddpos('MyGreenGroup', range(line('.'), line('.')))\n\n  \" matchend()\n  call assert_equal(4, matchend(range(5), '4'))\n  call assert_equal(3, matchend(range(1, 5), '4'))\n  call assert_equal(-1, matchend(range(1, 5), '42'))\n\n  \" matchstrpos()\n  call assert_equal(['4', 4, 0, 1], matchstrpos(range(5), '4'))\n  call assert_equal(['4', 3, 0, 1], matchstrpos(range(1, 5), '4'))\n  call assert_equal(['', -1, -1, -1], matchstrpos(range(1, 5), '42'))\n\n  \" max() reverse()\n  call assert_equal(0, max(range(0)))\n  call assert_equal(0, max(range(10, 9)))\n  call assert_equal(9, max(range(10)))\n  call assert_equal(18, max(range(0, 20, 3)))\n  call assert_equal(20, max(range(20, 0, -3)))\n  call assert_equal(99999, max(range(100000)))\n  call assert_equal(99999, max(range(99999, 0, -1)))\n  call assert_equal(99999, max(reverse(range(100000))))\n  call assert_equal(99999, max(reverse(range(99999, 0, -1))))\n\n  \" min() reverse()\n  call assert_equal(0, min(range(0)))\n  call assert_equal(0, min(range(10, 9)))\n  call assert_equal(5, min(range(5, 10)))\n  call assert_equal(5, min(range(5, 10, 3)))\n  call assert_equal(2, min(range(20, 0, -3)))\n  call assert_equal(0, min(range(100000)))\n  call assert_equal(0, min(range(99999, 0, -1)))\n  call assert_equal(0, min(reverse(range(100000))))\n  call assert_equal(0, min(reverse(range(99999, 0, -1))))\n\n  \" remove()\n  call assert_equal(1, remove(range(1, 10), 0))\n  call assert_equal(2, remove(range(1, 10), 1))\n  call assert_equal(9, remove(range(1, 10), 8))\n  call assert_equal(10, remove(range(1, 10), 9))\n  call assert_equal(10, remove(range(1, 10), -1))\n  call assert_equal([3, 4, 5], remove(range(1, 10), 2, 4))\n\n  \" repeat()\n  call assert_equal([0, 1, 2, 0, 1, 2], repeat(range(3), 2))\n  call assert_equal([0, 1, 2], repeat(range(3), 1))\n  call assert_equal([], repeat(range(3), 0))\n  call assert_equal([], repeat(range(5, 4), 2))\n  call assert_equal([], repeat(range(5, 4), 0))\n\n  \" reverse()\n  call assert_equal([2, 1, 0], reverse(range(3)))\n  call assert_equal([0, 1, 2, 3], reverse(range(3, 0, -1)))\n  call assert_equal([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], reverse(range(10)))\n  call assert_equal([20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10], reverse(range(10, 20)))\n  call assert_equal([16, 13, 10], reverse(range(10, 18, 3)))\n  call assert_equal([19, 16, 13, 10], reverse(range(10, 19, 3)))\n  call assert_equal([19, 16, 13, 10], reverse(range(10, 20, 3)))\n  call assert_equal([11, 14, 17, 20], reverse(range(20, 10, -3)))\n  call assert_equal([], reverse(range(0)))\n\n  \" TODO: setpos()\n  \" new\n  \" call setline(1, repeat([''], bufnr('')))\n  \" call setline(bufnr('') + 1, repeat('x', bufnr('') * 2 + 6))\n  \" call setpos('x', range(bufnr(''), bufnr('') + 3))\n  \" bwipe!\n\n  \" setreg()\n  call setreg('a', range(3))\n  call assert_equal(\"0\\n1\\n2\\n\", getreg('a'))\n\n  \" settagstack()\n  call settagstack(1, #{items : range(4)})\n\n  \" sign_define()\n  call assert_fails(\"call sign_define(range(5))\", \"E715:\")\n  call assert_fails(\"call sign_placelist(range(5))\", \"E715:\")\n\n  \" sign_undefine()\n  call assert_fails(\"call sign_undefine(range(5))\", \"E908:\")\n\n  \" sign_unplacelist()\n  call assert_fails(\"call sign_unplacelist(range(5))\", \"E715:\")\n\n  \" sort()\n  call assert_equal([0, 1, 2, 3, 4, 5], sort(range(5, 0, -1)))\n\n  \" string()\n  call assert_equal('[0, 1, 2, 3, 4]', string(range(5)))\n\n  \" taglist() with 'tagfunc'\n  func TagFunc(pattern, flags, info)\n    return range(10)\n  endfunc\n  set tagfunc=TagFunc\n  call assert_fails(\"call taglist('asdf')\", 'E987:')\n  set tagfunc=\n\n  \" term_start()\n  if has('terminal') && has('termguicolors')\n    call assert_fails('call term_start(range(3, 4))', 'E474:')\n    let g:terminal_ansi_colors = range(16)\n    if has('win32')\n      let cmd = \"cmd /c dir\"\n    else\n      let cmd = \"ls\"\n    endif\n    call assert_fails('call term_start(\"' .. cmd .. '\", #{term_finish: \"close\"'\n        \\ .. ', ansi_colors: range(16)})', 'E475:')\n    unlet g:terminal_ansi_colors\n  endif\n\n  \" type()\n  call assert_equal(v:t_list, type(range(5)))\n\n  \" uniq()\n  call assert_equal([0, 1, 2, 3, 4], uniq(range(5)))\n\n  \" errors\n  call assert_fails('let x=range(2, 8, 0)', 'E726:')\n  call assert_fails('let x=range(3, 1)', 'E727:')\n  call assert_fails('let x=range(1, 3, -2)', 'E727:')\n  call assert_fails('let x=range([])', 'E745:')\n  call assert_fails('let x=range(1, [])', 'E745:')\n  call assert_fails('let x=range(1, 4, [])', 'E745:')\nendfunc\n\nfunc Test_garbagecollect_now_fails()\n  let v:testing = 0\n  call assert_fails('call test_garbagecollect_now()', 'E1142:')\n  let v:testing = 1\nendfunc\n\nfunc Test_echoraw()\n  CheckScreendump\n\n  \" Normally used for escape codes, but let's test with a CR.\n  let lines =<< trim END\n    call echoraw(\"hello\\<CR>x\")\n  END\n  call writefile(lines, 'XTest_echoraw')\n  let buf = RunVimInTerminal('-S XTest_echoraw', {'rows': 5, 'cols': 40})\n  call VerifyScreenDump(buf, 'Test_functions_echoraw', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_echoraw')\nendfunc\n\n\" Test for echo highlighting\nfunc Test_echohl()\n  echohl Search\n  echo 'Vim'\n  call assert_equal('Vim', Screenline(&lines))\n  \" TODO: How to check the highlight group used by echohl?\n  \" ScreenAttrs() returns all zeros.\n  echohl None\nendfunc\n\n\" Test for the eval() function\nfunc Test_eval()\n  call assert_fails(\"call eval('5 a')\", 'E488:')\nendfunc\n\n\" Test for the keytrans() function\nfunc Test_keytrans()\n  call assert_equal('<Space>', keytrans(' '))\n  call assert_equal('<lt>', keytrans('<'))\n  call assert_equal('<lt>Tab>', keytrans('<Tab>'))\n  call assert_equal('<Tab>', keytrans(\"\\<Tab>\"))\n  call assert_equal('<C-V>', keytrans(\"\\<C-V>\"))\n  call assert_equal('<BS>', keytrans(\"\\<BS>\"))\n  call assert_equal('<Home>', keytrans(\"\\<Home>\"))\n  call assert_equal('<C-Home>', keytrans(\"\\<C-Home>\"))\n  call assert_equal('<M-Home>', keytrans(\"\\<M-Home>\"))\n  call assert_equal('<C-Space>', keytrans(\"\\<C-Space>\"))\n  call assert_equal('<M-Space>', keytrans(\"\\<*M-Space>\"))\n  call assert_equal('<M-x>', \"\\<*M-x>\"->keytrans())\n  call assert_equal('<C-I>', \"\\<*C-I>\"->keytrans())\n  call assert_equal('<S-3>', \"\\<*S-3>\"->keytrans())\n  call assert_equal('\u03c0', '\u03c0'->keytrans())\n  call assert_equal('<M-\u03c0>', \"\\<M-\u03c0>\"->keytrans())\n  call assert_equal('\u011b', '\u011b'->keytrans())\n  call assert_equal('<M-\u011b>', \"\\<M-\u011b>\"->keytrans())\n  call assert_equal('', ''->keytrans())\n  call assert_equal('', test_null_string()->keytrans())\n  call assert_fails('call keytrans(1)', 'E1174:')\n  call assert_fails('call keytrans()', 'E119:')\nendfunc\n\n\" Test for the nr2char() function\nfunc Test_nr2char()\n  set encoding=latin1\n  call assert_equal('@', nr2char(64))\n  set encoding=utf8\n  call assert_equal('a', nr2char(97, 1))\n  call assert_equal('a', nr2char(97, 0))\n\n  call assert_equal(\"\\x80\\xfc\\b\" .. nr2char(0x100000), eval('\"\\<M-' .. nr2char(0x100000) .. '>\"'))\n  call assert_equal(\"\\x80\\xfc\\b\" .. nr2char(0x40000000), eval('\"\\<M-' .. nr2char(0x40000000) .. '>\"'))\nendfunc\n\n\" Test for screenattr(), screenchar() and screenchars() functions\nfunc Test_screen_functions()\n  call assert_equal(-1, screenattr(-1, -1))\n  call assert_equal(-1, screenchar(-1, -1))\n  call assert_equal([], screenchars(-1, -1))\n\n  \" Run this in a separate Vim instance to avoid messing up.\n  let after =<< trim [CODE]\n    scriptencoding utf-8\n    call setline(1, '\u53e3')\n    redraw\n    call assert_equal(0, screenattr(1, 1))\n    call assert_equal(char2nr('\u53e3'), screenchar(1, 1))\n    call assert_equal([char2nr('\u53e3')], screenchars(1, 1))\n    call assert_equal('\u53e3', screenstring(1, 1))\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [CODE]\n\n  let encodings = ['utf-8', 'cp932', 'cp936', 'cp949', 'cp950']\n  if !has('win32')\n    let encodings += ['euc-jp']\n  endif\n  for enc in encodings\n    let msg = 'enc=' .. enc\n    if RunVim([], after, $'--clean --cmd \"set encoding={enc}\"')\n      call assert_equal([], readfile('Xresult'), msg)\n    endif\n    call delete('Xresult')\n  endfor\nendfunc\n\n\" Test for getcurpos() and setpos()\nfunc Test_getcurpos_setpos()\n  new\n  call setline(1, ['012345678', '012345678'])\n  normal gg6l\n  let sp = getcurpos()\n  normal 0\n  call setpos('.', sp)\n  normal jyl\n  call assert_equal('6', @\")\n  call assert_equal(-1, setpos('.', test_null_list()))\n  call assert_equal(-1, setpos('.', {}))\n\n  let winid = win_getid()\n  normal G$\n  let pos = getcurpos()\n  wincmd w\n  call assert_equal(pos, getcurpos(winid))\n\n  wincmd w\n  close!\n\n  call assert_equal(getcurpos(), getcurpos(0))\n  call assert_equal([0, 0, 0, 0, 0], getcurpos(-1))\n  call assert_equal([0, 0, 0, 0, 0], getcurpos(1999))\nendfunc\n\nfunc Test_getmousepos()\n  enew!\n  call setline(1, \"\\t\\t\\t1234\")\n  call test_setmouse(1, 1)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 1,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 1,\n        \\ line: 1,\n        \\ column: 1,\n        \\ }, getmousepos())\n  call test_setmouse(1, 25)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 25,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 25,\n        \\ line: 1,\n        \\ column: 4,\n        \\ }, getmousepos())\n  call test_setmouse(1, 50)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 50,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 50,\n        \\ line: 1,\n        \\ column: 8,\n        \\ }, getmousepos())\n\n  \" If the mouse is positioned past the last buffer line, \"line\" and \"column\"\n  \" should act like it's positioned on the last buffer line.\n  call test_setmouse(2, 25)\n  call assert_equal(#{\n        \\ screenrow: 2,\n        \\ screencol: 25,\n        \\ winid: win_getid(),\n        \\ winrow: 2,\n        \\ wincol: 25,\n        \\ line: 1,\n        \\ column: 4,\n        \\ }, getmousepos())\n  call test_setmouse(2, 50)\n  call assert_equal(#{\n        \\ screenrow: 2,\n        \\ screencol: 50,\n        \\ winid: win_getid(),\n        \\ winrow: 2,\n        \\ wincol: 50,\n        \\ line: 1,\n        \\ column: 8,\n        \\ }, getmousepos())\n  bwipe!\nendfunc\n\nfunc Test_getmouseshape()\n  CheckFeature mouseshape\n\n  call assert_equal('arrow', getmouseshape())\nendfunc\n\n\" Test for glob()\nfunc Test_glob()\n  call assert_equal('', glob(test_null_string()))\n  call assert_equal('', globpath(test_null_string(), test_null_string()))\n  call assert_fails(\"let x = globpath(&rtp, 'syntax/c.vim', [])\", 'E745:')\n\n  call writefile([], 'Xglob1')\n  call writefile([], 'XGLOB2')\n  set wildignorecase\n  \" Sort output of glob() otherwise we end up with different\n  \" ordering depending on whether file system is case-sensitive.\n  call assert_equal(['XGLOB2', 'Xglob1'], sort(glob('Xglob[12]', 0, 1)))\n  \" wildignorecase shall be applied even when the pattern contains no wildcards.\n  call assert_equal('XGLOB2', glob('xglob2'))\n  set wildignorecase&\n\n  call delete('Xglob1')\n  call delete('XGLOB2')\n\n  call assert_fails(\"call glob('*', 0, {})\", 'E728:')\nendfunc\n\n\" Test for browse()\nfunc Test_browse()\n  CheckFeature browse\n  call assert_fails('call browse([], \"open\", \"x\", \"a.c\")', 'E745:')\nendfunc\n\n\" Test for browsedir()\nfunc Test_browsedir()\n  CheckFeature browse\n  call assert_fails('call browsedir(\"open\", [])', 'E730:')\nendfunc\n\nfunc HasDefault(msg = 'msg')\n  return a:msg\nendfunc\n\nfunc Test_default_arg_value()\n  call assert_equal('msg', HasDefault())\nendfunc\n\n\" Test for gettext()\nfunc Test_gettext()\n  call assert_fails('call gettext(1)', 'E1174:')\nendfunc\n\nfunc Test_builtin_check()\n  call assert_fails('let g:[\"trim\"] = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let g:.trim = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let l:[\"trim\"] = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let l:.trim = {x -> \" \" .. x}', 'E704:')\n  let lines =<< trim END\n    vim9script\n    var trim = (x) => \" \" .. x\n  END\n  call v9.CheckScriptFailure(lines, 'E704:')\n\n  call assert_fails('call extend(g:, #{foo: { -> \"foo\" }})', 'E704:')\n  let g:bar = 123\n  call extend(g:, #{bar: { -> \"foo\" }}, \"keep\")\n  call assert_fails('call extend(g:, #{bar: { -> \"foo\" }}, \"force\")', 'E704:')\n  unlet g:bar\n\n  call assert_fails('call extend(l:, #{foo: { -> \"foo\" }})', 'E704:')\n  let bar = 123\n  call extend(l:, #{bar: { -> \"foo\" }}, \"keep\")\n  call assert_fails('call extend(l:, #{bar: { -> \"foo\" }}, \"force\")', 'E704:')\n  unlet bar\n\n  call assert_fails('call extend(g:, #{foo: function(\"extend\")})', 'E704:')\n  let g:bar = 123\n  call extend(g:, #{bar: function(\"extend\")}, \"keep\")\n  call assert_fails('call extend(g:, #{bar: function(\"extend\")}, \"force\")', 'E704:')\n  unlet g:bar\n\n  call assert_fails('call extend(l:, #{foo: function(\"extend\")})', 'E704:')\n  let bar = 123\n  call extend(l:, #{bar: function(\"extend\")}, \"keep\")\n  call assert_fails('call extend(l:, #{bar: function(\"extend\")}, \"force\")', 'E704:')\n  unlet bar\nendfunc\n\nfunc Test_funcref_to_string()\n  let Fn = funcref('g:Test_funcref_to_string')\n  call assert_equal(\"function('g:Test_funcref_to_string')\", string(Fn))\nendfunc\n\n\" Test for isabsolutepath()\nfunc Test_isabsolutepath()\n  call assert_false(isabsolutepath(''))\n  call assert_false(isabsolutepath('.'))\n  call assert_false(isabsolutepath('../Foo'))\n  call assert_false(isabsolutepath('Foo/'))\n  if has('win32')\n    call assert_true(isabsolutepath('A:\\'))\n    call assert_true(isabsolutepath('A:\\Foo'))\n    call assert_true(isabsolutepath('A:/Foo'))\n    call assert_false(isabsolutepath('A:Foo'))\n    call assert_false(isabsolutepath('\\Windows'))\n    call assert_true(isabsolutepath('\\\\Server2\\Share\\Test\\Foo.txt'))\n  else\n    call assert_true(isabsolutepath('/'))\n    call assert_true(isabsolutepath('/usr/share/'))\n  endif\nendfunc\n\n\" Test for exepath()\nfunc Test_exepath()\n  if has('win32')\n    call assert_notequal(exepath('cmd'), '')\n\n    let oldNoDefaultCurrentDirectoryInExePath = $NoDefaultCurrentDirectoryInExePath\n    call writefile(['@echo off', 'echo Evil'], 'vim-test-evil.bat')\n    let $NoDefaultCurrentDirectoryInExePath = ''\n    call assert_notequal(exepath(\"vim-test-evil.bat\"), '')\n    let $NoDefaultCurrentDirectoryInExePath = '1'\n    call assert_equal(exepath(\"vim-test-evil.bat\"), '')\n    let $NoDefaultCurrentDirectoryInExePath = oldNoDefaultCurrentDirectoryInExePath\n    call delete('vim-test-evil.bat')\n  else\n    call assert_notequal(exepath('sh'), '')\n  endif\nendfunc\n\n\" Test for virtcol()\nfunc Test_virtcol()\n  new\n  call setline(1, \"the\\tquick\\tbrown\\tfox\")\n  norm! 4|\n  call assert_equal(8, virtcol('.'))\n  call assert_equal(8, virtcol('.', v:false))\n  call assert_equal([4, 8], virtcol('.', v:true))\n\n  let w = winwidth(0)\n  call setline(2, repeat('a', w + 2))\n  let win_nosbr = win_getid()\n  split\n  setlocal showbreak=!!\n  let win_sbr = win_getid()\n  call assert_equal([w, w], virtcol([2, w], v:true, win_nosbr))\n  call assert_equal([w + 1, w + 1], virtcol([2, w + 1], v:true, win_nosbr))\n  call assert_equal([w + 2, w + 2], virtcol([2, w + 2], v:true, win_nosbr))\n  call assert_equal([w, w], virtcol([2, w], v:true, win_sbr))\n  call assert_equal([w + 3, w + 3], virtcol([2, w + 1], v:true, win_sbr))\n  call assert_equal([w + 4, w + 4], virtcol([2, w + 2], v:true, win_sbr))\n  close\n\n  call assert_equal(0, virtcol(''))\n  call assert_equal([0, 0], virtcol('', v:true))\n  call assert_equal(0, virtcol('.', v:false, 5001))\n  call assert_equal([0, 0], virtcol('.', v:true, 5001))\n\n  bwipe!\nendfunc\n\nfunc Test_delfunc_while_listing()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      set nocompatible\n      for i in range(1, 999)\n        exe 'func ' .. 'MyFunc' .. i .. '()'\n        endfunc\n      endfor\n      au CmdlineLeave : call timer_start(0, {-> execute('delfunc MyFunc622')})\n  END\n  call writefile(lines, 'Xfunctionclear', 'D')\n  let buf = RunVimInTerminal('-S Xfunctionclear', {'rows': 12})\n\n  \" This was using freed memory.  The height of the terminal must be so that\n  \" the next function to be listed with \"j\" is the one that is deleted in the\n  \" timer callback, tricky!\n  call term_sendkeys(buf, \":func /MyFunc\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"j\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"\\<CR>\")\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for the reverse() function with a string\nfunc Test_string_reverse()\n  let lines =<< trim END\n    call assert_equal('', reverse(test_null_string()))\n    for [s1, s2] in [['', ''], ['a', 'a'], ['ab', 'ba'], ['abc', 'cba'],\n                   \\ ['abcd', 'dcba'], ['\u00ab-\u00ab-\u00bb-\u00bb', '\u00bb-\u00bb-\u00ab-\u00ab'],\n                   \\ ['\ud83c\udde6', '\ud83c\udde6'], ['\ud83c\udde6\ud83c\udde7', '\ud83c\udde7\ud83c\udde6'], ['\ud83c\udde6\ud83c\udde7\ud83c\udde8', '\ud83c\udde8\ud83c\udde7\ud83c\udde6'],\n                   \\ ['\ud83c\udde6\u00ab\ud83c\udde7-\ud83c\udde8\u00bb\ud83c\udde9', '\ud83c\udde9\u00bb\ud83c\udde8-\ud83c\udde7\u00ab\ud83c\udde6']]\n      call assert_equal(s2, reverse(s1))\n    endfor\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal('dcba', reverse('abcd'))\n  let &encoding = save_enc\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_class\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_enum\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_type\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t\temsg(_(e_at_end_of_file));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    if (RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n    --no_wait_return;\n    update_screen(UPD_CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc_RedrawingDisabled = FALSE;\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return() for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc_RedrawingDisabled = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL && lines_ga.ga_len > current_line)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc_RedrawingDisabled)\n    {\n\tif (RedrawingDisabled > 0)\n\t    --RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return() we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw(void)\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION;\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(e_exception_not_caught_str),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP;\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW;\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, 0);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tsave_pending_end_reg_executing = pending_end_reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n    int\t\tmay_have_range;\n#ifdef FEAT_EVAL\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n    int\t\tdid_append_cmd = FALSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    int vim9script = in_vim9script();\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    // Handle \":export\" - it functions almost like a command modifier.\n    // \":export var Name: type\"\n    // \":export def Name(...\"\n    // etc.\n    if (vim9script && checkforcmd_noparen(&ea.cmd, \"export\", 6))\n\tis_export = TRUE;\n#endif\n\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n#ifdef FEAT_EVAL\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n#else\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n#endif\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n#endif\n\n    ea.cmd = cmd;\n\n#ifdef FEAT_EVAL\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\tgoto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\terrormsg = ex_range_without_command(&ea);\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(e_not_an_editor_command));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t\tdid_append_cmd = TRUE;\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(e_command_not_allowed_in_rvim);\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    errormsg = _(e_no_range_allowed);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\n    {\n\terrormsg = _(e_no_bang_allowed);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(e_backwards_range_given);\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invalid_argument);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(e_use_w_or_w_gt_gt);\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea, FALSE);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n' && !(ea.argt & EX_EXPR_ARG))\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalid_register_name);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits_quoted(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_positive_count_required);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    if (ea.line2 >= LONG_MAX - (n - 1))\n\t\tea.line2 = LONG_MAX;  // avoid overflow\n\t    else\n\t\tea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_characters_str, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argument_required);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_horizontal:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if ((ea.argt & EX_XFILE)\n\t    && expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\tgoto doend;\n\n#ifdef FEAT_EVAL\n    if (is_export && (ea.argt & EX_EXPORT) == 0)\n    {\n\temsg(_(e_invalid_command_after_export));\n\tgoto doend;\n    }\n#endif\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // A command will reset \"is_export\" when exporting an item.  If it is still\n    // set something went wrong or the command was never executed.\n    if (!ea.skip && is_export)\n    {\n\tif (errormsg == NULL)\n\t    errormsg = _(e_export_with_invalid_argument);\n\tis_export = FALSE;\n    }\n\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (sourcing_a_script(&ea)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif ((sourcing || !KeyTyped) && !did_append_cmd)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n    is_export = FALSE;\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n    pending_end_reg_executing = save_pending_end_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Handle a range without a command.\n * Returns an error message on failure.\n */\n    char *\nex_range_without_command(exarg_T *eap)\n{\n    char *errormsg = NULL;\n\n    if ((*eap->cmd == '|' || (exmode_active && eap->line1 != eap->line2))\n#ifdef FEAT_EVAL\n\t    && !in_vim9script()\n#endif\n       )\n    {\n\teap->cmdidx = CMD_print;\n\teap->argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\tif ((errormsg = invalid_range(eap)) == NULL)\n\t{\n\t    correct_range(eap);\n\t    ex_print(eap);\n\t}\n    }\n    else if (eap->addr_count != 0)\n    {\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t{\n\t    // With '-' in 'cpoptions' a line number past the file is an\n\t    // error, otherwise put it at the end of the file.\n\t    if (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\teap->line2 = -1;\n\t    else\n\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t}\n\n\tif (eap->line2 < 0)\n\t    errormsg = _(e_invalid_range);\n\telse\n\t{\n\t    if (eap->line2 == 0)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    return errormsg;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\" or \".\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !ASCII_ISALPHA((*pp)[i]) && (*pp)[i] != '_'\n\t\t\t && (!noparen || ((*pp)[i] != '(' && (*pp)[i] != '.')))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\" or \".\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script)\n\t    {\n\t\tif (has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n#ifdef FEAT_EVAL\n\t\tif (eap->cmd[0] == '#' && eap->cmd[1] == '{'\n\t\t\t\t\t\t\t && eap->cmd[2] != '{')\n\t\t    *errormsg = _(e_cannot_use_hash_curly_to_start_comment);\n#endif\n\t    }\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmdmods[].\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t    case 'h':\tif (checkforcmd_noparen(&eap->cmd, \"horizontal\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_HOR;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t\t\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\t\t//  longer, in case it was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose > 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose - 1;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    size_t  len = STRLEN(IObuff);\n    char_u  *s = cmd;\n    char_u  *d;\n\n    if (len > IOSIZE - 100)\n    {\n\t// Not enough space, truncate and put in \"...\".\n\td = IObuff + IOSIZE - 100;\n\td -= mb_head_off(IObuff, d);\n\tSTRCPY(d, \"...\");\n    }\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n#endif\n\n/*\n * Return TRUE and set \"*idx\" if \"p\" points to a one letter command.\n * If not in Vim9 script:\n * - The 'k' command can directly be followed by any character.\n * - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n *\t    but :sre[wind] is another command, as are :scr[iptnames],\n *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n */\n    static int\none_letter_cmd(char_u *p, cmdidx_T *idx)\n{\n    if (in_vim9script())\n\treturn FALSE;\n    if (*p == 'k')\n    {\n\t*idx = CMD_k;\n\treturn TRUE;\n    }\n    if (p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\t*idx = CMD_substitute;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if \"cmd\" starts with \"123->\", a number followed by a method\n * call.\n */\n    int\nnumber_method(char_u *cmd)\n{\n    char_u *p = skipdigits(cmd);\n\n    return p > cmd && (p = skipwhite(p))[0] == '-' && p[1] == '>';\n}\n#endif\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL)\n\t       || (p[0] == '0' && p[1] == 'z'))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || (eap->cmd[0] == '$'\n\t\t\t\t  && eap->cmd[1] != '\\'' && eap->cmd[1] != '\"')\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // '$\"string\"->func()' is an expression.\n\t\t\t    // \"$'string'->func()\" is an expression.\n\t\t\t || (eap->cmd[0] == '$'\n\t\t\t     && (eap->cmd[1] == '\\'' || eap->cmd[1] == '\"'))\n\t\t\t    // '0z1234->func()' is an expression.\n\t\t\t || (eap->cmd[0] == '0' && eap->cmd[1] == 'z')\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if ((p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.'\n\t\t\t\t     && (ASCII_ISALPHA(p[1]) || p[1] == '_'))))\n\t\t\t// g:[key] is an expression\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0)\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    // Not \"redir => var\" (when skipping).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| (eap->skip && IS_WHITE_OR_NUL(\n\t\t\t\t\t\t      *(skipwhite(p) + oplen)))\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize trying to use a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_var;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// 1234->func() is a method call\n\tif (number_method(eap->cmd))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// \"g:\", \"s:\" and \"l:\" are always assumed to be a variable, thus start\n\t// an expression.  A global/substitute/list command needs to use a\n\t// longer name.\n\tif (vim_strchr((char_u *)\"gsl\", *p) != NULL && p[1] == ':')\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] != NUL && p[0] == p[1]\n\t\t\t\t\t\t   && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     */\n    p = eap->cmd;\n    if (one_letter_cmd(p, &eap->cmdidx))\n    {\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\t// The \"d\" command can directly be followed by 'l' or 'p' flag, when\n\t// not in Vim9 script.\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(e_command_table_needs_to_be_updated_run_make_cmdidxs);\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL && cmdnames[eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// :Print and :mode are not supported in Vim9 script.\n\t// Some commands cannot be shortened in Vim9 script.\n\tif (vim9 && eap->cmdidx != CMD_SIZE)\n\t{\n\t    if (eap->cmdidx == CMD_mode || eap->cmdidx == CMD_Print)\n\t\teap->cmdidx = CMD_SIZE;\n\t    else if ((cmdnames[eap->cmdidx].cmd_argt & EX_WHOLE)\n\t\t\t  && len < (int)STRLEN(cmdnames[eap->cmdidx].cmd_name))\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), eap->cmd);\n\t\teap->cmdidx = CMD_SIZE;\n\t    }\n\t}\n\n\t// Do not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" in legacy script, for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4 && !vim9)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"horizontal\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"legacy\", 3, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n    {\"vim9cmd\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.flags = 0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T\tea;\n    char_u\t*name;\n    char_u\t*p;\n    int\t\tvim9script = in_vim9script();\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL))\n\treturn;\n\n    name = tv_get_string(&argvars[0]);\n    if (name == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tvim9script = tv_get_bool(&argvars[1]);\n\tcmdmod.cmod_flags &= ~(CMOD_VIM9CMD | CMOD_LEGACY);\n\tcmdmod.cmod_flags |= vim9script ? CMOD_VIM9CMD : CMOD_LEGACY;\n    }\n\n    while (*name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    ++emsg_silent;  // don't complain about using \"en\" in Vim9 script\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    --emsg_silent;\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\tgoto theend;\n\n    if (vim9script)\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    goto theend;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\ntheend:\n    cmdmod.cmod_flags = save_cmod_flags;\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    if (!one_letter_cmd(cmd, &idx))\n\tfor (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t\tidx = (cmdidx_T)((int)idx + 1))\n\t    if (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t\tbreak;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd_start,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    char_u\t*cmd = cmd_start;\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    char_u *p = cmd;\n\n\t    // a quote is only valid at the start or after a separator\n\t    while (p > cmd_start)\n\t    {\n\t\t--p;\n\t\tif (!VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    if (cmd > cmd_start && !VIM_ISWHITE(*p) && *p != ',' && *p != ';')\n\t\tbreak;\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_no_range_allowed));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1'\n\t\tn = 1;\n\t    else\n\t    {\n\t\t// \"number\", \"+number\" or \"-number\"\n\t\tn = getdigits(&cmd);\n\t\tif (n == MAXLNUM)\n\t\t{\n\t\t    emsg(_(e_line_number_out_of_range));\n\t\t    goto error;\n\t\t}\n\t    }\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing: need to adjust for lines in a\n\t\t// closed fold after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t\t\t\t\t && address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t{\n\t\t    if (n >= LONG_MAX - lnum)\n\t\t    {\n\t\t\temsg(_(e_line_number_out_of_range));\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum += n;\n\t\t}\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(\"Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\");\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(e_sorry_command_is_not_available_in_this_version);\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t{\n\t\t    if (eap->addr_count == 0)\n\t\t\treturn _(e_no_errors);\n\t\t    return _(e_invalid_range);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + (size_t)i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t    errormsgp, &escaped, TRUE);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n * If \"keep_backslash\" is TRUE do not remove any backslash.\n */\n    void\nseparate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"'/'#': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n\t\t    && !in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t// remove the '\\'\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_characters_str, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n    if (in_vim9script())\n\tcomment_char = '#';\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(e_nr_more_file_to_edit,\n\t\t\t   e_nr_more_files_to_edit , n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(e_cannot_find_color_scheme_str), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(UPD_CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * Do preparations for \"qall\" and \"wqall\".\n * Returns FAIL when quitting should be aborted.\n */\n    int\nbefore_quit_all(exarg_T *eap)\n{\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn FAIL;\n    }\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n    if (before_quit_all(eap) == FAIL)\n\treturn;\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (is_aucmd_win(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn;\n    }\n    if (window_layout_locked(CMD_close))\n\treturn;\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n# ifdef FEAT_TERMINAL\n\t    if (term_job_running(buf->b_term))\n\t    {\n\t\tif (term_confirm_stop(buf) == FAIL)\n\t\t    return;\n\t\t// Manually kill the terminal here because this command will\n\t\t// hide it otherwise.\n\t\tfree_terminal(buf);\n\t\tneed_hide = FALSE;\n\t    }\n\t    else\n# endif\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tdialog_changed(buf, FALSE);\n\t\tif (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\t    return;\n\t\tneed_hide = FALSE;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invalid_value_for_argument_str,\n\t\t\t\t\t\t\t\t     eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (first_tabpage->tp_next == NULL)\n    {\n\temsg(_(e_cannot_close_last_tab_page));\n\treturn;\n    }\n\n    if (window_layout_locked(CMD_tabclose))\n\treturn;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg != NULL)\n\treturn;\n\n    tp = find_tabpage(tab_number);\n    if (tp == NULL)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (tp != curtab)\n    {\n\ttabpage_close_other(tp, eap->forceit);\n\treturn;\n    }\n    else if (!text_locked() && !curbuf_locked())\n\ttabpage_close(eap->forceit);\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (first_tabpage->tp_next == NULL)\n    {\n\tmsg(_(\"Already only one tab page\"));\n\treturn;\n    }\n\n    if (window_layout_locked(CMD_tabonly))\n\treturn;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg != NULL)\n\treturn;\n\n    goto_tabpage(tab_number);\n    // Repeat this up to a 1000 times, because autocommands may\n    // mess up the lists.\n    for (done = 0; done < 1000; ++done)\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_topframe != topframe)\n\t    {\n\t\ttabpage_close_other(tp, eap->forceit);\n\t\t// if we failed to close it quit\n\t\tif (valid_tabpage(tp))\n\t\t    done = 1000;\n\t\t// start over, \"tp\" is now invalid\n\t\tbreak;\n\t    }\n\tif (first_tabpage->tp_next == NULL)\n\t    break;\n    }\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    if (window_layout_locked(CMD_tabclose))\n\treturn;\n\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    if (window_layout_locked(CMD_only))\n\treturn;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twin_T   *wp;\n\tint\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (eap->skip)\n\treturn;\n\n    if (window_layout_locked(CMD_hide))\n\treturn;\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    if (eap->addr_count == 0)\n\twin_close(curwin, FALSE);\t// don't free buffer\n    else\n    {\n\tint\twinnr = 0;\n\twin_T\t*win;\n\n\tFOR_ALL_WINDOWS(win)\n\t{\n\t    winnr++;\n\t    if (winnr == eap->line2)\n\t\tbreak;\n\t}\n\tif (win == NULL)\n\t    win = lastwin;\n\twin_close(win, FALSE);\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (check_restricted())\n\treturn;\n\n    if (!eap->forceit)\n\tautowrite_all();\n    apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n    windgoto((int)Rows - 1, 0);\n    out_char('\\n');\n    out_flush();\n    stoptermcap();\n    out_flush();\t\t// needed for SUN to restore xterm buffer\n    mch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n    ui_suspend();\t\t// call machine specific function\n    maketitle();\n    resettitle();\t\t// force updating the title\n    starttermcap();\n    scroll_start();\t\t// scroll screen before redrawing\n    redraw_later_clear();\n    shell_resized();\t// may have resized window\n    apply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_empty_buffer));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.  Also for other commands that can't\n * appear at the toplevel.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = ex_errmsg(e_invalid_command_str, eap->cmd);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n    char_u\t*fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tchar_u\t*file_to_find = NULL;\n\tchar\t*search_ctx = NULL;\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname,\n\t\t\t\t\t  &file_to_find, &search_ctx);\n\tvim_free(file_to_find);\n\tvim_findfile_cleanup(search_ctx);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\ntheend:\n    vim_free(fname);\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screen_mode_setting_not_supported));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win(n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win(n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n    char_u\t*fname;\n    int\t\tcount;\n    char_u\t*file_to_find = NULL;\n    char\t*search_ctx = NULL;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t   TRUE, curbuf->b_ffname, &file_to_find, &search_ctx);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it appears\n\t// several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t  FALSE, curbuf->b_ffname, &file_to_find, &search_ctx);\n\t}\n    }\n    VIM_CLEAR(file_to_find);\n    vim_findfile_cleanup(search_ctx);\n\n    if (fname == NULL)\n\treturn;\n\n    eap->arg = fname;\n    do_exedit(eap, NULL);\n    vim_free(fname);\n}\n\n/*\n * \":open\" simulation: for now works just like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    // make a copy of the line, when searching for a mark it might be\n\t    // flushed\n\t    char_u *line = vim_strsave(ml_get_curline());\n\n\t    regmatch.rm_ic = p_ic;\n\t    if (vim_regexec(&regmatch, line, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);\n\t    else\n\t\temsg(_(e_no_match));\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(line);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tint save_RedrawingDisabled = RedrawingDisabled;\n\t\tRedrawingDisabled = 0;\n\t\tint save_nwr = no_wait_return;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tint save_ms = msg_scroll;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\tint save_he = hold_gui_events;\n\t\thold_gui_events = 0;\n#endif\n\t\tset_must_redraw(UPD_CLEAR);\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = save_RedrawingDisabled;\n\t\tno_wait_return = save_nwr;\n\t\tmsg_scroll = save_ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = save_he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit a new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"textlock\" or \"curbuf_lock\" is set.\n\t// Only \":edit\" or \":script\" can bring us here, others are stopped\n\t// earlier.\n\tif (*eap->arg != NUL && text_or_buf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n\tn = curwin->w_arg_idx_invalid;\n\tcheck_arg_idx(curwin);\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n    {\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n\treturn;\n    }\n\n    if (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browseFile;\n\n\tbrowseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\tNULL, NULL, NULL, curbuf);\n\tif (browseFile != NULL)\n\t{\n\t    i = readfile(browseFile, NULL,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t    vim_free(browseFile);\n\t}\n\telse\n\t    i = OK;\n    }\n    else\n#endif\n\tif (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t    eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n    if (i != OK)\n    {\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    semsg(_(e_cant_open_file_str), eap->arg);\n    }\n    else\n    {\n\tif (empty && exmode_active)\n\t{\n\t    // Delete the empty line that remains.  Historically ex does\n\t    // this but vi doesn't.\n\t    if (eap->line2 == 0)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t    {\n\t\tml_delete(lnum);\n\t\tif (curwin->w_cursor.lnum > 1\n\t\t\t&& curwin->w_cursor.lnum >= lnum)\n\t\t    --curwin->w_cursor.lnum;\n\t\tdeleted_lines_mark(lnum, 1L);\n\t    }\n\t}\n\tredraw_curbuf_later(UPD_VALID);\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    last_chdir_reason = NULL;\n    shorten_fnames(TRUE);\n}\n\n/*\n * Trigger DirChangedPre for \"acmd_fname\" with directory \"new_dir\".\n */\n    void\ntrigger_DirChangedPre(char_u *acmd_fname, char_u *new_dir)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"directory\", new_dir);\n    dict_set_items_ro(v_event);\n#endif\n    apply_autocmds(EVENT_DIRCHANGEDPRE, acmd_fname, new_dir, FALSE, curbuf);\n#ifdef FEAT_EVAL\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    char_u\t*acmd_fname = NULL;\n    char_u\t**pp;\n    char_u\t*tofree;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(e_cannot_change_directory_buffer_is_modified_add_bang_to_override));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(e_no_previous_directory));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n\n    // For UNIX \":cd\" means: go to home directory.\n    // On other systems too if 'cdhome' is set.\n#if defined(UNIX) || defined(VMS)\n    if (*new_dir == NUL)\n#else\n    if (*new_dir == NUL && p_cdh)\n#endif\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n    dir_differs = pdir == NULL\n\t\t\t    || pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (dir_differs)\n    {\n\tif (scope == CDSCOPE_WINDOW)\n\t    acmd_fname = (char_u *)\"window\";\n\telse if (scope == CDSCOPE_TABPAGE)\n\t    acmd_fname = (char_u *)\"tabpage\";\n\telse\n\t    acmd_fname = (char_u *)\"global\";\n\ttrigger_DirChangedPre(acmd_fname, new_dir);\n\n\tif (vim_chdir(new_dir))\n\t{\n\t    emsg(_(e_command_failed));\n\t    vim_free(pdir);\n\t    return FALSE;\n\t}\n    }\n\n    if (scope == CDSCOPE_WINDOW)\n\tpp = &curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tpp = &curtab->tp_prevdir;\n    else\n\tpp = &prev_dir;\n    tofree = *pp;  // new_dir may use this\n    *pp = pdir;\n\n    post_chdir(scope);\n\n    if (dir_differs)\n\tapply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE, curbuf);\n    vim_free(tofree);\n    return TRUE;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory unless 'cdhome' is set\n    if (*new_dir == NUL && !p_cdh)\n    {\n\tex_pwd(NULL);\n\treturn;\n    }\n#endif\n\n    cdscope_T\tscope = CDSCOPE_GLOBAL;\n\n    if (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\tscope = CDSCOPE_WINDOW;\n    else if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\tscope = CDSCOPE_TABPAGE;\n\n    if (changedir_func(new_dir, eap->forceit, scope))\n    {\n\t// Echo the new current directory if the command was typed.\n\tif (KeyTyped || p_verbose >= 5)\n\t    ex_pwd(eap);\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (last_chdir_reason != NULL)\n\t\tcontext = last_chdir_reason;\n\t    else if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(e_directory_unknown));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invalid_argument_str), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n\tcursor_sleep();\n    else\n\tcursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n\tcursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invalid_argument_str), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(e_winsize_requires_two_number_arguments));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invalid_argument));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(e_obtaining_window_position_not_implemented_for_this_platform));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(e_winpos_requires_two_number_arguments));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    int\tsave_efr = exec_from_reg;\n\n    exec_from_reg = TRUE;\n\n    /*\n     * Execute from the typeahead buffer.\n     * Continue until the stuff buffer is empty and all added characters\n     * have been consumed.\n     */\n    while (!stuff_empty() || typebuf.tb_len > prev_len)\n\t(void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n    exec_from_reg = save_efr;\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(e_cannot_use_redir_inside_execute));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invalid_argument_str), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw, with clear for \":redraw!\".\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    redraw_cmd(eap->forceit);\n}\n\n/*\n * \":redraw\": force redraw, with clear if \"clear\" is TRUE.\n */\n    void\nredraw_cmd(int clear)\n{\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    validate_cursor();\n    update_topline();\n    update_screen(clear ? UPD_CLEAR : VIsual_active ? UPD_INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n\n    // After drawing the statusline screen_attr may still be set.\n    screen_stop_highlight();\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    // When invoked from a callback or autocmd the command line may be active.\n    if (State & MODE_CMDLINE)\n\tredrawcmdline();\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    if (msg_scrolled && (State & MODE_CMDLINE))\n\treturn;  // redraw later\n\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    if (State & MODE_CMDLINE)\n\tredraw_statuslines();\n    else\n\tupdate_screen(VIsual_active ? UPD_INVERTED : 0);\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int save_RedrawingDisabled = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    int save_p_lz = p_lz;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = save_RedrawingDisabled;\n    p_lz = save_p_lz;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(e_cannot_create_directory_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_str_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(e_str_exists_add_bang_to_override), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(e_cannot_open_str_for_writing_2), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n    {\n\temsg(_(e_argument_required));\n\treturn;\n    }\n\n    if (eap->arg[1] != NUL)\t// more than one character?\n    {\n\tsemsg(_(e_trailing_characters_str), eap->arg);\n\treturn;\n    }\n\n    pos = curwin->w_cursor;\t\t// save curwin->w_cursor\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_WHITE | BL_FIX);\n    if (setmark(*eap->arg) == FAIL)\t// set mark\n\temsg(_(e_argument_must_be_letter_or_forward_backward_quote));\n    curwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n    sst->save_pending_end_reg_executing = pending_end_reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    pending_end_reg_executing = sst->save_pending_end_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_not_allowed_here));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(e_recursive_use_of_normal_too_deep));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & MODE_INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_characters_str, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(UPD_VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<script>\",\t\t// script file name\n#define SPEC_SCRIPT (SPEC_STACK + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_SCRIPT + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<script>\" to current script name\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped,\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n    int\t\tempty_is_error)\t// empty result is considered an error\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(e_hashsmall_is_not_available_without_the_eval_feature);\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(e_no_alternate_file_name_to_substitute_for_hash);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_buffer_number_to_substitute_for_abuf);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\t\tresult = estack_sfile(ESTACK_SFILE);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_call_stack_to_substitute_for_stack);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_SCRIPT:\t// script file name\n\t\tresult = estack_sfile(ESTACK_SCRIPT);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_script_file_name_to_substitute_for_script);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_slnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_sflnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_using_sid_not_in_script_context);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (empty_is_error)\n\t{\n\t    if (valid != VALID_HEAD + VALID_PATH)\n\t\t*errormsg = _(e_empty_file_name_for_percent_or_hash_only_works_with_ph);\n\t    else\n\t\t*errormsg = _(e_evaluates_to_an_empty_string);\n\t}\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL, TRUE);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\",\n\t\t\t\t\t\t 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t     0L, (char_u *)\"popup\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\",\n\t\t\t\t\t  0L, (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t    0L, (char_u *)\"extend\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (did_filetype)\n\treturn;\n\n    char_u *arg = eap->arg;\n    if (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\targ += 9;\n\n    set_option_value_give_err((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n    if (arg != eap->arg)\n\tdid_filetype = FALSE;\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(UPD_SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n", "\" Tests for various functions.\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\n\" Must be done first, since the alternate buffer must be unset.\nfunc Test_00_bufexists()\n  call assert_equal(0, bufexists('does_not_exist'))\n  call assert_equal(1, bufexists(bufnr('%')))\n  call assert_equal(0, bufexists(0))\n  new Xfoo\n  let bn = bufnr('%')\n  call assert_equal(1, bufexists(bn))\n  call assert_equal(1, bufexists('Xfoo'))\n  call assert_equal(1, bufexists(getcwd() . '/Xfoo'))\n  call assert_equal(1, bufexists(0))\n  bw\n  call assert_equal(0, bufexists(bn))\n  call assert_equal(0, bufexists('Xfoo'))\nendfunc\n\nfunc Test_has()\n  call assert_equal(1, has('eval'))\n  call assert_equal(1, has('eval', 1))\n\n  if has('unix')\n    call assert_equal(1, or(has('ttyin'), 1))\n    call assert_equal(0, and(has('ttyout'), 0))\n    call assert_equal(1, has('multi_byte_encoding'))\n    call assert_equal(0, has(':tearoff'))\n  endif\n  call assert_equal(1, has('vcon', 1))\n  call assert_equal(1, has('mouse_gpm_enabled', 1))\n\n  call assert_equal(has('gui_win32') && has('menu'), has(':tearoff'))\n\n  call assert_equal(0, has('nonexistent'))\n  call assert_equal(0, has('nonexistent', 1))\n\n  \" Will we ever have patch 9999?\n  let ver = 'patch-' .. v:version / 100 .. '.' .. v:version % 100 .. '.9999'\n  call assert_equal(0, has(ver))\n\n  \" There actually isn't a patch 9.0.0, but this is more consistent.\n  call assert_equal(1, has('patch-9.0.0'))\nendfunc\n\nfunc Test_empty()\n  call assert_equal(1, empty(''))\n  call assert_equal(0, empty('a'))\n\n  call assert_equal(1, empty(0))\n  call assert_equal(1, empty(-0))\n  call assert_equal(0, empty(1))\n  call assert_equal(0, empty(-1))\n\n  call assert_equal(1, empty(0.0))\n  call assert_equal(1, empty(-0.0))\n  call assert_equal(0, empty(1.0))\n  call assert_equal(0, empty(-1.0))\n  call assert_equal(0, empty(1.0/0.0))\n  call assert_equal(0, empty(0.0/0.0))\n\n  call assert_equal(1, empty([]))\n  call assert_equal(0, empty(['a']))\n\n  call assert_equal(1, empty({}))\n  call assert_equal(0, empty({'a':1}))\n\n  call assert_equal(1, empty(v:null))\n  call assert_equal(1, empty(v:none))\n  call assert_equal(1, empty(v:false))\n  call assert_equal(0, empty(v:true))\n\n  if has('channel')\n    call assert_equal(1, empty(test_null_channel()))\n  endif\n  if has('job')\n    call assert_equal(1, empty(test_null_job()))\n  endif\n\n  call assert_equal(0, empty(function('Test_empty')))\n  call assert_equal(0, empty(function('Test_empty', [0])))\n\n  call assert_fails(\"call empty(test_void())\", ['E340:', 'E685:'])\n  call assert_fails(\"call empty(test_unknown())\", ['E340:', 'E685:'])\nendfunc\n\nfunc Test_err_teapot()\n  call assert_fails('call err_teapot()', \"E418: I'm a teapot\")\n  call assert_fails('call err_teapot(0)', \"E418: I'm a teapot\")\n  call assert_fails('call err_teapot(v:false)', \"E418: I'm a teapot\")\n\n  call assert_fails('call err_teapot(\"1\")', \"E503: Coffee is currently not available\")\n  call assert_fails('call err_teapot(v:true)', \"E503: Coffee is currently not available\")\n  let expr = 1\n  call assert_fails('call err_teapot(expr)', \"E503: Coffee is currently not available\")\nendfunc\n\nfunc Test_test_void()\n  call assert_fails('echo 1 == test_void()', 'E1031:')\n  call assert_fails('echo 1.0 == test_void()', 'E1031:')\n  call assert_fails('let x = json_encode(test_void())', ['E340:', 'E685:'])\n  call assert_fails('let x = copy(test_void())', ['E340:', 'E685:'])\n  call assert_fails('let x = copy([test_void()])', 'E1031:')\nendfunc\n\nfunc Test_islocked()\n  call assert_fails('call islocked(99)', 'E475:')\n  call assert_fails('call islocked(\"s: x\")', 'E488:')\nendfunc\n\nfunc Test_len()\n  call assert_equal(1, len(0))\n  call assert_equal(2, len(12))\n\n  call assert_equal(0, len(''))\n  call assert_equal(2, len('ab'))\n\n  call assert_equal(0, len([]))\n  call assert_equal(0, len(test_null_list()))\n  call assert_equal(2, len([2, 1]))\n\n  call assert_equal(0, len({}))\n  call assert_equal(0, len(test_null_dict()))\n  call assert_equal(2, len({'a': 1, 'b': 2}))\n\n  call assert_fails('call len(v:none)', 'E701:')\n  call assert_fails('call len({-> 0})', 'E701:')\nendfunc\n\nfunc Test_max()\n  call assert_equal(0, max([]))\n  call assert_equal(2, max([2]))\n  call assert_equal(2, max([1, 2]))\n  call assert_equal(2, max([1, 2, v:null]))\n\n  call assert_equal(0, max({}))\n  call assert_equal(2, max({'a':1, 'b':2}))\n\n  call assert_fails('call max(1)', 'E712:')\n  call assert_fails('call max(v:none)', 'E712:')\n\n  \" check we only get one error\n  call assert_fails('call max([#{}, [1]])', ['E728:', 'E728:'])\n  call assert_fails('call max(#{a: {}, b: [1]})', ['E728:', 'E728:'])\nendfunc\n\nfunc Test_min()\n  call assert_equal(0, min([]))\n  call assert_equal(2, min([2]))\n  call assert_equal(1, min([1, 2]))\n  call assert_equal(0, min([1, 2, v:null]))\n\n  call assert_equal(0, min({}))\n  call assert_equal(1, min({'a':1, 'b':2}))\n\n  call assert_fails('call min(1)', 'E712:')\n  call assert_fails('call min(v:none)', 'E712:')\n  call assert_fails('call min([1, {}])', 'E728:')\n\n  \" check we only get one error\n  call assert_fails('call min([[1], #{}])', ['E745:', 'E745:'])\n  call assert_fails('call min(#{a: [1], b: #{}})', ['E745:', 'E745:'])\nendfunc\n\nfunc Test_strwidth()\n  for aw in ['single', 'double']\n    exe 'set ambiwidth=' . aw\n    call assert_equal(0, strwidth(''))\n    call assert_equal(1, strwidth(\"\\t\"))\n    call assert_equal(3, strwidth('Vim'))\n    call assert_equal(4, strwidth(1234))\n    call assert_equal(5, strwidth(-1234))\n\n    call assert_equal(2, strwidth('\ud83d\ude09'))\n    call assert_equal(17, strwidth('E\u0125o\u015dan\u011do \u0109iu\u0135a\u016dde'))\n    call assert_equal((aw == 'single') ? 6 : 7, strwidth('Stra\u00dfe'))\n\n    call assert_fails('call strwidth({->0})', 'E729:')\n    call assert_fails('call strwidth([])', 'E730:')\n    call assert_fails('call strwidth({})', 'E731:')\n  endfor\n\n  call assert_equal(3, strwidth(1.2))\n  call v9.CheckDefAndScriptFailure(['echo strwidth(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\n\n  set ambiwidth&\nendfunc\n\nfunc Test_str2nr()\n  call assert_equal(0, str2nr(''))\n  call assert_equal(1, str2nr('1'))\n  call assert_equal(1, str2nr(' 1 '))\n\n  call assert_equal(1, str2nr('+1'))\n  call assert_equal(1, str2nr('+ 1'))\n  call assert_equal(1, str2nr(' + 1 '))\n\n  call assert_equal(-1, str2nr('-1'))\n  call assert_equal(-1, str2nr('- 1'))\n  call assert_equal(-1, str2nr(' - 1 '))\n\n  call assert_equal(123456789, str2nr('123456789'))\n  call assert_equal(-123456789, str2nr('-123456789'))\n\n  call assert_equal(5, str2nr('101', 2))\n  call assert_equal(5, '0b101'->str2nr(2))\n  call assert_equal(5, str2nr('0B101', 2))\n  call assert_equal(-5, str2nr('-101', 2))\n  call assert_equal(-5, str2nr('-0b101', 2))\n  call assert_equal(-5, str2nr('-0B101', 2))\n\n  call assert_equal(65, str2nr('101', 8))\n  call assert_equal(65, str2nr('0101', 8))\n  call assert_equal(-65, str2nr('-101', 8))\n  call assert_equal(-65, str2nr('-0101', 8))\n  call assert_equal(65, str2nr('0o101', 8))\n  call assert_equal(65, str2nr('0O0101', 8))\n  call assert_equal(-65, str2nr('-0O101', 8))\n  call assert_equal(-65, str2nr('-0o0101', 8))\n\n  call assert_equal(11259375, str2nr('abcdef', 16))\n  call assert_equal(11259375, str2nr('ABCDEF', 16))\n  call assert_equal(-11259375, str2nr('-ABCDEF', 16))\n  call assert_equal(11259375, str2nr('0xabcdef', 16))\n  call assert_equal(11259375, str2nr('0Xabcdef', 16))\n  call assert_equal(11259375, str2nr('0XABCDEF', 16))\n  call assert_equal(-11259375, str2nr('-0xABCDEF', 16))\n\n  call assert_equal(1, str2nr(\"1'000'000\", 10, 0))\n  call assert_equal(256, str2nr(\"1'0000'0000\", 2, 1))\n  call assert_equal(262144, str2nr(\"1'000'000\", 8, 1))\n  call assert_equal(1000000, str2nr(\"1'000'000\", 10, 1))\n  call assert_equal(1000, str2nr(\"1'000''000\", 10, 1))\n  call assert_equal(65536, str2nr(\"1'00'00\", 16, 1))\n\n  call assert_equal(0, str2nr('0x10'))\n  call assert_equal(0, str2nr('0b10'))\n  call assert_equal(0, str2nr('0o10'))\n  call assert_equal(1, str2nr('12', 2))\n  call assert_equal(1, str2nr('18', 8))\n  call assert_equal(1, str2nr('1g', 16))\n\n  call assert_equal(0, str2nr(v:null))\n  call assert_equal(0, str2nr(v:none))\n\n  call assert_fails('call str2nr([])', 'E730:')\n  call assert_fails('call str2nr({->2})', 'E729:')\n  call assert_equal(1, str2nr(1.2))\n  call v9.CheckDefAndScriptFailure(['echo str2nr(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\n  call assert_fails('call str2nr(10, [])', 'E745:')\nendfunc\n\nfunc Test_strftime()\n  CheckFunction strftime\n\n  \" Format of strftime() depends on system. We assume\n  \" that basic formats tested here are available and\n  \" identical on all systems which support strftime().\n  \"\n  \" The 2nd parameter of strftime() is a local time, so the output day\n  \" of strftime() can be 17 or 18, depending on timezone.\n  call assert_match('^2017-01-1[78]$', strftime('%Y-%m-%d', 1484695512))\n  \"\n  call assert_match('^\\d\\d\\d\\d-\\(0\\d\\|1[012]\\)-\\([012]\\d\\|3[01]\\) \\([01]\\d\\|2[0-3]\\):[0-5]\\d:\\([0-5]\\d\\|60\\)$', '%Y-%m-%d %H:%M:%S'->strftime())\n\n  call assert_fails('call strftime([])', 'E730:')\n  call assert_fails('call strftime(\"%Y\", [])', 'E745:')\n\n  \" Check that the time changes after we change the timezone\n  \" Save previous timezone value, if any\n  if exists('$TZ')\n    let tz = $TZ\n  endif\n\n  \" Force EST and then UTC, save the current hour (24-hour clock) for each\n  let $TZ = 'EST' | let est = strftime('%H')\n  let $TZ = 'UTC' | let utc = strftime('%H')\n\n  \" Those hours should be two bytes long, and should not be the same; if they\n  \" are, a tzset(3) call may have failed somewhere\n  call assert_equal(strlen(est), 2)\n  call assert_equal(strlen(utc), 2)\n  \" TODO: this fails on MS-Windows\n  if has('unix')\n    call assert_notequal(est, utc)\n  endif\n\n  \" If we cached a timezone value, put it back, otherwise clear it\n  if exists('tz')\n    let $TZ = tz\n  else\n    unlet $TZ\n  endif\nendfunc\n\nfunc Test_strptime()\n  CheckFunction strptime\n\n  if exists('$TZ')\n    let tz = $TZ\n  endif\n  let $TZ = 'UTC'\n\n  call assert_equal(1484653763, strptime('%Y-%m-%d %T', '2017-01-17 11:49:23'))\n\n  \" Force DST and check that it's considered\n  let $TZ = 'WINTER0SUMMER,J1,J365'\n  call assert_equal(1484653763 - 3600, strptime('%Y-%m-%d %T', '2017-01-17 11:49:23'))\n\n  call assert_fails('call strptime()', 'E119:')\n  call assert_fails('call strptime(\"xxx\")', 'E119:')\n  call assert_equal(0, strptime(\"%Y\", ''))\n  call assert_equal(0, strptime(\"%Y\", \"xxx\"))\n\n  if exists('tz')\n    let $TZ = tz\n  else\n    unlet $TZ\n  endif\nendfunc\n\nfunc Test_resolve_unix()\n  CheckUnix\n\n  \" Xlink1 -> Xlink2\n  \" Xlink2 -> Xlink3\n  silent !ln -s -f Xlink2 Xlink1\n  silent !ln -s -f Xlink3 Xlink2\n  call assert_equal('Xlink3', resolve('Xlink1'))\n  call assert_equal('./Xlink3', resolve('./Xlink1'))\n  call assert_equal('Xlink3/', resolve('Xlink2/'))\n  \" FIXME: these tests result in things like \"Xlink2/\" instead of \"Xlink3/\"?!\n  \"call assert_equal('Xlink3/', resolve('Xlink1/'))\n  \"call assert_equal('./Xlink3/', resolve('./Xlink1/'))\n  \"call assert_equal(getcwd() . '/Xlink3/', resolve(getcwd() . '/Xlink1/'))\n  call assert_equal(getcwd() . '/Xlink3', resolve(getcwd() . '/Xlink1'))\n\n  \" Test resolve() with a symlink cycle.\n  \" Xlink1 -> Xlink2\n  \" Xlink2 -> Xlink3\n  \" Xlink3 -> Xlink1\n  silent !ln -s -f Xlink1 Xlink3\n  call assert_fails('call resolve(\"Xlink1\")',   'E655:')\n  call assert_fails('call resolve(\"./Xlink1\")', 'E655:')\n  call assert_fails('call resolve(\"Xlink2\")',   'E655:')\n  call assert_fails('call resolve(\"Xlink3\")',   'E655:')\n  call delete('Xlink1')\n  call delete('Xlink2')\n  call delete('Xlink3')\n\n  silent !ln -s -f Xresolvedir//Xfile Xresolvelink\n  call assert_equal('Xresolvedir/Xfile', resolve('Xresolvelink'))\n  call delete('Xresolvelink')\n\n  silent !ln -s -f Xlink2/ Xlink1\n  call assert_equal('Xlink2', 'Xlink1'->resolve())\n  call assert_equal('Xlink2/', resolve('Xlink1/'))\n  call delete('Xlink1')\n\n  silent !ln -s -f ./Xlink2 Xlink1\n  call assert_equal('Xlink2', resolve('Xlink1'))\n  call assert_equal('./Xlink2', resolve('./Xlink1'))\n  call delete('Xlink1')\n\n  call assert_equal('/', resolve('/'))\nendfunc\n\nfunc s:normalize_fname(fname)\n  let ret = substitute(a:fname, '\\', '/', 'g')\n  let ret = substitute(ret, '//', '/', 'g')\n  return ret->tolower()\nendfunc\n\nfunc Test_resolve_win32()\n  CheckMSWindows\n\n  \" test for shortcut file\n  if executable('cscript')\n    new Xresfile\n    wq\n    let lines =<< trim END\n\tSet fs = CreateObject(\"Scripting.FileSystemObject\")\n\tSet ws = WScript.CreateObject(\"WScript.Shell\")\n\tSet shortcut = ws.CreateShortcut(\"Xlink.lnk\")\n\tshortcut.TargetPath = fs.BuildPath(ws.CurrentDirectory, \"Xresfile\")\n\tshortcut.Save\n    END\n    call writefile(lines, 'link.vbs')\n    silent !cscript link.vbs\n    call delete('link.vbs')\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink.lnk')))\n    call delete('Xresfile')\n\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink.lnk')))\n    call delete('Xlink.lnk')\n  else\n    echomsg 'skipped test for shortcut file'\n  endif\n\n  \" remove files\n  call delete('Xlink')\n  call delete('Xdir', 'd')\n  call delete('Xresfile')\n\n  \" test for symbolic link to a file\n  new Xresfile\n  wq\n  call assert_equal('Xresfile', resolve('Xresfile'))\n  silent !mklink Xlink Xresfile\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xresfile'), s:normalize_fname(resolve('./Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for symbolic link to a file'\n  endif\n  call delete('Xresfile')\n\n  \" test for junction to a directory\n  call mkdir('Xdir')\n  silent !mklink /J Xlink Xdir\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n\n    call delete('Xdir', 'd')\n\n    \" test for junction already removed\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xlink'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for junction to a directory'\n    call delete('Xdir', 'd')\n  endif\n\n  \" test for symbolic link to a directory\n  call mkdir('Xdir')\n  silent !mklink /D Xlink Xdir\n  if !v:shell_error\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n\n    call delete('Xdir', 'd')\n\n    \" test for symbolic link already removed\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xlink'), s:normalize_fname(resolve(getcwd() . '/Xlink')))\n    call delete('Xlink')\n  else\n    echomsg 'skipped test for symbolic link to a directory'\n    call delete('Xdir', 'd')\n  endif\n\n  \" test for buffer name\n  new Xbuffile\n  wq\n  silent !mklink Xlink Xbuffile\n  if !v:shell_error\n    edit Xlink\n    call assert_equal('Xlink', bufname('%'))\n    call delete('Xlink')\n    bw!\n  else\n    echomsg 'skipped test for buffer name'\n  endif\n  call delete('Xbuffile')\n\n  \" test for reparse point\n  call mkdir('Xdir')\n  call assert_equal('Xdir', resolve('Xdir'))\n  silent !mklink /D Xdirlink Xdir\n  if !v:shell_error\n    w Xdir/text.txt\n    call assert_equal('Xdir/text.txt', resolve('Xdir/text.txt'))\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir\\text.txt'), s:normalize_fname(resolve('Xdirlink\\text.txt')))\n    call assert_equal(s:normalize_fname(getcwd() . '\\Xdir'), s:normalize_fname(resolve('Xdirlink')))\n    call delete('Xdirlink')\n  else\n    echomsg 'skipped test for reparse point'\n  endif\n\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_simplify()\n  call assert_equal('',            simplify(''))\n  call assert_equal('/',           simplify('/'))\n  call assert_equal('/',           simplify('/.'))\n  call assert_equal('/',           simplify('/..'))\n  call assert_equal('/...',        simplify('/...'))\n  call assert_equal('//path',      simplify('//path'))\n  if has('unix')\n    call assert_equal('/path',       simplify('///path'))\n    call assert_equal('/path',       simplify('////path'))\n  endif\n\n  call assert_equal('./dir/file',  './dir/file'->simplify())\n  call assert_equal('./dir/file',  simplify('.///dir//file'))\n  call assert_equal('./dir/file',  simplify('./dir/./file'))\n  call assert_equal('./file',      simplify('./dir/../file'))\n  call assert_equal('../dir/file', simplify('dir/../../dir/file'))\n  call assert_equal('./file',      simplify('dir/.././file'))\n  call assert_equal('../dir',      simplify('./../dir'))\n  call assert_equal('..',          simplify('../testdir/..'))\n  call mkdir('Xsimpdir')\n  call assert_equal('.',           simplify('Xsimpdir/../.'))\n  call delete('Xsimpdir', 'd')\n\n  call assert_fails('call simplify({->0})', 'E729:')\n  call assert_fails('call simplify([])', 'E730:')\n  call assert_fails('call simplify({})', 'E731:')\n  call assert_equal('1.2', simplify(1.2))\n  call v9.CheckDefAndScriptFailure(['echo simplify(1.2)'], ['E1013: Argument 1: type mismatch, expected string but got float', 'E1174: String required for argument 1'])\nendfunc\n\nfunc Test_pathshorten()\n  call assert_equal('', pathshorten(''))\n  call assert_equal('foo', pathshorten('foo'))\n  call assert_equal('/foo', '/foo'->pathshorten())\n  call assert_equal('f/', pathshorten('foo/'))\n  call assert_equal('f/bar', pathshorten('foo/bar'))\n  call assert_equal('f/b/foobar', 'foo/bar/foobar'->pathshorten())\n  call assert_equal('/f/b/foobar', pathshorten('/foo/bar/foobar'))\n  call assert_equal('.f/bar', pathshorten('.foo/bar'))\n  call assert_equal('~f/bar', pathshorten('~foo/bar'))\n  call assert_equal('~.f/bar', pathshorten('~.foo/bar'))\n  call assert_equal('.~f/bar', pathshorten('.~foo/bar'))\n  call assert_equal('~/f/bar', pathshorten('~/foo/bar'))\n  call assert_fails('call pathshorten([])', 'E730:')\n\n  \" test pathshorten with optional variable to set preferred size of shortening\n  call assert_equal('', pathshorten('', 2))\n  call assert_equal('foo', pathshorten('foo', 2))\n  call assert_equal('/foo', pathshorten('/foo', 2))\n  call assert_equal('fo/', pathshorten('foo/', 2))\n  call assert_equal('fo/bar', pathshorten('foo/bar', 2))\n  call assert_equal('fo/ba/foobar', pathshorten('foo/bar/foobar', 2))\n  call assert_equal('/fo/ba/foobar', pathshorten('/foo/bar/foobar', 2))\n  call assert_equal('.fo/bar', pathshorten('.foo/bar', 2))\n  call assert_equal('~fo/bar', pathshorten('~foo/bar', 2))\n  call assert_equal('~.fo/bar', pathshorten('~.foo/bar', 2))\n  call assert_equal('.~fo/bar', pathshorten('.~foo/bar', 2))\n  call assert_equal('~/fo/bar', pathshorten('~/foo/bar', 2))\n  call assert_fails('call pathshorten([],2)', 'E730:')\n  call assert_notequal('~/fo/bar', pathshorten('~/foo/bar', 3))\n  call assert_equal('~/foo/bar', pathshorten('~/foo/bar', 3))\n  call assert_equal('~/f/bar', pathshorten('~/foo/bar', 0))\nendfunc\n\nfunc Test_strpart()\n  call assert_equal('de', strpart('abcdefg', 3, 2))\n  call assert_equal('ab', strpart('abcdefg', -2, 4))\n  call assert_equal('abcdefg', 'abcdefg'->strpart(-2))\n  call assert_equal('fg', strpart('abcdefg', 5, 4))\n  call assert_equal('defg', strpart('abcdefg', 3))\n  call assert_equal('', strpart('abcdefg', 10))\n  call assert_fails(\"let s=strpart('abcdef', [])\", 'E745:')\n\n  call assert_equal('l\u00e9p', strpart('\u00e9l\u00e9phant', 2, 4))\n  call assert_equal('l\u00e9phant', strpart('\u00e9l\u00e9phant', 2))\n\n  call assert_equal('\u00e9', strpart('\u00e9l\u00e9phant', 0, 1, 1))\n  call assert_equal('\u00e9p', strpart('\u00e9l\u00e9phant', 3, 2, v:true))\n  call assert_equal('o\u0301', strpart('co\u0301mposed', 1, 1, 1))\nendfunc\n\nfunc Test_tolower()\n  call assert_equal(\"\", tolower(\"\"))\n\n  \" Test with all printable ASCII characters.\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',\n          \\ tolower(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))\n\n  \" Test with a few uppercase diacritics.\n  call assert_equal(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\", tolower(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\"))\n  call assert_equal(\"b\u1e03\u1e07\", tolower(\"B\u1e02\u1e06\"))\n  call assert_equal(\"c\u00e7\u0107\u0109\u010b\u010d\", tolower(\"C\u00c7\u0106\u0108\u010a\u010c\"))\n  call assert_equal(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\", tolower(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\"))\n  call assert_equal(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\", tolower(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\"))\n  call assert_equal(\"f\u1e1f \", tolower(\"F\u1e1e \"))\n  call assert_equal(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\", tolower(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\"))\n  call assert_equal(\"h\u0125\u0127\u1e23\u1e27\u1e29\", tolower(\"H\u0124\u0126\u1e22\u1e26\u1e28\"))\n  call assert_equal(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012fi\u01d0\u1ec9\", tolower(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\"))\n  call assert_equal(\"j\u0135\", tolower(\"J\u0134\"))\n  call assert_equal(\"k\u0137\u01e9\u1e31\u1e35\", tolower(\"K\u0136\u01e8\u1e30\u1e34\"))\n  call assert_equal(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\", tolower(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\"))\n  call assert_equal(\"m\u1e3f\u1e41\", tolower(\"M\u1e3e\u1e40\"))\n  call assert_equal(\"n\u00f1\u0144\u0146\u0148\u1e45\u1e49\", tolower(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\"))\n  call assert_equal(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\", tolower(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\"))\n  call assert_equal(\"p\u1e55\u1e57\", tolower(\"P\u1e54\u1e56\"))\n  call assert_equal(\"q\", tolower(\"Q\"))\n  call assert_equal(\"r\u0155\u0157\u0159\u1e59\u1e5f\", tolower(\"R\u0154\u0156\u0158\u1e58\u1e5e\"))\n  call assert_equal(\"s\u015b\u015d\u015f\u0161\u1e61\", tolower(\"S\u015a\u015c\u015e\u0160\u1e60\"))\n  call assert_equal(\"t\u0163\u0165\u0167\u1e6b\u1e6f\", tolower(\"T\u0162\u0164\u0166\u1e6a\u1e6e\"))\n  call assert_equal(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\", tolower(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\"))\n  call assert_equal(\"v\u1e7d\", tolower(\"V\u1e7c\"))\n  call assert_equal(\"w\u0175\u1e81\u1e83\u1e85\u1e87\", tolower(\"W\u0174\u1e80\u1e82\u1e84\u1e86\"))\n  call assert_equal(\"x\u1e8b\u1e8d\", tolower(\"X\u1e8a\u1e8c\"))\n  call assert_equal(\"y\u00fd\u0177\u00ff\u1e8f\u1ef3\u1ef7\u1ef9\", tolower(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\"))\n  call assert_equal(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\", tolower(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\"))\n\n  \" Test with a few lowercase diacritics, which should remain unchanged.\n  call assert_equal(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\", tolower(\"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\"))\n  call assert_equal(\"b\u1e03\u1e07\", tolower(\"b\u1e03\u1e07\"))\n  call assert_equal(\"c\u00e7\u0107\u0109\u010b\u010d\", tolower(\"c\u00e7\u0107\u0109\u010b\u010d\"))\n  call assert_equal(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\", tolower(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\"))\n  call assert_equal(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\", tolower(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\"))\n  call assert_equal(\"f\u1e1f\", tolower(\"f\u1e1f\"))\n  call assert_equal(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\", tolower(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\"))\n  call assert_equal(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\", tolower(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\"))\n  call assert_equal(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\", tolower(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\"))\n  call assert_equal(\"j\u0135\u01f0\", tolower(\"j\u0135\u01f0\"))\n  call assert_equal(\"k\u0137\u01e9\u1e31\u1e35\", tolower(\"k\u0137\u01e9\u1e31\u1e35\"))\n  call assert_equal(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\", tolower(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\"))\n  call assert_equal(\"m\u1e3f\u1e41 \", tolower(\"m\u1e3f\u1e41 \"))\n  call assert_equal(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\", tolower(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\"))\n  call assert_equal(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\", tolower(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\"))\n  call assert_equal(\"p\u1e55\u1e57\", tolower(\"p\u1e55\u1e57\"))\n  call assert_equal(\"q\", tolower(\"q\"))\n  call assert_equal(\"r\u0155\u0157\u0159\u1e59\u1e5f\", tolower(\"r\u0155\u0157\u0159\u1e59\u1e5f\"))\n  call assert_equal(\"s\u015b\u015d\u015f\u0161\u1e61\", tolower(\"s\u015b\u015d\u015f\u0161\u1e61\"))\n  call assert_equal(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\", tolower(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\"))\n  call assert_equal(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\", tolower(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\"))\n  call assert_equal(\"v\u1e7d\", tolower(\"v\u1e7d\"))\n  call assert_equal(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\", tolower(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\"))\n  call assert_equal(\"\u1e8b\u1e8d\", tolower(\"\u1e8b\u1e8d\"))\n  call assert_equal(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\", tolower(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\"))\n  call assert_equal(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\", tolower(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\"))\n\n  \" According to https://twitter.com/jifa/status/625776454479970304\n  \" \u023a (U+023A) and \u023e (U+023E) are the *only* code points to increase\n  \" in length (2 to 3 bytes) when lowercased. So let's test them.\n  call assert_equal(\"\u2c65 \u2c66\", tolower(\"\u023a \u023e\"))\n\n  \" This call to tolower with invalid utf8 sequence used to cause access to\n  \" invalid memory.\n  call tolower(\"\\xC0\\x80\\xC0\")\n  call tolower(\"123\\xC0\\x80\\xC0\")\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(\"abc\", tolower(\"ABC\"))\n  let &encoding = save_enc\nendfunc\n\nfunc Test_toupper()\n  call assert_equal(\"\", toupper(\"\"))\n\n  \" Test with all printable ASCII characters.\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~',\n          \\ toupper(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))\n\n  \" Test with a few lowercase diacritics.\n  call assert_equal(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\", \"a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u1ea3\"->toupper())\n  call assert_equal(\"B\u1e02\u1e06\", toupper(\"b\u1e03\u1e07\"))\n  call assert_equal(\"C\u00c7\u0106\u0108\u010a\u010c\", toupper(\"c\u00e7\u0107\u0109\u010b\u010d\"))\n  call assert_equal(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\", toupper(\"d\u010f\u0111\u1e0b\u1e0f\u1e11\"))\n  call assert_equal(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\", toupper(\"e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u1ebb\u1ebd\"))\n  call assert_equal(\"F\u1e1e\", toupper(\"f\u1e1f\"))\n  call assert_equal(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\", toupper(\"g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u1e21\"))\n  call assert_equal(\"H\u0124\u0126\u1e22\u1e26\u1e28\u1e96\", toupper(\"h\u0125\u0127\u1e23\u1e27\u1e29\u1e96\"))\n  call assert_equal(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u01cf\u1ec8\", toupper(\"i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u1ec9\"))\n  call assert_equal(\"J\u0134\u01f0\", toupper(\"j\u0135\u01f0\"))\n  call assert_equal(\"K\u0136\u01e8\u1e30\u1e34\", toupper(\"k\u0137\u01e9\u1e31\u1e35\"))\n  call assert_equal(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\", toupper(\"l\u013a\u013c\u013e\u0140\u0142\u1e3b\"))\n  call assert_equal(\"M\u1e3e\u1e40 \", toupper(\"m\u1e3f\u1e41 \"))\n  call assert_equal(\"N\u00d1\u0143\u0145\u0147\u0149\u1e44\u1e48\", toupper(\"n\u00f1\u0144\u0146\u0148\u0149\u1e45\u1e49\"))\n  call assert_equal(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\", toupper(\"o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u1ecf\"))\n  call assert_equal(\"P\u1e54\u1e56\", toupper(\"p\u1e55\u1e57\"))\n  call assert_equal(\"Q\", toupper(\"q\"))\n  call assert_equal(\"R\u0154\u0156\u0158\u1e58\u1e5e\", toupper(\"r\u0155\u0157\u0159\u1e59\u1e5f\"))\n  call assert_equal(\"S\u015a\u015c\u015e\u0160\u1e60\", toupper(\"s\u015b\u015d\u015f\u0161\u1e61\"))\n  call assert_equal(\"T\u0162\u0164\u0166\u1e6a\u1e6e\u1e97\", toupper(\"t\u0163\u0165\u0167\u1e6b\u1e6f\u1e97\"))\n  call assert_equal(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\", toupper(\"u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u1ee7\"))\n  call assert_equal(\"V\u1e7c\", toupper(\"v\u1e7d\"))\n  call assert_equal(\"W\u0174\u1e80\u1e82\u1e84\u1e86\u1e98\", toupper(\"w\u0175\u1e81\u1e83\u1e85\u1e87\u1e98\"))\n  call assert_equal(\"\u1e8a\u1e8c\", toupper(\"\u1e8b\u1e8d\"))\n  call assert_equal(\"Y\u00dd\u0178\u0176\u1e8e\u1e99\u1ef2\u1ef6\u1ef8\", toupper(\"y\u00fd\u00ff\u0177\u1e8f\u1e99\u1ef3\u1ef7\u1ef9\"))\n  call assert_equal(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\", toupper(\"z\u017a\u017c\u017e\u01b6\u1e91\u1e95\"))\n\n  \" Test that uppercase diacritics, which should remain unchanged.\n  call assert_equal(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\", toupper(\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u1ea2\"))\n  call assert_equal(\"B\u1e02\u1e06\", toupper(\"B\u1e02\u1e06\"))\n  call assert_equal(\"C\u00c7\u0106\u0108\u010a\u010c\", toupper(\"C\u00c7\u0106\u0108\u010a\u010c\"))\n  call assert_equal(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\", toupper(\"D\u010e\u0110\u1e0a\u1e0e\u1e10\"))\n  call assert_equal(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\", toupper(\"E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u1eba\u1ebc\"))\n  call assert_equal(\"F\u1e1e \", toupper(\"F\u1e1e \"))\n  call assert_equal(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\", toupper(\"G\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4\u1e20\"))\n  call assert_equal(\"H\u0124\u0126\u1e22\u1e26\u1e28\", toupper(\"H\u0124\u0126\u1e22\u1e26\u1e28\"))\n  call assert_equal(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\", toupper(\"I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u1ec8\"))\n  call assert_equal(\"J\u0134\", toupper(\"J\u0134\"))\n  call assert_equal(\"K\u0136\u01e8\u1e30\u1e34\", toupper(\"K\u0136\u01e8\u1e30\u1e34\"))\n  call assert_equal(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\", toupper(\"L\u0139\u013b\u013d\u013f\u0141\u1e3a\"))\n  call assert_equal(\"M\u1e3e\u1e40\", toupper(\"M\u1e3e\u1e40\"))\n  call assert_equal(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\", toupper(\"N\u00d1\u0143\u0145\u0147\u1e44\u1e48\"))\n  call assert_equal(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\", toupper(\"O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01a0\u01d1\u01ea\u01ec\u1ece\"))\n  call assert_equal(\"P\u1e54\u1e56\", toupper(\"P\u1e54\u1e56\"))\n  call assert_equal(\"Q\", toupper(\"Q\"))\n  call assert_equal(\"R\u0154\u0156\u0158\u1e58\u1e5e\", toupper(\"R\u0154\u0156\u0158\u1e58\u1e5e\"))\n  call assert_equal(\"S\u015a\u015c\u015e\u0160\u1e60\", toupper(\"S\u015a\u015c\u015e\u0160\u1e60\"))\n  call assert_equal(\"T\u0162\u0164\u0166\u1e6a\u1e6e\", toupper(\"T\u0162\u0164\u0166\u1e6a\u1e6e\"))\n  call assert_equal(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\", toupper(\"U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u1ee6\"))\n  call assert_equal(\"V\u1e7c\", toupper(\"V\u1e7c\"))\n  call assert_equal(\"W\u0174\u1e80\u1e82\u1e84\u1e86\", toupper(\"W\u0174\u1e80\u1e82\u1e84\u1e86\"))\n  call assert_equal(\"X\u1e8a\u1e8c\", toupper(\"X\u1e8a\u1e8c\"))\n  call assert_equal(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\", toupper(\"Y\u00dd\u0176\u0178\u1e8e\u1ef2\u1ef6\u1ef8\"))\n  call assert_equal(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\", toupper(\"Z\u0179\u017b\u017d\u01b5\u1e90\u1e94\"))\n\n  call assert_equal(\"\u023a \u023e\", toupper(\"\u2c65 \u2c66\"))\n\n  \" This call to toupper with invalid utf8 sequence used to cause access to\n  \" invalid memory.\n  call toupper(\"\\xC0\\x80\\xC0\")\n  call toupper(\"123\\xC0\\x80\\xC0\")\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(\"ABC\", toupper(\"abc\"))\n  let &encoding = save_enc\nendfunc\n\nfunc Test_tr()\n  call assert_equal('foo', tr('bar', 'bar', 'foo'))\n  call assert_equal('zxy', 'cab'->tr('abc', 'xyz'))\n  call assert_fails(\"let s=tr([], 'abc', 'def')\", 'E730:')\n  call assert_fails(\"let s=tr('abc', [], 'def')\", 'E730:')\n  call assert_fails(\"let s=tr('abc', 'abc', [])\", 'E730:')\n  call assert_fails(\"let s=tr('abcd', 'abcd', 'def')\", 'E475:')\n  set encoding=latin1\n  call assert_fails(\"let s=tr('abcd', 'abcd', 'def')\", 'E475:')\n  call assert_equal('hEllO', tr('hello', 'eo', 'EO'))\n  call assert_equal('hello', tr('hello', 'xy', 'ab'))\n  call assert_fails('call tr(\"abc\", \"123\", \"\u2081\u2082\")', 'E475:')\n  set encoding=utf8\nendfunc\n\n\" Tests for the mode() function\nlet current_modes = ''\nfunc Save_mode()\n  let g:current_modes = mode(0) . '-' . mode(1)\n  return ''\nendfunc\n\n\" Test for the mode() function\nfunc Test_mode()\n  new\n  call append(0, [\"Blue Ball Black\", \"Brown Band Bowl\", \"\"])\n\n  \" Only complete from the current buffer.\n  set complete=.\n\n  inoremap <F2> <C-R>=Save_mode()<CR>\n  xnoremap <F2> <Cmd>call Save_mode()<CR>\n\n  normal! 3G\n  exe \"normal i\\<F2>\\<Esc>\"\n  call assert_equal('i-i', g:current_modes)\n  \" i_CTRL-P: Multiple matches\n  exe \"normal i\\<C-G>uBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-P: Single match\n  exe \"normal iBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X\n  exe \"normal iBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ix', g:current_modes)\n  \" i_CTRL-X CTRL-P: Multiple matches\n  exe \"normal iBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P: Single match\n  exe \"normal iBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal iBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: Multiple matches\n  exe \"normal i\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: Single match\n  exe \"normal iBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-P: No match\n  exe \"normal iCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-P: No match\n  exe \"normal iCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n  \" i_CTRL-X CTRL-L: No match\n  exe \"normal iabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('i-ic', g:current_modes)\n\n  exe \"normal R\\<F2>\\<Esc>\"\n  call assert_equal('R-R', g:current_modes)\n  \" R_CTRL-P: Multiple matches\n  exe \"normal RBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-P: Single match\n  exe \"normal RBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X\n  exe \"normal RBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rx', g:current_modes)\n  \" R_CTRL-X CTRL-P: Multiple matches\n  exe \"normal RBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P: Single match\n  exe \"normal RBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal RBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: Multiple matches\n  exe \"normal R\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: Single match\n  exe \"normal RBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-P: No match\n  exe \"normal RCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-P: No match\n  exe \"normal RCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n  \" R_CTRL-X CTRL-L: No match\n  exe \"normal Rabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rc', g:current_modes)\n\n  exe \"normal gR\\<F2>\\<Esc>\"\n  call assert_equal('R-Rv', g:current_modes)\n  \" gR_CTRL-P: Multiple matches\n  exe \"normal gRBa\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-P: Single match\n  exe \"normal gRBro\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X\n  exe \"normal gRBa\\<C-X>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvx', g:current_modes)\n  \" gR_CTRL-X CTRL-P: Multiple matches\n  exe \"normal gRBa\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P: Single match\n  exe \"normal gRBro\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P + CTRL-P: Single match\n  exe \"normal gRBro\\<C-X>\\<C-P>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: Multiple matches\n  exe \"normal gR\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: Single match\n  exe \"normal gRBlu\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-P: No match\n  exe \"normal gRCom\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-P: No match\n  exe \"normal gRCom\\<C-X>\\<C-P>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n  \" gR_CTRL-X CTRL-L: No match\n  exe \"normal gRabc\\<C-X>\\<C-L>\\<F2>\\<Esc>u\"\n  call assert_equal('R-Rvc', g:current_modes)\n\n  call assert_equal('n', 0->mode())\n  call assert_equal('n', 1->mode())\n\n  \" i_CTRL-O\n  exe \"normal i\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niI\", g:current_modes)\n\n  \" R_CTRL-O\n  exe \"normal R\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niR\", g:current_modes)\n\n  \" gR_CTRL-O\n  exe \"normal gR\\<C-O>:call Save_mode()\\<Cr>\\<Esc>\"\n  call assert_equal(\"n-niV\", g:current_modes)\n\n  \" How to test operator-pending mode?\n\n  call feedkeys(\"v\", 'xt')\n  call assert_equal('v', mode())\n  call assert_equal('v', mode(1))\n  call feedkeys(\"\\<Esc>V\", 'xt')\n  call assert_equal('V', mode())\n  call assert_equal('V', mode(1))\n  call feedkeys(\"\\<Esc>\\<C-V>\", 'xt')\n  call assert_equal(\"\\<C-V>\", mode())\n  call assert_equal(\"\\<C-V>\", mode(1))\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  call feedkeys(\"gh\", 'xt')\n  call assert_equal('s', mode())\n  call assert_equal('s', mode(1))\n  call feedkeys(\"\\<Esc>gH\", 'xt')\n  call assert_equal('S', mode())\n  call assert_equal('S', mode(1))\n  call feedkeys(\"\\<Esc>g\\<C-H>\", 'xt')\n  call assert_equal(\"\\<C-S>\", mode())\n  call assert_equal(\"\\<C-S>\", mode(1))\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  \" v_CTRL-O\n  exe \"normal gh\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"v-vs\", g:current_modes)\n  exe \"normal gH\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"V-Vs\", g:current_modes)\n  exe \"normal g\\<C-H>\\<C-O>\\<F2>\\<Esc>\"\n  call assert_equal(\"\\<C-V>-\\<C-V>s\", g:current_modes)\n\n  call feedkeys(\":echo \\<C-R>=Save_mode()\\<C-U>\\<CR>\", 'xt')\n  call assert_equal('c-c', g:current_modes)\n  call feedkeys(\"gQecho \\<C-R>=Save_mode()\\<CR>\\<CR>vi\\<CR>\", 'xt')\n  call assert_equal('c-cv', g:current_modes)\n  call feedkeys(\"Qcall Save_mode()\\<CR>vi\\<CR>\", 'xt')\n  call assert_equal('c-ce', g:current_modes)\n  \" How to test Ex mode?\n\n  \" Test mode in operatorfunc (it used to be Operator-pending).\n  set operatorfunc=OperatorFunc\n  function OperatorFunc(_)\n    call Save_mode()\n  endfunction\n  execute \"normal! g@l\\<Esc>\"\n  call assert_equal('n-n', g:current_modes)\n  execute \"normal! i\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niI', g:current_modes)\n  execute \"normal! R\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niR', g:current_modes)\n  execute \"normal! gR\\<C-o>g@l\\<Esc>\"\n  call assert_equal('n-niV', g:current_modes)\n\n  if has('terminal')\n    term\n    call feedkeys(\"\\<C-W>N\", 'xt')\n    call assert_equal('n', mode())\n    call assert_equal('nt', mode(1))\n    call feedkeys(\"aexit\\<CR>\", 'xt')\n  endif\n\n  bwipe!\n  iunmap <F2>\n  xunmap <F2>\n  set complete&\n  set operatorfunc&\n  delfunction OperatorFunc\nendfunc\n\n\" Test for append()\nfunc Test_append()\n  enew!\n  split\n  call assert_equal(0, append(1, []))\n  call assert_equal(0, append(1, test_null_list()))\n  call assert_equal(0, append(0, [\"foo\"]))\n  call assert_equal(0, append(1, []))\n  call assert_equal(0, append(1, test_null_list()))\n  call assert_equal(0, append(8, []))\n  call assert_equal(0, append(9, test_null_list()))\n  call assert_equal(['foo', ''], getline(1, '$'))\n  split\n  only\n  undo\n  undo\n\n  \" Using $ instead of '$' must give an error\n  call assert_fails(\"call append($, 'foobar')\", 'E116:')\n\n  call assert_fails(\"call append({}, '')\", ['E728:', 'E728:'])\nendfunc\n\n\" Test for setline()\nfunc Test_setline()\n  new\n  call setline(0, [\"foo\"])\n  call setline(0, [])\n  call setline(0, test_null_list())\n  call setline(1, [\"bar\"])\n  call setline(1, [])\n  call setline(1, test_null_list())\n  call setline(2, [])\n  call setline(2, test_null_list())\n  call setline(3, [])\n  call setline(3, test_null_list())\n  call setline(2, [\"baz\"])\n  call assert_equal(['bar', 'baz'], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_getbufvar()\n  let bnr = bufnr('%')\n  let b:var_num = '1234'\n  let def_num = '5678'\n  call assert_equal('1234', getbufvar(bnr, 'var_num'))\n  call assert_equal('1234', getbufvar(bnr, 'var_num', def_num))\n\n  let bd = getbufvar(bnr, '')\n  call assert_equal('1234', bd['var_num'])\n  call assert_true(exists(\"bd['changedtick']\"))\n  call assert_equal(2, len(bd))\n\n  let bd2 = getbufvar(bnr, '', def_num)\n  call assert_equal(bd, bd2)\n\n  unlet b:var_num\n  call assert_equal(def_num, getbufvar(bnr, 'var_num', def_num))\n  call assert_equal('', getbufvar(bnr, 'var_num'))\n\n  let bd = getbufvar(bnr, '')\n  call assert_equal(1, len(bd))\n  let bd = getbufvar(bnr, '',def_num)\n  call assert_equal(1, len(bd))\n\n  call assert_equal('', getbufvar(9999, ''))\n  call assert_equal(def_num, getbufvar(9999, '', def_num))\n  unlet def_num\n\n  call assert_equal(0, getbufvar(bnr, '&autoindent'))\n  call assert_equal(0, getbufvar(bnr, '&autoindent', 1))\n\n  \" Set and get a buffer-local variable\n  call setbufvar(bnr, 'bufvar_test', ['one', 'two'])\n  call assert_equal(['one', 'two'], getbufvar(bnr, 'bufvar_test'))\n\n  \" Open new window with forced option values\n  set fileformats=unix,dos\n  new ++ff=dos ++bin ++enc=iso-8859-2\n  call assert_equal('dos', getbufvar(bufnr('%'), '&fileformat'))\n  call assert_equal(1, getbufvar(bufnr('%'), '&bin'))\n  call assert_equal('iso-8859-2', getbufvar(bufnr('%'), '&fenc'))\n  close\n\n  \" Get the b: dict.\n  let b:testvar = 'one'\n  new\n  let b:testvar = 'two'\n  let thebuf = bufnr()\n  wincmd w\n  call assert_equal('two', getbufvar(thebuf, 'testvar'))\n  call assert_equal('two', getbufvar(thebuf, '').testvar)\n  bwipe!\n\n  set fileformats&\nendfunc\n\nfunc Test_last_buffer_nr()\n  call assert_equal(bufnr('$'), last_buffer_nr())\nendfunc\n\nfunc Test_stridx()\n  call assert_equal(-1, stridx('', 'l'))\n  call assert_equal(0,  stridx('', ''))\n  call assert_equal(0,  'hello'->stridx(''))\n  call assert_equal(-1, stridx('hello', 'L'))\n  call assert_equal(2,  stridx('hello', 'l', -1))\n  call assert_equal(2,  stridx('hello', 'l', 0))\n  call assert_equal(2,  'hello'->stridx('l', 1))\n  call assert_equal(3,  stridx('hello', 'l', 3))\n  call assert_equal(-1, stridx('hello', 'l', 4))\n  call assert_equal(-1, stridx('hello', 'l', 10))\n  call assert_equal(2,  stridx('hello', 'll'))\n  call assert_equal(-1, stridx('hello', 'hello world'))\n  call assert_fails(\"let n=stridx('hello', [])\", 'E730:')\n  call assert_fails(\"let n=stridx([], 'l')\", 'E730:')\nendfunc\n\nfunc Test_strridx()\n  call assert_equal(-1, strridx('', 'l'))\n  call assert_equal(0,  strridx('', ''))\n  call assert_equal(5,  strridx('hello', ''))\n  call assert_equal(-1, strridx('hello', 'L'))\n  call assert_equal(3,  'hello'->strridx('l'))\n  call assert_equal(3,  strridx('hello', 'l', 10))\n  call assert_equal(3,  strridx('hello', 'l', 3))\n  call assert_equal(2,  strridx('hello', 'l', 2))\n  call assert_equal(-1, strridx('hello', 'l', 1))\n  call assert_equal(-1, strridx('hello', 'l', 0))\n  call assert_equal(-1, strridx('hello', 'l', -1))\n  call assert_equal(2,  strridx('hello', 'll'))\n  call assert_equal(-1, strridx('hello', 'hello world'))\n  call assert_fails(\"let n=strridx('hello', [])\", 'E730:')\n  call assert_fails(\"let n=strridx([], 'l')\", 'E730:')\nendfunc\n\nfunc Test_match_func()\n  call assert_equal(4,  match('testing', 'ing'))\n  call assert_equal(4,  'testing'->match('ing', 2))\n  call assert_equal(-1, match('testing', 'ing', 5))\n  call assert_equal(-1, match('testing', 'ing', 8))\n  call assert_equal(1, match(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(-1, match(['vim', 'testing', 'execute'], 'img'))\n  call assert_fails(\"let x=match('vim', [])\", 'E730:')\n  call assert_equal(3, match(['a', 'b', 'c', 'a'], 'a', 1))\n  call assert_equal(-1, match(['a', 'b', 'c', 'a'], 'a', 5))\n  call assert_equal(4,  match('testing', 'ing', -1))\n  call assert_fails(\"let x=match('testing', 'ing', 0, [])\", 'E745:')\n  call assert_equal(-1, match(test_null_list(), 2))\n  call assert_equal(-1, match('abc', '\\\\%('))\nendfunc\n\nfunc Test_matchend()\n  call assert_equal(7,  matchend('testing', 'ing'))\n  call assert_equal(7,  'testing'->matchend('ing', 2))\n  call assert_equal(-1, matchend('testing', 'ing', 5))\n  call assert_equal(-1, matchend('testing', 'ing', 8))\n  call assert_equal(match(['vim', 'testing', 'execute'], 'ing'), matchend(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(match(['vim', 'testing', 'execute'], 'img'), matchend(['vim', 'testing', 'execute'], 'img'))\nendfunc\n\nfunc Test_matchlist()\n  call assert_equal(['acd', 'a', '', 'c', 'd', '', '', '', '', ''],  matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)'))\n  call assert_equal(['d', '', '', '', 'd', '', '', '', '', ''],  'acd'->matchlist('\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)', 2))\n  call assert_equal([],  matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)', 4))\nendfunc\n\nfunc Test_matchstr()\n  call assert_equal('ing',  matchstr('testing', 'ing'))\n  call assert_equal('ing',  'testing'->matchstr('ing', 2))\n  call assert_equal('', matchstr('testing', 'ing', 5))\n  call assert_equal('', matchstr('testing', 'ing', 8))\n  call assert_equal('testing', matchstr(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal('', matchstr(['vim', 'testing', 'execute'], 'img'))\nendfunc\n\nfunc Test_matchstrpos()\n  call assert_equal(['ing', 4, 7], matchstrpos('testing', 'ing'))\n  call assert_equal(['ing', 4, 7], 'testing'->matchstrpos('ing', 2))\n  call assert_equal(['', -1, -1], matchstrpos('testing', 'ing', 5))\n  call assert_equal(['', -1, -1], matchstrpos('testing', 'ing', 8))\n  call assert_equal(['ing', 1, 4, 7], matchstrpos(['vim', 'testing', 'execute'], 'ing'))\n  call assert_equal(['', -1, -1, -1], matchstrpos(['vim', 'testing', 'execute'], 'img'))\n  call assert_equal(['', -1, -1], matchstrpos(test_null_list(), '\\a'))\nendfunc\n\nfunc Test_nextnonblank_prevnonblank()\n  new\ninsert\nThis\n\n\nis\n\na\nTest\n.\n  call assert_equal(0, nextnonblank(-1))\n  call assert_equal(0, nextnonblank(0))\n  call assert_equal(1, nextnonblank(1))\n  call assert_equal(4, 2->nextnonblank())\n  call assert_equal(4, nextnonblank(3))\n  call assert_equal(4, nextnonblank(4))\n  call assert_equal(6, nextnonblank(5))\n  call assert_equal(6, nextnonblank(6))\n  call assert_equal(7, nextnonblank(7))\n  call assert_equal(0, 8->nextnonblank())\n\n  call assert_equal(0, prevnonblank(-1))\n  call assert_equal(0, prevnonblank(0))\n  call assert_equal(1, 1->prevnonblank())\n  call assert_equal(1, prevnonblank(2))\n  call assert_equal(1, prevnonblank(3))\n  call assert_equal(4, prevnonblank(4))\n  call assert_equal(4, 5->prevnonblank())\n  call assert_equal(6, prevnonblank(6))\n  call assert_equal(7, prevnonblank(7))\n  call assert_equal(0, prevnonblank(8))\n  bw!\nendfunc\n\nfunc Test_byte2line_line2byte()\n  new\n  set endofline\n  call setline(1, ['a', 'bc', 'd'])\n\n  set fileformat=unix\n  call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],\n  \\                 map(range(-1, 8), 'byte2line(v:val)'))\n  call assert_equal([-1, -1, 1, 3, 6, 8, -1],\n  \\                 map(range(-1, 5), 'line2byte(v:val)'))\n\n  set fileformat=mac\n  call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],\n  \\                 map(range(-1, 8), 'v:val->byte2line()'))\n  call assert_equal([-1, -1, 1, 3, 6, 8, -1],\n  \\                 map(range(-1, 5), 'v:val->line2byte()'))\n\n  set fileformat=dos\n  call assert_equal([-1, -1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, -1],\n  \\                 map(range(-1, 11), 'byte2line(v:val)'))\n  call assert_equal([-1, -1, 1, 4, 8, 11, -1],\n  \\                 map(range(-1, 5), 'line2byte(v:val)'))\n\n  bw!\n  set noendofline nofixendofline\n  normal a-\n  for ff in [\"unix\", \"mac\", \"dos\"]\n    let &fileformat = ff\n    call assert_equal(1, line2byte(1))\n    call assert_equal(2, line2byte(2))  \" line2byte(line(\"$\") + 1) is the buffer size plus one (as per :help line2byte).\n  endfor\n\n  set endofline& fixendofline& fileformat&\n  bw!\nendfunc\n\n\" Test for byteidx() using a character index\nfunc Test_byteidx()\n  let a = '.\u00e9.' \" one char of two bytes\n  call assert_equal(0, byteidx(a, 0))\n  call assert_equal(1, byteidx(a, 1))\n  call assert_equal(3, byteidx(a, 2))\n  call assert_equal(4, byteidx(a, 3))\n  call assert_equal(-1, byteidx(a, 4))\n\n  let b = '.e\u0301.' \" normal e with composing char\n  call assert_equal(0, b->byteidx(0))\n  call assert_equal(1, b->byteidx(1))\n  call assert_equal(4, b->byteidx(2))\n  call assert_equal(5, b->byteidx(3))\n  call assert_equal(-1, b->byteidx(4))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidx(str, 0))\n  call assert_equal(1, byteidx(str, 1))\n  call assert_equal(6, byteidx(str, 2))\n  call assert_equal(7, byteidx(str, 3))\n  call assert_equal(12, byteidx(str, 4))\n  call assert_equal(-1, byteidx(str, 5))\n\n  \" empty string\n  call assert_equal(0, byteidx('', 0))\n  call assert_equal(-1, byteidx('', 1))\n\n  \" error cases\n  call assert_fails(\"call byteidx([], 0)\", 'E730:')\n  call assert_fails(\"call byteidx('abc', [])\", 'E745:')\n  call assert_fails(\"call byteidx('abc', 0, {})\", ['E728:', 'E728:'])\n  call assert_fails(\"call byteidx('abc', 0, -1)\", ['E1023:', 'E1023:'])\nendfunc\n\n\" Test for byteidxcomp() using a character index\nfunc Test_byteidxcomp()\n  let a = '.\u00e9.' \" one char of two bytes\n  call assert_equal(0, byteidxcomp(a, 0))\n  call assert_equal(1, byteidxcomp(a, 1))\n  call assert_equal(3, byteidxcomp(a, 2))\n  call assert_equal(4, byteidxcomp(a, 3))\n  call assert_equal(-1, byteidxcomp(a, 4))\n\n  let b = '.e\u0301.' \" normal e with composing char\n  call assert_equal(0, b->byteidxcomp(0))\n  call assert_equal(1, b->byteidxcomp(1))\n  call assert_equal(2, b->byteidxcomp(2))\n  call assert_equal(4, b->byteidxcomp(3))\n  call assert_equal(5, b->byteidxcomp(4))\n  call assert_equal(-1, b->byteidxcomp(5))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidxcomp(str, 0))\n  call assert_equal(1, byteidxcomp(str, 1))\n  call assert_equal(2, byteidxcomp(str, 2))\n  call assert_equal(4, byteidxcomp(str, 3))\n  call assert_equal(6, byteidxcomp(str, 4))\n  call assert_equal(7, byteidxcomp(str, 5))\n  call assert_equal(8, byteidxcomp(str, 6))\n  call assert_equal(10, byteidxcomp(str, 7))\n  call assert_equal(12, byteidxcomp(str, 8))\n  call assert_equal(-1, byteidxcomp(str, 9))\n\n  \" empty string\n  call assert_equal(0, byteidxcomp('', 0))\n  call assert_equal(-1, byteidxcomp('', 1))\n\n  \" error cases\n  call assert_fails(\"call byteidxcomp([], 0)\", 'E730:')\n  call assert_fails(\"call byteidxcomp('abc', [])\", 'E745:')\n  call assert_fails(\"call byteidxcomp('abc', 0, {})\", ['E728:', 'E728:'])\n  call assert_fails(\"call byteidxcomp('abc', 0, -1)\", ['E1023:', 'E1023:'])\nendfunc\n\n\" Test for byteidx() using a UTF-16 index\nfunc Test_byteidx_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(3)\n    call assert_equal(i, byteidx(str, i, v:true))\n  endfor\n  call assert_equal(3, byteidx(str, 3, v:true))\n  call assert_equal(-1, byteidx(str, 4, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(3, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(6, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" string with two byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(1, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(5, byteidx(str, 4, v:true))\n  call assert_equal(9, byteidx(str, 5, v:true))\n  call assert_equal(10, byteidx(str, 6, v:true))\n  call assert_equal(-1, byteidx(str, 7, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(4, byteidx(str, 2, v:true))\n  call assert_equal(5, byteidx(str, 3, v:true))\n  call assert_equal(8, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidx(str, 0, v:true))\n  call assert_equal(1, byteidx(str, 1, v:true))\n  call assert_equal(6, byteidx(str, 2, v:true))\n  call assert_equal(7, byteidx(str, 3, v:true))\n  call assert_equal(12, byteidx(str, 4, v:true))\n  call assert_equal(-1, byteidx(str, 5, v:true))\n\n  \" empty string\n  call assert_equal(0, byteidx('', 0, v:true))\n  call assert_equal(-1, byteidx('', 1, v:true))\n\n  \" error cases\n  call assert_fails('call byteidx(str, 0, [])', 'E745:')\nendfunc\n\n\" Test for byteidxcomp() using a UTF-16 index\nfunc Test_byteidxcomp_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(3)\n    call assert_equal(i, byteidxcomp(str, i, v:true))\n  endfor\n  call assert_equal(3, byteidxcomp(str, 3, v:true))\n  call assert_equal(-1, byteidxcomp(str, 4, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(3, byteidxcomp(str, 2, v:true))\n  call assert_equal(5, byteidxcomp(str, 3, v:true))\n  call assert_equal(6, byteidxcomp(str, 4, v:true))\n  call assert_equal(-1, byteidxcomp(str, 5, v:true))\n\n  \" string with two byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(1, byteidxcomp(str, 2, v:true))\n  call assert_equal(5, byteidxcomp(str, 3, v:true))\n  call assert_equal(5, byteidxcomp(str, 4, v:true))\n  call assert_equal(9, byteidxcomp(str, 5, v:true))\n  call assert_equal(10, byteidxcomp(str, 6, v:true))\n  call assert_equal(-1, byteidxcomp(str, 7, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(2, byteidxcomp(str, 2, v:true))\n  call assert_equal(4, byteidxcomp(str, 3, v:true))\n  call assert_equal(5, byteidxcomp(str, 4, v:true))\n  call assert_equal(6, byteidxcomp(str, 5, v:true))\n  call assert_equal(8, byteidxcomp(str, 6, v:true))\n  call assert_equal(-1, byteidxcomp(str, 7, v:true))\n  call assert_fails('call byteidxcomp(str, 0, [])', 'E745:')\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, byteidxcomp(str, 0, v:true))\n  call assert_equal(1, byteidxcomp(str, 1, v:true))\n  call assert_equal(2, byteidxcomp(str, 2, v:true))\n  call assert_equal(4, byteidxcomp(str, 3, v:true))\n  call assert_equal(6, byteidxcomp(str, 4, v:true))\n  call assert_equal(7, byteidxcomp(str, 5, v:true))\n  call assert_equal(8, byteidxcomp(str, 6, v:true))\n  call assert_equal(10, byteidxcomp(str, 7, v:true))\n  call assert_equal(12, byteidxcomp(str, 8, v:true))\n  call assert_equal(-1, byteidxcomp(str, 9, v:true))\n\n  \" empty string\n  call assert_equal(0, byteidxcomp('', 0, v:true))\n  call assert_equal(-1, byteidxcomp('', 1, v:true))\n\n  \" error cases\n  call assert_fails('call byteidxcomp(str, 0, [])', 'E745:')\nendfunc\n\n\" Test for charidx() using a byte index\nfunc Test_charidx()\n  let a = 'xa\u0301b\u0301y'\n  call assert_equal(0, charidx(a, 0))\n  call assert_equal(1, charidx(a, 3))\n  call assert_equal(2, charidx(a, 4))\n  call assert_equal(3, charidx(a, 7))\n  call assert_equal(4, charidx(a, 8))\n  call assert_equal(-1, charidx(a, 9))\n  call assert_equal(-1, charidx(a, -1))\n\n  \" count composing characters\n  call assert_equal(0, a->charidx(0, 1))\n  call assert_equal(2, a->charidx(2, 1))\n  call assert_equal(3, a->charidx(4, 1))\n  call assert_equal(5, a->charidx(7, 1))\n  call assert_equal(6, a->charidx(8, 1))\n  call assert_equal(-1, a->charidx(9, 1))\n\n  \" empty string\n  call assert_equal(0, charidx('', 0))\n  call assert_equal(-1, charidx('', 1))\n  call assert_equal(0, charidx('', 0, 1))\n  call assert_equal(-1, charidx('', 1, 1))\n\n  \" error cases\n  call assert_equal(0, charidx(test_null_string(), 0))\n  call assert_equal(-1, charidx(test_null_string(), 1))\n  call assert_fails('let x = charidx([], 1)', 'E1174:')\n  call assert_fails('let x = charidx(\"abc\", [])', 'E1210:')\n  call assert_fails('let x = charidx(\"abc\", 1, [])', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, -1)', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, 2)', 'E1212:')\nendfunc\n\n\" Test for charidx() using a UTF-16 index\nfunc Test_charidx_from_utf16_index()\n  \" string with single byte characters\n  let str = \"abc\"\n  for i in range(4)\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(-1, charidx(str, 4, v:false, v:true))\n\n  \" string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  call assert_equal(0, charidx(str, 0, v:false, v:true))\n  call assert_equal(1, charidx(str, 1, v:false, v:true))\n  call assert_equal(2, charidx(str, 2, v:false, v:true))\n  call assert_equal(3, charidx(str, 3, v:false, v:true))\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n\n  \" string with four byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, charidx(str, 0, v:false, v:true))\n  call assert_equal(1, charidx(str, 1, v:false, v:true))\n  call assert_equal(1, charidx(str, 2, v:false, v:true))\n  call assert_equal(2, charidx(str, 3, v:false, v:true))\n  call assert_equal(2, charidx(str, 4, v:false, v:true))\n  call assert_equal(3, charidx(str, 5, v:false, v:true))\n  call assert_equal(4, charidx(str, 6, v:false, v:true))\n  call assert_equal(-1, charidx(str, 7, v:false, v:true))\n\n  \" string with composing characters\n  let str = '-a\u0301-b\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, charidx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(6, charidx(str, 6, v:true, v:true))\n  call assert_equal(-1, charidx(str, 7, v:true, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, charidx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, charidx(str, 4, v:false, v:true))\n  call assert_equal(-1, charidx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, charidx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(8, charidx(str, 8, v:true, v:true))\n  call assert_equal(-1, charidx(str, 9, v:true, v:true))\n\n  \" empty string\n  call assert_equal(0, charidx('', 0, v:false, v:true))\n  call assert_equal(-1, charidx('', 1, v:false, v:true))\n  call assert_equal(0, charidx('', 0, v:true, v:true))\n  call assert_equal(-1, charidx('', 1, v:true, v:true))\n\n  \" error cases\n  call assert_equal(0, charidx('', 0, v:false, v:true))\n  call assert_equal(-1, charidx('', 1, v:false, v:true))\n  call assert_equal(0, charidx('', 0, v:true, v:true))\n  call assert_equal(-1, charidx('', 1, v:true, v:true))\n  call assert_equal(0, charidx(test_null_string(), 0, v:false, v:true))\n  call assert_equal(-1, charidx(test_null_string(), 1, v:false, v:true))\n  call assert_fails('let x = charidx(\"abc\", 1, v:false, [])', 'E1212:')\n  call assert_fails('let x = charidx(\"abc\", 1, v:true, [])', 'E1212:')\nendfunc\n\n\" Test for utf16idx() using a byte index\nfunc Test_utf16idx_from_byteidx()\n  \" UTF-16 index of a string with single byte characters\n  let str = \"abc\"\n  for i in range(4)\n    call assert_equal(i, utf16idx(str, i))\n  endfor\n  call assert_equal(-1, utf16idx(str, 4))\n\n  \" UTF-16 index of a string with two byte characters\n  let str = 'a\u00a9\u00a9b'\n  call assert_equal(0, str->utf16idx(0))\n  call assert_equal(1, str->utf16idx(1))\n  call assert_equal(1, str->utf16idx(2))\n  call assert_equal(2, str->utf16idx(3))\n  call assert_equal(2, str->utf16idx(4))\n  call assert_equal(3, str->utf16idx(5))\n  call assert_equal(4, str->utf16idx(6))\n  call assert_equal(-1, str->utf16idx(7))\n\n  \" UTF-16 index of a string with four byte characters\n  let str = 'a\ud83d\ude0a\ud83d\ude0ab'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(1, utf16idx(str, 4))\n  call assert_equal(3, utf16idx(str, 5))\n  call assert_equal(3, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(3, utf16idx(str, 8))\n  call assert_equal(5, utf16idx(str, 9))\n  call assert_equal(6, utf16idx(str, 10))\n  call assert_equal(-1, utf16idx(str, 11))\n\n  \" UTF-16 index of a string with composing characters\n  let str = '-a\u0301-b\u0301'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(2, utf16idx(str, 4))\n  call assert_equal(3, utf16idx(str, 5))\n  call assert_equal(3, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(4, utf16idx(str, 8))\n  call assert_equal(-1, utf16idx(str, 9))\n  call assert_equal(0, utf16idx(str, 0, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:true))\n  call assert_equal(2, utf16idx(str, 2, v:true))\n  call assert_equal(2, utf16idx(str, 3, v:true))\n  call assert_equal(3, utf16idx(str, 4, v:true))\n  call assert_equal(4, utf16idx(str, 5, v:true))\n  call assert_equal(5, utf16idx(str, 6, v:true))\n  call assert_equal(5, utf16idx(str, 7, v:true))\n  call assert_equal(6, utf16idx(str, 8, v:true))\n  call assert_equal(-1, utf16idx(str, 9, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  call assert_equal(0, utf16idx(str, 0))\n  call assert_equal(1, utf16idx(str, 1))\n  call assert_equal(1, utf16idx(str, 2))\n  call assert_equal(1, utf16idx(str, 3))\n  call assert_equal(1, utf16idx(str, 4))\n  call assert_equal(1, utf16idx(str, 5))\n  call assert_equal(2, utf16idx(str, 6))\n  call assert_equal(3, utf16idx(str, 7))\n  call assert_equal(3, utf16idx(str, 8))\n  call assert_equal(3, utf16idx(str, 9))\n  call assert_equal(3, utf16idx(str, 10))\n  call assert_equal(3, utf16idx(str, 11))\n  call assert_equal(4, utf16idx(str, 12))\n  call assert_equal(-1, utf16idx(str, 13))\n  call assert_equal(0, utf16idx(str, 0, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:true))\n  call assert_equal(2, utf16idx(str, 2, v:true))\n  call assert_equal(2, utf16idx(str, 3, v:true))\n  call assert_equal(3, utf16idx(str, 4, v:true))\n  call assert_equal(3, utf16idx(str, 5, v:true))\n  call assert_equal(4, utf16idx(str, 6, v:true))\n  call assert_equal(5, utf16idx(str, 7, v:true))\n  call assert_equal(6, utf16idx(str, 8, v:true))\n  call assert_equal(6, utf16idx(str, 9, v:true))\n  call assert_equal(7, utf16idx(str, 10, v:true))\n  call assert_equal(7, utf16idx(str, 11, v:true))\n  call assert_equal(8, utf16idx(str, 12, v:true))\n  call assert_equal(-1, utf16idx(str, 13, v:true))\n\n  \" empty string\n  call assert_equal(0, utf16idx('', 0))\n  call assert_equal(-1, utf16idx('', 1))\n  call assert_equal(0, utf16idx('', 0, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:true))\n\n  \" error cases\n  call assert_equal(0, utf16idx(\"\", 0))\n  call assert_equal(-1, utf16idx(\"\", 1))\n  call assert_equal(-1, utf16idx(\"abc\", -1))\n  call assert_equal(0, utf16idx(test_null_string(), 0))\n  call assert_equal(-1, utf16idx(test_null_string(), 1))\n  call assert_fails('let l = utf16idx([], 0)', 'E1174:')\n  call assert_fails('let l = utf16idx(\"ab\", [])', 'E1210:')\n  call assert_fails('let l = utf16idx(\"ab\", 0, [])', 'E1212:')\nendfunc\n\n\" Test for utf16idx() using a character index\nfunc Test_utf16idx_from_charidx()\n  let str = \"abc\"\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(3, utf16idx(str, 3, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 4, v:false, v:true))\n\n  \" UTF-16 index of a string with two byte characters\n  let str = \"a\u00a9\u00a9b\"\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n\n  \" UTF-16 index of a string with four byte characters\n  let str = \"a\ud83d\ude0a\ud83d\ude0ab\"\n  call assert_equal(0, utf16idx(str, 0, v:false, v:true))\n  call assert_equal(1, utf16idx(str, 1, v:false, v:true))\n  call assert_equal(3, utf16idx(str, 2, v:false, v:true))\n  call assert_equal(5, utf16idx(str, 3, v:false, v:true))\n  call assert_equal(6, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n\n  \" UTF-16 index of a string with composing characters\n  let str = '-a\u0301-b\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, utf16idx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(6, utf16idx(str, 6, v:true, v:true))\n  call assert_equal(-1, utf16idx(str, 7, v:true, v:true))\n\n  \" string with multiple composing characters\n  let str = '-a\u0328\u0301-a\u0328\u0301'\n  for i in str->strcharlen()->range()\n    call assert_equal(i, utf16idx(str, i, v:false, v:true))\n  endfor\n  call assert_equal(4, utf16idx(str, 4, v:false, v:true))\n  call assert_equal(-1, utf16idx(str, 5, v:false, v:true))\n  for i in str->strchars()->range()\n    call assert_equal(i, utf16idx(str, i, v:true, v:true))\n  endfor\n  call assert_equal(8, utf16idx(str, 8, v:true, v:true))\n  call assert_equal(-1, utf16idx(str, 9, v:true, v:true))\n\n  \" empty string\n  call assert_equal(0, utf16idx('', 0, v:false, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:false, v:true))\n  call assert_equal(0, utf16idx('', 0, v:true, v:true))\n  call assert_equal(-1, utf16idx('', 1, v:true, v:true))\n\n  \" error cases\n  call assert_equal(0, utf16idx(test_null_string(), 0, v:true, v:true))\n  call assert_equal(-1, utf16idx(test_null_string(), 1, v:true, v:true))\n  call assert_fails('let l = utf16idx(\"ab\", 0, v:false, [])', 'E1212:')\nendfunc\n\n\" Test for strutf16len()\nfunc Test_strutf16len()\n  call assert_equal(3, strutf16len('abc'))\n  call assert_equal(3, 'abc'->strutf16len(v:true))\n  call assert_equal(4, strutf16len('a\u00a9\u00a9b'))\n  call assert_equal(4, strutf16len('a\u00a9\u00a9b', v:true))\n  call assert_equal(6, strutf16len('a\ud83d\ude0a\ud83d\ude0ab'))\n  call assert_equal(6, strutf16len('a\ud83d\ude0a\ud83d\ude0ab', v:true))\n  call assert_equal(4, strutf16len('-a\u0301-b\u0301'))\n  call assert_equal(6, strutf16len('-a\u0301-b\u0301', v:true))\n  call assert_equal(4, strutf16len('-a\u0328\u0301-a\u0328\u0301'))\n  call assert_equal(8, strutf16len('-a\u0328\u0301-a\u0328\u0301', v:true))\n  call assert_equal(0, strutf16len(''))\n\n  \" error cases\n  call assert_fails('let l = strutf16len([])', 'E1174:')\n  call assert_fails('let l = strutf16len(\"a\", [])', 'E1212:')\n  call assert_equal(0, strutf16len(test_null_string()))\nendfunc\n\nfunc Test_count()\n  let l = ['a', 'a', 'A', 'b']\n  call assert_equal(2, count(l, 'a'))\n  call assert_equal(1, count(l, 'A'))\n  call assert_equal(1, count(l, 'b'))\n  call assert_equal(0, count(l, 'B'))\n\n  call assert_equal(2, count(l, 'a', 0))\n  call assert_equal(1, count(l, 'A', 0))\n  call assert_equal(1, count(l, 'b', 0))\n  call assert_equal(0, count(l, 'B', 0))\n\n  call assert_equal(3, count(l, 'a', 1))\n  call assert_equal(3, count(l, 'A', 1))\n  call assert_equal(1, count(l, 'b', 1))\n  call assert_equal(1, count(l, 'B', 1))\n  call assert_equal(0, count(l, 'c', 1))\n\n  call assert_equal(1, count(l, 'a', 0, 1))\n  call assert_equal(2, count(l, 'a', 1, 1))\n  call assert_fails('call count(l, \"a\", 0, 10)', 'E684:')\n  call assert_fails('call count(l, \"a\", [])', 'E745:')\n\n  let d = {1: 'a', 2: 'a', 3: 'A', 4: 'b'}\n  call assert_equal(2, count(d, 'a'))\n  call assert_equal(1, count(d, 'A'))\n  call assert_equal(1, count(d, 'b'))\n  call assert_equal(0, count(d, 'B'))\n\n  call assert_equal(2, count(d, 'a', 0))\n  call assert_equal(1, count(d, 'A', 0))\n  call assert_equal(1, count(d, 'b', 0))\n  call assert_equal(0, count(d, 'B', 0))\n\n  call assert_equal(3, count(d, 'a', 1))\n  call assert_equal(3, count(d, 'A', 1))\n  call assert_equal(1, count(d, 'b', 1))\n  call assert_equal(1, count(d, 'B', 1))\n  call assert_equal(0, count(d, 'c', 1))\n\n  call assert_fails('call count(d, \"a\", 0, 1)', 'E474:')\n\n  call assert_equal(0, count(\"foo\", \"bar\"))\n  call assert_equal(1, count(\"foo\", \"oo\"))\n  call assert_equal(2, count(\"foo\", \"o\"))\n  call assert_equal(0, count(\"foo\", \"O\"))\n  call assert_equal(2, count(\"foo\", \"O\", 1))\n  call assert_equal(2, count(\"fooooo\", \"oo\"))\n  call assert_equal(0, count(\"foo\", \"\"))\n\n  call assert_fails('call count(0, 0)', 'E706:')\n  call assert_fails('call count(\"\", \"\", {})', ['E728:', 'E728:'])\nendfunc\n\nfunc Test_changenr()\n  new Xchangenr\n  call assert_equal(0, changenr())\n  norm ifoo\n  call assert_equal(1, changenr())\n  set undolevels=10\n  norm Sbar\n  call assert_equal(2, changenr())\n  undo\n  call assert_equal(1, changenr())\n  redo\n  call assert_equal(2, changenr())\n  bw!\n  set undolevels&\nendfunc\n\nfunc Test_filewritable()\n  new Xfilewritable\n  write!\n  call assert_equal(1, filewritable('Xfilewritable'))\n\n  call assert_notequal(0, setfperm('Xfilewritable', 'r--r-----'))\n  call assert_equal(0, filewritable('Xfilewritable'))\n\n  call assert_notequal(0, setfperm('Xfilewritable', 'rw-r-----'))\n  call assert_equal(1, 'Xfilewritable'->filewritable())\n\n  call assert_equal(0, filewritable('doesnotexist'))\n\n  call mkdir('Xwritedir', 'D')\n  call assert_equal(2, filewritable('Xwritedir'))\n\n  call delete('Xfilewritable')\n  bw!\nendfunc\n\nfunc Test_Executable()\n  if has('win32')\n    call assert_equal(1, executable('notepad'))\n    call assert_equal(1, 'notepad.exe'->executable())\n    call assert_equal(0, executable('notepad.exe.exe'))\n    call assert_equal(0, executable('shell32.dll'))\n    call assert_equal(0, executable('win.ini'))\n\n    \" get \"notepad\" path and remove the leading drive and sep. (ex. 'C:\\')\n    let notepadcmd = exepath('notepad.exe')\n    let driveroot = notepadcmd[:2]\n    let notepadcmd = notepadcmd[3:]\n    new\n    \" check that the relative path works in /\n    execute 'lcd' driveroot\n    call assert_equal(1, executable(notepadcmd))\n    call assert_equal(driveroot .. notepadcmd, notepadcmd->exepath())\n    bwipe\n\n    \" create \"notepad.bat\"\n    call mkdir('Xnotedir')\n    let notepadbat = fnamemodify('Xnotedir/notepad.bat', ':p')\n    call writefile([], notepadbat)\n    new\n    \" check that the path and the pathext order is valid\n    lcd Xnotedir\n    let [pathext, $PATHEXT] = [$PATHEXT, '.com;.exe;.bat;.cmd']\n    call assert_equal(notepadbat, exepath('notepad'))\n    let $PATHEXT = pathext\n    \" check for symbolic link\n    execute 'silent !mklink np.bat \"' .. notepadbat .. '\"'\n    call assert_equal(1, executable('./np.bat'))\n    call assert_equal(1, executable('./np'))\n    bwipe\n    eval 'Xnotedir'->delete('rf')\n  elseif has('unix')\n    call assert_equal(1, 'cat'->executable())\n    call assert_equal(0, executable('nodogshere'))\n\n    \" get \"cat\" path and remove the leading /\n    let catcmd = exepath('cat')[1:]\n    new\n    \" check that the relative path works in /\n    lcd /\n    call assert_equal(1, executable(catcmd))\n    let result = catcmd->exepath()\n    \" when using chroot looking for sbin/cat can return bin/cat, that is OK\n    if catcmd =~ '\\<sbin\\>' && result =~ '\\<bin\\>'\n      call assert_equal('/' .. substitute(catcmd, '\\<sbin\\>', 'bin', ''), result)\n    else\n      \" /bin/cat and /usr/bin/cat may be hard linked, we could get either\n      let result = substitute(result, '/usr/bin/cat', '/bin/cat', '')\n      let catcmd = substitute(catcmd, 'usr/bin/cat', 'bin/cat', '')\n      call assert_equal('/' .. catcmd, result)\n    endif\n    bwipe\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_executable_windows_store_apps()\n  CheckMSWindows\n\n  \" Windows Store apps install some 'decoy' .exe that require some careful\n  \" handling as they behave similarly to symlinks.\n  let app_dir = expand(\"$LOCALAPPDATA\\\\Microsoft\\\\WindowsApps\")\n  if !isdirectory(app_dir)\n    return\n  endif\n\n  let save_path = $PATH\n  let $PATH = app_dir\n  \" Ensure executable() finds all the app .exes\n  for entry in readdir(app_dir)\n    if entry =~ '\\.exe$'\n      call assert_true(executable(entry))\n    endif\n  endfor\n\n  let $PATH = save_path\nendfunc\n\nfunc Test_executable_longname()\n  CheckMSWindows\n\n  \" Create a temporary .bat file with 205 characters in the name.\n  \" Maximum length of a filename (including the path) on MS-Windows is 259\n  \" characters.\n  \" See https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation\n  let len = 259 - getcwd()->len() - 6\n  if len > 200\n    let len = 200\n  endif\n\n  let fname = 'X' . repeat('\u3042', len) . '.bat'\n  call writefile([], fname)\n  call assert_equal(1, executable(fname))\n  call delete(fname)\nendfunc\n\nfunc Test_hostname()\n  let hostname_vim = hostname()\n  if has('unix')\n    let hostname_system = systemlist('uname -n')[0]\n    call assert_equal(hostname_vim, hostname_system)\n  endif\nendfunc\n\nfunc Test_getpid()\n  \" getpid() always returns the same value within a vim instance.\n  call assert_equal(getpid(), getpid())\n  if has('unix')\n    call assert_equal(systemlist('echo $PPID')[0], string(getpid()))\n  endif\nendfunc\n\nfunc Test_hlexists()\n  call assert_equal(0, hlexists('does_not_exist'))\n  call assert_equal(0, 'Number'->hlexists())\n  call assert_equal(0, highlight_exists('does_not_exist'))\n  call assert_equal(0, highlight_exists('Number'))\n  syntax on\n  call assert_equal(0, hlexists('does_not_exist'))\n  call assert_equal(1, hlexists('Number'))\n  call assert_equal(0, highlight_exists('does_not_exist'))\n  call assert_equal(1, highlight_exists('Number'))\n  syntax off\nendfunc\n\n\" Test for the col() function\nfunc Test_col()\n  new\n  call setline(1, 'abcdef')\n  norm gg4|mx6|mY2|\n  call assert_equal(2, col('.'))\n  call assert_equal(7, col('$'))\n  call assert_equal(2, col('v'))\n  call assert_equal(4, col(\"'x\"))\n  call assert_equal(6, col(\"'Y\"))\n  call assert_equal(2, [1, 2]->col())\n  call assert_equal(7, col([1, '$']))\n\n  call assert_equal(0, col(''))\n  call assert_equal(0, col('x'))\n  call assert_equal(0, col([2, '$']))\n  call assert_equal(0, col([1, 100]))\n  call assert_equal(0, col([1]))\n  call assert_equal(0, col(test_null_list()))\n  call assert_fails('let c = col({})', 'E1222:')\n  call assert_fails('let c = col(\".\", [])', 'E1210:')\n\n  \" test for getting the visual start column\n  func T()\n    let g:Vcol = col('v')\n    return ''\n  endfunc\n  let g:Vcol = 0\n  xmap <expr> <F2> T()\n  exe \"normal gg3|ve\\<F2>\"\n  call assert_equal(3, g:Vcol)\n  xunmap <F2>\n  delfunc T\n\n  \" Test for the visual line start and end marks '< and '>\n  call setline(1, ['one', 'one two', 'one two three'])\n  \"normal! ggVG\n  call feedkeys(\"ggVG\\<Esc>\", 'xt')\n  call assert_equal(1, col(\"'<\"))\n  call assert_equal(14, col(\"'>\"))\n  \" Delete the last line of the visually selected region\n  $d\n  call assert_notequal(14, col(\"'>\"))\n\n  \" Test with 'virtualedit'\n  set virtualedit=all\n  call cursor(1, 10)\n  call assert_equal(4, col('.'))\n  set virtualedit&\n\n  \" Test for getting the column number in another window\n  let winid = win_getid()\n  new\n  call win_execute(winid, 'normal 1G$')\n  call assert_equal(3, col('.', winid))\n  call win_execute(winid, 'normal 2G')\n  call assert_equal(8, col('$', winid))\n  call assert_equal(0, col('.', 5001))\n\n  bw!\nendfunc\n\n\" Test for input()\nfunc Test_input_func()\n  \" Test for prompt with multiple lines\n  redir => v\n  call feedkeys(\":let c = input(\\\"A\\\\nB\\\\nC\\\\n? \\\")\\<CR>B\\<CR>\", 'xt')\n  redir END\n  call assert_equal(\"B\", c)\n  call assert_equal(['A', 'B', 'C'], split(v, \"\\n\"))\n\n  \" Test for default value\n  call feedkeys(\":let c = input('color? ', 'red')\\<CR>\\<CR>\", 'xt')\n  call assert_equal('red', c)\n\n  \" Test for completion at the input prompt\n  func! Tcomplete(arglead, cmdline, pos)\n    return \"item1\\nitem2\\nitem3\"\n  endfunc\n  call feedkeys(\":let c = input('Q? ', '', 'custom,Tcomplete')\\<CR>\"\n        \\ .. \"\\<C-A>\\<CR>\", 'xt')\n  delfunc Tcomplete\n  call assert_equal('item1 item2 item3', c)\n\n  \" Test for using special characters as default input\n  call feedkeys(\":let c = input('name? ', \\\"x\\\\<BS>y\\\")\\<CR>\\<CR>\", 'xt')\n  call assert_equal('y', c)\n\n  \" Test for using text with composing characters as default input\n  call feedkeys(\":let c = input('name? ', \\\"a\u0303\u0333\\\")\\<CR>\\<CR>\", 'xt')\n  call assert_equal('a\u0303\u0333', c)\n\n  \" Test for using <CR> as default input\n  call feedkeys(\":let c = input('name? ', \\\"\\\\<CR>\\\")\\<CR>x\\<CR>\", 'xt')\n  call assert_equal(' x', c)\n\n  call assert_fails(\"call input('F:', '', 'invalid')\", 'E180:')\n  call assert_fails(\"call input('F:', '', [])\", 'E730:')\nendfunc\n\n\" Test for the inputdialog() function\nfunc Test_inputdialog()\n  set timeout timeoutlen=10\n  if has('gui_running')\n    call assert_fails('let v=inputdialog([], \"xx\")', 'E730:')\n    call assert_fails('let v=inputdialog(\"Q\", [])', 'E730:')\n  else\n    call feedkeys(\":let v=inputdialog('Q:', 'xx', 'yy')\\<CR>\\<CR>\", 'xt')\n    call assert_equal('xx', v)\n    call feedkeys(\":let v=inputdialog('Q:', 'xx', 'yy')\\<CR>\\<Esc>\", 'xt')\n    call assert_equal('yy', v)\n  endif\n  set timeout& timeoutlen&\nendfunc\n\n\" Test for inputlist()\nfunc Test_inputlist()\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>1\\<cr>\", 'tx')\n  call assert_equal(1, c)\n  call feedkeys(\":let c = ['Select color:', '1. red', '2. green', '3. blue']->inputlist()\\<cr>2\\<cr>\", 'tx')\n  call assert_equal(2, c)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>3\\<cr>\", 'tx')\n  call assert_equal(3, c)\n\n  \" CR to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<cr>\", 'tx')\n  call assert_equal(0, c)\n\n  \" Esc to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<Esc>\", 'tx')\n  call assert_equal(0, c)\n\n  \" q to cancel\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>q\", 'tx')\n  call assert_equal(0, c)\n\n  \" Cancel after inputting a number\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>5q\", 'tx')\n  call assert_equal(0, c)\n\n  \" Use backspace to delete characters in the prompt\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>1\\<BS>3\\<BS>2\\<cr>\", 'tx')\n  call assert_equal(2, c)\n\n  \" Use mouse to make a selection\n  call test_setmouse(&lines - 3, 2)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<LeftMouse>\", 'tx')\n  call assert_equal(1, c)\n  \" Mouse click outside of the list\n  call test_setmouse(&lines - 6, 2)\n  call feedkeys(\":let c = inputlist(['Select color:', '1. red', '2. green', '3. blue'])\\<cr>\\<LeftMouse>\", 'tx')\n  call assert_equal(-2, c)\n\n  call assert_fails('call inputlist(\"\")', 'E686:')\n  call assert_fails('call inputlist(test_null_list())', 'E686:')\nendfunc\n\nfunc Test_range_inputlist()\n  \" flush out any garbage left in the buffer\n  while getchar(0)\n  endwhile\n\n  call feedkeys(\":let result = inputlist(range(10))\\<CR>1\\<CR>\", 'x')\n  call assert_equal(1, result)\n  call feedkeys(\":let result = inputlist(range(3, 10))\\<CR>1\\<CR>\", 'x')\n  call assert_equal(1, result)\n\n  unlet result\nendfunc\n\nfunc Test_balloon_show()\n  CheckFeature balloon_eval\n\n  \" This won't do anything but must not crash either.\n  call balloon_show('hi!')\n  if !has('gui_running')\n    call balloon_show(range(3))\n    call balloon_show([])\n  endif\nendfunc\n\nfunc Test_setbufvar_options()\n  \" This tests that aucmd_prepbuf() and aucmd_restbuf() properly restore the\n  \" window layout and cursor position.\n  call assert_equal(1, winnr('$'))\n  split dummy_preview\n  resize 2\n  set winfixheight winfixwidth\n  let prev_id = win_getid()\n\n  wincmd j\n  let wh = winheight(0)\n  let dummy_buf = bufnr('dummy_buf1', v:true)\n  call setbufvar(dummy_buf, '&buftype', 'nofile')\n  execute 'belowright vertical split #' . dummy_buf\n  call assert_equal(wh, winheight(0))\n  let dum1_id = win_getid()\n  call setline(1, 'foo')\n  normal! V$\n  call assert_equal(4, col('.'))\n  call setbufvar('dummy_preview', '&buftype', 'nofile')\n  call assert_equal(4, col('.'))\n\n  wincmd h\n  let wh = winheight(0)\n  call setline(1, 'foo')\n  normal! V$\n  call assert_equal(4, col('.'))\n  let dummy_buf = bufnr('dummy_buf2', v:true)\n  eval 'nofile'->setbufvar(dummy_buf, '&buftype')\n  call assert_equal(4, col('.'))\n  execute 'belowright vertical split #' . dummy_buf\n  call assert_equal(wh, winheight(0))\n\n  bwipe!\n  call win_gotoid(prev_id)\n  bwipe!\n  call win_gotoid(dum1_id)\n  bwipe!\nendfunc\n\nfunc Test_setbufvar_keep_window_title()\n  CheckRunVimInTerminal\n  if !has('title') || empty(&t_ts)\n    throw \"Skipped: can't get/set title\"\n  endif\n\n  let lines =<< trim END\n      set title\n      edit Xa.txt\n      let g:buf = bufadd('Xb.txt')\n      inoremap <F2> <C-R>=setbufvar(g:buf, '&autoindent', 1) ?? ''<CR>\n  END\n  call writefile(lines, 'Xsetbufvar', 'D')\n  let buf = RunVimInTerminal('-S Xsetbufvar', {})\n  call WaitForAssert({-> assert_match('Xa.txt', term_gettitle(buf))}, 1000)\n\n  call term_sendkeys(buf, \"i\\<F2>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call TermWait(buf)\n  call assert_match('Xa.txt', term_gettitle(buf))\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_redo_in_nested_functions()\n  nnoremap g. :set opfunc=Operator<CR>g@\n  function Operator( type, ... )\n     let @x = 'XXX'\n     execute 'normal! g`[' . (a:type ==# 'line' ? 'V' : 'v') . 'g`]' . '\"xp'\n  endfunction\n\n  function! Apply()\n      5,6normal! .\n  endfunction\n\n  new\n  call setline(1, repeat(['some \"quoted\" text', 'more \"quoted\" text'], 3))\n  1normal g.i\"\n  call assert_equal('some \"XXX\" text', getline(1))\n  3,4normal .\n  call assert_equal('some \"XXX\" text', getline(3))\n  call assert_equal('more \"XXX\" text', getline(4))\n  call Apply()\n  call assert_equal('some \"XXX\" text', getline(5))\n  call assert_equal('more \"XXX\" text', getline(6))\n  bwipe!\n\n  nunmap g.\n  delfunc Operator\n  delfunc Apply\nendfunc\n\nfunc Test_trim()\n  call assert_equal(\"Testing\", trim(\"  \\t\\r\\r\\x0BTesting  \\t\\n\\r\\n\\t\\x0B\\x0B\"))\n  call assert_equal(\"Testing\", \"  \\t  \\r\\r\\n\\n\\x0BTesting  \\t\\n\\r\\n\\t\\x0B\\x0B\"->trim())\n  call assert_equal(\"RESERVE\", trim(\"xyz \\twwRESERVEzyww \\t\\t\", \" wxyz\\t\"))\n  call assert_equal(\"wRE    \\tSERVEzyww\", trim(\"wRE    \\tSERVEzyww\"))\n  call assert_equal(\"abcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\"))\n  call assert_equal(\"\\tabcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\", \" \"))\n  call assert_equal(\" \\tabcd\\t     xxxx   tail\", trim(\" \\tabcd\\t     xxxx   tail\", \"abx\"))\n  call assert_equal(\"RESERVE\", trim(\"\u4f60RESERVE\u597d\", \"\u4f60\u597d\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\", trim(\"\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60\", \"\u4f60\u597d\"))\n  call assert_equal(\"\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60\", trim(\" \\n\\r\\r   \u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", ))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    \u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", \" \u4f60\u597d\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    tteesstttt\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B ttestt\", \" \u4f60\u597dtes\"))\n  call assert_equal(\"\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B\", trim(\"    tteesstttt\u4f60\u597d\u60a8R E SER V E\u65e9\u597d\u4f60\u4f60    \\t  \\x0B ttestt\", \"   \u4f60\u4f60\u4f60\u597d\u597d\u597dtttsses\"))\n  call assert_equal(\"\u7559\u4e0b\", trim(\"\u8fd9\u4e9b\u4e9b\u4e0d\u8981\u8fd9\u4e9b\u7559\u4e0b\u8fd9\u4e9b\", \"\u8fd9\u4e9b\u4e0d\u8981\"))\n  call assert_equal(\"\", trim(\"\", \"\"))\n  call assert_equal(\"a\", trim(\"a\", \"\"))\n  call assert_equal(\"\", trim(\"\", \"a\"))\n\n  call assert_equal(\"vim\", trim(\"  vim  \", \" \", 0))\n  call assert_equal(\"vim  \", trim(\"  vim  \", \" \", 1))\n  call assert_equal(\"  vim\", trim(\"  vim  \", \" \", 2))\n  call assert_fails('eval trim(\"  vim  \", \" \", [])', 'E745:')\n  call assert_fails('eval trim(\"  vim  \", \" \", -1)', 'E475:')\n  call assert_fails('eval trim(\"  vim  \", \" \", 3)', 'E475:')\n  call assert_fails('eval trim(\"  vim  \", 0)', 'E1174:')\n\n  let chars = join(map(range(1, 0x20) + [0xa0], {n -> n->nr2char()}), '')\n  call assert_equal(\"x\", trim(chars . \"x\" . chars))\n\n  call assert_fails('let c=trim([])', 'E730:')\nendfunc\n\n\" Test for reg_recording() and reg_executing()\nfunc Test_reg_executing_and_recording()\n  let s:reg_stat = ''\n  func s:save_reg_stat()\n    let s:reg_stat = reg_recording() . ':' . reg_executing()\n    return ''\n  endfunc\n\n  new\n  call s:save_reg_stat()\n  call assert_equal(':', s:reg_stat)\n  call feedkeys(\"qa\\\"=s:save_reg_stat()\\<CR>pq\", 'xt')\n  call assert_equal('a:', s:reg_stat)\n  call feedkeys(\"@a\", 'xt')\n  call assert_equal(':a', s:reg_stat)\n  call feedkeys(\"qb@aq\", 'xt')\n  call assert_equal('b:a', s:reg_stat)\n  call feedkeys(\"q\\\"\\\"=s:save_reg_stat()\\<CR>pq\", 'xt')\n  call assert_equal('\":', s:reg_stat)\n\n  \" :normal command saves and restores reg_executing\n  let s:reg_stat = ''\n  let @q = \":call TestFunc()\\<CR>:call s:save_reg_stat()\\<CR>\"\n  func TestFunc() abort\n    normal! ia\n  endfunc\n  call feedkeys(\"@q\", 'xt')\n  call assert_equal(':q', s:reg_stat)\n  delfunc TestFunc\n\n  \" getchar() command saves and restores reg_executing\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:regs += [reg_executing()]\n    let g:typed = getchar(0)\n    let g:regs += [reg_executing()]\n  endfunc\n  call feedkeys(\"@qy\", 'xt')\n  call assert_equal(char2nr(\"y\"), g:typed)\n  call assert_equal(['q', 'q'], g:regs)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed\n  unlet g:regs\n\n  \" input() command saves and restores reg_executing\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:regs += [reg_executing()]\n    let g:typed = '?'->input()\n    let g:regs += [reg_executing()]\n  endfunc\n  call feedkeys(\"@qy\\<CR>\", 'xt')\n  call assert_equal(\"y\", g:typed)\n  call assert_equal(['q', 'q'], g:regs)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed\n  unlet g:regs\n\n  bwipe!\n  delfunc s:save_reg_stat\n  unlet s:reg_stat\nendfunc\n\nfunc Test_inputsecret()\n  map W :call TestFunc()<CR>\n  let @q = \"W\"\n  let g:typed1 = ''\n  let g:typed2 = ''\n  let g:regs = []\n  func TestFunc() abort\n    let g:typed1 = '?'->inputsecret()\n    let g:typed2 = inputsecret('password: ')\n  endfunc\n  call feedkeys(\"@qsomething\\<CR>else\\<CR>\", 'xt')\n  call assert_equal(\"something\", g:typed1)\n  call assert_equal(\"else\", g:typed2)\n  delfunc TestFunc\n  unmap W\n  unlet g:typed1\n  unlet g:typed2\nendfunc\n\nfunc Test_getchar()\n  call feedkeys('a', '')\n  call assert_equal(char2nr('a'), getchar())\n  call assert_equal(0, getchar(0))\n  call assert_equal(0, getchar(1))\n\n  call feedkeys('a', '')\n  call assert_equal('a', getcharstr())\n  call assert_equal('', getcharstr(0))\n  call assert_equal('', getcharstr(1))\n\n  call feedkeys(\"\\<M-F2>\", '')\n  call assert_equal(\"\\<M-F2>\", getchar(0))\n  call assert_equal(0, getchar(0))\n\n  call setline(1, 'xxxx')\n  call test_setmouse(1, 3)\n  let v:mouse_win = 9\n  let v:mouse_winid = 9\n  let v:mouse_lnum = 9\n  let v:mouse_col = 9\n  call feedkeys(\"\\<S-LeftMouse>\", '')\n  call assert_equal(\"\\<S-LeftMouse>\", getchar())\n  call assert_equal(1, v:mouse_win)\n  call assert_equal(win_getid(1), v:mouse_winid)\n  call assert_equal(1, v:mouse_lnum)\n  call assert_equal(3, v:mouse_col)\n  enew!\nendfunc\n\nfunc Test_libcall_libcallnr()\n  CheckFeature libcall\n\n  if has('win32')\n    let libc = 'msvcrt.dll'\n  elseif has('mac')\n    let libc = 'libSystem.B.dylib'\n  elseif executable('ldd')\n    let libc = matchstr(split(system('ldd ' . GetVimProg())), '/libc\\.so\\>')\n  endif\n  if get(l:, 'libc', '') ==# ''\n    \" On Unix, libc.so can be in various places.\n    if has('linux')\n      \" There is not documented but regarding the 1st argument of glibc's\n      \" dlopen an empty string and nullptr are equivalent, so using an empty\n      \" string for the 1st argument of libcall allows to call functions.\n      let libc = ''\n    elseif has('sun')\n      \" Set the path to libc.so according to the architecture.\n      let test_bits = system('file ' . GetVimProg())\n      let test_arch = system('uname -p')\n      if test_bits =~ '64-bit' && test_arch =~ 'sparc'\n        let libc = '/usr/lib/sparcv9/libc.so'\n      elseif test_bits =~ '64-bit' && test_arch =~ 'i386'\n        let libc = '/usr/lib/amd64/libc.so'\n      else\n        let libc = '/usr/lib/libc.so'\n      endif\n    else\n      \" Unfortunately skip this test until a good way is found.\n      return\n    endif\n  endif\n\n  if has('win32')\n    call assert_equal($USERPROFILE, 'USERPROFILE'->libcall(libc, 'getenv'))\n  else\n    call assert_equal($HOME, 'HOME'->libcall(libc, 'getenv'))\n  endif\n\n  \" If function returns NULL, libcall() should return an empty string.\n  call assert_equal('', libcall(libc, 'getenv', 'X_ENV_DOES_NOT_EXIT'))\n\n  \" Test libcallnr() with string and integer argument.\n  call assert_equal(4, 'abcd'->libcallnr(libc, 'strlen'))\n  call assert_equal(char2nr('A'), char2nr('a')->libcallnr(libc, 'toupper'))\n\n  call assert_fails(\"call libcall(libc, 'Xdoesnotexist_', '')\", ['', 'E364:'])\n  call assert_fails(\"call libcallnr(libc, 'Xdoesnotexist_', '')\", ['', 'E364:'])\n\n  call assert_fails(\"call libcall('Xdoesnotexist_', 'getenv', 'HOME')\", ['', 'E364:'])\n  call assert_fails(\"call libcallnr('Xdoesnotexist_', 'strlen', 'abcd')\", ['', 'E364:'])\nendfunc\n\nsandbox function Fsandbox()\n  normal ix\nendfunc\n\nfunc Test_func_sandbox()\n  sandbox let F = {-> 'hello'}\n  call assert_equal('hello', F())\n\n  sandbox let F = {-> \"normal ix\\<Esc>\"->execute()}\n  call assert_fails('call F()', 'E48:')\n  unlet F\n\n  call assert_fails('call Fsandbox()', 'E48:')\n  delfunc Fsandbox\n\n  \" From a sandbox try to set a predefined variable (which cannot be modified\n  \" from a sandbox)\n  call assert_fails('sandbox let v:lnum = 10', 'E794:')\nendfunc\n\nfunc EditAnotherFile()\n  let word = expand('<cword>')\n  edit Xfuncrange2\nendfunc\n\nfunc Test_func_range_with_edit()\n  \" Define a function that edits another buffer, then call it with a range that\n  \" is invalid in that buffer.\n  call writefile(['just one line'], 'Xfuncrange2', 'D')\n  new\n  eval 10->range()->setline(1)\n  write Xfuncrange1\n  call assert_fails('5,8call EditAnotherFile()', 'E16:')\n\n  call delete('Xfuncrange1')\n  bwipe!\nendfunc\n\nfunc Test_func_exists_on_reload()\n  call writefile(['func ExistingFunction()', 'echo \"yes\"', 'endfunc'], 'Xfuncexists', 'D')\n  call assert_equal(0, exists('*ExistingFunction'))\n  source Xfuncexists\n  call assert_equal(1, '*ExistingFunction'->exists())\n  \" Redefining a function when reloading a script is OK.\n  source Xfuncexists\n  call assert_equal(1, exists('*ExistingFunction'))\n\n  \" But redefining in another script is not OK.\n  call writefile(['func ExistingFunction()', 'echo \"yes\"', 'endfunc'], 'Xfuncexists2', 'D')\n  call assert_fails('source Xfuncexists2', 'E122:')\n\n  \" Defining a new function from the cmdline should fail if the function is\n  \" already defined\n  call assert_fails('call feedkeys(\":func ExistingFunction()\\<CR>\", \"xt\")', 'E122:')\n\n  delfunc ExistingFunction\n  call assert_equal(0, exists('*ExistingFunction'))\n  call writefile([\n\t\\ 'func ExistingFunction()', 'echo \"yes\"', 'endfunc',\n\t\\ 'func ExistingFunction()', 'echo \"no\"', 'endfunc',\n\t\\ ], 'Xfuncexists')\n  call assert_fails('source Xfuncexists', 'E122:')\n  call assert_equal(1, exists('*ExistingFunction'))\n\n  delfunc ExistingFunction\nendfunc\n\n\" Test confirm({msg} [, {choices} [, {default} [, {type}]]])\nfunc Test_confirm()\n  CheckUnix\n  CheckNotGui\n\n  call feedkeys('o', 'L')\n  let a = confirm('Press O to proceed')\n  call assert_equal(1, a)\n\n  call feedkeys('y', 'L')\n  let a = 'Are you sure?'->confirm(\"&Yes\\n&No\")\n  call assert_equal(1, a)\n\n  call feedkeys('n', 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(2, a)\n\n  \" confirm() should return 0 when pressing CTRL-C.\n  call feedkeys(\"\\<C-C>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(0, a)\n\n  \" <Esc> requires another character to avoid it being seen as the start of an\n  \" escape sequence.  Zero should be harmless.\n  eval \"\\<Esc>0\"->feedkeys('L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(0, a)\n\n  \" Default choice is returned when pressing <CR>.\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\")\n  call assert_equal(1, a)\n\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\", 2)\n  call assert_equal(2, a)\n\n  call feedkeys(\"\\<CR>\", 'L')\n  let a = confirm('Are you sure?', \"&Yes\\n&No\", 0)\n  call assert_equal(0, a)\n\n  \" Test with the {type} 4th argument\n  for type in ['Error', 'Question', 'Info', 'Warning', 'Generic']\n    call feedkeys('y', 'L')\n    let a = confirm('Are you sure?', \"&Yes\\n&No\\n\", 1, type)\n    call assert_equal(1, a)\n  endfor\n\n  call assert_fails('call confirm([])', 'E730:')\n  call assert_fails('call confirm(\"Are you sure?\", [])', 'E730:')\n  call assert_fails('call confirm(\"Are you sure?\", \"&Yes\\n&No\\n\", [])', 'E745:')\n  call assert_fails('call confirm(\"Are you sure?\", \"&Yes\\n&No\\n\", 0, [])', 'E730:')\nendfunc\n\nfunc Test_platform_name()\n  \" The system matches at most only one name.\n  let names = ['amiga', 'bsd', 'hpux', 'linux', 'mac', 'qnx', 'sun', 'vms', 'win32', 'win32unix']\n  call assert_inrange(0, 1, len(filter(copy(names), 'has(v:val)')))\n\n  \" Is Unix?\n  call assert_equal(has('bsd'), has('bsd') && has('unix'))\n  call assert_equal(has('hpux'), has('hpux') && has('unix'))\n  call assert_equal(has('linux'), has('linux') && has('unix'))\n  call assert_equal(has('mac'), has('mac') && has('unix'))\n  call assert_equal(has('qnx'), has('qnx') && has('unix'))\n  call assert_equal(has('sun'), has('sun') && has('unix'))\n  call assert_equal(has('win32'), has('win32') && !has('unix'))\n  call assert_equal(has('win32unix'), has('win32unix') && has('unix'))\n\n  if has('unix') && executable('uname')\n    let uname = system('uname')\n    \" GNU userland on BSD kernels (e.g., GNU/kFreeBSD) don't have BSD defined\n    call assert_equal(uname =~? '\\%(GNU/k\\w\\+\\)\\@<!BSD\\|DragonFly', has('bsd'))\n    call assert_equal(uname =~? 'HP-UX', has('hpux'))\n    call assert_equal(uname =~? 'Linux', has('linux'))\n    call assert_equal(uname =~? 'Darwin', has('mac'))\n    call assert_equal(uname =~? 'QNX', has('qnx'))\n    call assert_equal(uname =~? 'SunOS', has('sun'))\n    call assert_equal(uname =~? 'CYGWIN\\|MSYS', has('win32unix'))\n  endif\nendfunc\n\nfunc Test_readdir()\n  call mkdir('Xreaddir', 'R')\n  call writefile([], 'Xreaddir/foo.txt')\n  call writefile([], 'Xreaddir/bar.txt')\n  call mkdir('Xreaddir/dir')\n\n  \" All results\n  let files = readdir('Xreaddir')\n  call assert_equal(['bar.txt', 'dir', 'foo.txt'], sort(files))\n\n  \" Only results containing \"f\"\n  let files = 'Xreaddir'->readdir({ x -> stridx(x, 'f') != -1 })\n  call assert_equal(['foo.txt'], sort(files))\n\n  \" Only .txt files\n  let files = readdir('Xreaddir', { x -> x =~ '.txt$' })\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Only .txt files with string\n  let files = readdir('Xreaddir', 'v:val =~ \".txt$\"')\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Limit to 1 result.\n  let l = []\n  let files = readdir('Xreaddir', {x -> len(add(l, x)) == 2 ? -1 : 1})\n  call assert_equal(1, len(files))\n\n  \" Nested readdir() must not crash\n  let files = readdir('Xreaddir', 'readdir(\"Xreaddir\", \"1\") != []')\n  call sort(files)->assert_equal(['bar.txt', 'dir', 'foo.txt'])\nendfunc\n\nfunc Test_readdirex()\n  call mkdir('Xexdir', 'R')\n  call writefile(['foo'], 'Xexdir/foo.txt')\n  call writefile(['barbar'], 'Xexdir/bar.txt')\n  call mkdir('Xexdir/dir')\n\n  \" All results\n  let files = readdirex('Xexdir')->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'dir', 'foo.txt'], sort(files))\n  let sizes = readdirex('Xexdir')->map({-> v:val.size})\n  call assert_equal([0, 4, 7], sort(sizes))\n\n  \" Only results containing \"f\"\n  let files = 'Xexdir'->readdirex({ e -> stridx(e.name, 'f') != -1 })\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['foo.txt'], sort(files))\n\n  \" Only .txt files\n  let files = readdirex('Xexdir', { e -> e.name =~ '.txt$' })\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Only .txt files with string\n  let files = readdirex('Xexdir', 'v:val.name =~ \".txt$\"')\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(['bar.txt', 'foo.txt'], sort(files))\n\n  \" Limit to 1 result.\n  let l = []\n  let files = readdirex('Xexdir', {e -> len(add(l, e.name)) == 2 ? -1 : 1})\n\t\t\t  \\ ->map({-> v:val.name})\n  call assert_equal(1, len(files))\n\n  \" Nested readdirex() must not crash\n  let files = readdirex('Xexdir', 'readdirex(\"Xexdir\", \"1\") != []')\n\t\t\t  \\ ->map({-> v:val.name})\n  call sort(files)->assert_equal(['bar.txt', 'dir', 'foo.txt'])\n\n  \" report broken link correctly\n  if has(\"unix\")\n    call writefile([], 'Xexdir/abc.txt')\n    call system(\"ln -s Xexdir/abc.txt Xexdir/link\")\n    call delete('Xexdir/abc.txt')\n    let files = readdirex('Xexdir', 'readdirex(\"Xexdir\", \"1\") != []')\n\t\t\t  \\ ->map({-> v:val.name .. '_' .. v:val.type})\n    call sort(files)->assert_equal(\n        \\ ['bar.txt_file', 'dir_dir', 'foo.txt_file', 'link_link'])\n  endif\n\n  call assert_fails('call readdirex(\"doesnotexist\")', 'E484:')\nendfunc\n\nfunc Test_readdirex_sort()\n  CheckUnix\n  \" Skip tests on Mac OS X and Cygwin (does not allow several files with different casing)\n  if has(\"osxdarwin\") || has(\"osx\") || has(\"macunix\") || has(\"win32unix\")\n    throw 'Skipped: Test_readdirex_sort on systems that do not allow this using the default filesystem'\n  endif\n  let _collate = v:collate\n  call mkdir('Xsortdir2', 'R')\n  call writefile(['1'], 'Xsortdir2/README.txt')\n  call writefile(['2'], 'Xsortdir2/Readme.txt')\n  call writefile(['3'], 'Xsortdir2/readme.txt')\n\n  \" 1) default\n  let files = readdirex('Xsortdir2')->map({-> v:val.name})\n  let default = copy(files)\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], files, 'sort using default')\n\n  \" 2) no sorting\n  let files = readdirex('Xsortdir2', 1, #{sort: 'none'})->map({-> v:val.name})\n  let unsorted = copy(files)\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], sort(files), 'unsorted')\n  call assert_fails(\"call readdirex('Xsortdir2', 1, #{slort: 'none'})\", 'E857: Dictionary key \"sort\" required')\n\n  \" 3) sort by case (same as default)\n  let files = readdirex('Xsortdir2', 1, #{sort: 'case'})->map({-> v:val.name})\n  call assert_equal(default, files, 'sort by case')\n\n  \" 4) sort by ignoring case\n  let files = readdirex('Xsortdir2', 1, #{sort: 'icase'})->map({-> v:val.name})\n  call assert_equal(unsorted->sort('i'), files, 'sort by icase')\n\n  \" 5) Default Collation\n  let collate = v:collate\n  lang collate C\n  let files = readdirex('Xsortdir2', 1, #{sort: 'collate'})->map({-> v:val.name})\n  call assert_equal(['README.txt', 'Readme.txt', 'readme.txt'], files, 'sort by C collation')\n\n  \" 6) Collation de_DE\n  \" Switch locale, this may not work on the CI system, if the locale isn't\n  \" available\n  try\n    lang collate de_DE\n    let files = readdirex('Xsortdir2', 1, #{sort: 'collate'})->map({-> v:val.name})\n    call assert_equal(['readme.txt', 'Readme.txt', 'README.txt'], files, 'sort by de_DE collation')\n  catch\n    throw 'Skipped: de_DE collation is not available'\n\n  finally\n    exe 'lang collate' collate\n  endtry\nendfunc\n\nfunc Test_readdir_sort()\n  \" some more cases for testing sorting for readdirex\n  let dir = 'Xsortdir3'\n  call mkdir(dir, 'R')\n  call writefile(['1'], dir .. '/README.txt')\n  call writefile(['2'], dir .. '/Readm.txt')\n  call writefile(['3'], dir .. '/read.txt')\n  call writefile(['4'], dir .. '/Z.txt')\n  call writefile(['5'], dir .. '/a.txt')\n  call writefile(['6'], dir .. '/b.txt')\n\n  \" 1) default\n  let files = readdir(dir)\n  let default = copy(files)\n  call assert_equal(default->sort(), files, 'sort using default')\n\n  \" 2) sort by case (same as default)\n  let files = readdir(dir, '1', #{sort: 'case'})\n  call assert_equal(default, files, 'sort using default')\n\n  \" 3) sort by ignoring case\n  let files = readdir(dir, '1', #{sort: 'icase'})\n  call assert_equal(default->sort('i'), files, 'sort by ignoring case')\n\n  \" 4) collation\n  let collate = v:collate\n  lang collate C\n  let files = readdir(dir, 1, #{sort: 'collate'})\n  call assert_equal(default->sort(), files, 'sort by C collation')\n  exe \"lang collate\" collate\n\n  \" 5) Errors\n  call assert_fails('call readdir(dir, 1, 1)', 'E1206:')\n  call assert_fails('call readdir(dir, 1, #{sorta: 1})')\n  call assert_fails('call readdir(dir, 1, test_null_dict())', 'E1297:')\n  call assert_fails('call readdirex(dir, 1, 1)', 'E1206:')\n  call assert_fails('call readdirex(dir, 1, #{sorta: 1})')\n  call assert_fails('call readdirex(dir, 1, test_null_dict())', 'E1297:')\n\n  \" 6) ignore other values in dict\n  let files = readdir(dir, '1', #{sort: 'c'})\n  call assert_equal(default, files, 'sort using default2')\n\n  \" Cleanup\n  exe \"lang collate\" collate\nendfunc\n\nfunc Test_delete_rf()\n  call mkdir('Xrfdir')\n  call writefile([], 'Xrfdir/foo.txt')\n  call writefile([], 'Xrfdir/bar.txt')\n  call mkdir('Xrfdir/[a-1]')  \" issue #696\n  call writefile([], 'Xrfdir/[a-1]/foo.txt')\n  call writefile([], 'Xrfdir/[a-1]/bar.txt')\n  call assert_true(filereadable('Xrfdir/foo.txt'))\n  call assert_true('Xrfdir/[a-1]/foo.txt'->filereadable())\n\n  call assert_equal(0, delete('Xrfdir', 'rf'))\n  call assert_false(filereadable('Xrfdir/foo.txt'))\n  call assert_false(filereadable('Xrfdir/[a-1]/foo.txt'))\n\n  if has('unix')\n    call mkdir('Xrfdir/Xdir2', 'p')\n    silent !chmod 555 Xrfdir\n    call assert_equal(-1, delete('Xrfdir/Xdir2', 'rf'))\n    call assert_equal(-1, delete('Xrfdir', 'rf'))\n    silent !chmod 755 Xrfdir\n    call assert_equal(0, delete('Xrfdir', 'rf'))\n  endif\nendfunc\n\nfunc Test_call()\n  call assert_equal(3, call('len', [123]))\n  call assert_equal(3, 'len'->call([123]))\n  call assert_fails(\"call call('len', 123)\", 'E1211:')\n  call assert_equal(0, call('', []))\n  call assert_equal(0, call('len', test_null_list()))\n\n  function Mylen() dict\n     return len(self.data)\n  endfunction\n  let mydict = {'data': [0, 1, 2, 3], 'len': function(\"Mylen\")}\n  eval mydict.len->call([], mydict)->assert_equal(4)\n  call assert_fails(\"call call('Mylen', [], 0)\", 'E1206:')\n  call assert_fails('call foo', 'E107:')\n\n  \" These once caused a crash.\n  call call(test_null_function(), [])\n  call call(test_null_partial(), [])\n  call assert_fails('call test_null_function()()', 'E1192:')\n  call assert_fails('call test_null_partial()()', 'E117:')\n\n  let lines =<< trim END\n      let Time = 'localtime'\n      call Time()\n  END\n  call v9.CheckScriptFailure(lines, 'E1085:')\nendfunc\n\nfunc Test_char2nr()\n  call assert_equal(12354, char2nr('\u3042', 1))\n  call assert_equal(120, 'x'->char2nr())\n  set encoding=latin1\n  call assert_equal(120, 'x'->char2nr())\n  set encoding=utf-8\nendfunc\n\nfunc Test_charclass()\n  call assert_equal(0, charclass(' '))\n  call assert_equal(1, charclass('.'))\n  call assert_equal(2, charclass('x'))\n  call assert_equal(3, charclass(\"\\u203c\"))\n  \" this used to crash vim\n  call assert_equal(0, \"xxx\"[-1]->charclass())\nendfunc\n\nfunc Test_eventhandler()\n  call assert_equal(0, eventhandler())\nendfunc\n\nfunc Test_bufadd_bufload()\n  call assert_equal(0, bufexists('someName'))\n  let buf = bufadd('someName')\n  call assert_notequal(0, buf)\n  call assert_equal(1, bufexists('someName'))\n  call assert_equal(0, getbufvar(buf, '&buflisted'))\n  call assert_equal(0, bufloaded(buf))\n  call bufload(buf)\n  call assert_equal(1, bufloaded(buf))\n  call assert_equal([''], getbufline(buf, 1, '$'))\n\n  let curbuf = bufnr('')\n  eval ['some', 'text']->writefile('XotherName')\n  let buf = 'XotherName'->bufadd()\n  call assert_notequal(0, buf)\n  eval 'XotherName'->bufexists()->assert_equal(1)\n  call assert_equal(0, getbufvar(buf, '&buflisted'))\n  call assert_equal(0, bufloaded(buf))\n  eval buf->bufload()\n  call assert_equal(1, bufloaded(buf))\n  call assert_equal(['some', 'text'], getbufline(buf, 1, '$'))\n  call assert_equal(curbuf, bufnr(''))\n\n  let buf1 = bufadd('')\n  let buf2 = bufadd('')\n  call assert_notequal(0, buf1)\n  call assert_notequal(0, buf2)\n  call assert_notequal(buf1, buf2)\n  call assert_equal(1, bufexists(buf1))\n  call assert_equal(1, bufexists(buf2))\n  call assert_equal(0, bufloaded(buf1))\n  exe 'bwipe ' .. buf1\n  call assert_equal(0, bufexists(buf1))\n  call assert_equal(1, bufexists(buf2))\n  exe 'bwipe ' .. buf2\n  call assert_equal(0, bufexists(buf2))\n\n  \" When 'buftype' is \"nofile\" then bufload() does not read the file.\n  \" Other values too.\n  for val in [['nofile', 0],\n            \\ ['nowrite', 1],\n            \\ ['acwrite', 1],\n            \\ ['quickfix', 0],\n            \\ ['help', 1],\n            \\ ['terminal', 0],\n            \\ ['prompt', 0],\n            \\ ['popup', 0],\n            \\ ]\n    bwipe! XotherName\n    let buf = bufadd('XotherName')\n    call setbufvar(buf, '&bt', val[0])\n    call bufload(buf)\n    call assert_equal(val[1] ? ['some', 'text'] : [''], getbufline(buf, 1, '$'), val[0])\n  endfor\n\n  bwipe someName\n  bwipe XotherName\n  call assert_equal(0, bufexists('someName'))\n  call delete('XotherName')\nendfunc\n\nfunc Test_state()\n  CheckRunVimInTerminal\n\n  let getstate = \":echo 'state: ' .. g:state .. '; mode: ' .. g:mode\\<CR>\"\n\n  let lines =<< trim END\n\tcall setline(1, ['one', 'two', 'three'])\n\tmap ;; gg\n\tset complete=.\n\tfunc RunTimer()\n\t  call timer_start(10, {id -> execute('let g:state = state()') .. execute('let g:mode = mode()')})\n\tendfunc\n\tau Filetype foobar let g:state = state()|let g:mode = mode()\n  END\n  call writefile(lines, 'XState')\n  let buf = RunVimInTerminal('-S XState', #{rows: 6})\n\n  \" Using a \":\" command Vim is busy, thus \"S\" is returned\n  call term_sendkeys(buf, \":echo 'state: ' .. state() .. '; mode: ' .. mode()\\<CR>\")\n  call WaitForAssert({-> assert_match('state: S; mode: n', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":\\<CR>\")\n\n  \" Using a timer callback\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: c; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Halfway a mapping\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>;\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \";\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: mSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" A operator is pending\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>y\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"y\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: oSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" A register was specified\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>\\\"r\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"yy\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: oSc; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Insert mode completion (bit slower on Mac)\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>Got\\<C-N>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: aSc; mode: i', term_getline(buf, 6))}, 1000)\n\n  \" Autocommand executing\n  call term_sendkeys(buf, \":set filetype=foobar\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: xS; mode: n', term_getline(buf, 6))}, 1000)\n\n  \" Todo: \"w\" - waiting for ch_evalexpr()\n\n  \" messages scrolled\n  call term_sendkeys(buf, \":call RunTimer()\\<CR>:echo \\\"one\\\\ntwo\\\\nthree\\\"\\<CR>\")\n  call TermWait(buf, 25)\n  call term_sendkeys(buf, \"\\<CR>\")\n  call term_sendkeys(buf, getstate)\n  call WaitForAssert({-> assert_match('state: Scs; mode: r', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XState')\nendfunc\n\nfunc Test_range()\n  \" destructuring\n  let [x, y] = range(2)\n  call assert_equal([0, 1], [x, y])\n\n  \" index\n  call assert_equal(4, range(1, 10)[3])\n\n  \" add()\n  call assert_equal([0, 1, 2, 3], add(range(3), 3))\n  call assert_equal([0, 1, 2, [0, 1, 2]], add([0, 1, 2], range(3)))\n  call assert_equal([0, 1, 2, [0, 1, 2]], add(range(3), range(3)))\n\n  \" append()\n  new\n  call append('.', range(5))\n  call assert_equal(['', '0', '1', '2', '3', '4'], getline(1, '$'))\n  bwipe!\n\n  \" appendbufline()\n  new\n  call appendbufline(bufnr(''), '.', range(5))\n  call assert_equal(['0', '1', '2', '3', '4', ''], getline(1, '$'))\n  bwipe!\n\n  \" call()\n  func TwoArgs(a, b)\n    return [a:a, a:b]\n  endfunc\n  call assert_equal([0, 1], call('TwoArgs', range(2)))\n\n  \" col()\n  new\n  call setline(1, ['foo', 'bar'])\n  call assert_equal(2, col(range(1, 2)))\n  bwipe!\n\n  \" complete()\n  execute \"normal! a\\<C-r>=[complete(col('.'), range(10)), ''][1]\\<CR>\"\n  \" complete_info()\n  execute \"normal! a\\<C-r>=[complete(col('.'), range(10)), ''][1]\\<CR>\\<C-r>=[complete_info(range(5)), ''][1]\\<CR>\"\n\n  \" copy()\n  call assert_equal([1, 2, 3], copy(range(1, 3)))\n\n  \" count()\n  call assert_equal(0, count(range(0), 3))\n  call assert_equal(0, count(range(2), 3))\n  call assert_equal(1, count(range(5), 3))\n\n  \" cursor()\n  new\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  call cursor(range(1, 2))\n  call assert_equal([2, 1], [col('.'), line('.')])\n  bwipe!\n\n  \" deepcopy()\n  call assert_equal([1, 2, 3], deepcopy(range(1, 3)))\n\n  \" empty()\n  call assert_true(empty(range(0)))\n  call assert_false(empty(range(2)))\n\n  \" execute()\n  new\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  call execute(range(3))\n  call assert_equal(2, line('.'))\n  bwipe!\n\n  \" extend()\n  call assert_equal([1, 2, 3, 4], extend([1], range(2, 4)))\n  call assert_equal([1, 2, 3, 4], extend(range(1, 1), range(2, 4)))\n  call assert_equal([1, 2, 3, 4], extend(range(1, 1), [2, 3, 4]))\n\n  \" filter()\n  call assert_equal([1, 3], filter(range(5), 'v:val % 2'))\n  call assert_equal([1, 5, 7, 11, 13], filter(filter(range(15), 'v:val % 2'), 'v:val % 3'))\n\n  \" funcref()\n  call assert_equal([0, 1], funcref('TwoArgs', range(2))())\n\n  \" function()\n  call assert_equal([0, 1], function('TwoArgs', range(2))())\n\n  \" garbagecollect()\n  let thelist = [1, range(2), 3]\n  let otherlist = range(3)\n  call test_garbagecollect_now()\n\n  \" get()\n  call assert_equal(4, get(range(1, 10), 3))\n  call assert_equal(-1, get(range(1, 10), 42, -1))\n\n  \" index()\n  call assert_equal(1, index(range(1, 5), 2))\n  call assert_fails(\"echo index([1, 2], 1, [])\", 'E745:')\n\n  \" insert()\n  call assert_equal([42, 1, 2, 3, 4, 5], insert(range(1, 5), 42))\n  call assert_equal([42, 1, 2, 3, 4, 5], insert(range(1, 5), 42, 0))\n  call assert_equal([1, 42, 2, 3, 4, 5], insert(range(1, 5), 42, 1))\n  call assert_equal([1, 2, 3, 4, 42, 5], insert(range(1, 5), 42, 4))\n  call assert_equal([1, 2, 3, 4, 42, 5], insert(range(1, 5), 42, -1))\n  call assert_equal([1, 2, 3, 4, 5, 42], insert(range(1, 5), 42, 5))\n\n  \" join()\n  call assert_equal('0 1 2 3 4', join(range(5)))\n\n  \" json_encode()\n  call assert_equal('[0,1,2,3]', json_encode(range(4)))\n\n  \" len()\n  call assert_equal(0, len(range(0)))\n  call assert_equal(2, len(range(2)))\n  call assert_equal(5, len(range(0, 12, 3)))\n  call assert_equal(4, len(range(3, 0, -1)))\n\n  \" list2str()\n  call assert_equal('ABC', list2str(range(65, 67)))\n  call assert_fails('let s = list2str(5)', 'E1211:')\n\n  \" lock()\n  let thelist = range(5)\n  lockvar thelist\n\n  \" map()\n  call assert_equal([0, 2, 4, 6, 8], map(range(5), 'v:val * 2'))\n  call assert_equal([3, 5, 7, 9, 11], map(map(range(5), 'v:val * 2'), 'v:val + 3'))\n  call assert_equal([2, 6], map(filter(range(5), 'v:val % 2'), 'v:val * 2'))\n  call assert_equal([2, 4, 8], filter(map(range(5), 'v:val * 2'), 'v:val % 3'))\n\n  \" match()\n  call assert_equal(3, match(range(5), 3))\n\n  \" matchaddpos()\n  highlight MyGreenGroup ctermbg=green guibg=green\n  call matchaddpos('MyGreenGroup', range(line('.'), line('.')))\n\n  \" matchend()\n  call assert_equal(4, matchend(range(5), '4'))\n  call assert_equal(3, matchend(range(1, 5), '4'))\n  call assert_equal(-1, matchend(range(1, 5), '42'))\n\n  \" matchstrpos()\n  call assert_equal(['4', 4, 0, 1], matchstrpos(range(5), '4'))\n  call assert_equal(['4', 3, 0, 1], matchstrpos(range(1, 5), '4'))\n  call assert_equal(['', -1, -1, -1], matchstrpos(range(1, 5), '42'))\n\n  \" max() reverse()\n  call assert_equal(0, max(range(0)))\n  call assert_equal(0, max(range(10, 9)))\n  call assert_equal(9, max(range(10)))\n  call assert_equal(18, max(range(0, 20, 3)))\n  call assert_equal(20, max(range(20, 0, -3)))\n  call assert_equal(99999, max(range(100000)))\n  call assert_equal(99999, max(range(99999, 0, -1)))\n  call assert_equal(99999, max(reverse(range(100000))))\n  call assert_equal(99999, max(reverse(range(99999, 0, -1))))\n\n  \" min() reverse()\n  call assert_equal(0, min(range(0)))\n  call assert_equal(0, min(range(10, 9)))\n  call assert_equal(5, min(range(5, 10)))\n  call assert_equal(5, min(range(5, 10, 3)))\n  call assert_equal(2, min(range(20, 0, -3)))\n  call assert_equal(0, min(range(100000)))\n  call assert_equal(0, min(range(99999, 0, -1)))\n  call assert_equal(0, min(reverse(range(100000))))\n  call assert_equal(0, min(reverse(range(99999, 0, -1))))\n\n  \" remove()\n  call assert_equal(1, remove(range(1, 10), 0))\n  call assert_equal(2, remove(range(1, 10), 1))\n  call assert_equal(9, remove(range(1, 10), 8))\n  call assert_equal(10, remove(range(1, 10), 9))\n  call assert_equal(10, remove(range(1, 10), -1))\n  call assert_equal([3, 4, 5], remove(range(1, 10), 2, 4))\n\n  \" repeat()\n  call assert_equal([0, 1, 2, 0, 1, 2], repeat(range(3), 2))\n  call assert_equal([0, 1, 2], repeat(range(3), 1))\n  call assert_equal([], repeat(range(3), 0))\n  call assert_equal([], repeat(range(5, 4), 2))\n  call assert_equal([], repeat(range(5, 4), 0))\n\n  \" reverse()\n  call assert_equal([2, 1, 0], reverse(range(3)))\n  call assert_equal([0, 1, 2, 3], reverse(range(3, 0, -1)))\n  call assert_equal([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], reverse(range(10)))\n  call assert_equal([20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10], reverse(range(10, 20)))\n  call assert_equal([16, 13, 10], reverse(range(10, 18, 3)))\n  call assert_equal([19, 16, 13, 10], reverse(range(10, 19, 3)))\n  call assert_equal([19, 16, 13, 10], reverse(range(10, 20, 3)))\n  call assert_equal([11, 14, 17, 20], reverse(range(20, 10, -3)))\n  call assert_equal([], reverse(range(0)))\n\n  \" TODO: setpos()\n  \" new\n  \" call setline(1, repeat([''], bufnr('')))\n  \" call setline(bufnr('') + 1, repeat('x', bufnr('') * 2 + 6))\n  \" call setpos('x', range(bufnr(''), bufnr('') + 3))\n  \" bwipe!\n\n  \" setreg()\n  call setreg('a', range(3))\n  call assert_equal(\"0\\n1\\n2\\n\", getreg('a'))\n\n  \" settagstack()\n  call settagstack(1, #{items : range(4)})\n\n  \" sign_define()\n  call assert_fails(\"call sign_define(range(5))\", \"E715:\")\n  call assert_fails(\"call sign_placelist(range(5))\", \"E715:\")\n\n  \" sign_undefine()\n  call assert_fails(\"call sign_undefine(range(5))\", \"E908:\")\n\n  \" sign_unplacelist()\n  call assert_fails(\"call sign_unplacelist(range(5))\", \"E715:\")\n\n  \" sort()\n  call assert_equal([0, 1, 2, 3, 4, 5], sort(range(5, 0, -1)))\n\n  \" string()\n  call assert_equal('[0, 1, 2, 3, 4]', string(range(5)))\n\n  \" taglist() with 'tagfunc'\n  func TagFunc(pattern, flags, info)\n    return range(10)\n  endfunc\n  set tagfunc=TagFunc\n  call assert_fails(\"call taglist('asdf')\", 'E987:')\n  set tagfunc=\n\n  \" term_start()\n  if has('terminal') && has('termguicolors')\n    call assert_fails('call term_start(range(3, 4))', 'E474:')\n    let g:terminal_ansi_colors = range(16)\n    if has('win32')\n      let cmd = \"cmd /c dir\"\n    else\n      let cmd = \"ls\"\n    endif\n    call assert_fails('call term_start(\"' .. cmd .. '\", #{term_finish: \"close\"'\n        \\ .. ', ansi_colors: range(16)})', 'E475:')\n    unlet g:terminal_ansi_colors\n  endif\n\n  \" type()\n  call assert_equal(v:t_list, type(range(5)))\n\n  \" uniq()\n  call assert_equal([0, 1, 2, 3, 4], uniq(range(5)))\n\n  \" errors\n  call assert_fails('let x=range(2, 8, 0)', 'E726:')\n  call assert_fails('let x=range(3, 1)', 'E727:')\n  call assert_fails('let x=range(1, 3, -2)', 'E727:')\n  call assert_fails('let x=range([])', 'E745:')\n  call assert_fails('let x=range(1, [])', 'E745:')\n  call assert_fails('let x=range(1, 4, [])', 'E745:')\nendfunc\n\nfunc Test_garbagecollect_now_fails()\n  let v:testing = 0\n  call assert_fails('call test_garbagecollect_now()', 'E1142:')\n  let v:testing = 1\nendfunc\n\nfunc Test_echoraw()\n  CheckScreendump\n\n  \" Normally used for escape codes, but let's test with a CR.\n  let lines =<< trim END\n    call echoraw(\"hello\\<CR>x\")\n  END\n  call writefile(lines, 'XTest_echoraw')\n  let buf = RunVimInTerminal('-S XTest_echoraw', {'rows': 5, 'cols': 40})\n  call VerifyScreenDump(buf, 'Test_functions_echoraw', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_echoraw')\nendfunc\n\n\" Test for echo highlighting\nfunc Test_echohl()\n  echohl Search\n  echo 'Vim'\n  call assert_equal('Vim', Screenline(&lines))\n  \" TODO: How to check the highlight group used by echohl?\n  \" ScreenAttrs() returns all zeros.\n  echohl None\nendfunc\n\n\" Test for the eval() function\nfunc Test_eval()\n  call assert_fails(\"call eval('5 a')\", 'E488:')\nendfunc\n\n\" Test for the keytrans() function\nfunc Test_keytrans()\n  call assert_equal('<Space>', keytrans(' '))\n  call assert_equal('<lt>', keytrans('<'))\n  call assert_equal('<lt>Tab>', keytrans('<Tab>'))\n  call assert_equal('<Tab>', keytrans(\"\\<Tab>\"))\n  call assert_equal('<C-V>', keytrans(\"\\<C-V>\"))\n  call assert_equal('<BS>', keytrans(\"\\<BS>\"))\n  call assert_equal('<Home>', keytrans(\"\\<Home>\"))\n  call assert_equal('<C-Home>', keytrans(\"\\<C-Home>\"))\n  call assert_equal('<M-Home>', keytrans(\"\\<M-Home>\"))\n  call assert_equal('<C-Space>', keytrans(\"\\<C-Space>\"))\n  call assert_equal('<M-Space>', keytrans(\"\\<*M-Space>\"))\n  call assert_equal('<M-x>', \"\\<*M-x>\"->keytrans())\n  call assert_equal('<C-I>', \"\\<*C-I>\"->keytrans())\n  call assert_equal('<S-3>', \"\\<*S-3>\"->keytrans())\n  call assert_equal('\u03c0', '\u03c0'->keytrans())\n  call assert_equal('<M-\u03c0>', \"\\<M-\u03c0>\"->keytrans())\n  call assert_equal('\u011b', '\u011b'->keytrans())\n  call assert_equal('<M-\u011b>', \"\\<M-\u011b>\"->keytrans())\n  call assert_equal('', ''->keytrans())\n  call assert_equal('', test_null_string()->keytrans())\n  call assert_fails('call keytrans(1)', 'E1174:')\n  call assert_fails('call keytrans()', 'E119:')\nendfunc\n\n\" Test for the nr2char() function\nfunc Test_nr2char()\n  set encoding=latin1\n  call assert_equal('@', nr2char(64))\n  set encoding=utf8\n  call assert_equal('a', nr2char(97, 1))\n  call assert_equal('a', nr2char(97, 0))\n\n  call assert_equal(\"\\x80\\xfc\\b\" .. nr2char(0x100000), eval('\"\\<M-' .. nr2char(0x100000) .. '>\"'))\n  call assert_equal(\"\\x80\\xfc\\b\" .. nr2char(0x40000000), eval('\"\\<M-' .. nr2char(0x40000000) .. '>\"'))\nendfunc\n\n\" Test for screenattr(), screenchar() and screenchars() functions\nfunc Test_screen_functions()\n  call assert_equal(-1, screenattr(-1, -1))\n  call assert_equal(-1, screenchar(-1, -1))\n  call assert_equal([], screenchars(-1, -1))\n\n  \" Run this in a separate Vim instance to avoid messing up.\n  let after =<< trim [CODE]\n    scriptencoding utf-8\n    call setline(1, '\u53e3')\n    redraw\n    call assert_equal(0, screenattr(1, 1))\n    call assert_equal(char2nr('\u53e3'), screenchar(1, 1))\n    call assert_equal([char2nr('\u53e3')], screenchars(1, 1))\n    call assert_equal('\u53e3', screenstring(1, 1))\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [CODE]\n\n  let encodings = ['utf-8', 'cp932', 'cp936', 'cp949', 'cp950']\n  if !has('win32')\n    let encodings += ['euc-jp']\n  endif\n  for enc in encodings\n    let msg = 'enc=' .. enc\n    if RunVim([], after, $'--clean --cmd \"set encoding={enc}\"')\n      call assert_equal([], readfile('Xresult'), msg)\n    endif\n    call delete('Xresult')\n  endfor\nendfunc\n\n\" Test for getcurpos() and setpos()\nfunc Test_getcurpos_setpos()\n  new\n  call setline(1, ['012345678', '012345678'])\n  normal gg6l\n  let sp = getcurpos()\n  normal 0\n  call setpos('.', sp)\n  normal jyl\n  call assert_equal('6', @\")\n  call assert_equal(-1, setpos('.', test_null_list()))\n  call assert_equal(-1, setpos('.', {}))\n\n  let winid = win_getid()\n  normal G$\n  let pos = getcurpos()\n  wincmd w\n  call assert_equal(pos, getcurpos(winid))\n\n  wincmd w\n  close!\n\n  call assert_equal(getcurpos(), getcurpos(0))\n  call assert_equal([0, 0, 0, 0, 0], getcurpos(-1))\n  call assert_equal([0, 0, 0, 0, 0], getcurpos(1999))\nendfunc\n\nfunc Test_getmousepos()\n  enew!\n  call setline(1, \"\\t\\t\\t1234\")\n  call test_setmouse(1, 1)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 1,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 1,\n        \\ line: 1,\n        \\ column: 1,\n        \\ }, getmousepos())\n  call test_setmouse(1, 25)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 25,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 25,\n        \\ line: 1,\n        \\ column: 4,\n        \\ }, getmousepos())\n  call test_setmouse(1, 50)\n  call assert_equal(#{\n        \\ screenrow: 1,\n        \\ screencol: 50,\n        \\ winid: win_getid(),\n        \\ winrow: 1,\n        \\ wincol: 50,\n        \\ line: 1,\n        \\ column: 8,\n        \\ }, getmousepos())\n\n  \" If the mouse is positioned past the last buffer line, \"line\" and \"column\"\n  \" should act like it's positioned on the last buffer line.\n  call test_setmouse(2, 25)\n  call assert_equal(#{\n        \\ screenrow: 2,\n        \\ screencol: 25,\n        \\ winid: win_getid(),\n        \\ winrow: 2,\n        \\ wincol: 25,\n        \\ line: 1,\n        \\ column: 4,\n        \\ }, getmousepos())\n  call test_setmouse(2, 50)\n  call assert_equal(#{\n        \\ screenrow: 2,\n        \\ screencol: 50,\n        \\ winid: win_getid(),\n        \\ winrow: 2,\n        \\ wincol: 50,\n        \\ line: 1,\n        \\ column: 8,\n        \\ }, getmousepos())\n  bwipe!\nendfunc\n\nfunc Test_getmouseshape()\n  CheckFeature mouseshape\n\n  call assert_equal('arrow', getmouseshape())\nendfunc\n\n\" Test for glob()\nfunc Test_glob()\n  call assert_equal('', glob(test_null_string()))\n  call assert_equal('', globpath(test_null_string(), test_null_string()))\n  call assert_fails(\"let x = globpath(&rtp, 'syntax/c.vim', [])\", 'E745:')\n\n  call writefile([], 'Xglob1')\n  call writefile([], 'XGLOB2')\n  set wildignorecase\n  \" Sort output of glob() otherwise we end up with different\n  \" ordering depending on whether file system is case-sensitive.\n  call assert_equal(['XGLOB2', 'Xglob1'], sort(glob('Xglob[12]', 0, 1)))\n  \" wildignorecase shall be applied even when the pattern contains no wildcards.\n  call assert_equal('XGLOB2', glob('xglob2'))\n  set wildignorecase&\n\n  call delete('Xglob1')\n  call delete('XGLOB2')\n\n  call assert_fails(\"call glob('*', 0, {})\", 'E728:')\nendfunc\n\n\" Test for browse()\nfunc Test_browse()\n  CheckFeature browse\n  call assert_fails('call browse([], \"open\", \"x\", \"a.c\")', 'E745:')\nendfunc\n\n\" Test for browsedir()\nfunc Test_browsedir()\n  CheckFeature browse\n  call assert_fails('call browsedir(\"open\", [])', 'E730:')\nendfunc\n\nfunc HasDefault(msg = 'msg')\n  return a:msg\nendfunc\n\nfunc Test_default_arg_value()\n  call assert_equal('msg', HasDefault())\nendfunc\n\n\" Test for gettext()\nfunc Test_gettext()\n  call assert_fails('call gettext(1)', 'E1174:')\nendfunc\n\nfunc Test_builtin_check()\n  call assert_fails('let g:[\"trim\"] = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let g:.trim = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let l:[\"trim\"] = {x -> \" \" .. x}', 'E704:')\n  call assert_fails('let l:.trim = {x -> \" \" .. x}', 'E704:')\n  let lines =<< trim END\n    vim9script\n    var trim = (x) => \" \" .. x\n  END\n  call v9.CheckScriptFailure(lines, 'E704:')\n\n  call assert_fails('call extend(g:, #{foo: { -> \"foo\" }})', 'E704:')\n  let g:bar = 123\n  call extend(g:, #{bar: { -> \"foo\" }}, \"keep\")\n  call assert_fails('call extend(g:, #{bar: { -> \"foo\" }}, \"force\")', 'E704:')\n  unlet g:bar\n\n  call assert_fails('call extend(l:, #{foo: { -> \"foo\" }})', 'E704:')\n  let bar = 123\n  call extend(l:, #{bar: { -> \"foo\" }}, \"keep\")\n  call assert_fails('call extend(l:, #{bar: { -> \"foo\" }}, \"force\")', 'E704:')\n  unlet bar\n\n  call assert_fails('call extend(g:, #{foo: function(\"extend\")})', 'E704:')\n  let g:bar = 123\n  call extend(g:, #{bar: function(\"extend\")}, \"keep\")\n  call assert_fails('call extend(g:, #{bar: function(\"extend\")}, \"force\")', 'E704:')\n  unlet g:bar\n\n  call assert_fails('call extend(l:, #{foo: function(\"extend\")})', 'E704:')\n  let bar = 123\n  call extend(l:, #{bar: function(\"extend\")}, \"keep\")\n  call assert_fails('call extend(l:, #{bar: function(\"extend\")}, \"force\")', 'E704:')\n  unlet bar\nendfunc\n\nfunc Test_funcref_to_string()\n  let Fn = funcref('g:Test_funcref_to_string')\n  call assert_equal(\"function('g:Test_funcref_to_string')\", string(Fn))\nendfunc\n\n\" Test for isabsolutepath()\nfunc Test_isabsolutepath()\n  call assert_false(isabsolutepath(''))\n  call assert_false(isabsolutepath('.'))\n  call assert_false(isabsolutepath('../Foo'))\n  call assert_false(isabsolutepath('Foo/'))\n  if has('win32')\n    call assert_true(isabsolutepath('A:\\'))\n    call assert_true(isabsolutepath('A:\\Foo'))\n    call assert_true(isabsolutepath('A:/Foo'))\n    call assert_false(isabsolutepath('A:Foo'))\n    call assert_false(isabsolutepath('\\Windows'))\n    call assert_true(isabsolutepath('\\\\Server2\\Share\\Test\\Foo.txt'))\n  else\n    call assert_true(isabsolutepath('/'))\n    call assert_true(isabsolutepath('/usr/share/'))\n  endif\nendfunc\n\n\" Test for exepath()\nfunc Test_exepath()\n  if has('win32')\n    call assert_notequal(exepath('cmd'), '')\n\n    let oldNoDefaultCurrentDirectoryInExePath = $NoDefaultCurrentDirectoryInExePath\n    call writefile(['@echo off', 'echo Evil'], 'vim-test-evil.bat')\n    let $NoDefaultCurrentDirectoryInExePath = ''\n    call assert_notequal(exepath(\"vim-test-evil.bat\"), '')\n    let $NoDefaultCurrentDirectoryInExePath = '1'\n    call assert_equal(exepath(\"vim-test-evil.bat\"), '')\n    let $NoDefaultCurrentDirectoryInExePath = oldNoDefaultCurrentDirectoryInExePath\n    call delete('vim-test-evil.bat')\n  else\n    call assert_notequal(exepath('sh'), '')\n  endif\nendfunc\n\n\" Test for virtcol()\nfunc Test_virtcol()\n  new\n  call setline(1, \"the\\tquick\\tbrown\\tfox\")\n  norm! 4|\n  call assert_equal(8, virtcol('.'))\n  call assert_equal(8, virtcol('.', v:false))\n  call assert_equal([4, 8], virtcol('.', v:true))\n\n  let w = winwidth(0)\n  call setline(2, repeat('a', w + 2))\n  let win_nosbr = win_getid()\n  split\n  setlocal showbreak=!!\n  let win_sbr = win_getid()\n  call assert_equal([w, w], virtcol([2, w], v:true, win_nosbr))\n  call assert_equal([w + 1, w + 1], virtcol([2, w + 1], v:true, win_nosbr))\n  call assert_equal([w + 2, w + 2], virtcol([2, w + 2], v:true, win_nosbr))\n  call assert_equal([w, w], virtcol([2, w], v:true, win_sbr))\n  call assert_equal([w + 3, w + 3], virtcol([2, w + 1], v:true, win_sbr))\n  call assert_equal([w + 4, w + 4], virtcol([2, w + 2], v:true, win_sbr))\n  close\n\n  call assert_equal(0, virtcol(''))\n  call assert_equal([0, 0], virtcol('', v:true))\n  call assert_equal(0, virtcol('.', v:false, 5001))\n  call assert_equal([0, 0], virtcol('.', v:true, 5001))\n\n  bwipe!\nendfunc\n\nfunc Test_delfunc_while_listing()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      set nocompatible\n      for i in range(1, 999)\n        exe 'func ' .. 'MyFunc' .. i .. '()'\n        endfunc\n      endfor\n      au CmdlineLeave : call timer_start(0, {-> execute('delfunc MyFunc622')})\n  END\n  call writefile(lines, 'Xfunctionclear', 'D')\n  let buf = RunVimInTerminal('-S Xfunctionclear', {'rows': 12})\n\n  \" This was using freed memory.  The height of the terminal must be so that\n  \" the next function to be listed with \"j\" is the one that is deleted in the\n  \" timer callback, tricky!\n  call term_sendkeys(buf, \":func /MyFunc\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"j\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"\\<CR>\")\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for the reverse() function with a string\nfunc Test_string_reverse()\n  let lines =<< trim END\n    call assert_equal('', reverse(test_null_string()))\n    for [s1, s2] in [['', ''], ['a', 'a'], ['ab', 'ba'], ['abc', 'cba'],\n                   \\ ['abcd', 'dcba'], ['\u00ab-\u00ab-\u00bb-\u00bb', '\u00bb-\u00bb-\u00ab-\u00ab'],\n                   \\ ['\ud83c\udde6', '\ud83c\udde6'], ['\ud83c\udde6\ud83c\udde7', '\ud83c\udde7\ud83c\udde6'], ['\ud83c\udde6\ud83c\udde7\ud83c\udde8', '\ud83c\udde8\ud83c\udde7\ud83c\udde6'],\n                   \\ ['\ud83c\udde6\u00ab\ud83c\udde7-\ud83c\udde8\u00bb\ud83c\udde9', '\ud83c\udde9\u00bb\ud83c\udde8-\ud83c\udde7\u00ab\ud83c\udde6']]\n      call assert_equal(s2, reverse(s1))\n    endfor\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal('dcba', reverse('abcd'))\n  let &encoding = save_enc\nendfunc\n\nfunc Test_fullcommand()\n  \" this used to crash vim\n  call assert_equal('', fullcommand(10))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_docmd.c", "src/testdir/test_functions.vim", "src/version.c"], "buggy_code_start_loc": [4090, 3609, 701], "buggy_code_end_loc": [4091, 3609, 701], "fixing_code_start_loc": [4090, 3610, 702], "fixing_code_end_loc": [4091, 3615, 704], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1846.", "other": {"cve": {"id": "CVE-2023-4734", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-02T18:15:17.127", "lastModified": "2023-12-21T02:52:18.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1846."}, {"lang": "es", "value": "Un Desbordamiento de Enteros o Wraparound en el repositorio de GitHub vim/vim version anterior a 9.0.1846."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1846", "matchCriteriaId": "CD174B25-7E00-4526-BFAB-ABD283C72975"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "14.1", "matchCriteriaId": "2BB2BFC1-74A1-4178-8488-69EC5A60B34F"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Oct/24", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/4c6fe2e2ea62469642ed1d80b16d39e616b25cf5", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/688e4382-d2b6-439a-a54e-484780f82217", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213984", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/4c6fe2e2ea62469642ed1d80b16d39e616b25cf5"}}