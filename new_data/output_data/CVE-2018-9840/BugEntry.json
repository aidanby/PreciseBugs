{"buggy_code": ["//\n//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.\n//\n\nimport Foundation\nimport LocalAuthentication\n\n@objc public class OWSScreenLock: NSObject {\n\n    public enum OWSScreenLockOutcome {\n        case success\n        case cancel\n        case failure(error:String)\n        case unexpectedFailure(error:String)\n    }\n\n    @objc public let screenLockTimeoutDefault = 15 * kMinuteInterval\n    @objc public let screenLockTimeouts = [\n        1 * kMinuteInterval,\n        5 * kMinuteInterval,\n        15 * kMinuteInterval,\n        30 * kMinuteInterval,\n        1 * kHourInterval,\n        0\n    ]\n\n    @objc public static let ScreenLockDidChange = Notification.Name(\"ScreenLockDidChange\")\n\n    let primaryStorage: OWSPrimaryStorage\n    let dbConnection: YapDatabaseConnection\n\n    private let OWSScreenLock_Collection = \"OWSScreenLock_Collection\"\n    private let OWSScreenLock_Key_IsScreenLockEnabled = \"OWSScreenLock_Key_IsScreenLockEnabled\"\n    private let OWSScreenLock_Key_ScreenLockTimeoutSeconds = \"OWSScreenLock_Key_ScreenLockTimeoutSeconds\"\n\n    // We don't want the verification process itself to trigger unlock verification.\n    // Passcode-code only authentication process deactivates the app.\n    private var ignoreUnlockUntilActive = false\n\n    // We temporarily resign any first responder while the Screen Lock is presented.\n    weak var firstResponderBeforeLockscreen: UIResponder?\n\n    // MARK - Singleton class\n\n    @objc(sharedManager)\n    public static let shared = OWSScreenLock()\n\n    private override init() {\n        self.primaryStorage = OWSPrimaryStorage.shared()\n        self.dbConnection = self.primaryStorage.newDatabaseConnection()\n\n        super.init()\n\n        SwiftSingletons.register(self)\n\n        NotificationCenter.default.addObserver(self,\n                                               selector: #selector(didBecomeActive),\n                                               name: NSNotification.Name.OWSApplicationDidBecomeActive,\n                                               object: nil)\n    }\n\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    func didBecomeActive() {\n        AssertIsOnMainThread()\n\n        ignoreUnlockUntilActive = false\n    }\n\n    // MARK: - Properties\n\n    @objc public func isScreenLockEnabled() -> Bool {\n        AssertIsOnMainThread()\n\n        if !OWSStorage.isStorageReady() {\n            owsFail(\"\\(logTag) accessed screen lock state before storage is ready.\")\n            return false\n        }\n\n        return self.dbConnection.bool(forKey: OWSScreenLock_Key_IsScreenLockEnabled, inCollection: OWSScreenLock_Collection, defaultValue: false)\n    }\n\n    private func setIsScreenLockEnabled(value: Bool) {\n        AssertIsOnMainThread()\n        assert(OWSStorage.isStorageReady())\n\n        self.dbConnection.setBool(value, forKey: OWSScreenLock_Key_IsScreenLockEnabled, inCollection: OWSScreenLock_Collection)\n\n        NotificationCenter.default.postNotificationNameAsync(OWSScreenLock.ScreenLockDidChange, object: nil)\n    }\n\n    @objc public func screenLockTimeout() -> TimeInterval {\n        AssertIsOnMainThread()\n\n        if !OWSStorage.isStorageReady() {\n            owsFail(\"\\(logTag) accessed screen lock state before storage is ready.\")\n            return 0\n        }\n\n        return self.dbConnection.double(forKey: OWSScreenLock_Key_ScreenLockTimeoutSeconds, inCollection: OWSScreenLock_Collection, defaultValue: screenLockTimeoutDefault)\n    }\n\n    @objc public func setScreenLockTimeout(_ value: TimeInterval) {\n        AssertIsOnMainThread()\n        assert(OWSStorage.isStorageReady())\n\n        self.dbConnection.setDouble(value, forKey: OWSScreenLock_Key_ScreenLockTimeoutSeconds, inCollection: OWSScreenLock_Collection)\n\n        NotificationCenter.default.postNotificationNameAsync(OWSScreenLock.ScreenLockDidChange, object: nil)\n    }\n\n    // MARK: - Methods\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    @objc public func tryToEnableScreenLock(completion: @escaping ((Error?) -> Void)) {\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_ENABLE_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to enable 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            self.setIsScreenLockEnabled(value: true)\n                                            completion(nil)\n                                        case .cancel:\n                                            completion(nil)\n                                        }\n        })\n    }\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    @objc public func tryToDisableScreenLock(completion: @escaping ((Error?) -> Void)) {\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_DISABLE_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to disable 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            self.setIsScreenLockEnabled(value: false)\n                                            completion(nil)\n                                        case .cancel:\n                                            completion(nil)\n                                        }\n        })\n    }\n\n    @objc public func tryToUnlockScreenLock(success: @escaping (() -> Void),\n                                            failure: @escaping ((Error) -> Void),\n                                            unexpectedFailure: @escaping ((Error) -> Void),\n                                            cancel: @escaping (() -> Void)) {\n        guard !ignoreUnlockUntilActive else {\n            DispatchQueue.main.async {\n                success()\n            }\n            return\n        }\n\n        // A popped keyboard breaks our layout and obscures the unlock button.\n        if let firstResponder = UIResponder.currentFirstResponder() {\n            Logger.debug(\"\\(self.logTag) in \\(#function) resigning first responder: \\(firstResponder)\")\n            firstResponder.resignFirstResponder()\n            self.firstResponderBeforeLockscreen = firstResponder\n        }\n\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_UNLOCK_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to unlock 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            failure(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            unexpectedFailure(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            // It's important we restore first responder status once the user completes\n                                            // In some cases, (RegistrationLock Reminder) it just puts the keyboard back where\n                                            // the user needs it, saving them a tap.\n                                            // But in the case of an inputAccessoryView, like the ConversationViewController,\n                                            // failing to restore firstResponder could make the input toolbar disappear until\n                                            if let firstResponder = self.firstResponderBeforeLockscreen {\n                                                Logger.debug(\"\\(self.logTag) in \\(#function) regaining first responder: \\(firstResponder)\")\n                                                firstResponder.becomeFirstResponder()\n                                                self.firstResponderBeforeLockscreen = nil\n                                            }\n                                            success()\n                                        case .cancel:\n                                            cancel()\n                                        }\n        })\n    }\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    private func tryToVerifyLocalAuthentication(localizedReason: String,\n                                                completion completionParam: @escaping ((OWSScreenLockOutcome) -> Void)) {\n        AssertIsOnMainThread()\n\n        // Ensure completion is always called on the main thread.\n        let completion = { (outcome: OWSScreenLockOutcome) in\n            switch outcome {\n            case .failure(let error):\n                Logger.error(\"\\(self.logTag) local authentication failed with error: \\(error)\")\n            default:\n                break\n            }\n            DispatchQueue.main.async {\n                completionParam(outcome)\n            }\n        }\n\n        let context = screenLockContext()\n        let defaultErrorDescription = NSLocalizedString(\"SCREEN_LOCK_ENABLE_UNKNOWN_ERROR\",\n                                                        comment: \"Indicates that an unknown error occurred while using Touch ID/Face ID/Phone Passcode.\")\n\n        var authError: NSError?\n        let canEvaluatePolicy = context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &authError)\n        if !canEvaluatePolicy || authError != nil {\n            Logger.error(\"\\(logTag) could not determine if local authentication is supported: \\(String(describing: authError))\")\n\n            let outcome = self.outcomeForLAError(errorParam: authError,\n                                                 defaultErrorDescription: defaultErrorDescription)\n            switch outcome {\n            case .success:\n                owsFail(\"\\(self.logTag) local authentication unexpected success\")\n                completion(.failure(error:defaultErrorDescription))\n            case .cancel, .failure, .unexpectedFailure:\n                completion(outcome)\n            }\n            return\n        }\n\n        // Use ignoreUnlockUntilActive to suppress unlock verifications.\n        ignoreUnlockUntilActive = true\n        context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: localizedReason) { success, evaluateError in\n\n            if success {\n                Logger.info(\"\\(self.logTag) local authentication succeeded.\")\n                completion(.success)\n            } else {\n                let outcome = self.outcomeForLAError(errorParam: evaluateError,\n                                                     defaultErrorDescription: defaultErrorDescription)\n                switch outcome {\n                case .success:\n                    owsFail(\"\\(self.logTag) local authentication unexpected success\")\n                    completion(.failure(error:defaultErrorDescription))\n                case .cancel, .failure, .unexpectedFailure:\n                    completion(outcome)\n                }\n            }\n        }\n    }\n\n    // MARK: - Outcome\n\n    private func outcomeForLAError(errorParam: Error?, defaultErrorDescription: String) -> OWSScreenLockOutcome {\n        if let error = errorParam {\n            guard let laError = error as? LAError else {\n                return .failure(error:defaultErrorDescription)\n            }\n\n            if #available(iOS 11.0, *) {\n                switch laError.code {\n                case .biometryNotAvailable:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryNotAvailable.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_AVAILABLE\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode are not available on this device.\"))\n                case .biometryNotEnrolled:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryNotEnrolled.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_ENROLLED\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode is not configured on this device.\"))\n                case .biometryLockout:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryLockout.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_LOCKOUT\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode is 'locked out' on this device due to authentication failures.\"))\n                default:\n                    // Fall through to second switch\n                    break\n                }\n            }\n\n            switch laError.code {\n            case .authenticationFailed:\n                Logger.error(\"\\(self.logTag) local authentication error: authenticationFailed.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_FAILED\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode authentication failed.\"))\n            case .userCancel, .userFallback, .systemCancel, .appCancel:\n                Logger.info(\"\\(self.logTag) local authentication cancelled.\")\n                return .cancel\n            case .passcodeNotSet:\n                Logger.error(\"\\(self.logTag) local authentication error: passcodeNotSet.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_PASSCODE_NOT_SET\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode passcode is not set.\"))\n            case .touchIDNotAvailable:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDNotAvailable.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_AVAILABLE\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode are not available on this device.\"))\n            case .touchIDNotEnrolled:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDNotEnrolled.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_ENROLLED\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode is not configured on this device.\"))\n            case .touchIDLockout:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDLockout.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_LOCKOUT\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode is 'locked out' on this device due to authentication failures.\"))\n            case .invalidContext:\n                owsFail(\"\\(self.logTag) context not valid.\")\n                return .unexpectedFailure(error:defaultErrorDescription)\n            case .notInteractive:\n                owsFail(\"\\(self.logTag) context not interactive.\")\n                return .unexpectedFailure(error:defaultErrorDescription)\n            }\n        }\n        return .failure(error:defaultErrorDescription)\n    }\n\n    private func authenticationError(errorDescription: String) -> Error {\n        return OWSErrorWithCodeDescription(.localAuthenticationError,\n                                           errorDescription)\n    }\n\n    // MARK: - Context\n\n    private func screenLockContext() -> LAContext {\n        let context = LAContext()\n\n        // If user has set any non-zero timeout, recycle biometric auth\n        // in the same period as our normal screen lock timeout, up to\n        // max of 10 seconds.\n        context.touchIDAuthenticationAllowableReuseDuration = TimeInterval(min(10.0, screenLockTimeout()))\n\n        if #available(iOS 11.0, *) {\n            assert(!context.interactionNotAllowed)\n        }\n\n        return context\n    }\n}\n", "//\n//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.\n//\n\n#import \"OWSScreenLockUI.h\"\n#import \"Signal-Swift.h\"\n#import <SignalMessaging/SignalMessaging-Swift.h>\n#import <SignalMessaging/UIView+OWS.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface OWSScreenLockUI ()\n\n@property (nonatomic) UIWindow *screenBlockingWindow;\n@property (nonatomic) UIViewController *screenBlockingViewController;\n@property (nonatomic) UIView *screenBlockingImageView;\n@property (nonatomic) UIView *screenBlockingButton;\n@property (nonatomic) NSArray<NSLayoutConstraint *> *screenBlockingConstraints;\n@property (nonatomic) NSString *screenBlockingSignature;\n\n// Unlike UIApplication.applicationState, this state is\n// updated conservatively, e.g. the flag is cleared during\n// \"will enter background.\"\n@property (nonatomic) BOOL appIsInactive;\n@property (nonatomic) BOOL appIsInBackground;\n\n@property (nonatomic) BOOL isShowingScreenLockUI;\n@property (nonatomic) BOOL didLastUnlockAttemptFail;\n\n// We want to remain in \"screen lock\" mode while \"local auth\"\n// UI is dismissing.\n@property (nonatomic) BOOL shouldClearAuthUIWhenActive;\n\n@property (nonatomic, nullable) NSDate *appEnteredBackgroundDate;\n@property (nonatomic, nullable) NSDate *appEnteredForegroundDate;\n@property (nonatomic, nullable) NSDate *lastUnlockSuccessDate;\n\n@property (nonatomic, nullable) NSTimer *inactiveTimer;\n\n@end\n\n#pragma mark -\n\n@implementation OWSScreenLockUI\n\n+ (instancetype)sharedManager\n{\n    static OWSScreenLockUI *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] initDefault];\n    });\n    return instance;\n}\n\n- (instancetype)initDefault\n{\n    self = [super init];\n\n    if (!self) {\n        return self;\n    }\n\n    [self observeNotifications];\n\n    OWSSingletonAssert();\n\n    return self;\n}\n\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n- (void)observeNotifications\n{\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationDidBecomeActive:)\n                                                 name:OWSApplicationDidBecomeActiveNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationWillResignActive:)\n                                                 name:OWSApplicationWillResignActiveNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationWillEnterForeground:)\n                                                 name:OWSApplicationWillEnterForegroundNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationDidEnterBackground:)\n                                                 name:OWSApplicationDidEnterBackgroundNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(registrationStateDidChange)\n                                                 name:RegistrationStateDidChangeNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(screenLockDidChange:)\n                                                 name:OWSScreenLock.ScreenLockDidChange\n                                               object:nil];\n}\n\n- (void)setupWithRootWindow:(UIWindow *)rootWindow\n{\n    OWSAssertIsOnMainThread();\n    OWSAssert(rootWindow);\n\n    [self prepareScreenProtectionWithRootWindow:rootWindow];\n\n    [AppReadiness runNowOrWhenAppIsReady:^{\n        [self ensureScreenProtection];\n    }];\n}\n\n#pragma mark - Methods\n\n- (void)setAppIsInactive:(BOOL)appIsInactive\n{\n    BOOL didChange = _appIsInactive != appIsInactive;\n\n    _appIsInactive = appIsInactive;\n\n    if (didChange) {\n        // If app is inactive for more than N seconds,\n        // treat this as \"entering the background\" for the purposes\n        // of Screen Lock.\n        if (!appIsInactive) {\n            [self.inactiveTimer invalidate];\n            self.inactiveTimer = nil;\n        } else if (!self.isShowingScreenLockUI) {\n            [self.inactiveTimer invalidate];\n            self.inactiveTimer = [NSTimer weakScheduledTimerWithTimeInterval:45.f\n                                                                      target:self\n                                                                    selector:@selector(inactiveTimerDidFire)\n                                                                    userInfo:nil\n                                                                     repeats:NO];\n        }\n    }\n\n    [self ensureScreenProtection];\n}\n\n- (void)setAppIsInBackground:(BOOL)appIsInBackground\n{\n    if (appIsInBackground) {\n        if (!_appIsInBackground) {\n            [self markAppAsInBackground];\n        }\n    }\n\n    _appIsInBackground = appIsInBackground;\n\n    [self ensureScreenProtection];\n}\n\n- (void)markAppAsInBackground\n{\n    // Record the time when app entered background.\n    BOOL shouldResetEnteredBackgroundDate = NO;\n    if (!self.appEnteredBackgroundDate) {\n        // If this is the first time we're entering the\n        // background, record the date.\n        shouldResetEnteredBackgroundDate = YES;\n    }\n    if (self.hasUnlockedScreenLock) {\n        // If we've unlocked the screen lock, record the date.\n        shouldResetEnteredBackgroundDate = YES;\n    } else {\n        // If we're returning to the background _without_\n        // having unlocked the screen lock, DO NOT update this\n        // value as that would reset the unlock timeout.\n    }\n    if (shouldResetEnteredBackgroundDate) {\n        self.appEnteredBackgroundDate = [NSDate new];\n    }\n\n    self.didLastUnlockAttemptFail = NO;\n\n    [self.inactiveTimer invalidate];\n    self.inactiveTimer = nil;\n}\n\n- (void)ensureScreenProtection\n{\n    OWSAssertIsOnMainThread();\n\n    if (!AppReadiness.isAppReady) {\n        [AppReadiness runNowOrWhenAppIsReady:^{\n            [self ensureScreenProtection];\n        }];\n        return;\n    }\n\n    BOOL shouldHaveScreenLock = self.shouldHaveScreenLock;\n    BOOL shouldHaveScreenProtection = self.shouldHaveScreenProtection;\n\n    BOOL shouldShowBlockWindow = shouldHaveScreenProtection || shouldHaveScreenLock;\n    DDLogVerbose(@\"%@, shouldHaveScreenProtection: %d, shouldHaveScreenLock: %d, shouldShowBlockWindow: %d\",\n        self.logTag,\n        shouldHaveScreenProtection,\n        shouldHaveScreenLock,\n        shouldShowBlockWindow);\n    if (self.screenBlockingWindow.hidden != !shouldShowBlockWindow) {\n        DDLogInfo(@\"%@, %@.\", self.logTag, shouldShowBlockWindow ? @\"showing block window\" : @\"hiding block window\");\n    }\n    [self updateScreenBlockingWindow:shouldShowBlockWindow shouldHaveScreenLock:shouldHaveScreenLock animated:YES];\n\n    if (shouldHaveScreenLock && !self.didLastUnlockAttemptFail) {\n        [self tryToPresentScreenLockUI];\n    }\n}\n\n- (void)tryToPresentScreenLockUI\n{\n    OWSAssertIsOnMainThread();\n\n    // If we no longer want to present the screen lock UI, abort.\n    if (!self.shouldHaveScreenLock) {\n        return;\n    }\n    if (self.didLastUnlockAttemptFail) {\n        return;\n    }\n    if (self.isShowingScreenLockUI) {\n        return;\n    }\n\n    DDLogInfo(@\"%@, try to unlock screen lock\", self.logTag);\n\n    self.isShowingScreenLockUI = YES;\n\n    [OWSScreenLock.sharedManager tryToUnlockScreenLockWithSuccess:^{\n        DDLogInfo(@\"%@ unlock screen lock succeeded.\", self.logTag);\n        self.isShowingScreenLockUI = NO;\n        self.lastUnlockSuccessDate = [NSDate new];\n        [self ensureScreenProtection];\n    }\n        failure:^(NSError *error) {\n            DDLogInfo(@\"%@ unlock screen lock failed.\", self.logTag);\n\n            [self clearAuthUIWhenActive];\n\n            self.didLastUnlockAttemptFail = YES;\n\n            [self showScreenLockFailureAlertWithMessage:error.localizedDescription];\n        }\n        unexpectedFailure:^(NSError *error) {\n            DDLogInfo(@\"%@ unlock screen lock unexpectedly failed.\", self.logTag);\n\n            // Local Authentication isn't working properly.\n            // This isn't covered by the docs or the forums but in practice\n            // it appears to be effective to retry again after waiting a bit.\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self clearAuthUIWhenActive];\n            });\n        }\n        cancel:^{\n            DDLogInfo(@\"%@ unlock screen lock cancelled.\", self.logTag);\n\n            [self clearAuthUIWhenActive];\n\n            self.didLastUnlockAttemptFail = YES;\n\n            // Re-show the unlock UI.\n            [self ensureScreenProtection];\n        }];\n\n    [self ensureScreenProtection];\n}\n\n- (BOOL)shouldHaveScreenProtection\n{\n    // Show 'Screen Protection' if:\n    //\n    // * App is inactive and...\n    // * 'Screen Protection' is enabled.\n    if (!self.appIsInactive) {\n        return NO;\n    } else if (!Environment.preferences.screenSecurityIsEnabled) {\n        return NO;\n    } else {\n        return YES;\n    }\n}\n\n- (BOOL)hasUnlockedScreenLock\n{\n    if (!self.lastUnlockSuccessDate) {\n        return NO;\n    } else if (!self.appEnteredBackgroundDate) {\n        return YES;\n    } else {\n        return [self.lastUnlockSuccessDate isAfterDate:self.appEnteredBackgroundDate];\n    }\n}\n\n- (BOOL)shouldHaveScreenLock\n{\n    if (![TSAccountManager isRegistered]) {\n        // Don't show 'Screen Lock' if user is not registered.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 1.\", self.logTag);\n        return NO;\n    } else if (!OWSScreenLock.sharedManager.isScreenLockEnabled) {\n        // Don't show 'Screen Lock' if 'Screen Lock' isn't enabled.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 2.\", self.logTag);\n        return NO;\n    } else if (self.hasUnlockedScreenLock) {\n        // Don't show 'Screen Lock' if 'Screen Lock' has been unlocked.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 3.\", self.logTag);\n        return NO;\n    } else if (self.appIsInBackground) {\n        // Don't show 'Screen Lock' if app is in background.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 4.\", self.logTag);\n        return NO;\n    } else if (self.isShowingScreenLockUI) {\n        // Maintain blocking window in 'screen lock' mode while we're\n        // showing the 'Unlock Screen Lock' UI.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock YES 0.\", self.logTag);\n        return YES;\n    } else if (self.appIsInactive) {\n        // Don't show 'Screen Lock' if app is inactive.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 5.\", self.logTag);\n        return NO;\n    } else if (!self.appEnteredBackgroundDate) {\n        // Show 'Screen Lock' if app has just launched.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock YES 1.\", self.logTag);\n        return YES;\n    } else {\n        OWSAssert(self.appEnteredBackgroundDate);\n\n        NSTimeInterval screenLockInterval = fabs([self.appEnteredBackgroundDate timeIntervalSinceNow]);\n        NSTimeInterval screenLockTimeout = OWSScreenLock.sharedManager.screenLockTimeout;\n        OWSAssert(screenLockInterval >= 0);\n        OWSAssert(screenLockTimeout >= 0);\n        if (screenLockInterval < screenLockTimeout) {\n            // Don't show 'Screen Lock' if 'Screen Lock' timeout hasn't elapsed.\n            DDLogVerbose(@\"%@ shouldHaveScreenLock NO 6.\", self.logTag);\n            return NO;\n        } else {\n            // Otherwise, show 'Screen Lock'.\n            DDLogVerbose(@\"%@ shouldHaveScreenLock YES 2.\", self.logTag);\n            return YES;\n        }\n    }\n}\n\n- (void)showScreenLockFailureAlertWithMessage:(NSString *)message\n{\n    OWSAssertIsOnMainThread();\n\n    [OWSAlerts showAlertWithTitle:NSLocalizedString(@\"SCREEN_LOCK_UNLOCK_FAILED\",\n                                      @\"Title for alert indicating that screen lock could not be unlocked.\")\n                          message:message\n                      buttonTitle:nil\n                     buttonAction:^(UIAlertAction *action) {\n                         // After the alert, re-show the unlock UI.\n                         [self ensureScreenProtection];\n                     }];\n}\n\n// 'Screen Blocking' window obscures the app screen:\n//\n// * In the app switcher.\n// * During 'Screen Lock' unlock process.\n- (void)prepareScreenProtectionWithRootWindow:(UIWindow *)rootWindow\n{\n    OWSAssertIsOnMainThread();\n    OWSAssert(rootWindow);\n\n    UIWindow *window = [[UIWindow alloc] initWithFrame:rootWindow.bounds];\n    window.hidden = YES;\n    window.opaque = YES;\n    window.windowLevel = CGFLOAT_MAX;\n    window.backgroundColor = UIColor.ows_materialBlueColor;\n\n    UIViewController *viewController = [UIViewController new];\n    viewController.view.backgroundColor = UIColor.ows_materialBlueColor;\n\n\n    UIView *rootView = viewController.view;\n\n    UIView *edgesView = [UIView containerView];\n    [rootView addSubview:edgesView];\n    [edgesView autoPinEdgeToSuperviewEdge:ALEdgeTop];\n    [edgesView autoPinEdgeToSuperviewEdge:ALEdgeBottom];\n    [edgesView autoPinWidthToSuperview];\n\n    UIImage *image = [UIImage imageNamed:@\"logoSignal\"];\n    UIImageView *imageView = [UIImageView new];\n    imageView.image = image;\n    [edgesView addSubview:imageView];\n    [imageView autoHCenterInSuperview];\n\n    const CGSize screenSize = UIScreen.mainScreen.bounds.size;\n    const CGFloat shortScreenDimension = MIN(screenSize.width, screenSize.height);\n    const CGFloat imageSize = round(shortScreenDimension / 3.f);\n    [imageView autoSetDimension:ALDimensionWidth toSize:imageSize];\n    [imageView autoSetDimension:ALDimensionHeight toSize:imageSize];\n\n    const CGFloat kButtonHeight = 40.f;\n    OWSFlatButton *button =\n        [OWSFlatButton buttonWithTitle:NSLocalizedString(@\"SCREEN_LOCK_UNLOCK_SIGNAL\",\n                                           @\"Label for button on lock screen that lets users unlock Signal.\")\n                                  font:[OWSFlatButton fontForHeight:kButtonHeight]\n                            titleColor:[UIColor ows_materialBlueColor]\n                       backgroundColor:[UIColor whiteColor]\n                                target:self\n                              selector:@selector(showUnlockUI)];\n    [edgesView addSubview:button];\n\n    [button autoSetDimension:ALDimensionHeight toSize:kButtonHeight];\n    [button autoPinLeadingToSuperviewWithMargin:50.f];\n    [button autoPinTrailingToSuperviewWithMargin:50.f];\n    const CGFloat kVMargin = 65.f;\n    [button autoPinBottomToSuperviewWithMargin:kVMargin];\n\n    window.rootViewController = viewController;\n\n    self.screenBlockingWindow = window;\n    self.screenBlockingViewController = viewController;\n    self.screenBlockingImageView = imageView;\n    self.screenBlockingButton = button;\n\n    [self updateScreenBlockingWindow:YES shouldHaveScreenLock:NO animated:NO];\n}\n\n// The \"screen blocking\" window has three possible states:\n//\n// * \"Just a logo\".  Used when app is launching and in app switcher.  Must match the \"Launch Screen\"\n//    storyboard pixel-for-pixel.\n// * \"Screen Lock, local auth UI presented\". Move the Signal logo so that it is visible.\n// * \"Screen Lock, local auth UI not presented\". Move the Signal logo so that it is visible,\n//    show \"unlock\" button.\n- (void)updateScreenBlockingWindow:(BOOL)shouldShowBlockWindow\n              shouldHaveScreenLock:(BOOL)shouldHaveScreenLock\n                          animated:(BOOL)animated\n{\n    OWSAssertIsOnMainThread();\n\n    self.screenBlockingWindow.hidden = !shouldShowBlockWindow;\n\n    UIView *rootView = self.screenBlockingViewController.view;\n\n    [NSLayoutConstraint deactivateConstraints:self.screenBlockingConstraints];\n\n    NSMutableArray<NSLayoutConstraint *> *screenBlockingConstraints = [NSMutableArray new];\n\n    BOOL shouldShowUnlockButton = (!self.appIsInactive && !self.appIsInBackground && self.didLastUnlockAttemptFail);\n\n    DDLogVerbose(@\"%@ updateScreenBlockingWindow. shouldShowBlockWindow: %d, shouldHaveScreenLock: %d, \"\n                 @\"shouldShowUnlockButton: %d.\",\n        self.logTag,\n        shouldShowBlockWindow,\n        shouldHaveScreenLock,\n        shouldShowUnlockButton);\n\n    NSString *signature = [NSString stringWithFormat:@\"%d %d\", shouldHaveScreenLock, self.isShowingScreenLockUI];\n    if ([NSObject isNullableObject:self.screenBlockingSignature equalTo:signature]) {\n        // Skip redundant work to avoid interfering with ongoing animations.\n        return;\n    }\n\n    self.screenBlockingButton.hidden = !shouldHaveScreenLock;\n\n    if (self.isShowingScreenLockUI) {\n        const CGFloat kVMargin = 60.f;\n        [screenBlockingConstraints addObject:[self.screenBlockingImageView autoPinEdge:ALEdgeTop\n                                                                                toEdge:ALEdgeTop\n                                                                                ofView:rootView\n                                                                            withOffset:kVMargin]];\n    } else {\n        [screenBlockingConstraints addObject:[self.screenBlockingImageView autoVCenterInSuperview]];\n    }\n\n    self.screenBlockingConstraints = screenBlockingConstraints;\n    self.screenBlockingSignature = signature;\n\n    if (animated) {\n        [UIView animateWithDuration:0.35f\n                         animations:^{\n                             [rootView layoutIfNeeded];\n                         }];\n    } else {\n        [rootView layoutIfNeeded];\n    }\n}\n\n- (void)showUnlockUI\n{\n    OWSAssertIsOnMainThread();\n\n    DDLogInfo(@\"showUnlockUI\");\n\n    self.didLastUnlockAttemptFail = NO;\n\n    [self ensureScreenProtection];\n}\n\n#pragma mark - Events\n\n- (void)screenLockDidChange:(NSNotification *)notification\n{\n    [self ensureScreenProtection];\n}\n\n- (void)registrationStateDidChange\n{\n    OWSAssertIsOnMainThread();\n\n    DDLogInfo(@\"registrationStateDidChange\");\n\n    [self ensureScreenProtection];\n}\n\n- (void)clearAuthUIWhenActive\n{\n    // For continuity, continue to present blocking screen in \"screen lock\" mode while\n    // dismissing the \"local auth UI\".\n    if (self.appIsInactive) {\n        self.shouldClearAuthUIWhenActive = YES;\n    } else {\n        self.isShowingScreenLockUI = NO;\n        [self ensureScreenProtection];\n    }\n}\n\n- (void)applicationDidBecomeActive:(NSNotification *)notification\n{\n    if (self.shouldClearAuthUIWhenActive) {\n        self.shouldClearAuthUIWhenActive = NO;\n        self.isShowingScreenLockUI = NO;\n    }\n\n    self.appIsInactive = NO;\n}\n\n- (void)applicationWillResignActive:(NSNotification *)notification\n{\n    self.appIsInactive = YES;\n}\n\n- (void)applicationWillEnterForeground:(NSNotification *)notification\n{\n    // Clear the \"delay Screen Lock UI\" state; we don't want any\n    // delays when presenting the \"unlock screen lock UI\" after\n    // returning from background.\n    self.lastUnlockSuccessDate = nil;\n\n    self.appIsInBackground = NO;\n    self.appEnteredForegroundDate = [NSDate new];\n}\n\n- (void)applicationDidEnterBackground:(NSNotification *)notification\n{\n    self.appIsInBackground = YES;\n}\n\n- (void)inactiveTimerDidFire\n{\n    [self markAppAsInBackground];\n}\n\n@end\n\nNS_ASSUME_NONNULL_END\n"], "fixing_code": ["//\n//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.\n//\n\nimport Foundation\nimport LocalAuthentication\n\n@objc public class OWSScreenLock: NSObject {\n\n    public enum OWSScreenLockOutcome {\n        case success\n        case cancel\n        case failure(error:String)\n        case unexpectedFailure(error:String)\n    }\n\n    @objc public let screenLockTimeoutDefault = 15 * kMinuteInterval\n    @objc public let screenLockTimeouts = [\n        1 * kMinuteInterval,\n        5 * kMinuteInterval,\n        15 * kMinuteInterval,\n        30 * kMinuteInterval,\n        1 * kHourInterval,\n        0\n    ]\n\n    @objc public static let ScreenLockWasEnabled = Notification.Name(\"ScreenLockWasEnabled\")\n    @objc public static let ScreenLockDidChange = Notification.Name(\"ScreenLockDidChange\")\n\n    let primaryStorage: OWSPrimaryStorage\n    let dbConnection: YapDatabaseConnection\n\n    private let OWSScreenLock_Collection = \"OWSScreenLock_Collection\"\n    private let OWSScreenLock_Key_IsScreenLockEnabled = \"OWSScreenLock_Key_IsScreenLockEnabled\"\n    private let OWSScreenLock_Key_ScreenLockTimeoutSeconds = \"OWSScreenLock_Key_ScreenLockTimeoutSeconds\"\n\n    // We don't want the verification process itself to trigger unlock verification.\n    // Passcode-code only authentication process deactivates the app.\n    private var ignoreUnlockUntilActive = false\n\n    // We temporarily resign any first responder while the Screen Lock is presented.\n    weak var firstResponderBeforeLockscreen: UIResponder?\n\n    // MARK - Singleton class\n\n    @objc(sharedManager)\n    public static let shared = OWSScreenLock()\n\n    private override init() {\n        self.primaryStorage = OWSPrimaryStorage.shared()\n        self.dbConnection = self.primaryStorage.newDatabaseConnection()\n\n        super.init()\n\n        SwiftSingletons.register(self)\n\n        NotificationCenter.default.addObserver(self,\n                                               selector: #selector(didBecomeActive),\n                                               name: NSNotification.Name.OWSApplicationDidBecomeActive,\n                                               object: nil)\n    }\n\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    func didBecomeActive() {\n        AssertIsOnMainThread()\n\n        ignoreUnlockUntilActive = false\n    }\n\n    // MARK: - Properties\n\n    @objc public func isScreenLockEnabled() -> Bool {\n        AssertIsOnMainThread()\n\n        if !OWSStorage.isStorageReady() {\n            owsFail(\"\\(logTag) accessed screen lock state before storage is ready.\")\n            return false\n        }\n\n        return self.dbConnection.bool(forKey: OWSScreenLock_Key_IsScreenLockEnabled, inCollection: OWSScreenLock_Collection, defaultValue: false)\n    }\n\n    private func setIsScreenLockEnabled(value: Bool) {\n        AssertIsOnMainThread()\n        assert(OWSStorage.isStorageReady())\n\n        let isEnabling = value && !isScreenLockEnabled()\n\n        self.dbConnection.setBool(value, forKey: OWSScreenLock_Key_IsScreenLockEnabled, inCollection: OWSScreenLock_Collection)\n\n        if isEnabling {\n            NotificationCenter.default.postNotificationNameAsync(OWSScreenLock.ScreenLockWasEnabled, object: nil)\n        }\n        NotificationCenter.default.postNotificationNameAsync(OWSScreenLock.ScreenLockDidChange, object: nil)\n    }\n\n    @objc public func screenLockTimeout() -> TimeInterval {\n        AssertIsOnMainThread()\n\n        if !OWSStorage.isStorageReady() {\n            owsFail(\"\\(logTag) accessed screen lock state before storage is ready.\")\n            return 0\n        }\n\n        return self.dbConnection.double(forKey: OWSScreenLock_Key_ScreenLockTimeoutSeconds, inCollection: OWSScreenLock_Collection, defaultValue: screenLockTimeoutDefault)\n    }\n\n    @objc public func setScreenLockTimeout(_ value: TimeInterval) {\n        AssertIsOnMainThread()\n        assert(OWSStorage.isStorageReady())\n\n        self.dbConnection.setDouble(value, forKey: OWSScreenLock_Key_ScreenLockTimeoutSeconds, inCollection: OWSScreenLock_Collection)\n\n        NotificationCenter.default.postNotificationNameAsync(OWSScreenLock.ScreenLockDidChange, object: nil)\n    }\n\n    // MARK: - Methods\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    @objc public func tryToEnableScreenLock(completion: @escaping ((Error?) -> Void)) {\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_ENABLE_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to enable 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            self.setIsScreenLockEnabled(value: true)\n                                            completion(nil)\n                                        case .cancel:\n                                            completion(nil)\n                                        }\n        })\n    }\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    @objc public func tryToDisableScreenLock(completion: @escaping ((Error?) -> Void)) {\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_DISABLE_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to disable 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            completion(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            self.setIsScreenLockEnabled(value: false)\n                                            completion(nil)\n                                        case .cancel:\n                                            completion(nil)\n                                        }\n        })\n    }\n\n    @objc public func tryToUnlockScreenLock(success: @escaping (() -> Void),\n                                            failure: @escaping ((Error) -> Void),\n                                            unexpectedFailure: @escaping ((Error) -> Void),\n                                            cancel: @escaping (() -> Void)) {\n        guard !ignoreUnlockUntilActive else {\n            DispatchQueue.main.async {\n                success()\n            }\n            return\n        }\n\n        // A popped keyboard breaks our layout and obscures the unlock button.\n        if let firstResponder = UIResponder.currentFirstResponder() {\n            Logger.debug(\"\\(self.logTag) in \\(#function) resigning first responder: \\(firstResponder)\")\n            firstResponder.resignFirstResponder()\n            self.firstResponderBeforeLockscreen = firstResponder\n        }\n\n        tryToVerifyLocalAuthentication(localizedReason: NSLocalizedString(\"SCREEN_LOCK_REASON_UNLOCK_SCREEN_LOCK\",\n                                                                        comment: \"Description of how and why Signal iOS uses Touch ID/Face ID/Phone Passcode to unlock 'screen lock'.\"),\n                                       completion: { (outcome: OWSScreenLockOutcome) in\n                                        AssertIsOnMainThread()\n\n                                        switch outcome {\n                                        case .failure(let error):\n                                            failure(self.authenticationError(errorDescription: error))\n                                        case .unexpectedFailure(let error):\n                                            unexpectedFailure(self.authenticationError(errorDescription: error))\n                                        case .success:\n                                            // It's important we restore first responder status once the user completes\n                                            // In some cases, (RegistrationLock Reminder) it just puts the keyboard back where\n                                            // the user needs it, saving them a tap.\n                                            // But in the case of an inputAccessoryView, like the ConversationViewController,\n                                            // failing to restore firstResponder could make the input toolbar disappear until\n                                            if let firstResponder = self.firstResponderBeforeLockscreen {\n                                                Logger.debug(\"\\(self.logTag) in \\(#function) regaining first responder: \\(firstResponder)\")\n                                                firstResponder.becomeFirstResponder()\n                                                self.firstResponderBeforeLockscreen = nil\n                                            }\n                                            success()\n                                        case .cancel:\n                                            cancel()\n                                        }\n        })\n    }\n\n    // On failure, completion is called with an error argument.\n    // On success or cancel, completion is called with nil argument.\n    // Success and cancel can be differentiated by consulting\n    // isScreenLockEnabled.\n    private func tryToVerifyLocalAuthentication(localizedReason: String,\n                                                completion completionParam: @escaping ((OWSScreenLockOutcome) -> Void)) {\n        AssertIsOnMainThread()\n\n        // Ensure completion is always called on the main thread.\n        let completion = { (outcome: OWSScreenLockOutcome) in\n            switch outcome {\n            case .failure(let error):\n                Logger.error(\"\\(self.logTag) local authentication failed with error: \\(error)\")\n            default:\n                break\n            }\n            DispatchQueue.main.async {\n                completionParam(outcome)\n            }\n        }\n\n        let context = screenLockContext()\n        let defaultErrorDescription = NSLocalizedString(\"SCREEN_LOCK_ENABLE_UNKNOWN_ERROR\",\n                                                        comment: \"Indicates that an unknown error occurred while using Touch ID/Face ID/Phone Passcode.\")\n\n        var authError: NSError?\n        let canEvaluatePolicy = context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &authError)\n        if !canEvaluatePolicy || authError != nil {\n            Logger.error(\"\\(logTag) could not determine if local authentication is supported: \\(String(describing: authError))\")\n\n            let outcome = self.outcomeForLAError(errorParam: authError,\n                                                 defaultErrorDescription: defaultErrorDescription)\n            switch outcome {\n            case .success:\n                owsFail(\"\\(self.logTag) local authentication unexpected success\")\n                completion(.failure(error:defaultErrorDescription))\n            case .cancel, .failure, .unexpectedFailure:\n                completion(outcome)\n            }\n            return\n        }\n\n        // Use ignoreUnlockUntilActive to suppress unlock verifications.\n        ignoreUnlockUntilActive = true\n        context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: localizedReason) { success, evaluateError in\n\n            if success {\n                Logger.info(\"\\(self.logTag) local authentication succeeded.\")\n                completion(.success)\n            } else {\n                let outcome = self.outcomeForLAError(errorParam: evaluateError,\n                                                     defaultErrorDescription: defaultErrorDescription)\n                switch outcome {\n                case .success:\n                    owsFail(\"\\(self.logTag) local authentication unexpected success\")\n                    completion(.failure(error:defaultErrorDescription))\n                case .cancel, .failure, .unexpectedFailure:\n                    completion(outcome)\n                }\n            }\n        }\n    }\n\n    // MARK: - Outcome\n\n    private func outcomeForLAError(errorParam: Error?, defaultErrorDescription: String) -> OWSScreenLockOutcome {\n        if let error = errorParam {\n            guard let laError = error as? LAError else {\n                return .failure(error:defaultErrorDescription)\n            }\n\n            if #available(iOS 11.0, *) {\n                switch laError.code {\n                case .biometryNotAvailable:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryNotAvailable.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_AVAILABLE\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode are not available on this device.\"))\n                case .biometryNotEnrolled:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryNotEnrolled.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_ENROLLED\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode is not configured on this device.\"))\n                case .biometryLockout:\n                    Logger.error(\"\\(self.logTag) local authentication error: biometryLockout.\")\n                    return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_LOCKOUT\",\n                                                             comment: \"Indicates that Touch ID/Face ID/Phone Passcode is 'locked out' on this device due to authentication failures.\"))\n                default:\n                    // Fall through to second switch\n                    break\n                }\n            }\n\n            switch laError.code {\n            case .authenticationFailed:\n                Logger.error(\"\\(self.logTag) local authentication error: authenticationFailed.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_FAILED\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode authentication failed.\"))\n            case .userCancel, .userFallback, .systemCancel, .appCancel:\n                Logger.info(\"\\(self.logTag) local authentication cancelled.\")\n                return .cancel\n            case .passcodeNotSet:\n                Logger.error(\"\\(self.logTag) local authentication error: passcodeNotSet.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_PASSCODE_NOT_SET\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode passcode is not set.\"))\n            case .touchIDNotAvailable:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDNotAvailable.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_AVAILABLE\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode are not available on this device.\"))\n            case .touchIDNotEnrolled:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDNotEnrolled.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_NOT_ENROLLED\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode is not configured on this device.\"))\n            case .touchIDLockout:\n                Logger.error(\"\\(self.logTag) local authentication error: touchIDLockout.\")\n                return .failure(error: NSLocalizedString(\"SCREEN_LOCK_ERROR_LOCAL_AUTHENTICATION_LOCKOUT\",\n                                                         comment: \"Indicates that Touch ID/Face ID/Phone Passcode is 'locked out' on this device due to authentication failures.\"))\n            case .invalidContext:\n                owsFail(\"\\(self.logTag) context not valid.\")\n                return .unexpectedFailure(error:defaultErrorDescription)\n            case .notInteractive:\n                owsFail(\"\\(self.logTag) context not interactive.\")\n                return .unexpectedFailure(error:defaultErrorDescription)\n            }\n        }\n        return .failure(error:defaultErrorDescription)\n    }\n\n    private func authenticationError(errorDescription: String) -> Error {\n        return OWSErrorWithCodeDescription(.localAuthenticationError,\n                                           errorDescription)\n    }\n\n    // MARK: - Context\n\n    private func screenLockContext() -> LAContext {\n        let context = LAContext()\n\n        // If user has set any non-zero timeout, recycle biometric auth\n        // in the same period as our normal screen lock timeout, up to\n        // max of 10 seconds.\n        context.touchIDAuthenticationAllowableReuseDuration = TimeInterval(min(10.0, screenLockTimeout()))\n\n        if #available(iOS 11.0, *) {\n            assert(!context.interactionNotAllowed)\n        }\n\n        return context\n    }\n}\n", "//\n//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.\n//\n\n#import \"OWSScreenLockUI.h\"\n#import \"Signal-Swift.h\"\n#import <SignalMessaging/SignalMessaging-Swift.h>\n#import <SignalMessaging/UIView+OWS.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface OWSScreenLockUI ()\n\n@property (nonatomic) UIWindow *screenBlockingWindow;\n@property (nonatomic) UIViewController *screenBlockingViewController;\n@property (nonatomic) UIView *screenBlockingImageView;\n@property (nonatomic) UIView *screenBlockingButton;\n@property (nonatomic) NSArray<NSLayoutConstraint *> *screenBlockingConstraints;\n@property (nonatomic) NSString *screenBlockingSignature;\n\n// Unlike UIApplication.applicationState, this state is\n// updated conservatively, e.g. the flag is cleared during\n// \"will enter background.\"\n@property (nonatomic) BOOL appIsInactive;\n@property (nonatomic) BOOL appIsInBackground;\n\n@property (nonatomic) BOOL isShowingScreenLockUI;\n@property (nonatomic) BOOL didLastUnlockAttemptFail;\n\n// We want to remain in \"screen lock\" mode while \"local auth\"\n// UI is dismissing.\n@property (nonatomic) BOOL shouldClearAuthUIWhenActive;\n\n// Indicates whether or not the user is currently locked out of\n// the app.  Only applies if OWSScreenLock.isScreenLockEnabled.\n//\n// * The user is locked out out by default on app launch.\n// * The user is also locked out if they spend more than\n//   \"timeout\" seconds outside the app.  When the user leaves\n//   the app, a \"countdown\" begins.\n@property (nonatomic) BOOL isScreenLockUnlocked;\n\n@property (nonatomic, nullable) NSDate *screenLockCountdownDate;\n\n// We normally start the \"countdown\" when the app enters the background,\n// But we also want to start the \"countdown\" if the app is inactive for\n// more than N seconds.\n@property (nonatomic, nullable) NSTimer *inactiveTimer;\n\n\n@end\n\n#pragma mark -\n\n@implementation OWSScreenLockUI\n\n+ (instancetype)sharedManager\n{\n    static OWSScreenLockUI *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] initDefault];\n    });\n    return instance;\n}\n\n- (instancetype)initDefault\n{\n    self = [super init];\n\n    if (!self) {\n        return self;\n    }\n\n    [self observeNotifications];\n\n    OWSSingletonAssert();\n\n    return self;\n}\n\n- (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n- (void)observeNotifications\n{\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationDidBecomeActive:)\n                                                 name:OWSApplicationDidBecomeActiveNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationWillResignActive:)\n                                                 name:OWSApplicationWillResignActiveNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationWillEnterForeground:)\n                                                 name:OWSApplicationWillEnterForegroundNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(applicationDidEnterBackground:)\n                                                 name:OWSApplicationDidEnterBackgroundNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(registrationStateDidChange)\n                                                 name:RegistrationStateDidChangeNotification\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(screenLockDidChange:)\n                                                 name:OWSScreenLock.ScreenLockDidChange\n                                               object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self\n                                             selector:@selector(screenLockWasEnabled:)\n                                                 name:OWSScreenLock.ScreenLockWasEnabled\n                                               object:nil];\n}\n\n- (void)setupWithRootWindow:(UIWindow *)rootWindow\n{\n    OWSAssertIsOnMainThread();\n    OWSAssert(rootWindow);\n\n    [self prepareScreenProtectionWithRootWindow:rootWindow];\n\n    [AppReadiness runNowOrWhenAppIsReady:^{\n        [self ensureScreenProtection];\n    }];\n}\n\n#pragma mark - Methods\n\n- (void)tryToActivateScreenLockUponBecomingActive\n{\n    OWSAssert(!self.appIsInactive);\n\n    if (!self.isScreenLockUnlocked) {\n        // Screen lock is already activated.\n        DDLogVerbose(@\"%@ tryToActivateScreenLockUponBecomingActive NO 0\", self.logTag);\n        return;\n    }\n    if (!self.screenLockCountdownDate) {\n        // We became inactive, but never started a countdown.\n        DDLogVerbose(@\"%@ tryToActivateScreenLockUponBecomingActive NO 1\", self.logTag);\n        return;\n    }\n    NSTimeInterval countdownInterval = fabs([self.screenLockCountdownDate timeIntervalSinceNow]);\n    OWSAssert(countdownInterval >= 0);\n    NSTimeInterval screenLockTimeout = OWSScreenLock.sharedManager.screenLockTimeout;\n    OWSAssert(screenLockTimeout >= 0);\n    if (countdownInterval >= screenLockTimeout) {\n        self.isScreenLockUnlocked = NO;\n        DDLogVerbose(@\"%@ tryToActivateScreenLockUponBecomingActive YES 1 (%0.3f >= %0.3f)\",\n            self.logTag,\n            countdownInterval,\n            screenLockTimeout);\n    } else {\n        DDLogVerbose(@\"%@ tryToActivateScreenLockUponBecomingActive NO 2 (%0.3f < %0.3f)\",\n            self.logTag,\n            countdownInterval,\n            screenLockTimeout);\n    }\n}\n\n- (void)setAppIsInactive:(BOOL)appIsInactive\n{\n    _appIsInactive = appIsInactive;\n\n    if (!appIsInactive) {\n        [self tryToActivateScreenLockUponBecomingActive];\n\n        self.screenLockCountdownDate = nil;\n    }\n\n    [self startInactiveTimerIfNecessary];\n\n    [self ensureScreenProtection];\n}\n\n- (void)setAppIsInBackground:(BOOL)appIsInBackground\n{\n    if (appIsInBackground && !_appIsInBackground) {\n        [self startScreenLockCountdownIfNecessary];\n    }\n\n    _appIsInBackground = appIsInBackground;\n\n    [self ensureScreenProtection];\n}\n\n- (void)startScreenLockCountdownIfNecessary\n{\n    if (!self.screenLockCountdownDate) {\n        DDLogVerbose(@\"%@ startScreenLockCountdownIfNecessary.\", self.logTag);\n        self.screenLockCountdownDate = [NSDate new];\n    }\n\n    self.didLastUnlockAttemptFail = NO;\n\n    [self clearInactiveTimer];\n}\n\n- (void)ensureScreenProtection\n{\n    OWSAssertIsOnMainThread();\n\n    if (!AppReadiness.isAppReady) {\n        [AppReadiness runNowOrWhenAppIsReady:^{\n            [self ensureScreenProtection];\n        }];\n        return;\n    }\n\n    BOOL shouldHaveScreenLock = self.shouldHaveScreenLock;\n    BOOL shouldHaveScreenProtection = self.shouldHaveScreenProtection;\n\n    BOOL shouldShowBlockWindow = shouldHaveScreenProtection || shouldHaveScreenLock;\n    DDLogVerbose(@\"%@, shouldHaveScreenProtection: %d, shouldHaveScreenLock: %d, shouldShowBlockWindow: %d\",\n        self.logTag,\n        shouldHaveScreenProtection,\n        shouldHaveScreenLock,\n        shouldShowBlockWindow);\n    if (self.screenBlockingWindow.hidden != !shouldShowBlockWindow) {\n        DDLogInfo(@\"%@, %@.\", self.logTag, shouldShowBlockWindow ? @\"showing block window\" : @\"hiding block window\");\n    }\n    [self updateScreenBlockingWindow:shouldShowBlockWindow shouldHaveScreenLock:shouldHaveScreenLock animated:YES];\n\n    if (shouldHaveScreenLock && !self.didLastUnlockAttemptFail) {\n        [self tryToPresentScreenLockUI];\n    }\n}\n\n- (void)tryToPresentScreenLockUI\n{\n    OWSAssertIsOnMainThread();\n\n    // If we no longer want to present the screen lock UI, abort.\n    if (!self.shouldHaveScreenLock) {\n        return;\n    }\n    if (self.didLastUnlockAttemptFail) {\n        return;\n    }\n    if (self.isShowingScreenLockUI) {\n        return;\n    }\n\n    DDLogInfo(@\"%@, try to unlock screen lock\", self.logTag);\n\n    self.isShowingScreenLockUI = YES;\n\n    [OWSScreenLock.sharedManager tryToUnlockScreenLockWithSuccess:^{\n        DDLogInfo(@\"%@ unlock screen lock succeeded.\", self.logTag);\n\n        self.isShowingScreenLockUI = NO;\n\n        self.isScreenLockUnlocked = YES;\n\n        [self ensureScreenProtection];\n    }\n        failure:^(NSError *error) {\n            DDLogInfo(@\"%@ unlock screen lock failed.\", self.logTag);\n\n            [self clearAuthUIWhenActive];\n\n            self.didLastUnlockAttemptFail = YES;\n\n            [self showScreenLockFailureAlertWithMessage:error.localizedDescription];\n        }\n        unexpectedFailure:^(NSError *error) {\n            DDLogInfo(@\"%@ unlock screen lock unexpectedly failed.\", self.logTag);\n\n            // Local Authentication isn't working properly.\n            // This isn't covered by the docs or the forums but in practice\n            // it appears to be effective to retry again after waiting a bit.\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self clearAuthUIWhenActive];\n            });\n        }\n        cancel:^{\n            DDLogInfo(@\"%@ unlock screen lock cancelled.\", self.logTag);\n\n            [self clearAuthUIWhenActive];\n\n            self.didLastUnlockAttemptFail = YES;\n\n            // Re-show the unlock UI.\n            [self ensureScreenProtection];\n        }];\n\n    [self ensureScreenProtection];\n}\n\n- (BOOL)shouldHaveScreenProtection\n{\n    // Show 'Screen Protection' if:\n    //\n    // * App is inactive and...\n    // * 'Screen Protection' is enabled.\n    if (!self.appIsInactive) {\n        return NO;\n    } else if (!Environment.preferences.screenSecurityIsEnabled) {\n        return NO;\n    } else {\n        return YES;\n    }\n}\n\n- (BOOL)shouldHaveScreenLock\n{\n    if (![TSAccountManager isRegistered]) {\n        // Don't show 'Screen Lock' if user is not registered.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 1.\", self.logTag);\n        return NO;\n    } else if (!OWSScreenLock.sharedManager.isScreenLockEnabled) {\n        // Don't show 'Screen Lock' if 'Screen Lock' isn't enabled.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 2.\", self.logTag);\n        return NO;\n    } else if (self.appIsInBackground) {\n        // Don't show 'Screen Lock' if app is in background.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 4.\", self.logTag);\n        return NO;\n    } else if (self.isShowingScreenLockUI) {\n        // Maintain blocking window in 'screen lock' mode while we're\n        // showing the 'Unlock Screen Lock' UI.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock YES 0.\", self.logTag);\n        return YES;\n    } else if (self.appIsInactive) {\n        // Don't show 'Screen Lock' if app is inactive.\n        DDLogVerbose(@\"%@ shouldHaveScreenLock NO 5.\", self.logTag);\n        return NO;\n    } else {\n        BOOL shouldHaveScreenLock = !self.isScreenLockUnlocked;\n        DDLogVerbose(@\"%@ shouldHaveScreenLock ? %d.\", self.logTag, shouldHaveScreenLock);\n        return shouldHaveScreenLock;\n    }\n}\n\n- (void)showScreenLockFailureAlertWithMessage:(NSString *)message\n{\n    OWSAssertIsOnMainThread();\n\n    [OWSAlerts showAlertWithTitle:NSLocalizedString(@\"SCREEN_LOCK_UNLOCK_FAILED\",\n                                      @\"Title for alert indicating that screen lock could not be unlocked.\")\n                          message:message\n                      buttonTitle:nil\n                     buttonAction:^(UIAlertAction *action) {\n                         // After the alert, re-show the unlock UI.\n                         [self ensureScreenProtection];\n                     }];\n}\n\n// 'Screen Blocking' window obscures the app screen:\n//\n// * In the app switcher.\n// * During 'Screen Lock' unlock process.\n- (void)prepareScreenProtectionWithRootWindow:(UIWindow *)rootWindow\n{\n    OWSAssertIsOnMainThread();\n    OWSAssert(rootWindow);\n\n    UIWindow *window = [[UIWindow alloc] initWithFrame:rootWindow.bounds];\n    window.hidden = YES;\n    window.opaque = YES;\n    window.windowLevel = CGFLOAT_MAX;\n    window.backgroundColor = UIColor.ows_materialBlueColor;\n\n    UIViewController *viewController = [UIViewController new];\n    viewController.view.backgroundColor = UIColor.ows_materialBlueColor;\n\n\n    UIView *rootView = viewController.view;\n\n    UIView *edgesView = [UIView containerView];\n    [rootView addSubview:edgesView];\n    [edgesView autoPinEdgeToSuperviewEdge:ALEdgeTop];\n    [edgesView autoPinEdgeToSuperviewEdge:ALEdgeBottom];\n    [edgesView autoPinWidthToSuperview];\n\n    UIImage *image = [UIImage imageNamed:@\"logoSignal\"];\n    UIImageView *imageView = [UIImageView new];\n    imageView.image = image;\n    [edgesView addSubview:imageView];\n    [imageView autoHCenterInSuperview];\n\n    const CGSize screenSize = UIScreen.mainScreen.bounds.size;\n    const CGFloat shortScreenDimension = MIN(screenSize.width, screenSize.height);\n    const CGFloat imageSize = round(shortScreenDimension / 3.f);\n    [imageView autoSetDimension:ALDimensionWidth toSize:imageSize];\n    [imageView autoSetDimension:ALDimensionHeight toSize:imageSize];\n\n    const CGFloat kButtonHeight = 40.f;\n    OWSFlatButton *button =\n        [OWSFlatButton buttonWithTitle:NSLocalizedString(@\"SCREEN_LOCK_UNLOCK_SIGNAL\",\n                                           @\"Label for button on lock screen that lets users unlock Signal.\")\n                                  font:[OWSFlatButton fontForHeight:kButtonHeight]\n                            titleColor:[UIColor ows_materialBlueColor]\n                       backgroundColor:[UIColor whiteColor]\n                                target:self\n                              selector:@selector(showUnlockUI)];\n    [edgesView addSubview:button];\n\n    [button autoSetDimension:ALDimensionHeight toSize:kButtonHeight];\n    [button autoPinLeadingToSuperviewWithMargin:50.f];\n    [button autoPinTrailingToSuperviewWithMargin:50.f];\n    const CGFloat kVMargin = 65.f;\n    [button autoPinBottomToSuperviewWithMargin:kVMargin];\n\n    window.rootViewController = viewController;\n\n    self.screenBlockingWindow = window;\n    self.screenBlockingViewController = viewController;\n    self.screenBlockingImageView = imageView;\n    self.screenBlockingButton = button;\n\n    [self updateScreenBlockingWindow:YES shouldHaveScreenLock:NO animated:NO];\n}\n\n// The \"screen blocking\" window has three possible states:\n//\n// * \"Just a logo\".  Used when app is launching and in app switcher.  Must match the \"Launch Screen\"\n//    storyboard pixel-for-pixel.\n// * \"Screen Lock, local auth UI presented\". Move the Signal logo so that it is visible.\n// * \"Screen Lock, local auth UI not presented\". Move the Signal logo so that it is visible,\n//    show \"unlock\" button.\n- (void)updateScreenBlockingWindow:(BOOL)shouldShowBlockWindow\n              shouldHaveScreenLock:(BOOL)shouldHaveScreenLock\n                          animated:(BOOL)animated\n{\n    OWSAssertIsOnMainThread();\n\n    self.screenBlockingWindow.hidden = !shouldShowBlockWindow;\n\n    UIView *rootView = self.screenBlockingViewController.view;\n\n    [NSLayoutConstraint deactivateConstraints:self.screenBlockingConstraints];\n\n    NSMutableArray<NSLayoutConstraint *> *screenBlockingConstraints = [NSMutableArray new];\n\n    BOOL shouldShowUnlockButton = (!self.appIsInactive && !self.appIsInBackground && self.didLastUnlockAttemptFail);\n\n    DDLogVerbose(@\"%@ updateScreenBlockingWindow. shouldShowBlockWindow: %d, shouldHaveScreenLock: %d, \"\n                 @\"shouldShowUnlockButton: %d.\",\n        self.logTag,\n        shouldShowBlockWindow,\n        shouldHaveScreenLock,\n        shouldShowUnlockButton);\n\n    NSString *signature = [NSString stringWithFormat:@\"%d %d\", shouldHaveScreenLock, self.isShowingScreenLockUI];\n    if ([NSObject isNullableObject:self.screenBlockingSignature equalTo:signature]) {\n        // Skip redundant work to avoid interfering with ongoing animations.\n        return;\n    }\n\n    self.screenBlockingButton.hidden = !shouldHaveScreenLock;\n\n    if (self.isShowingScreenLockUI) {\n        const CGFloat kVMargin = 60.f;\n        [screenBlockingConstraints addObject:[self.screenBlockingImageView autoPinEdge:ALEdgeTop\n                                                                                toEdge:ALEdgeTop\n                                                                                ofView:rootView\n                                                                            withOffset:kVMargin]];\n    } else {\n        [screenBlockingConstraints addObject:[self.screenBlockingImageView autoVCenterInSuperview]];\n    }\n\n    self.screenBlockingConstraints = screenBlockingConstraints;\n    self.screenBlockingSignature = signature;\n\n    if (animated) {\n        [UIView animateWithDuration:0.35f\n                         animations:^{\n                             [rootView layoutIfNeeded];\n                         }];\n    } else {\n        [rootView layoutIfNeeded];\n    }\n}\n\n- (void)showUnlockUI\n{\n    OWSAssertIsOnMainThread();\n\n    DDLogInfo(@\"showUnlockUI\");\n\n    self.didLastUnlockAttemptFail = NO;\n\n    [self ensureScreenProtection];\n}\n\n#pragma mark - Events\n\n- (void)screenLockDidChange:(NSNotification *)notification\n{\n    [self ensureScreenProtection];\n}\n\n- (void)screenLockWasEnabled:(NSNotification *)notification\n{\n    // When we enable screen lock, consider that an unlock.\n    self.isScreenLockUnlocked = YES;\n\n    DDLogVerbose(@\"%@ screenLockWasEnabled\", self.logTag);\n\n    [self ensureScreenProtection];\n}\n\n- (void)registrationStateDidChange\n{\n    OWSAssertIsOnMainThread();\n\n    DDLogInfo(@\"registrationStateDidChange\");\n\n    [self ensureScreenProtection];\n}\n\n- (void)clearAuthUIWhenActive\n{\n    // For continuity, continue to present blocking screen in \"screen lock\" mode while\n    // dismissing the \"local auth UI\".\n    if (self.appIsInactive) {\n        self.shouldClearAuthUIWhenActive = YES;\n    } else {\n        self.isShowingScreenLockUI = NO;\n        [self ensureScreenProtection];\n    }\n}\n\n- (void)applicationDidBecomeActive:(NSNotification *)notification\n{\n    if (self.shouldClearAuthUIWhenActive) {\n        self.shouldClearAuthUIWhenActive = NO;\n        self.isShowingScreenLockUI = NO;\n    }\n\n    self.appIsInactive = NO;\n}\n\n- (void)applicationWillResignActive:(NSNotification *)notification\n{\n    self.appIsInactive = YES;\n}\n\n- (void)applicationWillEnterForeground:(NSNotification *)notification\n{\n    self.appIsInBackground = NO;\n}\n\n- (void)applicationDidEnterBackground:(NSNotification *)notification\n{\n    self.appIsInBackground = YES;\n}\n\n#pragma mark - Inactive Timer\n\n- (void)inactiveTimerDidFire\n{\n    [self startScreenLockCountdownIfNecessary];\n}\n\n- (void)startInactiveTimerIfNecessary\n{\n    if (self.appIsInactive && !self.isShowingScreenLockUI && !self.inactiveTimer) {\n        [self.inactiveTimer invalidate];\n        self.inactiveTimer = [NSTimer weakScheduledTimerWithTimeInterval:45.f\n                                                                  target:self\n                                                                selector:@selector(inactiveTimerDidFire)\n                                                                userInfo:nil\n                                                                 repeats:NO];\n    }\n}\n\n- (void)clearInactiveTimer\n{\n    [self.inactiveTimer invalidate];\n    self.inactiveTimer = nil;\n}\n\n@end\n\nNS_ASSUME_NONNULL_END\n"], "filenames": ["Signal/src/util/OWSScreenLock.swift", "Signal/src/util/OWSScreenLockUI.m"], "buggy_code_start_loc": [26, 34], "buggy_code_end_loc": [90, 562], "fixing_code_start_loc": [27, 34], "fixing_code_end_loc": [97, 577], "type": "NVD-CWE-noinfo", "message": "The Open Whisper Signal app before 2.23.2 for iOS allows physically proximate attackers to bypass the screen locker feature via certain rapid sequences of actions that include app opening, clicking on cancel, and using the home button.", "other": {"cve": {"id": "CVE-2018-9840", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-10T05:29:00.207", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Open Whisper Signal app before 2.23.2 for iOS allows physically proximate attackers to bypass the screen locker feature via certain rapid sequences of actions that include app opening, clicking on cancel, and using the home button."}, {"lang": "es", "value": "La aplicaci\u00f3n Open Whisper Signal, en versiones anteriores a la 2.23.2 para iOS, permite que atacantes cercanos f\u00edsicamente omitan la caracter\u00edstica de bloqueo de pantalla mediante determinadas secuencias r\u00e1pidas de acciones que incluyen la apertura de apps, clics en cancelar y el uso del bot\u00f3n de inicio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:signal:signal:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "2.23.2", "matchCriteriaId": "E791C3AF-A1F9-4564-AAB1-FAE3D608F176"}]}]}], "references": [{"url": "http://nint.en.do/Signal-Bypass-Screen-locker.php", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/signalapp/Signal-iOS/commit/018a35df7b42b4941cb4dfc9f462b37c3fafd9e9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/signalapp/Signal-iOS/commits/release/2.23.2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/signalapp/Signal-iOS/commit/018a35df7b42b4941cb4dfc9f462b37c3fafd9e9"}}