{"buggy_code": ["<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * database_object\n *\n * This is a general object that is extended by all of the basic\n * database based objects in ampache. It attempts to do some standard\n * caching for all of the objects to cut down on the database calls\n *\n */\nabstract class database_object\n{\n    private static $object_cache = array();\n\n    // Statistics for debugging\n    public static $cache_hit = 0;\n    private static $_enabled = false;\n\n    /**\n     * get_info\n     * retrieves the info from the database and puts it in the cache\n     * @param integer $object_id\n     * @param string $table_name\n     * @return array\n     */\n    public function get_info($object_id, $table_name = '')\n    {\n        $table_name = $table_name ? Dba::escape($table_name) : Dba::escape(strtolower(get_class($this)));\n\n        // Make sure we've got a real id\n        if ($object_id < 1) {\n            return array();\n        }\n\n        if (self::is_cached($table_name, $object_id)) {\n            return self::get_from_cache($table_name, $object_id);\n        }\n\n        $sql        = \"SELECT * FROM `$table_name` WHERE `id`='$object_id'\";\n        $db_results = Dba::read($sql);\n\n        if (!$db_results) {\n            return array();\n        }\n\n        $row = Dba::fetch_assoc($db_results);\n\n        self::add_to_cache($table_name, $object_id, $row);\n\n        return $row;\n    } // get_info\n\n    /**\n     * clear_cache\n     */\n    public static function clear_cache()\n    {\n        self::$object_cache = array();\n    }\n\n    /**\n     * is_cached\n     * this checks the cache to see if the specified object is there\n     * @param string $index\n     * @param string $object_id\n     * @return boolean\n     */\n    public static function is_cached($index, $object_id)\n    {\n        // Make sure we've got some parents here before we dive below\n        if (!isset(self::$object_cache[$index])) {\n            return false;\n        }\n\n        return isset(self::$object_cache[$index][$object_id]);\n    } // is_cached\n\n    /**\n     * get_from_cache\n     * This attempts to retrieve the specified object from the cache we've got here\n     * @param string $index\n     * @param integer|string $object_id\n     * @return array\n     */\n    public static function get_from_cache($index, $object_id)\n    {\n        // Check if the object is set\n        if (isset(self::$object_cache[$index]) && isset(self::$object_cache[$index][$object_id])) {\n            self::$cache_hit++;\n\n            return self::$object_cache[$index][$object_id];\n        }\n\n        return array();\n    } // get_from_cache\n\n    /**\n     * add_to_cache\n     * This adds the specified object to the specified index in the cache\n     * @param string $index\n     * @param integer|string $object_id\n     * @param array $data\n     * @return boolean\n     */\n    public static function add_to_cache($index, $object_id, $data)\n    {\n        if (!self::$_enabled) {\n            return false;\n        }\n\n        $value = false;\n        if (!empty($data)) {\n            $value = $data;\n        }\n\n        self::$object_cache[$index][$object_id] = $value;\n\n        return true;\n    }\n    // add_to_cache\n\n    /**\n     * remove_from_cache\n     * This function clears something from the cache, there are a few places we need to do this\n     * in order to have things display correctly\n     * @param string $index\n     * @param integer $object_id\n     */\n    public static function remove_from_cache($index, $object_id)\n    {\n        if (isset(self::$object_cache[$index]) && isset(self::$object_cache[$index][$object_id])) {\n            unset(self::$object_cache[$index][$object_id]);\n        }\n    } // remove_from_cache\n\n    /**\n     * _auto_init\n     * Load in the cache settings once so we can avoid function calls\n     */\n    public static function _auto_init()\n    {\n        self::$_enabled = AmpConfig::get('memory_cache');\n    } // _auto_init\n} // end database_object.abstract\n"], "fixing_code": ["<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * database_object\n *\n * This is a general object that is extended by all of the basic\n * database based objects in ampache. It attempts to do some standard\n * caching for all of the objects to cut down on the database calls\n *\n */\nabstract class database_object\n{\n    private static $object_cache = array();\n\n    // Statistics for debugging\n    public static $cache_hit = 0;\n    private static $_enabled = false;\n\n    /**\n     * get_info\n     * retrieves the info from the database and puts it in the cache\n     * @param integer $object_id\n     * @param string $table_name\n     * @return array\n     */\n    public function get_info($object_id, $table_name = '')\n    {\n        $table     = $table_name ? Dba::escape($table_name) : Dba::escape(strtolower(get_class($this)));\n        $object_id = (int) $object_id;\n\n        // Make sure we've got a real id\n        if ($object_id < 1) {\n            return array();\n        }\n\n        if (self::is_cached($table, $object_id)) {\n            return self::get_from_cache($table, $object_id);\n        }\n\n        $params     = array($object_id);\n        $sql        = \"SELECT * FROM `$table` WHERE `id`= ?\";\n        $db_results = Dba::read($sql, $params);\n\n        if (!$db_results) {\n            return array();\n        }\n\n        $row = Dba::fetch_assoc($db_results);\n\n        self::add_to_cache($table, $object_id, $row);\n\n        return $row;\n    } // get_info\n\n    /**\n     * clear_cache\n     */\n    public static function clear_cache()\n    {\n        self::$object_cache = array();\n    }\n\n    /**\n     * is_cached\n     * this checks the cache to see if the specified object is there\n     * @param string $index\n     * @param string $object_id\n     * @return boolean\n     */\n    public static function is_cached($index, $object_id)\n    {\n        // Make sure we've got some parents here before we dive below\n        if (!isset(self::$object_cache[$index])) {\n            return false;\n        }\n\n        return isset(self::$object_cache[$index][$object_id]);\n    } // is_cached\n\n    /**\n     * get_from_cache\n     * This attempts to retrieve the specified object from the cache we've got here\n     * @param string $index\n     * @param integer|string $object_id\n     * @return array\n     */\n    public static function get_from_cache($index, $object_id)\n    {\n        // Check if the object is set\n        if (isset(self::$object_cache[$index]) && isset(self::$object_cache[$index][$object_id])) {\n            self::$cache_hit++;\n\n            return self::$object_cache[$index][$object_id];\n        }\n\n        return array();\n    } // get_from_cache\n\n    /**\n     * add_to_cache\n     * This adds the specified object to the specified index in the cache\n     * @param string $index\n     * @param integer|string $object_id\n     * @param array $data\n     * @return boolean\n     */\n    public static function add_to_cache($index, $object_id, $data)\n    {\n        if (!self::$_enabled) {\n            return false;\n        }\n\n        $value = false;\n        if (!empty($data)) {\n            $value = $data;\n        }\n\n        self::$object_cache[$index][$object_id] = $value;\n\n        return true;\n    }\n    // add_to_cache\n\n    /**\n     * remove_from_cache\n     * This function clears something from the cache, there are a few places we need to do this\n     * in order to have things display correctly\n     * @param string $index\n     * @param integer $object_id\n     */\n    public static function remove_from_cache($index, $object_id)\n    {\n        if (isset(self::$object_cache[$index]) && isset(self::$object_cache[$index][$object_id])) {\n            unset(self::$object_cache[$index][$object_id]);\n        }\n    } // remove_from_cache\n\n    /**\n     * _auto_init\n     * Load in the cache settings once so we can avoid function calls\n     */\n    public static function _auto_init()\n    {\n        self::$_enabled = AmpConfig::get('memory_cache');\n    } // _auto_init\n} // end database_object.abstract\n"], "filenames": ["lib/class/database_object.abstract.php"], "buggy_code_start_loc": [48], "buggy_code_end_loc": [69], "fixing_code_start_loc": [48], "fixing_code_end_loc": [71], "type": "CWE-89", "message": "Ampache before version 4.2.2 allows unauthenticated users to perform SQL injection. Refer to the referenced GitHub Security Advisory for details and a workaround. This is fixed in version 4.2.2 and the development branch.", "other": {"cve": {"id": "CVE-2020-15153", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-30T16:15:07.447", "lastModified": "2021-05-09T02:29:38.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ampache before version 4.2.2 allows unauthenticated users to perform SQL injection. Refer to the referenced GitHub Security Advisory for details and a workaround. This is fixed in version 4.2.2 and the development branch."}, {"lang": "es", "value": "Ampache versiones anteriores a 4.2.2, permite a usuarios no autenticados llevar a cabo una inyecci\u00f3n SQL.&#xa0;Consulte el Aviso de seguridad de GitHub al que se hace referencia para obtener detalles y una soluci\u00f3n alternativa.&#xa0;Esto es corregido en versi\u00f3n 4.2.2 y en la rama de desarrollo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ampache:ampache:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.2", "matchCriteriaId": "2058E2E3-F6DC-4174-A612-B0038C9EFB11"}]}]}], "references": [{"url": "https://github.com/ampache/ampache/commit/e92cb6154c32c513b9c07e5fdbf5ac7de81ef5ed", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ampache/ampache/releases/tag/4.2.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ampache/ampache/security/advisories/GHSA-phr3-mpx5-7826", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ampache/ampache/commit/e92cb6154c32c513b9c07e5fdbf5ac7de81ef5ed"}}