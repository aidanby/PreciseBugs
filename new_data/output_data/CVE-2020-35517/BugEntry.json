{"buggy_code": ["/*\n * FUSE: Filesystem in Userspace\n * Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>\n *\n * This program can be distributed under the terms of the GNU GPLv2.\n * See the file COPYING.\n */\n\n/*\n *\n * This file system mirrors the existing file system hierarchy of the\n * system, starting at the root file system. This is implemented by\n * just \"passing through\" all requests to the corresponding user-space\n * libc functions. In contrast to passthrough.c and passthrough_fh.c,\n * this implementation uses the low-level API. Its performance should\n * be the least bad among the three, but many operations are not\n * implemented. In particular, it is not possible to remove files (or\n * directories) because the code necessary to defer actual removal\n * until the file is not opened anymore would make the example much\n * more complicated.\n *\n * When writeback caching is enabled (-o writeback mount option), it\n * is only possible to write to files for which the mounting user has\n * read permissions. This is because the writeback cache requires the\n * kernel to be able to issue read requests for all files (which the\n * passthrough filesystem cannot satisfy if it can't read the file in\n * the underlying filesystem).\n *\n * Compile with:\n *\n *     gcc -Wall passthrough_ll.c `pkg-config fuse3 --cflags --libs` -o\n * passthrough_ll\n *\n * ## Source code ##\n * \\include passthrough_ll.c\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/timer.h\"\n#include \"fuse_virtio.h\"\n#include \"fuse_log.h\"\n#include \"fuse_lowlevel.h\"\n#include <assert.h>\n#include <cap-ng.h>\n#include <dirent.h>\n#include <errno.h>\n#include <glib.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/xattr.h>\n#include <syslog.h>\n#include <unistd.h>\n\n#include \"passthrough_helpers.h\"\n#include \"passthrough_seccomp.h\"\n\n/* Keep track of inode posix locks for each owner. */\nstruct lo_inode_plock {\n    uint64_t lock_owner;\n    int fd; /* fd for OFD locks */\n};\n\nstruct lo_map_elem {\n    union {\n        struct lo_inode *inode;\n        struct lo_dirp *dirp;\n        int fd;\n        ssize_t freelist;\n    };\n    bool in_use;\n};\n\n/* Maps FUSE fh or ino values to internal objects */\nstruct lo_map {\n    struct lo_map_elem *elems;\n    size_t nelems;\n    ssize_t freelist;\n};\n\nstruct lo_key {\n    ino_t ino;\n    dev_t dev;\n};\n\nstruct lo_inode {\n    int fd;\n\n    /*\n     * Atomic reference count for this object.  The nlookup field holds a\n     * reference and release it when nlookup reaches 0.\n     */\n    gint refcount;\n\n    struct lo_key key;\n\n    /*\n     * This counter keeps the inode alive during the FUSE session.\n     * Incremented when the FUSE inode number is sent in a reply\n     * (FUSE_LOOKUP, FUSE_READDIRPLUS, etc).  Decremented when an inode is\n     * released by requests like FUSE_FORGET, FUSE_RMDIR, FUSE_RENAME, etc.\n     *\n     * Note that this value is untrusted because the client can manipulate\n     * it arbitrarily using FUSE_FORGET requests.\n     *\n     * Protected by lo->mutex.\n     */\n    uint64_t nlookup;\n\n    fuse_ino_t fuse_ino;\n    pthread_mutex_t plock_mutex;\n    GHashTable *posix_locks; /* protected by lo_inode->plock_mutex */\n\n    mode_t filetype;\n};\n\nstruct lo_cred {\n    uid_t euid;\n    gid_t egid;\n};\n\nenum {\n    CACHE_NONE,\n    CACHE_AUTO,\n    CACHE_ALWAYS,\n};\n\nstruct lo_data {\n    pthread_mutex_t mutex;\n    int debug;\n    int writeback;\n    int flock;\n    int posix_lock;\n    int xattr;\n    char *source;\n    char *modcaps;\n    double timeout;\n    int cache;\n    int timeout_set;\n    int readdirplus_set;\n    int readdirplus_clear;\n    int allow_direct_io;\n    struct lo_inode root;\n    GHashTable *inodes; /* protected by lo->mutex */\n    struct lo_map ino_map; /* protected by lo->mutex */\n    struct lo_map dirp_map; /* protected by lo->mutex */\n    struct lo_map fd_map; /* protected by lo->mutex */\n\n    /* An O_PATH file descriptor to /proc/self/fd/ */\n    int proc_self_fd;\n};\n\nstatic const struct fuse_opt lo_opts[] = {\n    { \"writeback\", offsetof(struct lo_data, writeback), 1 },\n    { \"no_writeback\", offsetof(struct lo_data, writeback), 0 },\n    { \"source=%s\", offsetof(struct lo_data, source), 0 },\n    { \"flock\", offsetof(struct lo_data, flock), 1 },\n    { \"no_flock\", offsetof(struct lo_data, flock), 0 },\n    { \"posix_lock\", offsetof(struct lo_data, posix_lock), 1 },\n    { \"no_posix_lock\", offsetof(struct lo_data, posix_lock), 0 },\n    { \"xattr\", offsetof(struct lo_data, xattr), 1 },\n    { \"no_xattr\", offsetof(struct lo_data, xattr), 0 },\n    { \"modcaps=%s\", offsetof(struct lo_data, modcaps), 0 },\n    { \"timeout=%lf\", offsetof(struct lo_data, timeout), 0 },\n    { \"timeout=\", offsetof(struct lo_data, timeout_set), 1 },\n    { \"cache=none\", offsetof(struct lo_data, cache), CACHE_NONE },\n    { \"cache=auto\", offsetof(struct lo_data, cache), CACHE_AUTO },\n    { \"cache=always\", offsetof(struct lo_data, cache), CACHE_ALWAYS },\n    { \"readdirplus\", offsetof(struct lo_data, readdirplus_set), 1 },\n    { \"no_readdirplus\", offsetof(struct lo_data, readdirplus_clear), 1 },\n    { \"allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 1 },\n    { \"no_allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 0 },\n    FUSE_OPT_END\n};\nstatic bool use_syslog = false;\nstatic int current_log_level;\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n/* That we loaded cap-ng in the current thread from the saved */\nstatic __thread bool cap_loaded = 0;\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}\n\n/* Is `path` a single path component that is not \".\" or \"..\"? */\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}\n\nstatic struct lo_data *lo_data(fuse_req_t req)\n{\n    return (struct lo_data *)fuse_req_userdata(req);\n}\n\n/*\n * Load capng's state from our saved state if the current thread\n * hadn't previously been loaded.\n * returns 0 on success\n */\nstatic int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}\n\n/*\n * Helpers for dropping and regaining effective capabilities. Returns 0\n * on success, error otherwise\n */\nstatic int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}\n\nstatic int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}\n\nstatic void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}\n\nstatic void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}\n\nstatic int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}\n\nstatic struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}\n\n/* Caller must release refcount using lo_inode_put() */\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}\n\n/*\n * TODO Remove this helper and force callers to hold an inode refcount until\n * they are done with the fd.  This will be done in a later patch to make\n * review easier.\n */\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}\n\nstatic void lo_init(void *userdata, struct fuse_conn_info *conn)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    if (conn->capable & FUSE_CAP_EXPORT_SUPPORT) {\n        conn->want |= FUSE_CAP_EXPORT_SUPPORT;\n    }\n\n    if (lo->writeback && conn->capable & FUSE_CAP_WRITEBACK_CACHE) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating writeback\\n\");\n        conn->want |= FUSE_CAP_WRITEBACK_CACHE;\n    }\n    if (conn->capable & FUSE_CAP_FLOCK_LOCKS) {\n        if (lo->flock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating flock locks\\n\");\n            conn->want |= FUSE_CAP_FLOCK_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling flock locks\\n\");\n            conn->want &= ~FUSE_CAP_FLOCK_LOCKS;\n        }\n    }\n\n    if (conn->capable & FUSE_CAP_POSIX_LOCKS) {\n        if (lo->posix_lock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating posix locks\\n\");\n            conn->want |= FUSE_CAP_POSIX_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling posix locks\\n\");\n            conn->want &= ~FUSE_CAP_POSIX_LOCKS;\n        }\n    }\n\n    if ((lo->cache == CACHE_NONE && !lo->readdirplus_set) ||\n        lo->readdirplus_clear) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling readdirplus\\n\");\n        conn->want &= ~FUSE_CAP_READDIRPLUS;\n    }\n}\n\nstatic void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}\n\nstatic void lo_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,\n                       int valid, struct fuse_file_info *fi)\n{\n    int saverr;\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    int ifd;\n    int res;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    ifd = inode->fd;\n\n    /* If fi->fh is invalid we'll report EBADF later */\n    if (fi) {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (valid & FUSE_SET_ATTR_MODE) {\n        if (fi) {\n            res = fchmod(fd, attr->st_mode);\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            res = fchmodat(lo->proc_self_fd, procname, attr->st_mode, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {\n        uid_t uid = (valid & FUSE_SET_ATTR_UID) ? attr->st_uid : (uid_t)-1;\n        gid_t gid = (valid & FUSE_SET_ATTR_GID) ? attr->st_gid : (gid_t)-1;\n\n        res = fchownat(ifd, \"\", uid, gid, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & FUSE_SET_ATTR_SIZE) {\n        int truncfd;\n\n        if (fi) {\n            truncfd = fd;\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            truncfd = openat(lo->proc_self_fd, procname, O_RDWR);\n            if (truncfd < 0) {\n                goto out_err;\n            }\n        }\n\n        res = ftruncate(truncfd, attr->st_size);\n        if (!fi) {\n            saverr = errno;\n            close(truncfd);\n            errno = saverr;\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {\n        struct timespec tv[2];\n\n        tv[0].tv_sec = 0;\n        tv[1].tv_sec = 0;\n        tv[0].tv_nsec = UTIME_OMIT;\n        tv[1].tv_nsec = UTIME_OMIT;\n\n        if (valid & FUSE_SET_ATTR_ATIME_NOW) {\n            tv[0].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_ATIME) {\n            tv[0] = attr->st_atim;\n        }\n\n        if (valid & FUSE_SET_ATTR_MTIME_NOW) {\n            tv[1].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_MTIME) {\n            tv[1] = attr->st_mtim;\n        }\n\n        if (fi) {\n            res = futimens(fd, tv);\n        } else {\n            sprintf(procname, \"%i\", inode->fd);\n            res = utimensat(lo->proc_self_fd, procname, tv, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    lo_inode_put(lo, &inode);\n\n    return lo_getattr(req, ino, fi);\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}\n\n/* value_destroy_func for posix_locks GHashTable */\nstatic void posix_locks_value_destroy(gpointer data)\n{\n    struct lo_inode_plock *plock = data;\n\n    /*\n     * We had used open() for locks and had only one fd. So\n     * closing this fd should release all OFD locks.\n     */\n    close(plock->fd);\n    free(plock);\n}\n\n/*\n * Increments nlookup and caller must release refcount using\n * lo_inode_put(&parent).\n */\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}\n\nstatic void lo_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    struct fuse_entry_param e;\n    int err;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_lookup(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    /*\n     * Don't use is_safe_path_component(), allow \".\" and \"..\" for NFS export\n     * support.\n     */\n    if (strchr(name, '/')) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    err = lo_do_lookup(req, parent, name, &e);\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_entry(req, &e);\n    }\n}\n\n/*\n * On some archs, setres*id is limited to 2^16 but they\n * provide setres*id32 variants that allow 2^32.\n * Others just let setres*id do 2^32 anyway.\n */\n#ifdef SYS_setresgid32\n#define OURSYS_setresgid SYS_setresgid32\n#else\n#define OURSYS_setresgid SYS_setresgid\n#endif\n\n#ifdef SYS_setresuid32\n#define OURSYS_setresuid SYS_setresuid32\n#else\n#define OURSYS_setresuid SYS_setresuid\n#endif\n\n/*\n * Change to uid/gid of caller so that file is created with\n * ownership of caller.\n * TODO: What about selinux context?\n */\nstatic int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}\n\n/* Regain Privileges */\nstatic void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode, dev_t rdev)\n{\n    lo_mknod_symlink(req, parent, name, mode, rdev, NULL);\n}\n\nstatic void lo_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode)\n{\n    lo_mknod_symlink(req, parent, name, S_IFDIR | mode, 0, NULL);\n}\n\nstatic void lo_symlink(fuse_req_t req, const char *link, fuse_ino_t parent,\n                       const char *name)\n{\n    lo_mknod_symlink(req, parent, name, S_IFLNK, 0, link);\n}\n\nstatic void lo_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t parent,\n                    const char *name)\n{\n    int res;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct lo_inode *inode;\n    struct fuse_entry_param e;\n    char procname[64];\n    int saverr;\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    inode = lo_inode(req, ino);\n    if (!parent_inode || !inode) {\n        errno = EBADF;\n        goto out_err;\n    }\n\n    memset(&e, 0, sizeof(struct fuse_entry_param));\n    e.attr_timeout = lo->timeout;\n    e.entry_timeout = lo->timeout;\n\n    sprintf(procname, \"%i\", inode->fd);\n    res = linkat(lo->proc_self_fd, procname, parent_inode->fd, name,\n                 AT_SYMLINK_FOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(inode->fd, \"\", &e.attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    inode->nlookup++;\n    pthread_mutex_unlock(&lo->mutex);\n    e.ino = inode->fuse_ino;\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\n/* Increments nlookup and caller must release refcount using lo_inode_put() */\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}\n\nstatic void lo_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, AT_REMOVEDIR);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}\n\nstatic void lo_rename(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      fuse_ino_t newparent, const char *newname,\n                      unsigned int flags)\n{\n    int res;\n    struct lo_inode *parent_inode;\n    struct lo_inode *newparent_inode;\n    struct lo_inode *oldinode = NULL;\n    struct lo_inode *newinode = NULL;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name) || !is_safe_path_component(newname)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    newparent_inode = lo_inode(req, newparent);\n    if (!parent_inode || !newparent_inode) {\n        fuse_reply_err(req, EBADF);\n        goto out;\n    }\n\n    oldinode = lookup_name(req, parent, name);\n    newinode = lookup_name(req, newparent, newname);\n\n    if (!oldinode) {\n        fuse_reply_err(req, EIO);\n        goto out;\n    }\n\n    if (flags) {\n#ifndef SYS_renameat2\n        fuse_reply_err(req, EINVAL);\n#else\n        res = syscall(SYS_renameat2, parent_inode->fd, name,\n                        newparent_inode->fd, newname, flags);\n        if (res == -1 && errno == ENOSYS) {\n            fuse_reply_err(req, EINVAL);\n        } else {\n            fuse_reply_err(req, res == -1 ? errno : 0);\n        }\n#endif\n        goto out;\n    }\n\n    res = renameat(parent_inode->fd, name, newparent_inode->fd, newname);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\nout:\n    unref_inode_lolocked(lo, oldinode, 1);\n    unref_inode_lolocked(lo, newinode, 1);\n    lo_inode_put(lo, &oldinode);\n    lo_inode_put(lo, &newinode);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &newparent_inode);\n}\n\nstatic void lo_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, 0);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}\n\n/* To be called with lo->mutex held */\nstatic void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    assert(inode->nlookup >= n);\n    inode->nlookup -= n;\n    if (!inode->nlookup) {\n        lo_map_remove(&lo->ino_map, inode->fuse_ino);\n        g_hash_table_remove(lo->inodes, &inode->key);\n        if (g_hash_table_size(inode->posix_locks)) {\n            fuse_log(FUSE_LOG_WARNING, \"Hash table is not empty\\n\");\n        }\n        g_hash_table_destroy(inode->posix_locks);\n        pthread_mutex_destroy(&inode->plock_mutex);\n\n        /* Drop our refcount from lo_do_lookup() */\n        lo_inode_put(lo, &inode);\n    }\n}\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}\n\nstatic void lo_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    lo_forget_one(req, ino, nlookup);\n    fuse_reply_none(req);\n}\n\nstatic void lo_forget_multi(fuse_req_t req, size_t count,\n                            struct fuse_forget_data *forgets)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        lo_forget_one(req, forgets[i].ino, forgets[i].nlookup);\n    }\n    fuse_reply_none(req);\n}\n\nstatic void lo_readlink(fuse_req_t req, fuse_ino_t ino)\n{\n    char buf[PATH_MAX + 1];\n    int res;\n\n    res = readlinkat(lo_fd(req, ino), \"\", buf, sizeof(buf));\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    if (res == sizeof(buf)) {\n        return (void)fuse_reply_err(req, ENAMETOOLONG);\n    }\n\n    buf[res] = '\\0';\n\n    fuse_reply_readlink(req, buf);\n}\n\nstruct lo_dirp {\n    gint refcount;\n    DIR *dp;\n    struct dirent *entry;\n    off_t offset;\n};\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}\n\n/* Call lo_dirp_put() on the return value when no longer needed */\nstatic struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}\n\nstatic void lo_opendir(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int error = ENOMEM;\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d;\n    int fd;\n    ssize_t fh;\n\n    d = calloc(1, sizeof(struct lo_dirp));\n    if (d == NULL) {\n        goto out_err;\n    }\n\n    fd = openat(lo_fd(req, ino), \".\", O_RDONLY);\n    if (fd == -1) {\n        goto out_errno;\n    }\n\n    d->dp = fdopendir(fd);\n    if (d->dp == NULL) {\n        goto out_errno;\n    }\n\n    d->offset = 0;\n    d->entry = NULL;\n\n    g_atomic_int_set(&d->refcount, 1); /* paired with lo_releasedir() */\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_dirp_mapping(req, d);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        goto out_err;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_ALWAYS) {\n        fi->cache_readdir = 1;\n    }\n    fuse_reply_open(req, fi);\n    return;\n\nout_errno:\n    error = errno;\nout_err:\n    if (d) {\n        if (d->dp) {\n            closedir(d->dp);\n        } else if (fd != -1) {\n            close(fd);\n        }\n        free(d);\n    }\n    fuse_reply_err(req, error);\n}\n\nstatic void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}\n\nstatic void lo_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                       off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 0);\n}\n\nstatic void lo_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,\n                           off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 1);\n}\n\nstatic void lo_releasedir(fuse_req_t req, fuse_ino_t ino,\n                          struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    struct lo_dirp *d;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (!elem) {\n        pthread_mutex_unlock(&lo->mutex);\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    d = elem->dirp;\n    lo_map_remove(&lo->dirp_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    lo_dirp_put(&d); /* paired with lo_opendir() */\n\n    fuse_reply_err(req, 0);\n}\n\nstatic void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}\n\nstatic void lo_create(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      mode_t mode, struct fuse_file_info *fi)\n{\n    int fd;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct fuse_entry_param e;\n    int err;\n    struct lo_cred old = {};\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_create(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    if (!parent_inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    err = lo_change_cred(req, &old);\n    if (err) {\n        goto out;\n    }\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    fd = openat(parent_inode->fd, name, (fi->flags | O_CREAT) & ~O_NOFOLLOW,\n                mode);\n    err = fd == -1 ? errno : 0;\n    lo_restore_cred(&old);\n\n    if (!err) {\n        ssize_t fh;\n\n        pthread_mutex_lock(&lo->mutex);\n        fh = lo_add_fd_mapping(req, fd);\n        pthread_mutex_unlock(&lo->mutex);\n        if (fh == -1) {\n            close(fd);\n            err = ENOMEM;\n            goto out;\n        }\n\n        fi->fh = fh;\n        err = lo_do_lookup(req, parent, name, &e);\n    }\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n\nout:\n    lo_inode_put(lo, &parent_inode);\n\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_create(req, &e, fi);\n    }\n}\n\n/* Should be called with inode->plock_mutex held */\nstatic struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}\n\nstatic void lo_getlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_getlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" owner=0x%lx, l_type=%d l_start=0x%lx\"\n             \" l_len=0x%lx\\n\",\n             ino, fi->flags, fi->lock_owner, lock->l_type, lock->l_start,\n             lock->l_len);\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    ret = fcntl(plock->fd, F_OFD_GETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    if (saverr) {\n        fuse_reply_err(req, saverr);\n    } else {\n        fuse_reply_lock(req, lock);\n    }\n}\n\nstatic void lo_setlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock, int sleep)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_setlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" cmd=%d pid=%d owner=0x%lx sleep=%d l_whence=%d\"\n             \" l_start=0x%lx l_len=0x%lx\\n\",\n             ino, fi->flags, lock->l_type, lock->l_pid, fi->lock_owner, sleep,\n             lock->l_whence, lock->l_start, lock->l_len);\n\n    if (sleep) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    /* TODO: Is it alright to modify flock? */\n    lock->l_pid = 0;\n    ret = fcntl(plock->fd, F_OFD_SETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,\n                        struct fuse_file_info *fi)\n{\n    int res;\n    struct lo_dirp *d;\n    int fd;\n\n    (void)ino;\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    fd = dirfd(d->dp);\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n\n    lo_dirp_put(&d);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}\n\nstatic void lo_release(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    int fd = -1;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    if (elem) {\n        fd = elem->fd;\n        elem = NULL;\n        lo_map_remove(&lo->fd_map, fi->fh);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    close(fd);\n    fuse_reply_err(req, 0);\n}\n\nstatic void lo_flush(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int res;\n    (void)ino;\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    /* An fd is going away. Cleanup associated posix locks */\n    pthread_mutex_lock(&inode->plock_mutex);\n    g_hash_table_remove(inode->posix_locks, GUINT_TO_POINTER(fi->lock_owner));\n    pthread_mutex_unlock(&inode->plock_mutex);\n\n    res = close(dup(lo_fi_fd(req, fi)));\n    lo_inode_put(lo_data(req), &inode);\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,\n                     struct fuse_file_info *fi)\n{\n    int res;\n    int fd;\n    char *buf;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_fsync(ino=%\" PRIu64 \", fi=0x%p)\\n\", ino,\n             (void *)fi);\n\n    if (!fi) {\n        struct lo_data *lo = lo_data(req);\n\n        res = asprintf(&buf, \"%i\", lo_fd(req, ino));\n        if (res == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n\n        fd = openat(lo->proc_self_fd, buf, O_RDWR);\n        free(buf);\n        if (fd == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n    } else {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n    if (!fi) {\n        close(fd);\n    }\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t offset,\n                    struct fuse_file_info *fi)\n{\n    struct fuse_bufvec buf = FUSE_BUFVEC_INIT(size);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_read(ino=%\" PRIu64 \", size=%zd, \"\n             \"off=%lu)\\n\",\n             ino, size, (unsigned long)offset);\n\n    buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    buf.buf[0].fd = lo_fi_fd(req, fi);\n    buf.buf[0].pos = offset;\n\n    fuse_reply_data(req, &buf);\n}\n\nstatic void lo_write_buf(fuse_req_t req, fuse_ino_t ino,\n                         struct fuse_bufvec *in_buf, off_t off,\n                         struct fuse_file_info *fi)\n{\n    (void)ino;\n    ssize_t res;\n    struct fuse_bufvec out_buf = FUSE_BUFVEC_INIT(fuse_buf_size(in_buf));\n    bool cap_fsetid_dropped = false;\n\n    out_buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    out_buf.buf[0].fd = lo_fi_fd(req, fi);\n    out_buf.buf[0].pos = off;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_write_buf(ino=%\" PRIu64 \", size=%zd, off=%lu)\\n\", ino,\n             out_buf.buf[0].size, (unsigned long)off);\n\n    /*\n     * If kill_priv is set, drop CAP_FSETID which should lead to kernel\n     * clearing setuid/setgid on file.\n     */\n    if (fi->kill_priv) {\n        res = drop_effective_cap(\"FSETID\", &cap_fsetid_dropped);\n        if (res != 0) {\n            fuse_reply_err(req, res);\n            return;\n        }\n    }\n\n    res = fuse_buf_copy(&out_buf, in_buf);\n    if (res < 0) {\n        fuse_reply_err(req, -res);\n    } else {\n        fuse_reply_write(req, (size_t)res);\n    }\n\n    if (cap_fsetid_dropped) {\n        res = gain_effective_cap(\"FSETID\");\n        if (res) {\n            fuse_log(FUSE_LOG_ERR, \"Failed to gain CAP_FSETID\\n\");\n        }\n    }\n}\n\nstatic void lo_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    int res;\n    struct statvfs stbuf;\n\n    res = fstatvfs(lo_fd(req, ino), &stbuf);\n    if (res == -1) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_statfs(req, &stbuf);\n    }\n}\n\nstatic void lo_fallocate(fuse_req_t req, fuse_ino_t ino, int mode, off_t offset,\n                         off_t length, struct fuse_file_info *fi)\n{\n    int err = EOPNOTSUPP;\n    (void)ino;\n\n#ifdef CONFIG_FALLOCATE\n    err = fallocate(lo_fi_fd(req, fi), mode, offset, length);\n    if (err < 0) {\n        err = errno;\n    }\n\n#elif defined(CONFIG_POSIX_FALLOCATE)\n    if (mode) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    err = posix_fallocate(lo_fi_fd(req, fi), offset, length);\n#endif\n\n    fuse_reply_err(req, err);\n}\n\nstatic void lo_flock(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     int op)\n{\n    int res;\n    (void)ino;\n\n    res = flock(lo_fi_fd(req, fi), op);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\",\n             ino, name, size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    /*\n     * It is not safe to open() non-regular/non-dir files in file server\n     * unless O_PATH is used, so use that method for regular files/dir\n     * only (as it seems giving less performance overhead).\n     * Otherwise, call fchdir() to avoid open().\n     */\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = fgetxattr(fd, name, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = getxattr(procname, name, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}\n\nstatic void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\", ino,\n             size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = flistxattr(fd, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = listxattr(procname, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}\n\nstatic void lo_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        const char *value, size_t size, int flags)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_setxattr(ino=%\" PRIu64\n             \", name=%s value=%s size=%zd)\\n\", ino, name, value, size);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fsetxattr(fd, name, value, size, flags);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = setxattr(procname, name, value, size, flags);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_removexattr(ino=%\" PRIu64 \", name=%s)\\n\", ino,\n             name);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fremovexattr(fd, name);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = removexattr(procname, name);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\n#ifdef HAVE_COPY_FILE_RANGE\nstatic void lo_copy_file_range(fuse_req_t req, fuse_ino_t ino_in, off_t off_in,\n                               struct fuse_file_info *fi_in, fuse_ino_t ino_out,\n                               off_t off_out, struct fuse_file_info *fi_out,\n                               size_t len, int flags)\n{\n    int in_fd, out_fd;\n    ssize_t res;\n\n    in_fd = lo_fi_fd(req, fi_in);\n    out_fd = lo_fi_fd(req, fi_out);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_copy_file_range(ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, size=%zd, flags=0x%x)\\n\",\n             ino_in, in_fd, off_in, ino_out, out_fd, off_out, len, flags);\n\n    res = copy_file_range(in_fd, &off_in, out_fd, &off_out, len, flags);\n    if (res < 0) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_write(req, res);\n    }\n}\n#endif\n\nstatic void lo_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,\n                     struct fuse_file_info *fi)\n{\n    off_t res;\n\n    (void)ino;\n    res = lseek(lo_fi_fd(req, fi), off, whence);\n    if (res != -1) {\n        fuse_reply_lseek(req, res);\n    } else {\n        fuse_reply_err(req, errno);\n    }\n}\n\nstatic void lo_destroy(void *userdata)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    pthread_mutex_lock(&lo->mutex);\n    while (true) {\n        GHashTableIter iter;\n        gpointer key, value;\n\n        g_hash_table_iter_init(&iter, lo->inodes);\n        if (!g_hash_table_iter_next(&iter, &key, &value)) {\n            break;\n        }\n\n        struct lo_inode *inode = value;\n        unref_inode(lo, inode, inode->nlookup);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n}\n\nstatic struct fuse_lowlevel_ops lo_oper = {\n    .init = lo_init,\n    .lookup = lo_lookup,\n    .mkdir = lo_mkdir,\n    .mknod = lo_mknod,\n    .symlink = lo_symlink,\n    .link = lo_link,\n    .unlink = lo_unlink,\n    .rmdir = lo_rmdir,\n    .rename = lo_rename,\n    .forget = lo_forget,\n    .forget_multi = lo_forget_multi,\n    .getattr = lo_getattr,\n    .setattr = lo_setattr,\n    .readlink = lo_readlink,\n    .opendir = lo_opendir,\n    .readdir = lo_readdir,\n    .readdirplus = lo_readdirplus,\n    .releasedir = lo_releasedir,\n    .fsyncdir = lo_fsyncdir,\n    .create = lo_create,\n    .getlk = lo_getlk,\n    .setlk = lo_setlk,\n    .open = lo_open,\n    .release = lo_release,\n    .flush = lo_flush,\n    .fsync = lo_fsync,\n    .read = lo_read,\n    .write_buf = lo_write_buf,\n    .statfs = lo_statfs,\n    .fallocate = lo_fallocate,\n    .flock = lo_flock,\n    .getxattr = lo_getxattr,\n    .listxattr = lo_listxattr,\n    .setxattr = lo_setxattr,\n    .removexattr = lo_removexattr,\n#ifdef HAVE_COPY_FILE_RANGE\n    .copy_file_range = lo_copy_file_range,\n#endif\n    .lseek = lo_lseek,\n    .destroy = lo_destroy,\n};\n\n/* Print vhost-user.json backend program capabilities */\nstatic void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}\n\n/*\n * Drop all Linux capabilities because the wait parent process only needs to\n * sit in waitpid(2) and terminate.\n */\nstatic void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}\n\n/*\n * Move to a new mount, net, and pid namespaces to isolate this process.\n */\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}\n\n/*\n * Capture the capability state, we'll need to restore this for individual\n * threads later; see load_capng.\n */\nstatic void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}\n\nstatic void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}\n\n\n/*\n * Make the source directory our root so symlinks cannot escape and no other\n * files are accessible.  Assumes unshare(CLONE_NEWNS) was already called.\n */\nstatic void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}\n\n/*\n * Only keep whitelisted capabilities that are needed for file system operation\n * The (possibly NULL) modcaps_in string passed in is free'd before exit.\n */\nstatic void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}\n\n/*\n * Lock down this process to prevent access to other processes or files outside\n * source directory.  This reduces the impact of arbitrary code execution bugs.\n */\nstatic void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}\n\n/* Set the maximum number of open file descriptors */\nstatic void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}\n\nstatic void log_func(enum fuse_log_level level, const char *fmt, va_list ap)\n{\n    g_autofree char *localfmt = NULL;\n\n    if (current_log_level < level) {\n        return;\n    }\n\n    if (current_log_level == FUSE_LOG_DEBUG) {\n        if (!use_syslog) {\n            localfmt = g_strdup_printf(\"[%\" PRId64 \"] [ID: %08ld] %s\",\n                                       get_clock(), syscall(__NR_gettid), fmt);\n        } else {\n            localfmt = g_strdup_printf(\"[ID: %08ld] %s\", syscall(__NR_gettid),\n                                       fmt);\n        }\n        fmt = localfmt;\n    }\n\n    if (use_syslog) {\n        int priority = LOG_ERR;\n        switch (level) {\n        case FUSE_LOG_EMERG:\n            priority = LOG_EMERG;\n            break;\n        case FUSE_LOG_ALERT:\n            priority = LOG_ALERT;\n            break;\n        case FUSE_LOG_CRIT:\n            priority = LOG_CRIT;\n            break;\n        case FUSE_LOG_ERR:\n            priority = LOG_ERR;\n            break;\n        case FUSE_LOG_WARNING:\n            priority = LOG_WARNING;\n            break;\n        case FUSE_LOG_NOTICE:\n            priority = LOG_NOTICE;\n            break;\n        case FUSE_LOG_INFO:\n            priority = LOG_INFO;\n            break;\n        case FUSE_LOG_DEBUG:\n            priority = LOG_DEBUG;\n            break;\n        }\n        vsyslog(priority, fmt, ap);\n    } else {\n        vfprintf(stderr, fmt, ap);\n    }\n}\n\nstatic void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}\n\nstatic guint lo_key_hash(gconstpointer key)\n{\n    const struct lo_key *lkey = key;\n\n    return (guint)lkey->ino + (guint)lkey->dev;\n}\n\nstatic gboolean lo_key_equal(gconstpointer a, gconstpointer b)\n{\n    const struct lo_key *la = a;\n    const struct lo_key *lb = b;\n\n    return la->ino == lb->ino && la->dev == lb->dev;\n}\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}\n\nint main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n    };\n    struct lo_map_elem *root_elem;\n    int ret = -1;\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    lo_map_reserve(&lo.ino_map, 0)->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    /*\n     * log_level is 0 if not configured via cmd options (0 is LOG_EMERG,\n     * and we don't use this log level).\n     */\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n    }\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}\n"], "fixing_code": ["/*\n * FUSE: Filesystem in Userspace\n * Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>\n *\n * This program can be distributed under the terms of the GNU GPLv2.\n * See the file COPYING.\n */\n\n/*\n *\n * This file system mirrors the existing file system hierarchy of the\n * system, starting at the root file system. This is implemented by\n * just \"passing through\" all requests to the corresponding user-space\n * libc functions. In contrast to passthrough.c and passthrough_fh.c,\n * this implementation uses the low-level API. Its performance should\n * be the least bad among the three, but many operations are not\n * implemented. In particular, it is not possible to remove files (or\n * directories) because the code necessary to defer actual removal\n * until the file is not opened anymore would make the example much\n * more complicated.\n *\n * When writeback caching is enabled (-o writeback mount option), it\n * is only possible to write to files for which the mounting user has\n * read permissions. This is because the writeback cache requires the\n * kernel to be able to issue read requests for all files (which the\n * passthrough filesystem cannot satisfy if it can't read the file in\n * the underlying filesystem).\n *\n * Compile with:\n *\n *     gcc -Wall passthrough_ll.c `pkg-config fuse3 --cflags --libs` -o\n * passthrough_ll\n *\n * ## Source code ##\n * \\include passthrough_ll.c\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/timer.h\"\n#include \"fuse_virtio.h\"\n#include \"fuse_log.h\"\n#include \"fuse_lowlevel.h\"\n#include <assert.h>\n#include <cap-ng.h>\n#include <dirent.h>\n#include <errno.h>\n#include <glib.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/xattr.h>\n#include <syslog.h>\n#include <unistd.h>\n\n#include \"passthrough_helpers.h\"\n#include \"passthrough_seccomp.h\"\n\n/* Keep track of inode posix locks for each owner. */\nstruct lo_inode_plock {\n    uint64_t lock_owner;\n    int fd; /* fd for OFD locks */\n};\n\nstruct lo_map_elem {\n    union {\n        struct lo_inode *inode;\n        struct lo_dirp *dirp;\n        int fd;\n        ssize_t freelist;\n    };\n    bool in_use;\n};\n\n/* Maps FUSE fh or ino values to internal objects */\nstruct lo_map {\n    struct lo_map_elem *elems;\n    size_t nelems;\n    ssize_t freelist;\n};\n\nstruct lo_key {\n    ino_t ino;\n    dev_t dev;\n};\n\nstruct lo_inode {\n    int fd;\n\n    /*\n     * Atomic reference count for this object.  The nlookup field holds a\n     * reference and release it when nlookup reaches 0.\n     */\n    gint refcount;\n\n    struct lo_key key;\n\n    /*\n     * This counter keeps the inode alive during the FUSE session.\n     * Incremented when the FUSE inode number is sent in a reply\n     * (FUSE_LOOKUP, FUSE_READDIRPLUS, etc).  Decremented when an inode is\n     * released by requests like FUSE_FORGET, FUSE_RMDIR, FUSE_RENAME, etc.\n     *\n     * Note that this value is untrusted because the client can manipulate\n     * it arbitrarily using FUSE_FORGET requests.\n     *\n     * Protected by lo->mutex.\n     */\n    uint64_t nlookup;\n\n    fuse_ino_t fuse_ino;\n    pthread_mutex_t plock_mutex;\n    GHashTable *posix_locks; /* protected by lo_inode->plock_mutex */\n\n    mode_t filetype;\n};\n\nstruct lo_cred {\n    uid_t euid;\n    gid_t egid;\n};\n\nenum {\n    CACHE_NONE,\n    CACHE_AUTO,\n    CACHE_ALWAYS,\n};\n\nstruct lo_data {\n    pthread_mutex_t mutex;\n    int debug;\n    int writeback;\n    int flock;\n    int posix_lock;\n    int xattr;\n    char *source;\n    char *modcaps;\n    double timeout;\n    int cache;\n    int timeout_set;\n    int readdirplus_set;\n    int readdirplus_clear;\n    int allow_direct_io;\n    struct lo_inode root;\n    GHashTable *inodes; /* protected by lo->mutex */\n    struct lo_map ino_map; /* protected by lo->mutex */\n    struct lo_map dirp_map; /* protected by lo->mutex */\n    struct lo_map fd_map; /* protected by lo->mutex */\n\n    /* An O_PATH file descriptor to /proc/self/fd/ */\n    int proc_self_fd;\n};\n\nstatic const struct fuse_opt lo_opts[] = {\n    { \"writeback\", offsetof(struct lo_data, writeback), 1 },\n    { \"no_writeback\", offsetof(struct lo_data, writeback), 0 },\n    { \"source=%s\", offsetof(struct lo_data, source), 0 },\n    { \"flock\", offsetof(struct lo_data, flock), 1 },\n    { \"no_flock\", offsetof(struct lo_data, flock), 0 },\n    { \"posix_lock\", offsetof(struct lo_data, posix_lock), 1 },\n    { \"no_posix_lock\", offsetof(struct lo_data, posix_lock), 0 },\n    { \"xattr\", offsetof(struct lo_data, xattr), 1 },\n    { \"no_xattr\", offsetof(struct lo_data, xattr), 0 },\n    { \"modcaps=%s\", offsetof(struct lo_data, modcaps), 0 },\n    { \"timeout=%lf\", offsetof(struct lo_data, timeout), 0 },\n    { \"timeout=\", offsetof(struct lo_data, timeout_set), 1 },\n    { \"cache=none\", offsetof(struct lo_data, cache), CACHE_NONE },\n    { \"cache=auto\", offsetof(struct lo_data, cache), CACHE_AUTO },\n    { \"cache=always\", offsetof(struct lo_data, cache), CACHE_ALWAYS },\n    { \"readdirplus\", offsetof(struct lo_data, readdirplus_set), 1 },\n    { \"no_readdirplus\", offsetof(struct lo_data, readdirplus_clear), 1 },\n    { \"allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 1 },\n    { \"no_allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 0 },\n    FUSE_OPT_END\n};\nstatic bool use_syslog = false;\nstatic int current_log_level;\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n/* That we loaded cap-ng in the current thread from the saved */\nstatic __thread bool cap_loaded = 0;\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}\n\n/* Is `path` a single path component that is not \".\" or \"..\"? */\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}\n\nstatic struct lo_data *lo_data(fuse_req_t req)\n{\n    return (struct lo_data *)fuse_req_userdata(req);\n}\n\n/*\n * Load capng's state from our saved state if the current thread\n * hadn't previously been loaded.\n * returns 0 on success\n */\nstatic int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}\n\n/*\n * Helpers for dropping and regaining effective capabilities. Returns 0\n * on success, error otherwise\n */\nstatic int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}\n\nstatic int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}\n\nstatic void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}\n\nstatic void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}\n\nstatic int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}\n\nstatic struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}\n\n/* Assumes lo->mutex is held */\nstatic ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}\n\n/* Caller must release refcount using lo_inode_put() */\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}\n\n/*\n * TODO Remove this helper and force callers to hold an inode refcount until\n * they are done with the fd.  This will be done in a later patch to make\n * review easier.\n */\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}\n\nstatic void lo_init(void *userdata, struct fuse_conn_info *conn)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    if (conn->capable & FUSE_CAP_EXPORT_SUPPORT) {\n        conn->want |= FUSE_CAP_EXPORT_SUPPORT;\n    }\n\n    if (lo->writeback && conn->capable & FUSE_CAP_WRITEBACK_CACHE) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating writeback\\n\");\n        conn->want |= FUSE_CAP_WRITEBACK_CACHE;\n    }\n    if (conn->capable & FUSE_CAP_FLOCK_LOCKS) {\n        if (lo->flock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating flock locks\\n\");\n            conn->want |= FUSE_CAP_FLOCK_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling flock locks\\n\");\n            conn->want &= ~FUSE_CAP_FLOCK_LOCKS;\n        }\n    }\n\n    if (conn->capable & FUSE_CAP_POSIX_LOCKS) {\n        if (lo->posix_lock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating posix locks\\n\");\n            conn->want |= FUSE_CAP_POSIX_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling posix locks\\n\");\n            conn->want &= ~FUSE_CAP_POSIX_LOCKS;\n        }\n    }\n\n    if ((lo->cache == CACHE_NONE && !lo->readdirplus_set) ||\n        lo->readdirplus_clear) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling readdirplus\\n\");\n        conn->want &= ~FUSE_CAP_READDIRPLUS;\n    }\n}\n\nstatic void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}\n\nstatic void lo_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,\n                       int valid, struct fuse_file_info *fi)\n{\n    int saverr;\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    int ifd;\n    int res;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    ifd = inode->fd;\n\n    /* If fi->fh is invalid we'll report EBADF later */\n    if (fi) {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (valid & FUSE_SET_ATTR_MODE) {\n        if (fi) {\n            res = fchmod(fd, attr->st_mode);\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            res = fchmodat(lo->proc_self_fd, procname, attr->st_mode, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {\n        uid_t uid = (valid & FUSE_SET_ATTR_UID) ? attr->st_uid : (uid_t)-1;\n        gid_t gid = (valid & FUSE_SET_ATTR_GID) ? attr->st_gid : (gid_t)-1;\n\n        res = fchownat(ifd, \"\", uid, gid, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & FUSE_SET_ATTR_SIZE) {\n        int truncfd;\n\n        if (fi) {\n            truncfd = fd;\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            truncfd = openat(lo->proc_self_fd, procname, O_RDWR);\n            if (truncfd < 0) {\n                goto out_err;\n            }\n        }\n\n        res = ftruncate(truncfd, attr->st_size);\n        if (!fi) {\n            saverr = errno;\n            close(truncfd);\n            errno = saverr;\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {\n        struct timespec tv[2];\n\n        tv[0].tv_sec = 0;\n        tv[1].tv_sec = 0;\n        tv[0].tv_nsec = UTIME_OMIT;\n        tv[1].tv_nsec = UTIME_OMIT;\n\n        if (valid & FUSE_SET_ATTR_ATIME_NOW) {\n            tv[0].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_ATIME) {\n            tv[0] = attr->st_atim;\n        }\n\n        if (valid & FUSE_SET_ATTR_MTIME_NOW) {\n            tv[1].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_MTIME) {\n            tv[1] = attr->st_mtim;\n        }\n\n        if (fi) {\n            res = futimens(fd, tv);\n        } else {\n            sprintf(procname, \"%i\", inode->fd);\n            res = utimensat(lo->proc_self_fd, procname, tv, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    lo_inode_put(lo, &inode);\n\n    return lo_getattr(req, ino, fi);\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}\n\n/* value_destroy_func for posix_locks GHashTable */\nstatic void posix_locks_value_destroy(gpointer data)\n{\n    struct lo_inode_plock *plock = data;\n\n    /*\n     * We had used open() for locks and had only one fd. So\n     * closing this fd should release all OFD locks.\n     */\n    close(plock->fd);\n    free(plock);\n}\n\n/*\n * Increments nlookup and caller must release refcount using\n * lo_inode_put(&parent).\n */\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}\n\nstatic void lo_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    struct fuse_entry_param e;\n    int err;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_lookup(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    /*\n     * Don't use is_safe_path_component(), allow \".\" and \"..\" for NFS export\n     * support.\n     */\n    if (strchr(name, '/')) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    err = lo_do_lookup(req, parent, name, &e);\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_entry(req, &e);\n    }\n}\n\n/*\n * On some archs, setres*id is limited to 2^16 but they\n * provide setres*id32 variants that allow 2^32.\n * Others just let setres*id do 2^32 anyway.\n */\n#ifdef SYS_setresgid32\n#define OURSYS_setresgid SYS_setresgid32\n#else\n#define OURSYS_setresgid SYS_setresgid\n#endif\n\n#ifdef SYS_setresuid32\n#define OURSYS_setresuid SYS_setresuid32\n#else\n#define OURSYS_setresuid SYS_setresuid\n#endif\n\n/*\n * Change to uid/gid of caller so that file is created with\n * ownership of caller.\n * TODO: What about selinux context?\n */\nstatic int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}\n\n/* Regain Privileges */\nstatic void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode, dev_t rdev)\n{\n    lo_mknod_symlink(req, parent, name, mode, rdev, NULL);\n}\n\nstatic void lo_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode)\n{\n    lo_mknod_symlink(req, parent, name, S_IFDIR | mode, 0, NULL);\n}\n\nstatic void lo_symlink(fuse_req_t req, const char *link, fuse_ino_t parent,\n                       const char *name)\n{\n    lo_mknod_symlink(req, parent, name, S_IFLNK, 0, link);\n}\n\nstatic void lo_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t parent,\n                    const char *name)\n{\n    int res;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct lo_inode *inode;\n    struct fuse_entry_param e;\n    char procname[64];\n    int saverr;\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    inode = lo_inode(req, ino);\n    if (!parent_inode || !inode) {\n        errno = EBADF;\n        goto out_err;\n    }\n\n    memset(&e, 0, sizeof(struct fuse_entry_param));\n    e.attr_timeout = lo->timeout;\n    e.entry_timeout = lo->timeout;\n\n    sprintf(procname, \"%i\", inode->fd);\n    res = linkat(lo->proc_self_fd, procname, parent_inode->fd, name,\n                 AT_SYMLINK_FOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(inode->fd, \"\", &e.attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    inode->nlookup++;\n    pthread_mutex_unlock(&lo->mutex);\n    e.ino = inode->fuse_ino;\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\n/* Increments nlookup and caller must release refcount using lo_inode_put() */\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}\n\nstatic void lo_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, AT_REMOVEDIR);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}\n\nstatic void lo_rename(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      fuse_ino_t newparent, const char *newname,\n                      unsigned int flags)\n{\n    int res;\n    struct lo_inode *parent_inode;\n    struct lo_inode *newparent_inode;\n    struct lo_inode *oldinode = NULL;\n    struct lo_inode *newinode = NULL;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name) || !is_safe_path_component(newname)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    newparent_inode = lo_inode(req, newparent);\n    if (!parent_inode || !newparent_inode) {\n        fuse_reply_err(req, EBADF);\n        goto out;\n    }\n\n    oldinode = lookup_name(req, parent, name);\n    newinode = lookup_name(req, newparent, newname);\n\n    if (!oldinode) {\n        fuse_reply_err(req, EIO);\n        goto out;\n    }\n\n    if (flags) {\n#ifndef SYS_renameat2\n        fuse_reply_err(req, EINVAL);\n#else\n        res = syscall(SYS_renameat2, parent_inode->fd, name,\n                        newparent_inode->fd, newname, flags);\n        if (res == -1 && errno == ENOSYS) {\n            fuse_reply_err(req, EINVAL);\n        } else {\n            fuse_reply_err(req, res == -1 ? errno : 0);\n        }\n#endif\n        goto out;\n    }\n\n    res = renameat(parent_inode->fd, name, newparent_inode->fd, newname);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\nout:\n    unref_inode_lolocked(lo, oldinode, 1);\n    unref_inode_lolocked(lo, newinode, 1);\n    lo_inode_put(lo, &oldinode);\n    lo_inode_put(lo, &newinode);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &newparent_inode);\n}\n\nstatic void lo_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, 0);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}\n\n/* To be called with lo->mutex held */\nstatic void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    assert(inode->nlookup >= n);\n    inode->nlookup -= n;\n    if (!inode->nlookup) {\n        lo_map_remove(&lo->ino_map, inode->fuse_ino);\n        g_hash_table_remove(lo->inodes, &inode->key);\n        if (g_hash_table_size(inode->posix_locks)) {\n            fuse_log(FUSE_LOG_WARNING, \"Hash table is not empty\\n\");\n        }\n        g_hash_table_destroy(inode->posix_locks);\n        pthread_mutex_destroy(&inode->plock_mutex);\n\n        /* Drop our refcount from lo_do_lookup() */\n        lo_inode_put(lo, &inode);\n    }\n}\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}\n\nstatic void lo_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    lo_forget_one(req, ino, nlookup);\n    fuse_reply_none(req);\n}\n\nstatic void lo_forget_multi(fuse_req_t req, size_t count,\n                            struct fuse_forget_data *forgets)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        lo_forget_one(req, forgets[i].ino, forgets[i].nlookup);\n    }\n    fuse_reply_none(req);\n}\n\nstatic void lo_readlink(fuse_req_t req, fuse_ino_t ino)\n{\n    char buf[PATH_MAX + 1];\n    int res;\n\n    res = readlinkat(lo_fd(req, ino), \"\", buf, sizeof(buf));\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    if (res == sizeof(buf)) {\n        return (void)fuse_reply_err(req, ENAMETOOLONG);\n    }\n\n    buf[res] = '\\0';\n\n    fuse_reply_readlink(req, buf);\n}\n\nstruct lo_dirp {\n    gint refcount;\n    DIR *dp;\n    struct dirent *entry;\n    off_t offset;\n};\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}\n\n/* Call lo_dirp_put() on the return value when no longer needed */\nstatic struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}\n\nstatic void lo_opendir(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int error = ENOMEM;\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d;\n    int fd;\n    ssize_t fh;\n\n    d = calloc(1, sizeof(struct lo_dirp));\n    if (d == NULL) {\n        goto out_err;\n    }\n\n    fd = openat(lo_fd(req, ino), \".\", O_RDONLY);\n    if (fd == -1) {\n        goto out_errno;\n    }\n\n    d->dp = fdopendir(fd);\n    if (d->dp == NULL) {\n        goto out_errno;\n    }\n\n    d->offset = 0;\n    d->entry = NULL;\n\n    g_atomic_int_set(&d->refcount, 1); /* paired with lo_releasedir() */\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_dirp_mapping(req, d);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        goto out_err;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_ALWAYS) {\n        fi->cache_readdir = 1;\n    }\n    fuse_reply_open(req, fi);\n    return;\n\nout_errno:\n    error = errno;\nout_err:\n    if (d) {\n        if (d->dp) {\n            closedir(d->dp);\n        } else if (fd != -1) {\n            close(fd);\n        }\n        free(d);\n    }\n    fuse_reply_err(req, error);\n}\n\nstatic void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}\n\nstatic void lo_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                       off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 0);\n}\n\nstatic void lo_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,\n                           off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 1);\n}\n\nstatic void lo_releasedir(fuse_req_t req, fuse_ino_t ino,\n                          struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    struct lo_dirp *d;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (!elem) {\n        pthread_mutex_unlock(&lo->mutex);\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    d = elem->dirp;\n    lo_map_remove(&lo->dirp_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    lo_dirp_put(&d); /* paired with lo_opendir() */\n\n    fuse_reply_err(req, 0);\n}\n\nstatic void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}\n\nstatic void lo_create(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      mode_t mode, struct fuse_file_info *fi)\n{\n    int fd;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct fuse_entry_param e;\n    int err;\n    struct lo_cred old = {};\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_create(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    if (!parent_inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    err = lo_change_cred(req, &old);\n    if (err) {\n        goto out;\n    }\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    fd = openat(parent_inode->fd, name, (fi->flags | O_CREAT) & ~O_NOFOLLOW,\n                mode);\n    err = fd == -1 ? errno : 0;\n    lo_restore_cred(&old);\n\n    if (!err) {\n        ssize_t fh;\n\n        pthread_mutex_lock(&lo->mutex);\n        fh = lo_add_fd_mapping(req, fd);\n        pthread_mutex_unlock(&lo->mutex);\n        if (fh == -1) {\n            close(fd);\n            err = ENOMEM;\n            goto out;\n        }\n\n        fi->fh = fh;\n        err = lo_do_lookup(req, parent, name, &e);\n    }\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n\nout:\n    lo_inode_put(lo, &parent_inode);\n\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_create(req, &e, fi);\n    }\n}\n\n/* Should be called with inode->plock_mutex held */\nstatic struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}\n\nstatic void lo_getlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_getlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" owner=0x%lx, l_type=%d l_start=0x%lx\"\n             \" l_len=0x%lx\\n\",\n             ino, fi->flags, fi->lock_owner, lock->l_type, lock->l_start,\n             lock->l_len);\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    ret = fcntl(plock->fd, F_OFD_GETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    if (saverr) {\n        fuse_reply_err(req, saverr);\n    } else {\n        fuse_reply_lock(req, lock);\n    }\n}\n\nstatic void lo_setlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock, int sleep)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_setlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" cmd=%d pid=%d owner=0x%lx sleep=%d l_whence=%d\"\n             \" l_start=0x%lx l_len=0x%lx\\n\",\n             ino, fi->flags, lock->l_type, lock->l_pid, fi->lock_owner, sleep,\n             lock->l_whence, lock->l_start, lock->l_len);\n\n    if (sleep) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    /* TODO: Is it alright to modify flock? */\n    lock->l_pid = 0;\n    ret = fcntl(plock->fd, F_OFD_SETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,\n                        struct fuse_file_info *fi)\n{\n    int res;\n    struct lo_dirp *d;\n    int fd;\n\n    (void)ino;\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    fd = dirfd(d->dp);\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n\n    lo_dirp_put(&d);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}\n\nstatic void lo_release(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    int fd = -1;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    if (elem) {\n        fd = elem->fd;\n        elem = NULL;\n        lo_map_remove(&lo->fd_map, fi->fh);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    close(fd);\n    fuse_reply_err(req, 0);\n}\n\nstatic void lo_flush(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int res;\n    (void)ino;\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    /* An fd is going away. Cleanup associated posix locks */\n    pthread_mutex_lock(&inode->plock_mutex);\n    g_hash_table_remove(inode->posix_locks, GUINT_TO_POINTER(fi->lock_owner));\n    pthread_mutex_unlock(&inode->plock_mutex);\n\n    res = close(dup(lo_fi_fd(req, fi)));\n    lo_inode_put(lo_data(req), &inode);\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,\n                     struct fuse_file_info *fi)\n{\n    int res;\n    int fd;\n    char *buf;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_fsync(ino=%\" PRIu64 \", fi=0x%p)\\n\", ino,\n             (void *)fi);\n\n    if (!fi) {\n        struct lo_data *lo = lo_data(req);\n\n        res = asprintf(&buf, \"%i\", lo_fd(req, ino));\n        if (res == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n\n        fd = openat(lo->proc_self_fd, buf, O_RDWR);\n        free(buf);\n        if (fd == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n    } else {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n    if (!fi) {\n        close(fd);\n    }\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t offset,\n                    struct fuse_file_info *fi)\n{\n    struct fuse_bufvec buf = FUSE_BUFVEC_INIT(size);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_read(ino=%\" PRIu64 \", size=%zd, \"\n             \"off=%lu)\\n\",\n             ino, size, (unsigned long)offset);\n\n    buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    buf.buf[0].fd = lo_fi_fd(req, fi);\n    buf.buf[0].pos = offset;\n\n    fuse_reply_data(req, &buf);\n}\n\nstatic void lo_write_buf(fuse_req_t req, fuse_ino_t ino,\n                         struct fuse_bufvec *in_buf, off_t off,\n                         struct fuse_file_info *fi)\n{\n    (void)ino;\n    ssize_t res;\n    struct fuse_bufvec out_buf = FUSE_BUFVEC_INIT(fuse_buf_size(in_buf));\n    bool cap_fsetid_dropped = false;\n\n    out_buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    out_buf.buf[0].fd = lo_fi_fd(req, fi);\n    out_buf.buf[0].pos = off;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_write_buf(ino=%\" PRIu64 \", size=%zd, off=%lu)\\n\", ino,\n             out_buf.buf[0].size, (unsigned long)off);\n\n    /*\n     * If kill_priv is set, drop CAP_FSETID which should lead to kernel\n     * clearing setuid/setgid on file.\n     */\n    if (fi->kill_priv) {\n        res = drop_effective_cap(\"FSETID\", &cap_fsetid_dropped);\n        if (res != 0) {\n            fuse_reply_err(req, res);\n            return;\n        }\n    }\n\n    res = fuse_buf_copy(&out_buf, in_buf);\n    if (res < 0) {\n        fuse_reply_err(req, -res);\n    } else {\n        fuse_reply_write(req, (size_t)res);\n    }\n\n    if (cap_fsetid_dropped) {\n        res = gain_effective_cap(\"FSETID\");\n        if (res) {\n            fuse_log(FUSE_LOG_ERR, \"Failed to gain CAP_FSETID\\n\");\n        }\n    }\n}\n\nstatic void lo_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    int res;\n    struct statvfs stbuf;\n\n    res = fstatvfs(lo_fd(req, ino), &stbuf);\n    if (res == -1) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_statfs(req, &stbuf);\n    }\n}\n\nstatic void lo_fallocate(fuse_req_t req, fuse_ino_t ino, int mode, off_t offset,\n                         off_t length, struct fuse_file_info *fi)\n{\n    int err = EOPNOTSUPP;\n    (void)ino;\n\n#ifdef CONFIG_FALLOCATE\n    err = fallocate(lo_fi_fd(req, fi), mode, offset, length);\n    if (err < 0) {\n        err = errno;\n    }\n\n#elif defined(CONFIG_POSIX_FALLOCATE)\n    if (mode) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    err = posix_fallocate(lo_fi_fd(req, fi), offset, length);\n#endif\n\n    fuse_reply_err(req, err);\n}\n\nstatic void lo_flock(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     int op)\n{\n    int res;\n    (void)ino;\n\n    res = flock(lo_fi_fd(req, fi), op);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}\n\nstatic void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\",\n             ino, name, size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    /*\n     * It is not safe to open() non-regular/non-dir files in file server\n     * unless O_PATH is used, so use that method for regular files/dir\n     * only (as it seems giving less performance overhead).\n     * Otherwise, call fchdir() to avoid open().\n     */\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = fgetxattr(fd, name, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = getxattr(procname, name, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}\n\nstatic void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\", ino,\n             size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = flistxattr(fd, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = listxattr(procname, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}\n\nstatic void lo_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        const char *value, size_t size, int flags)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_setxattr(ino=%\" PRIu64\n             \", name=%s value=%s size=%zd)\\n\", ino, name, value, size);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fsetxattr(fd, name, value, size, flags);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = setxattr(procname, name, value, size, flags);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\nstatic void lo_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_removexattr(ino=%\" PRIu64 \", name=%s)\\n\", ino,\n             name);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fremovexattr(fd, name);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = removexattr(procname, name);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}\n\n#ifdef HAVE_COPY_FILE_RANGE\nstatic void lo_copy_file_range(fuse_req_t req, fuse_ino_t ino_in, off_t off_in,\n                               struct fuse_file_info *fi_in, fuse_ino_t ino_out,\n                               off_t off_out, struct fuse_file_info *fi_out,\n                               size_t len, int flags)\n{\n    int in_fd, out_fd;\n    ssize_t res;\n\n    in_fd = lo_fi_fd(req, fi_in);\n    out_fd = lo_fi_fd(req, fi_out);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_copy_file_range(ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, size=%zd, flags=0x%x)\\n\",\n             ino_in, in_fd, off_in, ino_out, out_fd, off_out, len, flags);\n\n    res = copy_file_range(in_fd, &off_in, out_fd, &off_out, len, flags);\n    if (res < 0) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_write(req, res);\n    }\n}\n#endif\n\nstatic void lo_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,\n                     struct fuse_file_info *fi)\n{\n    off_t res;\n\n    (void)ino;\n    res = lseek(lo_fi_fd(req, fi), off, whence);\n    if (res != -1) {\n        fuse_reply_lseek(req, res);\n    } else {\n        fuse_reply_err(req, errno);\n    }\n}\n\nstatic void lo_destroy(void *userdata)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    pthread_mutex_lock(&lo->mutex);\n    while (true) {\n        GHashTableIter iter;\n        gpointer key, value;\n\n        g_hash_table_iter_init(&iter, lo->inodes);\n        if (!g_hash_table_iter_next(&iter, &key, &value)) {\n            break;\n        }\n\n        struct lo_inode *inode = value;\n        unref_inode(lo, inode, inode->nlookup);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n}\n\nstatic struct fuse_lowlevel_ops lo_oper = {\n    .init = lo_init,\n    .lookup = lo_lookup,\n    .mkdir = lo_mkdir,\n    .mknod = lo_mknod,\n    .symlink = lo_symlink,\n    .link = lo_link,\n    .unlink = lo_unlink,\n    .rmdir = lo_rmdir,\n    .rename = lo_rename,\n    .forget = lo_forget,\n    .forget_multi = lo_forget_multi,\n    .getattr = lo_getattr,\n    .setattr = lo_setattr,\n    .readlink = lo_readlink,\n    .opendir = lo_opendir,\n    .readdir = lo_readdir,\n    .readdirplus = lo_readdirplus,\n    .releasedir = lo_releasedir,\n    .fsyncdir = lo_fsyncdir,\n    .create = lo_create,\n    .getlk = lo_getlk,\n    .setlk = lo_setlk,\n    .open = lo_open,\n    .release = lo_release,\n    .flush = lo_flush,\n    .fsync = lo_fsync,\n    .read = lo_read,\n    .write_buf = lo_write_buf,\n    .statfs = lo_statfs,\n    .fallocate = lo_fallocate,\n    .flock = lo_flock,\n    .getxattr = lo_getxattr,\n    .listxattr = lo_listxattr,\n    .setxattr = lo_setxattr,\n    .removexattr = lo_removexattr,\n#ifdef HAVE_COPY_FILE_RANGE\n    .copy_file_range = lo_copy_file_range,\n#endif\n    .lseek = lo_lseek,\n    .destroy = lo_destroy,\n};\n\n/* Print vhost-user.json backend program capabilities */\nstatic void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}\n\n/*\n * Drop all Linux capabilities because the wait parent process only needs to\n * sit in waitpid(2) and terminate.\n */\nstatic void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}\n\n/*\n * Move to a new mount, net, and pid namespaces to isolate this process.\n */\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    /*\n     * We only need /proc/self/fd. Prevent \"..\" from accessing parent\n     * directories of /proc/self/fd by bind-mounting it over /proc. Since / was\n     * previously remounted with MS_REC | MS_SLAVE this mount change only\n     * affects our process.\n     */\n    if (mount(\"/proc/self/fd\", \"/proc\", NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, MS_BIND): %m\\n\");\n        exit(1);\n    }\n\n    /* Get the /proc (actually /proc/self/fd, see above) file descriptor */\n    lo->proc_self_fd = open(\"/proc\", O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(/proc, O_PATH): %m\\n\");\n        exit(1);\n    }\n}\n\n/*\n * Capture the capability state, we'll need to restore this for individual\n * threads later; see load_capng.\n */\nstatic void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}\n\nstatic void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}\n\n\n/*\n * Make the source directory our root so symlinks cannot escape and no other\n * files are accessible.  Assumes unshare(CLONE_NEWNS) was already called.\n */\nstatic void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}\n\n/*\n * Only keep whitelisted capabilities that are needed for file system operation\n * The (possibly NULL) modcaps_in string passed in is free'd before exit.\n */\nstatic void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}\n\n/*\n * Lock down this process to prevent access to other processes or files outside\n * source directory.  This reduces the impact of arbitrary code execution bugs.\n */\nstatic void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}\n\n/* Set the maximum number of open file descriptors */\nstatic void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}\n\nstatic void log_func(enum fuse_log_level level, const char *fmt, va_list ap)\n{\n    g_autofree char *localfmt = NULL;\n\n    if (current_log_level < level) {\n        return;\n    }\n\n    if (current_log_level == FUSE_LOG_DEBUG) {\n        if (!use_syslog) {\n            localfmt = g_strdup_printf(\"[%\" PRId64 \"] [ID: %08ld] %s\",\n                                       get_clock(), syscall(__NR_gettid), fmt);\n        } else {\n            localfmt = g_strdup_printf(\"[ID: %08ld] %s\", syscall(__NR_gettid),\n                                       fmt);\n        }\n        fmt = localfmt;\n    }\n\n    if (use_syslog) {\n        int priority = LOG_ERR;\n        switch (level) {\n        case FUSE_LOG_EMERG:\n            priority = LOG_EMERG;\n            break;\n        case FUSE_LOG_ALERT:\n            priority = LOG_ALERT;\n            break;\n        case FUSE_LOG_CRIT:\n            priority = LOG_CRIT;\n            break;\n        case FUSE_LOG_ERR:\n            priority = LOG_ERR;\n            break;\n        case FUSE_LOG_WARNING:\n            priority = LOG_WARNING;\n            break;\n        case FUSE_LOG_NOTICE:\n            priority = LOG_NOTICE;\n            break;\n        case FUSE_LOG_INFO:\n            priority = LOG_INFO;\n            break;\n        case FUSE_LOG_DEBUG:\n            priority = LOG_DEBUG;\n            break;\n        }\n        vsyslog(priority, fmt, ap);\n    } else {\n        vfprintf(stderr, fmt, ap);\n    }\n}\n\nstatic void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}\n\nstatic guint lo_key_hash(gconstpointer key)\n{\n    const struct lo_key *lkey = key;\n\n    return (guint)lkey->ino + (guint)lkey->dev;\n}\n\nstatic gboolean lo_key_equal(gconstpointer a, gconstpointer b)\n{\n    const struct lo_key *la = a;\n    const struct lo_key *lb = b;\n\n    return la->ino == lb->ino && la->dev == lb->dev;\n}\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}\n\nint main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n    };\n    struct lo_map_elem *root_elem;\n    int ret = -1;\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    lo_map_reserve(&lo.ino_map, 0)->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    /*\n     * log_level is 0 if not configured via cmd options (0 is LOG_EMERG,\n     * and we don't use this log level).\n     */\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n    }\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}\n"], "filenames": ["tools/virtiofsd/passthrough_ll.c"], "buggy_code_start_loc": [2396], "buggy_code_end_loc": [2487], "fixing_code_start_loc": [2395], "fixing_code_end_loc": [2474], "type": "CWE-269", "message": "A flaw was found in qemu. A host privilege escalation issue was found in the virtio-fs shared file system daemon where a privileged guest user is able to create a device special file in the shared directory and use it to r/w access host devices.", "other": {"cve": {"id": "CVE-2020-35517", "sourceIdentifier": "secalert@redhat.com", "published": "2021-01-28T20:15:12.913", "lastModified": "2023-02-12T23:41:03.483", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in qemu. A host privilege escalation issue was found in the virtio-fs shared file system daemon where a privileged guest user is able to create a device special file in the shared directory and use it to r/w access host devices."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en qemu.&#xa0;Se encontr\u00f3 un problema de escalada de privilegios del host en el demonio del sistema de archivos compartidos virtio-fs, donde un usuario invitado privilegiado puede crear un archivo especial de dispositivo en el directorio compartido y usarlo para dispositivos host de acceso de r/w"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndIncluding": "5.2.50", "matchCriteriaId": "01657731-34D9-471D-BCD4-D7772822C761"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1915823", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/ebf101955ce8f8d72fba103b5151115a4335de2c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.gnu.org/archive/html/qemu-devel/2021-01/msg05461.html", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-27", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210312-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/01/22/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/ebf101955ce8f8d72fba103b5151115a4335de2c"}}