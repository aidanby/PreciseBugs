{"buggy_code": ["/*  ADMesh -- process triangulated solid meshes\n *  Copyright (C) 1995, 1996  Anthony D. Martin <amartin@engr.csulb.edu>\n *  Copyright (C) 2013, 2014  several contributors, see AUTHORS\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n *  Questions, comments, suggestions, etc to\n *           https://github.com/admesh/admesh/issues\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"stl.h\"\n\nstatic void stl_reverse_facet(stl_file *stl, int facet_num);\nstatic void stl_reverse_vector(float v[]);\nint stl_check_normal_vector(stl_file *stl, int facet_num, int normal_fix_flag);\n\nstatic void\nstl_reverse_facet(stl_file *stl, int facet_num) {\n  stl_vertex tmp_vertex;\n  /*  int tmp_neighbor;*/\n  int neighbor[3];\n  int vnot[3];\n\n  stl->stats.facets_reversed += 1;\n\n  neighbor[0] = stl->neighbors_start[facet_num].neighbor[0];\n  neighbor[1] = stl->neighbors_start[facet_num].neighbor[1];\n  neighbor[2] = stl->neighbors_start[facet_num].neighbor[2];\n  vnot[0] = stl->neighbors_start[facet_num].which_vertex_not[0];\n  vnot[1] = stl->neighbors_start[facet_num].which_vertex_not[1];\n  vnot[2] = stl->neighbors_start[facet_num].which_vertex_not[2];\n\n  /* reverse the facet */\n  tmp_vertex = stl->facet_start[facet_num].vertex[0];\n  stl->facet_start[facet_num].vertex[0] =\n    stl->facet_start[facet_num].vertex[1];\n  stl->facet_start[facet_num].vertex[1] = tmp_vertex;\n\n  /* fix the vnots of the neighboring facets */\n  if(neighbor[0] != -1)\n    stl->neighbors_start[neighbor[0]].which_vertex_not[(vnot[0] + 1) % 3] =\n      (stl->neighbors_start[neighbor[0]].\n       which_vertex_not[(vnot[0] + 1) % 3] + 3) % 6;\n  if(neighbor[1] != -1)\n    stl->neighbors_start[neighbor[1]].which_vertex_not[(vnot[1] + 1) % 3] =\n      (stl->neighbors_start[neighbor[1]].\n       which_vertex_not[(vnot[1] + 1) % 3] + 4) % 6;\n  if(neighbor[2] != -1)\n    stl->neighbors_start[neighbor[2]].which_vertex_not[(vnot[2] + 1) % 3] =\n      (stl->neighbors_start[neighbor[2]].\n       which_vertex_not[(vnot[2] + 1) % 3] + 2) % 6;\n\n  /* swap the neighbors of the facet that is being reversed */\n  stl->neighbors_start[facet_num].neighbor[1] = neighbor[2];\n  stl->neighbors_start[facet_num].neighbor[2] = neighbor[1];\n\n  /* swap the vnots of the facet that is being reversed */\n  stl->neighbors_start[facet_num].which_vertex_not[1] = vnot[2];\n  stl->neighbors_start[facet_num].which_vertex_not[2] = vnot[1];\n\n  /* reverse the values of the vnots of the facet that is being reversed */\n  stl->neighbors_start[facet_num].which_vertex_not[0] =\n    (stl->neighbors_start[facet_num].which_vertex_not[0] + 3) % 6;\n  stl->neighbors_start[facet_num].which_vertex_not[1] =\n    (stl->neighbors_start[facet_num].which_vertex_not[1] + 3) % 6;\n  stl->neighbors_start[facet_num].which_vertex_not[2] =\n    (stl->neighbors_start[facet_num].which_vertex_not[2] + 3) % 6;\n}\n\nvoid\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}\n\nint\nstl_check_normal_vector(stl_file *stl, int facet_num, int normal_fix_flag) {\n  /* Returns 0 if the normal is within tolerance */\n  /* Returns 1 if the normal is not within tolerance, but direction is OK */\n  /* Returns 2 if the normal is not within tolerance and backwards */\n  /* Returns 4 if the status is unknown. */\n\n  float normal[3];\n  float test_norm[3];\n  stl_facet *facet;\n\n  facet = &stl->facet_start[facet_num];\n\n  stl_calculate_normal(normal, facet);\n  stl_normalize_vector(normal);\n\n  if(   (ABS(normal[0] - facet->normal.x) < 0.001)\n        && (ABS(normal[1] - facet->normal.y) < 0.001)\n        && (ABS(normal[2] - facet->normal.z) < 0.001)) {\n    /* It is not really necessary to change the values here */\n    /* but just for consistency, I will. */\n    facet->normal.x = normal[0];\n    facet->normal.y = normal[1];\n    facet->normal.z = normal[2];\n    return 0;\n  }\n\n  test_norm[0] = facet->normal.x;\n  test_norm[1] = facet->normal.y;\n  test_norm[2] = facet->normal.z;\n\n  stl_normalize_vector(test_norm);\n  if(   (ABS(normal[0] - test_norm[0]) < 0.001)\n        && (ABS(normal[1] - test_norm[1]) < 0.001)\n        && (ABS(normal[2] - test_norm[2]) < 0.001)) {\n    if(normal_fix_flag) {\n      facet->normal.x = normal[0];\n      facet->normal.y = normal[1];\n      facet->normal.z = normal[2];\n      stl->stats.normals_fixed += 1;\n    }\n    return 1;\n  }\n\n  stl_reverse_vector(test_norm);\n  if(   (ABS(normal[0] - test_norm[0]) < 0.001)\n        && (ABS(normal[1] - test_norm[1]) < 0.001)\n        && (ABS(normal[2] - test_norm[2]) < 0.001)) {\n    /* Facet is backwards. */\n    if(normal_fix_flag) {\n      facet->normal.x = normal[0];\n      facet->normal.y = normal[1];\n      facet->normal.z = normal[2];\n      stl->stats.normals_fixed += 1;\n    }\n    return 2;\n  }\n  if(normal_fix_flag) {\n    facet->normal.x = normal[0];\n    facet->normal.y = normal[1];\n    facet->normal.z = normal[2];\n    stl->stats.normals_fixed += 1;\n  }\n  return 4;\n}\n\nstatic void\nstl_reverse_vector(float v[]) {\n  v[0] *= -1;\n  v[1] *= -1;\n  v[2] *= -1;\n}\n\n\nvoid\nstl_calculate_normal(float normal[], stl_facet *facet) {\n  float v1[3];\n  float v2[3];\n\n  v1[0] = facet->vertex[1].x - facet->vertex[0].x;\n  v1[1] = facet->vertex[1].y - facet->vertex[0].y;\n  v1[2] = facet->vertex[1].z - facet->vertex[0].z;\n  v2[0] = facet->vertex[2].x - facet->vertex[0].x;\n  v2[1] = facet->vertex[2].y - facet->vertex[0].y;\n  v2[2] = facet->vertex[2].z - facet->vertex[0].z;\n\n  normal[0] = (float)((double)v1[1] * (double)v2[2]) - ((double)v1[2] * (double)v2[1]);\n  normal[1] = (float)((double)v1[2] * (double)v2[0]) - ((double)v1[0] * (double)v2[2]);\n  normal[2] = (float)((double)v1[0] * (double)v2[1]) - ((double)v1[1] * (double)v2[0]);\n}\n\nvoid stl_normalize_vector(float v[]) {\n  double length;\n  double factor;\n  float min_normal_length;\n\n  length = sqrt((double)v[0] * (double)v[0] + (double)v[1] * (double)v[1] + (double)v[2] * (double)v[2]);\n  min_normal_length = 0.000000000001;\n  if(length < min_normal_length) {\n    v[0] = 0.0;\n    v[1] = 0.0;\n    v[2] = 0.0;\n    return;\n  }\n  factor = 1.0 / length;\n  v[0] *= factor;\n  v[1] *= factor;\n  v[2] *= factor;\n}\n\nvoid\nstl_fix_normal_values(stl_file *stl) {\n  int i;\n\n  if (stl->error) return;\n\n  for(i = 0; i < stl->stats.number_of_facets; i++) {\n    stl_check_normal_vector(stl, i, 1);\n  }\n}\n\nvoid\nstl_reverse_all_facets(stl_file *stl) {\n  int i;\n  float normal[3];\n\n  if (stl->error) return;\n\n  for(i = 0; i < stl->stats.number_of_facets; i++) {\n    stl_reverse_facet(stl, i);\n    stl_calculate_normal(normal, &stl->facet_start[i]);\n    stl_normalize_vector(normal);\n    stl->facet_start[i].normal.x = normal[0];\n    stl->facet_start[i].normal.y = normal[1];\n    stl->facet_start[i].normal.z = normal[2];\n  }\n}\n\n"], "fixing_code": ["/*  ADMesh -- process triangulated solid meshes\n *  Copyright (C) 1995, 1996  Anthony D. Martin <amartin@engr.csulb.edu>\n *  Copyright (C) 2013, 2014  several contributors, see AUTHORS\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n *  Questions, comments, suggestions, etc to\n *           https://github.com/admesh/admesh/issues\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"stl.h\"\n\nstatic void stl_reverse_facet(stl_file *stl, int facet_num);\nstatic void stl_reverse_vector(float v[]);\nint stl_check_normal_vector(stl_file *stl, int facet_num, int normal_fix_flag);\n\nstatic void\nstl_reverse_facet(stl_file *stl, int facet_num) {\n  stl_vertex tmp_vertex;\n  /*  int tmp_neighbor;*/\n  int neighbor[3];\n  int vnot[3];\n\n  stl->stats.facets_reversed += 1;\n\n  neighbor[0] = stl->neighbors_start[facet_num].neighbor[0];\n  neighbor[1] = stl->neighbors_start[facet_num].neighbor[1];\n  neighbor[2] = stl->neighbors_start[facet_num].neighbor[2];\n  vnot[0] = stl->neighbors_start[facet_num].which_vertex_not[0];\n  vnot[1] = stl->neighbors_start[facet_num].which_vertex_not[1];\n  vnot[2] = stl->neighbors_start[facet_num].which_vertex_not[2];\n\n  /* reverse the facet */\n  tmp_vertex = stl->facet_start[facet_num].vertex[0];\n  stl->facet_start[facet_num].vertex[0] =\n    stl->facet_start[facet_num].vertex[1];\n  stl->facet_start[facet_num].vertex[1] = tmp_vertex;\n\n  /* fix the vnots of the neighboring facets */\n  if(neighbor[0] != -1)\n    stl->neighbors_start[neighbor[0]].which_vertex_not[(vnot[0] + 1) % 3] =\n      (stl->neighbors_start[neighbor[0]].\n       which_vertex_not[(vnot[0] + 1) % 3] + 3) % 6;\n  if(neighbor[1] != -1)\n    stl->neighbors_start[neighbor[1]].which_vertex_not[(vnot[1] + 1) % 3] =\n      (stl->neighbors_start[neighbor[1]].\n       which_vertex_not[(vnot[1] + 1) % 3] + 4) % 6;\n  if(neighbor[2] != -1)\n    stl->neighbors_start[neighbor[2]].which_vertex_not[(vnot[2] + 1) % 3] =\n      (stl->neighbors_start[neighbor[2]].\n       which_vertex_not[(vnot[2] + 1) % 3] + 2) % 6;\n\n  /* swap the neighbors of the facet that is being reversed */\n  stl->neighbors_start[facet_num].neighbor[1] = neighbor[2];\n  stl->neighbors_start[facet_num].neighbor[2] = neighbor[1];\n\n  /* swap the vnots of the facet that is being reversed */\n  stl->neighbors_start[facet_num].which_vertex_not[1] = vnot[2];\n  stl->neighbors_start[facet_num].which_vertex_not[2] = vnot[1];\n\n  /* reverse the values of the vnots of the facet that is being reversed */\n  stl->neighbors_start[facet_num].which_vertex_not[0] =\n    (stl->neighbors_start[facet_num].which_vertex_not[0] + 3) % 6;\n  stl->neighbors_start[facet_num].which_vertex_not[1] =\n    (stl->neighbors_start[facet_num].which_vertex_not[1] + 3) % 6;\n  stl->neighbors_start[facet_num].which_vertex_not[2] =\n    (stl->neighbors_start[facet_num].which_vertex_not[2] + 3) % 6;\n}\n\nvoid\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}\n\nint\nstl_check_normal_vector(stl_file *stl, int facet_num, int normal_fix_flag) {\n  /* Returns 0 if the normal is within tolerance */\n  /* Returns 1 if the normal is not within tolerance, but direction is OK */\n  /* Returns 2 if the normal is not within tolerance and backwards */\n  /* Returns 4 if the status is unknown. */\n\n  float normal[3];\n  float test_norm[3];\n  stl_facet *facet;\n\n  facet = &stl->facet_start[facet_num];\n\n  stl_calculate_normal(normal, facet);\n  stl_normalize_vector(normal);\n\n  if(   (ABS(normal[0] - facet->normal.x) < 0.001)\n        && (ABS(normal[1] - facet->normal.y) < 0.001)\n        && (ABS(normal[2] - facet->normal.z) < 0.001)) {\n    /* It is not really necessary to change the values here */\n    /* but just for consistency, I will. */\n    facet->normal.x = normal[0];\n    facet->normal.y = normal[1];\n    facet->normal.z = normal[2];\n    return 0;\n  }\n\n  test_norm[0] = facet->normal.x;\n  test_norm[1] = facet->normal.y;\n  test_norm[2] = facet->normal.z;\n\n  stl_normalize_vector(test_norm);\n  if(   (ABS(normal[0] - test_norm[0]) < 0.001)\n        && (ABS(normal[1] - test_norm[1]) < 0.001)\n        && (ABS(normal[2] - test_norm[2]) < 0.001)) {\n    if(normal_fix_flag) {\n      facet->normal.x = normal[0];\n      facet->normal.y = normal[1];\n      facet->normal.z = normal[2];\n      stl->stats.normals_fixed += 1;\n    }\n    return 1;\n  }\n\n  stl_reverse_vector(test_norm);\n  if(   (ABS(normal[0] - test_norm[0]) < 0.001)\n        && (ABS(normal[1] - test_norm[1]) < 0.001)\n        && (ABS(normal[2] - test_norm[2]) < 0.001)) {\n    /* Facet is backwards. */\n    if(normal_fix_flag) {\n      facet->normal.x = normal[0];\n      facet->normal.y = normal[1];\n      facet->normal.z = normal[2];\n      stl->stats.normals_fixed += 1;\n    }\n    return 2;\n  }\n  if(normal_fix_flag) {\n    facet->normal.x = normal[0];\n    facet->normal.y = normal[1];\n    facet->normal.z = normal[2];\n    stl->stats.normals_fixed += 1;\n  }\n  return 4;\n}\n\nstatic void\nstl_reverse_vector(float v[]) {\n  v[0] *= -1;\n  v[1] *= -1;\n  v[2] *= -1;\n}\n\n\nvoid\nstl_calculate_normal(float normal[], stl_facet *facet) {\n  float v1[3];\n  float v2[3];\n\n  v1[0] = facet->vertex[1].x - facet->vertex[0].x;\n  v1[1] = facet->vertex[1].y - facet->vertex[0].y;\n  v1[2] = facet->vertex[1].z - facet->vertex[0].z;\n  v2[0] = facet->vertex[2].x - facet->vertex[0].x;\n  v2[1] = facet->vertex[2].y - facet->vertex[0].y;\n  v2[2] = facet->vertex[2].z - facet->vertex[0].z;\n\n  normal[0] = (float)((double)v1[1] * (double)v2[2]) - ((double)v1[2] * (double)v2[1]);\n  normal[1] = (float)((double)v1[2] * (double)v2[0]) - ((double)v1[0] * (double)v2[2]);\n  normal[2] = (float)((double)v1[0] * (double)v2[1]) - ((double)v1[1] * (double)v2[0]);\n}\n\nvoid stl_normalize_vector(float v[]) {\n  double length;\n  double factor;\n  float min_normal_length;\n\n  length = sqrt((double)v[0] * (double)v[0] + (double)v[1] * (double)v[1] + (double)v[2] * (double)v[2]);\n  min_normal_length = 0.000000000001;\n  if(length < min_normal_length) {\n    v[0] = 0.0;\n    v[1] = 0.0;\n    v[2] = 0.0;\n    return;\n  }\n  factor = 1.0 / length;\n  v[0] *= factor;\n  v[1] *= factor;\n  v[2] *= factor;\n}\n\nvoid\nstl_fix_normal_values(stl_file *stl) {\n  int i;\n\n  if (stl->error) return;\n\n  for(i = 0; i < stl->stats.number_of_facets; i++) {\n    stl_check_normal_vector(stl, i, 1);\n  }\n}\n\nvoid\nstl_reverse_all_facets(stl_file *stl) {\n  int i;\n  float normal[3];\n\n  if (stl->error) return;\n\n  for(i = 0; i < stl->stats.number_of_facets; i++) {\n    stl_reverse_facet(stl, i);\n    stl_calculate_normal(normal, &stl->facet_start[i]);\n    stl_normalize_vector(normal);\n    stl->facet_start[i].normal.x = normal[0];\n    stl->facet_start[i].normal.y = normal[1];\n    stl->facet_start[i].normal.z = normal[2];\n  }\n}\n\n"], "filenames": ["src/normals.c"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [146], "fixing_code_start_loc": [145], "fixing_code_end_loc": [147], "type": "CWE-129", "message": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh Master Commit 767a105 and v0.98.4. A specially-crafted stl file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.", "other": {"cve": {"id": "CVE-2022-38072", "sourceIdentifier": "talos-cna@cisco.com", "published": "2023-04-03T16:15:07.343", "lastModified": "2023-04-09T02:13:14.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh Master Commit 767a105 and v0.98.4. A specially-crafted stl file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "talos-cna@cisco.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}, {"source": "talos-cna@cisco.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-118"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:admesh_project:admesh:0.98.4:*:*:*:*:*:*:*", "matchCriteriaId": "CA8A8D5A-8011-49C7-9527-213CD58D0AD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:admesh_project:admesh:2022-11-18:*:*:*:*:*:*:*", "matchCriteriaId": "784F7EAF-BC6F-421B-8B95-B15CC7A331D0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:slic3r:libslic3r:b1a5500:*:*:*:*:*:*:*", "matchCriteriaId": "2A6DF928-F3A0-46D0-9806-75464C70DD9D"}]}]}], "references": [{"url": "https://github.com/admesh/admesh/commit/5fab257268a0ee6f832c18d72af89810a29fbd5f", "source": "talos-cna@cisco.com", "tags": ["Patch"]}, {"url": "https://talosintelligence.com/vulnerability_reports/TALOS-2022-1594", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/admesh/admesh/commit/5fab257268a0ee6f832c18d72af89810a29fbd5f"}}