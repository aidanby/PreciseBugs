{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key INIT(= -1);\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n                        && vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    CLEAR_FIELD(dummy_cmdmod);\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    proftime_T\ttm;\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n#ifdef FEAT_RELTIME\n\t// Set the time limit to half a second.\n\tprofile_setlimit(500L, &tm);\n#endif\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\tsia.sa_tm = &tm;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textwinlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textwinlock;\n\t    p = get_expr_line();\n\t    --textwinlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_WILDMENU\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t    (void)showmatches(xp, FALSE);\n#endif\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n#ifdef FEAT_WILDMENU\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t       )\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    int p_wmnu_save = p_wmnu;\n\t\t    p_wmnu = 0;\n#endif\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n#ifdef FEAT_WILDMENU\n\t\t    p_wmnu = p_wmnu_save;\n#endif\n\t\t}\n#ifdef FEAT_WILDMENU\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t(void)showmatches(xp, FALSE);\n#endif\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n#ifdef FEAT_WILDMENU\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    i = vim_iswordc(p[-1]);\n\t    while (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t    && vim_iswordc(p[-1]) == i)\n\t\t--p;\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& !break_ctrl_c\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n#endif\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n#ifdef FEAT_WILDMENU\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n#endif\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n#ifdef FEAT_WILDMENU\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n#endif\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n#ifdef FEAT_WILDMENU\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n#endif\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n#ifdef FEAT_WILDMENU\n\t    wildmenu_cleanup(&ccline);\n#endif\n\t}\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n#endif\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1)\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t    (void)showmatches(&xpc, FALSE);\n#endif\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n#endif\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_and_win_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textwinlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    if (textwinlock != 0)\n\treturn e_not_allowed_to_change_text_or_change_window;\n    return e_not_allowed_to_change_text_here;\n}\n\n/*\n * Return TRUE when the text must not be changed and/or we cannot switch to\n * another window.  TRUE while evaluating 'completefunc'.\n */\n    int\ntext_locked(void)\n{\n    return text_and_win_locked() || textlock != 0;\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to  set \"textwinlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textwinlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textwinlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    if (exmode_active || msg_scrolled != 0)\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_ccline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = 0;\n    if (p != NULL)\n    rettv->vval.v_number = p->cmdpos + 1;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\n  call delete('Xtestfile')\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  call delete('Xtest', 'rf')\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xdir1/Xdir2', 'p')\n  call writefile(['testfile1'], 'Xdir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xdir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xdir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xdir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xdir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xdir1/0', @:)\n  call feedkeys(\":e Xdir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xdir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  call delete('Xdir1', 'rf')\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_wildmenu')\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_redraw')\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n  call delete('Xdir with space', 'd')\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  call delete('Xtags')\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E475:')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'p')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'p')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  call delete('Xpathdir', 'rf')\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'p')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\n  call delete('a', 'rf')\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\n  call delete('Xtest.vim')\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xdir')\n  call writefile(['one'], 'Xdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n  call delete('Xdir', 'rf')\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xfile1')\n  call writefile([], 'Xfile2')\n  call feedkeys(\":doautocmd BufEnter Xfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xfile1 Xfile2\", @:)\n  call delete('Xfile1')\n  call delete('Xfile2')\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  augroup! XTest.test\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\n  call delete('XTEST')\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_getcmdwintype()\n  CheckFeature cmdwin\n\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  CheckFeature cmdwin\n\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n  call mkdir('Xdir')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\n  call delete('Xdir', 'd')\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_verbose')\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdwin_bug()\n  CheckFeature cmdwin\n\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_restore')\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature cmdwin\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  CheckFeature cmdwin\n\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  CheckFeature cmdwin\n\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  CheckFeature cmdwin\n\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\n  call delete('XtestCmdlineClearTabenter')\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp')\n  call writefile([], 'Xfile.java')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\n  call delete('Xfile.cpp')\n  call delete('Xfile.java')\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_cmdwin')\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xdir')\n  call writefile([], 'Xdir/Xfile1')\n  call writefile([], 'Xdir/Xfile2')\n  cd Xdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo')\n    call writefile([], 'Xtestbar')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n    call delete('XTESTfoo')\n    call delete('Xtestbar')\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xdir/autoload', 'p')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  CheckFeature cmdwin\n\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  CheckFeature cmdwin\n\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xdir1/dir2/dir3/dir4', 'p')\n  call writefile([], 'Xdir1/file1_1.txt')\n  call writefile([], 'Xdir1/file1_2.txt')\n  call writefile([], 'Xdir1/dir2/file2_1.txt')\n  call writefile([], 'Xdir1/dir2/file2_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xdir1/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/dir2/dir3/dir4/file4_1.txt', @:)\n\n  call delete('Xdir1', 'rf')\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xfile')\n  call writefile([], 'Xfile.c')\n  call writefile([], 'Xfile.o')\n  set suffixes=\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.c Xfile.o', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.o Xfile.c', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c Xfile.o Xfile', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xfile', 'Xfile.c', 'Xfile.o'], getcompletion('Xfile', 'file'))\n  call assert_equal(['Xfile'], getcompletion('Xfile$', 'file'))\n  call delete('Xfile')\n  call delete('Xfile.c')\n  call delete('Xfile.o')\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xdir/XdirA/XdirB', 'p')\n  call writefile([], 'Xdir/XfileA')\n  call writefile([], 'Xdir/XdirA/XfileB')\n  call writefile([], 'Xdir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xdi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xdir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xdir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xdir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumfold')\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  edit SomeFile.txt\n  enew\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SF', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*File.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'p')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  call delete('Xcmd', 'rf')\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  call delete('Xa1b2c3.vim')\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key INIT(= -1);\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n                        && vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    CLEAR_FIELD(dummy_cmdmod);\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    proftime_T\ttm;\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n#ifdef FEAT_RELTIME\n\t// Set the time limit to half a second.\n\tprofile_setlimit(500L, &tm);\n#endif\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\tsia.sa_tm = &tm;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textwinlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textwinlock;\n\t    p = get_expr_line();\n\t    --textwinlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_WILDMENU\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t    (void)showmatches(xp, FALSE);\n#endif\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n#ifdef FEAT_WILDMENU\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t       )\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    int p_wmnu_save = p_wmnu;\n\t\t    p_wmnu = 0;\n#endif\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n#ifdef FEAT_WILDMENU\n\t\t    p_wmnu = p_wmnu_save;\n#endif\n\t\t}\n#ifdef FEAT_WILDMENU\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t(void)showmatches(xp, FALSE);\n#endif\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n#ifdef FEAT_WILDMENU\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& !break_ctrl_c\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n#endif\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n#ifdef FEAT_WILDMENU\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n#endif\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n#ifdef FEAT_WILDMENU\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n#endif\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n#ifdef FEAT_WILDMENU\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n#endif\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n#ifdef FEAT_WILDMENU\n\t    wildmenu_cleanup(&ccline);\n#endif\n\t}\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n#endif\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1)\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t    (void)showmatches(&xpc, FALSE);\n#endif\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n#endif\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_and_win_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textwinlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    if (textwinlock != 0)\n\treturn e_not_allowed_to_change_text_or_change_window;\n    return e_not_allowed_to_change_text_here;\n}\n\n/*\n * Return TRUE when the text must not be changed and/or we cannot switch to\n * another window.  TRUE while evaluating 'completefunc'.\n */\n    int\ntext_locked(void)\n{\n    return text_and_win_locked() || textlock != 0;\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to  set \"textwinlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textwinlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textwinlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    if (exmode_active || msg_scrolled != 0)\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_ccline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = 0;\n    if (p != NULL)\n    rettv->vval.v_number = p->cmdpos + 1;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\n  call delete('Xtestfile')\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  call delete('Xtest', 'rf')\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xdir1/Xdir2', 'p')\n  call writefile(['testfile1'], 'Xdir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xdir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xdir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xdir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xdir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xdir1/0', @:)\n  call feedkeys(\":e Xdir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xdir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  call delete('Xdir1', 'rf')\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_wildmenu')\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_redraw')\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n  call delete('Xdir with space', 'd')\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  call delete('Xtags')\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E475:')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'p')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'p')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  call delete('Xpathdir', 'rf')\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'p')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\n  call delete('a', 'rf')\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n\n    \" This was going before the start in latin1.\n    call feedkeys(\": \\<C-W>\\<CR>\", 'tx')\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\n  call delete('Xtest.vim')\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xdir')\n  call writefile(['one'], 'Xdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n  call delete('Xdir', 'rf')\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xfile1')\n  call writefile([], 'Xfile2')\n  call feedkeys(\":doautocmd BufEnter Xfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xfile1 Xfile2\", @:)\n  call delete('Xfile1')\n  call delete('Xfile2')\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  augroup! XTest.test\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\n  call delete('XTEST')\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_getcmdwintype()\n  CheckFeature cmdwin\n\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  CheckFeature cmdwin\n\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n  call mkdir('Xdir')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\n  call delete('Xdir', 'd')\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_verbose')\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdwin_bug()\n  CheckFeature cmdwin\n\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_restore')\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature cmdwin\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  CheckFeature cmdwin\n\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  CheckFeature cmdwin\n\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  CheckFeature cmdwin\n\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\n  call delete('XtestCmdlineClearTabenter')\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp')\n  call writefile([], 'Xfile.java')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\n  call delete('Xfile.cpp')\n  call delete('Xfile.java')\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_cmdwin')\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xdir')\n  call writefile([], 'Xdir/Xfile1')\n  call writefile([], 'Xdir/Xfile2')\n  cd Xdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo')\n    call writefile([], 'Xtestbar')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n    call delete('XTESTfoo')\n    call delete('Xtestbar')\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xdir/autoload', 'p')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  CheckFeature cmdwin\n\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  CheckFeature cmdwin\n\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xdir1/dir2/dir3/dir4', 'p')\n  call writefile([], 'Xdir1/file1_1.txt')\n  call writefile([], 'Xdir1/file1_2.txt')\n  call writefile([], 'Xdir1/dir2/file2_1.txt')\n  call writefile([], 'Xdir1/dir2/file2_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xdir1/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/dir2/dir3/dir4/file4_1.txt', @:)\n\n  call delete('Xdir1', 'rf')\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xfile')\n  call writefile([], 'Xfile.c')\n  call writefile([], 'Xfile.o')\n  set suffixes=\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.c Xfile.o', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.o Xfile.c', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c Xfile.o Xfile', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xfile', 'Xfile.c', 'Xfile.o'], getcompletion('Xfile', 'file'))\n  call assert_equal(['Xfile'], getcompletion('Xfile$', 'file'))\n  call delete('Xfile')\n  call delete('Xfile.c')\n  call delete('Xfile.o')\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xdir/XdirA/XdirB', 'p')\n  call writefile([], 'Xdir/XfileA')\n  call writefile([], 'Xdir/XdirA/XfileB')\n  call writefile([], 'Xdir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xdi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xdir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xdir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xdir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumfold')\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  edit SomeFile.txt\n  enew\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SF', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*File.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'p')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  call delete('Xcmd', 'rf')\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  call delete('Xa1b2c3.vim')\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_getln.c", "src/testdir/test_cmdline.vim", "src/version.c"], "buggy_code_start_loc": [1085, 775, 748], "buggy_code_end_loc": [1089, 775, 748], "fixing_code_start_loc": [1085, 776, 749], "fixing_code_end_loc": [1092, 779, 751], "type": "CWE-122", "message": "Heap-based Buffer Overflow in function cmdline_erase_chars in GitHub repository vim/vim prior to 8.2.4899. This vulnerabilities are capable of crashing software, modify memory, and possible remote execution", "other": {"cve": {"id": "CVE-2022-1619", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-08T10:15:07.940", "lastModified": "2023-05-03T12:15:19.350", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in function cmdline_erase_chars in GitHub repository vim/vim prior to 8.2.4899. This vulnerabilities are capable of crashing software, modify memory, and possible remote execution"}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en Heap en la funci\u00f3n cmdline_erase_chars en el repositorio de GitHub vim/vim anterior a 8.2.4899. Esta vulnerabilidad es capaz de colapsar el software, modificar la memoria, y la posible ejecuci\u00f3n remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4899", "matchCriteriaId": "548D32AF-C7F0-44F4-A8C9-369E9DC62E80"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/ef02f16609ff0a26ffc6e20263523424980898fe", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b3200483-624e-4c76-a070-e246f62a7450", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A6BY5P7ERZS7KXSBCGFCOXLMLGWUUJIH/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JUN33257RUM4RS2I4GZETKFSAXPETATG/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://security.netapp.com/advisory/ntap-20220930-0007/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/ef02f16609ff0a26ffc6e20263523424980898fe"}}