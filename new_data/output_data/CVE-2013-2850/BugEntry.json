{"buggy_code": ["/*******************************************************************************\n * This file contains main functions related to iSCSI Parameter negotiation.\n *\n * \\u00a9 Copyright 2007-2011 RisingTide Systems LLC.\n *\n * Licensed to the Linux Foundation under the General Public License (GPL) version 2.\n *\n * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n ******************************************************************************/\n\n#include <linux/slab.h>\n\n#include \"iscsi_target_core.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_parameters.h\"\n\nint iscsi_login_rx_data(\n\tstruct iscsi_conn *conn,\n\tchar *buf,\n\tint length)\n{\n\tint rx_got;\n\tstruct kvec iov;\n\n\tmemset(&iov, 0, sizeof(struct kvec));\n\tiov.iov_len\t= length;\n\tiov.iov_base\t= buf;\n\n\t/*\n\t * Initial Marker-less Interval.\n\t * Add the values regardless of IFMarker/OFMarker, considering\n\t * it may not be negoitated yet.\n\t */\n\tconn->of_marker += length;\n\n\trx_got = rx_data(conn, &iov, 1, length);\n\tif (rx_got != length) {\n\t\tpr_err(\"rx_data returned %d, expecting %d.\\n\",\n\t\t\t\trx_got, length);\n\t\treturn -1;\n\t}\n\n\treturn 0 ;\n}\n\nint iscsi_login_tx_data(\n\tstruct iscsi_conn *conn,\n\tchar *pdu_buf,\n\tchar *text_buf,\n\tint text_length)\n{\n\tint length, tx_sent, iov_cnt = 1;\n\tstruct kvec iov[2];\n\n\tlength = (ISCSI_HDR_LEN + text_length);\n\n\tmemset(&iov[0], 0, 2 * sizeof(struct kvec));\n\tiov[0].iov_len\t\t= ISCSI_HDR_LEN;\n\tiov[0].iov_base\t\t= pdu_buf;\n\n\tif (text_buf && text_length) {\n\t\tiov[1].iov_len\t= text_length;\n\t\tiov[1].iov_base\t= text_buf;\n\t\tiov_cnt++;\n\t}\n\n\t/*\n\t * Initial Marker-less Interval.\n\t * Add the values regardless of IFMarker/OFMarker, considering\n\t * it may not be negoitated yet.\n\t */\n\tconn->if_marker += length;\n\n\ttx_sent = tx_data(conn, &iov[0], iov_cnt, length);\n\tif (tx_sent != length) {\n\t\tpr_err(\"tx_data returned %d, expecting %d.\\n\",\n\t\t\t\ttx_sent, length);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid iscsi_dump_conn_ops(struct iscsi_conn_ops *conn_ops)\n{\n\tpr_debug(\"HeaderDigest: %s\\n\", (conn_ops->HeaderDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"DataDigest: %s\\n\", (conn_ops->DataDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"MaxRecvDataSegmentLength: %u\\n\",\n\t\t\t\tconn_ops->MaxRecvDataSegmentLength);\n\tpr_debug(\"OFMarker: %s\\n\", (conn_ops->OFMarker) ? \"Yes\" : \"No\");\n\tpr_debug(\"IFMarker: %s\\n\", (conn_ops->IFMarker) ? \"Yes\" : \"No\");\n\tif (conn_ops->OFMarker)\n\t\tpr_debug(\"OFMarkInt: %u\\n\", conn_ops->OFMarkInt);\n\tif (conn_ops->IFMarker)\n\t\tpr_debug(\"IFMarkInt: %u\\n\", conn_ops->IFMarkInt);\n}\n\nvoid iscsi_dump_sess_ops(struct iscsi_sess_ops *sess_ops)\n{\n\tpr_debug(\"InitiatorName: %s\\n\", sess_ops->InitiatorName);\n\tpr_debug(\"InitiatorAlias: %s\\n\", sess_ops->InitiatorAlias);\n\tpr_debug(\"TargetName: %s\\n\", sess_ops->TargetName);\n\tpr_debug(\"TargetAlias: %s\\n\", sess_ops->TargetAlias);\n\tpr_debug(\"TargetPortalGroupTag: %hu\\n\",\n\t\t\tsess_ops->TargetPortalGroupTag);\n\tpr_debug(\"MaxConnections: %hu\\n\", sess_ops->MaxConnections);\n\tpr_debug(\"InitialR2T: %s\\n\",\n\t\t\t(sess_ops->InitialR2T) ? \"Yes\" : \"No\");\n\tpr_debug(\"ImmediateData: %s\\n\", (sess_ops->ImmediateData) ?\n\t\t\t\"Yes\" : \"No\");\n\tpr_debug(\"MaxBurstLength: %u\\n\", sess_ops->MaxBurstLength);\n\tpr_debug(\"FirstBurstLength: %u\\n\", sess_ops->FirstBurstLength);\n\tpr_debug(\"DefaultTime2Wait: %hu\\n\", sess_ops->DefaultTime2Wait);\n\tpr_debug(\"DefaultTime2Retain: %hu\\n\",\n\t\t\tsess_ops->DefaultTime2Retain);\n\tpr_debug(\"MaxOutstandingR2T: %hu\\n\",\n\t\t\tsess_ops->MaxOutstandingR2T);\n\tpr_debug(\"DataPDUInOrder: %s\\n\",\n\t\t\t(sess_ops->DataPDUInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"DataSequenceInOrder: %s\\n\",\n\t\t\t(sess_ops->DataSequenceInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"ErrorRecoveryLevel: %hu\\n\",\n\t\t\tsess_ops->ErrorRecoveryLevel);\n\tpr_debug(\"SessionType: %s\\n\", (sess_ops->SessionType) ?\n\t\t\t\"Discovery\" : \"Normal\");\n}\n\nvoid iscsi_print_params(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list)\n\t\tpr_debug(\"%s: %s\\n\", param->name, param->value);\n}\n\nstatic struct iscsi_param *iscsi_set_default_param(struct iscsi_param_list *param_list,\n\t\tchar *name, char *value, u8 phase, u8 scope, u8 sender,\n\t\tu16 type_range, u8 use)\n{\n\tstruct iscsi_param *param = NULL;\n\n\tparam = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\tif (!param) {\n\t\tpr_err(\"Unable to allocate memory for parameter.\\n\");\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&param->p_list);\n\n\tparam->name = kstrdup(name, GFP_KERNEL);\n\tif (!param->name) {\n\t\tpr_err(\"Unable to allocate memory for parameter name.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for parameter value.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->phase\t\t= phase;\n\tparam->scope\t\t= scope;\n\tparam->sender\t\t= sender;\n\tparam->use\t\t= use;\n\tparam->type_range\t= type_range;\n\n\tswitch (param->type_range) {\n\tcase TYPERANGE_BOOL_AND:\n\t\tparam->type = TYPE_BOOL_AND;\n\t\tbreak;\n\tcase TYPERANGE_BOOL_OR:\n\t\tparam->type = TYPE_BOOL_OR;\n\t\tbreak;\n\tcase TYPERANGE_0_TO_2:\n\tcase TYPERANGE_0_TO_3600:\n\tcase TYPERANGE_0_TO_32767:\n\tcase TYPERANGE_0_TO_65535:\n\tcase TYPERANGE_1_TO_65535:\n\tcase TYPERANGE_2_TO_3600:\n\tcase TYPERANGE_512_TO_16777215:\n\t\tparam->type = TYPE_NUMBER;\n\t\tbreak;\n\tcase TYPERANGE_AUTH:\n\tcase TYPERANGE_DIGEST:\n\t\tparam->type = TYPE_VALUE_LIST | TYPE_STRING;\n\t\tbreak;\n\tcase TYPERANGE_MARKINT:\n\t\tparam->type = TYPE_NUMBER_RANGE;\n\t\tparam->type_range |= TYPERANGE_1_TO_65535;\n\t\tbreak;\n\tcase TYPERANGE_ISCSINAME:\n\tcase TYPERANGE_SESSIONTYPE:\n\tcase TYPERANGE_TARGETADDRESS:\n\tcase TYPERANGE_UTF8:\n\t\tparam->type = TYPE_STRING;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown type_range 0x%02x\\n\",\n\t\t\t\tparam->type_range);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&param->p_list, &param_list->param_list);\n\n\treturn param;\nout:\n\tif (param) {\n\t\tkfree(param->value);\n\t\tkfree(param->name);\n\t\tkfree(param);\n\t}\n\n\treturn NULL;\n}\n\n/* #warning Add extension keys */\nint iscsi_create_default_params(struct iscsi_param_list **param_list_ptr)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param_list *pl;\n\n\tpl = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!pl) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_param_list.\\n\");\n\t\treturn -1 ;\n\t}\n\tINIT_LIST_HEAD(&pl->param_list);\n\tINIT_LIST_HEAD(&pl->extra_response_list);\n\n\t/*\n\t * The format for setting the initial parameter definitions are:\n\t *\n\t * Parameter name:\n\t * Initial value:\n\t * Allowable phase:\n\t * Scope:\n\t * Allowable senders:\n\t * Typerange:\n\t * Use:\n\t */\n\tparam = iscsi_set_default_param(pl, AUTHMETHOD, INITIAL_AUTHMETHOD,\n\t\t\tPHASE_SECURITY, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_AUTH, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, HEADERDIGEST, INITIAL_HEADERDIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATADIGEST, INITIAL_DATADIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXCONNECTIONS,\n\t\t\tINITIAL_MAXCONNECTIONS, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SENDTARGETS, INITIAL_SENDTARGETS,\n\t\t\tPHASE_FFP0, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_UTF8, 0);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETNAME, INITIAL_TARGETNAME,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_ISCSINAME, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORNAME,\n\t\t\tINITIAL_INITIATORNAME, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_ISCSINAME, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETALIAS, INITIAL_TARGETALIAS,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_UTF8, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORALIAS,\n\t\t\tINITIAL_INITIATORALIAS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR, TYPERANGE_UTF8,\n\t\t\tUSE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETADDRESS,\n\t\t\tINITIAL_TARGETADDRESS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_TARGETADDRESS, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETPORTALGROUPTAG,\n\t\t\tINITIAL_TARGETPORTALGROUPTAG,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_0_TO_65535, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIALR2T, INITIAL_INITIALR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IMMEDIATEDATA,\n\t\t\tINITIAL_IMMEDIATEDATA, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_AND,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXXMITDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXXMITDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXBURSTLENGTH,\n\t\t\tINITIAL_MAXBURSTLENGTH, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, FIRSTBURSTLENGTH,\n\t\t\tINITIAL_FIRSTBURSTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2WAIT,\n\t\t\tINITIAL_DEFAULTTIME2WAIT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2RETAIN,\n\t\t\tINITIAL_DEFAULTTIME2RETAIN,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXOUTSTANDINGR2T,\n\t\t\tINITIAL_MAXOUTSTANDINGR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATAPDUINORDER,\n\t\t\tINITIAL_DATAPDUINORDER, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_OR,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATASEQUENCEINORDER,\n\t\t\tINITIAL_DATASEQUENCEINORDER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, ERRORRECOVERYLEVEL,\n\t\t\tINITIAL_ERRORRECOVERYLEVEL,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_2, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SESSIONTYPE, INITIAL_SESSIONTYPE,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_SESSIONTYPE, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKER, INITIAL_IFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKER, INITIAL_OFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKINT, INITIAL_IFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_MARKINT, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKINT, INITIAL_OFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_MARKINT, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\t/*\n\t * Extra parameters for ISER from RFC-5046\n\t */\n\tparam = iscsi_set_default_param(pl, RDMAEXTENSIONS, INITIAL_RDMAEXTENSIONS,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_TARGETRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\t*param_list_ptr = pl;\n\treturn 0;\nout:\n\tiscsi_release_param_list(pl);\n\treturn -1;\n}\n\nint iscsi_set_keys_to_negotiate(\n\tstruct iscsi_param_list *param_list,\n\tbool iser)\n{\n\tstruct iscsi_param *param;\n\n\tparam_list->iser = iser;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tparam->state = 0;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (param->value)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IFMARKER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, OFMARKER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IFMARKINT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, OFMARKINT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_set_keys_irrelevant_for_discovery(\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIALR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXOUTSTANDINGR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATAPDUINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2WAIT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2RETAIN))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, RDMAEXTENSIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t}\n\n\treturn 0;\n}\n\nint iscsi_copy_param_list(\n\tstruct iscsi_param_list **dst_param_list,\n\tstruct iscsi_param_list *src_param_list,\n\tint leading)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param *new_param = NULL;\n\tstruct iscsi_param_list *param_list = NULL;\n\n\tparam_list = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!param_list) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_param_list.\\n\");\n\t\tgoto err_out;\n\t}\n\tINIT_LIST_HEAD(&param_list->param_list);\n\tINIT_LIST_HEAD(&param_list->extra_response_list);\n\n\tlist_for_each_entry(param, &src_param_list->param_list, p_list) {\n\t\tif (!leading && (param->scope & SCOPE_SESSION_WIDE)) {\n\t\t\tif ((strcmp(param->name, \"TargetName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"InitiatorName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"TargetPortalGroupTag\") != 0))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tnew_param = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\t\tif (!new_param) {\n\t\t\tpr_err(\"Unable to allocate memory for struct iscsi_param.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->name = kstrdup(param->name, GFP_KERNEL);\n\t\tnew_param->value = kstrdup(param->value, GFP_KERNEL);\n\t\tif (!new_param->value || !new_param->name) {\n\t\t\tkfree(new_param->value);\n\t\t\tkfree(new_param->name);\n\t\t\tkfree(new_param);\n\t\t\tpr_err(\"Unable to allocate memory for parameter name/value.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->set_param = param->set_param;\n\t\tnew_param->phase = param->phase;\n\t\tnew_param->scope = param->scope;\n\t\tnew_param->sender = param->sender;\n\t\tnew_param->type = param->type;\n\t\tnew_param->use = param->use;\n\t\tnew_param->type_range = param->type_range;\n\n\t\tlist_add_tail(&new_param->p_list, &param_list->param_list);\n\t}\n\n\tif (!list_empty(&param_list->param_list)) {\n\t\t*dst_param_list = param_list;\n\t} else {\n\t\tpr_err(\"No parameters allocated.\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tiscsi_release_param_list(param_list);\n\treturn -1;\n}\n\nstatic void iscsi_release_extra_responses(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *er, *er_tmp;\n\n\tlist_for_each_entry_safe(er, er_tmp, &param_list->extra_response_list,\n\t\t\ter_list) {\n\t\tlist_del(&er->er_list);\n\t\tkfree(er);\n\t}\n}\n\nvoid iscsi_release_param_list(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param, *param_tmp;\n\n\tlist_for_each_entry_safe(param, param_tmp, &param_list->param_list,\n\t\t\tp_list) {\n\t\tlist_del(&param->p_list);\n\n\t\tkfree(param->name);\n\t\tkfree(param->value);\n\t\tkfree(param);\n\t}\n\n\tiscsi_release_extra_responses(param_list);\n\n\tkfree(param_list);\n}\n\nstruct iscsi_param *iscsi_find_param_from_key(\n\tchar *key,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (!key || !param_list) {\n\t\tpr_err(\"Key or parameter list pointer is NULL.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(key, param->name))\n\t\t\treturn param;\n\t}\n\n\tpr_err(\"Unable to locate key \\\"%s\\\".\\n\", key);\n\treturn NULL;\n}\n\nint iscsi_extract_key_value(char *textbuf, char **key, char **value)\n{\n\t*value = strchr(textbuf, '=');\n\tif (!*value) {\n\t\tpr_err(\"Unable to locate \\\"=\\\" separator for key,\"\n\t\t\t\t\" ignoring request.\\n\");\n\t\treturn -1;\n\t}\n\n\t*key = textbuf;\n\t**value = '\\0';\n\t*value = *value + 1;\n\n\treturn 0;\n}\n\nint iscsi_update_param_value(struct iscsi_param *param, char *value)\n{\n\tkfree(param->value);\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for value.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"iSCSI Parameter updated to %s=%s\\n\",\n\t\t\tparam->name, param->value);\n\treturn 0;\n}\n\nstatic int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n\nstatic int iscsi_check_for_auth_key(char *key)\n{\n\t/*\n\t * RFC 1994\n\t */\n\tif (!strcmp(key, \"CHAP_A\") || !strcmp(key, \"CHAP_I\") ||\n\t    !strcmp(key, \"CHAP_C\") || !strcmp(key, \"CHAP_N\") ||\n\t    !strcmp(key, \"CHAP_R\"))\n\t\treturn 1;\n\n\t/*\n\t * RFC 2945\n\t */\n\tif (!strcmp(key, \"SRP_U\") || !strcmp(key, \"SRP_N\") ||\n\t    !strcmp(key, \"SRP_g\") || !strcmp(key, \"SRP_s\") ||\n\t    !strcmp(key, \"SRP_A\") || !strcmp(key, \"SRP_B\") ||\n\t    !strcmp(key, \"SRP_M\") || !strcmp(key, \"SRP_HM\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)\n{\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(param->value, NO))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(param->value, YES))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t /*\n\t\t  * Required for gPXE iSCSI boot client\n\t\t  */\n\t\tif (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t/*\n\t\t * The GlobalSAN iSCSI Initiator for MacOSX does\n\t\t * not respond to MaxBurstLength, FirstBurstLength,\n\t\t * DefaultTime2Wait or DefaultTime2Retain parameter keys.\n\t\t * So, we set them to 'reply optional' here, and assume the\n\t\t * the defaults from iscsi_parameters.h if the initiator\n\t\t * is not RFC compliant and the keys are not negotiated.\n\t\t */\n\t\tif (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, DEFAULTTIME2WAIT))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, DEFAULTTIME2RETAIN))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t/*\n\t\t * Required for gPXE iSCSI boot client\n\t\t */\n\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_PHASE_DECLARATIVE(param))\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n}\n\nstatic int iscsi_check_boolean_value(struct iscsi_param *param, char *value)\n{\n\tif (strcmp(value, YES) && strcmp(value, NO)) {\n\t\tpr_err(\"Illegal value for \\\"%s\\\", must be either\"\n\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name, YES, NO);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_numerical_value(struct iscsi_param *param, char *value_ptr)\n{\n\tchar *tmpptr;\n\tint value = 0;\n\n\tvalue = simple_strtoul(value_ptr, &tmpptr, 0);\n\n\tif (IS_TYPERANGE_0_TO_2(param)) {\n\t\tif ((value < 0) || (value > 2)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 2.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_3600(param)) {\n\t\tif ((value < 0) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_32767(param)) {\n\t\tif ((value < 0) || (value > 32767)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 32767.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_65535(param)) {\n\t\tif ((value < 0) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_1_TO_65535(param)) {\n\t\tif ((value < 1) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 1 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_2_TO_3600(param)) {\n\t\tif ((value < 2) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 2 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_512_TO_16777215(param)) {\n\t\tif ((value < 512) || (value > 16777215)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 512 and 16777215.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_numerical_range_value(struct iscsi_param *param, char *value)\n{\n\tchar *left_val_ptr = NULL, *right_val_ptr = NULL;\n\tchar *tilde_ptr = NULL;\n\tu32 left_val, right_val, local_left_val;\n\n\tif (strcmp(param->name, IFMARKINT) &&\n\t    strcmp(param->name, OFMARKINT)) {\n\t\tpr_err(\"Only parameters \\\"%s\\\" or \\\"%s\\\" may contain a\"\n\t\t       \" numerical range value.\\n\", IFMARKINT, OFMARKINT);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_PROPOSER(param))\n\t\treturn 0;\n\n\ttilde_ptr = strchr(value, '~');\n\tif (!tilde_ptr) {\n\t\tpr_err(\"Unable to locate numerical range indicator\"\n\t\t\t\" \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\treturn -1;\n\t}\n\t*tilde_ptr = '\\0';\n\n\tleft_val_ptr = value;\n\tright_val_ptr = value + strlen(left_val_ptr) + 1;\n\n\tif (iscsi_check_numerical_value(param, left_val_ptr) < 0)\n\t\treturn -1;\n\tif (iscsi_check_numerical_value(param, right_val_ptr) < 0)\n\t\treturn -1;\n\n\tleft_val = simple_strtoul(left_val_ptr, NULL, 0);\n\tright_val = simple_strtoul(right_val_ptr, NULL, 0);\n\t*tilde_ptr = '~';\n\n\tif (right_val < left_val) {\n\t\tpr_err(\"Numerical range for parameter \\\"%s\\\" contains\"\n\t\t\t\" a right value which is less than the left.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * For now,  enforce reasonable defaults for [I,O]FMarkInt.\n\t */\n\ttilde_ptr = strchr(param->value, '~');\n\tif (!tilde_ptr) {\n\t\tpr_err(\"Unable to locate numerical range indicator\"\n\t\t\t\" \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\treturn -1;\n\t}\n\t*tilde_ptr = '\\0';\n\n\tleft_val_ptr = param->value;\n\tright_val_ptr = param->value + strlen(left_val_ptr) + 1;\n\n\tlocal_left_val = simple_strtoul(left_val_ptr, NULL, 0);\n\t*tilde_ptr = '~';\n\n\tif (param->set_param) {\n\t\tif ((left_val < local_left_val) ||\n\t\t    (right_val < local_left_val)) {\n\t\t\tpr_err(\"Passed value range \\\"%u~%u\\\" is below\"\n\t\t\t\t\" minimum left value \\\"%u\\\" for key \\\"%s\\\",\"\n\t\t\t\t\" rejecting.\\n\", left_val, right_val,\n\t\t\t\tlocal_left_val, param->name);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif ((left_val < local_left_val) &&\n\t\t    (right_val < local_left_val)) {\n\t\t\tpr_err(\"Received value range \\\"%u~%u\\\" is\"\n\t\t\t\t\" below minimum left value \\\"%u\\\" for key\"\n\t\t\t\t\" \\\"%s\\\", rejecting.\\n\", left_val, right_val,\n\t\t\t\tlocal_left_val, param->name);\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t\tif (iscsi_update_param_value(param, REJECT) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_string_or_list_value(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_PROPOSER(param))\n\t\treturn 0;\n\n\tif (IS_TYPERANGE_AUTH_PARAM(param)) {\n\t\tif (strcmp(value, KRB5) && strcmp(value, SPKM1) &&\n\t\t    strcmp(value, SPKM2) && strcmp(value, SRP) &&\n\t\t    strcmp(value, CHAP) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\"\"\n\t\t\t\t\" or \\\"%s\\\".\\n\", param->name, KRB5,\n\t\t\t\t\tSPKM1, SPKM2, SRP, CHAP, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_DIGEST_PARAM(param)) {\n\t\tif (strcmp(value, CRC32C) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tCRC32C, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_SESSIONTYPE(param)) {\n\t\tif (strcmp(value, DISCOVERY) && strcmp(value, NORMAL)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tDISCOVERY, NORMAL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tThis function is used to pick a value range number,  currently just\n *\treturns the lesser of both right values.\n */\nstatic char *iscsi_get_value_from_number_range(\n\tstruct iscsi_param *param,\n\tchar *value)\n{\n\tchar *end_ptr, *tilde_ptr1 = NULL, *tilde_ptr2 = NULL;\n\tu32 acceptor_right_value, proposer_right_value;\n\n\ttilde_ptr1 = strchr(value, '~');\n\tif (!tilde_ptr1)\n\t\treturn NULL;\n\t*tilde_ptr1++ = '\\0';\n\tproposer_right_value = simple_strtoul(tilde_ptr1, &end_ptr, 0);\n\n\ttilde_ptr2 = strchr(param->value, '~');\n\tif (!tilde_ptr2)\n\t\treturn NULL;\n\t*tilde_ptr2++ = '\\0';\n\tacceptor_right_value = simple_strtoul(tilde_ptr2, &end_ptr, 0);\n\n\treturn (acceptor_right_value >= proposer_right_value) ?\n\t\ttilde_ptr1 : tilde_ptr2;\n}\n\nstatic char *iscsi_check_valuelist_for_support(\n\tstruct iscsi_param *param,\n\tchar *value)\n{\n\tchar *tmp1 = NULL, *tmp2 = NULL;\n\tchar *acceptor_values = NULL, *proposer_values = NULL;\n\n\tacceptor_values = param->value;\n\tproposer_values = value;\n\n\tdo {\n\t\tif (!proposer_values)\n\t\t\treturn NULL;\n\t\ttmp1 = strchr(proposer_values, ',');\n\t\tif (tmp1)\n\t\t\t*tmp1 = '\\0';\n\t\tacceptor_values = param->value;\n\t\tdo {\n\t\t\tif (!acceptor_values) {\n\t\t\t\tif (tmp1)\n\t\t\t\t\t*tmp1 = ',';\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp2 = strchr(acceptor_values, ',');\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2 = '\\0';\n\t\t\tif (!strcmp(acceptor_values, proposer_values)) {\n\t\t\t\tif (tmp2)\n\t\t\t\t\t*tmp2 = ',';\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2++ = ',';\n\n\t\t\tacceptor_values = tmp2;\n\t\t} while (acceptor_values);\n\t\tif (tmp1)\n\t\t\t*tmp1++ = ',';\n\t\tproposer_values = tmp1;\n\t} while (proposer_values);\n\nout:\n\treturn proposer_values;\n}\n\nstatic int iscsi_check_acceptor_state(struct iscsi_param *param, char *value,\n\t\t\t\tstruct iscsi_conn *conn)\n{\n\tu8 acceptor_boolean_value = 0, proposer_boolean_value = 0;\n\tchar *negoitated_value = NULL;\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_REJECT(param))\n\t\treturn 0;\n\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value && proposer_boolean_value)\n\t\t\tdo {} while (0);\n\t\telse {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value || proposer_boolean_value) {\n\t\t\tif (iscsi_update_param_value(param, YES) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tchar *tmpptr, buf[11];\n\t\tu32 acceptor_value = simple_strtoul(param->value, &tmpptr, 0);\n\t\tu32 proposer_value = simple_strtoul(value, &tmpptr, 0);\n\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) ||\n\t\t    !strcmp(param->name, MAXBURSTLENGTH) ||\n\t\t    !strcmp(param->name, FIRSTBURSTLENGTH) ||\n\t\t    !strcmp(param->name, MAXOUTSTANDINGR2T) ||\n\t\t    !strcmp(param->name, DEFAULTTIME2RETAIN) ||\n\t\t    !strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tif (proposer_value > acceptor_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tif (acceptor_value > proposer_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tstruct iscsi_param *param_mxdsl;\n\t\t\tunsigned long long tmp;\n\t\t\tint rc;\n\n\t\t\trc = strict_strtoull(param->value, 0, &tmp);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tconn->conn_ops->MaxRecvDataSegmentLength = tmp;\n\t\t\tpr_debug(\"Saving op->MaxRecvDataSegmentLength from\"\n\t\t\t\t\" original initiator received value: %u\\n\",\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength);\n\n\t\t\tparam_mxdsl = iscsi_find_param_from_key(\n\t\t\t\t\t\tMAXXMITDATASEGMENTLENGTH,\n\t\t\t\t\t\tconn->param_list);\n\t\t\tif (!param_mxdsl)\n\t\t\t\treturn -1;\n\n\t\t\trc = iscsi_update_param_value(param,\n\t\t\t\t\t\tparam_mxdsl->value);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tpr_debug(\"Updated %s to target MXDSL value: %s\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\n\t} else if (IS_TYPE_NUMBER_RANGE(param)) {\n\t\tnegoitated_value = iscsi_get_value_from_number_range(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value)\n\t\t\treturn -1;\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tnegoitated_value = iscsi_check_valuelist_for_support(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value) {\n\t\t\tpr_err(\"Proposer's value list \\\"%s\\\" contains\"\n\t\t\t\t\" no valid values from Acceptor's value list\"\n\t\t\t\t\" \\\"%s\\\".\\n\", value, param->value);\n\t\t\treturn -1;\n\t\t}\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_PHASE_DECLARATIVE(param)) {\n\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\treturn -1;\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_proposer_state(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_RESPONSE_GOT(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_TYPE_NUMBER_RANGE(param)) {\n\t\tu32 left_val = 0, right_val = 0, recieved_value = 0;\n\t\tchar *left_val_ptr = NULL, *right_val_ptr = NULL;\n\t\tchar *tilde_ptr = NULL;\n\n\t\tif (!strcmp(value, IRRELEVANT) || !strcmp(value, REJECT)) {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttilde_ptr = strchr(value, '~');\n\t\tif (tilde_ptr) {\n\t\t\tpr_err(\"Illegal \\\"~\\\" in response for \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\treturn -1;\n\t\t}\n\t\ttilde_ptr = strchr(param->value, '~');\n\t\tif (!tilde_ptr) {\n\t\t\tpr_err(\"Unable to locate numerical range\"\n\t\t\t\t\" indicator \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\t*tilde_ptr = '\\0';\n\n\t\tleft_val_ptr = param->value;\n\t\tright_val_ptr = param->value + strlen(left_val_ptr) + 1;\n\t\tleft_val = simple_strtoul(left_val_ptr, NULL, 0);\n\t\tright_val = simple_strtoul(right_val_ptr, NULL, 0);\n\t\trecieved_value = simple_strtoul(value, NULL, 0);\n\n\t\t*tilde_ptr = '~';\n\n\t\tif ((recieved_value < left_val) ||\n\t\t    (recieved_value > right_val)) {\n\t\t\tpr_err(\"Illegal response \\\"%s=%u\\\", value must\"\n\t\t\t\t\" be between %u and %u.\\n\", param->name,\n\t\t\t\trecieved_value, left_val, right_val);\n\t\t\treturn -1;\n\t\t}\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tchar *comma_ptr = NULL, *tmp_ptr = NULL;\n\n\t\tcomma_ptr = strchr(value, ',');\n\t\tif (comma_ptr) {\n\t\t\tpr_err(\"Illegal \\\",\\\" in response for \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp_ptr = iscsi_check_valuelist_for_support(param, value);\n\t\tif (!tmp_ptr)\n\t\t\treturn -1;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int iscsi_check_value(struct iscsi_param *param, char *value)\n{\n\tchar *comma_ptr = NULL;\n\n\tif (!strcmp(value, REJECT)) {\n\t\tif (!strcmp(param->name, IFMARKINT) ||\n\t\t    !strcmp(param->name, OFMARKINT)) {\n\t\t\t/*\n\t\t\t * Reject is not fatal for [I,O]FMarkInt,  and causes\n\t\t\t * [I,O]FMarker to be reset to No. (See iSCSI v20 A.3.2)\n\t\t\t */\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"Received %s=%s\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\tif (!strcmp(value, IRRELEVANT)) {\n\t\tpr_debug(\"Received %s=%s\\n\", param->name, value);\n\t\tSET_PSTATE_IRRELEVANT(param);\n\t\treturn 0;\n\t}\n\tif (!strcmp(value, NOTUNDERSTOOD)) {\n\t\tif (!IS_PSTATE_PROPOSER(param)) {\n\t\t\tpr_err(\"Received illegal offer %s=%s\\n\",\n\t\t\t\tparam->name, value);\n\t\t\treturn -1;\n\t\t}\n\n/* #warning FIXME: Add check for X-ExtensionKey here */\n\t\tpr_err(\"Standard iSCSI key \\\"%s\\\" cannot be answered\"\n\t\t\t\" with \\\"%s\\\", protocol error.\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tcomma_ptr = NULL;\n\t\tcomma_ptr = strchr(value, ',');\n\n\t\tif (comma_ptr && !IS_TYPE_VALUE_LIST(param)) {\n\t\t\tpr_err(\"Detected value separator \\\",\\\", but\"\n\t\t\t\t\" key \\\"%s\\\" does not allow a value list,\"\n\t\t\t\t\" protocol error.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr = '\\0';\n\n\t\tif (strlen(value) > VALUE_MAXLEN) {\n\t\t\tpr_err(\"Value for key \\\"%s\\\" exceeds %d,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t\tVALUE_MAXLEN);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (IS_TYPE_BOOL_AND(param) || IS_TYPE_BOOL_OR(param)) {\n\t\t\tif (iscsi_check_boolean_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_NUMBER(param)) {\n\t\t\tif (iscsi_check_numerical_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_NUMBER_RANGE(param)) {\n\t\t\tif (iscsi_check_numerical_range_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_STRING(param) || IS_TYPE_VALUE_LIST(param)) {\n\t\t\tif (iscsi_check_string_or_list_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tpr_err(\"Huh? 0x%02x\\n\", param->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr++ = ',';\n\n\t\tvalue = comma_ptr;\n\t} while (value);\n\n\treturn 0;\n}\n\nstatic struct iscsi_param *__iscsi_check_key(\n\tchar *key,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic struct iscsi_param *iscsi_check_key(\n\tchar *key,\n\tint phase,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\t/*\n\t * Key name length must not exceed 63 bytes. (See iSCSI v20 5.1)\n\t */\n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" received twice, protocol error.\\n\",\n\t\t\t\tkey);\n\t\treturn NULL;\n\t}\n\n\tif (!phase)\n\t\treturn param;\n\n\tif (!(param->phase & phase)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be negotiated during \",\n\t\t\t\tparam->name);\n\t\tswitch (phase) {\n\t\tcase PHASE_SECURITY:\n\t\t\tpr_debug(\"Security phase.\\n\");\n\t\t\tbreak;\n\t\tcase PHASE_OPERATIONAL:\n\t\t\tpr_debug(\"Operational phase.\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"Unknown phase.\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic int iscsi_enforce_integrity_rules(\n\tu8 phase,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tu8 DataSequenceInOrder = 0;\n\tu8 ErrorRecoveryLevel = 0, SessionType = 0;\n\tu8 IFMarker = 0, OFMarker = 0;\n\tu8 IFMarkInt_Reject = 1, OFMarkInt_Reject = 1;\n\tu32 FirstBurstLength = 0, MaxBurstLength = 0;\n\tstruct iscsi_param *param = NULL;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, SESSIONTYPE))\n\t\t\tif (!strcmp(param->value, NORMAL))\n\t\t\t\tSessionType = 1;\n\t\tif (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tErrorRecoveryLevel = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\tif (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tDataSequenceInOrder = 1;\n\t\tif (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tMaxBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\tif (!strcmp(param->name, IFMARKER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tIFMarker = 1;\n\t\tif (!strcmp(param->name, OFMARKER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tOFMarker = 1;\n\t\tif (!strcmp(param->name, IFMARKINT))\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tIFMarkInt_Reject = 1;\n\t\tif (!strcmp(param->name, OFMARKINT))\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tOFMarkInt_Reject = 1;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!SessionType && (!IS_PSTATE_ACCEPTOR(param) &&\n\t\t     (strcmp(param->name, IFMARKER) &&\n\t\t      strcmp(param->name, OFMARKER) &&\n\t\t      strcmp(param->name, IFMARKINT) &&\n\t\t      strcmp(param->name, OFMARKINT))))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, MAXOUTSTANDINGR2T) &&\n\t\t    DataSequenceInOrder && (ErrorRecoveryLevel > 0)) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) && !SessionType) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tFirstBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\t\tif (FirstBurstLength > MaxBurstLength) {\n\t\t\t\tchar tmpbuf[11];\n\t\t\t\tmemset(tmpbuf, 0, sizeof(tmpbuf));\n\t\t\t\tsprintf(tmpbuf, \"%u\", MaxBurstLength);\n\t\t\t\tif (iscsi_update_param_value(param, tmpbuf))\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, IFMARKER) && IFMarkInt_Reject) {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tIFMarker = 0;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, OFMARKER) && OFMarkInt_Reject) {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tOFMarker = 0;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\t param->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, IFMARKINT) && !IFMarker) {\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tcontinue;\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\t\tif (iscsi_update_param_value(param, IRRELEVANT) < 0)\n\t\t\t\treturn -1;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, OFMARKINT) && !OFMarker) {\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tcontinue;\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\t\tif (iscsi_update_param_value(param, IRRELEVANT) < 0)\n\t\t\t\treturn -1;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}\n\nint iscsi_encode_text_output(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 *length,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *output_buf = NULL;\n\tstruct iscsi_extra_response *er;\n\tstruct iscsi_param *param;\n\n\toutput_buf = textbuf + *length;\n\n\tif (iscsi_enforce_integrity_rules(phase, param_list) < 0)\n\t\treturn -1;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->sender & sender))\n\t\t\tcontinue;\n\t\tif (IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_RESPONSE_SENT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_RESPONSE_SENT(param);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    !IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_PROPOSER(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_PROPOSER(param);\n\t\t\tiscsi_check_proposer_for_optional_reply(param);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t}\n\t}\n\n\tlist_for_each_entry(er, &param_list->extra_response_list, er_list) {\n\t\t*length += sprintf(output_buf, \"%s=%s\", er->key, er->value);\n\t\t*length += 1;\n\t\toutput_buf = textbuf + *length;\n\t\tpr_debug(\"Sending key: %s=%s\\n\", er->key, er->value);\n\t}\n\tiscsi_release_extra_responses(param_list);\n\n\treturn 0;\n}\n\nint iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\n{\n\tint ret = 0;\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    IS_PSTATE_PROPOSER(param) &&\n\t\t    !IS_PSTATE_RESPONSE_GOT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    !IS_PHASE_DECLARATIVE(param)) {\n\t\t\tpr_err(\"No response for proposed key \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint iscsi_change_param_value(\n\tchar *keyvalue,\n\tstruct iscsi_param_list *param_list,\n\tint check_key)\n{\n\tchar *key = NULL, *value = NULL;\n\tstruct iscsi_param *param;\n\tint sender = 0;\n\n\tif (iscsi_extract_key_value(keyvalue, &key, &value) < 0)\n\t\treturn -1;\n\n\tif (!check_key) {\n\t\tparam = __iscsi_check_key(keyvalue, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\t} else {\n\t\tparam = iscsi_check_key(keyvalue, 0, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\n\t\tparam->set_param = 1;\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tparam->set_param = 0;\n\t\t\treturn -1;\n\t\t}\n\t\tparam->set_param = 0;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid iscsi_set_connection_parameters(\n\tstruct iscsi_conn_ops *ops,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"---------------------------------------------------\"\n\t\t\t\"---------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\t/*\n\t\t * Special case to set MAXXMITDATASEGMENTLENGTH from the\n\t\t * target requested MaxRecvDataSegmentLength, even though\n\t\t * this key is not sent over the wire.\n\t\t */\n\t\tif (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tif (param_list->iser == true)\n\t\t\t\tcontinue;\n\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxXmitDataSegmentLength:     %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tpr_debug(\"AuthMethod:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tops->HeaderDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"HeaderDigest:                 %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tops->DataDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"DataDigest:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\t/*\n\t\t\t * At this point iscsi_check_acceptor_state() will have\n\t\t\t * set ops->MaxRecvDataSegmentLength from the original\n\t\t\t * initiator provided value.\n\t\t\t */\n\t\t\tpr_debug(\"MaxRecvDataSegmentLength:     %u\\n\",\n\t\t\t\tops->MaxRecvDataSegmentLength);\n\t\t} else if (!strcmp(param->name, OFMARKER)) {\n\t\t\tops->OFMarker = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"OFMarker:                     %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IFMARKER)) {\n\t\t\tops->IFMarker = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"IFMarker:                     %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, OFMARKINT)) {\n\t\t\tops->OFMarkInt =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"OFMarkInt:                    %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IFMARKINT)) {\n\t\t\tops->IFMarkInt =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"IFMarkInt:                    %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tops->InitiatorRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"InitiatorRecvDataSegmentLength: %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxRecvDataSegmentLength =\n\t\t\t\t\tops->InitiatorRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MRDSL from InitiatorRecvDataSegmentLength\\n\");\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tops->TargetRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetRecvDataSegmentLength:  %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\t\tops->TargetRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MXDSL from TargetRecvDataSegmentLength\\n\");\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n}\n\nvoid iscsi_set_session_parameters(\n\tstruct iscsi_sess_ops *ops,\n\tstruct iscsi_param_list *param_list,\n\tint leading)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->InitiatorName,\n\t\t\t\t\t\tsizeof(ops->InitiatorName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorName:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->InitiatorAlias,\n\t\t\t\t\t\tsizeof(ops->InitiatorAlias),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorAlias:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->TargetName,\n\t\t\t\t\t\tsizeof(ops->TargetName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetName:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->TargetAlias, sizeof(ops->TargetAlias),\n\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetAlias:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tops->TargetPortalGroupTag =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetPortalGroupTag:         %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tops->MaxConnections =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxConnections:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tops->InitialR2T = !strcmp(param->value, YES);\n\t\t\t pr_debug(\"InitialR2T:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tops->ImmediateData = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"ImmediateData:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tops->MaxBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxBurstLength:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tops->FirstBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"FirstBurstLength:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tops->DefaultTime2Wait =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Wait:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tops->DefaultTime2Retain =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Retain:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tops->MaxOutstandingR2T =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxOutstandingR2T:            %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tops->DataPDUInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataPDUInOrder:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tops->DataSequenceInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataSequenceInOrder:          %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tops->ErrorRecoveryLevel =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"ErrorRecoveryLevel:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tops->SessionType = !strcmp(param->value, DISCOVERY);\n\t\t\tpr_debug(\"SessionType:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tops->RDMAExtensions = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"RDMAExtensions:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\n}\n", "#ifndef ISCSI_PARAMETERS_H\n#define ISCSI_PARAMETERS_H\n\nstruct iscsi_extra_response {\n\tchar key[64];\n\tchar value[32];\n\tstruct list_head er_list;\n} ____cacheline_aligned;\n\nstruct iscsi_param {\n\tchar *name;\n\tchar *value;\n\tu8 set_param;\n\tu8 phase;\n\tu8 scope;\n\tu8 sender;\n\tu8 type;\n\tu8 use;\n\tu16 type_range;\n\tu32 state;\n\tstruct list_head p_list;\n} ____cacheline_aligned;\n\nextern int iscsi_login_rx_data(struct iscsi_conn *, char *, int);\nextern int iscsi_login_tx_data(struct iscsi_conn *, char *, char *, int);\nextern void iscsi_dump_conn_ops(struct iscsi_conn_ops *);\nextern void iscsi_dump_sess_ops(struct iscsi_sess_ops *);\nextern void iscsi_print_params(struct iscsi_param_list *);\nextern int iscsi_create_default_params(struct iscsi_param_list **);\nextern int iscsi_set_keys_to_negotiate(struct iscsi_param_list *, bool);\nextern int iscsi_set_keys_irrelevant_for_discovery(struct iscsi_param_list *);\nextern int iscsi_copy_param_list(struct iscsi_param_list **,\n\t\t\tstruct iscsi_param_list *, int);\nextern int iscsi_change_param_value(char *, struct iscsi_param_list *, int);\nextern void iscsi_release_param_list(struct iscsi_param_list *);\nextern struct iscsi_param *iscsi_find_param_from_key(char *, struct iscsi_param_list *);\nextern int iscsi_extract_key_value(char *, char **, char **);\nextern int iscsi_update_param_value(struct iscsi_param *, char *);\nextern int iscsi_decode_text_input(u8, u8, char *, u32, struct iscsi_conn *);\nextern int iscsi_encode_text_output(u8, u8, char *, u32 *,\n\t\t\tstruct iscsi_param_list *);\nextern int iscsi_check_negotiated_keys(struct iscsi_param_list *);\nextern void iscsi_set_connection_parameters(struct iscsi_conn_ops *,\n\t\t\tstruct iscsi_param_list *);\nextern void iscsi_set_session_parameters(struct iscsi_sess_ops *,\n\t\t\tstruct iscsi_param_list *, int);\n\n#define YES\t\t\t\t\"Yes\"\n#define NO\t\t\t\t\"No\"\n#define ALL\t\t\t\t\"All\"\n#define IRRELEVANT\t\t\t\"Irrelevant\"\n#define NONE\t\t\t\t\"None\"\n#define NOTUNDERSTOOD\t\t\t\"NotUnderstood\"\n#define REJECT\t\t\t\t\"Reject\"\n\n/*\n * The Parameter Names.\n */\n#define AUTHMETHOD\t\t\t\"AuthMethod\"\n#define HEADERDIGEST\t\t\t\"HeaderDigest\"\n#define DATADIGEST\t\t\t\"DataDigest\"\n#define MAXCONNECTIONS\t\t\t\"MaxConnections\"\n#define SENDTARGETS\t\t\t\"SendTargets\"\n#define TARGETNAME\t\t\t\"TargetName\"\n#define INITIATORNAME\t\t\t\"InitiatorName\"\n#define TARGETALIAS\t\t\t\"TargetAlias\"\n#define INITIATORALIAS\t\t\t\"InitiatorAlias\"\n#define TARGETADDRESS\t\t\t\"TargetAddress\"\n#define TARGETPORTALGROUPTAG\t\t\"TargetPortalGroupTag\"\n#define INITIALR2T\t\t\t\"InitialR2T\"\n#define IMMEDIATEDATA\t\t\t\"ImmediateData\"\n#define MAXRECVDATASEGMENTLENGTH\t\"MaxRecvDataSegmentLength\"\n#define MAXXMITDATASEGMENTLENGTH\t\"MaxXmitDataSegmentLength\"\n#define MAXBURSTLENGTH\t\t\t\"MaxBurstLength\"\n#define FIRSTBURSTLENGTH\t\t\"FirstBurstLength\"\n#define DEFAULTTIME2WAIT\t\t\"DefaultTime2Wait\"\n#define DEFAULTTIME2RETAIN\t\t\"DefaultTime2Retain\"\n#define MAXOUTSTANDINGR2T\t\t\"MaxOutstandingR2T\"\n#define DATAPDUINORDER\t\t\t\"DataPDUInOrder\"\n#define DATASEQUENCEINORDER\t\t\"DataSequenceInOrder\"\n#define ERRORRECOVERYLEVEL\t\t\"ErrorRecoveryLevel\"\n#define SESSIONTYPE\t\t\t\"SessionType\"\n#define IFMARKER\t\t\t\"IFMarker\"\n#define OFMARKER\t\t\t\"OFMarker\"\n#define IFMARKINT\t\t\t\"IFMarkInt\"\n#define OFMARKINT\t\t\t\"OFMarkInt\"\n#define X_EXTENSIONKEY\t\t\t\"X-com.sbei.version\"\n#define X_EXTENSIONKEY_CISCO_NEW\t\"X-com.cisco.protocol\"\n#define X_EXTENSIONKEY_CISCO_OLD\t\"X-com.cisco.iscsi.draft\"\n\n/*\n * Parameter names of iSCSI Extentions for RDMA (iSER).  See RFC-5046\n */\n#define RDMAEXTENSIONS\t\t\t\"RDMAExtensions\"\n#define INITIATORRECVDATASEGMENTLENGTH\t\"InitiatorRecvDataSegmentLength\"\n#define TARGETRECVDATASEGMENTLENGTH\t\"TargetRecvDataSegmentLength\"\n\n/*\n * For AuthMethod.\n */\n#define KRB5\t\t\t\t\"KRB5\"\n#define SPKM1\t\t\t\t\"SPKM1\"\n#define SPKM2\t\t\t\t\"SPKM2\"\n#define SRP\t\t\t\t\"SRP\"\n#define CHAP\t\t\t\t\"CHAP\"\n\n/*\n * Initial values for Parameter Negotiation.\n */\n#define INITIAL_AUTHMETHOD\t\t\tCHAP\n#define INITIAL_HEADERDIGEST\t\t\t\"CRC32C,None\"\n#define INITIAL_DATADIGEST\t\t\t\"CRC32C,None\"\n#define INITIAL_MAXCONNECTIONS\t\t\t\"1\"\n#define INITIAL_SENDTARGETS\t\t\tALL\n#define INITIAL_TARGETNAME\t\t\t\"LIO.Target\"\n#define INITIAL_INITIATORNAME\t\t\t\"LIO.Initiator\"\n#define INITIAL_TARGETALIAS\t\t\t\"LIO Target\"\n#define INITIAL_INITIATORALIAS\t\t\t\"LIO Initiator\"\n#define INITIAL_TARGETADDRESS\t\t\t\"0.0.0.0:0000,0\"\n#define INITIAL_TARGETPORTALGROUPTAG\t\t\"1\"\n#define INITIAL_INITIALR2T\t\t\tYES\n#define INITIAL_IMMEDIATEDATA\t\t\tYES\n#define INITIAL_MAXRECVDATASEGMENTLENGTH\t\"8192\"\n/*\n * Match outgoing MXDSL default to incoming Open-iSCSI default\n */\n#define INITIAL_MAXXMITDATASEGMENTLENGTH\t\"262144\"\n#define INITIAL_MAXBURSTLENGTH\t\t\t\"262144\"\n#define INITIAL_FIRSTBURSTLENGTH\t\t\"65536\"\n#define INITIAL_DEFAULTTIME2WAIT\t\t\"2\"\n#define INITIAL_DEFAULTTIME2RETAIN\t\t\"20\"\n#define INITIAL_MAXOUTSTANDINGR2T\t\t\"1\"\n#define INITIAL_DATAPDUINORDER\t\t\tYES\n#define INITIAL_DATASEQUENCEINORDER\t\tYES\n#define INITIAL_ERRORRECOVERYLEVEL\t\t\"0\"\n#define INITIAL_SESSIONTYPE\t\t\tNORMAL\n#define INITIAL_IFMARKER\t\t\tNO\n#define INITIAL_OFMARKER\t\t\tNO\n#define INITIAL_IFMARKINT\t\t\t\"2048~65535\"\n#define INITIAL_OFMARKINT\t\t\t\"2048~65535\"\n\n/*\n * Initial values for iSER parameters following RFC-5046 Section 6\n */\n#define INITIAL_RDMAEXTENSIONS\t\t\tNO\n#define INITIAL_INITIATORRECVDATASEGMENTLENGTH\t\"262144\"\n#define INITIAL_TARGETRECVDATASEGMENTLENGTH\t\"8192\"\n\n/*\n * For [Header,Data]Digests.\n */\n#define CRC32C\t\t\t\t\"CRC32C\"\n\n/*\n * For SessionType.\n */\n#define DISCOVERY\t\t\t\"Discovery\"\n#define NORMAL\t\t\t\t\"Normal\"\n\n/*\n * struct iscsi_param->use\n */\n#define USE_LEADING_ONLY\t\t0x01\n#define USE_INITIAL_ONLY\t\t0x02\n#define USE_ALL\t\t\t\t0x04\n\n#define IS_USE_LEADING_ONLY(p)\t\t((p)->use & USE_LEADING_ONLY)\n#define IS_USE_INITIAL_ONLY(p)\t\t((p)->use & USE_INITIAL_ONLY)\n#define IS_USE_ALL(p)\t\t\t((p)->use & USE_ALL)\n\n#define SET_USE_INITIAL_ONLY(p)\t\t((p)->use |= USE_INITIAL_ONLY)\n\n/*\n * struct iscsi_param->sender\n */\n#define\tSENDER_INITIATOR\t\t0x01\n#define SENDER_TARGET\t\t\t0x02\n#define SENDER_BOTH\t\t\t0x03\n/* Used in iscsi_check_key() */\n#define SENDER_RECEIVER\t\t\t0x04\n\n#define IS_SENDER_INITIATOR(p)\t\t((p)->sender & SENDER_INITIATOR)\n#define IS_SENDER_TARGET(p)\t\t((p)->sender & SENDER_TARGET)\n#define IS_SENDER_BOTH(p)\t\t((p)->sender & SENDER_BOTH)\n\n/*\n * struct iscsi_param->scope\n */\n#define SCOPE_CONNECTION_ONLY\t\t0x01\n#define SCOPE_SESSION_WIDE\t\t0x02\n\n#define IS_SCOPE_CONNECTION_ONLY(p)\t((p)->scope & SCOPE_CONNECTION_ONLY)\n#define IS_SCOPE_SESSION_WIDE(p)\t((p)->scope & SCOPE_SESSION_WIDE)\n\n/*\n * struct iscsi_param->phase\n */\n#define PHASE_SECURITY\t\t\t0x01\n#define PHASE_OPERATIONAL\t\t0x02\n#define PHASE_DECLARATIVE\t\t0x04\n#define PHASE_FFP0\t\t\t0x08\n\n#define IS_PHASE_SECURITY(p)\t\t((p)->phase & PHASE_SECURITY)\n#define IS_PHASE_OPERATIONAL(p)\t\t((p)->phase & PHASE_OPERATIONAL)\n#define IS_PHASE_DECLARATIVE(p)\t\t((p)->phase & PHASE_DECLARATIVE)\n#define IS_PHASE_FFP0(p)\t\t((p)->phase & PHASE_FFP0)\n\n/*\n * struct iscsi_param->type\n */\n#define TYPE_BOOL_AND\t\t\t0x01\n#define TYPE_BOOL_OR\t\t\t0x02\n#define TYPE_NUMBER\t\t\t0x04\n#define TYPE_NUMBER_RANGE\t\t0x08\n#define TYPE_STRING\t\t\t0x10\n#define TYPE_VALUE_LIST\t\t\t0x20\n\n#define IS_TYPE_BOOL_AND(p)\t\t((p)->type & TYPE_BOOL_AND)\n#define IS_TYPE_BOOL_OR(p)\t\t((p)->type & TYPE_BOOL_OR)\n#define IS_TYPE_NUMBER(p)\t\t((p)->type & TYPE_NUMBER)\n#define IS_TYPE_NUMBER_RANGE(p)\t\t((p)->type & TYPE_NUMBER_RANGE)\n#define IS_TYPE_STRING(p)\t\t((p)->type & TYPE_STRING)\n#define IS_TYPE_VALUE_LIST(p)\t\t((p)->type & TYPE_VALUE_LIST)\n\n/*\n * struct iscsi_param->type_range\n */\n#define TYPERANGE_BOOL_AND\t\t0x0001\n#define TYPERANGE_BOOL_OR\t\t0x0002\n#define TYPERANGE_0_TO_2\t\t0x0004\n#define TYPERANGE_0_TO_3600\t\t0x0008\n#define TYPERANGE_0_TO_32767\t\t0x0010\n#define TYPERANGE_0_TO_65535\t\t0x0020\n#define TYPERANGE_1_TO_65535\t\t0x0040\n#define TYPERANGE_2_TO_3600\t\t0x0080\n#define TYPERANGE_512_TO_16777215\t0x0100\n#define TYPERANGE_AUTH\t\t\t0x0200\n#define TYPERANGE_DIGEST\t\t0x0400\n#define TYPERANGE_ISCSINAME\t\t0x0800\n#define TYPERANGE_MARKINT\t\t0x1000\n#define TYPERANGE_SESSIONTYPE\t\t0x2000\n#define TYPERANGE_TARGETADDRESS\t\t0x4000\n#define TYPERANGE_UTF8\t\t\t0x8000\n\n#define IS_TYPERANGE_0_TO_2(p)\t\t((p)->type_range & TYPERANGE_0_TO_2)\n#define IS_TYPERANGE_0_TO_3600(p)\t((p)->type_range & TYPERANGE_0_TO_3600)\n#define IS_TYPERANGE_0_TO_32767(p)\t((p)->type_range & TYPERANGE_0_TO_32767)\n#define IS_TYPERANGE_0_TO_65535(p)\t((p)->type_range & TYPERANGE_0_TO_65535)\n#define IS_TYPERANGE_1_TO_65535(p)\t((p)->type_range & TYPERANGE_1_TO_65535)\n#define IS_TYPERANGE_2_TO_3600(p)\t((p)->type_range & TYPERANGE_2_TO_3600)\n#define IS_TYPERANGE_512_TO_16777215(p)\t((p)->type_range & \\\n\t\t\t\t\t\tTYPERANGE_512_TO_16777215)\n#define IS_TYPERANGE_AUTH_PARAM(p)\t((p)->type_range & TYPERANGE_AUTH)\n#define IS_TYPERANGE_DIGEST_PARAM(p)\t((p)->type_range & TYPERANGE_DIGEST)\n#define IS_TYPERANGE_SESSIONTYPE(p)\t((p)->type_range & \\\n\t\t\t\t\t\tTYPERANGE_SESSIONTYPE)\n\n/*\n * struct iscsi_param->state\n */\n#define PSTATE_ACCEPTOR\t\t\t0x01\n#define PSTATE_NEGOTIATE\t\t0x02\n#define PSTATE_PROPOSER\t\t\t0x04\n#define PSTATE_IRRELEVANT\t\t0x08\n#define PSTATE_REJECT\t\t\t0x10\n#define PSTATE_REPLY_OPTIONAL\t\t0x20\n#define PSTATE_RESPONSE_GOT\t\t0x40\n#define PSTATE_RESPONSE_SENT\t\t0x80\n\n#define IS_PSTATE_ACCEPTOR(p)\t\t((p)->state & PSTATE_ACCEPTOR)\n#define IS_PSTATE_NEGOTIATE(p)\t\t((p)->state & PSTATE_NEGOTIATE)\n#define IS_PSTATE_PROPOSER(p)\t\t((p)->state & PSTATE_PROPOSER)\n#define IS_PSTATE_IRRELEVANT(p)\t\t((p)->state & PSTATE_IRRELEVANT)\n#define IS_PSTATE_REJECT(p)\t\t((p)->state & PSTATE_REJECT)\n#define IS_PSTATE_REPLY_OPTIONAL(p)\t((p)->state & PSTATE_REPLY_OPTIONAL)\n#define IS_PSTATE_RESPONSE_GOT(p)\t((p)->state & PSTATE_RESPONSE_GOT)\n#define IS_PSTATE_RESPONSE_SENT(p)\t((p)->state & PSTATE_RESPONSE_SENT)\n\n#define SET_PSTATE_ACCEPTOR(p)\t\t((p)->state |= PSTATE_ACCEPTOR)\n#define SET_PSTATE_NEGOTIATE(p)\t\t((p)->state |= PSTATE_NEGOTIATE)\n#define SET_PSTATE_PROPOSER(p)\t\t((p)->state |= PSTATE_PROPOSER)\n#define SET_PSTATE_IRRELEVANT(p)\t((p)->state |= PSTATE_IRRELEVANT)\n#define SET_PSTATE_REJECT(p)\t\t((p)->state |= PSTATE_REJECT)\n#define SET_PSTATE_REPLY_OPTIONAL(p)\t((p)->state |= PSTATE_REPLY_OPTIONAL)\n#define SET_PSTATE_RESPONSE_GOT(p)\t((p)->state |= PSTATE_RESPONSE_GOT)\n#define SET_PSTATE_RESPONSE_SENT(p)\t((p)->state |= PSTATE_RESPONSE_SENT)\n\n#endif /* ISCSI_PARAMETERS_H */\n"], "fixing_code": ["/*******************************************************************************\n * This file contains main functions related to iSCSI Parameter negotiation.\n *\n * \\u00a9 Copyright 2007-2011 RisingTide Systems LLC.\n *\n * Licensed to the Linux Foundation under the General Public License (GPL) version 2.\n *\n * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n ******************************************************************************/\n\n#include <linux/slab.h>\n\n#include \"iscsi_target_core.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_parameters.h\"\n\nint iscsi_login_rx_data(\n\tstruct iscsi_conn *conn,\n\tchar *buf,\n\tint length)\n{\n\tint rx_got;\n\tstruct kvec iov;\n\n\tmemset(&iov, 0, sizeof(struct kvec));\n\tiov.iov_len\t= length;\n\tiov.iov_base\t= buf;\n\n\t/*\n\t * Initial Marker-less Interval.\n\t * Add the values regardless of IFMarker/OFMarker, considering\n\t * it may not be negoitated yet.\n\t */\n\tconn->of_marker += length;\n\n\trx_got = rx_data(conn, &iov, 1, length);\n\tif (rx_got != length) {\n\t\tpr_err(\"rx_data returned %d, expecting %d.\\n\",\n\t\t\t\trx_got, length);\n\t\treturn -1;\n\t}\n\n\treturn 0 ;\n}\n\nint iscsi_login_tx_data(\n\tstruct iscsi_conn *conn,\n\tchar *pdu_buf,\n\tchar *text_buf,\n\tint text_length)\n{\n\tint length, tx_sent, iov_cnt = 1;\n\tstruct kvec iov[2];\n\n\tlength = (ISCSI_HDR_LEN + text_length);\n\n\tmemset(&iov[0], 0, 2 * sizeof(struct kvec));\n\tiov[0].iov_len\t\t= ISCSI_HDR_LEN;\n\tiov[0].iov_base\t\t= pdu_buf;\n\n\tif (text_buf && text_length) {\n\t\tiov[1].iov_len\t= text_length;\n\t\tiov[1].iov_base\t= text_buf;\n\t\tiov_cnt++;\n\t}\n\n\t/*\n\t * Initial Marker-less Interval.\n\t * Add the values regardless of IFMarker/OFMarker, considering\n\t * it may not be negoitated yet.\n\t */\n\tconn->if_marker += length;\n\n\ttx_sent = tx_data(conn, &iov[0], iov_cnt, length);\n\tif (tx_sent != length) {\n\t\tpr_err(\"tx_data returned %d, expecting %d.\\n\",\n\t\t\t\ttx_sent, length);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid iscsi_dump_conn_ops(struct iscsi_conn_ops *conn_ops)\n{\n\tpr_debug(\"HeaderDigest: %s\\n\", (conn_ops->HeaderDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"DataDigest: %s\\n\", (conn_ops->DataDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"MaxRecvDataSegmentLength: %u\\n\",\n\t\t\t\tconn_ops->MaxRecvDataSegmentLength);\n\tpr_debug(\"OFMarker: %s\\n\", (conn_ops->OFMarker) ? \"Yes\" : \"No\");\n\tpr_debug(\"IFMarker: %s\\n\", (conn_ops->IFMarker) ? \"Yes\" : \"No\");\n\tif (conn_ops->OFMarker)\n\t\tpr_debug(\"OFMarkInt: %u\\n\", conn_ops->OFMarkInt);\n\tif (conn_ops->IFMarker)\n\t\tpr_debug(\"IFMarkInt: %u\\n\", conn_ops->IFMarkInt);\n}\n\nvoid iscsi_dump_sess_ops(struct iscsi_sess_ops *sess_ops)\n{\n\tpr_debug(\"InitiatorName: %s\\n\", sess_ops->InitiatorName);\n\tpr_debug(\"InitiatorAlias: %s\\n\", sess_ops->InitiatorAlias);\n\tpr_debug(\"TargetName: %s\\n\", sess_ops->TargetName);\n\tpr_debug(\"TargetAlias: %s\\n\", sess_ops->TargetAlias);\n\tpr_debug(\"TargetPortalGroupTag: %hu\\n\",\n\t\t\tsess_ops->TargetPortalGroupTag);\n\tpr_debug(\"MaxConnections: %hu\\n\", sess_ops->MaxConnections);\n\tpr_debug(\"InitialR2T: %s\\n\",\n\t\t\t(sess_ops->InitialR2T) ? \"Yes\" : \"No\");\n\tpr_debug(\"ImmediateData: %s\\n\", (sess_ops->ImmediateData) ?\n\t\t\t\"Yes\" : \"No\");\n\tpr_debug(\"MaxBurstLength: %u\\n\", sess_ops->MaxBurstLength);\n\tpr_debug(\"FirstBurstLength: %u\\n\", sess_ops->FirstBurstLength);\n\tpr_debug(\"DefaultTime2Wait: %hu\\n\", sess_ops->DefaultTime2Wait);\n\tpr_debug(\"DefaultTime2Retain: %hu\\n\",\n\t\t\tsess_ops->DefaultTime2Retain);\n\tpr_debug(\"MaxOutstandingR2T: %hu\\n\",\n\t\t\tsess_ops->MaxOutstandingR2T);\n\tpr_debug(\"DataPDUInOrder: %s\\n\",\n\t\t\t(sess_ops->DataPDUInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"DataSequenceInOrder: %s\\n\",\n\t\t\t(sess_ops->DataSequenceInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"ErrorRecoveryLevel: %hu\\n\",\n\t\t\tsess_ops->ErrorRecoveryLevel);\n\tpr_debug(\"SessionType: %s\\n\", (sess_ops->SessionType) ?\n\t\t\t\"Discovery\" : \"Normal\");\n}\n\nvoid iscsi_print_params(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list)\n\t\tpr_debug(\"%s: %s\\n\", param->name, param->value);\n}\n\nstatic struct iscsi_param *iscsi_set_default_param(struct iscsi_param_list *param_list,\n\t\tchar *name, char *value, u8 phase, u8 scope, u8 sender,\n\t\tu16 type_range, u8 use)\n{\n\tstruct iscsi_param *param = NULL;\n\n\tparam = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\tif (!param) {\n\t\tpr_err(\"Unable to allocate memory for parameter.\\n\");\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&param->p_list);\n\n\tparam->name = kstrdup(name, GFP_KERNEL);\n\tif (!param->name) {\n\t\tpr_err(\"Unable to allocate memory for parameter name.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for parameter value.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->phase\t\t= phase;\n\tparam->scope\t\t= scope;\n\tparam->sender\t\t= sender;\n\tparam->use\t\t= use;\n\tparam->type_range\t= type_range;\n\n\tswitch (param->type_range) {\n\tcase TYPERANGE_BOOL_AND:\n\t\tparam->type = TYPE_BOOL_AND;\n\t\tbreak;\n\tcase TYPERANGE_BOOL_OR:\n\t\tparam->type = TYPE_BOOL_OR;\n\t\tbreak;\n\tcase TYPERANGE_0_TO_2:\n\tcase TYPERANGE_0_TO_3600:\n\tcase TYPERANGE_0_TO_32767:\n\tcase TYPERANGE_0_TO_65535:\n\tcase TYPERANGE_1_TO_65535:\n\tcase TYPERANGE_2_TO_3600:\n\tcase TYPERANGE_512_TO_16777215:\n\t\tparam->type = TYPE_NUMBER;\n\t\tbreak;\n\tcase TYPERANGE_AUTH:\n\tcase TYPERANGE_DIGEST:\n\t\tparam->type = TYPE_VALUE_LIST | TYPE_STRING;\n\t\tbreak;\n\tcase TYPERANGE_MARKINT:\n\t\tparam->type = TYPE_NUMBER_RANGE;\n\t\tparam->type_range |= TYPERANGE_1_TO_65535;\n\t\tbreak;\n\tcase TYPERANGE_ISCSINAME:\n\tcase TYPERANGE_SESSIONTYPE:\n\tcase TYPERANGE_TARGETADDRESS:\n\tcase TYPERANGE_UTF8:\n\t\tparam->type = TYPE_STRING;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown type_range 0x%02x\\n\",\n\t\t\t\tparam->type_range);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&param->p_list, &param_list->param_list);\n\n\treturn param;\nout:\n\tif (param) {\n\t\tkfree(param->value);\n\t\tkfree(param->name);\n\t\tkfree(param);\n\t}\n\n\treturn NULL;\n}\n\n/* #warning Add extension keys */\nint iscsi_create_default_params(struct iscsi_param_list **param_list_ptr)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param_list *pl;\n\n\tpl = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!pl) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_param_list.\\n\");\n\t\treturn -1 ;\n\t}\n\tINIT_LIST_HEAD(&pl->param_list);\n\tINIT_LIST_HEAD(&pl->extra_response_list);\n\n\t/*\n\t * The format for setting the initial parameter definitions are:\n\t *\n\t * Parameter name:\n\t * Initial value:\n\t * Allowable phase:\n\t * Scope:\n\t * Allowable senders:\n\t * Typerange:\n\t * Use:\n\t */\n\tparam = iscsi_set_default_param(pl, AUTHMETHOD, INITIAL_AUTHMETHOD,\n\t\t\tPHASE_SECURITY, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_AUTH, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, HEADERDIGEST, INITIAL_HEADERDIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATADIGEST, INITIAL_DATADIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXCONNECTIONS,\n\t\t\tINITIAL_MAXCONNECTIONS, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SENDTARGETS, INITIAL_SENDTARGETS,\n\t\t\tPHASE_FFP0, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_UTF8, 0);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETNAME, INITIAL_TARGETNAME,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_ISCSINAME, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORNAME,\n\t\t\tINITIAL_INITIATORNAME, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_ISCSINAME, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETALIAS, INITIAL_TARGETALIAS,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_UTF8, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORALIAS,\n\t\t\tINITIAL_INITIATORALIAS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR, TYPERANGE_UTF8,\n\t\t\tUSE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETADDRESS,\n\t\t\tINITIAL_TARGETADDRESS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_TARGETADDRESS, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETPORTALGROUPTAG,\n\t\t\tINITIAL_TARGETPORTALGROUPTAG,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_0_TO_65535, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIALR2T, INITIAL_INITIALR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IMMEDIATEDATA,\n\t\t\tINITIAL_IMMEDIATEDATA, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_AND,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXXMITDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXXMITDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXBURSTLENGTH,\n\t\t\tINITIAL_MAXBURSTLENGTH, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, FIRSTBURSTLENGTH,\n\t\t\tINITIAL_FIRSTBURSTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2WAIT,\n\t\t\tINITIAL_DEFAULTTIME2WAIT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2RETAIN,\n\t\t\tINITIAL_DEFAULTTIME2RETAIN,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXOUTSTANDINGR2T,\n\t\t\tINITIAL_MAXOUTSTANDINGR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATAPDUINORDER,\n\t\t\tINITIAL_DATAPDUINORDER, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_OR,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATASEQUENCEINORDER,\n\t\t\tINITIAL_DATASEQUENCEINORDER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, ERRORRECOVERYLEVEL,\n\t\t\tINITIAL_ERRORRECOVERYLEVEL,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_2, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SESSIONTYPE, INITIAL_SESSIONTYPE,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_SESSIONTYPE, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKER, INITIAL_IFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKER, INITIAL_OFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKINT, INITIAL_IFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_MARKINT, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKINT, INITIAL_OFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_MARKINT, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\t/*\n\t * Extra parameters for ISER from RFC-5046\n\t */\n\tparam = iscsi_set_default_param(pl, RDMAEXTENSIONS, INITIAL_RDMAEXTENSIONS,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_TARGETRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\t*param_list_ptr = pl;\n\treturn 0;\nout:\n\tiscsi_release_param_list(pl);\n\treturn -1;\n}\n\nint iscsi_set_keys_to_negotiate(\n\tstruct iscsi_param_list *param_list,\n\tbool iser)\n{\n\tstruct iscsi_param *param;\n\n\tparam_list->iser = iser;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tparam->state = 0;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (param->value)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == false)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IFMARKER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, OFMARKER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IFMARKINT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, OFMARKINT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser == true)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_set_keys_irrelevant_for_discovery(\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIALR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXOUTSTANDINGR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATAPDUINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2WAIT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2RETAIN))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, RDMAEXTENSIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t}\n\n\treturn 0;\n}\n\nint iscsi_copy_param_list(\n\tstruct iscsi_param_list **dst_param_list,\n\tstruct iscsi_param_list *src_param_list,\n\tint leading)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param *new_param = NULL;\n\tstruct iscsi_param_list *param_list = NULL;\n\n\tparam_list = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!param_list) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_param_list.\\n\");\n\t\tgoto err_out;\n\t}\n\tINIT_LIST_HEAD(&param_list->param_list);\n\tINIT_LIST_HEAD(&param_list->extra_response_list);\n\n\tlist_for_each_entry(param, &src_param_list->param_list, p_list) {\n\t\tif (!leading && (param->scope & SCOPE_SESSION_WIDE)) {\n\t\t\tif ((strcmp(param->name, \"TargetName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"InitiatorName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"TargetPortalGroupTag\") != 0))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tnew_param = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\t\tif (!new_param) {\n\t\t\tpr_err(\"Unable to allocate memory for struct iscsi_param.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->name = kstrdup(param->name, GFP_KERNEL);\n\t\tnew_param->value = kstrdup(param->value, GFP_KERNEL);\n\t\tif (!new_param->value || !new_param->name) {\n\t\t\tkfree(new_param->value);\n\t\t\tkfree(new_param->name);\n\t\t\tkfree(new_param);\n\t\t\tpr_err(\"Unable to allocate memory for parameter name/value.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->set_param = param->set_param;\n\t\tnew_param->phase = param->phase;\n\t\tnew_param->scope = param->scope;\n\t\tnew_param->sender = param->sender;\n\t\tnew_param->type = param->type;\n\t\tnew_param->use = param->use;\n\t\tnew_param->type_range = param->type_range;\n\n\t\tlist_add_tail(&new_param->p_list, &param_list->param_list);\n\t}\n\n\tif (!list_empty(&param_list->param_list)) {\n\t\t*dst_param_list = param_list;\n\t} else {\n\t\tpr_err(\"No parameters allocated.\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tiscsi_release_param_list(param_list);\n\treturn -1;\n}\n\nstatic void iscsi_release_extra_responses(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *er, *er_tmp;\n\n\tlist_for_each_entry_safe(er, er_tmp, &param_list->extra_response_list,\n\t\t\ter_list) {\n\t\tlist_del(&er->er_list);\n\t\tkfree(er);\n\t}\n}\n\nvoid iscsi_release_param_list(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param, *param_tmp;\n\n\tlist_for_each_entry_safe(param, param_tmp, &param_list->param_list,\n\t\t\tp_list) {\n\t\tlist_del(&param->p_list);\n\n\t\tkfree(param->name);\n\t\tkfree(param->value);\n\t\tkfree(param);\n\t}\n\n\tiscsi_release_extra_responses(param_list);\n\n\tkfree(param_list);\n}\n\nstruct iscsi_param *iscsi_find_param_from_key(\n\tchar *key,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (!key || !param_list) {\n\t\tpr_err(\"Key or parameter list pointer is NULL.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(key, param->name))\n\t\t\treturn param;\n\t}\n\n\tpr_err(\"Unable to locate key \\\"%s\\\".\\n\", key);\n\treturn NULL;\n}\n\nint iscsi_extract_key_value(char *textbuf, char **key, char **value)\n{\n\t*value = strchr(textbuf, '=');\n\tif (!*value) {\n\t\tpr_err(\"Unable to locate \\\"=\\\" separator for key,\"\n\t\t\t\t\" ignoring request.\\n\");\n\t\treturn -1;\n\t}\n\n\t*key = textbuf;\n\t**value = '\\0';\n\t*value = *value + 1;\n\n\treturn 0;\n}\n\nint iscsi_update_param_value(struct iscsi_param *param, char *value)\n{\n\tkfree(param->value);\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for value.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"iSCSI Parameter updated to %s=%s\\n\",\n\t\t\tparam->name, param->value);\n\treturn 0;\n}\n\nstatic int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n\nstatic int iscsi_check_for_auth_key(char *key)\n{\n\t/*\n\t * RFC 1994\n\t */\n\tif (!strcmp(key, \"CHAP_A\") || !strcmp(key, \"CHAP_I\") ||\n\t    !strcmp(key, \"CHAP_C\") || !strcmp(key, \"CHAP_N\") ||\n\t    !strcmp(key, \"CHAP_R\"))\n\t\treturn 1;\n\n\t/*\n\t * RFC 2945\n\t */\n\tif (!strcmp(key, \"SRP_U\") || !strcmp(key, \"SRP_N\") ||\n\t    !strcmp(key, \"SRP_g\") || !strcmp(key, \"SRP_s\") ||\n\t    !strcmp(key, \"SRP_A\") || !strcmp(key, \"SRP_B\") ||\n\t    !strcmp(key, \"SRP_M\") || !strcmp(key, \"SRP_HM\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)\n{\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(param->value, NO))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(param->value, YES))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t /*\n\t\t  * Required for gPXE iSCSI boot client\n\t\t  */\n\t\tif (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t/*\n\t\t * The GlobalSAN iSCSI Initiator for MacOSX does\n\t\t * not respond to MaxBurstLength, FirstBurstLength,\n\t\t * DefaultTime2Wait or DefaultTime2Retain parameter keys.\n\t\t * So, we set them to 'reply optional' here, and assume the\n\t\t * the defaults from iscsi_parameters.h if the initiator\n\t\t * is not RFC compliant and the keys are not negotiated.\n\t\t */\n\t\tif (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, DEFAULTTIME2WAIT))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\tif (!strcmp(param->name, DEFAULTTIME2RETAIN))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t/*\n\t\t * Required for gPXE iSCSI boot client\n\t\t */\n\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_PHASE_DECLARATIVE(param))\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n}\n\nstatic int iscsi_check_boolean_value(struct iscsi_param *param, char *value)\n{\n\tif (strcmp(value, YES) && strcmp(value, NO)) {\n\t\tpr_err(\"Illegal value for \\\"%s\\\", must be either\"\n\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name, YES, NO);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_numerical_value(struct iscsi_param *param, char *value_ptr)\n{\n\tchar *tmpptr;\n\tint value = 0;\n\n\tvalue = simple_strtoul(value_ptr, &tmpptr, 0);\n\n\tif (IS_TYPERANGE_0_TO_2(param)) {\n\t\tif ((value < 0) || (value > 2)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 2.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_3600(param)) {\n\t\tif ((value < 0) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_32767(param)) {\n\t\tif ((value < 0) || (value > 32767)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 32767.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_65535(param)) {\n\t\tif ((value < 0) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_1_TO_65535(param)) {\n\t\tif ((value < 1) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 1 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_2_TO_3600(param)) {\n\t\tif ((value < 2) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 2 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_512_TO_16777215(param)) {\n\t\tif ((value < 512) || (value > 16777215)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 512 and 16777215.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_numerical_range_value(struct iscsi_param *param, char *value)\n{\n\tchar *left_val_ptr = NULL, *right_val_ptr = NULL;\n\tchar *tilde_ptr = NULL;\n\tu32 left_val, right_val, local_left_val;\n\n\tif (strcmp(param->name, IFMARKINT) &&\n\t    strcmp(param->name, OFMARKINT)) {\n\t\tpr_err(\"Only parameters \\\"%s\\\" or \\\"%s\\\" may contain a\"\n\t\t       \" numerical range value.\\n\", IFMARKINT, OFMARKINT);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_PROPOSER(param))\n\t\treturn 0;\n\n\ttilde_ptr = strchr(value, '~');\n\tif (!tilde_ptr) {\n\t\tpr_err(\"Unable to locate numerical range indicator\"\n\t\t\t\" \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\treturn -1;\n\t}\n\t*tilde_ptr = '\\0';\n\n\tleft_val_ptr = value;\n\tright_val_ptr = value + strlen(left_val_ptr) + 1;\n\n\tif (iscsi_check_numerical_value(param, left_val_ptr) < 0)\n\t\treturn -1;\n\tif (iscsi_check_numerical_value(param, right_val_ptr) < 0)\n\t\treturn -1;\n\n\tleft_val = simple_strtoul(left_val_ptr, NULL, 0);\n\tright_val = simple_strtoul(right_val_ptr, NULL, 0);\n\t*tilde_ptr = '~';\n\n\tif (right_val < left_val) {\n\t\tpr_err(\"Numerical range for parameter \\\"%s\\\" contains\"\n\t\t\t\" a right value which is less than the left.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * For now,  enforce reasonable defaults for [I,O]FMarkInt.\n\t */\n\ttilde_ptr = strchr(param->value, '~');\n\tif (!tilde_ptr) {\n\t\tpr_err(\"Unable to locate numerical range indicator\"\n\t\t\t\" \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\treturn -1;\n\t}\n\t*tilde_ptr = '\\0';\n\n\tleft_val_ptr = param->value;\n\tright_val_ptr = param->value + strlen(left_val_ptr) + 1;\n\n\tlocal_left_val = simple_strtoul(left_val_ptr, NULL, 0);\n\t*tilde_ptr = '~';\n\n\tif (param->set_param) {\n\t\tif ((left_val < local_left_val) ||\n\t\t    (right_val < local_left_val)) {\n\t\t\tpr_err(\"Passed value range \\\"%u~%u\\\" is below\"\n\t\t\t\t\" minimum left value \\\"%u\\\" for key \\\"%s\\\",\"\n\t\t\t\t\" rejecting.\\n\", left_val, right_val,\n\t\t\t\tlocal_left_val, param->name);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif ((left_val < local_left_val) &&\n\t\t    (right_val < local_left_val)) {\n\t\t\tpr_err(\"Received value range \\\"%u~%u\\\" is\"\n\t\t\t\t\" below minimum left value \\\"%u\\\" for key\"\n\t\t\t\t\" \\\"%s\\\", rejecting.\\n\", left_val, right_val,\n\t\t\t\tlocal_left_val, param->name);\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t\tif (iscsi_update_param_value(param, REJECT) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_string_or_list_value(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_PROPOSER(param))\n\t\treturn 0;\n\n\tif (IS_TYPERANGE_AUTH_PARAM(param)) {\n\t\tif (strcmp(value, KRB5) && strcmp(value, SPKM1) &&\n\t\t    strcmp(value, SPKM2) && strcmp(value, SRP) &&\n\t\t    strcmp(value, CHAP) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\"\"\n\t\t\t\t\" or \\\"%s\\\".\\n\", param->name, KRB5,\n\t\t\t\t\tSPKM1, SPKM2, SRP, CHAP, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_DIGEST_PARAM(param)) {\n\t\tif (strcmp(value, CRC32C) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tCRC32C, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_SESSIONTYPE(param)) {\n\t\tif (strcmp(value, DISCOVERY) && strcmp(value, NORMAL)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tDISCOVERY, NORMAL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tThis function is used to pick a value range number,  currently just\n *\treturns the lesser of both right values.\n */\nstatic char *iscsi_get_value_from_number_range(\n\tstruct iscsi_param *param,\n\tchar *value)\n{\n\tchar *end_ptr, *tilde_ptr1 = NULL, *tilde_ptr2 = NULL;\n\tu32 acceptor_right_value, proposer_right_value;\n\n\ttilde_ptr1 = strchr(value, '~');\n\tif (!tilde_ptr1)\n\t\treturn NULL;\n\t*tilde_ptr1++ = '\\0';\n\tproposer_right_value = simple_strtoul(tilde_ptr1, &end_ptr, 0);\n\n\ttilde_ptr2 = strchr(param->value, '~');\n\tif (!tilde_ptr2)\n\t\treturn NULL;\n\t*tilde_ptr2++ = '\\0';\n\tacceptor_right_value = simple_strtoul(tilde_ptr2, &end_ptr, 0);\n\n\treturn (acceptor_right_value >= proposer_right_value) ?\n\t\ttilde_ptr1 : tilde_ptr2;\n}\n\nstatic char *iscsi_check_valuelist_for_support(\n\tstruct iscsi_param *param,\n\tchar *value)\n{\n\tchar *tmp1 = NULL, *tmp2 = NULL;\n\tchar *acceptor_values = NULL, *proposer_values = NULL;\n\n\tacceptor_values = param->value;\n\tproposer_values = value;\n\n\tdo {\n\t\tif (!proposer_values)\n\t\t\treturn NULL;\n\t\ttmp1 = strchr(proposer_values, ',');\n\t\tif (tmp1)\n\t\t\t*tmp1 = '\\0';\n\t\tacceptor_values = param->value;\n\t\tdo {\n\t\t\tif (!acceptor_values) {\n\t\t\t\tif (tmp1)\n\t\t\t\t\t*tmp1 = ',';\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp2 = strchr(acceptor_values, ',');\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2 = '\\0';\n\t\t\tif (!strcmp(acceptor_values, proposer_values)) {\n\t\t\t\tif (tmp2)\n\t\t\t\t\t*tmp2 = ',';\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2++ = ',';\n\n\t\t\tacceptor_values = tmp2;\n\t\t} while (acceptor_values);\n\t\tif (tmp1)\n\t\t\t*tmp1++ = ',';\n\t\tproposer_values = tmp1;\n\t} while (proposer_values);\n\nout:\n\treturn proposer_values;\n}\n\nstatic int iscsi_check_acceptor_state(struct iscsi_param *param, char *value,\n\t\t\t\tstruct iscsi_conn *conn)\n{\n\tu8 acceptor_boolean_value = 0, proposer_boolean_value = 0;\n\tchar *negoitated_value = NULL;\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_REJECT(param))\n\t\treturn 0;\n\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value && proposer_boolean_value)\n\t\t\tdo {} while (0);\n\t\telse {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value || proposer_boolean_value) {\n\t\t\tif (iscsi_update_param_value(param, YES) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tchar *tmpptr, buf[11];\n\t\tu32 acceptor_value = simple_strtoul(param->value, &tmpptr, 0);\n\t\tu32 proposer_value = simple_strtoul(value, &tmpptr, 0);\n\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) ||\n\t\t    !strcmp(param->name, MAXBURSTLENGTH) ||\n\t\t    !strcmp(param->name, FIRSTBURSTLENGTH) ||\n\t\t    !strcmp(param->name, MAXOUTSTANDINGR2T) ||\n\t\t    !strcmp(param->name, DEFAULTTIME2RETAIN) ||\n\t\t    !strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tif (proposer_value > acceptor_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tif (acceptor_value > proposer_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tstruct iscsi_param *param_mxdsl;\n\t\t\tunsigned long long tmp;\n\t\t\tint rc;\n\n\t\t\trc = strict_strtoull(param->value, 0, &tmp);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tconn->conn_ops->MaxRecvDataSegmentLength = tmp;\n\t\t\tpr_debug(\"Saving op->MaxRecvDataSegmentLength from\"\n\t\t\t\t\" original initiator received value: %u\\n\",\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength);\n\n\t\t\tparam_mxdsl = iscsi_find_param_from_key(\n\t\t\t\t\t\tMAXXMITDATASEGMENTLENGTH,\n\t\t\t\t\t\tconn->param_list);\n\t\t\tif (!param_mxdsl)\n\t\t\t\treturn -1;\n\n\t\t\trc = iscsi_update_param_value(param,\n\t\t\t\t\t\tparam_mxdsl->value);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tpr_debug(\"Updated %s to target MXDSL value: %s\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\n\t} else if (IS_TYPE_NUMBER_RANGE(param)) {\n\t\tnegoitated_value = iscsi_get_value_from_number_range(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value)\n\t\t\treturn -1;\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tnegoitated_value = iscsi_check_valuelist_for_support(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value) {\n\t\t\tpr_err(\"Proposer's value list \\\"%s\\\" contains\"\n\t\t\t\t\" no valid values from Acceptor's value list\"\n\t\t\t\t\" \\\"%s\\\".\\n\", value, param->value);\n\t\t\treturn -1;\n\t\t}\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_PHASE_DECLARATIVE(param)) {\n\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\treturn -1;\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_proposer_state(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_RESPONSE_GOT(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_TYPE_NUMBER_RANGE(param)) {\n\t\tu32 left_val = 0, right_val = 0, recieved_value = 0;\n\t\tchar *left_val_ptr = NULL, *right_val_ptr = NULL;\n\t\tchar *tilde_ptr = NULL;\n\n\t\tif (!strcmp(value, IRRELEVANT) || !strcmp(value, REJECT)) {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttilde_ptr = strchr(value, '~');\n\t\tif (tilde_ptr) {\n\t\t\tpr_err(\"Illegal \\\"~\\\" in response for \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\treturn -1;\n\t\t}\n\t\ttilde_ptr = strchr(param->value, '~');\n\t\tif (!tilde_ptr) {\n\t\t\tpr_err(\"Unable to locate numerical range\"\n\t\t\t\t\" indicator \\\"~\\\" for \\\"%s\\\".\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\t*tilde_ptr = '\\0';\n\n\t\tleft_val_ptr = param->value;\n\t\tright_val_ptr = param->value + strlen(left_val_ptr) + 1;\n\t\tleft_val = simple_strtoul(left_val_ptr, NULL, 0);\n\t\tright_val = simple_strtoul(right_val_ptr, NULL, 0);\n\t\trecieved_value = simple_strtoul(value, NULL, 0);\n\n\t\t*tilde_ptr = '~';\n\n\t\tif ((recieved_value < left_val) ||\n\t\t    (recieved_value > right_val)) {\n\t\t\tpr_err(\"Illegal response \\\"%s=%u\\\", value must\"\n\t\t\t\t\" be between %u and %u.\\n\", param->name,\n\t\t\t\trecieved_value, left_val, right_val);\n\t\t\treturn -1;\n\t\t}\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tchar *comma_ptr = NULL, *tmp_ptr = NULL;\n\n\t\tcomma_ptr = strchr(value, ',');\n\t\tif (comma_ptr) {\n\t\t\tpr_err(\"Illegal \\\",\\\" in response for \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp_ptr = iscsi_check_valuelist_for_support(param, value);\n\t\tif (!tmp_ptr)\n\t\t\treturn -1;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int iscsi_check_value(struct iscsi_param *param, char *value)\n{\n\tchar *comma_ptr = NULL;\n\n\tif (!strcmp(value, REJECT)) {\n\t\tif (!strcmp(param->name, IFMARKINT) ||\n\t\t    !strcmp(param->name, OFMARKINT)) {\n\t\t\t/*\n\t\t\t * Reject is not fatal for [I,O]FMarkInt,  and causes\n\t\t\t * [I,O]FMarker to be reset to No. (See iSCSI v20 A.3.2)\n\t\t\t */\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"Received %s=%s\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\tif (!strcmp(value, IRRELEVANT)) {\n\t\tpr_debug(\"Received %s=%s\\n\", param->name, value);\n\t\tSET_PSTATE_IRRELEVANT(param);\n\t\treturn 0;\n\t}\n\tif (!strcmp(value, NOTUNDERSTOOD)) {\n\t\tif (!IS_PSTATE_PROPOSER(param)) {\n\t\t\tpr_err(\"Received illegal offer %s=%s\\n\",\n\t\t\t\tparam->name, value);\n\t\t\treturn -1;\n\t\t}\n\n/* #warning FIXME: Add check for X-ExtensionKey here */\n\t\tpr_err(\"Standard iSCSI key \\\"%s\\\" cannot be answered\"\n\t\t\t\" with \\\"%s\\\", protocol error.\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tcomma_ptr = NULL;\n\t\tcomma_ptr = strchr(value, ',');\n\n\t\tif (comma_ptr && !IS_TYPE_VALUE_LIST(param)) {\n\t\t\tpr_err(\"Detected value separator \\\",\\\", but\"\n\t\t\t\t\" key \\\"%s\\\" does not allow a value list,\"\n\t\t\t\t\" protocol error.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr = '\\0';\n\n\t\tif (strlen(value) > VALUE_MAXLEN) {\n\t\t\tpr_err(\"Value for key \\\"%s\\\" exceeds %d,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t\tVALUE_MAXLEN);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (IS_TYPE_BOOL_AND(param) || IS_TYPE_BOOL_OR(param)) {\n\t\t\tif (iscsi_check_boolean_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_NUMBER(param)) {\n\t\t\tif (iscsi_check_numerical_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_NUMBER_RANGE(param)) {\n\t\t\tif (iscsi_check_numerical_range_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_STRING(param) || IS_TYPE_VALUE_LIST(param)) {\n\t\t\tif (iscsi_check_string_or_list_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tpr_err(\"Huh? 0x%02x\\n\", param->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr++ = ',';\n\n\t\tvalue = comma_ptr;\n\t} while (value);\n\n\treturn 0;\n}\n\nstatic struct iscsi_param *__iscsi_check_key(\n\tchar *key,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic struct iscsi_param *iscsi_check_key(\n\tchar *key,\n\tint phase,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\t/*\n\t * Key name length must not exceed 63 bytes. (See iSCSI v20 5.1)\n\t */\n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" received twice, protocol error.\\n\",\n\t\t\t\tkey);\n\t\treturn NULL;\n\t}\n\n\tif (!phase)\n\t\treturn param;\n\n\tif (!(param->phase & phase)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be negotiated during \",\n\t\t\t\tparam->name);\n\t\tswitch (phase) {\n\t\tcase PHASE_SECURITY:\n\t\t\tpr_debug(\"Security phase.\\n\");\n\t\t\tbreak;\n\t\tcase PHASE_OPERATIONAL:\n\t\t\tpr_debug(\"Operational phase.\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"Unknown phase.\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic int iscsi_enforce_integrity_rules(\n\tu8 phase,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tu8 DataSequenceInOrder = 0;\n\tu8 ErrorRecoveryLevel = 0, SessionType = 0;\n\tu8 IFMarker = 0, OFMarker = 0;\n\tu8 IFMarkInt_Reject = 1, OFMarkInt_Reject = 1;\n\tu32 FirstBurstLength = 0, MaxBurstLength = 0;\n\tstruct iscsi_param *param = NULL;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, SESSIONTYPE))\n\t\t\tif (!strcmp(param->value, NORMAL))\n\t\t\t\tSessionType = 1;\n\t\tif (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tErrorRecoveryLevel = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\tif (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tDataSequenceInOrder = 1;\n\t\tif (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tMaxBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\tif (!strcmp(param->name, IFMARKER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tIFMarker = 1;\n\t\tif (!strcmp(param->name, OFMARKER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tOFMarker = 1;\n\t\tif (!strcmp(param->name, IFMARKINT))\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tIFMarkInt_Reject = 1;\n\t\tif (!strcmp(param->name, OFMARKINT))\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tOFMarkInt_Reject = 1;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!SessionType && (!IS_PSTATE_ACCEPTOR(param) &&\n\t\t     (strcmp(param->name, IFMARKER) &&\n\t\t      strcmp(param->name, OFMARKER) &&\n\t\t      strcmp(param->name, IFMARKINT) &&\n\t\t      strcmp(param->name, OFMARKINT))))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, MAXOUTSTANDINGR2T) &&\n\t\t    DataSequenceInOrder && (ErrorRecoveryLevel > 0)) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) && !SessionType) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tFirstBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\t\tif (FirstBurstLength > MaxBurstLength) {\n\t\t\t\tchar tmpbuf[11];\n\t\t\t\tmemset(tmpbuf, 0, sizeof(tmpbuf));\n\t\t\t\tsprintf(tmpbuf, \"%u\", MaxBurstLength);\n\t\t\t\tif (iscsi_update_param_value(param, tmpbuf))\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, IFMARKER) && IFMarkInt_Reject) {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tIFMarker = 0;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, OFMARKER) && OFMarkInt_Reject) {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tOFMarker = 0;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\t param->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, IFMARKINT) && !IFMarker) {\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tcontinue;\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\t\tif (iscsi_update_param_value(param, IRRELEVANT) < 0)\n\t\t\t\treturn -1;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t\tif (!strcmp(param->name, OFMARKINT) && !OFMarker) {\n\t\t\tif (!strcmp(param->value, REJECT))\n\t\t\t\tcontinue;\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\t\tif (iscsi_update_param_value(param, IRRELEVANT) < 0)\n\t\t\t\treturn -1;\n\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}\n\nint iscsi_encode_text_output(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 *length,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *output_buf = NULL;\n\tstruct iscsi_extra_response *er;\n\tstruct iscsi_param *param;\n\n\toutput_buf = textbuf + *length;\n\n\tif (iscsi_enforce_integrity_rules(phase, param_list) < 0)\n\t\treturn -1;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->sender & sender))\n\t\t\tcontinue;\n\t\tif (IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_RESPONSE_SENT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_RESPONSE_SENT(param);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    !IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_PROPOSER(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_PROPOSER(param);\n\t\t\tiscsi_check_proposer_for_optional_reply(param);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t}\n\t}\n\n\tlist_for_each_entry(er, &param_list->extra_response_list, er_list) {\n\t\t*length += sprintf(output_buf, \"%s=%s\", er->key, er->value);\n\t\t*length += 1;\n\t\toutput_buf = textbuf + *length;\n\t\tpr_debug(\"Sending key: %s=%s\\n\", er->key, er->value);\n\t}\n\tiscsi_release_extra_responses(param_list);\n\n\treturn 0;\n}\n\nint iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\n{\n\tint ret = 0;\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    IS_PSTATE_PROPOSER(param) &&\n\t\t    !IS_PSTATE_RESPONSE_GOT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    !IS_PHASE_DECLARATIVE(param)) {\n\t\t\tpr_err(\"No response for proposed key \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint iscsi_change_param_value(\n\tchar *keyvalue,\n\tstruct iscsi_param_list *param_list,\n\tint check_key)\n{\n\tchar *key = NULL, *value = NULL;\n\tstruct iscsi_param *param;\n\tint sender = 0;\n\n\tif (iscsi_extract_key_value(keyvalue, &key, &value) < 0)\n\t\treturn -1;\n\n\tif (!check_key) {\n\t\tparam = __iscsi_check_key(keyvalue, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\t} else {\n\t\tparam = iscsi_check_key(keyvalue, 0, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\n\t\tparam->set_param = 1;\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tparam->set_param = 0;\n\t\t\treturn -1;\n\t\t}\n\t\tparam->set_param = 0;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid iscsi_set_connection_parameters(\n\tstruct iscsi_conn_ops *ops,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"---------------------------------------------------\"\n\t\t\t\"---------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\t/*\n\t\t * Special case to set MAXXMITDATASEGMENTLENGTH from the\n\t\t * target requested MaxRecvDataSegmentLength, even though\n\t\t * this key is not sent over the wire.\n\t\t */\n\t\tif (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tif (param_list->iser == true)\n\t\t\t\tcontinue;\n\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxXmitDataSegmentLength:     %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tpr_debug(\"AuthMethod:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tops->HeaderDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"HeaderDigest:                 %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tops->DataDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"DataDigest:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\t/*\n\t\t\t * At this point iscsi_check_acceptor_state() will have\n\t\t\t * set ops->MaxRecvDataSegmentLength from the original\n\t\t\t * initiator provided value.\n\t\t\t */\n\t\t\tpr_debug(\"MaxRecvDataSegmentLength:     %u\\n\",\n\t\t\t\tops->MaxRecvDataSegmentLength);\n\t\t} else if (!strcmp(param->name, OFMARKER)) {\n\t\t\tops->OFMarker = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"OFMarker:                     %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IFMARKER)) {\n\t\t\tops->IFMarker = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"IFMarker:                     %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, OFMARKINT)) {\n\t\t\tops->OFMarkInt =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"OFMarkInt:                    %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IFMARKINT)) {\n\t\t\tops->IFMarkInt =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"IFMarkInt:                    %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tops->InitiatorRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"InitiatorRecvDataSegmentLength: %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxRecvDataSegmentLength =\n\t\t\t\t\tops->InitiatorRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MRDSL from InitiatorRecvDataSegmentLength\\n\");\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tops->TargetRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetRecvDataSegmentLength:  %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\t\tops->TargetRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MXDSL from TargetRecvDataSegmentLength\\n\");\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n}\n\nvoid iscsi_set_session_parameters(\n\tstruct iscsi_sess_ops *ops,\n\tstruct iscsi_param_list *param_list,\n\tint leading)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->InitiatorName,\n\t\t\t\t\t\tsizeof(ops->InitiatorName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorName:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->InitiatorAlias,\n\t\t\t\t\t\tsizeof(ops->InitiatorAlias),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorAlias:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->TargetName,\n\t\t\t\t\t\tsizeof(ops->TargetName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetName:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->TargetAlias, sizeof(ops->TargetAlias),\n\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetAlias:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tops->TargetPortalGroupTag =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetPortalGroupTag:         %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tops->MaxConnections =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxConnections:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tops->InitialR2T = !strcmp(param->value, YES);\n\t\t\t pr_debug(\"InitialR2T:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tops->ImmediateData = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"ImmediateData:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tops->MaxBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxBurstLength:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tops->FirstBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"FirstBurstLength:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tops->DefaultTime2Wait =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Wait:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tops->DefaultTime2Retain =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Retain:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tops->MaxOutstandingR2T =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxOutstandingR2T:            %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tops->DataPDUInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataPDUInOrder:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tops->DataSequenceInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataSequenceInOrder:          %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tops->ErrorRecoveryLevel =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"ErrorRecoveryLevel:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tops->SessionType = !strcmp(param->value, DISCOVERY);\n\t\t\tpr_debug(\"SessionType:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tops->RDMAExtensions = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"RDMAExtensions:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\n}\n", "#ifndef ISCSI_PARAMETERS_H\n#define ISCSI_PARAMETERS_H\n\n#include <scsi/iscsi_proto.h>\n\nstruct iscsi_extra_response {\n\tchar key[KEY_MAXLEN];\n\tchar value[32];\n\tstruct list_head er_list;\n} ____cacheline_aligned;\n\nstruct iscsi_param {\n\tchar *name;\n\tchar *value;\n\tu8 set_param;\n\tu8 phase;\n\tu8 scope;\n\tu8 sender;\n\tu8 type;\n\tu8 use;\n\tu16 type_range;\n\tu32 state;\n\tstruct list_head p_list;\n} ____cacheline_aligned;\n\nextern int iscsi_login_rx_data(struct iscsi_conn *, char *, int);\nextern int iscsi_login_tx_data(struct iscsi_conn *, char *, char *, int);\nextern void iscsi_dump_conn_ops(struct iscsi_conn_ops *);\nextern void iscsi_dump_sess_ops(struct iscsi_sess_ops *);\nextern void iscsi_print_params(struct iscsi_param_list *);\nextern int iscsi_create_default_params(struct iscsi_param_list **);\nextern int iscsi_set_keys_to_negotiate(struct iscsi_param_list *, bool);\nextern int iscsi_set_keys_irrelevant_for_discovery(struct iscsi_param_list *);\nextern int iscsi_copy_param_list(struct iscsi_param_list **,\n\t\t\tstruct iscsi_param_list *, int);\nextern int iscsi_change_param_value(char *, struct iscsi_param_list *, int);\nextern void iscsi_release_param_list(struct iscsi_param_list *);\nextern struct iscsi_param *iscsi_find_param_from_key(char *, struct iscsi_param_list *);\nextern int iscsi_extract_key_value(char *, char **, char **);\nextern int iscsi_update_param_value(struct iscsi_param *, char *);\nextern int iscsi_decode_text_input(u8, u8, char *, u32, struct iscsi_conn *);\nextern int iscsi_encode_text_output(u8, u8, char *, u32 *,\n\t\t\tstruct iscsi_param_list *);\nextern int iscsi_check_negotiated_keys(struct iscsi_param_list *);\nextern void iscsi_set_connection_parameters(struct iscsi_conn_ops *,\n\t\t\tstruct iscsi_param_list *);\nextern void iscsi_set_session_parameters(struct iscsi_sess_ops *,\n\t\t\tstruct iscsi_param_list *, int);\n\n#define YES\t\t\t\t\"Yes\"\n#define NO\t\t\t\t\"No\"\n#define ALL\t\t\t\t\"All\"\n#define IRRELEVANT\t\t\t\"Irrelevant\"\n#define NONE\t\t\t\t\"None\"\n#define NOTUNDERSTOOD\t\t\t\"NotUnderstood\"\n#define REJECT\t\t\t\t\"Reject\"\n\n/*\n * The Parameter Names.\n */\n#define AUTHMETHOD\t\t\t\"AuthMethod\"\n#define HEADERDIGEST\t\t\t\"HeaderDigest\"\n#define DATADIGEST\t\t\t\"DataDigest\"\n#define MAXCONNECTIONS\t\t\t\"MaxConnections\"\n#define SENDTARGETS\t\t\t\"SendTargets\"\n#define TARGETNAME\t\t\t\"TargetName\"\n#define INITIATORNAME\t\t\t\"InitiatorName\"\n#define TARGETALIAS\t\t\t\"TargetAlias\"\n#define INITIATORALIAS\t\t\t\"InitiatorAlias\"\n#define TARGETADDRESS\t\t\t\"TargetAddress\"\n#define TARGETPORTALGROUPTAG\t\t\"TargetPortalGroupTag\"\n#define INITIALR2T\t\t\t\"InitialR2T\"\n#define IMMEDIATEDATA\t\t\t\"ImmediateData\"\n#define MAXRECVDATASEGMENTLENGTH\t\"MaxRecvDataSegmentLength\"\n#define MAXXMITDATASEGMENTLENGTH\t\"MaxXmitDataSegmentLength\"\n#define MAXBURSTLENGTH\t\t\t\"MaxBurstLength\"\n#define FIRSTBURSTLENGTH\t\t\"FirstBurstLength\"\n#define DEFAULTTIME2WAIT\t\t\"DefaultTime2Wait\"\n#define DEFAULTTIME2RETAIN\t\t\"DefaultTime2Retain\"\n#define MAXOUTSTANDINGR2T\t\t\"MaxOutstandingR2T\"\n#define DATAPDUINORDER\t\t\t\"DataPDUInOrder\"\n#define DATASEQUENCEINORDER\t\t\"DataSequenceInOrder\"\n#define ERRORRECOVERYLEVEL\t\t\"ErrorRecoveryLevel\"\n#define SESSIONTYPE\t\t\t\"SessionType\"\n#define IFMARKER\t\t\t\"IFMarker\"\n#define OFMARKER\t\t\t\"OFMarker\"\n#define IFMARKINT\t\t\t\"IFMarkInt\"\n#define OFMARKINT\t\t\t\"OFMarkInt\"\n#define X_EXTENSIONKEY\t\t\t\"X-com.sbei.version\"\n#define X_EXTENSIONKEY_CISCO_NEW\t\"X-com.cisco.protocol\"\n#define X_EXTENSIONKEY_CISCO_OLD\t\"X-com.cisco.iscsi.draft\"\n\n/*\n * Parameter names of iSCSI Extentions for RDMA (iSER).  See RFC-5046\n */\n#define RDMAEXTENSIONS\t\t\t\"RDMAExtensions\"\n#define INITIATORRECVDATASEGMENTLENGTH\t\"InitiatorRecvDataSegmentLength\"\n#define TARGETRECVDATASEGMENTLENGTH\t\"TargetRecvDataSegmentLength\"\n\n/*\n * For AuthMethod.\n */\n#define KRB5\t\t\t\t\"KRB5\"\n#define SPKM1\t\t\t\t\"SPKM1\"\n#define SPKM2\t\t\t\t\"SPKM2\"\n#define SRP\t\t\t\t\"SRP\"\n#define CHAP\t\t\t\t\"CHAP\"\n\n/*\n * Initial values for Parameter Negotiation.\n */\n#define INITIAL_AUTHMETHOD\t\t\tCHAP\n#define INITIAL_HEADERDIGEST\t\t\t\"CRC32C,None\"\n#define INITIAL_DATADIGEST\t\t\t\"CRC32C,None\"\n#define INITIAL_MAXCONNECTIONS\t\t\t\"1\"\n#define INITIAL_SENDTARGETS\t\t\tALL\n#define INITIAL_TARGETNAME\t\t\t\"LIO.Target\"\n#define INITIAL_INITIATORNAME\t\t\t\"LIO.Initiator\"\n#define INITIAL_TARGETALIAS\t\t\t\"LIO Target\"\n#define INITIAL_INITIATORALIAS\t\t\t\"LIO Initiator\"\n#define INITIAL_TARGETADDRESS\t\t\t\"0.0.0.0:0000,0\"\n#define INITIAL_TARGETPORTALGROUPTAG\t\t\"1\"\n#define INITIAL_INITIALR2T\t\t\tYES\n#define INITIAL_IMMEDIATEDATA\t\t\tYES\n#define INITIAL_MAXRECVDATASEGMENTLENGTH\t\"8192\"\n/*\n * Match outgoing MXDSL default to incoming Open-iSCSI default\n */\n#define INITIAL_MAXXMITDATASEGMENTLENGTH\t\"262144\"\n#define INITIAL_MAXBURSTLENGTH\t\t\t\"262144\"\n#define INITIAL_FIRSTBURSTLENGTH\t\t\"65536\"\n#define INITIAL_DEFAULTTIME2WAIT\t\t\"2\"\n#define INITIAL_DEFAULTTIME2RETAIN\t\t\"20\"\n#define INITIAL_MAXOUTSTANDINGR2T\t\t\"1\"\n#define INITIAL_DATAPDUINORDER\t\t\tYES\n#define INITIAL_DATASEQUENCEINORDER\t\tYES\n#define INITIAL_ERRORRECOVERYLEVEL\t\t\"0\"\n#define INITIAL_SESSIONTYPE\t\t\tNORMAL\n#define INITIAL_IFMARKER\t\t\tNO\n#define INITIAL_OFMARKER\t\t\tNO\n#define INITIAL_IFMARKINT\t\t\t\"2048~65535\"\n#define INITIAL_OFMARKINT\t\t\t\"2048~65535\"\n\n/*\n * Initial values for iSER parameters following RFC-5046 Section 6\n */\n#define INITIAL_RDMAEXTENSIONS\t\t\tNO\n#define INITIAL_INITIATORRECVDATASEGMENTLENGTH\t\"262144\"\n#define INITIAL_TARGETRECVDATASEGMENTLENGTH\t\"8192\"\n\n/*\n * For [Header,Data]Digests.\n */\n#define CRC32C\t\t\t\t\"CRC32C\"\n\n/*\n * For SessionType.\n */\n#define DISCOVERY\t\t\t\"Discovery\"\n#define NORMAL\t\t\t\t\"Normal\"\n\n/*\n * struct iscsi_param->use\n */\n#define USE_LEADING_ONLY\t\t0x01\n#define USE_INITIAL_ONLY\t\t0x02\n#define USE_ALL\t\t\t\t0x04\n\n#define IS_USE_LEADING_ONLY(p)\t\t((p)->use & USE_LEADING_ONLY)\n#define IS_USE_INITIAL_ONLY(p)\t\t((p)->use & USE_INITIAL_ONLY)\n#define IS_USE_ALL(p)\t\t\t((p)->use & USE_ALL)\n\n#define SET_USE_INITIAL_ONLY(p)\t\t((p)->use |= USE_INITIAL_ONLY)\n\n/*\n * struct iscsi_param->sender\n */\n#define\tSENDER_INITIATOR\t\t0x01\n#define SENDER_TARGET\t\t\t0x02\n#define SENDER_BOTH\t\t\t0x03\n/* Used in iscsi_check_key() */\n#define SENDER_RECEIVER\t\t\t0x04\n\n#define IS_SENDER_INITIATOR(p)\t\t((p)->sender & SENDER_INITIATOR)\n#define IS_SENDER_TARGET(p)\t\t((p)->sender & SENDER_TARGET)\n#define IS_SENDER_BOTH(p)\t\t((p)->sender & SENDER_BOTH)\n\n/*\n * struct iscsi_param->scope\n */\n#define SCOPE_CONNECTION_ONLY\t\t0x01\n#define SCOPE_SESSION_WIDE\t\t0x02\n\n#define IS_SCOPE_CONNECTION_ONLY(p)\t((p)->scope & SCOPE_CONNECTION_ONLY)\n#define IS_SCOPE_SESSION_WIDE(p)\t((p)->scope & SCOPE_SESSION_WIDE)\n\n/*\n * struct iscsi_param->phase\n */\n#define PHASE_SECURITY\t\t\t0x01\n#define PHASE_OPERATIONAL\t\t0x02\n#define PHASE_DECLARATIVE\t\t0x04\n#define PHASE_FFP0\t\t\t0x08\n\n#define IS_PHASE_SECURITY(p)\t\t((p)->phase & PHASE_SECURITY)\n#define IS_PHASE_OPERATIONAL(p)\t\t((p)->phase & PHASE_OPERATIONAL)\n#define IS_PHASE_DECLARATIVE(p)\t\t((p)->phase & PHASE_DECLARATIVE)\n#define IS_PHASE_FFP0(p)\t\t((p)->phase & PHASE_FFP0)\n\n/*\n * struct iscsi_param->type\n */\n#define TYPE_BOOL_AND\t\t\t0x01\n#define TYPE_BOOL_OR\t\t\t0x02\n#define TYPE_NUMBER\t\t\t0x04\n#define TYPE_NUMBER_RANGE\t\t0x08\n#define TYPE_STRING\t\t\t0x10\n#define TYPE_VALUE_LIST\t\t\t0x20\n\n#define IS_TYPE_BOOL_AND(p)\t\t((p)->type & TYPE_BOOL_AND)\n#define IS_TYPE_BOOL_OR(p)\t\t((p)->type & TYPE_BOOL_OR)\n#define IS_TYPE_NUMBER(p)\t\t((p)->type & TYPE_NUMBER)\n#define IS_TYPE_NUMBER_RANGE(p)\t\t((p)->type & TYPE_NUMBER_RANGE)\n#define IS_TYPE_STRING(p)\t\t((p)->type & TYPE_STRING)\n#define IS_TYPE_VALUE_LIST(p)\t\t((p)->type & TYPE_VALUE_LIST)\n\n/*\n * struct iscsi_param->type_range\n */\n#define TYPERANGE_BOOL_AND\t\t0x0001\n#define TYPERANGE_BOOL_OR\t\t0x0002\n#define TYPERANGE_0_TO_2\t\t0x0004\n#define TYPERANGE_0_TO_3600\t\t0x0008\n#define TYPERANGE_0_TO_32767\t\t0x0010\n#define TYPERANGE_0_TO_65535\t\t0x0020\n#define TYPERANGE_1_TO_65535\t\t0x0040\n#define TYPERANGE_2_TO_3600\t\t0x0080\n#define TYPERANGE_512_TO_16777215\t0x0100\n#define TYPERANGE_AUTH\t\t\t0x0200\n#define TYPERANGE_DIGEST\t\t0x0400\n#define TYPERANGE_ISCSINAME\t\t0x0800\n#define TYPERANGE_MARKINT\t\t0x1000\n#define TYPERANGE_SESSIONTYPE\t\t0x2000\n#define TYPERANGE_TARGETADDRESS\t\t0x4000\n#define TYPERANGE_UTF8\t\t\t0x8000\n\n#define IS_TYPERANGE_0_TO_2(p)\t\t((p)->type_range & TYPERANGE_0_TO_2)\n#define IS_TYPERANGE_0_TO_3600(p)\t((p)->type_range & TYPERANGE_0_TO_3600)\n#define IS_TYPERANGE_0_TO_32767(p)\t((p)->type_range & TYPERANGE_0_TO_32767)\n#define IS_TYPERANGE_0_TO_65535(p)\t((p)->type_range & TYPERANGE_0_TO_65535)\n#define IS_TYPERANGE_1_TO_65535(p)\t((p)->type_range & TYPERANGE_1_TO_65535)\n#define IS_TYPERANGE_2_TO_3600(p)\t((p)->type_range & TYPERANGE_2_TO_3600)\n#define IS_TYPERANGE_512_TO_16777215(p)\t((p)->type_range & \\\n\t\t\t\t\t\tTYPERANGE_512_TO_16777215)\n#define IS_TYPERANGE_AUTH_PARAM(p)\t((p)->type_range & TYPERANGE_AUTH)\n#define IS_TYPERANGE_DIGEST_PARAM(p)\t((p)->type_range & TYPERANGE_DIGEST)\n#define IS_TYPERANGE_SESSIONTYPE(p)\t((p)->type_range & \\\n\t\t\t\t\t\tTYPERANGE_SESSIONTYPE)\n\n/*\n * struct iscsi_param->state\n */\n#define PSTATE_ACCEPTOR\t\t\t0x01\n#define PSTATE_NEGOTIATE\t\t0x02\n#define PSTATE_PROPOSER\t\t\t0x04\n#define PSTATE_IRRELEVANT\t\t0x08\n#define PSTATE_REJECT\t\t\t0x10\n#define PSTATE_REPLY_OPTIONAL\t\t0x20\n#define PSTATE_RESPONSE_GOT\t\t0x40\n#define PSTATE_RESPONSE_SENT\t\t0x80\n\n#define IS_PSTATE_ACCEPTOR(p)\t\t((p)->state & PSTATE_ACCEPTOR)\n#define IS_PSTATE_NEGOTIATE(p)\t\t((p)->state & PSTATE_NEGOTIATE)\n#define IS_PSTATE_PROPOSER(p)\t\t((p)->state & PSTATE_PROPOSER)\n#define IS_PSTATE_IRRELEVANT(p)\t\t((p)->state & PSTATE_IRRELEVANT)\n#define IS_PSTATE_REJECT(p)\t\t((p)->state & PSTATE_REJECT)\n#define IS_PSTATE_REPLY_OPTIONAL(p)\t((p)->state & PSTATE_REPLY_OPTIONAL)\n#define IS_PSTATE_RESPONSE_GOT(p)\t((p)->state & PSTATE_RESPONSE_GOT)\n#define IS_PSTATE_RESPONSE_SENT(p)\t((p)->state & PSTATE_RESPONSE_SENT)\n\n#define SET_PSTATE_ACCEPTOR(p)\t\t((p)->state |= PSTATE_ACCEPTOR)\n#define SET_PSTATE_NEGOTIATE(p)\t\t((p)->state |= PSTATE_NEGOTIATE)\n#define SET_PSTATE_PROPOSER(p)\t\t((p)->state |= PSTATE_PROPOSER)\n#define SET_PSTATE_IRRELEVANT(p)\t((p)->state |= PSTATE_IRRELEVANT)\n#define SET_PSTATE_REJECT(p)\t\t((p)->state |= PSTATE_REJECT)\n#define SET_PSTATE_REPLY_OPTIONAL(p)\t((p)->state |= PSTATE_REPLY_OPTIONAL)\n#define SET_PSTATE_RESPONSE_GOT(p)\t((p)->state |= PSTATE_RESPONSE_GOT)\n#define SET_PSTATE_RESPONSE_SENT(p)\t((p)->state |= PSTATE_RESPONSE_SENT)\n\n#endif /* ISCSI_PARAMETERS_H */\n"], "filenames": ["drivers/target/iscsi/iscsi_target_parameters.c", "drivers/target/iscsi/iscsi_target_parameters.h"], "buggy_code_start_loc": [761, 3], "buggy_code_end_loc": [1634, 6], "fixing_code_start_loc": [761, 4], "fixing_code_end_loc": [1631, 8], "type": "CWE-119", "message": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.", "other": {"cve": {"id": "CVE-2013-2850", "sourceIdentifier": "cve-coordination@google.com", "published": "2013-06-07T14:03:19.923", "lastModified": "2023-01-19T15:48:46.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en la funci\u00f3n iscsi_add_notunderstood_response en drivers/target/iscsi/iscsi_target_parameters.c en el subsistema de destino iSCSI en Linux kernel hasta v3.9.4 lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria y OOPS) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de una clave larga que no se maneja adecuadamente durante construcci\u00f3n de un paquete de respuesta de error."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.9}, "baseSeverity": "HIGH", "exploitabilityScore": 5.5, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.2.47", "matchCriteriaId": "5AEE466E-A19C-43FB-8D75-B2F16C7303D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.4.48", "matchCriteriaId": "BC140BA9-045E-4FF9-B307-4A190213C746"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5", "versionEndExcluding": "3.9.5", "matchCriteriaId": "6BFF5824-218F-4974-BE73-BC9768A88FF1"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=cea4dcfdad926a27a18e188720efe0f2c9403456", "source": "cve-coordination@google.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-05/msg00017.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00011.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00017.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00018.html", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/06/01/2", "source": "cve-coordination@google.com", "tags": ["Mailing List"]}, {"url": "http://www.ubuntu.com/usn/USN-1844-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1845-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1846-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1847-1", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=968036", "source": "cve-coordination@google.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456", "source": "cve-coordination@google.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456"}}