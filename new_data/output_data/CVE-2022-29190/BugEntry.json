{"buggy_code": ["package dtls\n\nimport (\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/handshake\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/recordlayer\"\n)\n\ntype fragment struct {\n\trecordLayerHeader recordlayer.Header\n\thandshakeHeader   handshake.Header\n\tdata              []byte\n}\n\ntype fragmentBuffer struct {\n\t// map of MessageSequenceNumbers that hold slices of fragments\n\tcache map[uint16][]*fragment\n\n\tcurrentMessageSequenceNumber uint16\n}\n\nfunc newFragmentBuffer() *fragmentBuffer {\n\treturn &fragmentBuffer{cache: map[uint16][]*fragment{}}\n}\n\n// Attempts to push a DTLS packet to the fragmentBuffer\n// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled\n// when an error returns it is fatal, and the DTLS connection should be stopped\nfunc (f *fragmentBuffer) push(buf []byte) (bool, error) {\n\tfrag := new(fragment)\n\tif err := frag.recordLayerHeader.Unmarshal(buf); err != nil {\n\t\treturn false, err\n\t}\n\n\t// fragment isn't a handshake, we don't need to handle it\n\tif frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {\n\t\treturn false, nil\n\t}\n\n\tfor buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {\n\t\tif err := frag.handshakeHeader.Unmarshal(buf); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {\n\t\t\tf.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}\n\t\t}\n\n\t\t// end index should be the length of handshake header but if the handshake\n\t\t// was fragmented, we should keep them all\n\t\tend := int(handshake.HeaderLength + frag.handshakeHeader.Length)\n\t\tif size := len(buf); end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Discard all headers, when rebuilding the packet we will re-build\n\t\tfrag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)\n\t\tf.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)\n\t\tbuf = buf[end:]\n\t}\n\n\treturn true, nil\n}\n\nfunc (f *fragmentBuffer) pop() (content []byte, epoch uint16) {\n\tfrags, ok := f.cache[f.currentMessageSequenceNumber]\n\tif !ok {\n\t\treturn nil, 0\n\t}\n\n\t// Go doesn't support recursive lambdas\n\tvar appendMessage func(targetOffset uint32) bool\n\n\trawMessage := []byte{}\n\tappendMessage = func(targetOffset uint32) bool {\n\t\tfor _, f := range frags {\n\t\t\tif f.handshakeHeader.FragmentOffset == targetOffset {\n\t\t\t\tfragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)\n\t\t\t\tif fragmentEnd != f.handshakeHeader.Length {\n\t\t\t\t\tif !appendMessage(fragmentEnd) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trawMessage = append(f.data, rawMessage...)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Recursively collect up\n\tif !appendMessage(0) {\n\t\treturn nil, 0\n\t}\n\n\tfirstHeader := frags[0].handshakeHeader\n\tfirstHeader.FragmentOffset = 0\n\tfirstHeader.FragmentLength = firstHeader.Length\n\n\trawHeader, err := firstHeader.Marshal()\n\tif err != nil {\n\t\treturn nil, 0\n\t}\n\n\tmessageEpoch := frags[0].recordLayerHeader.Epoch\n\n\tdelete(f.cache, f.currentMessageSequenceNumber)\n\tf.currentMessageSequenceNumber++\n\treturn append(rawHeader, rawMessage...), messageEpoch\n}\n", "package dtls\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFragmentBuffer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tName     string\n\t\tIn       [][]byte\n\t\tExpected [][]byte\n\t\tEpoch    uint16\n\t}{\n\t\t{\n\t\t\tName: \"Single Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Single Fragment Epoch 3\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 3,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Unordered Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Handshakes in Signle Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t} {\n\t\tfragmentBuffer := newFragmentBuffer()\n\t\tfor _, frag := range test.In {\n\t\t\tstatus, err := fragmentBuffer.push(frag)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if !status {\n\t\t\t\tt.Errorf(\"fragmentBuffer didn't accept fragments for '%s'\", test.Name)\n\t\t\t}\n\t\t}\n\n\t\tfor _, expected := range test.Expected {\n\t\t\tout, epoch := fragmentBuffer.pop()\n\t\t\tif !reflect.DeepEqual(out, expected) {\n\t\t\t\tt.Errorf(\"fragmentBuffer '%s' push/pop: got % 02x, want % 02x\", test.Name, out, expected)\n\t\t\t}\n\t\t\tif epoch != test.Epoch {\n\t\t\t\tt.Errorf(\"fragmentBuffer returned wrong epoch: got %d, want %d\", epoch, test.Epoch)\n\t\t\t}\n\t\t}\n\n\t\tif frag, _ := fragmentBuffer.pop(); frag != nil {\n\t\t\tt.Errorf(\"fragmentBuffer popped single buffer multiple times for '%s'\", test.Name)\n\t\t}\n\t}\n}\n"], "fixing_code": ["package dtls\n\nimport (\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/handshake\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/recordlayer\"\n)\n\ntype fragment struct {\n\trecordLayerHeader recordlayer.Header\n\thandshakeHeader   handshake.Header\n\tdata              []byte\n}\n\ntype fragmentBuffer struct {\n\t// map of MessageSequenceNumbers that hold slices of fragments\n\tcache map[uint16][]*fragment\n\n\tcurrentMessageSequenceNumber uint16\n}\n\nfunc newFragmentBuffer() *fragmentBuffer {\n\treturn &fragmentBuffer{cache: map[uint16][]*fragment{}}\n}\n\n// Attempts to push a DTLS packet to the fragmentBuffer\n// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled\n// when an error returns it is fatal, and the DTLS connection should be stopped\nfunc (f *fragmentBuffer) push(buf []byte) (bool, error) {\n\tfrag := new(fragment)\n\tif err := frag.recordLayerHeader.Unmarshal(buf); err != nil {\n\t\treturn false, err\n\t}\n\n\t// fragment isn't a handshake, we don't need to handle it\n\tif frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {\n\t\treturn false, nil\n\t}\n\n\tfor buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {\n\t\tif err := frag.handshakeHeader.Unmarshal(buf); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {\n\t\t\tf.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}\n\t\t}\n\n\t\t// end index should be the length of handshake header but if the handshake\n\t\t// was fragmented, we should keep them all\n\t\tend := int(handshake.HeaderLength + frag.handshakeHeader.Length)\n\t\tif size := len(buf); end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Discard all headers, when rebuilding the packet we will re-build\n\t\tfrag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)\n\t\tf.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)\n\t\tbuf = buf[end:]\n\t}\n\n\treturn true, nil\n}\n\nfunc (f *fragmentBuffer) pop() (content []byte, epoch uint16) {\n\tfrags, ok := f.cache[f.currentMessageSequenceNumber]\n\tif !ok {\n\t\treturn nil, 0\n\t}\n\n\t// Go doesn't support recursive lambdas\n\tvar appendMessage func(targetOffset uint32) bool\n\n\trawMessage := []byte{}\n\tappendMessage = func(targetOffset uint32) bool {\n\t\tfor _, f := range frags {\n\t\t\tif f.handshakeHeader.FragmentOffset == targetOffset {\n\t\t\t\tfragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)\n\t\t\t\tif fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {\n\t\t\t\t\tif !appendMessage(fragmentEnd) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trawMessage = append(f.data, rawMessage...)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Recursively collect up\n\tif !appendMessage(0) {\n\t\treturn nil, 0\n\t}\n\n\tfirstHeader := frags[0].handshakeHeader\n\tfirstHeader.FragmentOffset = 0\n\tfirstHeader.FragmentLength = firstHeader.Length\n\n\trawHeader, err := firstHeader.Marshal()\n\tif err != nil {\n\t\treturn nil, 0\n\t}\n\n\tmessageEpoch := frags[0].recordLayerHeader.Epoch\n\n\tdelete(f.cache, f.currentMessageSequenceNumber)\n\tf.currentMessageSequenceNumber++\n\treturn append(rawHeader, rawMessage...), messageEpoch\n}\n", "package dtls\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFragmentBuffer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tName     string\n\t\tIn       [][]byte\n\t\tExpected [][]byte\n\t\tEpoch    uint16\n\t}{\n\t\t{\n\t\t\tName: \"Single Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Single Fragment Epoch 3\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 3,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Unordered Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Handshakes in Signle Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop\n\t\t{\n\t\t\tName: \"Zero Length Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t} {\n\t\tfragmentBuffer := newFragmentBuffer()\n\t\tfor _, frag := range test.In {\n\t\t\tstatus, err := fragmentBuffer.push(frag)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if !status {\n\t\t\t\tt.Errorf(\"fragmentBuffer didn't accept fragments for '%s'\", test.Name)\n\t\t\t}\n\t\t}\n\n\t\tfor _, expected := range test.Expected {\n\t\t\tout, epoch := fragmentBuffer.pop()\n\t\t\tif !reflect.DeepEqual(out, expected) {\n\t\t\t\tt.Errorf(\"fragmentBuffer '%s' push/pop: got % 02x, want % 02x\", test.Name, out, expected)\n\t\t\t}\n\t\t\tif epoch != test.Epoch {\n\t\t\t\tt.Errorf(\"fragmentBuffer returned wrong epoch: got %d, want %d\", epoch, test.Epoch)\n\t\t\t}\n\t\t}\n\n\t\tif frag, _ := fragmentBuffer.pop(); frag != nil {\n\t\t\tt.Errorf(\"fragmentBuffer popped single buffer multiple times for '%s'\", test.Name)\n\t\t}\n\t}\n}\n"], "filenames": ["fragment_buffer.go", "fragment_buffer_test.go"], "buggy_code_start_loc": [79, 75], "buggy_code_end_loc": [80, 75], "fixing_code_start_loc": [79, 76], "fixing_code_end_loc": [80, 90], "type": "CWE-835", "message": "Pion DTLS is a Go implementation of Datagram Transport Layer Security. Prior to version 2.1.4, an attacker can send packets that sends Pion DTLS into an infinite loop when processing. Version 2.1.4 contains a patch for this issue. There are currently no known workarounds available.", "other": {"cve": {"id": "CVE-2022-29190", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-21T00:15:11.450", "lastModified": "2022-06-02T18:21:31.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pion DTLS is a Go implementation of Datagram Transport Layer Security. Prior to version 2.1.4, an attacker can send packets that sends Pion DTLS into an infinite loop when processing. Version 2.1.4 contains a patch for this issue. There are currently no known workarounds available."}, {"lang": "es", "value": "Pion DTLS es una implementaci\u00f3n de Go de Datagram Transport Layer Security. En versiones anteriores a 2.1.4, un atacante puede enviar paquetes que env\u00eden a Pion DTLS a un bucle infinito cuando los procesa. La versi\u00f3n 2.1.4 contiene un parche para este problema. Actualmente no se presentan mitigaciones conocidas disponibles"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pion:dtls:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "465946B5-0540-41EB-91CB-571B2E842EB4"}]}]}], "references": [{"url": "https://github.com/pion/dtls/commit/e0b2ce3592e8e7d73713ac67b363a2e192a4cecf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pion/dtls/releases/tag/v2.1.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pion/dtls/security/advisories/GHSA-cm8f-h6j3-p25c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pion/dtls/commit/e0b2ce3592e8e7d73713ac67b363a2e192a4cecf"}}