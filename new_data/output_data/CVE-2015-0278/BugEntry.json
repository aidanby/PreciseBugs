{"buggy_code": ["/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <errno.h>\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <poll.h>\n\n#if defined(__APPLE__) && !TARGET_OS_IPHONE\n# include <crt_externs.h>\n# define environ (*_NSGetEnviron())\n#else\nextern char **environ;\n#endif\n\n\nstatic QUEUE* uv__process_queue(uv_loop_t* loop, int pid) {\n  assert(pid > 0);\n  return loop->process_handles + pid % ARRAY_SIZE(loop->process_handles);\n}\n\n\nstatic void uv__chld(uv_signal_t* handle, int signum) {\n  uv_process_t* process;\n  uv_loop_t* loop;\n  int exit_status;\n  int term_signal;\n  unsigned int i;\n  int status;\n  pid_t pid;\n  QUEUE pending;\n  QUEUE* h;\n  QUEUE* q;\n\n  assert(signum == SIGCHLD);\n\n  QUEUE_INIT(&pending);\n  loop = handle->loop;\n\n  for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++) {\n    h = loop->process_handles + i;\n    q = QUEUE_HEAD(h);\n\n    while (q != h) {\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      q = QUEUE_NEXT(q);\n\n      do\n        pid = waitpid(process->pid, &status, WNOHANG);\n      while (pid == -1 && errno == EINTR);\n\n      if (pid == 0)\n        continue;\n\n      if (pid == -1) {\n        if (errno != ECHILD)\n          abort();\n        continue;\n      }\n\n      process->status = status;\n      QUEUE_REMOVE(&process->queue);\n      QUEUE_INSERT_TAIL(&pending, &process->queue);\n    }\n\n    while (!QUEUE_EMPTY(&pending)) {\n      q = QUEUE_HEAD(&pending);\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);\n\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      uv__handle_stop(process);\n\n      if (process->exit_cb == NULL)\n        continue;\n\n      exit_status = 0;\n      if (WIFEXITED(process->status))\n        exit_status = WEXITSTATUS(process->status);\n\n      term_signal = 0;\n      if (WIFSIGNALED(process->status))\n        term_signal = WTERMSIG(process->status);\n\n      process->exit_cb(process, exit_status, term_signal);\n    }\n  }\n}\n\n\nint uv__make_socketpair(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_cloexec;\n\n  if (no_cloexec)\n    goto skip;\n\n  if (socketpair(AF_UNIX, SOCK_STREAM | UV__SOCK_CLOEXEC | flags, 0, fds) == 0)\n    return 0;\n\n  /* Retry on EINVAL, it means SOCK_CLOEXEC is not supported.\n   * Anything else is a genuine error.\n   */\n  if (errno != EINVAL)\n    return -errno;\n\n  no_cloexec = 1;\n\nskip:\n#endif\n\n  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n    return -errno;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags & UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}\n\n\nint uv__make_pipe(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_pipe2;\n\n  if (no_pipe2)\n    goto skip;\n\n  if (uv__pipe2(fds, flags | UV__O_CLOEXEC) == 0)\n    return 0;\n\n  if (errno != ENOSYS)\n    return -errno;\n\n  no_pipe2 = 1;\n\nskip:\n#endif\n\n  if (pipe(fds))\n    return -errno;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags & UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}\n\n\n/*\n * Used for initializing stdio streams like options.stdin_stream. Returns\n * zero on success. See also the cleanup section in uv_spawn().\n */\nstatic int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {\n  int mask;\n  int fd;\n\n  mask = UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD | UV_INHERIT_STREAM;\n\n  switch (container->flags & mask) {\n  case UV_IGNORE:\n    return 0;\n\n  case UV_CREATE_PIPE:\n    assert(container->data.stream != NULL);\n    if (container->data.stream->type != UV_NAMED_PIPE)\n      return -EINVAL;\n    else\n      return uv__make_socketpair(fds, 0);\n\n  case UV_INHERIT_FD:\n  case UV_INHERIT_STREAM:\n    if (container->flags & UV_INHERIT_FD)\n      fd = container->data.fd;\n    else\n      fd = uv__stream_fd(container->data.stream);\n\n    if (fd == -1)\n      return -EINVAL;\n\n    fds[1] = fd;\n    return 0;\n\n  default:\n    assert(0 && \"Unexpected flags\");\n    return -EINVAL;\n  }\n}\n\n\nstatic int uv__process_open_stream(uv_stdio_container_t* container,\n                                   int pipefds[2],\n                                   int writable) {\n  int flags;\n\n  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)\n    return 0;\n\n  if (uv__close(pipefds[1]))\n    if (errno != EINTR && errno != EINPROGRESS)\n      abort();\n\n  pipefds[1] = -1;\n  uv__nonblock(pipefds[0], 1);\n\n  if (container->data.stream->type == UV_NAMED_PIPE &&\n      ((uv_pipe_t*)container->data.stream)->ipc)\n    flags = UV_STREAM_READABLE | UV_STREAM_WRITABLE;\n  else if (writable)\n    flags = UV_STREAM_WRITABLE;\n  else\n    flags = UV_STREAM_READABLE;\n\n  return uv__stream_open(container->data.stream, pipefds[0], flags);\n}\n\n\nstatic void uv__process_close_stream(uv_stdio_container_t* container) {\n  if (!(container->flags & UV_CREATE_PIPE)) return;\n  uv__stream_close((uv_stream_t*)container->data.stream);\n}\n\n\nstatic void uv__write_int(int fd, int val) {\n  ssize_t n;\n\n  do\n    n = write(fd, &val, sizeof(val));\n  while (n == -1 && errno == EINTR);\n\n  if (n == -1 && errno == EPIPE)\n    return; /* parent process has quit */\n\n  assert(n == sizeof(val));\n}\n\n\nstatic void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}\n\n\nint uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n  int signal_pipe[2] = { -1, -1 };\n  int (*pipes)[2];\n  int stdio_count;\n  QUEUE* q;\n  ssize_t r;\n  pid_t pid;\n  int err;\n  int exec_errorno;\n  int i;\n\n  assert(options->file != NULL);\n  assert(!(options->flags & ~(UV_PROCESS_DETACHED |\n                              UV_PROCESS_SETGID |\n                              UV_PROCESS_SETUID |\n                              UV_PROCESS_WINDOWS_HIDE |\n                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\n\n  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n  QUEUE_INIT(&process->queue);\n\n  stdio_count = options->stdio_count;\n  if (stdio_count < 3)\n    stdio_count = 3;\n\n  err = -ENOMEM;\n  pipes = malloc(stdio_count * sizeof(*pipes));\n  if (pipes == NULL)\n    goto error;\n\n  for (i = 0; i < stdio_count; i++) {\n    pipes[i][0] = -1;\n    pipes[i][1] = -1;\n  }\n\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_init_stdio(options->stdio + i, pipes[i]);\n    if (err)\n      goto error;\n  }\n\n  /* This pipe is used by the parent to wait until\n   * the child has called `execve()`. We need this\n   * to avoid the following race condition:\n   *\n   *    if ((pid = fork()) > 0) {\n   *      kill(pid, SIGTERM);\n   *    }\n   *    else if (pid == 0) {\n   *      execve(\"/bin/cat\", argp, envp);\n   *    }\n   *\n   * The parent sends a signal immediately after forking.\n   * Since the child may not have called `execve()` yet,\n   * there is no telling what process receives the signal,\n   * our fork or /bin/cat.\n   *\n   * To avoid ambiguity, we create a pipe with both ends\n   * marked close-on-exec. Then, after the call to `fork()`,\n   * the parent polls the read end until it EOFs or errors with EPIPE.\n   */\n  err = uv__make_pipe(signal_pipe, 0);\n  if (err)\n    goto error;\n\n  uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);\n\n  /* Acquire write lock to prevent opening new fds in worker threads */\n  uv_rwlock_wrlock(&loop->cloexec_lock);\n  pid = fork();\n\n  if (pid == -1) {\n    err = -errno;\n    uv_rwlock_wrunlock(&loop->cloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n\n  /* Release lock in parent process */\n  uv_rwlock_wrunlock(&loop->cloexec_lock);\n  uv__close(signal_pipe[1]);\n\n  process->status = 0;\n  exec_errorno = 0;\n  do\n    r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));\n  while (r == -1 && errno == EINTR);\n\n  if (r == 0)\n    ; /* okay, EOF */\n  else if (r == sizeof(exec_errorno))\n    ; /* okay, read errorno */\n  else if (r == -1 && errno == EPIPE)\n    ; /* okay, got EPIPE */\n  else\n    abort();\n\n  uv__close(signal_pipe[0]);\n\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_open_stream(options->stdio + i, pipes[i], i == 0);\n    if (err == 0)\n      continue;\n\n    while (i--)\n      uv__process_close_stream(options->stdio + i);\n\n    goto error;\n  }\n\n  /* Only activate this handle if exec() happened successfully */\n  if (exec_errorno == 0) {\n    q = uv__process_queue(loop, pid);\n    QUEUE_INSERT_TAIL(q, &process->queue);\n    uv__handle_start(process);\n  }\n\n  process->pid = pid;\n  process->exit_cb = options->exit_cb;\n\n  free(pipes);\n  return exec_errorno;\n\nerror:\n  if (pipes != NULL) {\n    for (i = 0; i < stdio_count; i++) {\n      if (i < options->stdio_count)\n        if (options->stdio[i].flags & (UV_INHERIT_FD | UV_INHERIT_STREAM))\n          continue;\n      if (pipes[i][0] != -1)\n        close(pipes[i][0]);\n      if (pipes[i][1] != -1)\n        close(pipes[i][1]);\n    }\n    free(pipes);\n  }\n\n  return err;\n}\n\n\nint uv_process_kill(uv_process_t* process, int signum) {\n  return uv_kill(process->pid, signum);\n}\n\n\nint uv_kill(int pid, int signum) {\n  if (kill(pid, signum))\n    return -errno;\n  else\n    return 0;\n}\n\n\nvoid uv__process_close(uv_process_t* handle) {\n  /* TODO stop signal watcher when this is the last handle */\n  QUEUE_REMOVE(&handle->queue);\n  uv__handle_stop(handle);\n}\n"], "fixing_code": ["/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <errno.h>\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <poll.h>\n\n#if defined(__APPLE__) && !TARGET_OS_IPHONE\n# include <crt_externs.h>\n# define environ (*_NSGetEnviron())\n#else\nextern char **environ;\n#endif\n\n\nstatic QUEUE* uv__process_queue(uv_loop_t* loop, int pid) {\n  assert(pid > 0);\n  return loop->process_handles + pid % ARRAY_SIZE(loop->process_handles);\n}\n\n\nstatic void uv__chld(uv_signal_t* handle, int signum) {\n  uv_process_t* process;\n  uv_loop_t* loop;\n  int exit_status;\n  int term_signal;\n  unsigned int i;\n  int status;\n  pid_t pid;\n  QUEUE pending;\n  QUEUE* h;\n  QUEUE* q;\n\n  assert(signum == SIGCHLD);\n\n  QUEUE_INIT(&pending);\n  loop = handle->loop;\n\n  for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++) {\n    h = loop->process_handles + i;\n    q = QUEUE_HEAD(h);\n\n    while (q != h) {\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      q = QUEUE_NEXT(q);\n\n      do\n        pid = waitpid(process->pid, &status, WNOHANG);\n      while (pid == -1 && errno == EINTR);\n\n      if (pid == 0)\n        continue;\n\n      if (pid == -1) {\n        if (errno != ECHILD)\n          abort();\n        continue;\n      }\n\n      process->status = status;\n      QUEUE_REMOVE(&process->queue);\n      QUEUE_INSERT_TAIL(&pending, &process->queue);\n    }\n\n    while (!QUEUE_EMPTY(&pending)) {\n      q = QUEUE_HEAD(&pending);\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);\n\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      uv__handle_stop(process);\n\n      if (process->exit_cb == NULL)\n        continue;\n\n      exit_status = 0;\n      if (WIFEXITED(process->status))\n        exit_status = WEXITSTATUS(process->status);\n\n      term_signal = 0;\n      if (WIFSIGNALED(process->status))\n        term_signal = WTERMSIG(process->status);\n\n      process->exit_cb(process, exit_status, term_signal);\n    }\n  }\n}\n\n\nint uv__make_socketpair(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_cloexec;\n\n  if (no_cloexec)\n    goto skip;\n\n  if (socketpair(AF_UNIX, SOCK_STREAM | UV__SOCK_CLOEXEC | flags, 0, fds) == 0)\n    return 0;\n\n  /* Retry on EINVAL, it means SOCK_CLOEXEC is not supported.\n   * Anything else is a genuine error.\n   */\n  if (errno != EINVAL)\n    return -errno;\n\n  no_cloexec = 1;\n\nskip:\n#endif\n\n  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n    return -errno;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags & UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}\n\n\nint uv__make_pipe(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_pipe2;\n\n  if (no_pipe2)\n    goto skip;\n\n  if (uv__pipe2(fds, flags | UV__O_CLOEXEC) == 0)\n    return 0;\n\n  if (errno != ENOSYS)\n    return -errno;\n\n  no_pipe2 = 1;\n\nskip:\n#endif\n\n  if (pipe(fds))\n    return -errno;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags & UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}\n\n\n/*\n * Used for initializing stdio streams like options.stdin_stream. Returns\n * zero on success. See also the cleanup section in uv_spawn().\n */\nstatic int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {\n  int mask;\n  int fd;\n\n  mask = UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD | UV_INHERIT_STREAM;\n\n  switch (container->flags & mask) {\n  case UV_IGNORE:\n    return 0;\n\n  case UV_CREATE_PIPE:\n    assert(container->data.stream != NULL);\n    if (container->data.stream->type != UV_NAMED_PIPE)\n      return -EINVAL;\n    else\n      return uv__make_socketpair(fds, 0);\n\n  case UV_INHERIT_FD:\n  case UV_INHERIT_STREAM:\n    if (container->flags & UV_INHERIT_FD)\n      fd = container->data.fd;\n    else\n      fd = uv__stream_fd(container->data.stream);\n\n    if (fd == -1)\n      return -EINVAL;\n\n    fds[1] = fd;\n    return 0;\n\n  default:\n    assert(0 && \"Unexpected flags\");\n    return -EINVAL;\n  }\n}\n\n\nstatic int uv__process_open_stream(uv_stdio_container_t* container,\n                                   int pipefds[2],\n                                   int writable) {\n  int flags;\n\n  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)\n    return 0;\n\n  if (uv__close(pipefds[1]))\n    if (errno != EINTR && errno != EINPROGRESS)\n      abort();\n\n  pipefds[1] = -1;\n  uv__nonblock(pipefds[0], 1);\n\n  if (container->data.stream->type == UV_NAMED_PIPE &&\n      ((uv_pipe_t*)container->data.stream)->ipc)\n    flags = UV_STREAM_READABLE | UV_STREAM_WRITABLE;\n  else if (writable)\n    flags = UV_STREAM_WRITABLE;\n  else\n    flags = UV_STREAM_READABLE;\n\n  return uv__stream_open(container->data.stream, pipefds[0], flags);\n}\n\n\nstatic void uv__process_close_stream(uv_stdio_container_t* container) {\n  if (!(container->flags & UV_CREATE_PIPE)) return;\n  uv__stream_close((uv_stream_t*)container->data.stream);\n}\n\n\nstatic void uv__write_int(int fd, int val) {\n  ssize_t n;\n\n  do\n    n = write(fd, &val, sizeof(val));\n  while (n == -1 && errno == EINTR);\n\n  if (n == -1 && errno == EPIPE)\n    return; /* parent process has quit */\n\n  assert(n == sizeof(val));\n}\n\n\nstatic void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}\n\n\nint uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n  int signal_pipe[2] = { -1, -1 };\n  int (*pipes)[2];\n  int stdio_count;\n  QUEUE* q;\n  ssize_t r;\n  pid_t pid;\n  int err;\n  int exec_errorno;\n  int i;\n\n  assert(options->file != NULL);\n  assert(!(options->flags & ~(UV_PROCESS_DETACHED |\n                              UV_PROCESS_SETGID |\n                              UV_PROCESS_SETUID |\n                              UV_PROCESS_WINDOWS_HIDE |\n                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\n\n  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n  QUEUE_INIT(&process->queue);\n\n  stdio_count = options->stdio_count;\n  if (stdio_count < 3)\n    stdio_count = 3;\n\n  err = -ENOMEM;\n  pipes = malloc(stdio_count * sizeof(*pipes));\n  if (pipes == NULL)\n    goto error;\n\n  for (i = 0; i < stdio_count; i++) {\n    pipes[i][0] = -1;\n    pipes[i][1] = -1;\n  }\n\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_init_stdio(options->stdio + i, pipes[i]);\n    if (err)\n      goto error;\n  }\n\n  /* This pipe is used by the parent to wait until\n   * the child has called `execve()`. We need this\n   * to avoid the following race condition:\n   *\n   *    if ((pid = fork()) > 0) {\n   *      kill(pid, SIGTERM);\n   *    }\n   *    else if (pid == 0) {\n   *      execve(\"/bin/cat\", argp, envp);\n   *    }\n   *\n   * The parent sends a signal immediately after forking.\n   * Since the child may not have called `execve()` yet,\n   * there is no telling what process receives the signal,\n   * our fork or /bin/cat.\n   *\n   * To avoid ambiguity, we create a pipe with both ends\n   * marked close-on-exec. Then, after the call to `fork()`,\n   * the parent polls the read end until it EOFs or errors with EPIPE.\n   */\n  err = uv__make_pipe(signal_pipe, 0);\n  if (err)\n    goto error;\n\n  uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);\n\n  /* Acquire write lock to prevent opening new fds in worker threads */\n  uv_rwlock_wrlock(&loop->cloexec_lock);\n  pid = fork();\n\n  if (pid == -1) {\n    err = -errno;\n    uv_rwlock_wrunlock(&loop->cloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n\n  /* Release lock in parent process */\n  uv_rwlock_wrunlock(&loop->cloexec_lock);\n  uv__close(signal_pipe[1]);\n\n  process->status = 0;\n  exec_errorno = 0;\n  do\n    r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));\n  while (r == -1 && errno == EINTR);\n\n  if (r == 0)\n    ; /* okay, EOF */\n  else if (r == sizeof(exec_errorno))\n    ; /* okay, read errorno */\n  else if (r == -1 && errno == EPIPE)\n    ; /* okay, got EPIPE */\n  else\n    abort();\n\n  uv__close(signal_pipe[0]);\n\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_open_stream(options->stdio + i, pipes[i], i == 0);\n    if (err == 0)\n      continue;\n\n    while (i--)\n      uv__process_close_stream(options->stdio + i);\n\n    goto error;\n  }\n\n  /* Only activate this handle if exec() happened successfully */\n  if (exec_errorno == 0) {\n    q = uv__process_queue(loop, pid);\n    QUEUE_INSERT_TAIL(q, &process->queue);\n    uv__handle_start(process);\n  }\n\n  process->pid = pid;\n  process->exit_cb = options->exit_cb;\n\n  free(pipes);\n  return exec_errorno;\n\nerror:\n  if (pipes != NULL) {\n    for (i = 0; i < stdio_count; i++) {\n      if (i < options->stdio_count)\n        if (options->stdio[i].flags & (UV_INHERIT_FD | UV_INHERIT_STREAM))\n          continue;\n      if (pipes[i][0] != -1)\n        close(pipes[i][0]);\n      if (pipes[i][1] != -1)\n        close(pipes[i][1]);\n    }\n    free(pipes);\n  }\n\n  return err;\n}\n\n\nint uv_process_kill(uv_process_t* process, int signum) {\n  return uv_kill(process->pid, signum);\n}\n\n\nint uv_kill(int pid, int signum) {\n  if (kill(pid, signum))\n    return -errno;\n  else\n    return 0;\n}\n\n\nvoid uv__process_close(uv_process_t* handle) {\n  /* TODO stop signal watcher when this is the last handle */\n  QUEUE_REMOVE(&handle->queue);\n  uv__handle_stop(handle);\n}\n"], "filenames": ["src/unix/process.c"], "buggy_code_start_loc": [330], "buggy_code_end_loc": [330], "fixing_code_start_loc": [331], "fixing_code_end_loc": [342], "type": "CWE-273", "message": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.", "other": {"cve": {"id": "CVE-2015-0278", "sourceIdentifier": "secalert@redhat.com", "published": "2015-05-18T15:59:02.713", "lastModified": "2023-02-12T23:15:30.490", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors."}, {"lang": "es", "value": "libuv anterior a 0.10.34 no cancela correctamente los privilegios de grupo, lo que permite a atacantes dependientes de contexto ganar privilegios a trav\u00e9s de vectores no especificados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-273"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libuv_project:libuv:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.10.33", "matchCriteriaId": "1F3C6C6F-0490-4B05-AE01-9384C47659C4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.37", "matchCriteriaId": "005B0AC4-4F5F-4BFD-8BA4-67570A7B1A4A"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2015-0186.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:228", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libuv/libuv/pull/215", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#%21msg/libuv/0JZxwLMtsMI/jraczskYWWQJ", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/pipermail/package-announce/2015-February/150526.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201611-10", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c"}}