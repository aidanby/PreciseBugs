{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\tDDP:\tAn implementation of the AppleTalk DDP protocol for\n *\t\tEthernet 'ELAP'.\n *\n *\t\tAlan Cox  <alan@lxorguk.ukuu.org.uk>\n *\n *\t\tWith more than a little assistance from\n *\n *\t\tWesley Craig <netatalk@umich.edu>\n *\n *\tFixes:\n *\t\tNeil Horman\t\t:\tAdded missing device ioctls\n *\t\tMichael Callahan\t:\tMade routing work\n *\t\tWesley Craig\t\t:\tFix probing to listen to a\n *\t\t\t\t\t\tpassed node id.\n *\t\tAlan Cox\t\t:\tAdded send/recvmsg support\n *\t\tAlan Cox\t\t:\tMoved at. to protinfo in\n *\t\t\t\t\t\tsocket.\n *\t\tAlan Cox\t\t:\tAdded firewall hooks.\n *\t\tAlan Cox\t\t:\tSupports new ARPHRD_LOOPBACK\n *\t\tChrister Weinigel\t: \tRouting and /proc fixes.\n *\t\tBradford Johnson\t:\tLocalTalk.\n *\t\tTom Dyas\t\t:\tModule support.\n *\t\tAlan Cox\t\t:\tHooks for PPP (based on the\n *\t\t\t\t\t\tLocalTalk hook).\n *\t\tAlan Cox\t\t:\tPosix bits\n *\t\tAlan Cox/Mike Freeman\t:\tPossible fix to NBP problems\n *\t\tBradford Johnson\t:\tIP-over-DDP (experimental)\n *\t\tJay Schulist\t\t:\tMoved IP-over-DDP to its own\n *\t\t\t\t\t\tdriver file. (ipddp.c & ipddp.h)\n *\t\tJay Schulist\t\t:\tMade work as module with\n *\t\t\t\t\t\tAppleTalk drivers, cleaned it.\n *\t\tRob Newberry\t\t:\tAdded proxy AARP and AARP\n *\t\t\t\t\t\tprocfs, moved probing to AARP\n *\t\t\t\t\t\tmodule.\n *              Adrian Sun/\n *              Michael Zuelsdorff      :       fix for net.0 packets. don't\n *                                              allow illegal ether/tokentalk\n *                                              port assignment. we lose a\n *                                              valid localtalk port as a\n *                                              result.\n *\t\tArnaldo C. de Melo\t:\tCleanup, in preparation for\n *\t\t\t\t\t\tshared skb support 8)\n *\t\tArnaldo C. de Melo\t:\tMove proc stuff to atalk_proc.c,\n *\t\t\t\t\t\tuse seq_file\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/termios.h>\t/* For TIOCOUTQ/INQ */\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <net/datalink.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/route.h>\n#include <net/compat.h>\n#include <linux/atalk.h>\n#include <linux/highmem.h>\n\nstruct datalink_proto *ddp_dl, *aarp_dl;\nstatic const struct proto_ops atalk_dgram_ops;\n\n/**************************************************************************\\\n*                                                                          *\n* Handlers for the socket list.                                            *\n*                                                                          *\n\\**************************************************************************/\n\nHLIST_HEAD(atalk_sockets);\nDEFINE_RWLOCK(atalk_sockets_lock);\n\nstatic inline void __atalk_insert_socket(struct sock *sk)\n{\n\tsk_add_node(sk, &atalk_sockets);\n}\n\nstatic inline void atalk_remove_socket(struct sock *sk)\n{\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&atalk_sockets_lock);\n}\n\nstatic struct sock *atalk_search_socket(struct sockaddr_at *to,\n\t\t\t\t\tstruct atalk_iface *atif)\n{\n\tstruct sock *s;\n\n\tread_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\tif (to->sat_port != at->src_port)\n\t\t\tcontinue;\n\n\t\tif (to->sat_addr.s_net == ATADDR_ANYNET &&\n\t\t    to->sat_addr.s_node == ATADDR_BCAST)\n\t\t\tgoto found;\n\n\t\tif (to->sat_addr.s_net == at->src_net &&\n\t\t    (to->sat_addr.s_node == at->src_node ||\n\t\t     to->sat_addr.s_node == ATADDR_BCAST ||\n\t\t     to->sat_addr.s_node == ATADDR_ANYNODE))\n\t\t\tgoto found;\n\n\t\t/* XXXX.0 -- we got a request for this router. make sure\n\t\t * that the node is appropriately set. */\n\t\tif (to->sat_addr.s_node == ATADDR_ANYNODE &&\n\t\t    to->sat_addr.s_net != ATADDR_ANYNET &&\n\t\t    atif->address.s_node == at->src_node) {\n\t\t\tto->sat_addr.s_node = atif->address.s_node;\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tread_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\n/**\n * atalk_find_or_insert_socket - Try to find a socket matching ADDR\n * @sk: socket to insert in the list if it is not there already\n * @sat: address to search for\n *\n * Try to find a socket matching ADDR in the socket list, if found then return\n * it. If not, insert SK into the socket list.\n *\n * This entire operation must execute atomically.\n */\nstatic struct sock *atalk_find_or_insert_socket(struct sock *sk,\n\t\t\t\t\t\tstruct sockaddr_at *sat)\n{\n\tstruct sock *s;\n\tstruct atalk_sock *at;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tat = at_sk(s);\n\n\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t    at->src_port == sat->sat_port)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\n\t__atalk_insert_socket(sk); /* Wheee, it's free, assign and insert. */\nfound:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\nstatic void atalk_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tif (sk_has_allocations(sk)) {\n\t\tsk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\nstatic inline void atalk_destroy_socket(struct sock *sk)\n{\n\tatalk_remove_socket(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (sk_has_allocations(sk)) {\n\t\ttimer_setup(&sk->sk_timer, atalk_destroy_timer, 0);\n\t\tsk->sk_timer.expires\t= jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/**************************************************************************\\\n*                                                                          *\n* Routing tables for the AppleTalk socket layer.                           *\n*                                                                          *\n\\**************************************************************************/\n\n/* Anti-deadlock ordering is atalk_routes_lock --> iface_lock -DaveM */\nstruct atalk_route *atalk_routes;\nDEFINE_RWLOCK(atalk_routes_lock);\n\nstruct atalk_iface *atalk_interfaces;\nDEFINE_RWLOCK(atalk_interfaces_lock);\n\n/* For probing devices or in a routerless network */\nstruct atalk_route atrtr_default;\n\n/* AppleTalk interface control */\n/*\n * Drop a device. Doesn't drop any of its routes - that is the caller's\n * problem. Called when we down the interface or delete the address.\n */\nstatic void atif_drop_device(struct net_device *dev)\n{\n\tstruct atalk_iface **iface = &atalk_interfaces;\n\tstruct atalk_iface *tmp;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\twhile ((tmp = *iface) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*iface = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t\tdev->atalk_ptr = NULL;\n\t\t} else\n\t\t\tiface = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_interfaces_lock);\n}\n\nstatic struct atalk_iface *atif_add_device(struct net_device *dev,\n\t\t\t\t\t   struct atalk_addr *sa)\n{\n\tstruct atalk_iface *iface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\n\tif (!iface)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tiface->dev = dev;\n\tdev->atalk_ptr = iface;\n\tiface->address = *sa;\n\tiface->status = 0;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\tiface->next = atalk_interfaces;\n\tatalk_interfaces = iface;\n\twrite_unlock_bh(&atalk_interfaces_lock);\nout:\n\treturn iface;\n}\n\n/* Perform phase 2 AARP probing on our tentative address */\nstatic int atif_probe_device(struct atalk_iface *atif)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = atif->address.s_node;\n\tint netct, nodect;\n\n\t/* Offset the network we start probing with */\n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t/* Scan the networks */\n\tatif->status |= ATIF_PROBE;\n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t/* Sweep the available nodes from a given start */\n\t\tatif->address.s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tatif->address.s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (atif->address.s_node > 0 &&\n\t\t\t    atif->address.s_node < 254) {\n\t\t\t\t/* Probe a proposed address */\n\t\t\t\taarp_probe_network(atif);\n\n\t\t\t\tif (!(atif->status & ATIF_PROBE_FAIL)) {\n\t\t\t\t\tatif->status &= ~ATIF_PROBE;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tatif->status &= ~ATIF_PROBE_FAIL;\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\tatif->status &= ~ATIF_PROBE;\n\n\treturn -EADDRINUSE;\t/* Network is full... */\n}\n\n\n/* Perform AARP probing for a proxy address */\nstatic int atif_proxy_probe_device(struct atalk_iface *atif,\n\t\t\t\t   struct atalk_addr *proxy_addr)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\t/* we probe the interface's network */\n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = ATADDR_ANYNODE;\t    /* we'll take anything */\n\tint netct, nodect;\n\n\t/* Offset the network we start probing with */\n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t/* Scan the networks */\n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t/* Sweep the available nodes from a given start */\n\t\tproxy_addr->s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tproxy_addr->s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (proxy_addr->s_node > 0 &&\n\t\t\t    proxy_addr->s_node < 254) {\n\t\t\t\t/* Tell AARP to probe a proposed address */\n\t\t\t\tint ret = aarp_proxy_probe_network(atif,\n\t\t\t\t\t\t\t\t    proxy_addr);\n\n\t\t\t\tif (ret != -EADDRINUSE)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\n\treturn -EADDRINUSE;\t/* Network is full... */\n}\n\n\nstruct atalk_addr *atalk_find_dev_addr(struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\treturn iface ? &iface->address : NULL;\n}\n\nstatic struct atalk_addr *atalk_find_primary(void)\n{\n\tstruct atalk_iface *fiface = NULL;\n\tstruct atalk_addr *retval;\n\tstruct atalk_iface *iface;\n\n\t/*\n\t * Return a point-to-point interface only if\n\t * there is no non-ptp interface available.\n\t */\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif (!fiface && !(iface->dev->flags & IFF_LOOPBACK))\n\t\t\tfiface = iface;\n\t\tif (!(iface->dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))) {\n\t\t\tretval = &iface->address;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fiface)\n\t\tretval = &fiface->address;\n\telse if (atalk_interfaces)\n\t\tretval = &atalk_interfaces->address;\n\telse\n\t\tretval = NULL;\nout:\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn retval;\n}\n\n/*\n * Find a match for 'any network' - ie any of our interfaces with that\n * node number will do just nicely.\n */\nstatic struct atalk_iface *atalk_find_anynet(int node, struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\n\tif (!iface || iface->status & ATIF_PROBE)\n\t\tgoto out_err;\n\n\tif (node != ATADDR_BCAST &&\n\t    iface->address.s_node != node &&\n\t    node != ATADDR_ANYNODE)\n\t\tgoto out_err;\nout:\n\treturn iface;\nout_err:\n\tiface = NULL;\n\tgoto out;\n}\n\n/* Find a match for a specific network:node pair */\nstatic struct atalk_iface *atalk_find_interface(__be16 net, int node)\n{\n\tstruct atalk_iface *iface;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif ((node == ATADDR_BCAST ||\n\t\t     node == ATADDR_ANYNODE ||\n\t\t     iface->address.s_node == node) &&\n\t\t    iface->address.s_net == net &&\n\t\t    !(iface->status & ATIF_PROBE))\n\t\t\tbreak;\n\n\t\t/* XXXX.0 -- net.0 returns the iface associated with net */\n\t\tif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\n\t\t    ntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\n\t\t    ntohs(net) <= ntohs(iface->nets.nr_lastnet))\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn iface;\n}\n\n\n/*\n * Find a route for an AppleTalk packet. This ought to get cached in\n * the socket (later on...). We know about host routes and the fact\n * that a route must be direct to broadcast.\n */\nstatic struct atalk_route *atrtr_find(struct atalk_addr *target)\n{\n\t/*\n\t * we must search through all routes unless we find a\n\t * host route, because some host routes might overlap\n\t * network routes\n\t */\n\tstruct atalk_route *net_route = NULL;\n\tstruct atalk_route *r;\n\n\tread_lock_bh(&atalk_routes_lock);\n\tfor (r = atalk_routes; r; r = r->next) {\n\t\tif (!(r->flags & RTF_UP))\n\t\t\tcontinue;\n\n\t\tif (r->target.s_net == target->s_net) {\n\t\t\tif (r->flags & RTF_HOST) {\n\t\t\t\t/*\n\t\t\t\t * if this host route is for the target,\n\t\t\t\t * the we're done\n\t\t\t\t */\n\t\t\t\tif (r->target.s_node == target->s_node)\n\t\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * this route will work if there isn't a\n\t\t\t\t * direct host route, so cache it\n\t\t\t\t */\n\t\t\t\tnet_route = r;\n\t\t}\n\t}\n\n\t/*\n\t * if we found a network route but not a direct host\n\t * route, then return it\n\t */\n\tif (net_route)\n\t\tr = net_route;\n\telse if (atrtr_default.dev)\n\t\tr = &atrtr_default;\n\telse /* No route can be found */\n\t\tr = NULL;\nout:\n\tread_unlock_bh(&atalk_routes_lock);\n\treturn r;\n}\n\n\n/*\n * Given an AppleTalk network, find the device to use. This can be\n * a simple lookup.\n */\nstruct net_device *atrtr_get_dev(struct atalk_addr *sa)\n{\n\tstruct atalk_route *atr = atrtr_find(sa);\n\treturn atr ? atr->dev : NULL;\n}\n\n/* Set up a default router */\nstatic void atrtr_set_default(struct net_device *dev)\n{\n\tatrtr_default.dev\t     = dev;\n\tatrtr_default.flags\t     = RTF_UP;\n\tatrtr_default.gateway.s_net  = htons(0);\n\tatrtr_default.gateway.s_node = 0;\n}\n\n/*\n * Add a router. Basically make sure it looks valid and stuff the\n * entry in the list. While it uses netranges we always set them to one\n * entry to work like netatalk.\n */\nstatic int atrtr_create(struct rtentry *r, struct net_device *devhint)\n{\n\tstruct sockaddr_at *ta = (struct sockaddr_at *)&r->rt_dst;\n\tstruct sockaddr_at *ga = (struct sockaddr_at *)&r->rt_gateway;\n\tstruct atalk_route *rt;\n\tstruct atalk_iface *iface, *riface;\n\tint retval = -EINVAL;\n\n\t/*\n\t * Fixme: Raise/Lower a routing change semaphore for these\n\t * operations.\n\t */\n\n\t/* Validate the request */\n\tif (ta->sat_family != AF_APPLETALK ||\n\t    (!devhint && ga->sat_family != AF_APPLETALK))\n\t\tgoto out;\n\n\t/* Now walk the routing table and make our decisions */\n\twrite_lock_bh(&atalk_routes_lock);\n\tfor (rt = atalk_routes; rt; rt = rt->next) {\n\t\tif (r->rt_flags != rt->flags)\n\t\t\tcontinue;\n\n\t\tif (ta->sat_addr.s_net == rt->target.s_net) {\n\t\t\tif (!(rt->flags & RTF_HOST))\n\t\t\t\tbreak;\n\t\t\tif (ta->sat_addr.s_node == rt->target.s_node)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!devhint) {\n\t\triface = NULL;\n\n\t\tread_lock_bh(&atalk_interfaces_lock);\n\t\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\t\tif (!riface &&\n\t\t\t    ntohs(ga->sat_addr.s_net) >=\n\t\t\t\t\tntohs(iface->nets.nr_firstnet) &&\n\t\t\t    ntohs(ga->sat_addr.s_net) <=\n\t\t\t\t\tntohs(iface->nets.nr_lastnet))\n\t\t\t\triface = iface;\n\n\t\t\tif (ga->sat_addr.s_net == iface->address.s_net &&\n\t\t\t    ga->sat_addr.s_node == iface->address.s_node)\n\t\t\t\triface = iface;\n\t\t}\n\t\tread_unlock_bh(&atalk_interfaces_lock);\n\n\t\tretval = -ENETUNREACH;\n\t\tif (!riface)\n\t\t\tgoto out_unlock;\n\n\t\tdevhint = riface->dev;\n\t}\n\n\tif (!rt) {\n\t\trt = kzalloc(sizeof(*rt), GFP_ATOMIC);\n\n\t\tretval = -ENOBUFS;\n\t\tif (!rt)\n\t\t\tgoto out_unlock;\n\n\t\trt->next = atalk_routes;\n\t\tatalk_routes = rt;\n\t}\n\n\t/* Fill in the routing entry */\n\trt->target  = ta->sat_addr;\n\tdev_hold(devhint);\n\trt->dev     = devhint;\n\trt->flags   = r->rt_flags;\n\trt->gateway = ga->sat_addr;\n\n\tretval = 0;\nout_unlock:\n\twrite_unlock_bh(&atalk_routes_lock);\nout:\n\treturn retval;\n}\n\n/* Delete a route. Find it and discard it */\nstatic int atrtr_delete(struct atalk_addr *addr)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tint retval = 0;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->target.s_net == addr->s_net &&\n\t\t    (!(tmp->flags&RTF_GATEWAY) ||\n\t\t     tmp->target.s_node == addr->s_node)) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(tmp->dev);\n\t\t\tkfree(tmp);\n\t\t\tgoto out;\n\t\t}\n\t\tr = &tmp->next;\n\t}\n\tretval = -ENOENT;\nout:\n\twrite_unlock_bh(&atalk_routes_lock);\n\treturn retval;\n}\n\n/*\n * Called when a device is downed. Just throw away any routes\n * via it.\n */\nstatic void atrtr_device_down(struct net_device *dev)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tr = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_routes_lock);\n\n\tif (atrtr_default.dev == dev)\n\t\tatrtr_set_default(NULL);\n}\n\n/* Actually down the interface */\nstatic inline void atalk_dev_down(struct net_device *dev)\n{\n\tatrtr_device_down(dev);\t/* Remove all routes for the device */\n\taarp_device_down(dev);\t/* Remove AARP entries for the device */\n\tatif_drop_device(dev);\t/* Remove the device */\n}\n\n/*\n * A device event has occurred. Watch for devices going down and\n * delete our use of them (iface and route).\n */\nstatic int ddp_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_DOWN)\n\t\t/* Discard any use of this */\n\t\tatalk_dev_down(dev);\n\n\treturn NOTIFY_DONE;\n}\n\n/* ioctl calls. Shouldn't even need touching */\n/* Device configuration ioctl calls */\nstatic int atif_ioctl(int cmd, void __user *arg)\n{\n\tstatic char aarp_mcast[6] = { 0x09, 0x00, 0x00, 0xFF, 0xFF, 0xFF };\n\tstruct ifreq atreq;\n\tstruct atalk_netrange *nr;\n\tstruct sockaddr_at *sa;\n\tstruct net_device *dev;\n\tstruct atalk_iface *atif;\n\tint ct;\n\tint limit;\n\tstruct rtentry rtdef;\n\tint add_route;\n\n\tif (get_user_ifreq(&atreq, NULL, arg))\n\t\treturn -EFAULT;\n\n\tdev = __dev_get_by_name(&init_net, atreq.ifr_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tsa = (struct sockaddr_at *)&atreq.ifr_addr;\n\tatif = atalk_find_dev(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (dev->type != ARPHRD_ETHER &&\n\t\t    dev->type != ARPHRD_LOOPBACK &&\n\t\t    dev->type != ARPHRD_LOCALTLK &&\n\t\t    dev->type != ARPHRD_PPP)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tnr = (struct atalk_netrange *)&sa->sat_zero[0];\n\t\tadd_route = 1;\n\n\t\t/*\n\t\t * if this is a point-to-point iface, and we already\n\t\t * have an iface for this AppleTalk address, then we\n\t\t * should not add a route\n\t\t */\n\t\tif ((dev->flags & IFF_POINTOPOINT) &&\n\t\t    atalk_find_interface(sa->sat_addr.s_net,\n\t\t\t\t\t sa->sat_addr.s_node)) {\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: point-to-point \"\n\t\t\t       \"interface added with \"\n\t\t\t       \"existing address\\n\");\n\t\t\tadd_route = 0;\n\t\t}\n\n\t\t/*\n\t\t * Phase 1 is fine on LocalTalk but we don't do\n\t\t * EtherTalk phase 1. Anyone wanting to add it, go ahead.\n\t\t */\n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\t\tif (atif) {\n\t\t\t/* Already setting address */\n\t\t\tif (atif->status & ATIF_PROBE)\n\t\t\t\treturn -EBUSY;\n\n\t\t\tatif->address.s_net  = sa->sat_addr.s_net;\n\t\t\tatif->address.s_node = sa->sat_addr.s_node;\n\t\t\tatrtr_device_down(dev);\t/* Flush old routes */\n\t\t} else {\n\t\t\tatif = atif_add_device(dev, &sa->sat_addr);\n\t\t\tif (!atif)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tatif->nets = *nr;\n\n\t\t/*\n\t\t * Check if the chosen address is used. If so we\n\t\t * error and atalkd will try another.\n\t\t */\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) &&\n\t\t    !(dev->flags & IFF_POINTOPOINT) &&\n\t\t    atif_probe_device(atif) < 0) {\n\t\t\tatif_drop_device(dev);\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\n\t\t/* Hey it worked - add the direct routes */\n\t\tsa = (struct sockaddr_at *)&rtdef.rt_gateway;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net  = atif->address.s_net;\n\t\tsa->sat_addr.s_node = atif->address.s_node;\n\t\tsa = (struct sockaddr_at *)&rtdef.rt_dst;\n\t\trtdef.rt_flags = RTF_UP;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_node = ATADDR_ANYNODE;\n\t\tif (dev->flags & IFF_LOOPBACK ||\n\t\t    dev->flags & IFF_POINTOPOINT)\n\t\t\trtdef.rt_flags |= RTF_HOST;\n\n\t\t/* Routerless initial state */\n\t\tif (nr->nr_firstnet == htons(0) &&\n\t\t    nr->nr_lastnet == htons(0xFFFE)) {\n\t\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\t\tatrtr_create(&rtdef, dev);\n\t\t\tatrtr_set_default(dev);\n\t\t} else {\n\t\t\tlimit = ntohs(nr->nr_lastnet);\n\t\t\tif (limit - ntohs(nr->nr_firstnet) > 4096) {\n\t\t\t\tprintk(KERN_WARNING \"Too many routes/\"\n\t\t\t\t       \"iface.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (add_route)\n\t\t\t\tfor (ct = ntohs(nr->nr_firstnet);\n\t\t\t\t     ct <= limit; ct++) {\n\t\t\t\t\tsa->sat_addr.s_net = htons(ct);\n\t\t\t\t\tatrtr_create(&rtdef, dev);\n\t\t\t\t}\n\t\t}\n\t\tdev_mc_add_global(dev, aarp_mcast);\n\t\treturn 0;\n\n\tcase SIOCGIFADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr = atif->address;\n\t\tbreak;\n\n\tcase SIOCGIFBRDADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\tsa->sat_addr.s_node = ATADDR_BCAST;\n\t\tbreak;\n\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tatalk_dev_down(dev);\n\t\tbreak;\n\n\tcase SIOCSARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * for now, we only support proxy AARP on ELAP;\n\t\t * we should be able to do it for LocalTalk, too.\n\t\t */\n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\t/*\n\t\t * atif points to the current interface on this network;\n\t\t * we aren't concerned about its current status (at\n\t\t * least for now), but it has all the settings about\n\t\t * the network we're going to probe. Consequently, it\n\t\t * must exist.\n\t\t */\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tnr = (struct atalk_netrange *)&(atif->nets);\n\t\t/*\n\t\t * Phase 1 is fine on Localtalk but we don't do\n\t\t * Ethertalk phase 1. Anyone wanting to add it, go ahead.\n\t\t */\n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Check if the chosen address is used. If so we\n\t\t * error and ATCP will try another.\n\t\t */\n\t\tif (atif_proxy_probe_device(atif, &(sa->sat_addr)) < 0)\n\t\t\treturn -EADDRINUSE;\n\n\t\t/*\n\t\t * We now have an address on the local network, and\n\t\t * the AARP code will defend it for us until we take it\n\t\t * down. We don't set up any routes right now, because\n\t\t * ATCP will install them manually via SIOCADDRT.\n\t\t */\n\t\tbreak;\n\n\tcase SIOCDARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t/* give to aarp module to remove proxy entry */\n\t\taarp_proxy_remove(atif->dev, &(sa->sat_addr));\n\t\treturn 0;\n\t}\n\n\treturn put_user_ifreq(&atreq, arg);\n}\n\nstatic int atrtr_ioctl_addrt(struct rtentry *rt)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (rt->rt_dev) {\n\t\tchar name[IFNAMSIZ];\n\n\t\tif (copy_from_user(name, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\t\tname[IFNAMSIZ-1] = '\\0';\n\n\t\tdev = __dev_get_by_name(&init_net, name);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t}\n\treturn atrtr_create(rt, dev);\n}\n\n/* Routing ioctl() calls */\nstatic int atrtr_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\treturn atrtr_ioctl_addrt(&rt);\n\t}\n\treturn -EINVAL;\n}\n\n/**************************************************************************\\\n*                                                                          *\n* Handling for system calls applied via the various interfaces to an       *\n* AppleTalk socket object.                                                 *\n*                                                                          *\n\\**************************************************************************/\n\n/*\n * Checksum: This is 'optional'. It's quite likely also a good\n * candidate for assembler hackery 8)\n */\nstatic unsigned long atalk_sum_partial(const unsigned char *data,\n\t\t\t\t       int len, unsigned long sum)\n{\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data++;\n\t\tsum = rol16(sum, 1);\n\t}\n\treturn sum;\n}\n\n/*  Checksum skb data --  similar to skb_checksum  */\nstatic unsigned long atalk_sum_skb(const struct sk_buff *skb, int offset,\n\t\t\t\t   int len, unsigned long sum)\n{\n\tint start = skb_headlen(skb);\n\tstruct sk_buff *frag_iter;\n\tint i, copy;\n\n\t/* checksum stuff in header space */\n\tif ((copy = start - offset) > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tsum = atalk_sum_partial(skb->data + offset, copy, sum);\n\t\tif ((len -= copy) == 0)\n\t\t\treturn sum;\n\n\t\toffset += copy;\n\t}\n\n\t/* checksum stuff in frags */\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tu8 *vaddr;\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tvaddr = kmap_atomic(skb_frag_page(frag));\n\t\t\tsum = atalk_sum_partial(vaddr + skb_frag_off(frag) +\n\t\t\t\t\t\toffset - start, copy, sum);\n\t\t\tkunmap_atomic(vaddr);\n\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tsum = atalk_sum_skb(frag_iter, offset - start,\n\t\t\t\t\t    copy, sum);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tBUG_ON(len > 0);\n\n\treturn sum;\n}\n\nstatic __be16 atalk_checksum(const struct sk_buff *skb, int len)\n{\n\tunsigned long sum;\n\n\t/* skip header 4 bytes */\n\tsum = atalk_sum_skb(skb, 4, len-4, 0);\n\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : htons(0xFFFF);\n}\n\nstatic struct proto ddp_proto = {\n\t.name\t  = \"DDP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct atalk_sock),\n};\n\n/*\n * Create a socket. Initialise the socket, blank the addresses\n * set the state.\n */\nstatic int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}\n\n/* Free a socket. No work needed */\nstatic int atalk_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\n\t\tsock_orphan(sk);\n\t\tsock->sk = NULL;\n\t\tatalk_destroy_socket(sk);\n\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n\treturn 0;\n}\n\n/**\n * atalk_pick_and_bind_port - Pick a source port when one is not given\n * @sk: socket to insert into the tables\n * @sat: address to search for\n *\n * Pick a source port when one is not given. If we can find a suitable free\n * one, we insert the socket into the tables using it.\n *\n * This whole operation must be atomic.\n */\nstatic int atalk_pick_and_bind_port(struct sock *sk, struct sockaddr_at *sat)\n{\n\tint retval;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\n\tfor (sat->sat_port = ATPORT_RESERVED;\n\t     sat->sat_port < ATPORT_LAST;\n\t     sat->sat_port++) {\n\t\tstruct sock *s;\n\n\t\tsk_for_each(s, &atalk_sockets) {\n\t\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t\t    at->src_port == sat->sat_port)\n\t\t\t\tgoto try_next_port;\n\t\t}\n\n\t\t/* Wheee, it's free, assign and insert. */\n\t\t__atalk_insert_socket(sk);\n\t\tat_sk(sk)->src_port = sat->sat_port;\n\t\tretval = 0;\n\t\tgoto out;\n\ntry_next_port:;\n\t}\n\n\tretval = -EBUSY;\nout:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn retval;\n}\n\nstatic int atalk_autobind(struct sock *sk)\n{\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at sat;\n\tstruct atalk_addr *ap = atalk_find_primary();\n\tint n = -EADDRNOTAVAIL;\n\n\tif (!ap || ap->s_net == htons(ATADDR_ANYNET))\n\t\tgoto out;\n\n\tat->src_net  = sat.sat_addr.s_net  = ap->s_net;\n\tat->src_node = sat.sat_addr.s_node = ap->s_node;\n\n\tn = atalk_pick_and_bind_port(sk, &sat);\n\tif (!n)\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\treturn n;\n}\n\n/* Set the address 'our end' of the connection */\nstatic int atalk_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_at *addr = (struct sockaddr_at *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED) ||\n\t    addr_len != sizeof(struct sockaddr_at))\n\t\treturn -EINVAL;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tlock_sock(sk);\n\tif (addr->sat_addr.s_net == htons(ATADDR_ANYNET)) {\n\t\tstruct atalk_addr *ap = atalk_find_primary();\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ap)\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net = ap->s_net;\n\t\tat->src_node = addr->sat_addr.s_node = ap->s_node;\n\t} else {\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!atalk_find_interface(addr->sat_addr.s_net,\n\t\t\t\t\t  addr->sat_addr.s_node))\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net;\n\t\tat->src_node = addr->sat_addr.s_node;\n\t}\n\n\tif (addr->sat_port == ATADDR_ANYPORT) {\n\t\terr = atalk_pick_and_bind_port(sk, addr);\n\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tat->src_port = addr->sat_port;\n\n\t\terr = -EADDRINUSE;\n\t\tif (atalk_find_or_insert_socket(sk, addr))\n\t\t\tgoto out;\n\t}\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* Set the address we talk to */\nstatic int atalk_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *addr;\n\tint err;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tif (addr_len != sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr = (struct sockaddr_at *)uaddr;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (addr->sat_addr.s_node == ATADDR_BCAST &&\n\t    !sock_flag(sk, SOCK_BROADCAST)) {\n#if 1\n\t\tpr_warn(\"atalk_connect: %s is broken and did not set SO_BROADCAST.\\n\",\n\t\t\tcurrent->comm);\n#else\n\t\treturn -EACCES;\n#endif\n\t}\n\n\tlock_sock(sk);\n\terr = -EBUSY;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\terr = -ENETUNREACH;\n\tif (!atrtr_get_dev(&addr->sat_addr))\n\t\tgoto out;\n\n\tat->dest_port = addr->sat_port;\n\tat->dest_net  = addr->sat_addr.s_net;\n\tat->dest_node = addr->sat_addr.s_node;\n\n\tsock->state  = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/*\n * Find the name of an AppleTalk socket. Just copy the right\n * fields into the sockaddr.\n */\nstatic int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tlock_sock(sk);\n\terr = -ENOBUFS;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\tmemset(&sat, 0, sizeof(sat));\n\n\tif (peer) {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\terr = sizeof(struct sockaddr_at);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)\n{\n\tstruct atalk_route *rt;\n\tstruct atalk_addr ta;\n\n\t/*\n\t * Don't route multicast, etc., packets, or packets sent to \"this\n\t * network\"\n\t */\n\tif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\n\t\t/*\n\t\t * FIXME:\n\t\t *\n\t\t * Can it ever happen that a packet is from a PPP iface and\n\t\t * needs to be broadcast onto the default network?\n\t\t */\n\t\tif (dev->type == ARPHRD_PPP)\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: didn't forward broadcast \"\n\t\t\t\t\t  \"packet received from PPP iface\\n\");\n\t\tgoto free_it;\n\t}\n\n\tta.s_net  = ddp->deh_dnet;\n\tta.s_node = ddp->deh_dnode;\n\n\t/* Route the packet */\n\trt = atrtr_find(&ta);\n\t/* increment hops count */\n\tlen_hops += 1 << 10;\n\tif (!rt || !(len_hops & (15 << 10)))\n\t\tgoto free_it;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\n\t/*\n\t * Route goes through another gateway, so set the target to the\n\t * gateway instead.\n\t */\n\n\tif (rt->flags & RTF_GATEWAY) {\n\t\tta.s_net  = rt->gateway.s_net;\n\t\tta.s_node = rt->gateway.s_node;\n\t}\n\n\t/* Fix up skb->len field */\n\tskb_trim(skb, min_t(unsigned int, origlen,\n\t\t\t    (rt->dev->hard_header_len +\n\t\t\t     ddp_dl->header_length + (len_hops & 1023))));\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp->deh_len_hops = htons(len_hops);\n\n\t/*\n\t * Send the buffer onwards\n\t *\n\t * Now we must always be careful. If it's come from LocalTalk to\n\t * EtherTalk it might not fit\n\t *\n\t * Order matters here: If a packet has to be copied to make a new\n\t * headroom (rare hopefully) then it won't need unsharing.\n\t *\n\t * Note. ddp-> becomes invalid at the realloc.\n\t */\n\tif (skb_headroom(skb) < 22) {\n\t\t/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */\n\t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t} else\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\n\t/*\n\t * If the buffer didn't vanish into the lack of space bitbucket we can\n\t * send it.\n\t */\n\tif (skb == NULL)\n\t\tgoto drop;\n\n\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\n\t\treturn NET_RX_DROP;\n\treturn NET_RX_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_RX_DROP;\n}\n\n/**\n *\tatalk_rcv - Receive a packet (in skb) from device dev\n *\t@skb: packet received\n *\t@dev: network device where the packet comes from\n *\t@pt: packet type\n *\t@orig_dev: the original receive net device\n *\n *\tReceive a packet (in skb) from device dev. This has come from the SNAP\n *\tdecoder, and on entry skb->transport_header is the DDP header, skb->len\n *\tis the DDP header, skb->len is the DDP length. The physical headers\n *\thave been extracted. PPP should probably pass frames marked as for this\n *\tlayer.  [ie ARPHRD_ETHERTALK]\n */\nstatic int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ddpehdr *ddp;\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n\tint origlen;\n\t__u16 len_hops;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Don't mangle buffer if shared */\n\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\tgoto out;\n\n\t/* Size check and make sure header is contiguous */\n\tif (!pskb_may_pull(skb, sizeof(*ddp)))\n\t\tgoto drop;\n\n\tddp = ddp_hdr(skb);\n\n\tlen_hops = ntohs(ddp->deh_len_hops);\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of atalk_checksum() or recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\n\t\tpr_debug(\"AppleTalk: dropping corrupted frame (deh_len=%u, \"\n\t\t\t \"skb->len=%u)\\n\", len_hops & 1023, skb->len);\n\t\tgoto drop;\n\t}\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto drop;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\tif (!atif) {\n\t\t/* Not ours, so we route the packet via the correct\n\t\t * AppleTalk iface\n\t\t */\n\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\n\t}\n\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto drop;\n\n\t/* Queue packet (standard) */\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto drop;\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n\n}\n\n/*\n * Receive a LocalTalk frame. We make some demands on the caller here.\n * Caller must provide enough headroom on the packet to pull the short\n * header and append a long one.\n */\nstatic int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto freeit;\n\n\t/* Expand any short form frames */\n\tif (skb_mac_header(skb)[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(__be16) || skb->len > 1023)\n\t\t\tgoto freeit;\n\n\t\t/* Don't mangle buffer if shared */\n\t\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\t\tddp = skb_push(skb, sizeof(*ddp) - 4);\n\n\t\t/* Now fill in the long header */\n\n\t\t/*\n\t\t * These two first. The mac overlays the new source/dest\n\t\t * network information so we MUST copy these before\n\t\t * we write the network numbers !\n\t\t */\n\n\t\tddp->deh_dnode = skb_mac_header(skb)[0];     /* From physical header */\n\t\tddp->deh_snode = skb_mac_header(skb)[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\t/* Non routable, so force a drop if we slip up later */\n\t\tddp->deh_len_hops = htons(skb->len + (DDP_MAXHOPS << 10));\n\t}\n\tskb_reset_transport_header(skb);\n\n\treturn atalk_rcv(skb, dev, pt, orig_dev);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int atalk_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_at *, usat, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size, hard_header_len;\n\tstruct atalk_route *rt, *rt_lo = NULL;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\tif (usat) {\n\t\terr = -EBUSY;\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\tgoto out;\n\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\tgoto out;\n\n\t\terr = -EPERM;\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\terr = -ENETUNREACH;\n\tif (!rt)\n\t\tgoto out;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\thard_header_len = dev->hard_header_len;\n\t/* Leave room for loopback hardware header if necessary */\n\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t    (dev->flags & IFF_LOOPBACK || !(rt->flags & RTF_GATEWAY))) {\n\t\tstruct atalk_addr at_lo;\n\n\t\tat_lo.s_node = 0;\n\t\tat_lo.s_net  = 0;\n\n\t\trt_lo = atrtr_find(&at_lo);\n\n\t\tif (rt_lo && rt_lo->dev->hard_header_len > hard_header_len)\n\t\t\thard_header_len = rt_lo->dev->hard_header_len;\n\t}\n\n\tsize += hard_header_len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%zd bytes).\\n\", sk, len);\n\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_no_check_tx)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\t/*\n\t\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t\t */\n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tif (!rt_lo) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\terr = -ENETUNREACH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdev = rt_lo->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t/*\n\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t */\n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%zd).\\n\", sk, len);\n\nout:\n\trelease_sock(sk);\n\treturn err ? : len;\n}\n\nstatic int atalk_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_msg(skb, offset, msg, copied);\n\n\tif (!err && msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_at *, sat, msg->msg_name);\n\t\tsat->sat_family      = AF_APPLETALK;\n\t\tsat->sat_port        = ddp->deh_sport;\n\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\tmsg->msg_namelen     = sizeof(*sat);\n\t}\n\n\tskb_free_datagram(sk, skb);\t/* Free the datagram. */\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n\n\n/*\n * AppleTalk ioctl calls.\n */\nstatic int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\t/* Protocol layer */\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\t/*\n\t\t * These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here\n\t\t */\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\t/* Interface */\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t/* proxy AARP */\n\tcase SIOCDARP:\t\t/* proxy AARP */\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_COMPAT\nstatic int atalk_compat_routing_ioctl(struct sock *sk, unsigned int cmd,\n\t\tstruct compat_rtentry __user *ur)\n{\n\tcompat_uptr_t rtdev;\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt.rt_dst, &ur->rt_dst,\n\t\t\t3 * sizeof(struct sockaddr)) ||\n\t    get_user(rt.rt_flags, &ur->rt_flags) ||\n\t    get_user(rt.rt_metric, &ur->rt_metric) ||\n\t    get_user(rt.rt_mtu, &ur->rt_mtu) ||\n\t    get_user(rt.rt_window, &ur->rt_window) ||\n\t    get_user(rt.rt_irtt, &ur->rt_irtt) ||\n\t    get_user(rtdev, &ur->rt_dev))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\trt.rt_dev = compat_ptr(rtdev);\n\t\treturn atrtr_ioctl_addrt(&rt);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nstatic int atalk_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn atalk_compat_routing_ioctl(sk, cmd, argp);\n\t/*\n\t * SIOCATALKDIFADDR is a SIOCPROTOPRIVATE ioctl number, so we\n\t * cannot handle it in common code. The data we access if ifreq\n\t * here is compatible, so we can simply call the native\n\t * handler.\n\t */\n\tcase SIOCATALKDIFADDR:\n\t\treturn atalk_ioctl(sock, cmd, (unsigned long)argp);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif /* CONFIG_COMPAT */\n\n\nstatic const struct net_proto_family atalk_family_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.create\t\t= atalk_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops atalk_dgram_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= atalk_release,\n\t.bind\t\t= atalk_bind,\n\t.connect\t= atalk_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= atalk_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= atalk_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= atalk_compat_ioctl,\n#endif\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.sendmsg\t= atalk_sendmsg,\n\t.recvmsg\t= atalk_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\nstatic struct notifier_block ddp_notifier = {\n\t.notifier_call\t= ddp_device_event,\n};\n\nstatic struct packet_type ltalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_LOCALTALK),\n\t.func\t\t= ltalk_rcv,\n};\n\nstatic struct packet_type ppptalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_PPPTALK),\n\t.func\t\t= atalk_rcv,\n};\n\nstatic unsigned char ddp_snap_id[] = { 0x08, 0x00, 0x07, 0x80, 0x9B };\n\n/* Export symbols for use by drivers when AppleTalk is a module */\nEXPORT_SYMBOL(atrtr_get_dev);\nEXPORT_SYMBOL(atalk_find_dev_addr);\n\n/* Called by proto.c on kernel start up */\nstatic int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl) {\n\t\tpr_crit(\"Unable to register DDP with SNAP.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_sock;\n\t}\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_snap;\n\n\trc = aarp_proto_init();\n\tif (rc)\n\t\tgoto out_dev;\n\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\nout_dev:\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_snap:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\nout_sock:\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}\nmodule_init(atalk_init);\n\n/*\n * No explicit module reference count manipulation is needed in the\n * protocol. Socket layer sets module reference count for us\n * and interfaces reference counting is done\n * by the network device layer.\n *\n * Ergo, before the AppleTalk module can be removed, all AppleTalk\n * sockets should be closed from user space.\n */\nstatic void __exit atalk_exit(void)\n{\n#ifdef CONFIG_SYSCTL\n\tatalk_unregister_sysctl();\n#endif /* CONFIG_SYSCTL */\n\tatalk_proc_exit();\n\taarp_cleanup_module();\t/* General aarp clean-up. */\n\tunregister_netdevice_notifier(&ddp_notifier);\n\tdev_remove_pack(&ltalk_packet_type);\n\tdev_remove_pack(&ppptalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\n\tproto_unregister(&ddp_proto);\n}\nmodule_exit(atalk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alan Cox <alan@lxorguk.ukuu.org.uk>\");\nMODULE_DESCRIPTION(\"AppleTalk 0.20\\n\");\nMODULE_ALIAS_NETPROTO(PF_APPLETALK);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\tDDP:\tAn implementation of the AppleTalk DDP protocol for\n *\t\tEthernet 'ELAP'.\n *\n *\t\tAlan Cox  <alan@lxorguk.ukuu.org.uk>\n *\n *\t\tWith more than a little assistance from\n *\n *\t\tWesley Craig <netatalk@umich.edu>\n *\n *\tFixes:\n *\t\tNeil Horman\t\t:\tAdded missing device ioctls\n *\t\tMichael Callahan\t:\tMade routing work\n *\t\tWesley Craig\t\t:\tFix probing to listen to a\n *\t\t\t\t\t\tpassed node id.\n *\t\tAlan Cox\t\t:\tAdded send/recvmsg support\n *\t\tAlan Cox\t\t:\tMoved at. to protinfo in\n *\t\t\t\t\t\tsocket.\n *\t\tAlan Cox\t\t:\tAdded firewall hooks.\n *\t\tAlan Cox\t\t:\tSupports new ARPHRD_LOOPBACK\n *\t\tChrister Weinigel\t: \tRouting and /proc fixes.\n *\t\tBradford Johnson\t:\tLocalTalk.\n *\t\tTom Dyas\t\t:\tModule support.\n *\t\tAlan Cox\t\t:\tHooks for PPP (based on the\n *\t\t\t\t\t\tLocalTalk hook).\n *\t\tAlan Cox\t\t:\tPosix bits\n *\t\tAlan Cox/Mike Freeman\t:\tPossible fix to NBP problems\n *\t\tBradford Johnson\t:\tIP-over-DDP (experimental)\n *\t\tJay Schulist\t\t:\tMoved IP-over-DDP to its own\n *\t\t\t\t\t\tdriver file. (ipddp.c & ipddp.h)\n *\t\tJay Schulist\t\t:\tMade work as module with\n *\t\t\t\t\t\tAppleTalk drivers, cleaned it.\n *\t\tRob Newberry\t\t:\tAdded proxy AARP and AARP\n *\t\t\t\t\t\tprocfs, moved probing to AARP\n *\t\t\t\t\t\tmodule.\n *              Adrian Sun/\n *              Michael Zuelsdorff      :       fix for net.0 packets. don't\n *                                              allow illegal ether/tokentalk\n *                                              port assignment. we lose a\n *                                              valid localtalk port as a\n *                                              result.\n *\t\tArnaldo C. de Melo\t:\tCleanup, in preparation for\n *\t\t\t\t\t\tshared skb support 8)\n *\t\tArnaldo C. de Melo\t:\tMove proc stuff to atalk_proc.c,\n *\t\t\t\t\t\tuse seq_file\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/termios.h>\t/* For TIOCOUTQ/INQ */\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <net/datalink.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/route.h>\n#include <net/compat.h>\n#include <linux/atalk.h>\n#include <linux/highmem.h>\n\nstruct datalink_proto *ddp_dl, *aarp_dl;\nstatic const struct proto_ops atalk_dgram_ops;\n\n/**************************************************************************\\\n*                                                                          *\n* Handlers for the socket list.                                            *\n*                                                                          *\n\\**************************************************************************/\n\nHLIST_HEAD(atalk_sockets);\nDEFINE_RWLOCK(atalk_sockets_lock);\n\nstatic inline void __atalk_insert_socket(struct sock *sk)\n{\n\tsk_add_node(sk, &atalk_sockets);\n}\n\nstatic inline void atalk_remove_socket(struct sock *sk)\n{\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&atalk_sockets_lock);\n}\n\nstatic struct sock *atalk_search_socket(struct sockaddr_at *to,\n\t\t\t\t\tstruct atalk_iface *atif)\n{\n\tstruct sock *s;\n\n\tread_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\tif (to->sat_port != at->src_port)\n\t\t\tcontinue;\n\n\t\tif (to->sat_addr.s_net == ATADDR_ANYNET &&\n\t\t    to->sat_addr.s_node == ATADDR_BCAST)\n\t\t\tgoto found;\n\n\t\tif (to->sat_addr.s_net == at->src_net &&\n\t\t    (to->sat_addr.s_node == at->src_node ||\n\t\t     to->sat_addr.s_node == ATADDR_BCAST ||\n\t\t     to->sat_addr.s_node == ATADDR_ANYNODE))\n\t\t\tgoto found;\n\n\t\t/* XXXX.0 -- we got a request for this router. make sure\n\t\t * that the node is appropriately set. */\n\t\tif (to->sat_addr.s_node == ATADDR_ANYNODE &&\n\t\t    to->sat_addr.s_net != ATADDR_ANYNET &&\n\t\t    atif->address.s_node == at->src_node) {\n\t\t\tto->sat_addr.s_node = atif->address.s_node;\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tread_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\n/**\n * atalk_find_or_insert_socket - Try to find a socket matching ADDR\n * @sk: socket to insert in the list if it is not there already\n * @sat: address to search for\n *\n * Try to find a socket matching ADDR in the socket list, if found then return\n * it. If not, insert SK into the socket list.\n *\n * This entire operation must execute atomically.\n */\nstatic struct sock *atalk_find_or_insert_socket(struct sock *sk,\n\t\t\t\t\t\tstruct sockaddr_at *sat)\n{\n\tstruct sock *s;\n\tstruct atalk_sock *at;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tat = at_sk(s);\n\n\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t    at->src_port == sat->sat_port)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\n\t__atalk_insert_socket(sk); /* Wheee, it's free, assign and insert. */\nfound:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\nstatic void atalk_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tif (sk_has_allocations(sk)) {\n\t\tsk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\nstatic inline void atalk_destroy_socket(struct sock *sk)\n{\n\tatalk_remove_socket(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (sk_has_allocations(sk)) {\n\t\ttimer_setup(&sk->sk_timer, atalk_destroy_timer, 0);\n\t\tsk->sk_timer.expires\t= jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/**************************************************************************\\\n*                                                                          *\n* Routing tables for the AppleTalk socket layer.                           *\n*                                                                          *\n\\**************************************************************************/\n\n/* Anti-deadlock ordering is atalk_routes_lock --> iface_lock -DaveM */\nstruct atalk_route *atalk_routes;\nDEFINE_RWLOCK(atalk_routes_lock);\n\nstruct atalk_iface *atalk_interfaces;\nDEFINE_RWLOCK(atalk_interfaces_lock);\n\n/* For probing devices or in a routerless network */\nstruct atalk_route atrtr_default;\n\n/* AppleTalk interface control */\n/*\n * Drop a device. Doesn't drop any of its routes - that is the caller's\n * problem. Called when we down the interface or delete the address.\n */\nstatic void atif_drop_device(struct net_device *dev)\n{\n\tstruct atalk_iface **iface = &atalk_interfaces;\n\tstruct atalk_iface *tmp;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\twhile ((tmp = *iface) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*iface = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t\tdev->atalk_ptr = NULL;\n\t\t} else\n\t\t\tiface = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_interfaces_lock);\n}\n\nstatic struct atalk_iface *atif_add_device(struct net_device *dev,\n\t\t\t\t\t   struct atalk_addr *sa)\n{\n\tstruct atalk_iface *iface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\n\tif (!iface)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tiface->dev = dev;\n\tdev->atalk_ptr = iface;\n\tiface->address = *sa;\n\tiface->status = 0;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\tiface->next = atalk_interfaces;\n\tatalk_interfaces = iface;\n\twrite_unlock_bh(&atalk_interfaces_lock);\nout:\n\treturn iface;\n}\n\n/* Perform phase 2 AARP probing on our tentative address */\nstatic int atif_probe_device(struct atalk_iface *atif)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = atif->address.s_node;\n\tint netct, nodect;\n\n\t/* Offset the network we start probing with */\n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t/* Scan the networks */\n\tatif->status |= ATIF_PROBE;\n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t/* Sweep the available nodes from a given start */\n\t\tatif->address.s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tatif->address.s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (atif->address.s_node > 0 &&\n\t\t\t    atif->address.s_node < 254) {\n\t\t\t\t/* Probe a proposed address */\n\t\t\t\taarp_probe_network(atif);\n\n\t\t\t\tif (!(atif->status & ATIF_PROBE_FAIL)) {\n\t\t\t\t\tatif->status &= ~ATIF_PROBE;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tatif->status &= ~ATIF_PROBE_FAIL;\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\tatif->status &= ~ATIF_PROBE;\n\n\treturn -EADDRINUSE;\t/* Network is full... */\n}\n\n\n/* Perform AARP probing for a proxy address */\nstatic int atif_proxy_probe_device(struct atalk_iface *atif,\n\t\t\t\t   struct atalk_addr *proxy_addr)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\t/* we probe the interface's network */\n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = ATADDR_ANYNODE;\t    /* we'll take anything */\n\tint netct, nodect;\n\n\t/* Offset the network we start probing with */\n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t/* Scan the networks */\n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t/* Sweep the available nodes from a given start */\n\t\tproxy_addr->s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tproxy_addr->s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (proxy_addr->s_node > 0 &&\n\t\t\t    proxy_addr->s_node < 254) {\n\t\t\t\t/* Tell AARP to probe a proposed address */\n\t\t\t\tint ret = aarp_proxy_probe_network(atif,\n\t\t\t\t\t\t\t\t    proxy_addr);\n\n\t\t\t\tif (ret != -EADDRINUSE)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\n\treturn -EADDRINUSE;\t/* Network is full... */\n}\n\n\nstruct atalk_addr *atalk_find_dev_addr(struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\treturn iface ? &iface->address : NULL;\n}\n\nstatic struct atalk_addr *atalk_find_primary(void)\n{\n\tstruct atalk_iface *fiface = NULL;\n\tstruct atalk_addr *retval;\n\tstruct atalk_iface *iface;\n\n\t/*\n\t * Return a point-to-point interface only if\n\t * there is no non-ptp interface available.\n\t */\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif (!fiface && !(iface->dev->flags & IFF_LOOPBACK))\n\t\t\tfiface = iface;\n\t\tif (!(iface->dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))) {\n\t\t\tretval = &iface->address;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fiface)\n\t\tretval = &fiface->address;\n\telse if (atalk_interfaces)\n\t\tretval = &atalk_interfaces->address;\n\telse\n\t\tretval = NULL;\nout:\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn retval;\n}\n\n/*\n * Find a match for 'any network' - ie any of our interfaces with that\n * node number will do just nicely.\n */\nstatic struct atalk_iface *atalk_find_anynet(int node, struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\n\tif (!iface || iface->status & ATIF_PROBE)\n\t\tgoto out_err;\n\n\tif (node != ATADDR_BCAST &&\n\t    iface->address.s_node != node &&\n\t    node != ATADDR_ANYNODE)\n\t\tgoto out_err;\nout:\n\treturn iface;\nout_err:\n\tiface = NULL;\n\tgoto out;\n}\n\n/* Find a match for a specific network:node pair */\nstatic struct atalk_iface *atalk_find_interface(__be16 net, int node)\n{\n\tstruct atalk_iface *iface;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif ((node == ATADDR_BCAST ||\n\t\t     node == ATADDR_ANYNODE ||\n\t\t     iface->address.s_node == node) &&\n\t\t    iface->address.s_net == net &&\n\t\t    !(iface->status & ATIF_PROBE))\n\t\t\tbreak;\n\n\t\t/* XXXX.0 -- net.0 returns the iface associated with net */\n\t\tif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\n\t\t    ntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\n\t\t    ntohs(net) <= ntohs(iface->nets.nr_lastnet))\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn iface;\n}\n\n\n/*\n * Find a route for an AppleTalk packet. This ought to get cached in\n * the socket (later on...). We know about host routes and the fact\n * that a route must be direct to broadcast.\n */\nstatic struct atalk_route *atrtr_find(struct atalk_addr *target)\n{\n\t/*\n\t * we must search through all routes unless we find a\n\t * host route, because some host routes might overlap\n\t * network routes\n\t */\n\tstruct atalk_route *net_route = NULL;\n\tstruct atalk_route *r;\n\n\tread_lock_bh(&atalk_routes_lock);\n\tfor (r = atalk_routes; r; r = r->next) {\n\t\tif (!(r->flags & RTF_UP))\n\t\t\tcontinue;\n\n\t\tif (r->target.s_net == target->s_net) {\n\t\t\tif (r->flags & RTF_HOST) {\n\t\t\t\t/*\n\t\t\t\t * if this host route is for the target,\n\t\t\t\t * the we're done\n\t\t\t\t */\n\t\t\t\tif (r->target.s_node == target->s_node)\n\t\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * this route will work if there isn't a\n\t\t\t\t * direct host route, so cache it\n\t\t\t\t */\n\t\t\t\tnet_route = r;\n\t\t}\n\t}\n\n\t/*\n\t * if we found a network route but not a direct host\n\t * route, then return it\n\t */\n\tif (net_route)\n\t\tr = net_route;\n\telse if (atrtr_default.dev)\n\t\tr = &atrtr_default;\n\telse /* No route can be found */\n\t\tr = NULL;\nout:\n\tread_unlock_bh(&atalk_routes_lock);\n\treturn r;\n}\n\n\n/*\n * Given an AppleTalk network, find the device to use. This can be\n * a simple lookup.\n */\nstruct net_device *atrtr_get_dev(struct atalk_addr *sa)\n{\n\tstruct atalk_route *atr = atrtr_find(sa);\n\treturn atr ? atr->dev : NULL;\n}\n\n/* Set up a default router */\nstatic void atrtr_set_default(struct net_device *dev)\n{\n\tatrtr_default.dev\t     = dev;\n\tatrtr_default.flags\t     = RTF_UP;\n\tatrtr_default.gateway.s_net  = htons(0);\n\tatrtr_default.gateway.s_node = 0;\n}\n\n/*\n * Add a router. Basically make sure it looks valid and stuff the\n * entry in the list. While it uses netranges we always set them to one\n * entry to work like netatalk.\n */\nstatic int atrtr_create(struct rtentry *r, struct net_device *devhint)\n{\n\tstruct sockaddr_at *ta = (struct sockaddr_at *)&r->rt_dst;\n\tstruct sockaddr_at *ga = (struct sockaddr_at *)&r->rt_gateway;\n\tstruct atalk_route *rt;\n\tstruct atalk_iface *iface, *riface;\n\tint retval = -EINVAL;\n\n\t/*\n\t * Fixme: Raise/Lower a routing change semaphore for these\n\t * operations.\n\t */\n\n\t/* Validate the request */\n\tif (ta->sat_family != AF_APPLETALK ||\n\t    (!devhint && ga->sat_family != AF_APPLETALK))\n\t\tgoto out;\n\n\t/* Now walk the routing table and make our decisions */\n\twrite_lock_bh(&atalk_routes_lock);\n\tfor (rt = atalk_routes; rt; rt = rt->next) {\n\t\tif (r->rt_flags != rt->flags)\n\t\t\tcontinue;\n\n\t\tif (ta->sat_addr.s_net == rt->target.s_net) {\n\t\t\tif (!(rt->flags & RTF_HOST))\n\t\t\t\tbreak;\n\t\t\tif (ta->sat_addr.s_node == rt->target.s_node)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!devhint) {\n\t\triface = NULL;\n\n\t\tread_lock_bh(&atalk_interfaces_lock);\n\t\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\t\tif (!riface &&\n\t\t\t    ntohs(ga->sat_addr.s_net) >=\n\t\t\t\t\tntohs(iface->nets.nr_firstnet) &&\n\t\t\t    ntohs(ga->sat_addr.s_net) <=\n\t\t\t\t\tntohs(iface->nets.nr_lastnet))\n\t\t\t\triface = iface;\n\n\t\t\tif (ga->sat_addr.s_net == iface->address.s_net &&\n\t\t\t    ga->sat_addr.s_node == iface->address.s_node)\n\t\t\t\triface = iface;\n\t\t}\n\t\tread_unlock_bh(&atalk_interfaces_lock);\n\n\t\tretval = -ENETUNREACH;\n\t\tif (!riface)\n\t\t\tgoto out_unlock;\n\n\t\tdevhint = riface->dev;\n\t}\n\n\tif (!rt) {\n\t\trt = kzalloc(sizeof(*rt), GFP_ATOMIC);\n\n\t\tretval = -ENOBUFS;\n\t\tif (!rt)\n\t\t\tgoto out_unlock;\n\n\t\trt->next = atalk_routes;\n\t\tatalk_routes = rt;\n\t}\n\n\t/* Fill in the routing entry */\n\trt->target  = ta->sat_addr;\n\tdev_hold(devhint);\n\trt->dev     = devhint;\n\trt->flags   = r->rt_flags;\n\trt->gateway = ga->sat_addr;\n\n\tretval = 0;\nout_unlock:\n\twrite_unlock_bh(&atalk_routes_lock);\nout:\n\treturn retval;\n}\n\n/* Delete a route. Find it and discard it */\nstatic int atrtr_delete(struct atalk_addr *addr)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tint retval = 0;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->target.s_net == addr->s_net &&\n\t\t    (!(tmp->flags&RTF_GATEWAY) ||\n\t\t     tmp->target.s_node == addr->s_node)) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(tmp->dev);\n\t\t\tkfree(tmp);\n\t\t\tgoto out;\n\t\t}\n\t\tr = &tmp->next;\n\t}\n\tretval = -ENOENT;\nout:\n\twrite_unlock_bh(&atalk_routes_lock);\n\treturn retval;\n}\n\n/*\n * Called when a device is downed. Just throw away any routes\n * via it.\n */\nstatic void atrtr_device_down(struct net_device *dev)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tr = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_routes_lock);\n\n\tif (atrtr_default.dev == dev)\n\t\tatrtr_set_default(NULL);\n}\n\n/* Actually down the interface */\nstatic inline void atalk_dev_down(struct net_device *dev)\n{\n\tatrtr_device_down(dev);\t/* Remove all routes for the device */\n\taarp_device_down(dev);\t/* Remove AARP entries for the device */\n\tatif_drop_device(dev);\t/* Remove the device */\n}\n\n/*\n * A device event has occurred. Watch for devices going down and\n * delete our use of them (iface and route).\n */\nstatic int ddp_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_DOWN)\n\t\t/* Discard any use of this */\n\t\tatalk_dev_down(dev);\n\n\treturn NOTIFY_DONE;\n}\n\n/* ioctl calls. Shouldn't even need touching */\n/* Device configuration ioctl calls */\nstatic int atif_ioctl(int cmd, void __user *arg)\n{\n\tstatic char aarp_mcast[6] = { 0x09, 0x00, 0x00, 0xFF, 0xFF, 0xFF };\n\tstruct ifreq atreq;\n\tstruct atalk_netrange *nr;\n\tstruct sockaddr_at *sa;\n\tstruct net_device *dev;\n\tstruct atalk_iface *atif;\n\tint ct;\n\tint limit;\n\tstruct rtentry rtdef;\n\tint add_route;\n\n\tif (get_user_ifreq(&atreq, NULL, arg))\n\t\treturn -EFAULT;\n\n\tdev = __dev_get_by_name(&init_net, atreq.ifr_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tsa = (struct sockaddr_at *)&atreq.ifr_addr;\n\tatif = atalk_find_dev(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (dev->type != ARPHRD_ETHER &&\n\t\t    dev->type != ARPHRD_LOOPBACK &&\n\t\t    dev->type != ARPHRD_LOCALTLK &&\n\t\t    dev->type != ARPHRD_PPP)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tnr = (struct atalk_netrange *)&sa->sat_zero[0];\n\t\tadd_route = 1;\n\n\t\t/*\n\t\t * if this is a point-to-point iface, and we already\n\t\t * have an iface for this AppleTalk address, then we\n\t\t * should not add a route\n\t\t */\n\t\tif ((dev->flags & IFF_POINTOPOINT) &&\n\t\t    atalk_find_interface(sa->sat_addr.s_net,\n\t\t\t\t\t sa->sat_addr.s_node)) {\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: point-to-point \"\n\t\t\t       \"interface added with \"\n\t\t\t       \"existing address\\n\");\n\t\t\tadd_route = 0;\n\t\t}\n\n\t\t/*\n\t\t * Phase 1 is fine on LocalTalk but we don't do\n\t\t * EtherTalk phase 1. Anyone wanting to add it, go ahead.\n\t\t */\n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\t\tif (atif) {\n\t\t\t/* Already setting address */\n\t\t\tif (atif->status & ATIF_PROBE)\n\t\t\t\treturn -EBUSY;\n\n\t\t\tatif->address.s_net  = sa->sat_addr.s_net;\n\t\t\tatif->address.s_node = sa->sat_addr.s_node;\n\t\t\tatrtr_device_down(dev);\t/* Flush old routes */\n\t\t} else {\n\t\t\tatif = atif_add_device(dev, &sa->sat_addr);\n\t\t\tif (!atif)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tatif->nets = *nr;\n\n\t\t/*\n\t\t * Check if the chosen address is used. If so we\n\t\t * error and atalkd will try another.\n\t\t */\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) &&\n\t\t    !(dev->flags & IFF_POINTOPOINT) &&\n\t\t    atif_probe_device(atif) < 0) {\n\t\t\tatif_drop_device(dev);\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\n\t\t/* Hey it worked - add the direct routes */\n\t\tsa = (struct sockaddr_at *)&rtdef.rt_gateway;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net  = atif->address.s_net;\n\t\tsa->sat_addr.s_node = atif->address.s_node;\n\t\tsa = (struct sockaddr_at *)&rtdef.rt_dst;\n\t\trtdef.rt_flags = RTF_UP;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_node = ATADDR_ANYNODE;\n\t\tif (dev->flags & IFF_LOOPBACK ||\n\t\t    dev->flags & IFF_POINTOPOINT)\n\t\t\trtdef.rt_flags |= RTF_HOST;\n\n\t\t/* Routerless initial state */\n\t\tif (nr->nr_firstnet == htons(0) &&\n\t\t    nr->nr_lastnet == htons(0xFFFE)) {\n\t\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\t\tatrtr_create(&rtdef, dev);\n\t\t\tatrtr_set_default(dev);\n\t\t} else {\n\t\t\tlimit = ntohs(nr->nr_lastnet);\n\t\t\tif (limit - ntohs(nr->nr_firstnet) > 4096) {\n\t\t\t\tprintk(KERN_WARNING \"Too many routes/\"\n\t\t\t\t       \"iface.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (add_route)\n\t\t\t\tfor (ct = ntohs(nr->nr_firstnet);\n\t\t\t\t     ct <= limit; ct++) {\n\t\t\t\t\tsa->sat_addr.s_net = htons(ct);\n\t\t\t\t\tatrtr_create(&rtdef, dev);\n\t\t\t\t}\n\t\t}\n\t\tdev_mc_add_global(dev, aarp_mcast);\n\t\treturn 0;\n\n\tcase SIOCGIFADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr = atif->address;\n\t\tbreak;\n\n\tcase SIOCGIFBRDADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\tsa->sat_addr.s_node = ATADDR_BCAST;\n\t\tbreak;\n\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tatalk_dev_down(dev);\n\t\tbreak;\n\n\tcase SIOCSARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * for now, we only support proxy AARP on ELAP;\n\t\t * we should be able to do it for LocalTalk, too.\n\t\t */\n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\t/*\n\t\t * atif points to the current interface on this network;\n\t\t * we aren't concerned about its current status (at\n\t\t * least for now), but it has all the settings about\n\t\t * the network we're going to probe. Consequently, it\n\t\t * must exist.\n\t\t */\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tnr = (struct atalk_netrange *)&(atif->nets);\n\t\t/*\n\t\t * Phase 1 is fine on Localtalk but we don't do\n\t\t * Ethertalk phase 1. Anyone wanting to add it, go ahead.\n\t\t */\n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Check if the chosen address is used. If so we\n\t\t * error and ATCP will try another.\n\t\t */\n\t\tif (atif_proxy_probe_device(atif, &(sa->sat_addr)) < 0)\n\t\t\treturn -EADDRINUSE;\n\n\t\t/*\n\t\t * We now have an address on the local network, and\n\t\t * the AARP code will defend it for us until we take it\n\t\t * down. We don't set up any routes right now, because\n\t\t * ATCP will install them manually via SIOCADDRT.\n\t\t */\n\t\tbreak;\n\n\tcase SIOCDARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t/* give to aarp module to remove proxy entry */\n\t\taarp_proxy_remove(atif->dev, &(sa->sat_addr));\n\t\treturn 0;\n\t}\n\n\treturn put_user_ifreq(&atreq, arg);\n}\n\nstatic int atrtr_ioctl_addrt(struct rtentry *rt)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (rt->rt_dev) {\n\t\tchar name[IFNAMSIZ];\n\n\t\tif (copy_from_user(name, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\t\tname[IFNAMSIZ-1] = '\\0';\n\n\t\tdev = __dev_get_by_name(&init_net, name);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t}\n\treturn atrtr_create(rt, dev);\n}\n\n/* Routing ioctl() calls */\nstatic int atrtr_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\treturn atrtr_ioctl_addrt(&rt);\n\t}\n\treturn -EINVAL;\n}\n\n/**************************************************************************\\\n*                                                                          *\n* Handling for system calls applied via the various interfaces to an       *\n* AppleTalk socket object.                                                 *\n*                                                                          *\n\\**************************************************************************/\n\n/*\n * Checksum: This is 'optional'. It's quite likely also a good\n * candidate for assembler hackery 8)\n */\nstatic unsigned long atalk_sum_partial(const unsigned char *data,\n\t\t\t\t       int len, unsigned long sum)\n{\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data++;\n\t\tsum = rol16(sum, 1);\n\t}\n\treturn sum;\n}\n\n/*  Checksum skb data --  similar to skb_checksum  */\nstatic unsigned long atalk_sum_skb(const struct sk_buff *skb, int offset,\n\t\t\t\t   int len, unsigned long sum)\n{\n\tint start = skb_headlen(skb);\n\tstruct sk_buff *frag_iter;\n\tint i, copy;\n\n\t/* checksum stuff in header space */\n\tif ((copy = start - offset) > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tsum = atalk_sum_partial(skb->data + offset, copy, sum);\n\t\tif ((len -= copy) == 0)\n\t\t\treturn sum;\n\n\t\toffset += copy;\n\t}\n\n\t/* checksum stuff in frags */\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tu8 *vaddr;\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tvaddr = kmap_atomic(skb_frag_page(frag));\n\t\t\tsum = atalk_sum_partial(vaddr + skb_frag_off(frag) +\n\t\t\t\t\t\toffset - start, copy, sum);\n\t\t\tkunmap_atomic(vaddr);\n\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tsum = atalk_sum_skb(frag_iter, offset - start,\n\t\t\t\t\t    copy, sum);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tBUG_ON(len > 0);\n\n\treturn sum;\n}\n\nstatic __be16 atalk_checksum(const struct sk_buff *skb, int len)\n{\n\tunsigned long sum;\n\n\t/* skip header 4 bytes */\n\tsum = atalk_sum_skb(skb, 4, len-4, 0);\n\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : htons(0xFFFF);\n}\n\nstatic struct proto ddp_proto = {\n\t.name\t  = \"DDP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct atalk_sock),\n};\n\n/*\n * Create a socket. Initialise the socket, blank the addresses\n * set the state.\n */\nstatic int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}\n\n/* Free a socket. No work needed */\nstatic int atalk_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\n\t\tsock_orphan(sk);\n\t\tsock->sk = NULL;\n\t\tatalk_destroy_socket(sk);\n\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n\treturn 0;\n}\n\n/**\n * atalk_pick_and_bind_port - Pick a source port when one is not given\n * @sk: socket to insert into the tables\n * @sat: address to search for\n *\n * Pick a source port when one is not given. If we can find a suitable free\n * one, we insert the socket into the tables using it.\n *\n * This whole operation must be atomic.\n */\nstatic int atalk_pick_and_bind_port(struct sock *sk, struct sockaddr_at *sat)\n{\n\tint retval;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\n\tfor (sat->sat_port = ATPORT_RESERVED;\n\t     sat->sat_port < ATPORT_LAST;\n\t     sat->sat_port++) {\n\t\tstruct sock *s;\n\n\t\tsk_for_each(s, &atalk_sockets) {\n\t\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t\t    at->src_port == sat->sat_port)\n\t\t\t\tgoto try_next_port;\n\t\t}\n\n\t\t/* Wheee, it's free, assign and insert. */\n\t\t__atalk_insert_socket(sk);\n\t\tat_sk(sk)->src_port = sat->sat_port;\n\t\tretval = 0;\n\t\tgoto out;\n\ntry_next_port:;\n\t}\n\n\tretval = -EBUSY;\nout:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn retval;\n}\n\nstatic int atalk_autobind(struct sock *sk)\n{\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at sat;\n\tstruct atalk_addr *ap = atalk_find_primary();\n\tint n = -EADDRNOTAVAIL;\n\n\tif (!ap || ap->s_net == htons(ATADDR_ANYNET))\n\t\tgoto out;\n\n\tat->src_net  = sat.sat_addr.s_net  = ap->s_net;\n\tat->src_node = sat.sat_addr.s_node = ap->s_node;\n\n\tn = atalk_pick_and_bind_port(sk, &sat);\n\tif (!n)\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\treturn n;\n}\n\n/* Set the address 'our end' of the connection */\nstatic int atalk_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_at *addr = (struct sockaddr_at *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED) ||\n\t    addr_len != sizeof(struct sockaddr_at))\n\t\treturn -EINVAL;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tlock_sock(sk);\n\tif (addr->sat_addr.s_net == htons(ATADDR_ANYNET)) {\n\t\tstruct atalk_addr *ap = atalk_find_primary();\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ap)\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net = ap->s_net;\n\t\tat->src_node = addr->sat_addr.s_node = ap->s_node;\n\t} else {\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!atalk_find_interface(addr->sat_addr.s_net,\n\t\t\t\t\t  addr->sat_addr.s_node))\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net;\n\t\tat->src_node = addr->sat_addr.s_node;\n\t}\n\n\tif (addr->sat_port == ATADDR_ANYPORT) {\n\t\terr = atalk_pick_and_bind_port(sk, addr);\n\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tat->src_port = addr->sat_port;\n\n\t\terr = -EADDRINUSE;\n\t\tif (atalk_find_or_insert_socket(sk, addr))\n\t\t\tgoto out;\n\t}\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* Set the address we talk to */\nstatic int atalk_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *addr;\n\tint err;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tif (addr_len != sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr = (struct sockaddr_at *)uaddr;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (addr->sat_addr.s_node == ATADDR_BCAST &&\n\t    !sock_flag(sk, SOCK_BROADCAST)) {\n#if 1\n\t\tpr_warn(\"atalk_connect: %s is broken and did not set SO_BROADCAST.\\n\",\n\t\t\tcurrent->comm);\n#else\n\t\treturn -EACCES;\n#endif\n\t}\n\n\tlock_sock(sk);\n\terr = -EBUSY;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\terr = -ENETUNREACH;\n\tif (!atrtr_get_dev(&addr->sat_addr))\n\t\tgoto out;\n\n\tat->dest_port = addr->sat_port;\n\tat->dest_net  = addr->sat_addr.s_net;\n\tat->dest_node = addr->sat_addr.s_node;\n\n\tsock->state  = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/*\n * Find the name of an AppleTalk socket. Just copy the right\n * fields into the sockaddr.\n */\nstatic int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tlock_sock(sk);\n\terr = -ENOBUFS;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\tmemset(&sat, 0, sizeof(sat));\n\n\tif (peer) {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\terr = sizeof(struct sockaddr_at);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)\n{\n\tstruct atalk_route *rt;\n\tstruct atalk_addr ta;\n\n\t/*\n\t * Don't route multicast, etc., packets, or packets sent to \"this\n\t * network\"\n\t */\n\tif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\n\t\t/*\n\t\t * FIXME:\n\t\t *\n\t\t * Can it ever happen that a packet is from a PPP iface and\n\t\t * needs to be broadcast onto the default network?\n\t\t */\n\t\tif (dev->type == ARPHRD_PPP)\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: didn't forward broadcast \"\n\t\t\t\t\t  \"packet received from PPP iface\\n\");\n\t\tgoto free_it;\n\t}\n\n\tta.s_net  = ddp->deh_dnet;\n\tta.s_node = ddp->deh_dnode;\n\n\t/* Route the packet */\n\trt = atrtr_find(&ta);\n\t/* increment hops count */\n\tlen_hops += 1 << 10;\n\tif (!rt || !(len_hops & (15 << 10)))\n\t\tgoto free_it;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\n\t/*\n\t * Route goes through another gateway, so set the target to the\n\t * gateway instead.\n\t */\n\n\tif (rt->flags & RTF_GATEWAY) {\n\t\tta.s_net  = rt->gateway.s_net;\n\t\tta.s_node = rt->gateway.s_node;\n\t}\n\n\t/* Fix up skb->len field */\n\tskb_trim(skb, min_t(unsigned int, origlen,\n\t\t\t    (rt->dev->hard_header_len +\n\t\t\t     ddp_dl->header_length + (len_hops & 1023))));\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp->deh_len_hops = htons(len_hops);\n\n\t/*\n\t * Send the buffer onwards\n\t *\n\t * Now we must always be careful. If it's come from LocalTalk to\n\t * EtherTalk it might not fit\n\t *\n\t * Order matters here: If a packet has to be copied to make a new\n\t * headroom (rare hopefully) then it won't need unsharing.\n\t *\n\t * Note. ddp-> becomes invalid at the realloc.\n\t */\n\tif (skb_headroom(skb) < 22) {\n\t\t/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */\n\t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t} else\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\n\t/*\n\t * If the buffer didn't vanish into the lack of space bitbucket we can\n\t * send it.\n\t */\n\tif (skb == NULL)\n\t\tgoto drop;\n\n\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\n\t\treturn NET_RX_DROP;\n\treturn NET_RX_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_RX_DROP;\n}\n\n/**\n *\tatalk_rcv - Receive a packet (in skb) from device dev\n *\t@skb: packet received\n *\t@dev: network device where the packet comes from\n *\t@pt: packet type\n *\t@orig_dev: the original receive net device\n *\n *\tReceive a packet (in skb) from device dev. This has come from the SNAP\n *\tdecoder, and on entry skb->transport_header is the DDP header, skb->len\n *\tis the DDP header, skb->len is the DDP length. The physical headers\n *\thave been extracted. PPP should probably pass frames marked as for this\n *\tlayer.  [ie ARPHRD_ETHERTALK]\n */\nstatic int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ddpehdr *ddp;\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n\tint origlen;\n\t__u16 len_hops;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Don't mangle buffer if shared */\n\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\tgoto out;\n\n\t/* Size check and make sure header is contiguous */\n\tif (!pskb_may_pull(skb, sizeof(*ddp)))\n\t\tgoto drop;\n\n\tddp = ddp_hdr(skb);\n\n\tlen_hops = ntohs(ddp->deh_len_hops);\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of atalk_checksum() or recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\n\t\tpr_debug(\"AppleTalk: dropping corrupted frame (deh_len=%u, \"\n\t\t\t \"skb->len=%u)\\n\", len_hops & 1023, skb->len);\n\t\tgoto drop;\n\t}\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto drop;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\tif (!atif) {\n\t\t/* Not ours, so we route the packet via the correct\n\t\t * AppleTalk iface\n\t\t */\n\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\n\t}\n\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto drop;\n\n\t/* Queue packet (standard) */\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto drop;\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n\n}\n\n/*\n * Receive a LocalTalk frame. We make some demands on the caller here.\n * Caller must provide enough headroom on the packet to pull the short\n * header and append a long one.\n */\nstatic int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto freeit;\n\n\t/* Expand any short form frames */\n\tif (skb_mac_header(skb)[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(__be16) || skb->len > 1023)\n\t\t\tgoto freeit;\n\n\t\t/* Don't mangle buffer if shared */\n\t\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\t\tddp = skb_push(skb, sizeof(*ddp) - 4);\n\n\t\t/* Now fill in the long header */\n\n\t\t/*\n\t\t * These two first. The mac overlays the new source/dest\n\t\t * network information so we MUST copy these before\n\t\t * we write the network numbers !\n\t\t */\n\n\t\tddp->deh_dnode = skb_mac_header(skb)[0];     /* From physical header */\n\t\tddp->deh_snode = skb_mac_header(skb)[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\t/* Non routable, so force a drop if we slip up later */\n\t\tddp->deh_len_hops = htons(skb->len + (DDP_MAXHOPS << 10));\n\t}\n\tskb_reset_transport_header(skb);\n\n\treturn atalk_rcv(skb, dev, pt, orig_dev);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int atalk_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_at *, usat, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size, hard_header_len;\n\tstruct atalk_route *rt, *rt_lo = NULL;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\tif (usat) {\n\t\terr = -EBUSY;\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\tgoto out;\n\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\tgoto out;\n\n\t\terr = -EPERM;\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\terr = -ENETUNREACH;\n\tif (!rt)\n\t\tgoto out;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\thard_header_len = dev->hard_header_len;\n\t/* Leave room for loopback hardware header if necessary */\n\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t    (dev->flags & IFF_LOOPBACK || !(rt->flags & RTF_GATEWAY))) {\n\t\tstruct atalk_addr at_lo;\n\n\t\tat_lo.s_node = 0;\n\t\tat_lo.s_net  = 0;\n\n\t\trt_lo = atrtr_find(&at_lo);\n\n\t\tif (rt_lo && rt_lo->dev->hard_header_len > hard_header_len)\n\t\t\thard_header_len = rt_lo->dev->hard_header_len;\n\t}\n\n\tsize += hard_header_len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%zd bytes).\\n\", sk, len);\n\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_no_check_tx)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\t/*\n\t\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t\t */\n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tif (!rt_lo) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\terr = -ENETUNREACH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdev = rt_lo->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t/*\n\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t */\n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%zd).\\n\", sk, len);\n\nout:\n\trelease_sock(sk);\n\treturn err ? : len;\n}\n\nstatic int atalk_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_msg(skb, offset, msg, copied);\n\n\tif (!err && msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_at *, sat, msg->msg_name);\n\t\tsat->sat_family      = AF_APPLETALK;\n\t\tsat->sat_port        = ddp->deh_sport;\n\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\tmsg->msg_namelen     = sizeof(*sat);\n\t}\n\n\tskb_free_datagram(sk, skb);\t/* Free the datagram. */\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n\n\n/*\n * AppleTalk ioctl calls.\n */\nstatic int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\t/* Protocol layer */\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\t/* Interface */\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t/* proxy AARP */\n\tcase SIOCDARP:\t\t/* proxy AARP */\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_COMPAT\nstatic int atalk_compat_routing_ioctl(struct sock *sk, unsigned int cmd,\n\t\tstruct compat_rtentry __user *ur)\n{\n\tcompat_uptr_t rtdev;\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt.rt_dst, &ur->rt_dst,\n\t\t\t3 * sizeof(struct sockaddr)) ||\n\t    get_user(rt.rt_flags, &ur->rt_flags) ||\n\t    get_user(rt.rt_metric, &ur->rt_metric) ||\n\t    get_user(rt.rt_mtu, &ur->rt_mtu) ||\n\t    get_user(rt.rt_window, &ur->rt_window) ||\n\t    get_user(rt.rt_irtt, &ur->rt_irtt) ||\n\t    get_user(rtdev, &ur->rt_dev))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\trt.rt_dev = compat_ptr(rtdev);\n\t\treturn atrtr_ioctl_addrt(&rt);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nstatic int atalk_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn atalk_compat_routing_ioctl(sk, cmd, argp);\n\t/*\n\t * SIOCATALKDIFADDR is a SIOCPROTOPRIVATE ioctl number, so we\n\t * cannot handle it in common code. The data we access if ifreq\n\t * here is compatible, so we can simply call the native\n\t * handler.\n\t */\n\tcase SIOCATALKDIFADDR:\n\t\treturn atalk_ioctl(sock, cmd, (unsigned long)argp);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif /* CONFIG_COMPAT */\n\n\nstatic const struct net_proto_family atalk_family_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.create\t\t= atalk_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops atalk_dgram_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= atalk_release,\n\t.bind\t\t= atalk_bind,\n\t.connect\t= atalk_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= atalk_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= atalk_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= atalk_compat_ioctl,\n#endif\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.sendmsg\t= atalk_sendmsg,\n\t.recvmsg\t= atalk_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\nstatic struct notifier_block ddp_notifier = {\n\t.notifier_call\t= ddp_device_event,\n};\n\nstatic struct packet_type ltalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_LOCALTALK),\n\t.func\t\t= ltalk_rcv,\n};\n\nstatic struct packet_type ppptalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_PPPTALK),\n\t.func\t\t= atalk_rcv,\n};\n\nstatic unsigned char ddp_snap_id[] = { 0x08, 0x00, 0x07, 0x80, 0x9B };\n\n/* Export symbols for use by drivers when AppleTalk is a module */\nEXPORT_SYMBOL(atrtr_get_dev);\nEXPORT_SYMBOL(atalk_find_dev_addr);\n\n/* Called by proto.c on kernel start up */\nstatic int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl) {\n\t\tpr_crit(\"Unable to register DDP with SNAP.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_sock;\n\t}\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_snap;\n\n\trc = aarp_proto_init();\n\tif (rc)\n\t\tgoto out_dev;\n\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\nout_dev:\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_snap:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\nout_sock:\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}\nmodule_init(atalk_init);\n\n/*\n * No explicit module reference count manipulation is needed in the\n * protocol. Socket layer sets module reference count for us\n * and interfaces reference counting is done\n * by the network device layer.\n *\n * Ergo, before the AppleTalk module can be removed, all AppleTalk\n * sockets should be closed from user space.\n */\nstatic void __exit atalk_exit(void)\n{\n#ifdef CONFIG_SYSCTL\n\tatalk_unregister_sysctl();\n#endif /* CONFIG_SYSCTL */\n\tatalk_proc_exit();\n\taarp_cleanup_module();\t/* General aarp clean-up. */\n\tunregister_netdevice_notifier(&ddp_notifier);\n\tdev_remove_pack(&ltalk_packet_type);\n\tdev_remove_pack(&ppptalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\n\tproto_unregister(&ddp_proto);\n}\nmodule_exit(atalk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alan Cox <alan@lxorguk.ukuu.org.uk>\");\nMODULE_DESCRIPTION(\"AppleTalk 0.20\\n\");\nMODULE_ALIAS_NETPROTO(PF_APPLETALK);\n"], "filenames": ["net/appletalk/ddp.c"], "buggy_code_start_loc": [1778], "buggy_code_end_loc": [1786], "fixing_code_start_loc": [1778], "fixing_code_end_loc": [1786], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition.", "other": {"cve": {"id": "CVE-2023-51781", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-11T19:15:12.553", "lastModified": "2024-01-18T19:58:50.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el kernel de Linux anterior a 6.6.8. atalk_ioctl en net/appletalk/ddp.c tiene un use after free debido a una condici\u00f3n de ejecuci\u00f3n atalk_recvmsg."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartExcluding": "2.6.12", "versionEndExcluding": "6.6.8", "matchCriteriaId": "C5C35A7D-82A5-436F-925A-384D92679784"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "4F76C298-81DC-43E4-8FC9-DC005A2116EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "0AB349B2-3F78-4197-882B-90ADB3BF645A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc4:*:*:*:*:*:*", "matchCriteriaId": "6AC88830-A9BC-4607-B572-A4B502FC9FD0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc5:*:*:*:*:*:*", "matchCriteriaId": "476CB3A5-D022-4F13-AAEF-CB6A5785516A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc6:*:*:*:*:*:*", "matchCriteriaId": "8CFD5CDD-1709-44C7-82BD-BAFDC46990D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "3A0038DE-E183-4958-A6E3-CE3821FEAFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc2:*:*:*:*:*:*", "matchCriteriaId": "E31AD4FC-436C-44AB-BCAB-3A0B37F69EE0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc3:*:*:*:*:*:*", "matchCriteriaId": "C56C6E04-4F04-44A3-8DB8-93899903CFCF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc4:*:*:*:*:*:*", "matchCriteriaId": "5C78EDA4-8BE6-42FC-9512-49032D525A55"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc5:*:*:*:*:*:*", "matchCriteriaId": "32F2E5CA-13C6-4601-B530-D465CBF73D1C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.6.8", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/189ff16722ee36ced4d2a2469d4ab65a8fee4198", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00005.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/189ff16722ee36ced4d2a2469d4ab65a8fee4198"}}