{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/bitstream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/codec/zgfx.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n/**\n * RDP8 Compressor Limits:\n *\n * Maximum number of uncompressed bytes in a single segment: 65535\n * Maximum match distance / minimum history size: 2500000 bytes.\n * Maximum number of segments: 65535\n * Maximum expansion of a segment (when compressed size exceeds uncompressed): 1000 bytes\n * Minimum match length: 3 bytes\n */\n\nstruct _ZGFX_TOKEN\n{\n\tUINT32 prefixLength;\n\tUINT32 prefixCode;\n\tUINT32 valueBits;\n\tUINT32 tokenType;\n\tUINT32 valueBase;\n};\ntypedef struct _ZGFX_TOKEN ZGFX_TOKEN;\n\nstruct _ZGFX_CONTEXT\n{\n\tBOOL Compressor;\n\n\tconst BYTE* pbInputCurrent;\n\tconst BYTE* pbInputEnd;\n\n\tUINT32 bits;\n\tUINT32 cBitsRemaining;\n\tUINT32 BitsCurrent;\n\tUINT32 cBitsCurrent;\n\n\tBYTE OutputBuffer[65536];\n\tUINT32 OutputCount;\n\n\tBYTE HistoryBuffer[2500000];\n\tUINT32 HistoryIndex;\n\tUINT32 HistoryBufferSize;\n};\n\nstatic const ZGFX_TOKEN ZGFX_TOKEN_TABLE[] = {\n\t// len code vbits type  vbase\n\t{ 1, 0, 8, 0, 0 },           // 0\n\t{ 5, 17, 5, 1, 0 },          // 10001\n\t{ 5, 18, 7, 1, 32 },         // 10010\n\t{ 5, 19, 9, 1, 160 },        // 10011\n\t{ 5, 20, 10, 1, 672 },       // 10100\n\t{ 5, 21, 12, 1, 1696 },      // 10101\n\t{ 5, 24, 0, 0, 0x00 },       // 11000\n\t{ 5, 25, 0, 0, 0x01 },       // 11001\n\t{ 6, 44, 14, 1, 5792 },      // 101100\n\t{ 6, 45, 15, 1, 22176 },     // 101101\n\t{ 6, 52, 0, 0, 0x02 },       // 110100\n\t{ 6, 53, 0, 0, 0x03 },       // 110101\n\t{ 6, 54, 0, 0, 0xFF },       // 110110\n\t{ 7, 92, 18, 1, 54944 },     // 1011100\n\t{ 7, 93, 20, 1, 317088 },    // 1011101\n\t{ 7, 110, 0, 0, 0x04 },      // 1101110\n\t{ 7, 111, 0, 0, 0x05 },      // 1101111\n\t{ 7, 112, 0, 0, 0x06 },      // 1110000\n\t{ 7, 113, 0, 0, 0x07 },      // 1110001\n\t{ 7, 114, 0, 0, 0x08 },      // 1110010\n\t{ 7, 115, 0, 0, 0x09 },      // 1110011\n\t{ 7, 116, 0, 0, 0x0A },      // 1110100\n\t{ 7, 117, 0, 0, 0x0B },      // 1110101\n\t{ 7, 118, 0, 0, 0x3A },      // 1110110\n\t{ 7, 119, 0, 0, 0x3B },      // 1110111\n\t{ 7, 120, 0, 0, 0x3C },      // 1111000\n\t{ 7, 121, 0, 0, 0x3D },      // 1111001\n\t{ 7, 122, 0, 0, 0x3E },      // 1111010\n\t{ 7, 123, 0, 0, 0x3F },      // 1111011\n\t{ 7, 124, 0, 0, 0x40 },      // 1111100\n\t{ 7, 125, 0, 0, 0x80 },      // 1111101\n\t{ 8, 188, 20, 1, 1365664 },  // 10111100\n\t{ 8, 189, 21, 1, 2414240 },  // 10111101\n\t{ 8, 252, 0, 0, 0x0C },      // 11111100\n\t{ 8, 253, 0, 0, 0x38 },      // 11111101\n\t{ 8, 254, 0, 0, 0x39 },      // 11111110\n\t{ 8, 255, 0, 0, 0x66 },      // 11111111\n\t{ 9, 380, 22, 1, 4511392 },  // 101111100\n\t{ 9, 381, 23, 1, 8705696 },  // 101111101\n\t{ 9, 382, 24, 1, 17094304 }, // 101111110\n\t{ 0 }\n};\n\nstatic INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)\n{\n\tif (!_zgfx)\n\t\treturn FALSE;\n\n\twhile (_zgfx->cBitsCurrent < _nbits)\n\t{\n\t\t_zgfx->BitsCurrent <<= 8;\n\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;\n\n\t\t_zgfx->cBitsCurrent += 8;\n\t}\n\n\t_zgfx->cBitsRemaining -= _nbits;\n\t_zgfx->cBitsCurrent -= _nbits;\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n\treturn TRUE;\n}\n\nstatic void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n{\n\tUINT32 front;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}\n\nstatic void zgfx_history_buffer_ring_read(ZGFX_CONTEXT* zgfx, int offset, BYTE* dst, UINT32 count)\n{\n\tUINT32 front;\n\tUINT32 index;\n\tINT32 bytes;\n\tUINT32 valid;\n\tINT32 bytesLeft;\n\tBYTE* dptr = dst;\n\tBYTE* origDst = dst;\n\n\tif ((count <= 0) || (count > INT32_MAX))\n\t\treturn;\n\n\tbytesLeft = (INT32)count;\n\tindex = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;\n\tbytes = MIN(bytesLeft, offset);\n\n\tif ((index + bytes) <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), bytes);\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - index;\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), front);\n\t\tCopyMemory(&dptr[front], zgfx->HistoryBuffer, bytes - front);\n\t}\n\n\tif ((bytesLeft -= bytes) == 0)\n\t\treturn;\n\n\tdptr += bytes;\n\tvalid = bytes;\n\n\tdo\n\t{\n\t\tbytes = valid;\n\n\t\tif (bytes > bytesLeft)\n\t\t\tbytes = bytesLeft;\n\n\t\tCopyMemory(dptr, origDst, bytes);\n\t\tdptr += bytes;\n\t\tvalid <<= 1;\n\t} while ((bytesLeft -= bytes) > 0);\n}\n\nstatic BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tUINT32 haveBits;\n\tUINT32 inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment;\n\n\tif (!zgfx || !stream)\n\t\treturn FALSE;\n\n\tcbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||\n\t    (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\n\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(\n\t\t\t\t\t\t    zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(\n\t\t\t\t\t\t    zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent,\n\t\t\t\t\t\t           count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/* Allocate the buffers a bit larger.\n *\n * Due to optimizations some h264 decoders will read data beyond\n * the actual available data, so ensure that it will never be a\n * out of bounds read.\n */\nstatic BYTE* aligned_zgfx_malloc(size_t size)\n{\n\treturn malloc(size + 64);\n}\n\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor;\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\n\t\t*ppDstData = NULL;\n\n\t\tif (zgfx->OutputCount > 0)\n\t\t\t*ppDstData = aligned_zgfx_malloc(zgfx->OutputCount);\n\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n\t\tUINT16 segmentCount;\n\t\tUINT32 uncompressedSize;\n\t\tBYTE* pConcatenated;\n\t\tsize_t used = 0;\n\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount);     /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\n\t\tpConcatenated = aligned_zgfx_malloc(uncompressedSize);\n\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\n\t\t\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\t\t\tgoto fail;\n\n\t\t\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\t\t\tgoto fail;\n\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t\tused += zgfx->OutputCount;\n\t\t}\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}\n\nstatic BOOL zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,\n                                  UINT32 SrcSize, UINT32* pFlags)\n{\n\t/* FIXME: Currently compression not implemented. Just copy the raw source */\n\tif (!Stream_EnsureRemainingCapacity(s, SrcSize + 1))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn FALSE;\n\t}\n\n\t(*pFlags) |= ZGFX_PACKET_COMPR_TYPE_RDP8; /* RDP 8.0 compression format */\n\tStream_Write_UINT8(s, (*pFlags));         /* header (1 byte) */\n\tStream_Write(s, pSrcData, SrcSize);\n\treturn TRUE;\n}\n\nint zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,\n                            UINT32 uncompressedSize, UINT32* pFlags)\n{\n\tint fragment;\n\tUINT16 maxLength;\n\tUINT32 totalLength;\n\tsize_t posSegmentCount = 0;\n\tconst BYTE* pSrcData;\n\tint status = 0;\n\tmaxLength = ZGFX_SEGMENTED_MAXSIZE;\n\ttotalLength = uncompressedSize;\n\tpSrcData = pUncompressed;\n\n\tfor (fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)\n\t{\n\t\tUINT32 SrcSize;\n\t\tsize_t posDstSize;\n\t\tsize_t posDataStart;\n\t\tUINT32 DstSize;\n\t\tSrcSize = (totalLength > maxLength) ? maxLength : totalLength;\n\t\tposDstSize = 0;\n\t\ttotalLength -= SrcSize;\n\n\t\t/* Ensure we have enough space for headers */\n\t\tif (!Stream_EnsureRemainingCapacity(sDst, 12))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (fragment == 0)\n\t\t{\n\t\t\t/* First fragment */\n\t\t\t/* descriptor (1 byte) */\n\t\t\tStream_Write_UINT8(sDst, (totalLength == 0) ? ZGFX_SEGMENTED_SINGLE\n\t\t\t                                            : ZGFX_SEGMENTED_MULTIPART);\n\n\t\t\tif (totalLength > 0)\n\t\t\t{\n\t\t\t\tposSegmentCount = Stream_GetPosition(sDst); /* segmentCount (2 bytes) */\n\t\t\t\tStream_Seek(sDst, 2);\n\t\t\t\tStream_Write_UINT32(sDst, uncompressedSize); /* uncompressedSize (4 bytes) */\n\t\t\t}\n\t\t}\n\n\t\tif (fragment > 0 || totalLength > 0)\n\t\t{\n\t\t\t/* Multipart */\n\t\t\tposDstSize = Stream_GetPosition(sDst); /* size (4 bytes) */\n\t\t\tStream_Seek(sDst, 4);\n\t\t}\n\n\t\tposDataStart = Stream_GetPosition(sDst);\n\n\t\tif (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))\n\t\t\treturn -1;\n\n\t\tif (posDstSize)\n\t\t{\n\t\t\t/* Fill segment data size */\n\t\t\tDstSize = Stream_GetPosition(sDst) - posDataStart;\n\t\t\tStream_SetPosition(sDst, posDstSize);\n\t\t\tStream_Write_UINT32(sDst, DstSize);\n\t\t\tStream_SetPosition(sDst, posDataStart + DstSize);\n\t\t}\n\n\t\tpSrcData += SrcSize;\n\t}\n\n\tStream_SealLength(sDst);\n\n\t/* fill back segmentCount */\n\tif (posSegmentCount)\n\t{\n\t\tStream_SetPosition(sDst, posSegmentCount);\n\t\tStream_Write_UINT16(sDst, fragment);\n\t\tStream_SetPosition(sDst, Stream_Length(sDst));\n\t}\n\n\treturn status;\n}\n\nint zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                  UINT32* pDstSize, UINT32* pFlags)\n{\n\tint status;\n\twStream* s = Stream_New(NULL, SrcSize);\n\tstatus = zgfx_compress_to_stream(zgfx, s, pSrcData, SrcSize, pFlags);\n\t(*ppDstData) = Stream_Buffer(s);\n\t(*pDstSize) = Stream_GetPosition(s);\n\tStream_Free(s, FALSE);\n\treturn status;\n}\n\nvoid zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush)\n{\n\tzgfx->HistoryIndex = 0;\n}\n\nZGFX_CONTEXT* zgfx_context_new(BOOL Compressor)\n{\n\tZGFX_CONTEXT* zgfx;\n\tzgfx = (ZGFX_CONTEXT*)calloc(1, sizeof(ZGFX_CONTEXT));\n\n\tif (zgfx)\n\t{\n\t\tzgfx->Compressor = Compressor;\n\t\tzgfx->HistoryBufferSize = sizeof(zgfx->HistoryBuffer);\n\t\tzgfx_context_reset(zgfx, FALSE);\n\t}\n\n\treturn zgfx;\n}\n\nvoid zgfx_context_free(ZGFX_CONTEXT* zgfx)\n{\n\tfree(zgfx);\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/bitstream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/codec/zgfx.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n/**\n * RDP8 Compressor Limits:\n *\n * Maximum number of uncompressed bytes in a single segment: 65535\n * Maximum match distance / minimum history size: 2500000 bytes.\n * Maximum number of segments: 65535\n * Maximum expansion of a segment (when compressed size exceeds uncompressed): 1000 bytes\n * Minimum match length: 3 bytes\n */\n\nstruct _ZGFX_TOKEN\n{\n\tUINT32 prefixLength;\n\tUINT32 prefixCode;\n\tUINT32 valueBits;\n\tUINT32 tokenType;\n\tUINT32 valueBase;\n};\ntypedef struct _ZGFX_TOKEN ZGFX_TOKEN;\n\nstruct _ZGFX_CONTEXT\n{\n\tBOOL Compressor;\n\n\tconst BYTE* pbInputCurrent;\n\tconst BYTE* pbInputEnd;\n\n\tUINT32 bits;\n\tUINT32 cBitsRemaining;\n\tUINT32 BitsCurrent;\n\tUINT32 cBitsCurrent;\n\n\tBYTE OutputBuffer[65536];\n\tUINT32 OutputCount;\n\n\tBYTE HistoryBuffer[2500000];\n\tUINT32 HistoryIndex;\n\tUINT32 HistoryBufferSize;\n};\n\nstatic const ZGFX_TOKEN ZGFX_TOKEN_TABLE[] = {\n\t// len code vbits type  vbase\n\t{ 1, 0, 8, 0, 0 },           // 0\n\t{ 5, 17, 5, 1, 0 },          // 10001\n\t{ 5, 18, 7, 1, 32 },         // 10010\n\t{ 5, 19, 9, 1, 160 },        // 10011\n\t{ 5, 20, 10, 1, 672 },       // 10100\n\t{ 5, 21, 12, 1, 1696 },      // 10101\n\t{ 5, 24, 0, 0, 0x00 },       // 11000\n\t{ 5, 25, 0, 0, 0x01 },       // 11001\n\t{ 6, 44, 14, 1, 5792 },      // 101100\n\t{ 6, 45, 15, 1, 22176 },     // 101101\n\t{ 6, 52, 0, 0, 0x02 },       // 110100\n\t{ 6, 53, 0, 0, 0x03 },       // 110101\n\t{ 6, 54, 0, 0, 0xFF },       // 110110\n\t{ 7, 92, 18, 1, 54944 },     // 1011100\n\t{ 7, 93, 20, 1, 317088 },    // 1011101\n\t{ 7, 110, 0, 0, 0x04 },      // 1101110\n\t{ 7, 111, 0, 0, 0x05 },      // 1101111\n\t{ 7, 112, 0, 0, 0x06 },      // 1110000\n\t{ 7, 113, 0, 0, 0x07 },      // 1110001\n\t{ 7, 114, 0, 0, 0x08 },      // 1110010\n\t{ 7, 115, 0, 0, 0x09 },      // 1110011\n\t{ 7, 116, 0, 0, 0x0A },      // 1110100\n\t{ 7, 117, 0, 0, 0x0B },      // 1110101\n\t{ 7, 118, 0, 0, 0x3A },      // 1110110\n\t{ 7, 119, 0, 0, 0x3B },      // 1110111\n\t{ 7, 120, 0, 0, 0x3C },      // 1111000\n\t{ 7, 121, 0, 0, 0x3D },      // 1111001\n\t{ 7, 122, 0, 0, 0x3E },      // 1111010\n\t{ 7, 123, 0, 0, 0x3F },      // 1111011\n\t{ 7, 124, 0, 0, 0x40 },      // 1111100\n\t{ 7, 125, 0, 0, 0x80 },      // 1111101\n\t{ 8, 188, 20, 1, 1365664 },  // 10111100\n\t{ 8, 189, 21, 1, 2414240 },  // 10111101\n\t{ 8, 252, 0, 0, 0x0C },      // 11111100\n\t{ 8, 253, 0, 0, 0x38 },      // 11111101\n\t{ 8, 254, 0, 0, 0x39 },      // 11111110\n\t{ 8, 255, 0, 0, 0x66 },      // 11111111\n\t{ 9, 380, 22, 1, 4511392 },  // 101111100\n\t{ 9, 381, 23, 1, 8705696 },  // 101111101\n\t{ 9, 382, 24, 1, 17094304 }, // 101111110\n\t{ 0 }\n};\n\nstatic INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)\n{\n\tif (!_zgfx)\n\t\treturn FALSE;\n\n\twhile (_zgfx->cBitsCurrent < _nbits)\n\t{\n\t\t_zgfx->BitsCurrent <<= 8;\n\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;\n\n\t\t_zgfx->cBitsCurrent += 8;\n\t}\n\n\t_zgfx->cBitsRemaining -= _nbits;\n\t_zgfx->cBitsCurrent -= _nbits;\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n\treturn TRUE;\n}\n\nstatic void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n{\n\tUINT32 front;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}\n\nstatic void zgfx_history_buffer_ring_read(ZGFX_CONTEXT* zgfx, int offset, BYTE* dst, UINT32 count)\n{\n\tUINT32 front;\n\tUINT32 index;\n\tINT32 bytes;\n\tUINT32 valid;\n\tINT32 bytesLeft;\n\tBYTE* dptr = dst;\n\tBYTE* origDst = dst;\n\n\tif ((count <= 0) || (count > INT32_MAX))\n\t\treturn;\n\n\tbytesLeft = (INT32)count;\n\tindex = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;\n\tbytes = MIN(bytesLeft, offset);\n\n\tif ((index + bytes) <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), bytes);\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - index;\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), front);\n\t\tCopyMemory(&dptr[front], zgfx->HistoryBuffer, bytes - front);\n\t}\n\n\tif ((bytesLeft -= bytes) == 0)\n\t\treturn;\n\n\tdptr += bytes;\n\tvalid = bytes;\n\n\tdo\n\t{\n\t\tbytes = valid;\n\n\t\tif (bytes > bytesLeft)\n\t\t\tbytes = bytesLeft;\n\n\t\tCopyMemory(dptr, origDst, bytes);\n\t\tdptr += bytes;\n\t\tvalid <<= 1;\n\t} while ((bytesLeft -= bytes) > 0);\n}\n\nstatic BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tUINT32 haveBits;\n\tUINT32 inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment;\n\n\tif (!zgfx || !stream || (segmentSize < 2))\n\t\treturn FALSE;\n\n\tcbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tif (!Stream_SafeSeek(stream, cbSegment))\n\t\treturn FALSE;\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\n\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(\n\t\t\t\t\t\t    zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(\n\t\t\t\t\t\t    zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tif (count > zgfx->cBitsRemaining / 8)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent,\n\t\t\t\t\t\t           count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/* Allocate the buffers a bit larger.\n *\n * Due to optimizations some h264 decoders will read data beyond\n * the actual available data, so ensure that it will never be a\n * out of bounds read.\n */\nstatic BYTE* aligned_zgfx_malloc(size_t size)\n{\n\treturn malloc(size + 64);\n}\n\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor;\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\n\t\t*ppDstData = NULL;\n\n\t\tif (zgfx->OutputCount > 0)\n\t\t\t*ppDstData = aligned_zgfx_malloc(zgfx->OutputCount);\n\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n\t\tUINT16 segmentCount;\n\t\tUINT32 uncompressedSize;\n\t\tBYTE* pConcatenated;\n\t\tsize_t used = 0;\n\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount);     /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\n\t\tpConcatenated = aligned_zgfx_malloc(uncompressedSize);\n\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\n\t\t\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\t\t\tgoto fail;\n\n\t\t\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\t\t\tgoto fail;\n\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t\tused += zgfx->OutputCount;\n\t\t}\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}\n\nstatic BOOL zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,\n                                  UINT32 SrcSize, UINT32* pFlags)\n{\n\t/* FIXME: Currently compression not implemented. Just copy the raw source */\n\tif (!Stream_EnsureRemainingCapacity(s, SrcSize + 1))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn FALSE;\n\t}\n\n\t(*pFlags) |= ZGFX_PACKET_COMPR_TYPE_RDP8; /* RDP 8.0 compression format */\n\tStream_Write_UINT8(s, (*pFlags));         /* header (1 byte) */\n\tStream_Write(s, pSrcData, SrcSize);\n\treturn TRUE;\n}\n\nint zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,\n                            UINT32 uncompressedSize, UINT32* pFlags)\n{\n\tint fragment;\n\tUINT16 maxLength;\n\tUINT32 totalLength;\n\tsize_t posSegmentCount = 0;\n\tconst BYTE* pSrcData;\n\tint status = 0;\n\tmaxLength = ZGFX_SEGMENTED_MAXSIZE;\n\ttotalLength = uncompressedSize;\n\tpSrcData = pUncompressed;\n\n\tfor (fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)\n\t{\n\t\tUINT32 SrcSize;\n\t\tsize_t posDstSize;\n\t\tsize_t posDataStart;\n\t\tUINT32 DstSize;\n\t\tSrcSize = (totalLength > maxLength) ? maxLength : totalLength;\n\t\tposDstSize = 0;\n\t\ttotalLength -= SrcSize;\n\n\t\t/* Ensure we have enough space for headers */\n\t\tif (!Stream_EnsureRemainingCapacity(sDst, 12))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (fragment == 0)\n\t\t{\n\t\t\t/* First fragment */\n\t\t\t/* descriptor (1 byte) */\n\t\t\tStream_Write_UINT8(sDst, (totalLength == 0) ? ZGFX_SEGMENTED_SINGLE\n\t\t\t                                            : ZGFX_SEGMENTED_MULTIPART);\n\n\t\t\tif (totalLength > 0)\n\t\t\t{\n\t\t\t\tposSegmentCount = Stream_GetPosition(sDst); /* segmentCount (2 bytes) */\n\t\t\t\tStream_Seek(sDst, 2);\n\t\t\t\tStream_Write_UINT32(sDst, uncompressedSize); /* uncompressedSize (4 bytes) */\n\t\t\t}\n\t\t}\n\n\t\tif (fragment > 0 || totalLength > 0)\n\t\t{\n\t\t\t/* Multipart */\n\t\t\tposDstSize = Stream_GetPosition(sDst); /* size (4 bytes) */\n\t\t\tStream_Seek(sDst, 4);\n\t\t}\n\n\t\tposDataStart = Stream_GetPosition(sDst);\n\n\t\tif (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))\n\t\t\treturn -1;\n\n\t\tif (posDstSize)\n\t\t{\n\t\t\t/* Fill segment data size */\n\t\t\tDstSize = Stream_GetPosition(sDst) - posDataStart;\n\t\t\tStream_SetPosition(sDst, posDstSize);\n\t\t\tStream_Write_UINT32(sDst, DstSize);\n\t\t\tStream_SetPosition(sDst, posDataStart + DstSize);\n\t\t}\n\n\t\tpSrcData += SrcSize;\n\t}\n\n\tStream_SealLength(sDst);\n\n\t/* fill back segmentCount */\n\tif (posSegmentCount)\n\t{\n\t\tStream_SetPosition(sDst, posSegmentCount);\n\t\tStream_Write_UINT16(sDst, fragment);\n\t\tStream_SetPosition(sDst, Stream_Length(sDst));\n\t}\n\n\treturn status;\n}\n\nint zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                  UINT32* pDstSize, UINT32* pFlags)\n{\n\tint status;\n\twStream* s = Stream_New(NULL, SrcSize);\n\tstatus = zgfx_compress_to_stream(zgfx, s, pSrcData, SrcSize, pFlags);\n\t(*ppDstData) = Stream_Buffer(s);\n\t(*pDstSize) = Stream_GetPosition(s);\n\tStream_Free(s, FALSE);\n\treturn status;\n}\n\nvoid zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush)\n{\n\tzgfx->HistoryIndex = 0;\n}\n\nZGFX_CONTEXT* zgfx_context_new(BOOL Compressor)\n{\n\tZGFX_CONTEXT* zgfx;\n\tzgfx = (ZGFX_CONTEXT*)calloc(1, sizeof(ZGFX_CONTEXT));\n\n\tif (zgfx)\n\t{\n\t\tzgfx->Compressor = Compressor;\n\t\tzgfx->HistoryBufferSize = sizeof(zgfx->HistoryBuffer);\n\t\tzgfx_context_reset(zgfx, FALSE);\n\t}\n\n\treturn zgfx;\n}\n\nvoid zgfx_context_free(ZGFX_CONTEXT* zgfx)\n{\n\tfree(zgfx);\n}\n"], "filenames": ["libfreerdp/codec/zgfx.c"], "buggy_code_start_loc": [233], "buggy_code_end_loc": [348], "fixing_code_start_loc": [233], "fixing_code_end_loc": [352], "type": "CWE-125", "message": "FreeRDP is a free remote desktop protocol library and clients. In affected versions there is an out of bound read in ZGFX decoder component of FreeRDP. A malicious server can trick a FreeRDP based client to read out of bound data and try to decode it likely resulting in a crash. This issue has been addressed in the 2.9.0 release. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2022-39316", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-16T20:15:10.180", "lastModified": "2023-01-25T19:56:05.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free remote desktop protocol library and clients. In affected versions there is an out of bound read in ZGFX decoder component of FreeRDP. A malicious server can trick a FreeRDP based client to read out of bound data and try to decode it likely resulting in a crash. This issue has been addressed in the 2.9.0 release. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.0", "matchCriteriaId": "AF273D61-AA72-44FE-937E-D5749D565AEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/e865c24efc40ebc52e75979c94cdd4ee2c1495b0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-5w4j-mrrh-jjrm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/e865c24efc40ebc52e75979c94cdd4ee2c1495b0"}}