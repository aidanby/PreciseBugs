{"buggy_code": ["<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Zend Db wrapper\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2014 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-07-27\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\nuse Laminas\\Db\\Adapter\\Driver\\DriverInterface;\nuse Laminas\\Db\\Adapter\\Driver\\ConnectionInterface;\nuse Laminas\\Db\\Adapter\\Platform\\PlatformInterface;\nuse Laminas\\Db\\Adapter\\Driver\\StatementInterface;\nuse Laminas\\Db\\Sql\\Insert;\nuse Laminas\\Db\\Sql\\Update;\nuse Laminas\\Db\\Sql\\Select;\nuse Laminas\\Db\\Sql\\Delete;\nuse Laminas\\Db\\ResultSet;\nuse Laminas\\Db\\Sql\\Sql;\nuse Laminas\\Db\\Sql\\SqlInterface;\n\n/**\n * Zend Db wrapper\n *\n * @category  Core\n * @name      Db\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://framework.zend.com/apidoc/2.2/namespaces/Zend.Db.html\n * @since     Available since 0.7dev - 2011-07-27\n *\n * @property Adapter $db\n * @property Sql $sql\n * @property DriverInterface $driver\n * @property ConnectionInterface $connection\n * @property PlatformInterface $platform\n * @property string $query_string\n * @property string $type_db\n */\nclass Db\n{\n    /** @var Adapter */\n    private $db;\n    /** @var string */\n    private $type_db;\n    /** @var Sql */\n    private $sql;\n    /** @var array */\n    private $options;\n    /** @var string */\n    private $last_query;\n\n    public const MYSQL = 'mysql';\n    public const PGSQL = 'pgsql';\n\n    public const MYSQL_DEFAULT_PORT = 3306;\n    public const PGSQL_DEFAULT_PORT = 5432;\n\n    /**\n     * Main constructor\n     *\n     * @param array $dsn Connection information\n     *                   If not set, database constants will be used.\n     */\n    public function __construct($dsn = null)\n    {\n        $_type = null;\n\n        if ($dsn !== null && is_array($dsn)) {\n            $_type_db = $dsn['TYPE_DB'];\n            $_host_db = $dsn['HOST_DB'];\n            $_port_db = $dsn['PORT_DB'];\n            $_user_db = $dsn['USER_DB'];\n            $_pwd_db = $dsn['PWD_DB'];\n            $_name_db = $dsn['NAME_DB'];\n        } else {\n            $_type_db = TYPE_DB;\n            $_host_db = HOST_DB;\n            $_port_db = PORT_DB;\n            $_user_db = USER_DB;\n            $_pwd_db = PWD_DB;\n            $_name_db = NAME_DB;\n        }\n\n        try {\n            if ($_type_db === self::MYSQL) {\n                $_type = 'Pdo_Mysql';\n            } elseif ($_type_db === self::PGSQL) {\n                $_type = 'Pdo_Pgsql';\n            } else {\n                throw new \\Exception(\"Type $_type_db not known (dsn: $_user_db@$_host_db(:$_port_db)/$_name_db)\");\n            }\n\n            $this->type_db = $_type_db;\n            $this->options = array(\n                'driver'   => $_type,\n                'hostname' => $_host_db,\n                'port'     => $_port_db,\n                'username' => $_user_db,\n                'password' => $_pwd_db,\n                'database' => $_name_db\n            );\n            if ($_type_db === self::MYSQL && !defined('NON_UTF_DBCONNECT')) {\n                $this->options['charset'] = 'utf8';\n            }\n\n            $this->doConnection();\n        } catch (Throwable $e) {\n            // perhaps factory() failed to load the specified Adapter class\n            Analog::log(\n                '[Db] Error (' . $e->getCode() . '|' .\n                $e->getMessage() . ')',\n                Analog::ALERT\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Do database connection\n     *\n     * @return void\n     */\n    private function doConnection()\n    {\n        $this->db = new Adapter($this->options);\n        $this->db->getDriver()->getConnection()->connect();\n        $this->sql = new Sql($this->db);\n\n        if (!$this->isPostgres()) {\n            $this->db->query(\"SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\");\n        }\n    }\n\n    /**\n     * To store Db in session\n     *\n     * @return array\n     */\n    public function __sleep()\n    {\n        return ['type_db', 'options'];\n    }\n\n    /**\n     * Connect again to the database on wakeup\n     *\n     * @return void\n     */\n    public function __wakeup()\n    {\n        $this->doConnection();\n    }\n\n    /**\n     * Retrieve current database version\n     *\n     * @param boolean $check_table Check if table exists, defaults to false\n     *\n     * @return float\n     *\n     * @throw LogicException\n     */\n    public function getDbVersion($check_table = false)\n    {\n        try {\n            if ($check_table === true) {\n                $exists = count($this->getTables(PREFIX_DB . 'database')) === 1;\n            } else {\n                $exists = true;\n            }\n\n            if ($exists === true) {\n                $select = $this->select('database');\n                $select->columns(\n                    array('version')\n                )->limit(1);\n\n                $results = $this->execute($select);\n                $result = $results->current();\n                return number_format(\n                    $result->version,\n                    3,\n                    '.',\n                    ''\n                );\n            } else {\n                return 0.63;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot check database version: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw new \\LogicException('Cannot check database version');\n        }\n    }\n\n    /**\n     * Check if database version suits our needs\n     *\n     * @return boolean\n     */\n    public function checkDbVersion()\n    {\n        if (GALETTE_MODE === 'DEV') {\n            Analog::log(\n                'Database version not checked in DEV mode.',\n                Analog::INFO\n            );\n            return true;\n        }\n\n        try {\n            return $this->getDbVersion() === GALETTE_DB_VERSION;\n        } catch (\\LogicException $e) {\n            return false;\n        }\n    }\n\n    /**\n     * Peform a select query on the whole table\n     *\n     * @param string $table Table name\n     *\n     * @return array\n     */\n    public function selectAll($table)\n    {\n        return $this->db->query(\n            'SELECT * FROM ' . PREFIX_DB . $table,\n            Adapter::QUERY_MODE_EXECUTE\n        );\n    }\n\n    /**\n     * Test if database can be contacted. Mostly used for installation\n     *\n     * @param string $type db type\n     * @param string $user database's user\n     * @param string $pass password for the user\n     * @param string $host which host we want to connect to\n     * @param string $port which tcp port we want to connect to\n     * @param string $db   database name\n     *\n     * @return true\n     */\n    public static function testConnectivity(\n        $type,\n        $user = null,\n        $pass = null,\n        $host = null,\n        $port = null,\n        $db = null\n    ) {\n        $_type = null;\n        try {\n            if ($type === self::MYSQL) {\n                $_type = 'Pdo_Mysql';\n            } elseif ($type === self::PGSQL) {\n                $_type = 'Pdo_Pgsql';\n            } else {\n                throw new \\Exception();\n            }\n\n            $_options = array(\n                'driver'   => $_type,\n                'hostname' => $host,\n                'port'     => $port,\n                'username' => $user,\n                'password' => $pass,\n                'database' => $db\n            );\n\n            $_db = new Adapter($_options);\n            $_db->getDriver()->getConnection()->connect();\n\n            return true;\n        } catch (Throwable $e) {\n            // perhaps failed to load the specified Adapter class\n            Analog::log(\n                '[' . __METHOD__ . '] Connection error (' . $e->getCode() . '|' .\n                $e->getMessage() . ')',\n                Analog::ALERT\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Drop test table if it exists, so we can make all checks.\n     *\n     * @return void\n     */\n    public function dropTestTable()\n    {\n        try {\n            $this->db->query('DROP TABLE IF EXISTS galette_test');\n            Analog::log('Test table successfully dropped.', Analog::DEBUG);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot drop test table! ' . $e->getMessage(),\n                Analog::WARNING\n            );\n        }\n    }\n\n    /**\n     * Checks GRANT access for install time\n     *\n     * @param string $mode are we at install time (i) or update time (u) ?\n     *\n     * @return array containing each test. Each array entry could\n     *           be either true or contains an exception of false if test did not\n     *           ran.\n     */\n    public function grantCheck($mode = 'i')\n    {\n        Analog::log(\n            'Check for database rights (mode ' . $mode . ')',\n            Analog::DEBUG\n        );\n        $stop = false;\n        $results = array(\n            'create' => false,\n            'insert' => false,\n            'select' => false,\n            'update' => false,\n            'delete' => false,\n            'drop'   => false\n        );\n        if ($mode === 'u') {\n            $results['alter'] = false;\n        }\n\n        //can Galette CREATE tables?\n        try {\n            $sql = 'CREATE TABLE galette_test (\n                test_id INTEGER NOT NULL,\n                test_text VARCHAR(20)\n            )';\n            $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n            $results['create'] = true;\n        } catch (Throwable $e) {\n            Analog::log('Cannot CREATE TABLE', Analog::WARNING);\n            //if we cannot create tables, we cannot check other permissions\n            $stop = true;\n            $results['create'] = $e;\n        }\n\n        //all those tests need the table to exists\n        if (!$stop) {\n            if ($mode == 'u') {\n                //can Galette ALTER tables? (only for update mode)\n                try {\n                    $sql = 'ALTER TABLE galette_test ALTER test_text SET DEFAULT \\'nothing\\'';\n                    $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n                    $results['alter'] = true;\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot ALTER TABLE | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['alter'] = $e;\n                }\n            }\n\n            //can Galette INSERT records ?\n            $values = array(\n                'test_id'      => 1,\n                'test_text'    => 'a simple text'\n            );\n            try {\n                $insert = $this->sql->insert('galette_test');\n                $insert->values($values);\n\n                $res = $this->execute($insert);\n\n                if ($res->count() === 1) {\n                    $results['insert'] = true;\n                } else {\n                    throw new \\Exception('No row inserted!');\n                }\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot INSERT records | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                //if we cannot insert records, some others tests cannot be done\n                $stop = true;\n                $results['insert'] = $e;\n            }\n\n            //all those tests need that the first record exists\n            if (!$stop) {\n                //can Galette UPDATE records ?\n                $values = array(\n                    'test_text' => 'another simple text'\n                );\n                try {\n                    $update = $this->sql->update('galette_test');\n                    $update->set($values)->where(\n                        array('test_id' => 1)\n                    );\n                    $res = $this->execute($update);\n                    if ($res->count() === 1) {\n                        $results['update'] = true;\n                    } else {\n                        throw new \\Exception('No row updated!');\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot UPDATE records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['update'] = $e;\n                }\n\n                //can Galette SELECT records ?\n                try {\n                    $select = $this->sql->select('galette_test');\n                    $select->where('test_id = 1');\n                    $res = $this->execute($select);\n                    $pass = $res->count() === 1;\n\n                    if ($pass) {\n                        $results['select'] = true;\n                    } else {\n                        throw new \\Exception('Select is empty!');\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot SELECT records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['select'] = $e;\n                }\n\n                //can Galette DELETE records ?\n                try {\n                    $delete = $this->sql->delete('galette_test');\n                    $delete->where(array('test_id' => 1));\n                    $this->execute($delete);\n                    $results['delete'] = true;\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot DELETE records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['delete'] = $e;\n                }\n            }\n\n            //can Galette DROP tables ?\n            try {\n                $sql = 'DROP TABLE galette_test';\n                $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n                $results['drop'] = true;\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot DROP TABLE | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                $results['drop'] = $e;\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * Get a list of Galette's tables\n     *\n     * @param string $prefix Specified table prefix, PREFIX_DB if null\n     *\n     * @return array\n     */\n    public function getTables($prefix = null)\n    {\n        $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n        $tmp_tables_list = $metadata->getTableNames();\n\n        if ($prefix === null) {\n            $prefix = PREFIX_DB;\n        }\n\n        $tables_list = array();\n        //filter table_list: we only want PREFIX_DB tables\n        foreach ($tmp_tables_list as $t) {\n            if (preg_match('/^' . $prefix . '/', $t)) {\n                $tables_list[] = $t;\n            }\n        }\n        return $tables_list;\n    }\n\n    /**\n     * Get columns for a specified table\n     *\n     * @param string $table Table name\n     *\n     * @return array\n     */\n    public function getColumns($table)\n    {\n        $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n        $table = $metadata->getTable(PREFIX_DB . $table);\n        return $table->getColumns();\n    }\n\n    /**\n     * Converts recursively database to UTF-8\n     *\n     * @param string  $prefix       Specified table prefix\n     * @param boolean $content_only Proceed only content (no table conversion)\n     *\n     * @return void\n     */\n    public function convertToUTF($prefix = null, $content_only = false)\n    {\n        if ($this->isPostgres()) {\n            Analog::log(\n                'Cannot change encoding on PostgreSQL database',\n                Analog::INFO\n            );\n            return;\n        }\n        if ($prefix === null) {\n            $prefix = PREFIX_DB;\n        }\n\n        try {\n            $tables = $this->getTables($prefix);\n\n            foreach ($tables as $table) {\n                if ($content_only === false) {\n                    //Change whole table charset\n                    //CONVERT TO instruction will take care of each fields,\n                    //but converting data stay our problem.\n                    $query = 'ALTER TABLE ' . $table .\n                        ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci';\n\n                    $this->db->query(\n                        $query,\n                        Adapter::QUERY_MODE_EXECUTE\n                    );\n\n                    Analog::log(\n                        'Charset successfully changed for table `' . $table . '`',\n                        Analog::DEBUG\n                    );\n                }\n\n                //Data conversion\n                if ($table != $prefix . 'pictures') {\n                    $this->convertContentToUTF($prefix, $table);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while converting to utf table ' .\n                $table . ' (' . $e->getMessage() . ')',\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Converts dtabase content to UTF-8\n     *\n     * @param string $prefix Specified table prefix\n     * @param string $table  the table we want to convert datas from\n     *\n     * @return void\n     */\n    private function convertContentToUTF($prefix, $table)\n    {\n\n        try {\n            $query = 'SET NAMES latin1';\n            $this->db->query(\n                $query,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot SET NAMES on table `' . $table . '`. ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n\n        try {\n            $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n            $tbl = $metadata->getTable($table);\n            $constraints = $tbl->getConstraints();\n            $pkeys = array();\n\n            foreach ($constraints as $constraint) {\n                if ($constraint->getType() === 'PRIMARY KEY') {\n                    $pkeys = $constraint->getColumns();\n                }\n            }\n\n            if (count($pkeys) == 0) {\n                //no primary key! How to do an update without that?\n                //Prior to 0.7, l10n and dynamic_fields tables does not\n                //contains any primary key. Since encoding conversion is done\n                //_before_ the SQL upgrade, we'll have to manually\n                //check these ones\n                if (preg_match('/' . $prefix . 'dynamic_fields/', $table) !== 0) {\n                    $pkeys = array(\n                        'item_id',\n                        'field_id',\n                        'field_form',\n                        'val_index'\n                    );\n                } elseif (preg_match('/' . $prefix . 'l10n/', $table) !== 0) {\n                    $pkeys = array(\n                        'text_orig',\n                        'text_locale'\n                    );\n                } else {\n                    //not a know case, we do not perform any update.\n                    throw new \\Exception(\n                        'Cannot define primary key for table `' . $table .\n                        '`, aborting'\n                    );\n                }\n            }\n\n            $select = $this->sql->select($table);\n            $results = $this->execute($select);\n\n            foreach ($results as $row) {\n                $data = array();\n                $where = array();\n\n                //build where\n                foreach ($pkeys as $k) {\n                    $where[] = $k . ' = \"' . $row->$k . '\"';\n                }\n\n                //build data\n                foreach ($row as $key => $value) {\n                    $data[$key] = $value;\n                }\n\n                //finally, update data!\n                $update = $this->sql->update($table);\n                $update->set($data)->where($where);\n                $this->execute($update);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while converting contents to UTF-8 for table ' .\n                $table . ' (' . $e->getMessage() . ')',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Is current database using Postgresql?\n     *\n     * @return boolean\n     */\n    public function isPostgres()\n    {\n        return $this->type_db === self::PGSQL;\n    }\n\n    /**\n     * Instanciate a select query\n     *\n     * @param string $table Table name, without prefix\n     * @param string $alias Tables alias, optionnal\n     *\n     * @return Select\n     */\n    public function select($table, $alias = null)\n    {\n        if ($alias === null) {\n            return $this->sql->select(\n                PREFIX_DB . $table\n            );\n        } else {\n            return $this->sql->select(\n                array(\n                    $alias => PREFIX_DB . $table\n                )\n            );\n        }\n    }\n\n    /**\n     * Instanciate an insert query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Insert\n     */\n    public function insert($table)\n    {\n        return $this->sql->insert(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Instanciate an update query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Update\n     */\n    public function update($table)\n    {\n        return $this->sql->update(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Instanciate a delete query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Delete\n     */\n    public function delete($table)\n    {\n        return $this->sql->delete(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Execute query string\n     *\n     * @param SqlInterface $sql SQL object\n     *\n     * @return StatementInterface|ResultSet\\ResultSet\n     */\n    public function execute($sql)\n    {\n        try {\n            $query_string = $this->sql->buildSqlString($sql);\n            $this->last_query = $query_string;\n            $this->log($query_string);\n            return $this->db->query(\n                $query_string,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n        } catch (Throwable $e) {\n            $msg = 'Query error: ';\n            if (isset($query_string)) {\n                $msg .= $query_string;\n            }\n            Analog::log(\n                $msg . ' ' . $e->__toString(),\n                Analog::ERROR\n            );\n            if ($sql instanceof Insert && $this->isDuplicateException($e)) {\n                throw new \\OverflowException('Duplicate entry', 0, $e);\n            }\n            throw $e;\n        }\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the variable we want to retrieve\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n            case 'db':\n                return $this->db;\n            case 'sql':\n                return $this->sql;\n            case 'driver':\n                return $this->db->getDriver();\n            case 'connection':\n                return $this->db->getDriver()->getConnection();\n            case 'platform':\n                return $this->db->getPlatform();\n            case 'query_string':\n                return $this->last_query;\n            case 'type_db':\n                return $this->type_db;\n        }\n    }\n\n    /**\n     * Get database information\n     *\n     * @return array\n     */\n    public function getInfos()\n    {\n        $infos = [\n            'engine'    => null,\n            'version'   => null,\n            'size'      => null,\n            'log_size'  => null,\n            'sql_mode'  => ''\n        ];\n\n        if ($this->isPostgres()) {\n            $infos['engine'] = 'PostgreSQL';\n            $sql = 'SHOW server_version';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n            $infos['version'] = $result['server_version'];\n\n            $sql = 'SELECT pg_database_size(\\'' . NAME_DB . '\\')';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n            $infos['size'] = (string)round($result['pg_database_size'] / 1024 / 1024);\n        } else {\n            $sql = 'SELECT @@sql_mode as mode, @@version AS version, @@version_comment AS version_comment';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n\n            $infos['engine']    = $result['version_comment'];\n            $infos['version']   = $result['version'];\n            $infos['sql_mode']  = $result['mode'];\n\n            $size_sql = 'SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 1) AS dbsize' .\n                ' FROM information_schema.tables WHERE table_schema=\"' . NAME_DB . '\"';\n            $result = $this->db->query($size_sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n\n            $infos['size'] = $result['dbsize'];\n        }\n\n        return $infos;\n    }\n\n    /**\n     * Handle sequence on PostgreSQL\n     *\n     * When inserting a value on a field with a sequence,\n     * this one is not incremented.\n     * This happens when installing system values (for status, titles, ...)\n     *\n     * @see https://bugs.galette.eu/issues/1158\n     * @see https://bugs.galette.eu/issues/1374\n     *\n     * @param string  $table    Table name\n     * @param integer $expected Expected value\n     *\n     * @return void\n     */\n    public function handleSequence($table, $expected)\n    {\n        if ($this->isPostgres()) {\n            //check for Postgres sequence\n            //see https://bugs.galette.eu/issues/1158\n            //see https://bugs.galette.eu/issues/1374\n            $seq = $table . '_id_seq';\n\n            $select = $this->select($seq);\n            $select->columns(['last_value']);\n            $results = $this->execute($select);\n            $result = $results->current();\n            if ($result->last_value < $expected) {\n                $this->db->query(\n                    'SELECT setval(\\'' . PREFIX_DB . $seq . '\\', ' . $expected . ')',\n                    Adapter::QUERY_MODE_EXECUTE\n                );\n            }\n        }\n    }\n\n    /**\n     * Check if current exception is on a duplicate key\n     *\n     * @param Throwable $exception Exception to check\n     *\n     * @return boolean\n     */\n    public function isDuplicateException($exception)\n    {\n        return $exception instanceof \\PDOException\n            && (\n                (!$this->isPostgres() && $exception->getCode() == 23000)\n                || ($this->isPostgres() && $exception->getCode() == 23505)\n            )\n        ;\n    }\n\n    /**\n     * Drops a table\n     *\n     * @param string  $table   Table name, without prefix\n     * @param boolean $maymiss Whether the table can be missing, defaults to false\n     *\n     * @return void\n     */\n    public function drop($table, $maymiss = false)\n    {\n        $sql = 'DROP TABLE ';\n        if ($maymiss === true) {\n            $sql .= 'IF EXISTS ';\n        }\n        $sql .= PREFIX_DB . $table;\n        $this->db->query(\n            $sql,\n            \\Laminas\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE\n        );\n    }\n\n    /**\n     * Log queries in specific file\n     *\n     * @param string $query Query to add in logs\n     *\n     * @return void\n     */\n    protected function log($query)\n    {\n        if (GALETTE_MODE == 'DEV' || defined('GALETTE_SQL_DEBUG')) {\n            $logfile = GALETTE_LOGS_PATH . 'galette_sql.log';\n            file_put_contents($logfile, $query . \"\\n\", FILE_APPEND);\n        }\n    }\n\n    /**\n     * Get last generated value\n     *\n     * @param object $entity Entity instance\n     *\n     * @return integer\n     */\n    public function getLastGeneratedValue($entity): int\n    {\n        return (int)$this->driver->getLastGeneratedValue(\n            $this->isPostgres() ?\n                PREFIX_DB . $entity::TABLE . '_id_seq'\n                : null\n        );\n    }\n\n    /**\n     * Get MySQL warnings\n     *\n     * @return array\n     */\n    public function getWarnings(): array\n    {\n        $results = $this->db->query('SHOW WARNINGS', Adapter::QUERY_MODE_EXECUTE);\n\n        $warnings = [];\n        foreach ($results as $result) {\n            $warnings[] = $result;\n        }\n\n        return $warnings;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Logo handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2014 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-09-13\n */\n\nnamespace Galette\\Core;\n\nuse Analog\\Analog;\n\n/**\n * This class stores and serve the logo.\n * If no custom logo is found, we take galette's default one.\n *\n * @category  Core\n * @name      Logo\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-09-13\n */\nclass Logo extends Picture\n{\n    protected $id = 'custom_logo';\n    //database wants a member id (integer), not a string.\n    //  Will be used to query the correct id\n    protected $db_id = 0;\n    protected $custom = true;\n\n    /**\n     * Default constructor.\n     */\n    public function __construct()\n    {\n        parent::__construct($this->id);\n    }\n\n    /**\n     * Gets the default picture to show, anyways\n     *\n     * @see Picture::getDefaultPicture()\n     *\n     * @return void\n     */\n    protected function getDefaultPicture()\n    {\n        $this->file_path = realpath(_CURRENT_THEME_PATH . 'images/galette.png');\n        $this->format = 'png';\n        $this->mime = 'image/png';\n        $this->custom = false;\n    }\n\n    /**\n     * Returns the relevant query to check if picture exists in database.\n     *\n     * @see picture::getCheckFileQuery()\n     *\n     * @return string SELECT query\n     */\n    protected function getCheckFileQuery()\n    {\n        global $zdb;\n\n        $select = $zdb->select(self::TABLE);\n        $select->columns(\n            array(\n                'picture',\n                'format'\n            )\n        );\n        $select->where(self::PK . ' = ' . $this->db_id);\n        return $select;\n    }\n\n    /**\n     * Returns custom state\n     *\n     * @return boolean\n     */\n    public function isCustom()\n    {\n        return $this->custom;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Mailing features\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-08-27\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Filters\\MailingsList;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * Mailing features\n *\n * @category  Core\n * @name      MailingHistory\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-08-27\n */\nclass MailingHistory extends History\n{\n    public const TABLE = 'mailing_history';\n    public const PK = 'mailing_id';\n\n    public const FILTER_DC_SENT = 0;\n    public const FILTER_SENT = 1;\n    public const FILTER_NOT_SENT = 2;\n\n    private $mailing = null;\n    private $id;\n    private $date;\n    private $subject;\n    private $message;\n    private $recipients;\n    private $sender;\n    private $sender_name;\n    private $sender_address;\n    private $sent = false;\n\n    private $senders;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                $zdb         Database\n     * @param Login             $login       Login\n     * @param Preferences       $preferences Preferences\n     * @param MailingsList|null $filters     Filtering\n     * @param Mailing|null      $mailing     Mailing\n     */\n    public function __construct(Db $zdb, Login $login, Preferences $preferences, MailingsList $filters = null, Mailing $mailing = null)\n    {\n        parent::__construct($zdb, $login, $preferences, $filters);\n        $this->mailing = $mailing;\n    }\n\n    /**\n     * Get the entire history list\n     *\n     * @return array\n     */\n    public function getHistory()\n    {\n        try {\n            $select = $this->zdb->select($this->getTableName(), 'a');\n            $select->join(\n                array('b' => PREFIX_DB . Adherent::TABLE),\n                'a.mailing_sender=b.' . Adherent::PK,\n                array('nom_adh', 'prenom_adh'),\n                $select::JOIN_LEFT\n            );\n            $this->buildWhereClause($select);\n            $select->order($this->buildOrderClause());\n            $this->buildLists($select);\n            $this->proceedCount($select);\n            //add limits to retrieve only relevant rows\n            $this->filters->setLimits($select);\n            $results = $this->zdb->execute($select);\n\n            $ret = array();\n            foreach ($results as $r) {\n                if ($r['mailing_sender'] !== null && $r['mailing_sender_name'] === null) {\n                    $r['mailing_sender_name']\n                        = Adherent::getSName($this->zdb, $r['mailing_sender']);\n                }\n                $body_resume = $r['mailing_body'];\n                if (strlen($body_resume) > 150) {\n                    $body_resume = substr($body_resume, 0, 150);\n                    $body_resume .= '[...]';\n                }\n                if (function_exists('tidy_parse_string')) {\n                    //if tidy extension is present, we use it to clean a bit\n                    $tidy_config = array(\n                        'clean'             => true,\n                        'show-body-only'    => true,\n                        'wrap' => 0,\n                    );\n                    $tidy = tidy_parse_string($body_resume, $tidy_config, 'UTF8');\n                    $tidy->cleanRepair();\n                    $r['mailing_body_resume'] = tidy_get_output($tidy);\n                } else {\n                    //if it is not... Well, let's serve the text as it.\n                    $r['mailing_body_resume'] = $body_resume;\n                }\n\n                $attachments = 0;\n                if (file_exists(GALETTE_ATTACHMENTS_PATH . $r[self::PK])) {\n                    $rdi = new \\RecursiveDirectoryIterator(\n                        GALETTE_ATTACHMENTS_PATH . $r[self::PK],\n                        \\FilesystemIterator::SKIP_DOTS\n                    );\n                    $contents = new \\RecursiveIteratorIterator(\n                        $rdi,\n                        \\RecursiveIteratorIterator::CHILD_FIRST\n                    );\n                    foreach ($contents as $path) {\n                        if ($path->isFile()) {\n                            $attachments++;\n                        }\n                    }\n                }\n                $r['attachments'] = $attachments;\n                $ret[] = $r;\n            }\n            return $ret;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to get history. | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds users and actions lists\n     *\n     * @param \\Laminas\\Db\\Sql\\Select $select Original select\n     *\n     * @return void\n     */\n    private function buildLists($select)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->quantifier('DISTINCT')->columns(['mailing_sender']);\n            $select->order(['mailing_sender ASC']);\n\n            $results = $this->zdb->execute($select);\n\n            $this->senders = [];\n            foreach ($results as $result) {\n                $sender = $result->mailing_sender;\n                if ($sender != null) {\n                    $this->senders[$sender] = Adherent::getSName($this->zdb, (int)$sender);\n                } elseif ($result->mailing_sender_name != null || $result->mailing_sender_address != null) {\n                    $this->senders[$result->mailing_sender_address] = $result->mailing_sender_name;\n                } else {\n                    $this->senders[-1] = _('Superadmin');\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list senders from mailing history! | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the order clause\n     *\n     * @return string SQL ORDER clause\n     */\n    protected function buildOrderClause()\n    {\n        $order = array();\n\n        switch ($this->filters->orderby) {\n            case MailingsList::ORDERBY_DATE:\n                $order[] = 'mailing_date ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SENDER:\n                $order[] = 'mailing_sender ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SUBJECT:\n                $order[] = 'mailing_subject ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SENT:\n                $order[] = 'mailing_sent ' . $this->filters->ordered;\n                break;\n        }\n\n        return $order;\n    }\n\n    /**\n     * Builds where clause, for filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return string SQL WHERE clause\n     */\n    private function buildWhereClause($select)\n    {\n        try {\n            if ($this->filters->start_date_filter != null) {\n                $d = new \\DateTime($this->filters->raw_start_date_filter);\n                $select->where->greaterThanOrEqualTo(\n                    'mailing_date',\n                    $d->format('Y-m-d')\n                );\n            }\n\n            if ($this->filters->end_date_filter != null) {\n                $d = new \\DateTime($this->filters->raw_end_date_filter);\n                $select->where->lessThanOrEqualTo(\n                    'mailing_date',\n                    $d->format('Y-m-d')\n                );\n            }\n\n            if ($this->filters->sender_filter != null && $this->filters->sender_filter != '0') {\n                $sender = $this->filters->sender_filter;\n                if ($sender == '-1') {\n                    $select->where('mailing_sender IS NULL');\n                } else {\n                    $select->where->equalTo(\n                        'mailing_sender',\n                        $sender\n                    );\n                }\n            }\n\n            switch ($this->filters->sent_filter) {\n                case self::FILTER_SENT:\n                    $select->where('mailing_sent = true');\n                    break;\n                case self::FILTER_NOT_SENT:\n                    $select->where('mailing_sent = false');\n                    break;\n                case self::FILTER_DC_SENT:\n                    //nothing to do here.\n                    break;\n            }\n\n\n            if ($this->filters->subject_filter != '') {\n                $token = $this->zdb->platform->quoteValue(\n                    '%' . strtolower($this->filters->subject_filter) . '%'\n                );\n\n                $select->where(\n                    'LOWER(mailing_subject) LIKE ' .\n                    $token\n                );\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Count history entries from the query\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function proceedCount($select)\n    {\n        try {\n            $countSelect = clone $select;\n            $countSelect->reset($countSelect::COLUMNS);\n            $countSelect->reset($countSelect::JOINS);\n            $countSelect->reset($countSelect::ORDER);\n            $countSelect->columns(\n                array(\n                    self::PK => new Expression('COUNT(' . self::PK . ')')\n                )\n            );\n\n            $results = $this->zdb->execute($countSelect);\n            $result = $results->current();\n\n            $k = self::PK;\n            $this->count = $result->$k;\n            if ($this->count > 0) {\n                $this->filters->setCounter($this->count);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot count history | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load mailing from an existing one\n     *\n     * @param Db             $zdb     Database instance\n     * @param integer        $id      Model identifier\n     * @param GaletteMailing $mailing Mailing object\n     * @param boolean        $new     True if we create a 'new' mailing,\n     *                                false otherwise (from preview for example)\n     *\n     * @return boolean\n     */\n    public static function loadFrom(Db $zdb, $id, $mailing, $new = true)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where('mailing_id = ' . $id);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n\n            return $mailing->loadFromHistory($result, $new);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to load mailing model #' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store a mailing in the history\n     *\n     * @param boolean $sent Defaults to false\n     *\n     * @return boolean\n     */\n    public function storeMailing($sent = false)\n    {\n        if ($this->mailing instanceof Mailing) {\n            if ($this->mailing->sender_name != null) {\n                $this->sender_name = $this->mailing->getSenderName();\n                $this->sender_address = $this->mailing->getSenderAddress();\n            }\n            $this->sender = $this->login->id;\n            $this->subject = $this->mailing->subject;\n            $this->message = $this->mailing->message;\n            $this->recipients = $this->mailing->recipients;\n            $this->sent = $sent;\n            $this->date = date('Y-m-d H:i:s');\n            if (!$this->mailing->existsInHistory()) {\n                $this->store();\n                $this->mailing->id = $this->id;\n                $this->mailing->moveAttachments($this->id);\n            } else {\n                if ($this->mailing->tmp_path !== false) {\n                    //attachments are still in a temporary path, move them\n                    $this->mailing->moveAttachments($this->id ?? $this->mailing->history_id);\n                }\n                //existing stored mailing. Just update row.\n                $this->update();\n            }\n        } else {\n            Analog::log(\n                '[' . __METHOD__ .\n                '] Mailing should be an instance of Mailing',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Update in the database\n     *\n     * @return boolean\n     */\n    public function update()\n    {\n        try {\n            $_recipients = array();\n            if ($this->recipients != null) {\n                foreach ($this->recipients as $_r) {\n                    $_recipients[$_r->id] = $_r->sname . ' <' . $_r->email . '>';\n                }\n            }\n\n            $sender = ($this->sender === 0) ?\n                new Expression('NULL') : $this->sender;\n            $sender_name = ($this->sender_name === null) ?\n                new Expression('NULL') : $this->sender_name;\n            $sender_address = ($this->sender_address === null) ?\n                new Expression('NULL') : $this->sender_address;\n\n            $values = array(\n                'mailing_sender'            => $sender,\n                'mailing_sender_name'       => $sender_name,\n                'mailing_sender_address'    => $sender_address,\n                'mailing_subject'           => $this->subject,\n                'mailing_body'              => $this->message,\n                'mailing_date'              => $this->date,\n                'mailing_recipients'        => serialize($_recipients),\n                'mailing_sent'              => ($this->sent) ?\n                    true :\n                    ($this->zdb->isPostgres() ? 'false' : 0)\n            );\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set($values);\n            $update->where(self::PK . ' = ' . $this->mailing->history_id);\n            $this->zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurend updating Mailing | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store in the database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        try {\n            $_recipients = array();\n            if ($this->recipients != null) {\n                foreach ($this->recipients as $_r) {\n                    $_recipients[$_r->id] = $_r->sname . ' <' . $_r->email . '>';\n                }\n            }\n\n            $sender = null;\n            if ($this->sender === 0) {\n                $sender = new Expression('NULL');\n            } else {\n                $sender = $this->sender;\n            }\n            $sender_name = ($this->sender_name === null) ?\n                new Expression('NULL') : $this->sender_name;\n            $sender_address = ($this->sender_address === null) ?\n                new Expression('NULL') : $this->sender_address;\n\n            $values = array(\n                'mailing_sender'            => $sender,\n                'mailing_sender_name'       => $sender_name,\n                'mailing_sender_address'    => $sender_address,\n                'mailing_subject'           => $this->subject,\n                'mailing_body'              => $this->message,\n                'mailing_date'              => $this->date,\n                'mailing_recipients'        => serialize($_recipients),\n                'mailing_sent'              => ($this->sent) ?\n                    true :\n                    ($this->zdb->isPostgres() ? 'false' : 0)\n            );\n\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($values);\n            $this->zdb->execute($insert);\n\n            $this->id = $this->zdb->getLastGeneratedValue($this);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurend storing Mailing | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified entries\n     *\n     * @param integer|array $ids  Mailing history entries identifiers\n     * @param History       $hist History instance\n     *\n     * @return boolean\n     */\n    public function removeEntries($ids, History $hist)\n    {\n        $list = array();\n        if (is_numeric($ids)) {\n            //we've got only one identifier\n            $list[] = $ids;\n        } else {\n            $list = $ids;\n        }\n\n        if (is_array($list)) {\n            try {\n                foreach ($list as $id) {\n                    $mailing = new Mailing($this->preferences, [], $id);\n                    $mailing->removeAttachments();\n                }\n\n                $this->zdb->connection->beginTransaction();\n\n                //delete members\n                $delete = $this->zdb->delete(self::TABLE);\n                $delete->where->in(self::PK, $list);\n                $this->zdb->execute($delete);\n\n                //commit all changes\n                $this->zdb->connection->commit();\n\n                //add an history entry\n                $hist->add(\n                    _T(\"Delete mailing entries\")\n                );\n\n                return true;\n            } catch (Throwable $e) {\n                $this->zdb->connection->rollBack();\n                Analog::log(\n                    'Unable to delete selected mailing history entries |' .\n                    $e->getMessage(),\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } else {\n            //not numeric and not an array: incorrect.\n            Analog::log(\n                'Asking to remove mailing entries, but without ' .\n                'providing an array or a single numeric value.',\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Get table's name\n     *\n     * @param boolean $prefixed Whether table name should be prefixed\n     *\n     * @return string\n     */\n    protected function getTableName($prefixed = false)\n    {\n        if ($prefixed === true) {\n            return PREFIX_DB . self::TABLE;\n        } else {\n            return self::TABLE;\n        }\n    }\n\n    /**\n     * Get table's PK\n     *\n     * @return string\n     */\n    protected function getPk()\n    {\n        return self::PK;\n    }\n\n    /**\n     * Get count for current query\n     *\n     * @return int\n     */\n    public function getCount()\n    {\n        return $this->count;\n    }\n\n    /**\n     * Get senders list\n     *\n     * @return array\n     */\n    public function getSendersList()\n    {\n        return $this->senders;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Password for galette. The original code was found\n * in includes/functions.inc.php\n *\n * PHP version 5\n *\n * Copyright \u00a9 2003-2020 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Georges Khaznadar (password encryption, images) <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2003-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-02-28\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Entity\\Adherent;\n\n/**\n * Temporary password management\n *\n * @category  Core\n * @name      Password\n * @package   Galette\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Georges Khaznadar (password encryption, images) <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2020 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-06-16\n */\n\nclass Password extends AbstractPassword\n{\n    public const TABLE = 'tmppasswds';\n    public const PK = Adherent::PK;\n\n    /** @var integer Overrides default password size */\n    public const DEFAULT_SIZE = 50;\n    /** @var string Overrides default character set */\n    protected $chars = 'abcdefghjkmnpqrstuvwxyz0123456789&@{[]}%#+*:ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    private $zdb;\n\n    /**\n     * Default constructor\n     *\n     * @param Db      $zdb   Database instance:\n     * @param boolean $clean Whether we should clean expired passwords in database\n     */\n    public function __construct(Db $zdb, bool $clean = true)\n    {\n        $this->zdb = $zdb;\n        if ($clean === true) {\n            $this->cleanExpired();\n        }\n    }\n\n    /**\n     * Remove all old password entries\n     *\n     * @param int $id_adh Member identifier\n     *\n     * @return boolean\n     */\n    private function removeOldEntries(int $id_adh): bool\n    {\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(self::PK . ' = ' . $id_adh);\n\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Temporary passwords for `' . $id_adh . '` has been removed.',\n                    Analog::DEBUG\n                );\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error has occurred removing old tmppasswords ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Generates a new password for specified member\n     *\n     * @param int $id_adh Member identifier\n     *\n     * @return boolean\n     */\n    public function generateNewPassword($id_adh): bool\n    {\n        //first of all, we'll remove all existant entries for specified id\n        $this->removeOldEntries($id_adh);\n\n        //second, generate a new password and store it in the database\n        $password = $this->makeRandomPassword();\n        $hash = password_hash($password, PASSWORD_BCRYPT);\n\n        try {\n            $values = array(\n                self::PK               => $id_adh,\n                'tmp_passwd'           => $hash,\n                'date_crea_tmp_passwd' => date('Y-m-d H:i:s')\n            );\n\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($values);\n\n            $add = $this->zdb->execute($insert);\n            if ($add) {\n                Analog::log(\n                    'New passwords temporary set for `' . $id_adh . '`.',\n                    Analog::DEBUG\n                );\n                $this->setPassword($password);\n                $this->setHash($hash);\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                \"An error occurred trying to add temporary password entry. \" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove expired passwords queries (older than 24 hours)\n     *\n     * @return boolean\n     */\n    protected function cleanExpired(): bool\n    {\n        $date = new \\DateTime();\n        $date->sub(new \\DateInterval('PT24H'));\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where->lessThan(\n                'date_crea_tmp_passwd',\n                $date->format('Y-m-d H:i:s')\n            );\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Old Temporary passwords have been deleted.',\n                    Analog::DEBUG\n                );\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred deleting expired temporary passwords. ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Check if requested hash is valid\n     *\n     * @param string $hash the hash\n     *\n     * @return false|int false if hash is not valid, member id otherwise\n     */\n    public function isHashValid(string $hash)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array(self::PK)\n            )->where(array('tmp_passwd' => $hash));\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $pk = self::PK;\n                return $result->$pk;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred getting requested hash. ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove a hash that has been used (ie. once password has been updated)\n     *\n     * @param string $hash hash\n     *\n     * @return boolean\n     */\n    public function removeHash(string $hash): bool\n    {\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                array('tmp_passwd' => $hash)\n            );\n\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Used hash has been successfully remove',\n                    Analog::DEBUG\n                );\n                return true;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred attempting to delete used hash' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Picture handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2006-2014 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2006-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Repository\\Members;\nuse Galette\\IO\\FileInterface;\nuse Galette\\IO\\FileTrait;\n\n/**\n * Picture handling\n *\n * @name Picture\n * @category  Core\n * @package   Galette\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2006-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\nclass Picture implements FileInterface\n{\n    use FileTrait;\n\n    //constants that will not be overrided\n    public const SQL_ERROR = -10;\n    public const SQL_BLOB_ERROR = -11;\n    //constants that can be overrided\n    //(do not use self::CONSTANT, but get_class[$this]::CONSTANT)\n    public const TABLE = 'pictures';\n    public const PK = Adherent::PK;\n\n    protected $tbl_prefix = '';\n\n    protected $id;\n    protected $height;\n    protected $width;\n    protected $optimal_height;\n    protected $optimal_width;\n    protected $file_path;\n    protected $format;\n    protected $mime;\n    protected $has_picture = false;\n    protected $store_path = GALETTE_PHOTOS_PATH;\n    protected $max_width = 200;\n    protected $max_height = 200;\n    private $insert_stmt;\n\n    /**\n     * Default constructor.\n     *\n     * @param int $id_adh the id of the member\n     */\n    public function __construct($id_adh = '')\n    {\n\n        $this->init(\n            null,\n            array('jpeg', 'jpg', 'png', 'gif'),\n            array(\n                'jpg'    =>    'image/jpeg',\n                'png'    =>    'image/png',\n                'gif'    =>    'image/gif'\n            )\n        );\n\n        // '!==' needed, otherwise ''==0\n        if ($id_adh !== '' && $id_adh !== null) {\n            $this->id = $id_adh;\n            if (!isset($this->db_id)) {\n                $this->db_id = $id_adh;\n            }\n\n            //if file does not exists on the FileSystem, check for it in the database\n            if (!$this->checkFileOnFS()) {\n                if ($this->checkFileInDB()) {\n                    $this->has_picture = true;\n                }\n            } else {\n                $this->has_picture = true;\n            }\n        }\n\n        // if we still have no picture, take the default one\n        if (empty($this->file_path)) {\n            $this->getDefaultPicture();\n        }\n\n        //we should not have an empty file_path, but...\n        if (!empty($this->file_path)) {\n            $this->setSizes();\n        }\n    }\n\n    /**\n     * \"Magic\" function called on unserialize\n     *\n     * @return void\n     */\n    public function __wakeup()\n    {\n        //if file has been deleted since we store our object in the session,\n        //we try to retrieve it\n        if (!$this->checkFileOnFS()) {\n            //if file does not exists on the FileSystem,\n            //check for it in the database\n            //$this->checkFileInDB();\n        } else {\n            $this->has_picture = false;\n        }\n\n        // if we still have no picture, take the default one\n        if (empty($this->file_path)) {\n            $this->getDefaultPicture();\n        }\n\n        //we should not have an empty file_path, but...\n        if (!empty($this->file_path)) {\n            $this->setSizes();\n        }\n    }\n\n    /**\n     * Check if current file is present on the File System\n     *\n     * @return boolean true if file is present on FS, false otherwise\n     */\n    private function checkFileOnFS()\n    {\n        $file_wo_ext = $this->store_path . $this->id;\n        if (file_exists($file_wo_ext . '.jpg')) {\n            $this->file_path = realpath($file_wo_ext . '.jpg');\n            $this->format = 'jpg';\n            $this->mime = 'image/jpeg';\n            return true;\n        } elseif (file_exists($file_wo_ext . '.png')) {\n            $this->file_path = realpath($file_wo_ext . '.png');\n            $this->format = 'png';\n            $this->mime = 'image/png';\n            return true;\n        } elseif (file_exists($file_wo_ext . '.gif')) {\n            $this->file_path = realpath($file_wo_ext . '.gif');\n            $this->format = 'gif';\n            $this->mime = 'image/gif';\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if current file is present in the database,\n     *   and copy it to the File System\n     *\n     * @return boolean true if file is present in the DB, false otherwise\n     */\n    private function checkFileInDB()\n    {\n        global $zdb;\n\n        try {\n            $select = $this->getCheckFileQuery();\n            $results = $zdb->execute($select);\n            $pic = $results->current();\n\n            if ($pic) {\n                // we must regenerate the picture file\n                $file_wo_ext = $this->store_path . $this->id;\n                file_put_contents(\n                    $file_wo_ext . '.' . $pic->format,\n                    $pic->picture\n                );\n\n                $this->format = $pic->format;\n                switch ($this->format) {\n                    case 'jpg':\n                        $this->mime = 'image/jpeg';\n                        break;\n                    case 'png':\n                        $this->mime = 'image/png';\n                        break;\n                    case 'gif':\n                        $this->mime = 'image/gif';\n                        break;\n                }\n                $this->file_path = realpath($file_wo_ext . '.' . $this->format);\n                return true;\n            }\n        } catch (Throwable $e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns the relevant query to check if picture exists in database.\n     *\n     * @return string SELECT query\n     */\n    protected function getCheckFileQuery()\n    {\n        global $zdb;\n        $class = get_class($this);\n\n        $select = $zdb->select($this->tbl_prefix . $class::TABLE);\n        $select->columns(\n            array(\n                'picture',\n                'format'\n            )\n        );\n        $select->where(array($class::PK => $this->db_id));\n        return $select;\n    }\n\n    /**\n     * Gets the default picture to show, anyways\n     *\n     * @return void\n     */\n    protected function getDefaultPicture()\n    {\n        $this->file_path = realpath(_CURRENT_THEME_PATH . 'images/default.png');\n        $this->format = 'png';\n        $this->mime = 'image/png';\n        $this->has_picture = false;\n    }\n\n    /**\n     * Set picture sizes\n     *\n     * @return void\n     */\n    private function setSizes()\n    {\n        list($width, $height) = getimagesize($this->file_path);\n        $this->height = $height;\n        $this->width = $width;\n        $this->optimal_height = $height;\n        $this->optimal_width = $width;\n\n        if ($this->height > $this->width) {\n            if ($this->height > $this->max_height) {\n                $ratio = $this->max_height / $this->height;\n                $this->optimal_height = $this->max_height;\n                $this->optimal_width = $this->width * $ratio;\n            }\n        } else {\n            if ($this->width > $this->max_width) {\n                $ratio = $this->max_width / $this->width;\n                $this->optimal_width = $this->max_width;\n                $this->optimal_height = $this->height * $ratio;\n            }\n        }\n    }\n\n    /**\n     * Get image file contents\n     *\n     * @return mixed\n     */\n    public function getContents()\n    {\n        readfile($this->file_path);\n    }\n\n    /**\n     * Set header and displays the picture.\n     *\n     * @param Response $response Reponse\n     *\n     * @return object the binary file\n     */\n    public function display(\\Slim\\Http\\Response $response)\n    {\n        $response = $response->withHeader('Content-Type', $this->mime)\n            ->withHeader('Content-Transfer-Encoding', 'binary')\n            ->withHeader('Expires', '0')\n            ->withHeader('Cache-Control', 'must-revalidate')\n            ->withHeader('Pragma', 'public');\n\n        $stream = fopen('php://memory', 'r+');\n        fwrite($stream, file_get_contents($this->file_path));\n        rewind($stream);\n\n        return $response->withBody(new \\Slim\\Http\\Stream($stream));\n    }\n\n    /**\n     * Deletes a picture, from both database and filesystem\n     *\n     * @param boolean $transaction Whether to use a transaction here or not\n     *\n     * @return boolean true if image was successfully deleted, false otherwise\n     */\n    public function delete($transaction = true)\n    {\n        global $zdb;\n        $class = get_class($this);\n\n        try {\n            if ($transaction === true) {\n                $zdb->connection->beginTransaction();\n            }\n\n            $delete = $zdb->delete($this->tbl_prefix . $class::TABLE);\n            $delete->where(\n                $class::PK . ' = ' . $this->db_id\n            );\n            $del = $zdb->execute($delete);\n\n            if (!$del->count() > 0) {\n                Analog::log(\n                    'Unable to remove picture database entry for ' . $this->db_id,\n                    Analog::ERROR\n                );\n                //it may be possible image is missing in the database.\n                //let's try to remove file anyway.\n            }\n\n            $file_wo_ext = $this->store_path . $this->id;\n\n            // take back default picture\n            $this->getDefaultPicture();\n            // fix sizes\n            $this->setSizes();\n\n            $success = false;\n            $_file = null;\n            if (file_exists($file_wo_ext . '.jpg')) {\n                //return unlink($file_wo_ext . '.jpg');\n                $_file = $file_wo_ext . '.jpg';\n                $success = unlink($_file);\n            } elseif (file_exists($file_wo_ext . '.png')) {\n                //return unlink($file_wo_ext . '.png');\n                $_file = $file_wo_ext . '.png';\n                $success = unlink($_file);\n            } elseif (file_exists($file_wo_ext . '.gif')) {\n                //return unlink($file_wo_ext . '.gif');\n                $_file = $file_wo_ext . '.gif';\n                $success = unlink($_file);\n            }\n\n            if ($_file !== null && $success !== true) {\n                //unable to remove file that exists!\n                if ($transaction === true) {\n                    $zdb->connection->rollBack();\n                }\n                Analog::log(\n                    'The file ' . $_file .\n                    ' was found on the disk but cannot be removed.',\n                    Analog::ERROR\n                );\n                return false;\n            } else {\n                if ($transaction === true) {\n                    $zdb->connection->commit();\n                }\n                $this->has_picture = false;\n                return true;\n            }\n        } catch (Throwable $e) {\n            if ($transaction === true) {\n                $zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred attempting to delete picture ' . $this->db_id .\n                'from database | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Stores an image on the disk and in the database\n     *\n     * @param object  $file the uploaded file\n     * @param boolean $ajax If the image cames from an ajax call (dnd)\n     *\n     * @return true|false result of the storage process\n     */\n    public function store($file, $ajax = false)\n    {\n        /** TODO: fix max size (by preferences ?) */\n        global $zdb;\n\n        $class = get_class($this);\n\n        $name = $file['name'];\n        $tmpfile = $file['tmp_name'];\n\n        //First, does the file have a valid name?\n        $reg = \"/^([^\" . implode('', $this->bad_chars) . \"]+)\\.(\" .\n            implode('|', $this->allowed_extensions) . \")$/i\";\n        if (preg_match($reg, $name, $matches)) {\n            Analog::log(\n                '[' . $class . '] Filename and extension are OK, proceed.',\n                Analog::DEBUG\n            );\n            $extension = strtolower($matches[2]);\n            if ($extension == 'jpeg') {\n                //jpeg is an allowed extension,\n                //but we change it to jpg to reduce further tests :)\n                $extension = 'jpg';\n            }\n        } else {\n            $erreg = \"/^([^\" . implode('', $this->bad_chars) . \"]+)\\.(.*)/i\";\n            $m = preg_match($erreg, $name, $errmatches);\n\n            $err_msg = '[' . $class . '] ';\n            if ($m == 1) {\n                //ok, we got a good filename and an extension. Extension is bad :)\n                $err_msg .= 'Invalid extension for file ' . $name . '.';\n                $ret = self::INVALID_EXTENSION;\n            } else {\n                $err_msg = 'Invalid filename `' . $name . '` (Tip: ';\n                $err_msg .= preg_replace(\n                    '|%s|',\n                    htmlentities($this->getBadChars()),\n                    \"file name should not contain any of: %s). \"\n                );\n                $ret = self::INVALID_FILENAME;\n            }\n\n            Analog::log(\n                $err_msg,\n                Analog::ERROR\n            );\n            return $ret;\n        }\n\n        //Second, let's check file size\n        if ($file['size'] > ($this->maxlenght * 1024)) {\n            Analog::log(\n                '[' . $class . '] File is too big (' . ($file['size'] * 1024) .\n                'Ko for maximum authorized ' . ($this->maxlenght * 1024) .\n                'Ko',\n                Analog::ERROR\n            );\n            return self::FILE_TOO_BIG;\n        } else {\n            Analog::log('[' . $class . '] Filesize is OK, proceed', Analog::DEBUG);\n        }\n\n        $current = getimagesize($tmpfile);\n\n        if (!in_array($current['mime'], $this->allowed_mimes)) {\n            Analog::log(\n                '[' . $class . '] Mimetype `' . $current['mime'] . '` not allowed',\n                Analog::ERROR\n            );\n            return self::MIME_NOT_ALLOWED;\n        } else {\n            Analog::log(\n                '[' . $class . '] Mimetype is allowed, proceed',\n                Analog::DEBUG\n            );\n        }\n\n        $this->delete();\n\n        $new_file = $this->store_path .\n            $this->id . '.' . $extension;\n        if ($ajax === true) {\n            rename($tmpfile, $new_file);\n        } else {\n            move_uploaded_file($tmpfile, $new_file);\n        }\n\n        // current[0] gives width ; current[1] gives height\n        if ($current[0] > $this->max_width || $current[1] > $this->max_height) {\n            /** FIXME: what if image cannot be resized?\n                Should'nt we want to stop the process here? */\n            $this->resizeImage($new_file, $extension);\n        }\n\n        return $this->storeInDb($zdb, $this->db_id, $new_file, $extension);\n    }\n\n    /**\n     * Stores an image in the database\n     *\n     * @param Db     $zdb  Database instance\n     * @param int    $id   Member ID\n     * @param string $file File path on disk\n     * @param string $ext  File extension\n     *\n     * @return boolean\n     */\n    private function storeInDb(Db $zdb, $id, $file, $ext)\n    {\n        $f = fopen($file, 'r');\n        $picture = '';\n        while ($r = fread($f, 8192)) {\n            $picture .= $r;\n        }\n        fclose($f);\n\n        $class = get_class($this);\n\n        try {\n            $zdb->connection->beginTransaction();\n            $stmt = $this->insert_stmt;\n            if ($stmt == null) {\n                $insert = $zdb->insert($this->tbl_prefix . $class::TABLE);\n                $insert->values(\n                    array(\n                        $class::PK  => ':' . $class::PK,\n                        'picture'   => ':picture',\n                        'format'    => ':format'\n                    )\n                );\n                $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n                $container = $stmt->getParameterContainer();\n                $container->offsetSet(\n                    'picture', //'picture',\n                    ':picture',\n                    $container::TYPE_LOB\n                );\n                $stmt->setParameterContainer($container);\n                $this->insert_stmt = $stmt;\n            }\n\n            $stmt->execute(\n                array(\n                    $class::PK  => $id,\n                    'picture'   => $picture,\n                    'format'    => $ext\n                )\n            );\n            $zdb->connection->commit();\n            $this->has_picture = true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            Analog::log(\n                'An error occurred storing picture in database: ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return self::SQL_ERROR;\n        }\n\n        return true;\n    }\n\n    /**\n     * Check for missing images in database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return void\n     */\n    public function missingInDb(Db $zdb)\n    {\n        $existing_disk = array();\n\n        //retrieve files on disk\n        if ($handle = opendir($this->store_path)) {\n            while (false !== ($entry = readdir($handle))) {\n                $reg = \"/^(\\d+)\\.(\" .\n                    implode('|', $this->allowed_extensions) . \")$/i\";\n                if (preg_match($reg, $entry, $matches)) {\n                    $id = $matches[1];\n                    $extension = strtolower($matches[2]);\n                    if ($extension == 'jpeg') {\n                        //jpeg is an allowed extension,\n                        //but we change it to jpg to reduce further tests :)\n                        $extension = 'jpg';\n                    }\n                    $existing_disk[$id] = array(\n                        'name'  => $entry,\n                        'id'    => $id,\n                        'ext'   => $extension\n                    );\n                }\n            }\n            closedir($handle);\n\n            if (count($existing_disk) === 0) {\n                //no image on disk, nothing to do :)\n                return;\n            }\n\n            //retrieve files in database\n            $class = get_class($this);\n            $select = $zdb->select($this->tbl_prefix . $class::TABLE);\n            $select\n                ->columns(array($class::PK))\n                ->where->in($class::PK, array_keys($existing_disk));\n\n            $results = $zdb->execute($select);\n\n            $existing_db = array();\n            foreach ($results as $result) {\n                $existing_db[] = (int)$result[self::PK];\n            }\n\n            $existing_diff = array_diff(array_keys($existing_disk), $existing_db);\n\n            //retrieve valid members ids\n            $members = new Members();\n            $valids = $members->getArrayList(\n                $existing_diff,\n                null,\n                false,\n                false,\n                array(self::PK)\n            );\n\n            foreach ($valids as $valid) {\n                $file = $existing_disk[$valid->id_adh];\n                $this->storeInDb(\n                    $zdb,\n                    $file['id'],\n                    $this->store_path . $file['id'] . '.' . $file['ext'],\n                    $file['ext']\n                );\n            }\n        } else {\n            Analog::log(\n                'Something went wrong opening images directory ' .\n                $this->store_path,\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Resize the image if it exceed max allowed sizes\n     *\n     * @param string $source the source image\n     * @param string $ext    file's extension\n     * @param string $dest   the destination image.\n     *                       If null, we'll use the source image. Defaults to null\n     *\n     * @return void\n     */\n    private function resizeImage($source, $ext, $dest = null)\n    {\n        $class = get_class($this);\n\n        if (function_exists(\"gd_info\")) {\n            $gdinfo = gd_info();\n            $h = $this->max_height;\n            $w = $this->max_width;\n            if ($dest == null) {\n                $dest = $source;\n            }\n\n            switch (strtolower($ext)) {\n                case 'jpg':\n                    if (!$gdinfo['JPEG Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no JPEG Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                case 'png':\n                    if (!$gdinfo['PNG Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no PNG Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                case 'gif':\n                    if (!$gdinfo['GIF Create Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no GIF Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            list($cur_width, $cur_height, $cur_type, $curattr)\n                = getimagesize($source);\n\n            $ratio = $cur_width / $cur_height;\n\n            // calculate image size according to ratio\n            if ($cur_width > $cur_height) {\n                $h = $w / $ratio;\n            } else {\n                $w = $h * $ratio;\n            }\n\n            $thumb = imagecreatetruecolor($w, $h);\n            switch ($ext) {\n                case 'jpg':\n                    $image = imagecreatefromjpeg($source);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagejpeg($thumb, $dest);\n                    break;\n                case 'png':\n                    $image = imagecreatefrompng($source);\n                    // Turn off alpha blending and set alpha flag. That prevent alpha\n                    // transparency to be saved as an arbitrary color (black in my tests)\n                    imagealphablending($thumb, false);\n                    imagealphablending($image, false);\n                    imagesavealpha($thumb, true);\n                    imagesavealpha($image, true);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagepng($thumb, $dest);\n                    break;\n                case 'gif':\n                    $image = imagecreatefromgif($source);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagegif($thumb, $dest);\n                    break;\n            }\n        } else {\n            Analog::log(\n                '[' . $class . '] GD is not present - ' .\n                'pictures could not be resized!',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Returns current file optimal height (resized)\n     *\n     * @return int optimal height\n     */\n    public function getOptimalHeight()\n    {\n        return (int)round($this->optimal_height, 1);\n    }\n\n    /**\n     * Returns current file height\n     *\n     * @return int current height\n     */\n    public function getHeight()\n    {\n        return $this->height;\n    }\n\n    /**\n     * Returns current file optimal width (resized)\n     *\n     * @return int optimal width\n     */\n    public function getOptimalWidth()\n    {\n        return (int)round($this->optimal_width, 1);\n    }\n\n    /**\n     * Returns current file width\n     *\n     * @return int current width\n     */\n    public function getWidth()\n    {\n        return $this->width;\n    }\n\n    /**\n     * Returns current file format\n     *\n     * @return string\n     */\n    public function getFormat()\n    {\n        return $this->format;\n    }\n\n    /**\n     * Have we got a picture ?\n     *\n     * @return bool True if a picture matches adherent's id, false otherwise\n     */\n    public function hasPicture()\n    {\n        return $this->has_picture;\n    }\n\n    /**\n     * Returns current file full path\n     *\n     * @return string full file path\n     */\n    public function getPath()\n    {\n        return $this->file_path;\n    }\n\n    /**\n     * Returns current mime type\n     *\n     * @return string\n     */\n    public function getMime()\n    {\n        return $this->mime;\n    }\n\n    /**\n     * Return textual error message\n     *\n     * @param int $code The error code\n     *\n     * @return string Localized message\n     */\n    public function getErrorMessage($code)\n    {\n        $error = null;\n        switch ($code) {\n            case self::SQL_ERROR:\n            case self::SQL_BLOB_ERROR:\n                $error = _T(\"An SQL error has occurred.\");\n                break;\n        }\n\n        if ($error === null) {\n            $error = $this->getErrorMessageFromCode($code);\n        }\n\n        return $error;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Abstract dynamic field\n *\n * PHP version 5\n *\n * Copyright \u00a9 2012-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  DynamicFields\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.1dev - 2012-07-28\n */\n\nnamespace Galette\\DynamicFields;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\Db;\nuse Galette\\Entity\\DynamicFieldsHandle;\nuse Galette\\Features\\Translatable;\nuse Galette\\Features\\I18n;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Predicate\\Expression as PredicateExpression;\n\n/**\n * Abstract dynamic field\n *\n * @name      DynamicField\n * @category  DynamicFields\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\n\nabstract class DynamicField\n{\n    use Translatable;\n    use I18n;\n\n    public const TABLE = 'field_types';\n    public const PK = 'field_id';\n\n    /** Separator field */\n    public const SEPARATOR = 0;\n    /** Simple text field */\n    public const TEXT = 1;\n    /** Line field */\n    public const LINE = 2;\n    /** Choice field (listbox) */\n    public const CHOICE = 3;\n    /** Date field */\n    public const DATE = 4;\n    /** Boolean field (checkbox) */\n    public const BOOLEAN = 5;\n    /** File field (upload) */\n    public const FILE = 6;\n\n    public const PERM_USER_WRITE = 0;\n    public const PERM_ADMIN = 1;\n    public const PERM_STAFF = 2;\n    public const PERM_MANAGER = 3;\n    public const PERM_USER_READ = 4;\n\n    public const DEFAULT_MAX_FILE_SIZE = 1024;\n    public const VALUES_FIELD_LENGTH = 100;\n\n    protected $has_data = false;\n    protected $has_width = false;\n    protected $has_height = false;\n    protected $has_size = false;\n    protected $multi_valued = false;\n    protected $fixed_values = false;\n    protected $has_permissions = true;\n\n    protected $id;\n    protected $index;\n    protected $perm;\n    protected $required;\n    protected $width;\n    protected $height;\n    protected $repeat;\n    protected $size;\n    protected $old_size;\n    protected $values;\n    protected $form;\n\n    protected $errors;\n\n    protected $zdb;\n\n    /**\n     * Default constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load field from its id\n     *\n     * @param Db  $zdb Database instance\n     * @param int $id  Field id\n     *\n     * @return DynamicField|false\n     */\n    public static function loadFieldType(Db $zdb, $id)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where('field_id = ' . $id);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $field_type = $result->field_type;\n                $field_type = self::getFieldType($zdb, $field_type);\n                $field_type->loadFromRs($result);\n                return $field_type;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | Unable to retrieve field `' . $id .\n                '` information | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n        return false;\n    }\n\n    /**\n     * Get correct field type instance\n     *\n     * @param Db  $zdb Database instance\n     * @param int $t   Field type\n     * @param int $id  Optional dynamic field id (to load data)\n     *\n     * @return DynamicField\n     */\n    public static function getFieldType(Db $zdb, $t, $id = null)\n    {\n        $df = null;\n        switch ($t) {\n            case self::SEPARATOR:\n                $df = new Separator($zdb, $id);\n                break;\n            case self::TEXT:\n                $df = new Text($zdb, $id);\n                break;\n            case self::LINE:\n                $df = new Line($zdb, $id);\n                break;\n            case self::CHOICE:\n                $df = new Choice($zdb, $id);\n                break;\n            case self::DATE:\n                $df = new Date($zdb, $id);\n                break;\n            case self::BOOLEAN:\n                $df = new Boolean($zdb, $id);\n                break;\n            case self::FILE:\n                $df = new File($zdb, $id);\n                break;\n            default:\n                throw new \\Exception('Unknown field type ' . $t . '!');\n                break;\n        }\n        return $df;\n    }\n\n    /**\n     * Load field\n     *\n     * @param integer $id Id\n     *\n     * @return void\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->where(self::PK . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if ($result) {\n                $this->loadFromRs($result);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to retrieve field type for field ' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Load field type from a db ResultSet\n     *\n     * @param ResultSet $rs     ResultSet\n     * @param boolean   $values Whether to load values. Defaults to true\n     *\n     * @return void\n     */\n    public function loadFromRs($rs, $values = true)\n    {\n        $this->id = (int)$rs->field_id;\n        $this->name = $rs->field_name;\n        $this->index = (int)$rs->field_index;\n        $this->perm = (int)$rs->field_perm;\n        $this->required = ($rs->field_required == 1 ? true : false);\n        $this->width = $rs->field_width;\n        $this->height = $rs->field_height;\n        $this->repeat = $rs->field_repeat;\n        $this->size = $rs->field_size;\n        $this->form = $rs->field_form;\n        if ($values && $this->hasFixedValues()) {\n            $this->loadFixedValues();\n        }\n    }\n\n    /**\n     * Retrieve fixed values table name\n     *\n     * @param integer $id       Field ID\n     * @param boolean $prefixed Whether table name should be prefixed\n     *\n     * @return string\n     */\n    public static function getFixedValuesTableName($id, $prefixed = false)\n    {\n        $name = 'field_contents_' . $id;\n        if ($prefixed === true) {\n            $name = PREFIX_DB . $name;\n        }\n        return $name;\n    }\n\n    /**\n     * Returns an array of fixed valued for a field of type 'choice'.\n     *\n     * @return void\n     */\n    private function loadFixedValues()\n    {\n        try {\n            $val_select = $this->zdb->select(\n                self::getFixedValuesTableName($this->id)\n            );\n\n            $val_select->columns(\n                array(\n                    'val'\n                )\n            )->order('id');\n\n            $results = $this->zdb->execute($val_select);\n            $this->values = array();\n            if ($results) {\n                foreach ($results as $val) {\n                    $this->values[] = $val->val;\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n        }\n    }\n\n    /**\n     * Get field type\n     *\n     * @return integer\n     */\n    abstract public function getType();\n\n    /**\n     * Get field type name\n     *\n     * @return String\n     */\n    public function getTypeName()\n    {\n        $types = $this->getFieldsTypesNames();\n        if (isset($types[$this->getType()])) {\n            return $types[$this->getType()];\n        } else {\n            throw new \\RuntimeException(\n                'Unknow type ' . $this->getType()\n            );\n        }\n    }\n\n    /**\n     * Does the field handle data?\n     *\n     * @return boolean\n     */\n    public function hasData()\n    {\n        return $this->has_data;\n    }\n\n    /**\n     * Does the field has width?\n     *\n     * @return boolean\n     */\n    public function hasWidth()\n    {\n        return $this->has_width;\n    }\n\n    /**\n     * Does the field has height?\n     *\n     * @return boolean\n     */\n    public function hasHeight()\n    {\n        return $this->has_height;\n    }\n\n    /**\n     * Does the field has a size?\n     *\n     * @return boolean\n     */\n    public function hasSize()\n    {\n        return $this->has_size;\n    }\n\n    /**\n     * Is the field multi valued?\n     *\n     * @return boolean\n     */\n    public function isMultiValued()\n    {\n        return $this->multi_valued;\n    }\n\n    /**\n     * Does the field has fixed values?\n     *\n     * @return boolean\n     */\n    public function hasFixedValues()\n    {\n        return $this->fixed_values;\n    }\n\n    /**\n     * Does the field require permissions?\n     *\n     * @return boolean\n     */\n    public function hasPermissions()\n    {\n        return $this->has_permissions;\n    }\n\n\n    /**\n     * Get field id\n     *\n     * @return integer\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Get field Permissions\n     *\n     * @return integer\n     */\n    public function getPerm()\n    {\n        return $this->perm;\n    }\n\n\n    /**\n     * Is field required?\n     *\n     * @return boolean\n     */\n    public function isRequired()\n    {\n        return $this->required;\n    }\n\n    /**\n     * Get field width\n     *\n     * @return integer\n     */\n    public function getWidth()\n    {\n        return $this->width;\n    }\n\n    /**\n     * Get field height\n     *\n     * @return integer\n     */\n    public function getHeight()\n    {\n        return $this->height;\n    }\n\n    /**\n     * Is current field repeatable?\n     *\n     * @return boolean\n     */\n    public function isRepeatable()\n    {\n        return $this->repeat != null && trim($this->repeat) != '' && (int)$this->repeat >= 0;\n    }\n\n    /**\n     * Get fields repetitions\n     *\n     * @return integer|boolean\n     */\n    public function getRepeat()\n    {\n        return $this->repeat;\n    }\n\n    /**\n     * Get field size\n     *\n     * @return integer\n     */\n    public function getSize()\n    {\n        return $this->size;\n    }\n\n    /**\n     * Get field index\n     *\n     * @return integer\n     */\n    public function getIndex()\n    {\n        return $this->index;\n    }\n\n    /**\n     * Retrieve permissions names for display\n     *\n     * @return array\n     */\n    public static function getPermsNames()\n    {\n        return [\n            self::PERM_USER_WRITE => _T(\"User, read/write\"),\n            self::PERM_STAFF      => _T(\"Staff member\"),\n            self::PERM_ADMIN      => _T(\"Administrator\"),\n            self::PERM_MANAGER    => _T(\"Group manager\"),\n            self::PERM_USER_READ  => _T(\"User, read only\")\n        ];\n    }\n\n    /**\n     * Retrieve forms names\n     *\n     * @return array\n     */\n    public static function getFormsNames()\n    {\n        return [\n            'adh'       => _T(\"Members\"),\n            'contrib'   => _T(\"Contributions\"),\n            'trans'     => _T(\"Transactions\")\n        ];\n    }\n\n    /**\n     * Retrieve form name\n     *\n     * @param string $form_name Form name\n     *\n     * @return string\n     */\n    public static function getFormTitle($form_name)\n    {\n        $names = self::getFormsNames();\n        return $names[$form_name];\n    }\n\n    /**\n     * Get permission name\n     *\n     * @return string\n     */\n    public function getPermName()\n    {\n        $perms = self::getPermsNames();\n        return $perms[$this->getPerm()];\n    }\n\n    /**\n     * Get form\n     *\n     * @return string\n     */\n    public function getForm()\n    {\n        return $this->form;\n    }\n\n    /**\n     * Get field values\n     *\n     * @param boolean $imploded Whether to implode values\n     *\n     * @return array\n     */\n    public function getValues($imploded = false)\n    {\n        if (!is_array($this->values)) {\n            return false;\n        }\n        if ($imploded === true) {\n            return implode(\"\\n\", $this->values);\n        } else {\n            return $this->values;\n        }\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values All values to check, basically the $_POST array\n     *                      after sending the form\n     *\n     * @return true|array\n     */\n    public function check($values)\n    {\n        $this->errors = [];\n        $this->warnings = [];\n\n        if (\n            (!isset($values['field_name']) || $values['field_name'] == '')\n            && get_class($this) != '\\Galette\\DynamicField\\Separator'\n        ) {\n            $this->errors[] = _T('Missing required field name!');\n        } else {\n            if ($this->old_name === null && $this->name !== null && $this->name != $values['field_name']) {\n                $this->old_name = $this->name;\n            }\n            $this->name = $values['field_name'];\n        }\n\n        if (!isset($values['field_perm']) || $values['field_perm'] === '') {\n            $this->errors[] = _T('Missing required field permissions!');\n        } else {\n            if (in_array($values['field_perm'], array_keys(self::getPermsNames()))) {\n                $this->perm = $values['field_perm'];\n            } else {\n                $this->errors[] = _T('Unknown permission!');\n            }\n        }\n\n        if ($this->id === null) {\n            if (!isset($values['form_name']) || $values['form_name'] == '') {\n                $this->errors[] = _T('Missing required form!');\n            } else {\n                if (in_array($values['form_name'], array_keys(self::getFormsNames()))) {\n                    $this->form = $values['form_name'];\n                } else {\n                    $this->errors[] = _T('Unknown form!');\n                }\n            }\n        }\n\n        $this->required = $values['field_required'] ?? false;\n\n        if (count($this->errors) === 0 && $this->isDuplicate($values['form_name'], $this->name, $this->id)) {\n            $this->errors[] = _T(\"- Field name already used.\");\n        }\n\n        if ($this->hasWidth() && isset($values['field_width']) && trim($values['field_width']) != '') {\n            $this->width = $values['field_width'];\n        }\n\n        if ($this->hasHeight() && isset($values['field_height']) && trim($values['field_height']) != '') {\n            $this->height = $values['field_height'];\n        }\n\n        if ($this->hasSize() && isset($values['field_size']) && trim($values['field_size']) != '') {\n            $this->size = $values['field_size'];\n        }\n\n        if (isset($values['field_repeat']) && trim($values['field_repeat']) != '') {\n            $this->repeat = $values['field_repeat'];\n        }\n\n        if ($this->hasFixedValues() && isset($values['fixed_values'])) {\n            $fixed_values = [];\n            foreach (explode(\"\\n\", $values['fixed_values']) as $val) {\n                $val = trim($val);\n                $len = mb_strlen($val);\n                if ($len > 0) {\n                    $fixed_values[] = $val;\n                    if ($len > $this->size) {\n                        if ($this->old_size === null) {\n                            $this->old_size = $this->size;\n                        }\n                        $this->size = $len;\n                    }\n                }\n            }\n\n            $this->values = $fixed_values;\n        }\n\n        if ($this->id == null) {\n            $this->index = $this->getNewIndex();\n        }\n\n        if (count($this->errors) === 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Store the field type\n     *\n     * @param array $values All values to check, basically the $_POST array\n     *                      after sending the form\n     *\n     * @return boolean\n     */\n    public function store($values)\n    {\n        if (!$this->check($values)) {\n            return false;\n        }\n\n        $isnew = ($this->id === null);\n        if ($this->old_name !== null) {\n            $this->deleteTranslation($this->old_name);\n            $this->addTranslation($this->name);\n        }\n\n        try {\n            $values = array(\n                'field_name'        => strip_tags($this->name),\n                'field_perm'        => $this->perm,\n                'field_required'    => $this->required,\n                'field_width'       => ($this->width === null ? new Expression('NULL') : $this->width),\n                'field_height'      => ($this->height === null ? new Expression('NULL') : $this->height),\n                'field_size'        => ($this->size === null ? new Expression('NULL') : $this->size),\n                'field_repeat'      => ($this->repeat === null ? new Expression('NULL') : $this->repeat),\n                'field_form'        => $this->form,\n                'field_index'       => $this->index\n            );\n\n            if ($this->required === false) {\n                //Handle booleans for postgres ; bugs #18899 and #19354\n                $values['field_required'] = $this->zdb->isPostgres() ? 'false' : 0;\n            }\n\n            if (!$isnew) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where(\n                    self::PK . ' = ' . $this->id\n                );\n                $this->zdb->execute($update);\n            } else {\n                $values['field_type'] = $this->getType();\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $this->zdb->execute($insert);\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                if ($this->name != '') {\n                    $this->addTranslation($this->name);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing field | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            $this->errors[] = _T(\"An error occurred storing the field.\");\n        }\n\n        if (count($this->errors) === 0 && $this->hasFixedValues()) {\n            $contents_table = self::getFixedValuesTableName($this->id, true);\n\n            try {\n                $this->zdb->drop(str_replace(PREFIX_DB, '', $contents_table), true);\n                $field_size = ((int)$this->size > 0) ? $this->size : 1;\n                $this->zdb->db->query(\n                    'CREATE TABLE ' . $contents_table .\n                    ' (id INTEGER NOT NULL,val varchar(' . $field_size .\n                    ') NOT NULL)',\n                    \\Laminas\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE\n                );\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Unable to manage fields values table ' .\n                    $contents_table . ' | ' . $e->getMessage(),\n                    Analog::ERROR\n                );\n                $this->errors[] = _T(\"An error occurred creating field values table\");\n            }\n\n            if (count($this->errors) == 0 && is_array($this->values)) {\n                $contents_table = self::getFixedValuesTableName($this->id);\n                try {\n                    $this->zdb->connection->beginTransaction();\n\n                    $insert = $this->zdb->insert($contents_table);\n                    $insert->values(\n                        array(\n                            'id'    => ':id',\n                            'val'   => ':val'\n                        )\n                    );\n                    $stmt = $this->zdb->sql->prepareStatementForSqlObject($insert);\n\n                    $cnt_values = count($this->values);\n                    for ($i = 0; $i < $cnt_values; $i++) {\n                        $stmt->execute(\n                            array(\n                                'id'    => $i,\n                                'val'   => $this->values[$i]\n                            )\n                        );\n                    }\n                    $this->zdb->connection->commit();\n                } catch (Throwable $e) {\n                    $this->zdb->connection->rollBack();\n                    Analog::log(\n                        'Unable to store field ' . $this->id . ' values (' .\n                        $e->getMessage() . ')',\n                        Analog::ERROR\n                    );\n                    $this->warnings[] = _T('An error occurred storing dynamic field values :(');\n                }\n            }\n        }\n\n        if (count($this->errors) === 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Get new index\n     *\n     * @return integer\n     */\n    protected function getNewIndex()\n    {\n        $select = $this->zdb->select(self::TABLE);\n        $select->columns(\n            array(\n                'idx' => new \\Laminas\\Db\\Sql\\Expression('COUNT(*) + 1')\n            )\n        );\n        $select->where(['field_form' => $this->form]);\n        $results = $this->zdb->execute($select);\n        $result = $results->current();\n        $idx = $result->idx;\n        return $idx;\n    }\n\n    /**\n     * Is field duplicated?\n     *\n     * @return boolean\n     */\n    public function isDuplicate()\n    {\n        //let's consider field is duplicated, in case of future errors\n        $duplicated = true;\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array(\n                    'cnt' => new \\Laminas\\Db\\Sql\\Expression('COUNT(' . self::PK . ')')\n                )\n            )->where(\n                array(\n                    'field_form' => $this->form,\n                    'field_name' => $this->name\n                )\n            );\n\n            if ($this->id !== null) {\n                $select->where->addPredicate(\n                    new PredicateExpression(\n                        'field_id NOT IN (?)',\n                        array($this->id)\n                    )\n                );\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dup = $result->cnt;\n            if (!$dup > 0) {\n                $duplicated = false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred checking field duplicity' . $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n        return $duplicated;\n    }\n    /**\n     * Move a dynamic field\n     *\n     * @param string $action What to do (either 'up' or 'down')\n     *\n     * @return boolean\n     */\n    public function move($action)\n    {\n        try {\n            $this->zdb->connection->beginTransaction();\n\n            $old_rank = $this->index;\n\n            $direction = $action == 'up' ? -1 : 1;\n            $new_rank = $old_rank + $direction;\n            $update = $this->zdb->update(self::TABLE);\n            $update->set([\n                    'field_index' => $old_rank\n            ])->where([\n                    'field_index'   => $new_rank,\n                    'field_form'    => $this->form\n            ]);\n            $this->zdb->execute($update);\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array(\n                    'field_index' => $new_rank\n                )\n            )->where(\n                array(\n                    self::PK        => $this->id\n                )\n            );\n            $this->zdb->execute($update);\n            $this->zdb->connection->commit();\n\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to change field ' . $this->id . ' rank | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Delete a dynamic field\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        try {\n            if ($this->hasFixedValues()) {\n                $contents_table = self::getFixedValuesTableName($this->id);\n                $this->zdb->drop($contents_table);\n            }\n\n            $this->zdb->connection->beginTransaction();\n            $old_rank = $this->index;\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array(\n                    'field_index' => new \\Laminas\\Db\\Sql\\Expression('field_index-1')\n                )\n            )->where\n                ->greaterThan('field_index', $old_rank)\n                ->equalTo('field_form', $this->form);\n            $this->zdb->execute($update);\n\n            //remove associated values\n            $delete = $this->zdb->delete(DynamicFieldsHandle::TABLE);\n            $delete->where(\n                array(\n                    'field_id'      => $this->id,\n                    'field_form'    => $this->form\n                )\n            );\n            $result = $this->zdb->execute($delete);\n            if (!$result) {\n                throw new \\RuntimeException('Unable to remove associated values for field ' . $this->id . '!');\n            }\n\n            //remove field type\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                array(\n                    'field_id'      => $this->id,\n                    'field_form'    => $this->form\n                )\n            );\n            $result = $this->zdb->execute($delete);\n            if (!$result) {\n                throw new \\RuntimeException('Unable to remove field ' . $this->id . '!');\n            }\n\n            $this->deleteTranslation($this->name);\n\n            $this->zdb->connection->commit();\n\n            return true;\n        } catch (Throwable $e) {\n            if ($this->zdb->connection->inTransaction()) {\n                //because of DROP autocommit on mysql...\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred deleting field | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Retrieve fields types names\n     *\n     * @return array\n     */\n    public static function getFieldsTypesNames()\n    {\n        $names = [\n            self::SEPARATOR => _T(\"separator\"),\n            self::TEXT      => _T(\"free text\"),\n            self::LINE      => _T(\"single line\"),\n            self::CHOICE    => _T(\"choice\"),\n            self::DATE      => _T(\"date\"),\n            self::BOOLEAN   => _T(\"boolean\"),\n            self::FILE      => _T(\"file\")\n        ];\n        return $names;\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get warnings\n     *\n     * @return array\n     */\n    public function getWarnings()\n    {\n        return $this->warnings;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Member class for galette\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-06-02\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Features\\Socials;\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Picture;\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Core\\Password;\nuse Galette\\Core\\Preferences;\nuse Galette\\Core\\History;\nuse Galette\\Repository\\Groups;\nuse Galette\\Core\\Login;\nuse Galette\\Repository\\Members;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Member class for galette\n *\n * @category  Entity\n * @name      Adherent\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 02-06-2009\n *\n * @property integer $id\n * @property integer|Title $title Either a title id or an instance of Title\n * @property string $stitle Title label\n * @property string company_name\n * @property string $name\n * @property string $surname\n * @property string $nickname\n * @property string $birthdate Localized birth date\n * @property string $rbirthdate Raw birth date\n * @property string $birth_place\n * @property integer $gender\n * @property string $sgender Gender label\n * @property string $job\n * @property string $language\n * @property integer $status\n * @property string $sstatus Status label\n * @property string $address\n * @property string $address_continuation\n * @property string $zipcode\n * @property string $town\n * @property string $country\n * @property string $phone\n * @property string $gsm\n * @property string $email\n * @property string $gnupgid\n * @property string $fingerprint\n * @property string $login\n * @property string $creation_date Localized creation date\n * @property string $modification_date Localized modification date\n * @property string $due_date Localized due date\n * @property string $others_infos\n * @property string $others_infos_admin\n * @property Picture $picture\n * @property array $groups\n * @property array $managed_groups\n * @property integer|Adherent $parent Parent id if parent dep is not loaded, Adherent instance otherwise\n * @property array $children\n * @property boolean $admin better to rely on isAdmin()\n * @property boolean $staff better to rely on isStaff()\n * @property boolean $due_free better to rely on isDueFree()\n * @property boolean $appears_in_list better to rely on appearsInMembersList()\n * @property boolean $active better to rely on isActive()\n * @property boolean $duplicate better to rely on isDuplicate()\n * @property string $sadmin yes/no\n * @property string $sstaff yes/no\n * @property string $sdue_free yes/no\n * @property string $sappears_in_list yes/no\n * @property string $sactive yes/no\n * @property string $sfullname\n * @property string $sname\n * @property string $saddress Concatened address and continuation\n * @property string $contribstatus State of member contributions\n * @property string $days_remaining\n * @property-read integer $parent_id\n * @property Social $social Social networks/Contact\n * @property string $number Member number\n *\n */\nclass Adherent\n{\n    use Dynamics;\n    use Socials;\n\n    public const TABLE = 'adherents';\n    public const PK = 'id_adh';\n\n    public const NC = 0;\n    public const MAN = 1;\n    public const WOMAN = 2;\n\n    public const AFTER_ADD_DEFAULT = 0;\n    public const AFTER_ADD_TRANS = 1;\n    public const AFTER_ADD_NEW = 2;\n    public const AFTER_ADD_SHOW = 3;\n    public const AFTER_ADD_LIST = 4;\n    public const AFTER_ADD_HOME = 5;\n\n    private $_id;\n    //Identity\n    private $_title;\n    private $_company_name;\n    private $_name;\n    private $_surname;\n    private $_nickname;\n    private $_birthdate;\n    private $_birth_place;\n    private $_gender;\n    private $_job;\n    private $_language;\n    private $_active;\n    private $_status;\n    //Contact information\n    private $_address;\n    private $_address_continuation; /** TODO: remove */\n    private $_zipcode;\n    private $_town;\n    private $_country;\n    private $_phone;\n    private $_gsm;\n    private $_email;\n    private $_gnupgid;\n    private $_fingerprint;\n    //Galette relative information\n    private $_appears_in_list;\n    private $_admin;\n    private $_staff;\n    private $_due_free;\n    private $_login;\n    private $_password;\n    private $_creation_date;\n    private $_modification_date;\n    private $_due_date;\n    private $_others_infos;\n    private $_others_infos_admin;\n    private $_picture;\n    private $_oldness;\n    private $_days_remaining;\n    private $_groups;\n    private $_managed_groups;\n    private $_parent;\n    private $_children;\n    private $_duplicate = false;\n    private $_socials;\n    private $_number;\n\n    private $_row_classes;\n\n    private $_self_adh = false;\n    private $_deps = array(\n        'picture'   => true,\n        'groups'    => true,\n        'dues'      => true,\n        'parent'    => false,\n        'children'  => false,\n        'dynamics'  => false,\n        'socials'   => false\n    );\n\n    private $zdb;\n    private $preferences;\n    private $fields;\n    private $history;\n\n    private $parent_fields = [\n        'adresse_adh',\n        'adresse2_adh',\n        'cp_adh',\n        'ville_adh',\n        'email_adh'\n    ];\n\n    private $errors = [];\n\n    private $sendmail = false;\n\n    /**\n     * Default constructor\n     *\n     * @param Db          $zdb  Database instance\n     * @param mixed       $args Either a ResultSet row, its id or its\n     *                          login or its email for to load s specific\n     *                          member, or null to just instantiate object\n     * @param false|array $deps Dependencies configuration, see Adherent::$_deps\n     */\n    public function __construct(Db $zdb, $args = null, $deps = null)\n    {\n        global $i18n;\n\n        $this->zdb = $zdb;\n\n        if ($deps !== null) {\n            if (is_array($deps)) {\n                $this->_deps = array_merge(\n                    $this->_deps,\n                    $deps\n                );\n            } elseif ($deps === false) {\n                //no dependencies\n                $this->_deps = array_fill_keys(\n                    array_keys($this->_deps),\n                    false\n                );\n            } else {\n                Analog::log(\n                    '$deps should be an array, ' . gettype($deps) . ' given!',\n                    Analog::WARNING\n                );\n            }\n        }\n\n        if ($args == null || is_int($args)) {\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            } else {\n                $this->_active = true;\n                $this->_language = $i18n->getID();\n                $this->_creation_date = date(\"Y-m-d\");\n                $this->_status = $this->getDefaultStatus();\n                $this->_title = null;\n                $this->_gender = self::NC;\n                $gp = new Password($this->zdb);\n                $this->_password = $gp->makeRandomPassword();\n                $this->_picture = new Picture();\n                $this->_admin = false;\n                $this->_staff = false;\n                $this->_due_free = false;\n                $this->_appears_in_list = false;\n                $this->_parent = null;\n\n                if ($this->_deps['dynamics'] === true) {\n                    $this->loadDynamicFields();\n                }\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        } elseif (is_string($args)) {\n            $this->loadFromLoginOrMail($args);\n        }\n    }\n\n    /**\n     * Loads a member from its id\n     *\n     * @param int $id the identifier for the member to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'a');\n\n            $select->join(\n                array('b' => PREFIX_DB . Status::TABLE),\n                'a.' . Status::PK . '=b.' . Status::PK,\n                array('priorite_statut')\n            )->where(array(self::PK => $id));\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() === 0) {\n                return false;\n            }\n\n            $this->loadFromRS($results->current());\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member form id `' . $id . '` | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads a member from its login\n     *\n     * @param string $login login for the member to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function loadFromLoginOrMail($login)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            if (GaletteMail::isValidEmail($login)) {\n                //we got a valid email address, use it\n                $select->where(array('email_adh' => $login));\n            } else {\n                ///we did not get an email address, consider using login\n                $select->where(array('login_adh' => $login));\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $this->loadFromRS($result);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member form login `' . $login . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->_self_adh = false;\n        $this->_id = $r->id_adh;\n        //Identity\n        if ($r->titre_adh !== null) {\n            $this->_title = new Title((int)$r->titre_adh);\n        }\n        $this->_company_name = $r->societe_adh;\n        $this->_name = $r->nom_adh;\n        $this->_surname = $r->prenom_adh;\n        $this->_nickname = $r->pseudo_adh;\n        if ($r->ddn_adh != '1901-01-01') {\n            $this->_birthdate = $r->ddn_adh;\n        }\n        $this->_birth_place = $r->lieu_naissance;\n        $this->_gender = (int)$r->sexe_adh;\n        $this->_job = $r->prof_adh;\n        $this->_language = $r->pref_lang;\n        $this->_active = ($r->activite_adh == 1) ? true : false;\n        $this->_status = (int)$r->id_statut;\n        //Contact information\n        $this->_address = $r->adresse_adh;\n        /** TODO: remove and merge with address */\n        $this->_address_continuation = $r->adresse2_adh;\n        $this->_zipcode = $r->cp_adh;\n        $this->_town = $r->ville_adh;\n        $this->_country = $r->pays_adh;\n        $this->_phone = $r->tel_adh;\n        $this->_gsm = $r->gsm_adh;\n        $this->_email = $r->email_adh;\n        $this->_gnupgid = $r->gpgid;\n        $this->_fingerprint = $r->fingerprint;\n        //Galette relative information\n        $this->_appears_in_list = ($r->bool_display_info == 1) ? true : false;\n        $this->_admin = ($r->bool_admin_adh == 1) ? true : false;\n        if (\n            isset($r->priorite_statut)\n            && $r->priorite_statut < Members::NON_STAFF_MEMBERS\n        ) {\n            $this->_staff = true;\n        }\n        $this->_due_free = ($r->bool_exempt_adh == 1) ? true : false;\n        $this->_login = $r->login_adh;\n        $this->_password = $r->mdp_adh;\n        $this->_creation_date = $r->date_crea_adh;\n        if ($r->date_modif_adh != '1901-01-01') {\n            $this->_modification_date = $r->date_modif_adh;\n        } else {\n            $this->_modification_date = $this->_creation_date;\n        }\n        $this->_due_date = $r->date_echeance;\n        $this->_others_infos = $r->info_public_adh;\n        $this->_others_infos_admin = $r->info_adh;\n        $this->_number = $r->num_adh;\n\n        if ($r->parent_id !== null) {\n            $this->_parent = (int)$r->parent_id;\n            if ($this->_deps['parent'] === true) {\n                $this->loadParent();\n            }\n        }\n\n        if ($this->_deps['children'] === true) {\n            $this->loadChildren();\n        }\n\n        if ($this->_deps['picture'] === true) {\n            $this->_picture = new Picture($this->_id);\n        }\n\n        if ($this->_deps['groups'] === true) {\n            $this->loadGroups();\n        }\n\n        if ($this->_deps['dues'] === true) {\n            $this->checkDues();\n        }\n\n        if ($this->_deps['dynamics'] === true) {\n            $this->loadDynamicFields();\n        }\n\n        if ($this->_deps['socials'] === true) {\n            $this->loadSocials();\n        }\n    }\n\n    /**\n     * Load member parent\n     *\n     * @return void\n     */\n    private function loadParent()\n    {\n        if (!$this->_parent instanceof Adherent) {\n            $deps = array_fill_keys(array_keys($this->_deps), false);\n            $this->_parent = new Adherent($this->zdb, (int)$this->_parent, $deps);\n        }\n    }\n\n    /**\n     * Load member children\n     *\n     * @return void\n     */\n    private function loadChildren()\n    {\n        $this->_children = array();\n        try {\n            $id = self::PK;\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array($id)\n            )->where(\n                'parent_id = ' . $this->_id\n            );\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() > 0) {\n                foreach ($results as $row) {\n                    $deps = $this->_deps;\n                    $deps['children'] = false;\n                    $deps['parent'] = false;\n                    $this->_children[] = new Adherent($this->zdb, (int)$row->$id, $deps);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load children for member #' . $this->_id . ' | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load member groups\n     *\n     * @return void\n     */\n    public function loadGroups()\n    {\n        $this->_groups = Groups::loadGroups($this->_id);\n        $this->_managed_groups = Groups::loadManagedGroups($this->_id);\n    }\n\n    /**\n     * Load member social network/contact information\n     *\n     * @return void\n     */\n    public function loadSocials()\n    {\n        $this->_socials = Social::getListForMember($this->_id);\n    }\n\n    /**\n     * Retrieve status from preferences\n     *\n     * @return pref_statut\n     *\n     */\n    private function getDefaultStatus()\n    {\n        global $preferences;\n        if ($preferences->pref_statut != '') {\n            return $preferences->pref_statut;\n        } else {\n            Analog::log(\n                'Unable to get pref_statut; is it defined in preferences?',\n                Analog::ERROR\n            );\n            return Status::DEFAULT_STATUS;\n        }\n    }\n\n    /**\n     * Check for dues status\n     *\n     * @return void\n     */\n    private function checkDues()\n    {\n        //how many days since our beloved member has been created\n        $date_now = new \\DateTime();\n        $this->_oldness = $date_now->diff(\n            new \\DateTime($this->_creation_date)\n        )->days;\n\n        if ($this->isDueFree()) {\n            //no fee required, we don't care about dates\n            $this->_row_classes .= ' cotis-exempt';\n        } else {\n            //ok, fee is required. Let's check the dates\n            if ($this->_due_date == '') {\n                $this->_row_classes .= ' cotis-never';\n            } else {\n                $date_end = new \\DateTime($this->_due_date);\n                $date_diff = $date_now->diff($date_end);\n                $this->_days_remaining = ($date_diff->invert == 1)\n                    ? $date_diff->days * -1\n                    : $date_diff->days;\n\n                if ($this->_days_remaining == 0) {\n                    $this->_row_classes .= ' cotis-lastday';\n                } elseif ($this->_days_remaining < 0) {\n                    //check if member is still active\n                    $this->_row_classes .= $this->isActive() ? ' cotis-late' : ' cotis-old';\n                } elseif ($this->_days_remaining < 30) {\n                    $this->_row_classes .= ' cotis-soon';\n                } else {\n                    $this->_row_classes .= ' cotis-ok';\n                }\n            }\n        }\n    }\n\n    /**\n     * Is member admin?\n     *\n     * @return bool\n     */\n    public function isAdmin()\n    {\n        return $this->_admin;\n    }\n\n    /**\n     * Is user member of staff?\n     *\n     * @return bool\n     */\n    public function isStaff()\n    {\n        return $this->_staff;\n    }\n\n    /**\n     * Is member freed of dues?\n     *\n     * @return bool\n     */\n    public function isDueFree()\n    {\n        return $this->_due_free;\n    }\n\n    /**\n     * Is member in specified group?\n     *\n     * @param string $group_name Group name\n     *\n     * @return boolean\n     */\n    public function isGroupMember($group_name)\n    {\n        if (is_array($this->_groups)) {\n            foreach ($this->_groups as $g) {\n                if ($g->getName() == $group_name) {\n                    return true;\n                    break;\n                }\n            }\n        } else {\n            Analog::log(\n                'Calling ' . __METHOD__ . ' without groups loaded!',\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Is member manager of specified group?\n     *\n     * @param string $group_name Group name\n     *\n     * @return boolean\n     */\n    public function isGroupManager($group_name)\n    {\n        if (is_array($this->_managed_groups)) {\n            foreach ($this->_managed_groups as $mg) {\n                if ($mg->getName() == $group_name) {\n                    return true;\n                    break;\n                }\n            }\n        } else {\n            Analog::log(\n                'Calling ' . __METHOD__ . ' without groups loaded!',\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Does current member represents a company?\n     *\n     * @return boolean\n     */\n    public function isCompany()\n    {\n        return trim($this->_company_name ?? '') != '';\n    }\n\n    /**\n     * Is current member a man?\n     *\n     * @return boolean\n     */\n    public function isMan()\n    {\n        return (int)$this->_gender === self::MAN;\n    }\n\n    /**\n     * Is current member a woman?\n     *\n     * @return boolean\n     */\n    public function isWoman()\n    {\n        return (int)$this->_gender === self::WOMAN;\n    }\n\n\n    /**\n     * Can member appears in public members list?\n     *\n     * @return bool\n     */\n    public function appearsInMembersList()\n    {\n        return $this->_appears_in_list;\n    }\n\n    /**\n     * Is member active?\n     *\n     * @return bool\n     */\n    public function isActive()\n    {\n        return $this->_active;\n    }\n\n    /**\n     * Does member have uploaded a picture?\n     *\n     * @return bool\n     */\n    public function hasPicture()\n    {\n        return $this->_picture->hasPicture();\n    }\n\n    /**\n     * Does member have a parent?\n     *\n     * @return bool\n     */\n    public function hasParent()\n    {\n        return !empty($this->_parent);\n    }\n\n    /**\n     * Does member have children?\n     *\n     * @return bool\n     */\n    public function hasChildren()\n    {\n        if ($this->_children === null) {\n            if ($this->id) {\n                Analog::log(\n                    'Children has not been loaded!',\n                    Analog::WARNING\n                );\n            }\n            return false;\n        } else {\n            return count($this->_children) > 0;\n        }\n    }\n\n    /**\n     * Get row class related to current fee status\n     *\n     * @param boolean $public we want the class for public pages\n     *\n     * @return string the class to apply\n     */\n    public function getRowClass($public = false)\n    {\n        $strclass = ($this->isActive()) ? 'active' : 'inactive';\n        if ($public === false) {\n            $strclass .= $this->_row_classes;\n        }\n        return $strclass;\n    }\n\n    /**\n     * Get current member due status\n     *\n     * @return string i18n string representing state of due\n     */\n    public function getDues()\n    {\n        $ret = '';\n        $date_now = new \\DateTime();\n        if ($this->isDueFree()) {\n            $ret = _T(\"Freed of dues\");\n        } elseif ($this->_due_date == '') {\n            $patterns = array('/%days/', '/%date/');\n            $cdate = new \\DateTime($this->_creation_date);\n            $replace = array(\n                $this->_oldness,\n                $cdate->format(__(\"Y-m-d\"))\n            );\n            if ($this->_active) {\n                $ret = preg_replace(\n                    $patterns,\n                    $replace,\n                    _T(\"Never contributed: Registered %days days ago (since %date)\")\n                );\n            } else {\n                $ret = _T(\"Never contributed\");\n            }\n        } elseif ($this->_days_remaining == 0) {\n            $ddate = new \\DateTime($this->_due_date);\n            $date_diff = $date_now->diff($ddate);\n            if ($date_diff->invert == 0) {\n                $ret = _T(\"Last day!\");\n            } else {\n                $ret = _T(\"Late since today!\");\n            }\n        } elseif ($this->_days_remaining < 0) {\n            $ddate = new \\DateTime($this->_due_date);\n            $patterns = array('/%days/', '/%date/');\n            $replace = array(\n                $this->_days_remaining * -1,\n                $ddate->format(__(\"Y-m-d\"))\n            );\n            if ($this->_active) {\n                $ret = preg_replace(\n                    $patterns,\n                    $replace,\n                    _T(\"Late of %days days (since %date)\")\n                );\n            } else {\n                $ret = _T(\"No longer member\");\n            }\n        } else {\n            $ddate = new \\DateTime($this->_due_date);\n            $patterns = array('/%days/', '/%date/');\n            $replace = array(\n                $this->_days_remaining,\n                $ddate->format(__(\"Y-m-d\"))\n            );\n            $ret = preg_replace(\n                $patterns,\n                $replace,\n                _T(\"%days days remaining (ending on %date)\")\n            );\n        }\n        return $ret;\n    }\n\n    /**\n     * Retrieve Full name and surname for the specified member id\n     *\n     * @param Db      $zdb   Database instance\n     * @param integer $id    Member id\n     * @param boolean $wid   Add member id\n     * @param boolean $wnick Add member nickname\n     *\n     * @return string formatted Name and Surname\n     */\n    public static function getSName($zdb, $id, $wid = false, $wnick = false)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where(self::PK . ' = ' . $id);\n\n            $results = $zdb->execute($select);\n            $row = $results->current();\n            return self::getNameWithCase(\n                $row->nom_adh,\n                $row->prenom_adh,\n                false,\n                ($wid === true ? $row->id_adh : false),\n                ($wnick === true ? $row->pseudo_adh : false)\n            );\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot get formatted name for member form id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get member name with correct case\n     *\n     * @param string        $name    Member name\n     * @param string        $surname Mmeber surname\n     * @param false|Title   $title   Member title to show or false\n     * @param false|integer $id      Member id to display or false\n     * @param false|string  $nick    Member nickname to display or false\n     *\n     * @return string\n     */\n    public static function getNameWithCase($name, $surname, $title = false, $id = false, $nick = false)\n    {\n        $str = '';\n\n        if ($title !== false && $title instanceof Title) {\n            $str .= $title->tshort . ' ';\n        }\n\n        $str .= mb_strtoupper($name ?? '', 'UTF-8') . ' ' .\n            ucwords(mb_strtolower($surname ?? '', 'UTF-8'), \" \\t\\r\\n\\f\\v-_|\");\n\n        if ($id !== false || $nick !== false) {\n            $str .= ' (';\n        }\n        if ($nick !== false) {\n            $str .= $nick;\n        }\n        if ($id !== false) {\n            if ($nick !== false && !empty($nick)) {\n                $str .= ', ';\n            }\n            $str .= $id;\n        }\n        if ($id !== false || $nick !== false) {\n            $str .= ')';\n        }\n        return strip_tags($str);\n    }\n\n    /**\n     * Change password for a given user\n     *\n     * @param Db     $zdb    Database instance\n     * @param string $id_adh Member identifier\n     * @param string $pass   New password\n     *\n     * @return boolean\n     */\n    public static function updatePassword(Db $zdb, $id_adh, $pass)\n    {\n        try {\n            $cpass = password_hash($pass, PASSWORD_BCRYPT);\n\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array('mdp_adh' => $cpass)\n            )->where(self::PK . ' = ' . $id_adh);\n            $zdb->execute($update);\n            Analog::log(\n                'Password for `' . $id_adh . '` has been updated.',\n                Analog::DEBUG\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while updating password for `' . $id_adh .\n                '` | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    private function getFieldLabel($field)\n    {\n        $label = $this->fields[$field]['label'];\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label ?? '', ':'));\n        return $label;\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public static function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Mark as self membership\n     *\n     * @return void\n     */\n    public function setSelfMembership()\n    {\n        $this->_self_adh = true;\n    }\n\n    /**\n     * Is member up to date?\n     *\n     * @return boolean\n     */\n    public function isUp2Date()\n    {\n        if ($this->_deps['dues']) {\n            if ($this->isDueFree()) {\n                //member is due free, he's up to date.\n                return true;\n            } else {\n                //let's check from end date, if present\n                if ($this->_due_date == null) {\n                    return false;\n                } else {\n                    $ech = new \\DateTime($this->_due_date);\n                    $now = new \\DateTime();\n                    $now->setTime(0, 0, 0);\n                    return $ech >= $now;\n                }\n            }\n        } else {\n            throw new \\RuntimeException(\n                'Cannot check if member is up to date, dues deps is disabled!'\n            );\n        }\n    }\n\n    /**\n     * Set dependencies\n     *\n     * @param Preferences $preferences Preferences instance\n     * @param array       $fields      Members fields configuration\n     * @param History     $history     History instance\n     *\n     * @return void\n     */\n    public function setDependencies(\n        Preferences $preferences,\n        array $fields,\n        History $history\n    ) {\n        $this->preferences = $preferences;\n        $this->fields = $fields;\n        $this->history = $history;\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        $this->errors = array();\n\n        //Sanitize\n        foreach ($values as &$rawvalue) {\n            if (is_string($rawvalue)) {\n                $rawvalue = strip_tags($rawvalue);\n            }\n        }\n\n        $fields = self::getDbFields($this->zdb);\n\n        //reset company name if needed\n        if (!isset($values['is_company'])) {\n            unset($values['is_company']);\n            $values['societe_adh'] = '';\n        }\n\n        //no parent if checkbox was unchecked\n        if (\n            !isset($values['attach'])\n            && empty($this->_id)\n            && isset($values['parent_id'])\n        ) {\n            unset($values['parent_id']);\n        }\n\n        if (isset($values['duplicate'])) {\n            //if we're duplicating, keep a trace (if an error occurs)\n            $this->_duplicate = true;\n        }\n\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = $values[$key];\n                if ($value !== true && $value !== false) {\n                    $value = trim($value ?? '');\n                }\n            } elseif (empty($this->_id)) {\n                switch ($key) {\n                    case 'bool_admin_adh':\n                    case 'bool_exempt_adh':\n                    case 'bool_display_info':\n                        $value = 0;\n                        break;\n                    case 'activite_adh':\n                        //values that are set at object instantiation\n                        $value = true;\n                        break;\n                    case 'date_crea_adh':\n                    case 'sexe_adh':\n                    case 'titre_adh':\n                    case 'id_statut':\n                    case 'pref_lang':\n                    case 'parent_id':\n                        //values that are set at object instantiation\n                        $value = $this->$prop;\n                        break;\n                    case self::PK:\n                        $value = null;\n                        break;\n                    default:\n                        $value = '';\n                        break;\n                }\n            } else {\n                //keep stored value on update\n                if ($prop != '_password' || isset($values['mdp_adh']) && isset($values['mdp_adh2'])) {\n                    $value = $this->$prop;\n                } else {\n                    $value = null;\n                }\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // fill up the adherent structure\n                if ($value !== null && $value !== true && $value !== false && !is_object($value)) {\n                    $value = stripslashes($value);\n                }\n                $this->$prop = $value;\n\n                // now, check validity\n                if ($value !== null && $value != '') {\n                    if ($key !== 'mdp_adh') {\n                        $this->validate($key, $value, $values);\n                    }\n                } elseif (empty($this->_id)) {\n                    //ensure login and password are not empty\n                    if (($key == 'login_adh' || $key == 'mdp_adh') && !isset($required[$key])) {\n                        $p = new Password($this->zdb);\n                        $generated_value = $p->makeRandomPassword(15);\n                        if ($key == 'login_adh') {\n                            //'@' is not permitted in logins\n                            $this->$prop = str_replace('@', 'a', $generated_value);\n                        } else {\n                            $this->$prop = $generated_value;\n                        }\n                    }\n                }\n            }\n        }\n\n        //password checks need data to be previously set\n        if (isset($values['mdp_adh'])) {\n            $this->validate('mdp_adh', $values['mdp_adh'], $values);\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            $prop = '_' . $this->fields[$key]['propname'];\n\n            if (!isset($disabled[$key])) {\n                $mandatory_missing = false;\n                if (!isset($this->$prop) || $this->$prop == '') {\n                    $mandatory_missing = true;\n                } elseif ($key === 'titre_adh' && $this->$prop == '-1') {\n                    $mandatory_missing = true;\n                }\n\n                if ($mandatory_missing === true) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        //attach to/detach from parent\n        if (isset($values['detach_parent'])) {\n            $this->_parent = null;\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n        $this->checkSocials($values);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a member' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            $this->checkDues();\n\n            Analog::log(\n                'Member checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Validate data for given key\n     * Set valid data in current object, also resets errors list\n     *\n     * @param string $field  Field name\n     * @param mixed  $value  Value we want to set\n     * @param array  $values All values, for some references\n     *\n     * @return void\n     */\n    public function validate($field, $value, $values)\n    {\n        global $preferences;\n\n        $prop = '_' . $this->fields[$field]['propname'];\n\n        if ($value === null || (is_string($value) && trim($value) == '')) {\n            //empty values are OK\n            $this->$prop = $value;\n            return;\n        }\n\n        switch ($field) {\n            // dates\n            case 'date_crea_adh':\n            case 'date_modif_adh_':\n            case 'ddn_adh':\n            case 'date_echeance':\n                try {\n                    $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                    if ($d === false) {\n                        //try with non localized date\n                        $d = \\DateTime::createFromFormat(\"Y-m-d\", $value);\n                        if ($d === false) {\n                            throw new \\Exception('Incorrect format');\n                        }\n                    }\n\n                    if ($field === 'ddn_adh') {\n                        $now = new \\DateTime();\n                        $now->setTime(0, 0, 0);\n                        $d->setTime(0, 0, 0);\n\n                        $diff = $now->diff($d);\n                        $days = (int)$diff->format('%R%a');\n                        if ($days >= 0) {\n                            $this->errors[] = _T('- Birthdate must be set in the past!');\n                        }\n\n                        $years = (int)$diff->format('%R%Y');\n                        if ($years <= -200) {\n                            $this->errors[] = str_replace(\n                                '%years',\n                                $years * -1,\n                                _T('- Members must be less than 200 years old (currently %years)!')\n                            );\n                        }\n                    }\n                    $this->$prop = $d->format('Y-m-d');\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Wrong date format. field: ' . $field .\n                        ', value: ' . $value . ', expected fmt: ' .\n                        __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                        Analog::INFO\n                    );\n                    $this->errors[] = str_replace(\n                        array(\n                            '%date_format',\n                            '%field'\n                        ),\n                        array(\n                            __(\"Y-m-d\"),\n                            $this->getFieldLabel($field)\n                        ),\n                        _T(\"- Wrong date format (%date_format) for %field!\")\n                    );\n                }\n                break;\n            case 'titre_adh':\n                if ($value !== null && $value !== '') {\n                    if ($value == '-1') {\n                        $this->$prop = null;\n                    } elseif (!$value instanceof Title) {\n                        $this->$prop = new Title((int)$value);\n                    }\n                } else {\n                    $this->$prop = null;\n                }\n                break;\n            case 'email_adh':\n                if (!GaletteMail::isValidEmail($value)) {\n                    $this->errors[] = _T(\"- Non-valid E-Mail address!\") .\n                        ' (' . $this->getFieldLabel($field) . ')';\n                }\n                if ($field == 'email_adh') {\n                    try {\n                        $select = $this->zdb->select(self::TABLE);\n                        $select->columns(\n                            array(self::PK)\n                        )->where(array('email_adh' => $value));\n                        if (!empty($this->_id)) {\n                            $select->where(\n                                self::PK . ' != ' . $this->_id\n                            );\n                        }\n\n                        $results = $this->zdb->execute($select);\n                        if ($results->count() !== 0) {\n                            $this->errors[] = _T(\"- This E-Mail address is already used by another member!\");\n                        }\n                    } catch (Throwable $e) {\n                        Analog::log(\n                            'An error occurred checking member email unicity.',\n                            Analog::ERROR\n                        );\n                        $this->errors[] = _T(\"An error has occurred while looking if login already exists.\");\n                    }\n                }\n                break;\n            case 'login_adh':\n                /** FIXME: add a preference for login length */\n                if (strlen($value) < 2) {\n                    $this->errors[] = str_replace(\n                        '%i',\n                        2,\n                        _T(\"- The username must be composed of at least %i characters!\")\n                    );\n                } else {\n                    //check if login does not contain the @ character\n                    if (strpos($value, '@') != false) {\n                        $this->errors[] = _T(\"- The username cannot contain the @ character\");\n                    } else {\n                        //check if login is already taken\n                        try {\n                            $select = $this->zdb->select(self::TABLE);\n                            $select->columns(\n                                array(self::PK)\n                            )->where(array('login_adh' => $value));\n                            if (!empty($this->_id)) {\n                                $select->where(\n                                    self::PK . ' != ' . $this->_id\n                                );\n                            }\n\n                            $results = $this->zdb->execute($select);\n                            if (\n                                $results->count() !== 0\n                                || $value == $preferences->pref_admin_login\n                            ) {\n                                $this->errors[] = _T(\"- This username is already in use, please choose another one!\");\n                            }\n                        } catch (Throwable $e) {\n                            Analog::log(\n                                'An error occurred checking member login uniqueness.',\n                                Analog::ERROR\n                            );\n                            $this->errors[] = _T(\"An error has occurred while looking if login already exists.\");\n                        }\n                    }\n                }\n                break;\n            case 'mdp_adh':\n                if (\n                    $this->_self_adh !== true\n                    && (!isset($values['mdp_adh2'])\n                    || $values['mdp_adh2'] != $value)\n                ) {\n                    $this->errors[] = _T(\"- The passwords don't match!\");\n                } elseif (\n                    $this->_self_adh === true\n                    && !crypt($value, $values['mdp_crypt']) == $values['mdp_crypt']\n                ) {\n                    $this->errors[] = _T(\"Password misrepeated: \");\n                } else {\n                    $pinfos = password_get_info($value);\n                    //check if value is already a hash\n                    if ($pinfos['algo'] == 0) {\n                        $this->$prop = password_hash(\n                            $value,\n                            PASSWORD_BCRYPT\n                        );\n\n                        $pwcheck = new \\Galette\\Util\\Password($preferences);\n                        $pwcheck->setAdherent($this);\n                        if (!$pwcheck->isValid($value)) {\n                            $this->errors = array_merge(\n                                $this->errors,\n                                $pwcheck->getErrors()\n                            );\n                        }\n                    }\n                }\n                break;\n            case 'id_statut':\n                try {\n                    $this->$prop = (int)$value;\n                    //check if status exists\n                    $select = $this->zdb->select(Status::TABLE);\n                    $select->where(Status::PK . '= ' . $value);\n\n                    $results = $this->zdb->execute($select);\n                    $result = $results->current();\n                    if (!$result) {\n                        $this->errors[] = str_replace(\n                            '%id',\n                            $value,\n                            _T(\"Status #%id does not exists in database.\")\n                        );\n                        break;\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'An error occurred checking status existence: ' . $e->getMessage(),\n                        Analog::ERROR\n                    );\n                    $this->errors[] = _T(\"An error has occurred while looking if status does exists.\");\n                }\n                break;\n            case 'sexe_adh':\n                if (in_array($value, [self::NC, self::MAN, self::WOMAN])) {\n                    $this->$prop = (int)$value;\n                } else {\n                    $this->errors[] = _T(\"Gender %gender does not exists!\");\n                }\n                break;\n            case 'parent_id':\n                $this->$prop = ($value instanceof Adherent) ? (int)$value->id : (int)$value;\n                $this->loadParent();\n                break;\n        }\n    }\n\n    /**\n     * Store the member\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $hist, $emitter, $login;\n        $event = null;\n\n        if (!$login->isAdmin() && !$login->isStaff() && !$login->isGroupManager() && $this->id == '') {\n            if ($this->preferences->pref_bool_create_member) {\n                $this->_parent = $login->id;\n            }\n        }\n\n        try {\n            $values = array();\n            $fields = self::getDbFields($this->zdb);\n\n            foreach ($fields as $field) {\n                if (\n                    $field !== 'date_modif_adh'\n                    || empty($this->_id)\n                ) {\n                    $prop = '_' . $this->fields[$field]['propname'];\n                    if (\n                        ($field === 'bool_admin_adh'\n                        || $field === 'bool_exempt_adh'\n                        || $field === 'bool_display_info'\n                        || $field === 'activite_adh')\n                        && $this->$prop === false\n                    ) {\n                        //Handle booleans for postgres ; bugs #18899 and #19354\n                        $values[$field] = $this->zdb->isPostgres() ? 'false' : 0;\n                    } elseif ($field === 'parent_id') {\n                        //handle parents\n                        if ($this->_parent === null) {\n                            $values['parent_id'] = new Expression('NULL');\n                        } elseif ($this->parent instanceof Adherent) {\n                            $values['parent_id'] = $this->_parent->id;\n                        } else {\n                            $values['parent_id'] = $this->_parent;\n                        }\n                    } else {\n                        $values[$field] = $this->$prop;\n                    }\n                }\n            }\n\n            //an empty value will cause date to be set to 1901-01-01, a null\n            //will result in 0000-00-00. We want a database NULL value here.\n            if (!$this->_birthdate) {\n                $values['ddn_adh'] = new Expression('NULL');\n            }\n            if (!$this->_due_date) {\n                $values['date_echeance'] = new Expression('NULL');\n            }\n\n            if ($this->_title instanceof Title) {\n                $values['titre_adh'] = $this->_title->id;\n            } else {\n                $values['titre_adh'] = new Expression('NULL');\n            }\n\n            if (!$this->_parent) {\n                $values['parent_id'] = new Expression('NULL');\n            }\n\n            if (!$this->_number) {\n                $values['num_adh'] = new Expression('NULL');\n            }\n\n            //fields that cannot be null\n            $notnull = [\n                '_surname'  => 'prenom_adh',\n                '_nickname' => 'pseudo_adh',\n                '_address'  => 'adresse_adh',\n                '_zipcode'  => 'cp_adh',\n                '_town'     => 'ville_adh'\n            ];\n            foreach ($notnull as $prop => $field) {\n                if ($this->$prop === null) {\n                    $values[$field] = '';\n                }\n            }\n\n            $success = false;\n            if (empty($this->_id)) {\n                //we're inserting a new member\n                unset($values[self::PK]);\n                //set modification date\n                $this->_modification_date = date('Y-m-d');\n                $values['date_modif_adh'] = $this->_modification_date;\n\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n                    $this->_picture = new Picture($this->_id);\n                    // logging\n                    if ($this->_self_adh) {\n                        $hist->add(\n                            _T(\"Self_subscription as a member: \") .\n                            $this->getNameWithCase($this->_name, $this->_surname),\n                            $this->sname\n                        );\n                    } else {\n                        $hist->add(\n                            _T(\"Member card added\"),\n                            $this->sname\n                        );\n                    }\n                    $success = true;\n\n                    $event = 'member.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new member.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new member!'\n                    );\n                }\n            } else {\n                //we're editing an existing member\n                if (!$this->isDueFree()) {\n                    // deadline\n                    $due_date = Contribution::getDueDate($this->zdb, $this->_id);\n                    if ($due_date) {\n                        $values['date_echeance'] = $due_date;\n                    }\n                }\n\n                if (!$this->_password) {\n                    unset($values['mdp_adh']);\n                }\n\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values);\n                $update->where(\n                    self::PK . '=' . $this->_id\n                );\n\n                $edit = $this->zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $this->updateModificationDate();\n                    $hist->add(\n                        _T(\"Member card updated\"),\n                        $this->sname\n                    );\n                }\n                $success = true;\n                $event = 'member.edit';\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore();\n                $this->storeSocials($this->id);\n            }\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n            return $success;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Update member modification date\n     *\n     * @return void\n     */\n    private function updateModificationDate()\n    {\n        try {\n            $modif_date = date('Y-m-d');\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array('date_modif_adh' => $modif_date)\n            )->where(self::PK . '=' . $this->_id);\n\n            $edit = $this->zdb->execute($update);\n            $this->_modification_date = $modif_date;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong updating modif date :\\'( | ' .\n                $e->getMessage() . \"\\n\" . $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrieve\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array(\n            'admin', 'staff', 'due_free', 'appears_in_list', 'active',\n            'row_classes', 'oldness', 'duplicate'\n        );\n        if (!defined('GALETTE_TESTS')) {\n            $forbidden[] = 'password'; //keep that for tests only\n        }\n\n        $virtuals = array(\n            'sadmin', 'sstaff', 'sdue_free', 'sappears_in_list', 'sactive',\n            'stitle', 'sstatus', 'sfullname', 'sname', 'saddress',\n            'rbirthdate', 'sgender', 'contribstatus',\n        );\n\n        $socials = array('website', 'msn', 'jabber', 'icq');\n\n        if (in_array($name, $forbidden)) {\n            switch ($name) {\n                case 'admin':\n                    return $this->isAdmin();\n                case 'staff':\n                    return $this->isStaff();\n                case 'due_free':\n                    return $this->isDueFree();\n                case 'appears_in_list':\n                    return $this->appearsInMembersList();\n                case 'active':\n                    return $this->isActive();\n                case 'duplicate':\n                    return $this->isDuplicate();\n                default:\n                    throw new \\RuntimeException(\"Call to __get for '$name' is forbidden!\");\n            }\n        }\n\n        if (in_array($name, $virtuals)) {\n            if (substr($name, 0, 1) !== '_') {\n                $real = '_' . substr($name, 1);\n            } else {\n                $real = $name;\n            }\n            switch ($name) {\n                case 'sadmin':\n                case 'sdue_free':\n                case 'sappears_in_list':\n                case 'sstaff':\n                    return (($this->$real) ? _T(\"Yes\") : _T(\"No\"));\n                    break;\n                case 'sactive':\n                    return (($this->$real) ? _T(\"Active\") : _T(\"Inactive\"));\n                    break;\n                case 'stitle':\n                    if (isset($this->_title) && $this->_title instanceof Title) {\n                        return $this->_title->tshort;\n                    } else {\n                        return null;\n                    }\n                    break;\n                case 'sstatus':\n                    $status = new Status($this->zdb);\n                    return $status->getLabel($this->_status);\n                    break;\n                case 'sfullname':\n                    return $this->getNameWithCase(\n                        $this->_name,\n                        $this->_surname,\n                        (isset($this->_title) ? $this->title : false)\n                    );\n                    break;\n                case 'saddress':\n                    $address = $this->_address;\n                    if ($this->_address_continuation !== '' && $this->_address_continuation !== null) {\n                        $address .= \"\\n\" . $this->_address_continuation;\n                    }\n                    return $address;\n                    break;\n                case 'sname':\n                    return $this->getNameWithCase($this->_name, $this->_surname);\n                    break;\n                case 'rbirthdate':\n                    return $this->_birthdate;\n                    break;\n                case 'sgender':\n                    switch ($this->gender) {\n                        case self::MAN:\n                            return _T('Man');\n                        case self::WOMAN:\n                            return _T('Woman');\n                        default:\n                            return _T('Unspecified');\n                    }\n                    break;\n                case 'contribstatus':\n                    return $this->getDues();\n                    break;\n            }\n        }\n\n        //for backward compatibility\n        if (in_array($name, $socials)) {\n            $values = Social::getListForMember($this->_id, $name);\n            return $values[0] ?? null;\n        }\n\n        if (substr($name, 0, 1) !== '_') {\n            $rname = '_' . $name;\n        } else {\n            $rname = $name;\n        }\n\n        switch ($name) {\n            case 'id':\n            case 'id_statut':\n                if ($this->$rname !== null) {\n                    return (int)$this->$rname;\n                } else {\n                    return null;\n                }\n                break;\n            case 'address':\n            case 'address_continuation':\n                return $this->$rname ?? '';\n                break;\n            case 'birthdate':\n            case 'creation_date':\n            case 'modification_date':\n            case 'due_date':\n                if ($this->$rname != '') {\n                    try {\n                        $d = new \\DateTime($this->$rname);\n                        return $d->format(__(\"Y-m-d\"));\n                    } catch (Throwable $e) {\n                        //oops, we've got a bad date :/\n                        Analog::log(\n                            'Bad date (' . $this->$rname . ') | ' .\n                            $e->getMessage(),\n                            Analog::INFO\n                        );\n                        return $this->$rname;\n                    }\n                }\n                break;\n            case 'parent_id':\n                return ($this->_parent instanceof Adherent) ? (int)$this->_parent->id : (int)$this->_parent;\n                break;\n            default:\n                if (!property_exists($this, $rname)) {\n                    Analog::log(\n                        \"Unknown property '$rname'\",\n                        Analog::WARNING\n                    );\n                    return null;\n                } else {\n                    return $this->$rname;\n                }\n                break;\n        }\n    }\n\n    /**\n     * Get member email\n     * If member does not have an email address, but is attached to\n     * another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getEmail()\n    {\n        $email = $this->_email;\n        if (empty($email)) {\n            $this->loadParent();\n            $email = $this->parent->email;\n        }\n\n        return $email;\n    }\n\n    /**\n     * Get member address.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getAddress()\n    {\n        $address = $this->_address;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $address = $this->parent->address;\n        }\n\n        return $address;\n    }\n\n    /**\n     * Get member address continuation.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getAddressContinuation()\n    {\n        $address = $this->_address;\n        $address_continuation = $this->_address_continuation;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $address_continuation = $this->parent->address_continuation;\n        }\n\n        return $address_continuation;\n    }\n\n    /**\n     * Get member zipcode.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getZipcode()\n    {\n        $address = $this->_address;\n        $zip = $this->_zipcode;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $zip = $this->parent->zipcode;\n        }\n\n        return $zip;\n    }\n\n    /**\n     * Get member town.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getTown()\n    {\n        $address = $this->_address;\n        $town = $this->_town;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $town = $this->parent->town;\n        }\n\n        return $town;\n    }\n\n    /**\n     * Get member country.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getCountry()\n    {\n        $address = $this->_address;\n        $country = $this->_country;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $country = $this->parent->country;\n        }\n\n        return $country;\n    }\n\n    /**\n     * Get member age\n     *\n     * @return string\n     */\n    public function getAge()\n    {\n        if ($this->_birthdate == null) {\n            return '';\n        }\n\n        $d = \\DateTime::createFromFormat('Y-m-d', $this->_birthdate);\n        if ($d === false) {\n            Analog::log(\n                'Invalid birthdate: ' . $this->_birthdate,\n                Analog::ERROR\n            );\n            return;\n        }\n\n        return str_replace(\n            '%age',\n            $d->diff(new \\DateTime())->y,\n            _T(' (%age years old)')\n        );\n    }\n\n    /**\n     * Get parent inherited fields\n     *\n     * @return array\n     */\n    public function getParentFields()\n    {\n        return $this->parent_fields;\n    }\n\n    /**\n     * Handle files (photo and dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n        // picture upload\n        if (isset($files['photo'])) {\n            if ($files['photo']['error'] === UPLOAD_ERR_OK) {\n                if ($files['photo']['tmp_name'] != '') {\n                    if (is_uploaded_file($files['photo']['tmp_name'])) {\n                        $res = $this->picture->store($files['photo']);\n                        if ($res < 0) {\n                            $this->errors[]\n                                = $this->picture->getErrorMessage($res);\n                        }\n                    }\n                }\n            } elseif ($files['photo']['error'] !== UPLOAD_ERR_NO_FILE) {\n                Analog::log(\n                    $this->picture->getPhpErrorMessage($files['photo']['error']),\n                    Analog::WARNING\n                );\n                $this->errors[] = $this->picture->getPhpErrorMessage(\n                    $files['photo']['error']\n                );\n            }\n        }\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a member files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Set member as duplicate\n     *\n     * @return void\n     */\n    public function setDuplicate()\n    {\n        //mark as duplicated\n        $this->_duplicate = true;\n        $infos = $this->_others_infos_admin;\n        $this->_others_infos_admin = str_replace(\n            ['%name', '%id'],\n            [$this->sname, $this->_id],\n            _T('Duplicated from %name (%id)')\n        );\n        if (!empty($infos)) {\n            $this->_others_infos_admin .= \"\\n\" . $infos;\n        }\n        //drop id_adh\n        $this->_id = null;\n        //drop email, must be unique\n        $this->_email = null;\n        //drop creation date\n        $this->_creation_date = date(\"Y-m-d\");\n        //drop login\n        $this->_login = null;\n        //reset picture\n        $this->_picture = new Picture();\n        //remove birthdate\n        $this->_birthdate = null;\n        //remove surname\n        $this->_surname = null;\n        //not admin\n        $this->_admin = false;\n        //not due free\n        $this->_due_free = false;\n    }\n\n    /**\n     * Get current errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get user groups\n     *\n     * @return array\n     */\n    public function getGroups()\n    {\n        return $this->_groups;\n    }\n\n    /**\n     * Get user managed groups\n     *\n     * @return array\n     */\n    public function getManagedGroups()\n    {\n        return $this->_managed_groups;\n    }\n\n    /**\n     * Can current logged-in user create member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canCreate(Login $login): bool\n    {\n        global $preferences;\n\n        if ($this->id && $login->id == $this->id || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        if ($preferences->pref_bool_create_member && $login->isLogged()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Can current logged-in user edit member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canEdit(Login $login): bool\n    {\n        //admin and staff users can edit, as well as member itself\n        if ($this->id && $login->id == $this->id || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can edit their child cards\n        if ($this->hasParent() && $this->parent_id === $login->id) {\n            return true;\n        }\n\n        //group managers can edit members of groups they manage\n        if ($login->isGroupManager()) {\n            foreach ($this->getGroups() as $g) {\n                if ($login->isGroupManager($g->getId())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Can current logged-in user display member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        return $this->canEdit($login);\n    }\n\n    /**\n     * Are we currently duplicated a member?\n     *\n     * @return boolean\n     */\n    public function isDuplicate(): bool\n    {\n        return $this->_duplicate;\n    }\n\n    /**\n     * Flag creation mail sending\n     *\n     * @param boolean $send True (default) to send creation email\n     *\n     * @return Adherent\n     */\n    public function setSendmail($send = true): self\n    {\n        $this->sendmail = $send;\n        return $this;\n    }\n\n    /**\n     * Should we send administrative emails to member?\n     *\n     * @return boolean\n     */\n    public function sendEMail()\n    {\n        return $this->sendmail;\n    }\n\n    /**\n     * Set member parent\n     *\n     * @param integer $id Parent identifier\n     *\n     * @return $this\n     */\n    public function setParent(int $id): self\n    {\n        $this->_parent = $id;\n        $this->loadParent();\n        return $this;\n    }\n\n    /**\n     * Reset dependencies to load\n     *\n     * @return $this\n     */\n    public function disableAllDeps(): self\n    {\n        foreach ($this->_deps as &$dep) {\n            $dep = false;\n        }\n        return $this;\n    }\n\n    /**\n     * Enable all dependencies to load\n     *\n     * @return $this\n     */\n    public function enableAllDeps(): self\n    {\n        foreach ($this->_deps as &$dep) {\n            $dep = true;\n        }\n        return $this;\n    }\n\n    /**\n     * Enable a load dependency\n     *\n     * @param string $name Dependency name\n     *\n     * @return $this\n     */\n    public function enableDep(string $name): self\n    {\n        if (!isset($this->_deps[$name])) {\n            Analog::log(\n                'dependency ' . $name . ' does not exists!',\n                Analog::WARNING\n            );\n        } else {\n            $this->_deps[$name] = true;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Enable a load dependency\n     *\n     * @param string $name Dependency name\n     *\n     * @return $this\n     */\n    public function disableDep(string $name): self\n    {\n        if (!isset($this->_deps[$name])) {\n            Analog::log(\n                'dependency ' . $name . ' does not exists!',\n                Analog::WARNING\n            );\n        } else {\n            $this->_deps[$name] = false;\n        }\n\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Contribution class for galette\n * Manage membership fees and donations.\n *\n * PHP version 5\n *\n * Copyright \u00a9 2010-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Galette\\IO\\ExternalScript;\nuse Galette\\IO\\PdfContribution;\nuse Galette\\Repository\\PaymentTypes;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Contribution class for galette\n * Manage membership fees and donations.\n *\n * @category  Entity\n * @name      Contribution\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n *\n * @property integer $id\n * @property string $date\n * @property DateTime $raw_date\n * @property integer $member\n * @property ContributionsTypes $type\n * @property integer $amount\n * @property integer $payment_type\n * @property integer $orig_amount\n * @property string $info\n * @property string $begin_date\n * @property DateTime $raw_begin_date\n * @property string $end_date\n * @property DateTime $raw_end_date\n * @property Transaction|null $transaction\n * @property integer $extension\n * @property integer $duration\n * @property string $spayment_type\n * @property integer $model\n */\nclass Contribution\n{\n    use Dynamics;\n\n    public const TABLE = 'cotisations';\n    public const PK = 'id_cotis';\n\n    public const TYPE_FEE = 'fee';\n    public const TYPE_DONATION = 'donation';\n\n    private $_id;\n    private $_date;\n    private $_member;\n    private $_type;\n    private $_amount;\n    private $_payment_type;\n    private $_orig_amount;\n    private $_info;\n    private $_begin_date;\n    private $_end_date;\n    private $_transaction = null;\n    private $_is_cotis;\n    private $_extension;\n\n    //fields list and their translation\n    private $_fields;\n\n    /** @var Db */\n    private $zdb;\n    /** @var Login */\n    private $login;\n    /** @var array */\n    private $errors;\n\n    private $sendmail = false;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                 $zdb   Database\n     * @param Login              $login Login instance\n     * @param null|int|ResultSet $args  Either a ResultSet row to load\n     *                                  a specific contribution, or an type id\n     *                                  to just instantiate object\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n\n        global $preferences;\n        $this->_payment_type = (int)$preferences->pref_default_paymenttype;\n\n        /*\n         * Fields configuration. Each field is an array and must reflect:\n         * array(\n         *   (string)label,\n         *   (string) property name\n         * )\n         *\n         * I'd prefer a static private variable for this...\n         * But call to the _T function does not seem to be allowed there :/\n         */\n        $this->_fields = array(\n            'id_cotis'            => array(\n                'label'    => _T('Contribution id'), //not a field in the form\n                'propname' => 'id'\n            ),\n            Adherent::PK          => array(\n                'label'    => _T(\"Contributor:\"),\n                'propname' => 'member'\n            ),\n            ContributionsTypes::PK => array(\n                'label'    => _T(\"Contribution type:\"),\n                'propname' => 'type'\n            ),\n            'montant_cotis'       => array(\n                'label'    => _T(\"Amount:\"),\n                'propname' => 'amount'\n            ),\n            'type_paiement_cotis' => array(\n                'label'    => _T(\"Payment type:\"),\n                'propname' => 'payment_type'\n            ),\n            'info_cotis'          => array(\n                'label'    => _T(\"Comments:\"),\n                'propname' => 'info'\n            ),\n            'date_enreg'          => array(\n                'label'    => _T('Date'), //not a field in the form\n                'propname' => 'date'\n            ),\n            'date_debut_cotis'    => array(\n                'label'    => _T(\"Date of contribution:\"),\n                'cotlabel' => _T(\"Start date of membership:\"), //if contribution is a membership fee, label differs\n                'propname' => 'begin_date'\n            ),\n            'date_fin_cotis'      => array(\n                'label'    => _T(\"End date of membership:\"),\n                'propname' => 'end_date'\n            ),\n            Transaction::PK       => array(\n                'label'    => _T('Transaction ID'), //not a field in the form\n                'propname' => 'transaction'\n            ),\n            //this one is not really a field, but is required in some cases...\n            //adding it here make more simple to check required fields\n            'duree_mois_cotis'    => array(\n                'label'    => _T(\"Membership extension:\"),\n                'propname' => 'extension'\n            )\n        );\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_array($args)) {\n            $this->_date = date(\"Y-m-d\");\n            if (isset($args['adh']) && $args['adh'] != '') {\n                $this->_member = (int)$args['adh'];\n            }\n            if (isset($args['trans'])) {\n                $this->_transaction = new Transaction($this->zdb, $this->login, (int)$args['trans']);\n                if (!isset($this->_member)) {\n                    $this->_member = (int)$this->_transaction->member;\n                }\n                $this->_amount = $this->_transaction->getMissingAmount();\n            }\n            $this->type = (int)$args['type'];\n            //calculate begin date for membership fee\n            $this->_begin_date = $this->_date;\n            if ($this->_is_cotis) {\n                $curend = self::getDueDate($this->zdb, $this->_member);\n                if ($curend != '') {\n                    $dend = new \\DateTime($curend);\n                    $now = date('Y-m-d');\n                    $dnow = new \\DateTime($now);\n                    if ($dend < $dnow) {\n                        // Member didn't renew on time\n                        $this->_begin_date = $now;\n                    } else {\n                        $this->_begin_date = $curend;\n                    }\n                }\n                $this->retrieveEndDate();\n            }\n            if (isset($args['payment_type'])) {\n                $this->_payment_type = $args['payment_type'];\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Sets end contribution date\n     *\n     * @return void\n     */\n    private function retrieveEndDate()\n    {\n        global $preferences;\n\n        $bdate = new \\DateTime($this->_begin_date);\n        if ($preferences->pref_beg_membership != '') {\n            //case beginning of membership\n            list($j, $m) = explode('/', $preferences->pref_beg_membership);\n            $edate = new \\DateTime($bdate->format('Y') . '-' . $m . '-' . $j);\n            while ($edate <= $bdate) {\n                $edate->modify('+1 year');\n            }\n\n            if ($preferences->pref_membership_offermonths > 0) {\n                //count days until end of membership date\n                $diff1 = (int)$bdate->diff($edate)->format('%a');\n\n                //count days between end of membership date and offered months\n                $tdate = clone $edate;\n                $tdate->modify('-' . $preferences->pref_membership_offermonths . ' month');\n                $diff2 = (int)$edate->diff($tdate)->format('%a');\n\n                //when number of days until end of membership is less than for offered months, it's free :)\n                if ($diff1 <= $diff2) {\n                    $edate->modify('+1 year');\n                }\n            }\n\n            $this->_end_date = $edate->format('Y-m-d');\n        } elseif ($preferences->pref_membership_ext != '') {\n            //case membership extension\n            if ($this->_extension == null) {\n                $this->_extension = $preferences->pref_membership_ext;\n            }\n            $dext = new \\DateInterval('P' . $this->_extension . 'M');\n            $edate = $bdate->add($dext);\n            $this->_end_date = $edate->format('Y-m-d');\n        } else {\n            throw new \\RuntimeException(\n                'Unable to define end date; none of pref_beg_membership nor pref_membership_ext are defined!'\n            );\n        }\n    }\n\n    /**\n     * Loads a contribution from its id\n     *\n     * @param int $id the identifier for the contribution to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'c');\n            $select->join(\n                array('a' => PREFIX_DB . Adherent::TABLE),\n                'c.' . Adherent::PK . '=a.' . Adherent::PK,\n                array()\n            );\n            //restrict query on current member id if he's not admin nor staff member\n            if (!$this->login->isAdmin() && !$this->login->isStaff()) {\n                if (!$this->login->isLogged()) {\n                    Analog::log(\n                        'Non-logged-in users cannot load contribution id `' . $id,\n                        Analog::ERROR\n                    );\n                    return false;\n                }\n                if (!$this->login->isGroupManager()) {\n                    $select->where\n                        ->nest()\n                            ->equalTo('a.' . Adherent::PK, $this->login->id)\n                            ->or\n                            ->equalTo('a.parent_id', $this->login->id)\n                        ->unnest()\n                        ->and\n                        ->equalTo('c.' . self::PK, $id)\n                    ;\n                } else {\n                    $select->where([\n                        Adherent::PK    => $this->login->id,\n                        self::PK        => $id\n                    ]);\n                }\n            } else {\n                $select->where->equalTo(self::PK, $id);\n            }\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $row = $results->current();\n                $this->loadFromRS($row);\n                return true;\n            } else {\n                Analog::log(\n                    'No contribution #' . $id . ' (user ' . $this->login->id . ')',\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred attempting to load contribution #' . $id .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = self::PK;\n        $this->_id = (int)$r->$pk;\n        $this->_date = $r->date_enreg;\n        $this->_amount = (int)$r->montant_cotis;\n        //save original amount, we need it for transactions parts calculations\n        $this->_orig_amount = (int)$r->montant_cotis;\n        $this->_payment_type = $r->type_paiement_cotis;\n        $this->_info = $r->info_cotis;\n        $this->_begin_date = $r->date_debut_cotis;\n        $enddate = $r->date_fin_cotis;\n        //do not work with knows bad dates...\n        //the one with BC comes from 0.63/pgsql demo... Why the hell a so\n        //strange date? don't know :(\n        if (\n            $enddate !== '0000-00-00'\n            && $enddate !== '1901-01-01'\n            && $enddate !== '0001-01-01 BC'\n        ) {\n            $this->_end_date = $r->date_fin_cotis;\n        }\n        $adhpk = Adherent::PK;\n        $this->_member = (int)$r->$adhpk;\n\n        $transpk = Transaction::PK;\n        if ($r->$transpk != '') {\n            $this->_transaction = new Transaction($this->zdb, $this->login, (int)$r->$transpk);\n        }\n\n        $this->type = (int)$r->id_type_cotis;\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        global $preferences;\n        $this->errors = array();\n\n        $fields = array_keys($this->_fields);\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->_fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = trim($values[$key]);\n            } else {\n                $value = '';\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // fill up the adherent structure\n                //$this->$prop = stripslashes($value); //not relevant here!\n\n                // now, check validity\n                switch ($key) {\n                    // dates\n                    case 'date_enreg':\n                    case 'date_debut_cotis':\n                    case 'date_fin_cotis':\n                        if ($value != '') {\n                            try {\n                                $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                                if ($d === false) {\n                                    throw new \\Exception('Incorrect format');\n                                }\n                                $this->$prop = $d->format('Y-m-d');\n                            } catch (Throwable $e) {\n                                Analog::log(\n                                    'Wrong date format. field: ' . $key .\n                                    ', value: ' . $value . ', expected fmt: ' .\n                                    __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                                    Analog::INFO\n                                );\n                                $this->errors[] = str_replace(\n                                    array(\n                                        '%date_format',\n                                        '%field'\n                                    ),\n                                    array(\n                                        __(\"Y-m-d\"),\n                                        $this->_fields[$key]['label']\n                                    ),\n                                    _T(\"- Wrong date format (%date_format) for %field!\")\n                                );\n                            }\n                        }\n                        break;\n                    case Adherent::PK:\n                        if ($value != '') {\n                            $this->_member = (int)$value;\n                        }\n                        break;\n                    case ContributionsTypes::PK:\n                        if ($value != '') {\n                            $this->type = (int)$value;\n                        }\n                        break;\n                    case 'montant_cotis':\n                        if (!empty($value)) {\n                            $this->_amount = $value;\n                        }\n                        $value = strtr($value, ',', '.');\n                        if (!is_numeric($value) && $value !== '') {\n                            $this->errors[] = _T(\"- The amount must be an integer!\");\n                        }\n                        break;\n                    case 'type_paiement_cotis':\n                        $ptypes = new PaymentTypes(\n                            $this->zdb,\n                            $preferences,\n                            $this->login\n                        );\n                        $ptlist = $ptypes->getList();\n                        if (isset($ptlist[$value])) {\n                            $this->_payment_type = $value;\n                        } else {\n                            $this->errors[] = _T(\"- Unknown payment type\");\n                        }\n                        break;\n                    case 'info_cotis':\n                        $this->_info = $value;\n                        break;\n                    case Transaction::PK:\n                        if ($value != '') {\n                            $this->_transaction = new Transaction($this->zdb, $this->login, (int)$value);\n                        }\n                        break;\n                    case 'duree_mois_cotis':\n                        if ($value != '') {\n                            if (!is_numeric($value) || $value <= 0) {\n                                $this->errors[] = _T(\"- The duration must be a positive integer!\");\n                            }\n                            $this->$prop = $value;\n                            $this->retrieveEndDate();\n                        }\n                        break;\n                }\n            }\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            if ($val === 1) {\n                $prop = '_' . $this->_fields[$key]['propname'];\n                if (\n                    !isset($disabled[$key])\n                    && (!isset($this->$prop)\n                    || (!is_object($this->$prop) && trim($this->$prop) == '')\n                    || (is_object($this->$prop) && trim($this->$prop->id) == ''))\n                ) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        if ($this->_transaction != null && $this->_amount != null) {\n            $missing = $this->_transaction->getMissingAmount();\n            //calculate new missing amount\n            $missing = $missing + $this->_orig_amount - $this->_amount;\n            if ($missing < 0) {\n                $this->errors[] = _T(\"- Sum of all contributions exceed corresponding transaction amount.\");\n            }\n        }\n\n        if ($this->isFee() && count($this->errors) == 0) {\n            $overlap = $this->checkOverlap();\n            if ($overlap !== true) {\n                //method directly return error message\n                $this->errors[] = $overlap;\n            }\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been threw attempting to edit/store a contribution' .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            Analog::log(\n                'Contribution checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Check that membership fees does not overlap\n     *\n     * @return boolean|string True if all is ok, false if error,\n     * error message if overlap\n     */\n    public function checkOverlap()\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'c');\n            $select->columns(\n                array('date_debut_cotis', 'date_fin_cotis')\n            )->join(\n                array('ct' => PREFIX_DB . ContributionsTypes::TABLE),\n                'c.' . ContributionsTypes::PK . '=ct.' . ContributionsTypes::PK,\n                array()\n            )->where(Adherent::PK . ' = ' . $this->_member)\n                ->where(array('cotis_extension' => new Expression('true')))\n                ->where->nest->nest\n                ->greaterThanOrEqualTo('date_debut_cotis', $this->_begin_date)\n                ->lessThan('date_debut_cotis', $this->_end_date)\n                ->unnest\n                ->or->nest\n                ->greaterThan('date_fin_cotis', $this->_begin_date)\n                ->lessThanOrEqualTo('date_fin_cotis', $this->_end_date);\n\n            if ($this->id != '') {\n                $select->where(self::PK . ' != ' . $this->id);\n            }\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $d = new \\DateTime($result->date_debut_cotis);\n\n                return _T(\"- Membership period overlaps period starting at \") .\n                    $d->format(__(\"Y-m-d\"));\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred checking overlapping fee. ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the contribution\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $hist, $emitter;\n\n        $event = null;\n\n        if (count($this->errors) > 0) {\n            throw new \\RuntimeException(\n                'Existing errors prevents storing contribution: ' .\n                print_r($this->errors, true)\n            );\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array();\n            $fields = self::getDbFields($this->zdb);\n            foreach ($fields as $field) {\n                $prop = '_' . $this->_fields[$field]['propname'];\n                switch ($field) {\n                    case ContributionsTypes::PK:\n                    case Transaction::PK:\n                        if (isset($this->$prop)) {\n                            $values[$field] = $this->$prop->id;\n                        }\n                        break;\n                    default:\n                        $values[$field] = $this->$prop;\n                        break;\n                }\n            }\n\n            //no end date, let's take database defaults\n            if (!$this->isFee() && !$this->_end_date) {\n                unset($values['date_fin_cotis']);\n            }\n\n            $success = false;\n            if (!isset($this->_id) || $this->_id == '') {\n                //we're inserting a new contribution\n                unset($values[self::PK]);\n\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Contribution added\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                    $success = true;\n                    $event = 'contribution.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new contribution.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new contribution!'\n                    );\n                }\n            } else {\n                //we're editing an existing contribution\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where(\n                    self::PK . '=' . $this->_id\n                );\n                $edit = $this->zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Contribution updated\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                }\n\n                if ($edit === false) {\n                    throw new \\Exception(\n                        'An error occurred updating contribution # ' . $this->_id . '!'\n                    );\n                }\n                $success = true;\n                $event = 'contribution.edit';\n            }\n            //update deadline\n            if ($this->isFee()) {\n                $this->updateDeadline();\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore(true);\n            }\n\n            $this->zdb->connection->commit();\n            $this->_orig_amount = $this->_amount;\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            if ($this->zdb->connection->inTransaction()) {\n                $this->zdb->connection->rollBack();\n            }\n            throw $e;\n        }\n    }\n\n    /**\n     * Update member dead line\n     *\n     * @return boolean\n     */\n    private function updateDeadline()\n    {\n        try {\n            $due_date = self::getDueDate($this->zdb, $this->_member);\n\n            if ($due_date != '') {\n                $date_fin_update = $due_date;\n            } else {\n                $date_fin_update = new Expression('NULL');\n            }\n\n            $update = $this->zdb->update(Adherent::TABLE);\n            $update->set(\n                array('date_echeance' => $date_fin_update)\n            )->where(\n                Adherent::PK . '=' . $this->_member\n            );\n            $this->zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred updating member ' . $this->_member .\n                '\\'s deadline |' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove contribution from database\n     *\n     * @param boolean $transaction Activate transaction mode (defaults to true)\n     *\n     * @return boolean\n     */\n    public function remove($transaction = true)\n    {\n        global $emitter;\n\n        try {\n            if ($transaction) {\n                $this->zdb->connection->beginTransaction();\n            }\n\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(self::PK . ' = ' . $this->_id);\n            $del = $this->zdb->execute($delete);\n            if ($del->count() > 0) {\n                $this->updateDeadline();\n                $this->dynamicsRemove(true);\n            } else {\n                Analog::log(\n                    'Contribution has not been removed!',\n                    Analog::WARNING\n                );\n                return false;\n            }\n            if ($transaction) {\n                $this->zdb->connection->commit();\n            }\n            $emitter->emit('contribution.remove', $this);\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred trying to remove contribution #' .\n                $this->_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    public function getFieldLabel($field)\n    {\n        $label = $this->_fields[$field]['label'];\n        if ($this->isFee() && $field == 'date_debut_cotis') {\n            $label = $this->_fields[$field]['cotlabel'];\n        }\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label, ':'));\n        return $label;\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public static function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Get the relevant CSS class for current contribution\n     *\n     * @return string current contribution row class\n     */\n    public function getRowClass()\n    {\n        return ($this->_end_date != $this->_begin_date && $this->_is_cotis) ?\n            'cotis-normal' : 'cotis-give';\n    }\n\n    /**\n     * Retrieve member due date\n     *\n     * @param Db      $zdb       Database instance\n     * @param integer $member_id Member identifier\n     *\n     * @return date\n     */\n    public static function getDueDate(Db $zdb, $member_id)\n    {\n        if (!$member_id) {\n            return '';\n        }\n        try {\n            $select = $zdb->select(self::TABLE, 'c');\n            $select->columns(\n                array(\n                    'max_date' => new Expression('MAX(date_fin_cotis)')\n                )\n            )->join(\n                array('ct' => PREFIX_DB . ContributionsTypes::TABLE),\n                'c.' . ContributionsTypes::PK . '=ct.' . ContributionsTypes::PK,\n                array()\n            )->where(\n                Adherent::PK . ' = ' . $member_id\n            )->where(\n                array('cotis_extension' => new Expression('true'))\n            );\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n            $due_date = $result->max_date;\n\n            //avoid bad dates in postgres and bad mysql return from zenddb\n            if ($due_date == '0001-01-01 BC' || $due_date == '1901-01-01') {\n                $due_date = '';\n            }\n            return $due_date;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred trying to retrieve member\\'s due date',\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Detach a contribution from a transaction\n     *\n     * @param Db    $zdb        Database instance\n     * @param Login $login      Login instance\n     * @param int   $trans_id   Transaction identifier\n     * @param int   $contrib_id Contribution identifier\n     *\n     * @return boolean\n     */\n    public static function unsetTransactionPart(Db $zdb, Login $login, $trans_id, $contrib_id)\n    {\n        try {\n            //first, we check if contribution is part of transaction\n            $c = new Contribution($zdb, $login, (int)$contrib_id);\n            if ($c->isTransactionPartOf($trans_id)) {\n                $update = $zdb->update(self::TABLE);\n                $update->set(\n                    array(Transaction::PK => null)\n                )->where(\n                    self::PK . ' = ' . $contrib_id\n                );\n                $zdb->execute($update);\n                return true;\n            } else {\n                Analog::log(\n                    'Contribution #' . $contrib_id .\n                    ' is not actually part of transaction #' . $trans_id,\n                    Analog::WARNING\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to detach contribution #' . $contrib_id .\n                ' to transaction #' . $trans_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set a contribution as a transaction part\n     *\n     * @param Db  $zdb        Database instance\n     * @param int $trans_id   Transaction identifier\n     * @param int $contrib_id Contribution identifier\n     *\n     * @return boolean\n     */\n    public static function setTransactionPart(Db $zdb, $trans_id, $contrib_id)\n    {\n        try {\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array(Transaction::PK => $trans_id)\n            )->where(self::PK . ' = ' . $contrib_id);\n\n            $zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to attach contribution #' . $contrib_id .\n                ' to transaction #' . $trans_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Is current contribution a membership fee\n     *\n     * @return boolean\n     */\n    public function isFee()\n    {\n        return $this->_is_cotis;\n    }\n\n    /**\n     * Is current contribution part of specified transaction\n     *\n     * @param int $id Transaction identifier\n     *\n     * @return boolean\n     */\n    public function isTransactionPartOf($id)\n    {\n        if ($this->isTransactionPart()) {\n            return $id == $this->_transaction->id;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Is current contribution part of transaction\n     *\n     * @return boolean\n     */\n    public function isTransactionPart()\n    {\n        return $this->_transaction != null;\n    }\n\n    /**\n     * Execute post contribution script\n     *\n     * @param ExternalScript $es     External script to execute\n     * @param array          $extra  Extra information on contribution\n     *                               Defaults to null\n     * @param array          $pextra Extra information on payment\n     *                               Defaults to null\n     *\n     * @return mixed Script return value on success, values and script output on fail\n     */\n    public function executePostScript(\n        ExternalScript $es,\n        $extra = null,\n        $pextra = null\n    ) {\n        global $preferences;\n\n        $payment = array(\n            'type'  => $this->getPaymentType()\n        );\n\n        if ($pextra !== null && is_array($pextra)) {\n            $payment = array_merge($payment, $pextra);\n        }\n\n        if (!file_exists(GALETTE_CACHE_DIR . '/pdf_contribs')) {\n            @mkdir(GALETTE_CACHE_DIR . '/pdf_contribs');\n        }\n\n        $voucher_path = null;\n        if ($this->_id !== null) {\n            $voucher = new PdfContribution($this, $this->zdb, $preferences);\n            $voucher->store(GALETTE_CACHE_DIR . '/pdf_contribs');\n            $voucher_path = $voucher->getPath();\n        }\n\n        $contrib = array(\n            'id'        => (int)$this->_id,\n            'date'      => $this->_date,\n            'type'      => $this->getRawType(),\n            'amount'    => $this->amount,\n            'voucher'   => $voucher_path,\n            'category'  => array(\n                'id'    => $this->type->id,\n                'label' => $this->type->libelle\n            ),\n            'payment'   => $payment\n        );\n\n        if ($this->_member !== null) {\n            $m = new Adherent($this->zdb, (int)$this->_member);\n            $member = array(\n                'id'            => (int)$this->_member,\n                'name'          => $m->sfullname,\n                'email'         => $m->email,\n                'organization'  => ($m->isCompany() ? 1 : 0),\n                'status'        => array(\n                    'id'    => $m->status,\n                    'label' => $m->sstatus\n                ),\n                'country'       => $m->country\n            );\n\n            if ($m->isCompany()) {\n                $member['organization_name'] = $m->company_name;\n            }\n\n            $contrib['member'] = $member;\n        }\n\n        if ($extra !== null && is_array($extra)) {\n            $contrib = array_merge($contrib, $extra);\n        }\n\n        $res = $es->send($contrib);\n\n        if ($res !== true) {\n            Analog::log(\n                'An error occurred calling post contribution ' .\n                \"script:\\n\" . $es->getOutput(),\n                Analog::ERROR\n            );\n            $res = _T(\"Contribution information\") . \"\\n\";\n            $res .= print_r($contrib, true);\n            $res .= \"\\n\\n\" . _T(\"Script output\") . \"\\n\";\n            $res .= $es->getOutput();\n        }\n\n        return $res;\n    }\n    /**\n     * Get raw contribution type\n     *\n     * @return string\n     */\n    public function getRawType()\n    {\n        if ($this->isFee()) {\n            return 'membership';\n        } else {\n            return 'donation';\n        }\n    }\n\n    /**\n     * Get contribution type label\n     *\n     * @return string\n     */\n    public function getTypeLabel()\n    {\n        if ($this->isFee()) {\n            return _T(\"Membership\");\n        } else {\n            return _T(\"Donation\");\n        }\n    }\n\n    /**\n     * Get payment type label\n     *\n     * @return string\n     */\n    public function getPaymentType()\n    {\n        if ($this->_payment_type === null) {\n            return '-';\n        }\n\n        $ptype = new PaymentType($this->zdb, (int)$this->payment_type);\n        return $ptype->getName(false);\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrieve\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n\n        $forbidden = array('is_cotis');\n        $virtuals = array('duration', 'spayment_type', 'model', 'raw_date',\n            'raw_begin_date', 'raw_end_date'\n        );\n\n        $rname = '_' . $name;\n\n        if (in_array($name, $forbidden)) {\n            Analog::log(\n                \"Call to __get for '$name' is forbidden!\",\n                Analog::WARNING\n            );\n\n            switch ($name) {\n                case 'is_cotis':\n                    return $this->isFee();\n                    break;\n                default:\n                    throw new \\RuntimeException(\"Call to __get for '$name' is forbidden!\");\n            }\n        } elseif (\n            property_exists($this, $rname)\n            || in_array($name, $virtuals)\n        ) {\n            switch ($name) {\n                case 'raw_date':\n                case 'raw_begin_date':\n                case 'raw_end_date':\n                    $rname = '_' . substr($name, 4);\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d;\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            throw $e;\n                        }\n                    }\n                    break;\n                case 'date':\n                case 'begin_date':\n                case 'end_date':\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$rname;\n                        }\n                    }\n                    break;\n                case 'duration':\n                    if ($this->_is_cotis) {\n                        $date_end = new \\DateTime($this->_end_date);\n                        $date_start = new \\DateTime($this->_begin_date);\n                        $diff = $date_end->diff($date_start);\n                        return $diff->format('%y') * 12 + $diff->format('%m');\n                    } else {\n                        return '';\n                    }\n                    break;\n                case 'spayment_type':\n                    return $this->getPaymentType();\n                    break;\n                case 'model':\n                    if ($this->_is_cotis === null) {\n                        return null;\n                    }\n                    return ($this->isFee()) ?\n                        PdfModel::INVOICE_MODEL : PdfModel::RECEIPT_MODEL;\n                    break;\n                default:\n                    return $this->$rname;\n                    break;\n            }\n        } else {\n            Analog::log(\n                \"Unknown property '$rname'\",\n                Analog::WARNING\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Global setter method\n     *\n     * @param string $name  name of the property we want to assign a value to\n     * @param object $value a relevant value for the property\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        global $preferences;\n\n        $forbidden = array('fields', 'is_cotis', 'end_date');\n\n        if (!in_array($name, $forbidden)) {\n            $rname = '_' . $name;\n            switch ($name) {\n                case 'transaction':\n                    if (is_int($value)) {\n                        $this->$rname = new Transaction($this->zdb, $this->login, $value);\n                    } else {\n                        Analog::log(\n                            'Trying to set a transaction from an id that is not an integer.',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'type':\n                    if (is_int($value)) {\n                        //set type\n                        $this->$rname = new ContributionsTypes($this->zdb, $value);\n                        //set is_cotis according to type\n                        if ($this->$rname->extension == 1) {\n                            $this->_is_cotis = true;\n                        } else {\n                            $this->_is_cotis = false;\n                        }\n                    } else {\n                        Analog::log(\n                            'Trying to set a type from an id that is not an integer.',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'begin_date':\n                    try {\n                        $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                        if ($d === false) {\n                            throw new \\Exception('Incorrect format');\n                        }\n                        $this->_begin_date = $d->format('Y-m-d');\n                    } catch (Throwable $e) {\n                        Analog::log(\n                            'Wrong date format. field: ' . $name .\n                            ', value: ' . $value . ', expected fmt: ' .\n                            __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                            Analog::INFO\n                        );\n                        $this->errors[] = str_replace(\n                            array(\n                                '%date_format',\n                                '%field'\n                            ),\n                            array(\n                                __(\"Y-m-d\"),\n                                $this->_fields['date_debut_cotis']['label']\n                            ),\n                            _T(\"- Wrong date format (%date_format) for %field!\")\n                        );\n                    }\n                    break;\n                case 'amount':\n                    if (is_numeric($value) && $value > 0) {\n                        $this->$rname = $value;\n                    } else {\n                        Analog::log(\n                            'Trying to set an amount with a non numeric value, ' .\n                            'or with a zero value',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'member':\n                    if (is_int($value)) {\n                        //set type\n                        $this->$rname = $value;\n                    }\n                    break;\n                case 'payment_type':\n                    $ptypes = new PaymentTypes(\n                        $this->zdb,\n                        $preferences,\n                        $this->login\n                    );\n                    $list = $ptypes->getList();\n                    if (isset($list[$value])) {\n                        $this->_payment_type = $value;\n                    } else {\n                        Analog::log(\n                            'Unknown payment type ' . $value,\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                default:\n                    Analog::log(\n                        '[' . __CLASS__ . ']: Trying to set an unknown property (' .\n                        $name . ')',\n                        Analog::WARNING\n                    );\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Flag creation mail sending\n     *\n     * @param boolean $send True (default) to send creation email\n     *\n     * @return Contribution\n     */\n    public function setSendmail($send = true)\n    {\n        $this->sendmail = $send;\n        return $this;\n    }\n\n    /**\n     * Should we send administrative emails to member?\n     *\n     * @return boolean\n     */\n    public function sendEMail()\n    {\n        return $this->sendmail;\n    }\n\n    /**\n     * Handle files (dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been threw attempting to edit/store a contribution files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Get required fields list\n     *\n     * @return array\n     */\n    public function getRequired(): array\n    {\n        return [\n            'id_type_cotis'     => 1,\n            'id_adh'            => 1,\n            'date_enreg'        => 1,\n            'date_debut_cotis'  => 1,\n            'date_fin_cotis'    => $this->isFee() ? 1 : 0,\n            'montant_cotis'     => $this->isFee() ? 1 : 0\n        ];\n    }\n\n    /**\n     * Can current logged-in user display contribution\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        //non-logged-in members cannot show contributions\n        if (!$login->isLogged()) {\n            return false;\n        }\n\n        //admin and staff users can edit, as well as member itself\n        if (!$this->id || $this->id && $login->id == $this->_member || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can see their children contributions\n        $parent = new Adherent($this->zdb);\n        $parent\n            ->disableAllDeps()\n            ->enableDep('children')\n            ->load($this->login->id);\n        if ($parent->hasChildren()) {\n            foreach ($parent->children as $child) {\n                if ($child->id === $this->_member) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return false;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Entitleds handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2007-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2007-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2007-10-27\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Features\\I18n;\n\n/**\n * Entitled handling. Manage:\n *      - id\n *      - label\n *      - extra (that may differ from one entity to another)\n *\n * @category  Entity\n * @name      Entitled\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2007-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2007-10-27\n *\n * @property integer $id\n * @property string $label\n * @property string $libelle\n * @property mixed $third\n * @property mixed $extension\n */\n\nabstract class Entitled\n{\n    use I18n;\n\n    public const ID_NOT_EXITS = -1;\n\n    private $zdb;\n    private $table;\n    private $fpk;\n    private $flabel;\n    private $fthird;\n    private $used;\n\n    public static $fields;\n    protected static $defaults;\n\n    /** @var string|false */\n    protected $order_field = false;\n\n    private $id;\n    private $label;\n    private $third;\n\n    private $errors = array();\n\n    /**\n     * Default constructor\n     *\n     * @param Db     $zdb    Database\n     * @param string $table  Table name\n     * @param string $fpk    Primary key field name\n     * @param string $flabel Label fields name\n     * @param string $fthird The third field name\n     * @param string $used   Table name for isUsed function\n     * @param mixed  $args   Either an int or a resultset to load\n     */\n    public function __construct(Db $zdb, $table, $fpk, $flabel, $fthird, $used, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->table = $table;\n        $this->fpk = $fpk;\n        $this->flabel = $flabel;\n        $this->fthird = $fthird;\n        $this->used = $used;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n    }\n\n    /**\n     * Loads an entry from its id\n     *\n     * @param int $id Entry ID\n     *\n     * @return boolean true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select($this->table);\n            $select->where($this->fpk . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $this->loadFromRS($result);\n\n                return true;\n            } else {\n                Analog::log(\n                    'Unknown ID ' . $id,\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load ' . $this->getType() . ' from id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = $this->fpk;\n        $this->id = $r->$pk;\n        $flabel = $this->flabel;\n        $this->label = $r->$flabel;\n        $fthird = $this->fthird;\n        $this->third = $r->$fthird;\n    }\n\n    /**\n     * Set defaults at install time\n     *\n     * @return boolean\n     * @throws Throwable\n     */\n    public function installInit()\n    {\n        $class = get_class($this);\n\n        try {\n            //first, we drop all values\n            $delete = $this->zdb->delete($this->table);\n            $this->zdb->execute($delete);\n\n            $values = array();\n            foreach ($class::$fields as $key => $f) {\n                $values[$f] = ':' . $key;\n            }\n\n            $insert = $this->zdb->insert($this->table);\n            $insert->values($values);\n            $stmt = $this->zdb->sql->prepareStatementForSqlObject($insert);\n\n            $this->zdb->handleSequence(\n                $this->table,\n                count(static::$defaults)\n            );\n\n            $fnames = array_values($values);\n            foreach ($class::$defaults as $d) {\n                $val = null;\n                if (isset($d['priority'])) {\n                    $val = $d['priority'];\n                } else {\n                    $val = $d['extension'];\n                }\n\n                $stmt->execute(\n                    array(\n                        $fnames[0]  => $d['id'],\n                        $fnames[1]  => $d['libelle'],\n                        $fnames[2]  => $val\n                    )\n                );\n            }\n\n            Analog::log(\n                'Defaults (' . $this->getType() .\n                ') were successfully stored into database.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to initialize defaults (' . $this->getType() . ').' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get list in an array built as:\n     * $array[id] = \"translated label\"\n     *\n     * @param boolean|null $extent Filter on (non) cotisations types\n     *\n     * @return array|false\n     */\n    public function getList(bool $extent = null)\n    {\n        $list = array();\n\n        try {\n            $select = $this->zdb->select($this->table);\n            $fields = array($this->fpk, $this->flabel);\n            if (\n                $this->order_field !== false\n                && $this->order_field !== $this->fpk\n                && $this->order_field !== $this->flabel\n            ) {\n                $fields[] = $this->order_field;\n            }\n            $select->quantifier('DISTINCT');\n            $select->columns($fields);\n\n            if ($this->order_field !== false) {\n                $select->order($this->order_field, $this->fpk);\n            }\n            if ($extent !== null) {\n                if ($extent === true) {\n                    $select->where(array($this->fthird => new Expression('true')));\n                } elseif ($extent === false) {\n                    $select->where(array($this->fthird => new Expression('false')));\n                }\n            }\n\n            $results = $this->zdb->execute($select);\n\n            foreach ($results as $r) {\n                $fpk = $this->fpk;\n                $flabel = $this->flabel;\n                $list[$r->$fpk] = _T($r->$flabel);\n            }\n            return $list;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Complete list\n     *\n     * @return array of all objects if succeeded, false otherwise\n     */\n    public function getCompleteList()\n    {\n        $list = array();\n\n        try {\n            $select = $this->zdb->select($this->table);\n            if ($this->order_field !== false) {\n                $select->order(array($this->order_field, $this->fpk));\n            }\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() == 0) {\n                Analog::log(\n                    'No entries (' . $this->getType() . ') defined in database.',\n                    Analog::INFO\n                );\n            } else {\n                $pk = $this->fpk;\n                $flabel = $this->flabel;\n                $fprio = $this->fthird;\n\n                foreach ($results as $r) {\n                    $list[$r->$pk] = array(\n                        'name'  => _T($r->$flabel),\n                        'extra' => $r->$fprio\n                    );\n                }\n            }\n            return $list;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list entries (' . $this->getType() .\n                ') | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get a entry\n     *\n     * @param integer $id Entry ID\n     *\n     * @return mixed|false Row if succeed ; false: no such id\n     */\n    public function get($id)\n    {\n        if (!is_numeric($id)) {\n            $this->errors[] = _T(\"ID must be an integer!\");\n            return false;\n        }\n\n        try {\n            $select = $this->zdb->select($this->table);\n            $select->where($this->fpk . '=' . $id);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if (!$result) {\n                $this->errors[] = _T(\"Label does not exist\");\n                return false;\n            }\n\n            return $result;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get a label\n     *\n     * @param integer $id         Id\n     * @param boolean $translated Do we want translated or original label?\n     *                            Defaults to true.\n     *\n     * @return string\n     */\n    public function getLabel($id, $translated = true)\n    {\n        $res = $this->get($id);\n        if ($res === false) {\n            //get() already logged\n            return self::ID_NOT_EXITS;\n        };\n        $field = $this->flabel;\n        return ($translated) ? _T($res->$field) : $res->$field;\n    }\n\n    /**\n     * Get an ID from a label\n     *\n     * @param string $label The label\n     *\n     * @return int|false Return id if it exists false otherwise\n     */\n    public function getIdByLabel($label)\n    {\n        try {\n            $pk = $this->fpk;\n            $select = $this->zdb->select($this->table);\n            $select->columns(array($pk))\n                ->where(array($this->flabel => $label));\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                return $result->$pk;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to retrieve ' . $this->getType() . ' from label `' .\n                $label . '` | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Add a new entry\n     *\n     * @param string  $label The label\n     * @param integer $extra Extra values (priority for statuses,\n     *                       extension for contributions types, ...)\n     *\n     * @return integer id if success ; -1 : DB error ; -2 : label already exists\n     */\n    public function add($label, $extra)\n    {\n        // Avoid duplicates.\n        $ret = $this->getIdByLabel($label);\n\n        if ($ret !== false) {\n            Analog::log(\n                $this->getType() . ' with label `' . $label . '` already exists',\n                Analog::WARNING\n            );\n            return -2;\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array(\n                $this->flabel  => $label,\n                $this->fthird  => $extra\n            );\n\n            $insert = $this->zdb->insert($this->table);\n            $insert->values($values);\n\n            $ret = $this->zdb->execute($insert);\n\n            if ($ret->count() > 0) {\n                Analog::log(\n                    'New ' . $this->getType() . ' `' . $label .\n                    '` added successfully.',\n                    Analog::INFO\n                );\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                $this->addTranslation($label);\n            } else {\n                throw new \\Exception('New ' . $this->getType() . ' not added.');\n            }\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to add new entry `' . $label . '` | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Update in database.\n     *\n     * @param integer $id    Entry ID\n     * @param string  $label The label\n     * @param integer $extra Extra values (priority for statuses,\n     *                       extension for contributions types, ...)\n     *\n     * @return ID_NOT_EXITS|boolean\n     */\n    public function update($id, $label, $extra)\n    {\n        $ret = $this->get($id);\n        if (!$ret) {\n            /* get() already logged and set $this->error. */\n            return self::ID_NOT_EXITS;\n        }\n\n        $class = get_class($this);\n\n        try {\n            $oldlabel = $ret->{$this->flabel};\n            $this->zdb->connection->beginTransaction();\n            $values = array(\n                $this->flabel  => $label,\n                $this->fthird  => $extra\n            );\n\n            $update = $this->zdb->update($this->table);\n            $update->set($values);\n            $update->where($this->fpk . ' = ' . $id);\n\n            $ret = $this->zdb->execute($update);\n\n            if ($oldlabel != $label) {\n                $this->deleteTranslation($oldlabel);\n                $this->addTranslation($label);\n            }\n\n            Analog::log(\n                $this->getType() . ' #' . $id . ' updated successfully.',\n                Analog::INFO\n            );\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to update ' . $this->getType() . ' #' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Delete entry\n     *\n     * @param integer $id Entry ID\n     *\n     * @return ID_NOT_EXITS|boolean\n     */\n    public function delete($id)\n    {\n        $ret = $this->get($id);\n        if (!$ret) {\n            /* get() already logged */\n            return self::ID_NOT_EXITS;\n        }\n\n        if ($this->isUsed($id)) {\n            $this->errors[] = _T(\"Cannot delete this label: it's still used\");\n            return false;\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $delete = $this->zdb->delete($this->table);\n            $delete->where($this->fpk . ' = ' . $id);\n\n            $this->zdb->execute($delete);\n            $this->deleteTranslation($ret->{$this->flabel});\n\n            Analog::log(\n                $this->getType() . ' ' . $id . ' deleted successfully.',\n                Analog::INFO\n            );\n\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to delete ' . $this->getType() . ' ' . $id .\n                ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Check if this entry is used.\n     *\n     * @param integer $id Entry ID\n     *\n     * @return boolean\n     */\n    public function isUsed($id)\n    {\n        try {\n            $select = $this->zdb->select($this->used);\n            $select->where($this->fpk . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if ($result !== null) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to check if ' . $this->getType . ' `' . $id .\n                '` is used. | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            //in case of error, we consider that it is used, to avoid errors\n            return true;\n        }\n    }\n\n    /**\n     * Get textual type representation\n     *\n     * @return string\n     */\n    abstract protected function getType();\n\n    /**\n     * Get translated textual representation\n     *\n     * @return string\n     */\n    abstract public function getI18nType();\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrive\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array();\n        $virtuals = array('extension', 'libelle');\n        if (\n            in_array($name, $virtuals)\n            || !in_array($name, $forbidden)\n            && isset($this->$name)\n        ) {\n            switch ($name) {\n                case 'libelle':\n                    return _T($this->label);\n                    break;\n                case 'extension':\n                    return $this->third;\n                    break;\n                default:\n                    return $this->$name;\n                    break;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors(): array\n    {\n        return $this->errors;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Group entity\n *\n * PHP version 5\n *\n * Copyright \u00a9 2012-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2012-01-17\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Login;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * Group entity\n *\n * @category  Entity\n * @name      Group\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2012-01-17\n */\nclass Group\n{\n    public const TABLE = 'groups';\n    public const PK = 'id_group';\n    //relations tables\n    public const GROUPSUSERS_TABLE = 'groups_members';\n    public const GROUPSMANAGERS_TABLE = 'groups_managers';\n\n    public const MEMBER_TYPE = 0;\n    public const MANAGER_TYPE = 1;\n\n    private $id;\n    private $group_name;\n    private $parent_group;\n    private $managers;\n    private $members;\n    private $groups;\n    private $creation_date;\n    private $count_members;\n    private $isempty;\n\n    /**\n     * Default constructor\n     *\n     * @param null|int|ResultSet $args Either a ResultSet row or its id for to load\n     *                                 a specific group, or null to just\n     *                                 instanciate object\n     */\n    public function __construct($args = null)\n    {\n        if ($args == null || is_int($args)) {\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n    }\n\n    /**\n     * Loads a group from its id\n     *\n     * @param int $id the identifiant for the group to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where(array(self::PK => $id));\n\n            $results = $zdb->execute($select);\n\n            if ($results->count() > 0) {\n                $this->loadFromRS($results->current());\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load group form id `' . $id . '` | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->id = $r->id_group;\n        $this->group_name = $r->group_name;\n        $this->creation_date = $r->creation_date;\n        if ($r->parent_group) {\n            $this->parent_group = new Group((int)$r->parent_group);\n        }\n        $adhpk = Adherent::PK;\n        if (isset($r->members)) {\n            //we're from a list, we just want members count\n            $this->count_members = $r->members;\n        } else {\n            //we're probably from a single group, let's load sub entities\n            //$this->loadPersons(self::MEMBER_TYPE);\n            //$this->loadPersons(self::MANAGER_TYPE);\n            //$this->loadSubGroups();\n        }\n    }\n\n    /**\n     * Loads members for the current group\n     *\n     * @param int $type Either self::MEMBER_TYPE or self::MANAGER_TYPE\n     *\n     * @return void\n     */\n    private function loadPersons($type)\n    {\n        global $zdb;\n\n        if ($this->id) {\n            try {\n                $join = null;\n                switch ($type) {\n                    case self::MEMBER_TYPE:\n                        $join = PREFIX_DB . self::GROUPSUSERS_TABLE;\n                        break;\n                    case self::MANAGER_TYPE:\n                        $join = PREFIX_DB . self::GROUPSMANAGERS_TABLE;\n                        break;\n                }\n\n                $select = $zdb->select(Adherent::TABLE, 'a');\n                $select->join(\n                    array('g' => $join),\n                    'g.' . Adherent::PK . '=a.' . Adherent::PK,\n                    array()\n                )->where(\n                    'g.' . self::PK . ' = ' . $this->id\n                )->order(\n                    'nom_adh ASC',\n                    'prenom_adh ASC'\n                );\n\n                $results = $zdb->execute($select);\n                $members = array();\n\n                $deps = array(\n                    'picture'   => false,\n                    'groups'    => false,\n                    'dues'      => false\n                );\n\n                foreach ($results as $m) {\n                    $members[] = new Adherent($zdb, $m, $deps);\n                }\n\n                if ($type === self::MEMBER_TYPE) {\n                    $this->members = $members;\n                } else {\n                    $this->managers = $members;\n                }\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot get group persons | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Load sub-groups\n     *\n     * @return void\n     */\n    private function loadSubGroups()\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE, 'a');\n\n            if (!$this->login->isAdmin() && !$this->login->isStaff()) {\n                $select->join(\n                    array('b' => PREFIX_DB . self::GROUPSMANAGERS_TABLE),\n                    'a.' . self::PK . '=b.' . self::PK,\n                    array()\n                )->where('b.' . Adherent::PK . ' = ' . $this->login->id);\n            }\n\n            $select->where('parent_group = ' . $this->id)\n                ->order('group_name ASC');\n\n            $results = $zdb->execute($select);\n            $groups = array();\n            $grppk = self::PK;\n            foreach ($results as $m) {\n                $group = new Group((int)$m->$grppk);\n                $group->setLogin($this->login);\n                $groups[] = $group;\n            }\n            $this->groups = $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot get subgroup for group ' . $this->group_name .\n                ' (' . $this->id . ')| ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified group\n     *\n     * @param boolean $cascade Also remove members and managers\n     *\n     * @return boolean\n     */\n    public function remove($cascade = false)\n    {\n        global $zdb;\n        $transaction = false;\n\n        try {\n            if (!$zdb->connection->inTransaction()) {\n                $zdb->connection->beginTransaction();\n                $transaction = true;\n            }\n\n            if ($cascade === true) {\n                $subgroups = $this->getGroups();\n                if (count($subgroups) > 0) {\n                    Analog::log(\n                        'Cascading remove ' . $this->group_name .\n                        '. Subgroups, their members and managers will be detached.',\n                        Analog::INFO\n                    );\n                    foreach ($subgroups as $subgroup) {\n                        $subgroup->remove(true);\n                    }\n                }\n\n                Analog::log(\n                    'Cascading remove ' . $this->group_name .\n                    '. Members and managers will be detached.',\n                    Analog::INFO\n                );\n\n                //delete members\n                $delete = $zdb->delete(self::GROUPSUSERS_TABLE);\n                $delete->where(\n                    self::PK . ' = ' . $this->id\n                );\n                $zdb->execute($delete);\n\n                //delete managers\n                $delete = $zdb->delete(self::GROUPSMANAGERS_TABLE);\n                $delete->where(\n                    self::PK . ' = ' . $this->id\n                );\n                $zdb->execute($delete);\n            }\n\n            //delete group itself\n            $delete = $zdb->delete(self::TABLE);\n            $delete->where(\n                self::PK . ' = ' . $this->id\n            );\n            $zdb->execute($delete);\n\n            //commit all changes\n            if ($transaction) {\n                $zdb->connection->commit();\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $zdb->connection->rollBack();\n            }\n            if ($e->getCode() == 23000) {\n                Analog::log(\n                    str_replace(\n                        '%group',\n                        $this->group_name,\n                        'Group \"%group\" still have members!'\n                    ),\n                    Analog::WARNING\n                );\n                $this->isempty = false;\n            } else {\n                Analog::log(\n                    'Unable to delete group ' . $this->group_name .\n                    ' (' . $this->id . ') |' . $e->getMessage(),\n                    Analog::ERROR\n                );\n                throw $e;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Is group empty? (after first deletion try)\n     *\n     * @return boolean\n     */\n    public function isEmpty()\n    {\n        return $this->isempty;\n    }\n\n    /**\n     * Detach a group from its parent\n     *\n     * @return boolean\n     */\n    public function detach()\n    {\n        global $zdb, $hist;\n\n        try {\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array('parent_group' => new Expression('NULL'))\n            )->where(\n                self::PK . ' = ' . $this->id\n            );\n\n            $edit = $zdb->execute($update);\n\n            //edit == 0 does not mean there were an error, but that there\n            //were nothing to change\n            if ($edit->count() > 0) {\n                $this->parent_group = null;\n                $hist->add(\n                    _T(\"Group has been detached from its parent\"),\n                    $this->group_name\n                );\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong detaching group `' . $this->group_name .\n                '` (' . $this->id . ') from its parent:\\'( | ' .\n                $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the group\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $zdb, $hist;\n\n        try {\n            $values = array(\n                self::PK     => $this->id,\n                'group_name' => $this->group_name\n            );\n\n            if ($this->parent_group) {\n                $values['parent_group'] = $this->parent_group->getId();\n            }\n\n            if (!isset($this->id) || $this->id == '') {\n                //we're inserting a new group\n                unset($values[self::PK]);\n                $this->creation_date = date(\"Y-m-d H:i:s\");\n                $values['creation_date'] = $this->creation_date;\n\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->id = $zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Group added\"),\n                        $this->group_name\n                    );\n                    return true;\n                } else {\n                    $hist->add(_T(\"Fail to add new group.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new group!'\n                    );\n                }\n            } else {\n                //we're editing an existing group\n                $update = $zdb->update(self::TABLE);\n                $update\n                    ->set($values)\n                    ->where(self::PK . '=' . $this->id);\n\n                $edit = $zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Group updated\"),\n                        $this->group_name\n                    );\n                }\n                return true;\n            }\n            /** FIXME: also store members and managers? */\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Is current logged-in user manager of the group?\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function isManager(Login $login)\n    {\n        if ($login->isAdmin() || $login->isStaff()) {\n            //admins as well as staff members are managers for all groups!\n            return true;\n        } else {\n            //let's check if current logged-in user is part of group managers\n            foreach ($this->managers as $manager) {\n                if ($login->login == $manager->login) {\n                    return true;\n                    break;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get group id\n     *\n     * @return integer\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Get Level of the group\n     *\n     * @return integer\n     */\n    public function getLevel()\n    {\n        if ($this->parent_group) {\n            return $this->parent_group->getLevel() + 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Get the full name of the group \"foo / bar\"\n     *\n     * @return string\n     */\n    public function getFullName()\n    {\n        if ($this->parent_group) {\n            return $this->parent_group->getFullName() . ' / ' . $this->group_name;\n        }\n        return $this->group_name;\n    }\n\n    /**\n     * Get the indented short name of the group \"  >> bar\"\n     *\n     * @return string\n     */\n    public function getIndentName()\n    {\n        if (($level = $this->getLevel())) {\n            return str_repeat(\"&nbsp;\", 3 * $level) . '&raquo; ' . $this->group_name;\n        }\n        return $this->group_name;\n    }\n\n    /**\n     * Get group name\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->group_name;\n    }\n\n    /**\n     * Get group members\n     *\n     * @return Adherent[]\n     */\n    public function getMembers()\n    {\n        if (!is_array($this->members)) {\n            $this->loadPersons(self::MEMBER_TYPE);\n        }\n        return $this->members;\n    }\n\n    /**\n     * Get groups managers\n     *\n     * @return Adherent[]\n     */\n    public function getManagers()\n    {\n        if (!is_array($this->managers)) {\n            $this->loadPersons(self::MANAGER_TYPE);\n        }\n        return $this->managers;\n    }\n\n    /**\n     * Get subgroups\n     *\n     * @return Group[]\n     */\n    public function getGroups()\n    {\n        if (!is_array($this->groups)) {\n            $this->loadSubGroups();\n        }\n        return $this->groups;\n    }\n\n    /**\n     * Get parent group\n     *\n     * @return Group\n     */\n    public function getParentGroup()\n    {\n        return $this->parent_group;\n    }\n\n    /**\n     * Get group creation date\n     *\n     * @param boolean $formatted Return date formatted, raw if false\n     *\n     * @return string\n     */\n    public function getCreationDate($formatted = true)\n    {\n        if ($formatted === true) {\n            $date = new \\DateTime($this->creation_date);\n            return $date->format(__(\"Y-m-d\"));\n        } else {\n            return $this->creation_date;\n        }\n    }\n\n    /**\n     * Get member count\n     *\n     * @param boolean $force Force members load, defaults to false\n     *\n     * @return int\n     */\n    public function getMemberCount($force = false)\n    {\n        if (isset($this->members) && is_array($this->members)) {\n            return count($this->members);\n        } elseif (isset($this->count_members)) {\n            return $this->count_members;\n        } else {\n            if ($force === true) {\n                return count($this->getMembers());\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Group name\n     *\n     * @return Group\n     */\n    public function setName($name)\n    {\n        $this->group_name = $name;\n        return $this;\n    }\n\n    /**\n     * Set all subgroups\n     *\n     * @param array $groups Groups id\n     *\n     * @return Group\n     */\n    public function setSubgroups($groups)\n    {\n        $this->groups = $groups;\n        return $this;\n    }\n\n    /**\n     * check if can Set parent group\n     *\n     * @param Group $group Parent group\n     *\n     * @return boolean\n     */\n    public function canSetParentGroup(Group $group)\n    {\n        do {\n            if ($group->getId() == $this->getId()) {\n                return false;\n            }\n        } while ($group = $group->getParentGroup());\n\n        return true;\n    }\n\n    /**\n     * Set parent group\n     *\n     * @param int $id Parent group identifier\n     *\n     * @return Group\n     */\n    public function setParentGroup($id)\n    {\n        $group = new Group((int)$id);\n\n        if (!$this->canSetParentGroup($group)) {\n            //does not seem to work :/\n            throw new \\Exception(\n                sprintf(\n                    _T('Group `%1$s` cannot be set as parent!'),\n                    $group->getName()\n                )\n            );\n        }\n\n        $this->parent_group = $group;\n        return $this;\n    }\n\n    /**\n     * Set members\n     *\n     * @param Adherent[] $members Members list\n     *\n     * @return void\n     */\n    public function setMembers($members)\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //first, remove current groups members\n            $delete = $zdb->delete(self::GROUPSUSERS_TABLE);\n            $delete->where(\n                self::PK . ' = ' . $this->id\n            );\n            $zdb->execute($delete);\n\n            Analog::log(\n                'Group members has been removed for `' . $this->group_name .\n                '`, we can now store new ones.',\n                Analog::INFO\n            );\n\n            $insert = $zdb->insert(self::GROUPSUSERS_TABLE);\n            $insert->values(\n                array(\n                    self::PK        => ':group',\n                    Adherent::PK    => ':adh'\n                )\n            );\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n            if (is_array($members)) {\n                foreach ($members as $m) {\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $this->id,\n                            'adh'   => $m->id\n                        )\n                    );\n\n                    if ($result) {\n                        Analog::log(\n                            'Member `' . $m->sname . '` attached to group `' .\n                            $this->group_name . '`.',\n                            Analog::DEBUG\n                        );\n                    } else {\n                        Analog::log(\n                            'An error occurred trying to attach member `' .\n                            $m->sname . '` to group `' . $this->group_name .\n                            '` (' . $this->id . ').',\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to attach `' . $m->sname . '` ' .\n                            'to ' . $this->group_name . '(' . $this->id . ')'\n                        );\n                    }\n                }\n            }\n            //commit all changes\n            $zdb->connection->commit();\n\n            Analog::log(\n                'Group members updated successfully.',\n                Analog::INFO\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            $messages = array();\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                'Unable to attach members to group `' . $this->group_name .\n                '` (' . $this->id . ')|' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set managers\n     *\n     * @param Adherent[] $members Managers list\n     *\n     * @return boolean\n     */\n    public function setManagers($members)\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //first, remove current groups managers\n            $delete = $zdb->delete(self::GROUPSMANAGERS_TABLE);\n            $delete->where(\n                self::PK . ' = ' . $this->id\n            );\n            $zdb->execute($delete);\n\n            Analog::log(\n                'Group managers has been removed for `' . $this->group_name .\n                '`, we can now store new ones.',\n                Analog::INFO\n            );\n\n            $insert = $zdb->insert(self::GROUPSMANAGERS_TABLE);\n            $insert->values(\n                array(\n                    self::PK        => ':group',\n                    Adherent::PK    => ':adh'\n                )\n            );\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n            if (is_array($members)) {\n                foreach ($members as $m) {\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $this->id,\n                            'adh'   => $m->id\n                        )\n                    );\n\n                    if ($result) {\n                        Analog::log(\n                            'Manager `' . $m->sname . '` attached to group `' .\n                            $this->group_name . '`.',\n                            Analog::DEBUG\n                        );\n                    } else {\n                        Analog::log(\n                            'An error occurred trying to attach manager `' .\n                            $m->sname . '` to group `' . $this->group_name .\n                            '` (' . $this->id . ').',\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to attach `' . $m->sname . '` ' .\n                            'to ' . $this->group_name . '(' . $this->id . ')'\n                        );\n                    }\n                }\n            }\n            //commit all changes\n            $zdb->connection->commit();\n\n            Analog::log(\n                'Groups managers updated successfully.',\n                Analog::INFO\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            $messages = array();\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                'Unable to attach managers to group `' . $this->group_name .\n                '` (' . $this->id . ')|' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set login instance\n     *\n     * @param Login $login Login instance\n     *\n     * @return Group\n     */\n    public function setLogin(Login $login)\n    {\n        $this->login = $login;\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Import model\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.6dev - 2013-09-26\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\n\n/**\n * Import model entity\n *\n * @category  Entity\n * @name      ImportModel\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.6dev - 2013-09-26\n */\nclass ImportModel\n{\n    public const TABLE = 'import_model';\n    public const PK = 'model_id';\n\n    private $id;\n    private $fields;\n    private $creation_date;\n\n    /**\n     * Loads model\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load()\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n\n            if ($result) {\n                $this->loadFromRS($result);\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load import model | ' . $e->getMessage() .\n                \"\\n\" . $e->__toString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->id = $r->model_id;\n        $this->fields = unserialize($r->model_fields);\n        $this->creation_date = $r->model_creation_date;\n    }\n\n    /**\n     * Remove model\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function remove($zdb)\n    {\n        try {\n            $result = $zdb->db->query(\n                'TRUNCATE TABLE ' . PREFIX_DB . self::TABLE,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n\n            if ($result) {\n                $this->id = null;\n                $this->fields = null;\n                $this->creation_date = null;\n                return true;\n            }\n\n            return false;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to remove import model ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the model\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function store($zdb)\n    {\n        try {\n            $values = array(\n                self::PK        => $this->id,\n                'model_fields'  => serialize($this->fields)\n            );\n\n            if (!isset($this->id) || $this->id == '') {\n                //we're inserting a new model\n                unset($values[self::PK]);\n                $this->creation_date = date(\"Y-m-d H:i:s\");\n                $values['model_creation_date'] = $this->creation_date;\n\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($values);\n                $results = $zdb->execute($insert);\n\n                if ($results->count() > 0) {\n                    return true;\n                } else {\n                    throw new \\Exception(\n                        'An error occurred inserting new import model!'\n                    );\n                }\n            } else {\n                //we're editing an existing model\n                $update = $zdb->update(self::TABLE);\n                $update->set($values);\n                $update->where(self::PK . '=' . $this->id);\n                $zdb->execute($update);\n                return true;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong storing import model :\\'( | ' .\n                $e->getMessage() . \"\\n\" . $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get fields\n     *\n     * @return array\n     */\n    public function getFields()\n    {\n        return $this->fields;\n    }\n\n    /**\n     * Get creation date\n     *\n     * @param boolean $formatted Return date formatted, raw if false\n     *\n     * @return string\n     */\n    public function getCreationDate($formatted = true)\n    {\n        if ($formatted === true) {\n            $date = new \\DateTime($this->creation_date);\n            return $date->format(__(\"Y-m-d\"));\n        } else {\n            return $this->creation_date;\n        }\n    }\n\n    /**\n     * Set fields\n     *\n     * @param array $fields Fields list\n     *\n     * @return void\n     */\n    public function setFields($fields)\n    {\n        $this->fields = $fields;\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Payment type\n *\n * PHP version 5\n *\n * Copyright \u00a9 2018-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2018-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.2dev - 2018-07-23\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Analog\\Analog;\nuse Galette\\Features\\I18n;\nuse Galette\\Features\\Translatable;\n\n/**\n * Payment type\n *\n * @category  Entity\n * @name      PaymentType\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2018-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.2dev - 2018-07-23\n */\n\nclass PaymentType\n{\n    use Translatable;\n    use I18n;\n\n    public const TABLE = 'paymenttypes';\n    public const PK = 'type_id';\n\n    private $zdb;\n    private $id;\n\n    public const OTHER = 6;\n    public const CASH = 1;\n    public const CREDITCARD = 2;\n    public const CHECK = 3;\n    public const TRANSFER = 4;\n    public const PAYPAL = 5;\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a payment type from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where(self::PK . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n\n            $this->id = $id;\n            $this->name = $res->type_name;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading payment type #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load payment type from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->name = $rs->type_name;\n    }\n\n    /**\n     * Store payment type in database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        $data = array(\n            'type_name' => $this->name\n        );\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                if ($this->old_name !== null) {\n                    $this->deleteTranslation($this->old_name);\n                    $this->addTranslation($this->name);\n                }\n\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($data)->where(\n                    self::PK . '=' . $this->id\n                );\n                $this->zdb->execute($update);\n            } else {\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $this->zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                $this->addTranslation($this->name);\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing payment type: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current title\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        $id = (int)$this->id;\n        if ($this->isSystemType()) {\n            throw new \\RuntimeException(_T(\"You cannot delete system payment types!\"));\n        }\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                self::PK . ' = ' . $id\n            );\n            $this->zdb->execute($delete);\n            $this->deleteTranslation($this->name);\n            Analog::log(\n                'Payment type #' . $id . ' (' . $this->name\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete payment type ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'id':\n            case 'name':\n                return $this->$name;\n                break;\n            default:\n                Analog::log(\n                    'Unable to get Title property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'name':\n                if (trim($value) === '') {\n                    Analog::log(\n                        'Name cannot be empty',\n                        Analog::WARNING\n                    );\n                } else {\n                    $this->old_name = $this->name;\n                    $this->name     = $value;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Get system payment types\n     *\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return array\n     */\n    public function getSystemTypes($translated = true)\n    {\n        if ($translated) {\n            $systypes = [\n                self::OTHER         => _T(\"Other\"),\n                self::CASH          => _T(\"Cash\"),\n                self::CREDITCARD    => _T(\"Credit card\"),\n                self::CHECK         => _T(\"Check\"),\n                self::TRANSFER      => _T(\"Transfer\"),\n                self::PAYPAL        => _T(\"Paypal\")\n            ];\n        } else {\n            $systypes = [\n                self::OTHER         => \"Other\",\n                self::CASH          => \"Cash\",\n                self::CREDITCARD    => \"Credit card\",\n                self::CHECK         => \"Check\",\n                self::TRANSFER      => \"Transfer\",\n                self::PAYPAL        => \"Paypal\"\n            ];\n        }\n        return $systypes;\n    }\n\n    /**\n     * Is current payment a system one\n     *\n     * @return boolean\n     *\n     */\n    public function isSystemType()\n    {\n        return isset($this->getSystemTypes()[$this->id]);\n    }\n\n    /**\n     * Simple text representation\n     *\n     * @return string\n     */\n    public function __toString()\n    {\n        return $this->getName();\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * PDF Model\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-19\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Preferences;\nuse Galette\\Features\\Replacements;\nuse Galette\\Repository\\PdfModels;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * PDF Model\n *\n * @category  Entity\n * @name      PdfModel\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-19\n *\n * @property integer $id\n * @property string $name\n * @property integer $type\n * @property string $header\n * @property string $footer\n * @property string $title\n * @property string $subtitle\n * @property string $body\n * @property string $styles\n * @property PdfMain $parent\n */\n\nabstract class PdfModel\n{\n    use Replacements;\n\n    public const TABLE = 'pdfmodels';\n    public const PK = 'model_id';\n\n    public const MAIN_MODEL = 1;\n    public const INVOICE_MODEL = 2;\n    public const RECEIPT_MODEL = 3;\n    public const ADHESION_FORM_MODEL = 4;\n\n    private $id;\n    private $name;\n    private $type;\n    private $header;\n    private $footer;\n    private $title;\n    private $subtitle;\n    private $body;\n    private $styles;\n    private $parent;\n\n    /**\n     * Main constructor\n     *\n     * @param Db          $zdb         Database instance\n     * @param Preferences $preferences Galette preferences\n     * @param int         $type        Model type\n     * @param mixed       $args        Arguments\n     */\n    public function __construct(Db $zdb, Preferences $preferences, $type, $args = null)\n    {\n        global $container, $login;\n        $this->router = $container->get('router');\n        $this->preferences = $preferences;\n        $this\n            ->setDb($zdb)\n            ->setLogin($login);\n        $this->type = $type;\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        } else {\n            $this->load($type);\n        }\n\n        $this->setPatterns($this->getMainPatterns());\n        $this->setMain();\n    }\n\n    /**\n     * Load a Model from its identifier\n     *\n     * @param int     $id   Identifier\n     * @param boolean $init Init data if required model is missing\n     *\n     * @return void\n     */\n    protected function load($id, $init = true)\n    {\n        global $login;\n\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)\n                ->where(self::PK . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n\n            $count = $results->count();\n            if ($count === 0) {\n                if ($init === true) {\n                    $models = new PdfModels($this->zdb, $this->preferences, $login);\n                    $models->installInit();\n                    $this->load($id, false);\n                } else {\n                    throw new \\RuntimeException('Model not found!');\n                }\n            } else {\n                $this->loadFromRs($results->current());\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading model #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load model from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    protected function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = (int)$rs->$pk;\n\n        $callback = function ($matches) {\n            return _T($matches[1]);\n        };\n        $this->name = preg_replace_callback(\n            '/_T\\(\"([^\\\"]+)\"\\)/',\n            $callback,\n            $rs->model_name\n        );\n\n        $this->title = $rs->model_title;\n        $this->subtitle = $rs->model_subtitle;\n        $this->header = $rs->model_header;\n        $this->footer = $rs->model_footer;\n        $this->body = $rs->model_body;\n        $this->styles .= $rs->model_styles;\n\n        if ($this->id > self::MAIN_MODEL) {\n            //FIXME: for now, parent will always be a PdfMain\n            $this->parent = new PdfMain(\n                $this->zdb,\n                $this->preferences,\n                (int)$rs->model_parent\n            );\n        }\n    }\n\n    /**\n     * Store model in database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        $title = $this->title;\n        if ($title === null || trim($title) === '') {\n            $title = new Expression('NULL');\n        }\n\n        $subtitle = $this->subtitle;\n        if ($subtitle === null || trim($subtitle) === '') {\n            $subtitle = new Expression('NULL');\n        }\n\n        $data = array(\n            'model_header'      => $this->header,\n            'model_footer'      => $this->footer,\n            'model_type'        => $this->type,\n            'model_title'       => $title,\n            'model_subtitle'    => $subtitle,\n            'model_body'        => $this->body,\n            'model_styles'      => $this->styles\n        );\n\n        try {\n            if ($this->id !== null) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($data)->where(\n                    self::PK . '=' . $this->id\n                );\n                $this->zdb->execute($update);\n            } else {\n                $data['model_name'] = $this->name;\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $this->zdb->execute($insert);\n                if (!($add->count() > 0)) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing model: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get object class for specified type\n     *\n     * @param int $type Type\n     *\n     * @return string\n     */\n    public static function getTypeClass(int $type)\n    {\n        $class = null;\n        switch ($type) {\n            case self::INVOICE_MODEL:\n                $class = 'PdfInvoice';\n                break;\n            case self::RECEIPT_MODEL:\n                $class = 'PdfReceipt';\n                break;\n            case self::ADHESION_FORM_MODEL:\n                $class = 'PdfAdhesionFormModel';\n                break;\n            default:\n                $class = 'PdfMain';\n                break;\n        }\n        $class = 'Galette\\\\Entity\\\\' . $class;\n        return $class;\n    }\n\n    /**\n     * Check length\n     *\n     * @param string  $value The value\n     * @param int     $chars Length\n     * @param string  $field Field name\n     * @param boolean $empty Can value be empty\n     *\n     * @return void\n     */\n    protected function checkChars($value, $chars, $field, $empty = false)\n    {\n        if ($value !== null && trim($value) !== '') {\n            if (mb_strlen($value) > $chars) {\n                throw new \\LengthException(\n                    str_replace(\n                        array('%field', '%chars'),\n                        array($field, $chars),\n                        _T(\"%field should be less than %chars characters long.\")\n                    )\n                );\n            }\n        } else {\n            if ($empty === false) {\n                throw new \\UnexpectedValueException(\n                    str_replace(\n                        '%field',\n                        $field,\n                        _T(\"%field should not be empty!\")\n                    )\n                );\n            }\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'name':\n            case 'id':\n            case 'header':\n            case 'footer':\n            case 'body':\n            case 'title':\n            case 'subtitle':\n            case 'type':\n            case 'styles':\n            case 'patterns':\n            case 'replaces':\n                return $this->$name;\n                break;\n            case 'hstyles':\n                $value = null;\n\n                //get header and footer from parent if not defined in current model\n                if (\n                    $this->id > self::MAIN_MODEL\n                    && $this->parent !== null\n                ) {\n                    $value = $this->parent->styles;\n                }\n\n                $value .= $this->styles;\n                return $value;\n                break;\n            case 'hheader':\n            case 'hfooter':\n            case 'htitle':\n            case 'hsubtitle':\n            case 'hbody':\n                $pname = substr($name, 1);\n                $prop_value = $this->$pname ?? '';\n\n                //get header and footer from parent if not defined in current model\n                if (\n                    $this->id > self::MAIN_MODEL\n                    && $this->parent !== null\n                    && ($pname === 'footer'\n                    || $pname === 'header')\n                    && trim($prop_value) === ''\n                ) {\n                    $prop_value = $this->parent->$pname;\n                }\n\n                $value = $this->proceedReplacements($prop_value);\n                return $value;\n                break;\n            default:\n                Analog::log(\n                    'Unable to get PdfModel property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'type':\n                if (\n                    $value === self::MAIN_MODEL\n                    || $value === self::INVOICE_MODEL\n                    || $value === self::RECEIPT_MODEL\n                    || $value === self::ADHESION_FORM_MODEL\n                ) {\n                    $this->$name = $value;\n                } else {\n                    throw new \\UnexpectedValueException(\n                        str_replace(\n                            '%type',\n                            $value,\n                            _T(\"Unknown type %type!\")\n                        )\n                    );\n                }\n                break;\n            case 'name':\n                try {\n                    $this->checkChars($value, 50, _T(\"Name\"));\n                    $this->$name = $value;\n                } catch (Throwable $e) {\n                    throw $e;\n                }\n                break;\n            case 'title':\n            case 'subtitle':\n                if ($name == 'title') {\n                    $field = _T(\"Title\");\n                } else {\n                    $field = _T(\"Subtitle\");\n                }\n                try {\n                    $this->checkChars($value, 100, $field, true);\n                    $this->$name = $value;\n                } catch (Throwable $e) {\n                    throw $e;\n                }\n                break;\n            case 'header':\n            case 'footer':\n            case 'body':\n                if ($value === null || trim($value) === '') {\n                    if ($name !== 'body' && get_class($this) === 'PdfMain') {\n                        throw new \\UnexpectedValueException(\n                            _T(\"header and footer should not be empty!\")\n                        );\n                    } elseif ($name === 'body' && get_class($this) !== 'PdfMain') {\n                        throw new \\UnexpectedValueException(\n                            _T(\"body should not be empty!\")\n                        );\n                    }\n                }\n\n                $this->$name = $value;\n                break;\n            case 'styles':\n                $this->styles = $value;\n                break;\n            default:\n                Analog::log(\n                    'Unable to set PdfModel property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Reminders\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-11\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Features\\Replacements;\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\History;\n\n/**\n * Reminders\n *\n * @category  Entity\n * @name      Reminder\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-11\n */\n\nclass Reminder\n{\n    use Replacements;\n\n    public const TABLE = 'reminders';\n    public const PK = 'reminder_id';\n\n    private $id;\n    private $type;\n    private $dest;\n    private $date;\n    /** @var boolean */\n    private $success = false;\n    /** @var boolean */\n    private $nomail;\n    private $comment;\n    private $msg;\n\n    public const IMPENDING = 1;\n    public const LATE = 2;\n\n    /**\n     * Main constructor\n     *\n     * @param mixed $args Arguments\n     */\n    public function __construct($args = null)\n    {\n        if ($args !== null) {\n            if (is_int($args)) {\n                $this->load($args);\n            } elseif (is_object($args)) {\n                $this->loadFromRs($args);\n            } else {\n                Analog::log(\n                    __METHOD__ . ': unknonw arg',\n                    Analog::WARNING\n                );\n            }\n        }\n    }\n\n    /**\n     * Load a reminder from its id\n     *\n     * @param int $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        global $zdb;\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1)\n                ->where(self::PK . ' = ' . $id);\n\n            $results = $zdb->execute($select);\n            $this->loadFromRs($results->current());\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading reminder #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load reminder from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        global $zdb;\n\n        try {\n            $pk = self::PK;\n            $this->id = $rs->$pk;\n            $this->type = $rs->reminder_type;\n            $this->dest = new Adherent($zdb, (int)$rs->reminder_dest);\n            $this->date = $rs->reminder_date;\n            $this->success = $rs->reminder_success;\n            $this->nomail = $rs->reminder_nomail;\n            $this->comment = $rs->reminder_comment;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ': incorrect ResultSet. Error: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store reminder in database and history\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    private function store($zdb)\n    {\n        $now = new \\DateTime();\n        $data = array(\n            'reminder_type'     => $this->type,\n            'reminder_dest'     => $this->dest->id,\n            'reminder_date'     => $now->format('Y-m-d'),\n            'reminder_success'  => ($this->success) ?\n                true :\n                ($zdb->isPostgres() ? 'false' : 0),\n            'reminder_nomail'   => ($this->nomail) ?\n                true :\n                ($zdb->isPostgres() ? 'false' : 0)\n        );\n        try {\n            $insert = $zdb->insert(self::TABLE);\n            $insert->values($data);\n\n            $add = $zdb->execute($insert);\n            if (!($add->count() > 0)) {\n                Analog::log('Reminder not stored!', Analog::ERROR);\n                return false;\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing reminder: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Was reminder sent successfully?\n     *\n     * @return boolean\n     */\n    public function isSuccess()\n    {\n        return $this->success;\n    }\n\n    /**\n     * Did member had an email when reminder was sent?\n     *\n     * @return boolean\n     */\n    public function hasMail()\n    {\n        return !$this->nomail;\n    }\n\n    /**\n     * Send the reminder\n     *\n     * @param Texts   $texts Text object\n     * @param History $hist  History\n     * @param Db      $zdb   Database instance\n     *\n     * @return boolean\n     */\n    public function send(Texts $texts, History $hist, Db $zdb)\n    {\n        global $preferences;\n\n        $this->success = false;\n\n        $type_name = 'late';\n        if ($this->type === self::IMPENDING) {\n            $type_name = 'impending';\n        }\n\n        if ($this->hasMail()) {\n            $texts->setMember($this->dest)\n                ->setNoContribution();\n\n            $texts->getTexts(\n                $type_name . 'duedate',\n                $this->dest->language\n            );\n\n            $mail = new GaletteMail($preferences);\n            $mail->setSubject($texts->getSubject());\n            $mail->setRecipients(\n                array(\n                    $this->dest->getEmail() => $this->dest->sname\n                )\n            );\n            $mail->setMessage($texts->getBody());\n            $sent = $mail->send();\n\n            $details = str_replace(\n                array(\n                    '%name',\n                    '%mail',\n                    '%days'\n                ),\n                array(\n                    $this->dest->sname,\n                    $this->dest->getEmail(),\n                    $this->dest->days_remaining\n                ),\n                _T(\"%name <%mail> (%days days)\")\n            );\n\n            if ($sent == GaletteMail::MAIL_SENT) {\n                $this->success = true;\n                $msg = '';\n                if ($type_name == 'late') {\n                    $msg = _T(\"Sent reminder email for late membership\");\n                } else {\n                    $msg = _T(\"Sent reminder email for impending membership\");\n                }\n                $this->msg = $details;\n                $hist->add($msg, $details);\n            } else {\n                if ($type_name == 'late') {\n                    $msg = _T(\"A problem happened while sending late membership email\");\n                } else {\n                    $msg = _T(\"A problem happened while sending impending membership email\");\n                }\n                $this->msg = $details;\n                $hist->add($msg, $details);\n            }\n        } else {\n            $this->nomail = true;\n            $str = str_replace(\n                '%membership',\n                $type_name,\n                _T(\"Unable to send %membership reminder (no email address).\")\n            );\n            $details = str_replace(\n                array(\n                    '%name',\n                    '%id',\n                    '%days'\n                ),\n                array(\n                    $this->dest->sname,\n                    $this->dest->id,\n                    $this->dest->days_remaining\n                ),\n                _T(\"%name (#%id - %days days)\")\n            );\n            $hist->add($str, $details);\n            $this->msg = $this->dest->sname;\n        }\n        //store reminder in database\n        $this->store($zdb);\n        return $this->success;\n    }\n\n    /**\n     * Retrieve message\n     *\n     * @return string\n     */\n    public function getMessage()\n    {\n        return $this->msg;\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n            case 'member_id':\n                return $this->dest->id;\n            case 'type':\n            case 'date':\n                return $this->$name;\n            default:\n                Analog::log(\n                    'Unable to get Reminder property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'type':\n                if (\n                    $value === self::IMPENDING\n                    || $value === self::LATE\n                ) {\n                    $this->type = $value;\n                } else {\n                    throw new \\UnexpectedValueException(\n                        'Unknown type!'\n                    );\n                }\n                break;\n            case 'dest':\n                if ($this->type !== null && $value instanceof Adherent) {\n                    $this->dest = $value;\n\n                    if ($value->getEmail() != '') {\n                        $this->nomail = false;\n                    }\n                } else {\n                    if (!$value instanceof Adherent) {\n                        throw new \\UnexpectedValueException(\n                            'Please provide a member object.'\n                        );\n                    } else {\n                        throw new \\UnderflowException(\n                            'Please set reminder type first.'\n                        );\n                    }\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Saved search\n *\n * PHP version 5\n *\n * Copyright \u00a9 2019-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2019-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.3dev - 2019-03-25\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Analog\\Analog;\n\n/**\n * Saved search\n *\n * @category  Entity\n * @name      SavedSearch\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2019-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.3dev - 2019-03-25\n */\n\nclass SavedSearch\n{\n    public const TABLE = 'searches';\n    public const PK = 'search_id';\n\n    private $zdb;\n    private $id;\n    private $name;\n    private $parameters = [];\n    private $author_id;\n    private $creation_date;\n    private $form;\n\n    private $login;\n    private $errors = [];\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb   Database instance\n     * @param Login $login Login instance\n     * @param mixed $args  Arguments\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n        $this->creation_date = date('Y-m-d H:i:s');\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a saved search from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where(self::PK . ' = ' . $id);\n            if ($this->login->isSuperAdmin()) {\n                $select->where(Adherent::PK . ' IS NULL');\n            } else {\n                $select->where(Adherent::PK . ' = ' . (int)$this->login->id);\n            }\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n\n            $this->loadFromRs($res);\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading saved search #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load a saved search from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->name = $rs->name;\n        $this->parameters = json_decode($rs->parameters, true);\n        $this->author_id = $rs->id_adh;\n        $this->creation_date = $rs->creation_date;\n        $this->form = $rs->form;\n    }\n\n    /**\n     * Check and set values\n     *\n     * @param array $values Values to set\n     *\n     * @return boolean\n     */\n    public function check($values)\n    {\n        $this->errors = [];\n        $mandatory = [\n            'form'  => _T('Form is mandatory!')\n        ];\n\n        foreach ($values as $key => $value) {\n            if (in_array($key, ['nbshow', 'page'])) {\n                continue;\n            }\n            if (empty($value) && isset($mandatory[$key])) {\n                $this->errors[] = $mandatory[$key];\n            }\n            $this->$key = $value;\n            unset($mandatory[$key]);\n        }\n\n        if (count($mandatory)) {\n            $this->errors = array_merge($this->errors, $mandatory);\n        }\n\n        if ($this->id === null && !$this->login->isSuperAdmin()) {\n            //set author for new searches\n            $this->author_id = $this->login->id;\n        }\n\n        return (count($this->errors) === 0);\n    }\n\n    /**\n     * Store saved search in database\n     *\n     * @return boolean|null\n     */\n    public function store()\n    {\n        $parameters = json_encode($this->parameters);\n        $data = array(\n            'name'              => $this->name,\n            'parameters'        => $parameters,\n            'id_adh'            => $this->author_id,\n            'creation_date'     => ($this->creation_date !== null ? $this->creation_date : date('Y-m-d H:i:s')),\n            'form'              => $this->form\n        );\n\n        try {\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($data);\n            $add = $this->zdb->execute($insert);\n            if (!$add->count() > 0) {\n                Analog::log('Not stored!', Analog::ERROR);\n                return false;\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing saved search: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current saved search\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        $id = (int)$this->id;\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                self::PK . ' = ' . $id\n            );\n            $this->zdb->execute($delete);\n            Analog::log(\n                'Saved search #' . $id . ' (' . $this->name\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (\\RuntimeException $re) {\n            throw $re;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete saved search ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        $forbidden = [];\n        $virtuals = ['sparameters'];\n        if (\n            in_array($name, $virtuals)\n            || !in_array($name, $forbidden)\n            && isset($this->$name)\n        ) {\n            switch ($name) {\n                case 'creation_date':\n                    if ($this->$name != '') {\n                        try {\n                            $d = new \\DateTime($this->$name);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$name . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$name;\n                        }\n                    }\n                    break;\n                case 'sparameters':\n                    include_once GALETTE_ROOT . 'includes/fields_defs/members_fields.php';\n                    $parameters = [];\n                    foreach ((array)$this->parameters as $key => $parameter) {\n                        if (isset($members_fields[$key])) {\n                            $key = $members_fields[$key]['label'];\n                        }\n                        if (is_array($parameter) || is_object($parameter)) {\n                            $parameter = json_encode($parameter);\n                        }\n                        $parameters[$key] = $parameter;\n                    }\n                    return $parameters;\n                    break;\n                default:\n                    if (!property_exists($this, $name)) {\n                        Analog::log(\n                            \"Unknown property '$name'\",\n                            Analog::WARNING\n                        );\n                        return null;\n                    } else {\n                        return $this->$name;\n                    }\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'form':\n                if (!in_array($value, $this->getKnownForms())) {\n                    $this->errors[] = str_replace('%form', $value, _T(\"Unknown form %form!\"));\n                }\n                $this->form = $value;\n                break;\n            case 'parameters':\n                if (!is_array($value)) {\n                    Analog::log(\n                        'Search parameters must be an array!',\n                        Analog::ERROR\n                    );\n                }\n                $this->parameters = $value;\n                break;\n            case 'name':\n                if (trim($value) === '') {\n                    $this->errors[] = _T(\"Name cannot be empty!\");\n                }\n                $this->name = $value;\n                break;\n            case 'author_id':\n                $this->author_id = (int)$value;\n                break;\n            default:\n                Analog::log(\n                    str_replace(\n                        ['%class', '%property'],\n                        [self::class, $name],\n                        'Unable to set %class property %property'\n                    ),\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Get known forms\n     *\n     * @return array\n     */\n    public function getKnownForms()\n    {\n        return [\n            'Adherent'\n        ];\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Social networks/Contacts\n *\n * PHP version 5\n *\n * Copyright \u00a9 2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.6dev - 2021-10-23\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Features\\I18n;\nuse Laminas\\Db\\ResultSet\\ResultSet;\nuse Laminas\\Db\\Sql\\Expression;\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Analog\\Analog;\n\n/**\n * Social networks/Contacts\n *\n * @category  Entity\n * @name      Social\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.6dev - 2021-10-23\n */\n\nclass Social\n{\n    use I18n;\n\n    public const TABLE = 'socials';\n    public const PK = 'id_social';\n\n    public const MASTODON = 'mastodon';\n    public const TWITTER = 'twitter';\n    public const FACEBOOK = 'facebook';\n    public const LINKEDIN = 'linkedin';\n    public const VIADEO = 'viadeo';\n    public const JABBER = 'jabber';\n    public const ICQ = 'icq';\n    public const WEBSITE = 'website';\n    public const BLOG = 'blog';\n\n    /** @var Db */\n    private $zdb;\n    /** @var int */\n    private $id;\n    /** @var string */\n    private $type;\n    /** @var string */\n    private $url;\n    /** @var int */\n    private $id_adh;\n    /** @var Adherent */\n    private $member;\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a social from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load(int $id): void\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where(self::PK . ' = ' . $id);\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n            $this->loadFromRs($res);\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading social #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Get socials for a member\n     *\n     * @param int|null    $id_adh Member id\n     * @param string|null $type   Type to retrieve\n     *\n     * @return array\n     *\n     * @throws Throwable\n     */\n    public static function getListForMember(int $id_adh = null, string $type = null): array\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n\n            if ($id_adh === null) {\n                $select->where(Adherent::PK . ' IS NULL');\n            } else {\n                $select->where([Adherent::PK => $id_adh]);\n            }\n\n            if ($type !== null) {\n                $select->where(['type' => $type]);\n            }\n\n            $select->order(self::PK);\n\n            $results = $zdb->execute($select);\n            $socials = [];\n            foreach ($results as $r) {\n                $socials[$r->{self::PK}] = new Social($zdb, $r);\n            }\n            return $socials;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading socials for member #' . $id_adh . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load social from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $this->id = $rs->{self::PK};\n        $this->setLinkedMember((int)$rs->{Adherent::PK});\n        $this->type = $rs->type;\n        $this->url = $rs->url;\n    }\n\n    /**\n     * Store social in database\n     *\n     * @return boolean\n     */\n    public function store(): bool\n    {\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set(['url' => $this->url])->where(\n                    self::PK . '=' . $this->id\n                );\n                $this->zdb->execute($update);\n            } else {\n                $insert = $this->zdb->insert(self::TABLE);\n                $id_adh = $this->{Adherent::PK} > 0 ? $this->{Adherent::PK} : new Expression('NULL');\n                $insert->values([\n                    'type'          => $this->type,\n                    'url'           => $this->url,\n                    Adherent::PK    => $id_adh\n                ]);\n                $add = $this->zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n                if (!in_array($this->type, $this->getSystemTypes(false))) {\n                    $this->addTranslation($this->type);\n                }\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing social: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current social\n     *\n     * @param array|null $ids IDs to remove, default to current id\n     *\n     * @return boolean\n     */\n    public function remove(array $ids = null): bool\n    {\n        if ($ids == null) {\n            $ids[] = $this->id;\n        }\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $ids]);\n            $this->zdb->execute($delete);\n            Analog::log(\n                'Social #' . implode(', #', $ids)  . ' deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete social #' . implode(', #', $ids) . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get(string $name)\n    {\n        return $this->$name;\n    }\n\n    /**\n     * Display URL the best way\n     *\n     * @return string\n     */\n    public function displayUrl(): string\n    {\n        if (isValidWebUrl($this->url)) {\n            return sprintf('<a href=\"%1$s\">%1$s</a>', $this->url);\n        }\n\n        if (GaletteMail::isValidEmail($this->url)) {\n            return sprintf('<a href=\"mailto:%1$s\">%1$s</a>', $this->url);\n        }\n\n        return $this->url;\n    }\n\n    /**\n     * Set type\n     *\n     * @param string $type Type\n     *\n     * @return $this\n     */\n    public function setType(string $type): self\n    {\n        $this->type = $type;\n        return $this;\n    }\n\n    /**\n     * Set linked member\n     *\n     * @param int|null $id Member id\n     *\n     * @return $this\n     */\n    public function setLinkedMember(int $id = null): self\n    {\n        $this->{Adherent::PK} = $id;\n        if ($this->{Adherent::PK} > 0) {\n            $this->member = new Adherent($this->zdb, $this->{Adherent::PK});\n        }\n        return $this;\n    }\n\n    /**\n     * Set URL\n     *\n     * @param string $url Value to set\n     *\n     * @return $this\n     */\n    public function setUrl(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    /**\n     * Get system social types\n     *\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return array\n     */\n    public function getSystemTypes(bool $translated = true): array\n    {\n        if ($translated) {\n            $systypes = [\n                self::MASTODON => _T('Mastodon'),\n                self::TWITTER => _T('Twitter'),\n                self::FACEBOOK => _T('Facebook'),\n                self::LINKEDIN => _T('LinkedIn'),\n                self::VIADEO => _T('Viadeo'),\n                self::JABBER => _T('Jabber'),\n                self::ICQ => _T('ICQ'),\n                self::WEBSITE => _T('Website'),\n                self::BLOG => _T('Blog')\n            ];\n        } else {\n            $systypes = [\n                self::MASTODON => 'mastodon',\n                self::TWITTER => 'twitter',\n                self::FACEBOOK => 'facebook',\n                self::LINKEDIN => 'linkedin',\n                self::VIADEO => 'viadeo',\n                self::JABBER => 'jabber',\n                self::ICQ => 'icq',\n                self::WEBSITE => 'website',\n                self::BLOG => 'blog'\n            ];\n        }\n        return $systypes;\n    }\n\n    /**\n     * Get system social types\n     *\n     * @param string  $type       Social type\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return string\n     */\n    public function getSystemType(string $type, bool $translated = true): string\n    {\n        return $this->getSystemTypes($translated)[$type] ?? _T($type);\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Title\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.4dev - 2013-01-27\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\n\n/**\n * Title\n *\n * @category  Entity\n * @name      Title\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-03-04\n */\n\nclass Title\n{\n    public const TABLE = 'titles';\n    public const PK = 'id_title';\n\n    private $id;\n    private $short;\n    private $long;\n\n    public const MR = 1;\n    public const MRS = 2;\n    public const MISS = 3;\n\n    /**\n     * Main constructor\n     *\n     * @param mixed $args Arguments\n     */\n    public function __construct($args = null)\n    {\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a title from its identifier\n     *\n     * @param int $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        global $zdb;\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1)->where(self::PK . ' = ' . $id);\n\n            $results = $zdb->execute($select);\n            $res = $results->current();\n\n            $this->id = $id;\n            $this->short = $res->short_label;\n            $this->long = $res->long_label;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading title #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load title from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->short = $rs->short_label;\n        if ($rs->long_label === 'NULL') {\n            //mysql's null...\n            $this->long = null;\n        } else {\n            $this->long = $rs->long_label;\n        }\n    }\n\n    /**\n     * Store title in database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function store($zdb)\n    {\n        $data = array(\n            'short_label'   => $this->short,\n            'long_label'    => $this->long\n        );\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                $update = $zdb->update(self::TABLE);\n                $update->set($data)->where(\n                    self::PK . '=' . $this->id\n                );\n                $zdb->execute($update);\n            } else {\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $zdb->getLastGeneratedValue($this);\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing title: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current title\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function remove($zdb)\n    {\n        $id = (int)$this->id;\n        if ($id === self::MR || $id === self::MRS) {\n            throw new \\RuntimeException(_T(\"You cannot delete Mr. or Mrs. titles!\"));\n        }\n\n        try {\n            $delete = $zdb->delete(self::TABLE);\n            $delete->where(\n                self::PK . ' = ' . $id\n            );\n            $zdb->execute($delete);\n            Analog::log(\n                'Title #' . $id . ' (' . $this->short\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (\\RuntimeException $re) {\n            throw $re;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete title ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'id':\n                return $this->$name;\n                break;\n            case 'short':\n            case 'long':\n                if (\n                    $name === 'long'\n                    && ($this->long == null || trim($this->long) === '')\n                ) {\n                    $name = 'short';\n                }\n                return $this->$name;\n                break;\n            case 'tshort':\n            case 'tlong':\n                $rname = null;\n                if ($name === 'tshort') {\n                    $rname = 'short';\n                } else {\n                    if ($this->long !== null && trim($this->long) !== '') {\n                        $rname = 'long';\n                    } else {\n                        //switch back to short version if long does not exists\n                        $rname = 'short';\n                    }\n                }\n                if (isset($lang) && isset($lang[$this->$rname])) {\n                    return _T($this->$rname);\n                } else {\n                    return $this->$rname;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to get Title property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'short':\n            case 'long':\n                if (trim($value) === '') {\n                    Analog::log(\n                        'Trying to set empty value for title' . $name,\n                        Analog::WARNING\n                    );\n                } else {\n                    $this->$name = $value;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Transaction class for galette\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-07-31\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Repository\\Contributions;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\History;\nuse Galette\\Core\\Login;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Transaction class for galette\n *\n * @category  Entity\n * @name      Transaction\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n *\n * @property integer $id\n * @property date $date\n * @property integer $amount\n * @property string $description\n * @property integer $member\n */\nclass Transaction\n{\n    use Dynamics;\n\n    public const TABLE = 'transactions';\n    public const PK = 'trans_id';\n\n    private $_id;\n    private $_date;\n    private $_amount;\n    private $_description;\n    private $_member;\n\n    //fields list and their translation\n    private $_fields;\n\n    private $zdb;\n    private $login;\n\n    private $errors;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                 $zdb   Database instance\n     * @param Login              $login Login instance\n     * @param null|int|ResultSet $args  Either a ResultSet row or its id for to load\n     *                                  a specific transaction, or null to just\n     *                                  instantiate object\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n\n        /*\n         * Fields configuration. Each field is an array and must reflect:\n         * array(\n         *   (string)label,\n         *   (string) propname\n         * )\n         *\n         * I'd prefer a static private variable for this...\n         * But call to the _T function does not seem to be allowed there :/\n         */\n        $this->_fields = array(\n            self::PK            => array(\n                'label'    => null, //not a field in the form\n                'propname' => 'id'\n            ),\n            'trans_date'          => array(\n                'label'    => _T(\"Date:\"), //not a field in the form\n                'propname' => 'date'\n            ),\n            'trans_amount'       => array(\n                'label'    => _T(\"Amount:\"),\n                'propname' => 'amount'\n            ),\n            'trans_desc'          => array(\n                'label'    => _T(\"Description:\"),\n                'propname' => 'description'\n            ),\n            Adherent::PK          => array(\n                'label'    => _T(\"Originator:\"),\n                'propname' => 'member'\n            )\n        );\n        if ($args == null || is_int($args)) {\n            $this->_date = date(\"Y-m-d\");\n\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Loads a transaction from its id\n     *\n     * @param int $id the identifier for the transaction to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 't');\n            $select->where(self::PK . ' = ' . $id);\n            $select->join(\n                array('a' => PREFIX_DB . Adherent::TABLE),\n                't.' . Adherent::PK . '=a.' . Adherent::PK,\n                array()\n            );\n\n            //restrict query on current member id if he's not admin nor staff member\n            if (!$this->login->isAdmin() && !$this->login->isStaff() && !$this->login->isGroupManager()) {\n                if (!$this->login->isLogged()) {\n                    Analog::log(\n                        'Non-logged-in users cannot load transaction id `' . $id,\n                        Analog::ERROR\n                    );\n                    return false;\n                }\n                $select->where\n                    ->nest()\n                        ->equalTo('a.' . Adherent::PK, $this->login->id)\n                        ->or\n                        ->equalTo('a.parent_id', $this->login->id)\n                    ->unnest()\n                    ->and\n                    ->equalTo('t.' . self::PK, $id)\n                ;\n            } else {\n                $select->where->equalTo(self::PK, $id);\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $this->loadFromRS($result);\n                return true;\n            } else {\n                Analog::log(\n                    'Transaction id `' . $id . '` does not exists',\n                    Analog::WARNING\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load transaction form id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove transaction (and all associated contributions) from database\n     *\n     * @param History $hist        History\n     * @param boolean $transaction Activate transaction mode (defaults to true)\n     *\n     * @return boolean\n     */\n    public function remove(History $hist, $transaction = true)\n    {\n        global $emitter;\n\n        try {\n            if ($transaction) {\n                $this->zdb->connection->beginTransaction();\n            }\n\n            //remove associated contributions if needeed\n            if ($this->getDispatchedAmount() > 0) {\n                $c = new Contributions($this->zdb, $this->login);\n                $clist = $c->getListFromTransaction($this->_id);\n                $cids = array();\n                foreach ($clist as $cid) {\n                    $cids[] = $cid->id;\n                }\n                $rem = $c->remove($cids, $hist, false);\n            }\n\n            //remove transaction itself\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                self::PK . ' = ' . $this->_id\n            );\n            $del = $this->zdb->execute($delete);\n            if ($del->count() > 0) {\n                $this->dynamicsRemove(true);\n            } else {\n                Analog::log(\n                    'Transaction has not been removed!',\n                    Analog::WARNING\n                );\n                return false;\n            }\n\n            if ($transaction) {\n                $this->zdb->connection->commit();\n            }\n\n            $emitter->emit('transaction.remove', $this);\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred trying to remove transaction #' .\n                $this->_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = self::PK;\n        $this->_id = $r->$pk;\n        $this->_date = $r->trans_date;\n        $this->_amount = $r->trans_amount;\n        $this->_description = $r->trans_desc;\n        $adhpk = Adherent::PK;\n        $this->_member = (int)$r->$adhpk;\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        $this->errors = array();\n\n        $fields = array_keys($this->_fields);\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->_fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = trim($values[$key]);\n            } else {\n                $value = '';\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // now, check validity\n                if ($value != '') {\n                    switch ($key) {\n                        // dates\n                        case 'trans_date':\n                            try {\n                                $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                                if ($d === false) {\n                                    throw new \\Exception('Incorrect format');\n                                }\n                                $this->$prop = $d->format('Y-m-d');\n                            } catch (Throwable $e) {\n                                Analog::log(\n                                    'Wrong date format. field: ' . $key .\n                                    ', value: ' . $value . ', expected fmt: ' .\n                                    __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                                    Analog::INFO\n                                );\n                                $this->errors[] = str_replace(\n                                    array(\n                                        '%date_format',\n                                        '%field'\n                                    ),\n                                    array(\n                                        __(\"Y-m-d\"),\n                                        $this->getFieldLabel($key)\n                                    ),\n                                    _T(\"- Wrong date format (%date_format) for %field!\")\n                                );\n                            }\n                            break;\n                        case Adherent::PK:\n                            $this->_member = (int)$value;\n                            break;\n                        case 'trans_amount':\n                            $this->_amount = $value;\n                            $value = strtr($value, ',', '.');\n                            if (!is_numeric($value)) {\n                                $this->errors[] = _T(\"- The amount must be an integer!\");\n                            }\n                            break;\n                        case 'trans_desc':\n                            /** TODO: retrieve field length from database and check that */\n                            $this->_description = $value;\n                            if (mb_strlen($value) > 150) {\n                                $this->errors[] = _T(\"- Transaction description must be 150 characters long maximum.\");\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            if ($val === 1) {\n                $prop = '_' . $this->_fields[$key]['propname'];\n                if (!isset($disabled[$key]) && !isset($this->$prop)) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        if ($this->_id != '') {\n            $dispatched = $this->getDispatchedAmount();\n            if ($dispatched > $this->_amount) {\n                $this->errors[] = _T(\"- Sum of all contributions exceed corresponding transaction amount.\");\n            }\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a transaction' .\n                print_r($this->errors, true),\n                Analog::DEBUG\n            );\n            return $this->errors;\n        } else {\n            Analog::log(\n                'Transaction checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Store the transaction\n     *\n     * @param History $hist History\n     *\n     * @return boolean\n     */\n    public function store(History $hist)\n    {\n        global $emitter;\n\n        $event = null;\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array();\n            $fields = $this->getDbFields($this->zdb);\n            /** FIXME: quote? */\n            foreach ($fields as $field) {\n                $prop = '_' . $this->_fields[$field]['propname'];\n                $values[$field] = $this->$prop;\n            }\n\n            $success = false;\n            if (!isset($this->_id) || $this->_id == '') {\n                //we're inserting a new transaction\n                unset($values[self::PK]);\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Transaction added\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                    $success = true;\n                    $event = 'transaction.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new transaction.\"));\n                    throw new \\RuntimeException(\n                        'An error occurred inserting new transaction!'\n                    );\n                }\n            } else {\n                //we're editing an existing transaction\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where(\n                    self::PK . '=' . $this->_id\n                );\n                $edit = $this->zdb->execute($update);\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Transaction updated\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                }\n                $success = true;\n                $event = 'transaction.edit';\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore(true);\n            }\n\n            $this->zdb->connection->commit();\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve amount that has already been dispatched into contributions\n     *\n     * @return double\n     */\n    public function getDispatchedAmount(): float\n    {\n        if (empty($this->_id)) {\n            return (double)0;\n        }\n\n        try {\n            $select = $this->zdb->select(Contribution::TABLE);\n            $select->columns(\n                array(\n                    'sum' => new Expression('SUM(montant_cotis)')\n                )\n            )->where(self::PK . ' = ' . $this->_id);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dispatched_amount = $result->sum;\n            return (double)$dispatched_amount;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred retrieving dispatched amounts | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve amount that has not yet been dispatched into contributions\n     *\n     * @return double\n     */\n    public function getMissingAmount()\n    {\n        if (empty($this->_id)) {\n            return (double)$this->amount;\n        }\n\n        try {\n            $select = $this->zdb->select(Contribution::TABLE);\n            $select->columns(\n                array(\n                    'sum' => new Expression('SUM(montant_cotis)')\n                )\n            )->where(self::PK . ' = ' . $this->_id);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dispatched_amount = $result->sum;\n            return (double)$this->_amount - (double)$dispatched_amount;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred retrieving missing amounts | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Get the relevant CSS class for current transaction\n     *\n     * @return string current transaction row class\n     */\n    public function getRowClass()\n    {\n        return ($this->getMissingAmount() == 0) ?\n            'transaction-normal' : 'transaction-uncomplete';\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrive\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array();\n\n        $rname = '_' . $name;\n        if (!in_array($name, $forbidden) && property_exists($this, $rname)) {\n            switch ($name) {\n                case 'date':\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$rname;\n                        }\n                    }\n                    break;\n                case 'id':\n                    if ($this->$rname !== null) {\n                        return (int)$this->$rname;\n                    }\n                    return null;\n                case 'amount':\n                    if ($this->$rname !== null) {\n                        return (double)$this->$rname;\n                    }\n                    return null;\n                default:\n                    return $this->$rname;\n            }\n        } else {\n            Analog::log(\n                sprintf(\n                    'Property %1$s does not exists for transaction',\n                    $name\n                ),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    public function getFieldLabel($field)\n    {\n        $label = $this->_fields[$field]['label'];\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label, ':'));\n        return $label;\n    }\n\n    /**\n     * Handle files (dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a transaction files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Can current logged-in user display transaction\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        //non-logged-in members cannot show contributions\n        if (!$login->isLogged()) {\n            return false;\n        }\n\n        //admin and staff users can edit, as well as member itself\n        if (!$this->id || $this->id && $login->id == $this->_member || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can see their children transactions\n        $parent = new Adherent($this->zdb);\n        $parent\n            ->disableAllDeps()\n            ->enableDep('children')\n            ->load($this->login->id);\n        if ($parent->hasChildren()) {\n            foreach ($parent->children as $child) {\n                if ($child->id === $this->_member) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return false;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Groups entity\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2014 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-10-25\n */\n\nnamespace Galette\\Repository;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Predicate\\PredicateSet;\nuse Galette\\Entity\\Group;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Core\\Login;\nuse Galette\\Core\\Db;\n\n/**\n * Groups entitiy\n *\n * @category  Repository\n * @name      Groups\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-10-25\n */\nclass Groups\n{\n\n    /**\n     * Constructor\n     *\n     * @param Db    $zdb   Database instance\n     * @param Login $login Login instance\n     */\n    public function __construct(Db $zdb, Login $login)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n    }\n\n    /**\n     * Get simple groups list (only id and names)\n     *\n     * @param boolean $as_groups Retrieve Group[]\n     *\n     * @return array\n     */\n    public static function getSimpleList($as_groups = false)\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(Group::TABLE);\n            if ($as_groups === false) {\n                $select->columns(\n                    array(Group::PK, 'group_name')\n                );\n            }\n            $groups = array();\n            $gpk = Group::PK;\n\n            $results = $zdb->execute($select);\n\n            foreach ($results as $row) {\n                if ($as_groups === false) {\n                    $groups[$row->$gpk] = $row->group_name;\n                } else {\n                    $groups[$row->$gpk] = new Group($row);\n                }\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups (simple) | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get groups list\n     *\n     * @param boolean $full Return full list or root only\n     * @param int     $id   Group ID to retrieve\n     *\n     * @return Group[]\n     */\n    public function getList($full = true, $id = null)\n    {\n        try {\n            $select = $this->zdb->select(Group::TABLE, 'a');\n            $select->join(\n                array('b' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                'a.' . Group::PK . '=b.' . Group::PK,\n                array('members' => new Expression('count(b.' . Group::PK . ')')),\n                $select::JOIN_LEFT\n            );\n\n            if (!$this->login->isAdmin() && !$this->login->isStaff() && $full === true) {\n                $select->join(\n                    array('c' => PREFIX_DB . Group::GROUPSMANAGERS_TABLE),\n                    'a.' . Group::PK . '=c.' . Group::PK,\n                    array()\n                )->where('c.' . Adherent::PK . ' = ' . $this->login->id);\n            }\n\n            if ($full !== true) {\n                $select->where('parent_group IS NULL');\n            }\n\n            if ($id !== null) {\n                $select->where(\n                    array(\n                        'a.' . Group::PK => $id,\n                        'a.parent_group' => $id\n                    ),\n                    PredicateSet::OP_OR\n                );\n            }\n\n            $select->group('a.' . Group::PK)\n                ->group('a.group_name')\n                ->group('a.creation_date')\n                ->group('a.parent_group')\n                ->order('a.group_name ASC');\n\n            $groups = array();\n\n            $results = $this->zdb->execute($select);\n\n            foreach ($results as $row) {\n                $group = new Group($row);\n                $group->setLogin($this->login);\n                $groups[$group->getFullName()] = $group;\n            }\n            if ($full) { // Order by tree name instead of name\n                ksort($groups);\n                Analog::log(\n                    'Groups SORTED: ' . print_r(array_keys($groups), true),\n                    Analog::DEBUG\n                );\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads managed groups for specific member\n     *\n     * @param int     $id       Memebr id\n     * @param boolean $as_group Retrieve Group[] or int[]\n     *\n     * @return array\n     */\n    public static function loadManagedGroups($id, $as_group = true)\n    {\n        return self::loadGroups($id, true, $as_group);\n    }\n\n    /**\n     * Loads groups for specific member\n     *\n     * @param int     $id       Member id\n     * @param boolean $managed  Retrieve managed groups (defaults to false)\n     * @param boolean $as_group Retrieve Group[] or int[]\n     *\n     * @return array\n     */\n    public static function loadGroups($id, $managed = false, $as_group = true)\n    {\n        global $zdb;\n        try {\n            $join_table = ($managed) ?\n                Group::GROUPSMANAGERS_TABLE : Group::GROUPSUSERS_TABLE;\n\n            $select = $zdb->select(Group::TABLE, 'a');\n            $select->join(\n                array(\n                    'b' => PREFIX_DB . $join_table\n                ),\n                'a.' . Group::PK . '=b.' . Group::PK,\n                array()\n            )->where(array('b.' . Adherent::PK => $id));\n\n            $results = $zdb->execute($select);\n\n            $groups = array();\n            foreach ($results as $r) {\n                if ($as_group === true) {\n                    $groups[] = new Group($r);\n                } else {\n                    $gpk = Group::PK;\n                    $groups[] = $r->$gpk;\n                }\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member groups for id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Add a member to specified groups\n     *\n     * @param Adherent $adh         Member\n     * @param array    $groups      Groups Groups list. Each entry must contain\n     *                              the group id, name each value separated\n     *                              by a pipe.\n     * @param boolean  $manager     Add member as manager, defaults to false\n     * @param boolean  $transaction Does a SQL transaction already exists? Defaults\n     *                              to false.\n     *\n     * @return boolean\n     */\n    public static function addMemberToGroups($adh, $groups, $manager = false, $transaction = false)\n    {\n        global $zdb;\n        try {\n            if ($transaction === false) {\n                $zdb->connection->beginTransaction();\n            }\n\n            $table = null;\n            if ($manager === true) {\n                $table = Group::GROUPSMANAGERS_TABLE;\n            } else {\n                $table = Group::GROUPSUSERS_TABLE;\n            }\n\n            //first, remove current groups members\n            $delete = $zdb->delete($table);\n            $delete->where(\n                Adherent::PK . ' = ' . $adh->id\n            );\n            $zdb->execute($delete);\n\n            $msg = null;\n            if ($manager === true) {\n                $msg = 'Member `' . $adh->sname . '` has been detached from groups he manages';\n            } else {\n                $msg = 'Member `' . $adh->sname . '` has been detached of its groups';\n            }\n            Analog::log(\n                $msg . ', we can now store new ones.',\n                Analog::INFO\n            );\n\n            //we proceed, if groups has been specified\n            if (is_array($groups)) {\n                $insert = $zdb->insert($table);\n                $insert->values(\n                    array(\n                        Group::PK       => ':group',\n                        Adherent::PK    => ':adh'\n                    )\n                );\n                $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n                foreach ($groups as $group) {\n                    list($gid, $gname) = explode('|', $group);\n\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $gid,\n                            'adh'   => $adh->id\n                        )\n                    );\n\n                    if ($result) {\n                        $msg = 'Member `' . $adh->sname . '` attached to group `' .\n                            $gname . '` (' . $gid . ')';\n                        if ($manager === true) {\n                            $msg .= ' as a manager';\n                        }\n                        Analog::log(\n                            $msg,\n                            Analog::DEBUG\n                        );\n                    } else {\n                        $msg = 'Unable to attach member `' .\n                            $adh->sname . '` (' . $adh->id . ') to group `' .\n                            $gname . '` (' . $gid . ').';\n                        if ($manager === true) {\n                            $msg .= ' as a manager';\n                        }\n                        Analog::log(\n                            $msg,\n                            Analog::ERROR\n                        );\n                        throw new \\Exception($msg);\n                    }\n                }\n            }\n            if ($transaction === false) {\n                //commit all changes\n                $zdb->connection->commit();\n            }\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction === false) {\n                $zdb->connection->rollBack();\n            }\n            $msg = 'Unable to add member `' . $adh->sname . '` (' . $adh->id .\n                ') to specified groups ' . print_r($groups, true);\n            if ($manager === true) {\n                $msg .= ' as a manager';\n            }\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                $msg . ' |' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove members from all their groups\n     *\n     * @param array $ids Members ids\n     *\n     * @return void\n     */\n    public static function removeMembersFromGroups(array $ids)\n    {\n        global $zdb;\n\n        try {\n            $del_qry = $zdb->delete(Group::GROUPSUSERS_TABLE);\n            $del_qry->where->in(Adherent::PK, $ids);\n            $zdb->execute($del_qry);\n\n            $del_qry = $zdb->delete(Group::GROUPSMANAGERS_TABLE);\n            $del_qry->where->in(Adherent::PK, $ids);\n            $zdb->execute($del_qry);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to remove member #' . $id . ' from his groups: ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove member from all his groups\n     *\n     * @param int $id Member's id\n     *\n     * @return void\n     */\n    public static function removeMemberFromGroups($id)\n    {\n        self::removeMembersFromGroups([$id]);\n    }\n\n    /**\n     * Check if groupname is unique\n     *\n     * @param Db     $zdb  Database instance\n     * @param string $name Requested name\n     *\n     * @return boolean\n     */\n    public static function isUnique(Db $zdb, $name)\n    {\n        try {\n            $select = $zdb->select(Group::TABLE);\n            $select->columns(\n                array('group_name')\n            )->where(array('group_name' => $name));\n            $results = $zdb->execute($select);\n            return !($results->count() > 0);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups (simple) | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get managed users id list\n     *\n     * @param array $groups List of managed groups.\n     *                      If empty, Groups::loadManagedGroups() will be called\n     *\n     * @return array|false\n     */\n    public function getManagerUsers(array $groups = [])\n    {\n        if (!$this->login->isGroupManager()) {\n            return false;\n        }\n        if (!count($groups)) {\n            $groups = self::loadManagedGroups($this->login->id, false);\n        }\n\n        $select = $this->zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            [Adherent::PK]\n        )->join(\n            array('b' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n            'a.' . Adherent::PK . '=b.' . Adherent::PK,\n            []\n        )->where->in('b.' . Group::PK, $groups);\n\n        $results = $this->zdb->execute($select);\n\n        $ids_adh = array();\n        foreach ($results as $r) {\n            $ids_adh[] = $r->id_adh;\n        }\n        return $ids_adh;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Members class\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-02-28\n */\n\nnamespace Galette\\Repository;\n\nuse Galette\\Entity\\Social;\nuse Throwable;\nuse Galette\\DynamicFields\\DynamicField;\nuse Galette\\Entity\\DynamicFieldsHandle;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Select;\nuse Laminas\\Db\\Sql\\Predicate\\PredicateSet;\nuse Laminas\\Db\\Sql\\Predicate\\Operator;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Entity\\Contribution;\nuse Galette\\Entity\\Transaction;\nuse Galette\\Entity\\Reminder;\nuse Galette\\Filters\\MembersList;\nuse Galette\\Filters\\AdvancedMembersList;\nuse Galette\\Core\\Picture;\nuse Galette\\Entity\\Group;\nuse Galette\\Repository\\Groups;\nuse Galette\\Entity\\Status;\nuse Galette\\Core\\Db;\n\n/**\n * Members class for galette\n *\n * @name Members\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\nclass Members\n{\n    public const TABLE = Adherent::TABLE;\n    public const PK = Adherent::PK;\n\n    public const ALL_ACCOUNTS = 0;\n    public const ACTIVE_ACCOUNT = 1;\n    public const INACTIVE_ACCOUNT = 2;\n\n    public const SHOW_LIST = 0;\n    public const SHOW_PUBLIC_LIST = 1;\n    public const SHOW_ARRAY_LIST = 2;\n    public const SHOW_STAFF = 3;\n    public const SHOW_MANAGED = 4;\n    public const SHOW_EXPORT = 5;\n\n    public const FILTER_NAME = 0;\n    public const FILTER_ADDRESS = 1;\n    public const FILTER_MAIL = 2;\n    public const FILTER_JOB = 3;\n    public const FILTER_INFOS = 4;\n    public const FILTER_DC_EMAIL = 5;\n    public const FILTER_W_EMAIL = 6;\n    public const FILTER_WO_EMAIL = 7;\n    public const FILTER_COMPANY_NAME = 8;\n    public const FILTER_DC_PUBINFOS = 9;\n    public const FILTER_W_PUBINFOS = 10;\n    public const FILTER_WO_PUBINFOS = 11;\n    public const FILTER_ID = 12;\n    public const FILTER_NUMBER = 13;\n\n    public const MEMBERSHIP_ALL = 0;\n    public const MEMBERSHIP_UP2DATE = 3;\n    public const MEMBERSHIP_NEARLY = 1;\n    public const MEMBERSHIP_LATE = 2;\n    public const MEMBERSHIP_NEVER = 4;\n    public const MEMBERSHIP_STAFF = 5;\n    public const MEMBERSHIP_ADMIN = 6;\n    public const MEMBERSHIP_NONE = 7;\n\n    public const ORDERBY_NAME = 'name';\n    public const ORDERBY_NICKNAME = 'nickname';\n    public const ORDERBY_STATUS = 'status';\n    public const ORDERBY_FEE_STATUS = 'fee_status';\n    public const ORDERBY_MODIFDATE = 'modif_date';\n    public const ORDERBY_ID = 'id';\n\n    public const NON_STAFF_MEMBERS = 30;\n\n    private $filters = false;\n    private $count = null;\n    private $errors = array();\n\n    /**\n     * Default constructor\n     *\n     * @param MembersList $filters Filtering\n     */\n    public function __construct($filters = null)\n    {\n        if ($filters === null) {\n            $this->filters = new MembersList();\n        } else {\n            $this->filters = $filters;\n        }\n    }\n\n    /**\n     * Get staff members list\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $limit      true to LIMIT query\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getStaffMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $limit = true\n    ) {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            $count,\n            true,\n            false,\n            $limit\n        );\n    }\n\n    /**\n     * Get managed members list (for groups managers)\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $limit      true to LIMIT query\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getManagedMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $limit = true\n    ) {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            $count,\n            false,\n            true,\n            $limit\n        );\n    }\n\n    /**\n     * Get members list\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $staff      true if we want only staff members\n     * @param boolean $managed    true if we want only managed groups\n     * @param boolean $limit      true if we want records pagination\n     * @param boolean $export     true if we are exporting\n     *\n     * @return Adherent[]|Laminas\\Db\\ResultSet\n     */\n    public function getMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $staff = false,\n        $managed = false,\n        $limit = true,\n        $export = false\n    ) {\n        global $zdb;\n\n        if ($limit === true) {\n            //force count if limit is active\n            $count = true;\n        }\n\n        try {\n            $_mode = self::SHOW_LIST;\n            if ($staff !== false) {\n                $_mode = self::SHOW_STAFF;\n            }\n            if ($managed !== false) {\n                $_mode = self::SHOW_MANAGED;\n            }\n            if ($export !== false) {\n                $_mode = self::SHOW_EXPORT;\n            }\n\n            $select = $this->buildSelect(\n                $_mode,\n                $fields,\n                false,\n                $count\n            );\n\n            //add limits to retrieve only relavant rows\n            if ($limit === true) {\n                $this->filters->setLimits($select);\n            }\n\n            $rows = $zdb->execute($select);\n            $this->filters->query = $zdb->query_string;\n\n            $members = array();\n            if ($as_members) {\n                $deps = array(\n                    'picture'   => false,\n                    'groups'    => false\n                );\n                foreach ($rows as $row) {\n                    $members[] = new Adherent($zdb, $row, $deps);\n                }\n            } else {\n                $members = $rows;\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified members\n     *\n     * @param integer|array $ids Members identifiers to delete\n     *\n     * @return boolean\n     */\n    public function removeMembers($ids)\n    {\n        global $zdb, $hist, $emitter;\n\n        $processed = array();\n        $list = array();\n        if (is_array($ids)) {\n            $list = $ids;\n        } elseif (is_numeric($ids)) {\n            $list = [(int)$ids];\n        } else {\n            return false;\n        }\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //Retrieve some information\n            $select = $zdb->select(self::TABLE);\n            $select->columns(\n                array(self::PK, 'nom_adh', 'prenom_adh', 'email_adh')\n            )->where->in(self::PK, $list);\n\n            $results = $zdb->execute($select);\n\n            $infos = null;\n            foreach ($results as $member) {\n                $str_adh = $member->id_adh . ' (' . $member->nom_adh . ' ' .\n                    $member->prenom_adh . ')';\n                $infos .= $str_adh . \"\\n\";\n\n                $p = new Picture($member->id_adh);\n                if ($p->hasPicture()) {\n                    if (!$p->delete(false)) {\n                        Analog::log(\n                            'Unable to delete picture for member ' . $str_adh,\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to delete picture for member ' .\n                            $str_adh\n                        );\n                    } else {\n                        $hist->add(\n                            _T(\"Member Picture deleted\"),\n                            $str_adh\n                        );\n                    }\n                }\n\n                $processed[] = [\n                    'id_adh' => $member->id_adh,\n                    'nom_adh' => $member->nom_adh,\n                    'prenom_adh' => $member->prenom_adh,\n                    'email_adh' => $member->email_adh\n                ];\n            }\n\n            //delete contributions\n            $del_qry = $zdb->delete(Contribution::TABLE);\n            $del_qry->where->in(\n                self::PK,\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //get transactions\n            $select = $zdb->select(Transaction::TABLE);\n            $select->where->in(self::PK, $list);\n            $results = $zdb->execute($select);\n\n            //if members has transactions;\n            //reset link with other contributions\n            //and remove them\n            if ($results->count() > 0) {\n                $transactions = [];\n                foreach ($results as $transaction) {\n                    $transactions[] = $transaction[Transaction::PK];\n                }\n\n                $update = $zdb->update(Contribution::TABLE);\n                $update->set([\n                    Transaction::PK => new Expression('NULL')\n                ])->where->in(\n                    Transaction::PK,\n                    $transactions\n                );\n                $zdb->execute($update);\n            }\n\n            //delete transactions\n            $del_qry = $zdb->delete(Transaction::TABLE);\n            $del_qry->where->in(self::PK, $list);\n            $zdb->execute($del_qry);\n\n            //delete groups membership/mamagmentship\n            Groups::removeMembersFromGroups($list);\n\n            //delete reminders\n            $del_qry = $zdb->delete(Reminder::TABLE);\n            $del_qry->where->in(\n                'reminder_dest',\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //delete dynamic fields values\n            $del_qry = $zdb->delete(DynamicFieldsHandle::TABLE);\n            $del_qry->where(['field_form' => 'adh']);\n            $del_qry->where->in('item_id', $list);\n            $zdb->execute($del_qry);\n\n            //delete members\n            $del_qry = $zdb->delete(self::TABLE);\n            $del_qry->where->in(\n                self::PK,\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //commit all changes\n            $zdb->connection->commit();\n\n            foreach ($processed as $p) {\n                $emitter->emit('member.remove', $p);\n            }\n\n            //add an history entry\n            $hist->add(\n                _T(\"Delete members cards, transactions and dues\"),\n                $infos\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            if ($e->getCode() == 23000) {\n                Analog::log(\n                    'Member still have existing dependencies in the ' .\n                    'database, maybe a mailing or some content from a ' .\n                    'plugin. Please remove dependencies before trying ' .\n                    'to remove him.',\n                    Analog::ERROR\n                );\n                $this->errors[] = _T(\"Cannot remove a member who still have dependencies (mailings, ...)\");\n            } else {\n                Analog::log(\n                    'Unable to delete selected member(s) |' .\n                    $e->getMessage(),\n                    Analog::ERROR\n                );\n                throw $e;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get members list\n     *\n     * @param boolean $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getList($as_members = false, $fields = null)\n    {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            false,\n            false,\n            false,\n            true,\n            false\n        );\n    }\n\n    /**\n     * Get members list with public information available\n     *\n     * @param boolean $with_photos get only members which have uploaded a\n     *                             photo (for trombinoscope)\n     *\n     * @return Adherent[]\n     */\n    public function getPublicList($with_photos)\n    {\n        global $zdb;\n\n        try {\n            $select = $this->buildSelect(\n                self::SHOW_PUBLIC_LIST,\n                null,\n                $with_photos,\n                true\n            );\n\n            $this->filters->setLimits($select);\n\n            $results = $zdb->execute($select);\n            $members = array();\n            $deps = array(\n                'groups'    => false,\n                'dues'      => false,\n                'picture'   => $with_photos\n            );\n            foreach ($results as $row) {\n                $members[] = new Adherent($zdb, $row, $deps);\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list members with public information (photos: '\n                . $with_photos . ') | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get list of members that has been selected\n     *\n     * @param array   $ids         an array of members id that has been selected\n     * @param array   $orderby     SQL order clause (optionnal)\n     * @param boolean $with_photos Should photos be loaded?\n     * @param boolean $as_members  Return Adherent[] or simple ResultSet\n     * @param array   $fields      Fields to use\n     * @param boolean $export      True if we are exporting\n     * @param boolean $dues        True if load dues as Adherent dependency\n     * @param boolean $parent      True if load parent as Adherent dependency\n     *\n     * @return Adherent[]\n     */\n    public function getArrayList(\n        $ids,\n        $orderby = null,\n        $with_photos = false,\n        $as_members = true,\n        $fields = null,\n        $export = false,\n        $dues = false,\n        $parent = false\n    ) {\n        global $zdb;\n\n        if (!is_array($ids) || count($ids) < 1) {\n            Analog::log('No member selected for labels.', Analog::INFO);\n            return false;\n        }\n\n        try {\n            $damode = self::SHOW_ARRAY_LIST;\n            if ($export === true) {\n                $damode = self::SHOW_EXPORT;\n            }\n            $select = $this->buildSelect(\n                $damode,\n                $fields,\n                false,\n                false\n            );\n            $select->where->in('a.' . self::PK, $ids);\n            if (is_array($orderby) && count($orderby) > 0) {\n                foreach ($orderby as $o) {\n                    $select->order($o);\n                }\n            }\n\n            $results = $zdb->execute($select);\n\n            $members = array();\n            $deps = array(\n                'picture'   => $with_photos,\n                'groups'    => false,\n                'dues'      => $dues,\n                'parent'    => $parent\n            );\n            foreach ($results as $o) {\n                if ($as_members === true) {\n                    $members[] = new Adherent($zdb, $o, $deps);\n                } else {\n                    $members[] = $o;\n                }\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load members form ids array | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the SELECT statement\n     *\n     * @param int   $mode   the current mode (see self::SHOW_*)\n     * @param array $fields fields list to retrieve\n     * @param bool  $photos true if we want to get only members with photos\n     *                      Default to false, only relevant for SHOW_PUBLIC_LIST\n     * @param bool  $count  true if we want to count members, defaults to false\n     *\n     * @return Select SELECT statement\n     */\n    private function buildSelect($mode, $fields, $photos, $count = false): Select\n    {\n        global $zdb, $login;\n\n        try {\n            if ($fields != null && is_array($fields) && !in_array('id_adh', $fields)) {\n                $fields[] = 'id_adh';\n            }\n            $fieldsList = ($fields != null)\n                            ? ((!is_array($fields) || count($fields) < 1) ? (array)'*'\n                            : $fields) : (array)'*';\n\n            $select = $zdb->select(self::TABLE, 'a');\n\n            $select->columns($fieldsList);\n\n            $select->quantifier('DISTINCT');\n\n            $select->join(\n                array('so' => PREFIX_DB . Social::TABLE),\n                'a.' . Adherent::PK . '=so.' . Adherent::PK,\n                array(),\n                $select::JOIN_LEFT\n            );\n\n            switch ($mode) {\n                case self::SHOW_STAFF:\n                case self::SHOW_LIST:\n                case self::SHOW_ARRAY_LIST:\n                case self::SHOW_EXPORT:\n                    $select->join(\n                        array('status' => PREFIX_DB . Status::TABLE),\n                        'a.' . Status::PK . '=status.' . Status::PK,\n                        array()\n                    );\n                    break;\n                case self::SHOW_MANAGED:\n                    $select->join(\n                        array('status' => PREFIX_DB . Status::TABLE),\n                        'a.' . Status::PK . '=status.' . Status::PK\n                    )->join(\n                        array('gr' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                        'a.' . Adherent::PK . '=gr.' . Adherent::PK,\n                        array()\n                    )->join(\n                        array('m' => PREFIX_DB . Group::GROUPSMANAGERS_TABLE),\n                        'gr.' . Group::PK . '=m.' . Group::PK,\n                        array()\n                    )->where('m.' . Adherent::PK . ' = ' . $login->id);\n                    break;\n                case self::SHOW_PUBLIC_LIST:\n                    if ($photos) {\n                        $select->join(\n                            array('picture' => PREFIX_DB . Picture::TABLE),\n                            'a.' . self::PK . '= picture.' . self::PK,\n                            array()\n                        );\n                    }\n                    break;\n            }\n\n            //check for contributions filtering\n            if (\n                $this->filters instanceof AdvancedMembersList\n                && $this->filters->withinContributions()\n            ) {\n                $select->join(\n                    array('ct' => PREFIX_DB . Contribution::TABLE),\n                    'ct.' . self::PK . '=a.' . self::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                );\n            }\n\n            //check if there are dynamic fields in filter\n            $hasDf = false;\n            $dfs = array();\n            if ($this->filters instanceof AdvancedMembersList) {\n                if (\n                    (bool)count($this->filters->free_search)\n                    && !isset($this->filters->free_search['empty'])\n                ) {\n                    $free_searches = $this->filters->free_search;\n                    foreach ($free_searches as $fs) {\n                        if (strpos($fs['field'], 'dyn_') === 0) {\n                            // simple dynamic fields\n                            $hasDf = true;\n                            $dfs[] = str_replace('dyn_', '', $fs['field']);\n                        }\n                    }\n                }\n            }\n\n            //check if there are dynamic fields for contributions in filter\n            $hasDfc = false;\n            $hasCdfc = false;\n            $cdfcs = array();\n\n            if (\n                $this->filters instanceof AdvancedMembersList\n                && $this->filters->withinContributions()\n            ) {\n                if (\n                    $this->filters->contrib_dynamic\n                    && count($this->filters->contrib_dynamic) > 0\n                    && !isset($this->filters->contrib_dynamic['empty'])\n                ) {\n                    $hasDfc = true;\n\n                    //check if there are dynamic fields in the filter\n                    foreach ($this->filters->contrib_dynamic as $k => $cd) {\n                        if (is_array($cd)) {\n                            $hasCdfc = true;\n                            $cdfcs[] = $k;\n                        }\n                    }\n                }\n            }\n\n            if ($hasDfc === true || $hasCdfc === true) {\n                $select->join(\n                    array('dfc' => PREFIX_DB . DynamicFieldsHandle::TABLE),\n                    'dfc.item_id=ct.' . Contribution::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                );\n            }\n\n            // simple dynamic fields\n            if ($hasDf === true) {\n                foreach ($dfs as $df) {\n                    $subselect = $zdb->select(DynamicFieldsHandle::TABLE, 'df');\n                    $subselect->columns(\n                        [\n                            'item_id'   => 'item_id',\n                            'val'       => 'field_val'\n                        ]\n                    );\n                    $subselect->where('df.field_form = \\'adh\\'');\n                    $subselect->where('df.field_id = ' . $df);\n                    $select->join(\n                        array('df' . $df => $subselect),\n                        'a.id_adh = df' . $df . '.item_id',\n                        array(),\n                        $select::JOIN_LEFT\n                    );\n                }\n            }\n\n            // choice dynamic fields\n            if ($hasCdfc === true) {\n                $cdf_field = 'cdf.id';\n                if (TYPE_DB === 'pgsql') {\n                    $cdf_field .= '::text';\n                }\n\n                $cdf_field = 'cdfc.id';\n                if (TYPE_DB === 'pgsql') {\n                    $cdf_field .= '::text';\n                }\n                foreach ($cdfcs as $cdf) {\n                    $rcdf_field = str_replace(\n                        'cdfc.',\n                        'cdfc' . $cdf . '.',\n                        $cdf_field\n                    );\n                    $select->join(\n                        array('cdfc' . $cdf => DynamicField::getFixedValuesTableName($cdf, true)),\n                        $rcdf_field . '=dfc.field_val',\n                        array(),\n                        $select::JOIN_LEFT\n                    );\n                }\n            }\n\n            if ($mode == self::SHOW_LIST || $mode == self::SHOW_MANAGED) {\n                if ($this->filters !== false) {\n                    $this->buildWhereClause($select);\n                }\n            } elseif ($mode == self::SHOW_PUBLIC_LIST) {\n                $select->where(\n                    array(\n                        new PredicateSet(\n                            array(\n                                new Operator(\n                                    'date_echeance',\n                                    '>=',\n                                    date('Y-m-d')\n                                ),\n                                new Operator(\n                                    'bool_exempt_adh',\n                                    '=',\n                                    new Expression('true')\n                                )\n                            ),\n                            PredicateSet::OP_OR\n                        ),\n                        new PredicateSet(\n                            array(\n                                new Operator(\n                                    'bool_display_info',\n                                    '=',\n                                    new Expression('true')\n                                ),\n                                new Operator(\n                                    'activite_adh',\n                                    '=',\n                                    new Expression('true')\n                                )\n                            ),\n                            PredicateSet::OP_AND\n                        )\n                    )\n                );\n            }\n\n            if ($mode === self::SHOW_STAFF) {\n                $select->where->lessThan(\n                    'status.priorite_statut',\n                    self::NON_STAFF_MEMBERS\n                );\n            }\n\n            if ($count) {\n                $this->proceedCount($select);\n            }\n\n            $this->buildOrderClause($select, $fields);\n\n            return $select;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot build SELECT clause for members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Count members from the query\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function proceedCount(Select $select)\n    {\n        global $zdb;\n\n        try {\n            $countSelect = clone $select;\n            $countSelect->reset($countSelect::COLUMNS);\n            $countSelect->reset($countSelect::ORDER);\n            $countSelect->reset($countSelect::HAVING);\n            $joins = $countSelect->joins;\n            $countSelect->reset($countSelect::JOINS);\n            foreach ($joins as $join) {\n                $countSelect->join(\n                    $join['name'],\n                    $join['on'],\n                    [],\n                    $join['type']\n                );\n                unset($join['columns']);\n            }\n            $countSelect->columns(\n                array(\n                    'count' => new Expression('count(DISTINCT a.' . self::PK . ')')\n                )\n            );\n\n            $have = $select->having;\n            if ($have->count() > 0) {\n                foreach ($have->getPredicates() as $h) {\n                    $countSelect->where($h);\n                }\n            }\n\n            $results = $zdb->execute($countSelect);\n\n            $this->count = (int)$results->current()->count;\n            if (isset($this->filters) && $this->count > 0) {\n                $this->filters->setCounter($this->count);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot count members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the order clause\n     *\n     * @param Select $select Original select\n     * @param array  $fields Fields list to ensure ORDER clause\n     *                       references selected fields. Optional.\n     *\n     * @return Select\n     */\n    private function buildOrderClause(Select $select, $fields = null): Select\n    {\n        $order = array();\n\n        switch ($this->filters->orderby) {\n            case self::ORDERBY_NICKNAME:\n                if ($this->canOrderBy('pseudo_adh', $fields)) {\n                    $order[] = 'pseudo_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_STATUS:\n                if ($this->canOrderBy('priorite_statut', $fields)) {\n                    $order[] = 'priorite_statut ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_MODIFDATE:\n                if ($this->canOrderBy('date_modif_adh', $fields)) {\n                    $order[] = 'date_modif_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case 'list_adh_contribstatus':\n            case self::ORDERBY_FEE_STATUS:\n                if ($this->canOrderBy('bool_exempt_adh', $fields)) {\n                    $order[] = 'bool_exempt_adh ' . $this->filters->getDirection();\n                }\n\n                if ($this->canOrderBy('date_echeance', $fields)) {\n                    $order[] = 'date_echeance ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_ID:\n                if ($this->canOrderBy('id_adh', $fields)) {\n                    $order[] = 'id_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case 'list_adh_name':\n            case 'nom_adh':\n            case 'prenom_adh':\n            case self::ORDERBY_NAME:\n                //defaults\n                break;\n            default:\n                if ($this->canOrderBy($this->filters->orderby, $fields)) {\n                    $order[] = $this->filters->orderby . ' ' . $this->filters->getDirection();\n                }\n                break;\n        }\n\n        //anyways, we want to order by firstname, lastname\n        if ($this->canOrderBy('nom_adh', $fields)) {\n            $order[] = 'nom_adh ' . $this->filters->getDirection();\n        }\n        if ($this->canOrderBy('prenom_adh', $fields)) {\n            $order[] = 'prenom_adh ' . $this->filters->getDirection();\n        }\n\n        $select->order($order);\n        return $select;\n    }\n\n    /**\n     * Is field allowed to order? it shoulsd be present in\n     * provided fields list (those that are SELECT'ed).\n     *\n     * @param string $field_name Field name to order by\n     * @param array  $fields     SELECTE'ed fields\n     *\n     * @return boolean\n     */\n    private function canOrderBy($field_name, $fields)\n    {\n        if ($fields === null) {\n            return true;\n        } elseif (!is_array($fields)) {\n            return false;\n        } elseif (in_array($field_name, $fields)) {\n            return true;\n        } else {\n            Analog::log(\n                'Trying to order by ' . $field_name . ' while it is not in ' .\n                'selected fields.',\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Builds where clause, for filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function buildWhereClause(Select $select)\n    {\n        global $zdb, $login;\n\n        try {\n            if ($this->filters->email_filter == self::FILTER_W_EMAIL) {\n                $select->where('email_adh != \\'\\'');\n            }\n            if ($this->filters->email_filter == self::FILTER_WO_EMAIL) {\n                $select->where('(email_adh = \\'\\' OR email_adh IS NULL)');\n            }\n\n            if ($this->filters->filter_str != '') {\n                $token = $zdb->platform->quoteValue(\n                    '%' . strtolower($this->filters->filter_str) . '%'\n                );\n                switch ($this->filters->field_filter) {\n                    case self::FILTER_NAME:\n                        if (TYPE_DB === 'pgsql') {\n                            $sep = \" || ' ' || \";\n                            $pre = '';\n                            $post = '';\n                        } else {\n                            $sep = ', \" \", ';\n                            $pre = 'CONCAT(';\n                            $post = ')';\n                        }\n\n                        $select->where(\n                            '(' .\n                            $pre . 'LOWER(nom_adh)' . $sep .\n                            'LOWER(prenom_adh)' . $sep .\n                            'LOWER(pseudo_adh)' . $post . ' LIKE ' .\n                            $token\n                            . ' OR ' .\n                            $pre . 'LOWER(prenom_adh)' . $sep .\n                            'LOWER(nom_adh)' . $sep .\n                            'LOWER(pseudo_adh)' . $post . ' LIKE ' .\n                            $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_COMPANY_NAME:\n                        $select->where(\n                            'LOWER(societe_adh) LIKE ' .\n                            $token\n                        );\n                        break;\n                    case self::FILTER_ADDRESS:\n                        $select->where(\n                            '(' .\n                            'LOWER(adresse_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(adresse2_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'cp_adh LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(ville_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(pays_adh) LIKE ' . $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_MAIL:\n                        $select->where(\n                            '(' .\n                            'LOWER(email_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(so.url) LIKE ' . $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_JOB:\n                        $select->where(\n                            'LOWER(prof_adh) LIKE ' . $token\n                        );\n                        break;\n                    case self::FILTER_INFOS:\n                        $more = '';\n                        if ($login->isAdmin() || $login->isStaff()) {\n                            $more = ' OR LOWER(info_adh) LIKE ' . $token;\n                        }\n                        $select->where(\n                            '(LOWER(info_public_adh) LIKE ' .\n                            $token . $more . ')'\n                        );\n                        break;\n                    case self::FILTER_NUMBER:\n                        $select->where->equalTo('a.num_adh', $this->filters->filter_str);\n                        break;\n                    case self::FILTER_ID:\n                        $select->where->equalTo('a.id_adh', $this->filters->filter_str);\n                        break;\n                }\n            }\n\n            if ($this->filters->membership_filter) {\n                switch ($this->filters->membership_filter) {\n                    case self::MEMBERSHIP_NEARLY:\n                        $now = new \\DateTime();\n                        $duedate = new \\DateTime();\n                        $duedate->modify('+1 month');\n                        $select->where->greaterThan(\n                            'date_echeance',\n                            $now->format('Y-m-d')\n                        )->lessThanOrEqualTo(\n                            'date_echeance',\n                            $duedate->format('Y-m-d')\n                        );\n                        break;\n                    case self::MEMBERSHIP_LATE:\n                        $select->where\n                            ->lessThan(\n                                'date_echeance',\n                                date('Y-m-d', time())\n                            )->equalTo('bool_exempt_adh', new Expression('false'));\n                        break;\n                    case self::MEMBERSHIP_UP2DATE:\n                        $select->where(\n                            '(' . 'date_echeance >= \\'' . date('Y-m-d', time())\n                            . '\\' OR bool_exempt_adh=true)'\n                        );\n                        break;\n                    case self::MEMBERSHIP_NEVER:\n                        $select->where('date_echeance IS NULL')\n                            ->where('bool_exempt_adh = false');\n                        break;\n                    case self::MEMBERSHIP_STAFF:\n                        $select->where->lessThan(\n                            'status.priorite_statut',\n                            self::NON_STAFF_MEMBERS\n                        );\n                        break;\n                    case self::MEMBERSHIP_ADMIN:\n                        $select->where->equalTo('bool_admin_adh', true);\n                        break;\n                    case self::MEMBERSHIP_NONE:\n                        $select->where->equalTo('a.id_statut', Status::DEFAULT_STATUS);\n                        break;\n                }\n            }\n\n            if ($this->filters->filter_account) {\n                switch ($this->filters->filter_account) {\n                    case self::ACTIVE_ACCOUNT:\n                        $select->where('activite_adh=true');\n                        break;\n                    case self::INACTIVE_ACCOUNT:\n                        $select->where('activite_adh=false');\n                        break;\n                }\n            }\n\n            if ($this->filters->group_filter) {\n                $select->join(\n                    array('g' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                    'a.' . Adherent::PK . '=g.' . Adherent::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                )->join(\n                    array('gs' => PREFIX_DB . Group::TABLE),\n                    'gs.' . Group::PK . '=g.' . Group::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                )->where(\n                    '(g.' . Group::PK . ' = ' . $this->filters->group_filter .\n                    ' OR gs.parent_group = NULL OR gs.parent_group = ' .\n                    $this->filters->group_filter . ')'\n                );\n            }\n\n            if ($this->filters instanceof AdvancedMembersList) {\n                $this->buildAdvancedWhereClause($select);\n            }\n\n            return $select;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds where clause, for advanced filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function buildAdvancedWhereClause(Select $select)\n    {\n        global $zdb, $login;\n\n        // Search members who belong to any (OR) or all (AND) listed groups.\n        // Idea is to build an array of members ID that fits groups selection\n        // we will use in the final query.\n        // The OR case is quite simple, AND is a bit more complex; since we must\n        // check each member do belongs to all listed groups.\n        if (\n            count($this->filters->groups_search) > 0\n            && !isset($this->filters->groups_search['empty'])\n        ) {\n            $groups_adh = [];\n            $wheregroups = [];\n\n            foreach ($this->filters->groups_search as $gs) { // then add a row for each group\n                $wheregroups[] = $gs['group'];\n            }\n\n            $gselect = $zdb->select(Group::GROUPSUSERS_TABLE, 'gu');\n            $gselect->columns(\n                array('id_adh')\n            )->join(\n                array('g' => PREFIX_DB . Group::TABLE),\n                'gu.id_group=g.' . Group::PK,\n                array(),\n                $select::JOIN_LEFT\n            )->where(\n                array(\n                    'g.id_group'        => ':group',\n                    'g.parent_group'    => ':pgroup'\n                ),\n                PredicateSet::OP_OR\n            );\n            $gselect->group(['gu.id_adh']);\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($gselect);\n\n            $mids = [];\n            $ids = [];\n            foreach ($this->filters->groups_search as $gs) { // then add a row for each ig/searched group pair\n                $gresults = $stmt->execute(\n                    array(\n                        'group'    => $gs['group'],\n                        'pgroup'   => $gs['group']\n                    )\n                );\n\n                switch ($this->filters->groups_search_log_op) {\n                    case AdvancedMembersList::OP_AND:\n                        foreach ($gresults as $gresult) {\n                            if (!isset($ids[$gresult['id_adh']])) {\n                                $ids[$gresult['id_adh']] = 0;\n                            }\n                            $ids[$gresult['id_adh']] += 1;\n                        }\n                        break;\n                    case AdvancedMembersList::OP_OR:\n                        foreach ($gresults as $gresult) {\n                            $mids[$gresult['id_adh']] = $gresult['id_adh'];\n                        }\n                        break;\n                }\n            }\n\n            if (count($ids)) {\n                foreach ($ids as $id_adh => $count) {\n                    if ($count == count($wheregroups)) {\n                        $mids[$id_adh] = $id_adh;\n                    }\n                }\n            }\n\n            if (count($mids)) {\n                //limit on found members\n                $select->where->in('a.id_adh', $mids);\n            } else {\n                //no match in groups, end of game.\n                $select->where('false = true');\n            }\n        }\n\n        //FIXME: should be retrieved from members_fields\n        $dates = [\n            'ddn_adh'               => 'birth_date',\n            'date_crea_adh'         => 'creation_date',\n            'date_modif_adh'        => 'modif_date',\n            'date_echeance'         => 'due_date',\n            'ct.date_enreg'         => 'contrib_creation_date',\n            'ct.date_debut_cotis'   => 'contrib_begin_date',\n            'ct.date_fin_cotis'     => 'contrib_end_date'\n        ];\n\n        foreach ($dates as $field => $property) {\n            $bprop = \"r{$property}_begin\";\n            if ($this->filters->$bprop) {\n                $d = new \\DateTime($this->filters->$bprop);\n                $select->where->greaterThanOrEqualTo(\n                    $field,\n                    $d->format('Y-m-d')\n                );\n            }\n            $eprop = \"r{$property}_end\";\n            if ($this->filters->$eprop) {\n                $d = new \\DateTime($this->filters->$eprop);\n                $select->where->lessThanOrEqualTo(\n                    $field,\n                    $d->format('Y-m-d')\n                );\n            }\n        }\n\n        if ($this->filters->show_public_infos) {\n            switch ($this->filters->show_public_infos) {\n                case self::FILTER_W_PUBINFOS:\n                    $select->where('bool_display_info = true');\n                    break;\n                case self::FILTER_WO_PUBINFOS:\n                    $select->where('bool_display_info = false');\n                    break;\n                case self::FILTER_DC_PUBINFOS:\n                    //nothing to do here.\n                    break;\n            }\n        }\n\n        if ($this->filters->status) {\n            $select->where->in(\n                'a.id_statut',\n                $this->filters->status\n            );\n        }\n\n        if (\n            $this->filters->contrib_min_amount\n            || $this->filters->contrib_max_amount\n        ) {\n            if ($this->filters->contrib_min_amount) {\n                $select->where->greaterThanOrEqualTo(\n                    'ct.montant_cotis',\n                    $this->filters->contrib_min_amount\n                );\n            }\n            if ($this->filters->contrib_max_amount) {\n                $select->where->lessThanOrEqualTo(\n                    'ct.montant_cotis',\n                    $this->filters->contrib_max_amount\n                );\n            }\n        }\n\n        if ($this->filters->contributions_types) {\n            $select->where->in(\n                'ct.id_type_cotis',\n                $this->filters->contributions_types\n            );\n        }\n\n        if ($this->filters->payments_types) {\n            $select->where->in(\n                'ct.type_paiement_cotis',\n                $this->filters->payments_types\n            );\n        }\n\n        if (\n            count($this->filters->contrib_dynamic) > 0\n            && !isset($this->filters->contrib_dynamic['empty'])\n        ) {\n            foreach ($this->filters->contrib_dynamic as $k => $cd) {\n                $qry = '';\n                $prefix = 'a.';\n                $field = null;\n                $qop = ' LIKE ';\n\n                if (is_array($cd)) {\n                    //dynamic choice spotted!\n                    $prefix = 'cdfc' . $k . '.';\n                    $qry = 'dfc.field_form = \\'contrib\\' AND ' .\n                        'dfc.field_id = ' . $k;\n                    $field = 'id';\n                    $select->where($qry);\n                    $select->where->in($prefix . $field, $cd);\n                } else {\n                    //dynamic field spotted!\n                    $prefix = 'dfc.';\n                    $qry = 'dfc.field_form = \\'contrib\\' AND ' .\n                        'dfc.field_id = ' . $k . ' AND ';\n                    $field = 'field_val';\n                    $qry .= 'LOWER(' . $prefix . $field . ') ' .\n                        $qop . ' ';\n                    $select->where($qry . $zdb->platform->quoteValue('%' . strtolower($cd) . '%'));\n                }\n            }\n        }\n\n        if (\n            count($this->filters->free_search) > 0\n            && !isset($this->filters->free_search['empty'])\n        ) {\n            foreach ($this->filters->free_search as $fs) {\n                $fs['search'] = mb_strtolower($fs['search']);\n                $qop = null;\n                switch ($fs['qry_op']) {\n                    case AdvancedMembersList::OP_EQUALS:\n                        $qop = '=';\n                        break;\n                    case AdvancedMembersList::OP_CONTAINS:\n                        $qop = 'LIKE';\n                        $fs['search'] = '%' . $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_NOT_EQUALS:\n                        $qop = '!=';\n                        break;\n                    case AdvancedMembersList::OP_NOT_CONTAINS:\n                        $qop = 'NOT LIKE';\n                        $fs['search'] = '%' . $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_STARTS_WITH:\n                        $qop = 'LIKE';\n                        $fs['search'] = $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_ENDS_WITH:\n                        $qop = 'LIKE';\n                        $fs['search'] = '%' . $fs['search'];\n                        break;\n                    case AdvancedMembersList::OP_BEFORE:\n                        $qop = '<';\n                        break;\n                    case AdvancedMembersList::OP_AFTER:\n                        $qop = '>';\n                        break;\n                    default:\n                        Analog::log(\n                            'Unknown query operator: ' . $fs['qry_op'] .\n                            ' (will fallback to equals)',\n                            Analog::WARNING\n                        );\n                        $qop = '=';\n                        break;\n                }\n\n                $qry = '';\n                $prefix = 'a.';\n                $dyn_field = false;\n                if (strpos($fs['field'], 'dyn_') === 0) {\n                    // simple dynamic field spotted!\n                    $index = str_replace('dyn_', '', $fs['field']);\n                    $dyn_field = DynamicField::loadFieldType($zdb, (int)$index);\n                    $prefix = 'df' . $index . '.';\n                    $fs['field'] = 'val';\n                }\n\n                //handle socials networks\n                if (strpos($fs['field'], 'socials_') === 0) {\n                    //social networks\n                    $type = str_replace('socials_', '', $fs['field']);\n                    $prefix = 'so.';\n                    $fs['field'] = 'url';\n                    $select->where(['so.type' => $type]);\n                }\n\n                if ($dyn_field && $dyn_field instanceof \\Galette\\DynamicFields\\Boolean) {\n                    if ($fs['search'] != 0) {\n                        $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                            $fs['search'];\n                    } else {\n                        $qry .= $prefix . $fs['field'] . ' IS NULL';\n                    }\n                } elseif (!strncmp($fs['field'], 'bool_', strlen('bool_'))) {\n                    $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                        $fs['search'];\n                } elseif (\n                    $fs['qry_op'] === AdvancedMembersList::OP_BEFORE\n                    || $fs['qry_op'] === AdvancedMembersList::OP_AFTER\n                ) {\n                    if ($prefix === 'a.') {\n                        //dates are OK in the main fields. no cast, just query!\n                        $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                            $zdb->platform->quoteValue($fs['search']);\n                    } else {\n                        //dynamic dates are stored in their localized format :/\n                        //use current lang format to query for now\n                        if ($zdb->isPostgres()) {\n                            $fs['search'] = \"to_date('\" . $fs['search'] . \"', 'YYYY-MM-DD')\";\n                            $store_fmt = __(\"Y-m-d\") === 'Y-m-d' ? 'YYYY-MM-DD' : 'DD/MM/YYYY';\n                            $qry .= \"to_date('\" . $prefix . $fs['field'] . \"', '$store_fmt')\";\n                        } else {\n                            $fs['search'] = \"STR_TO_DATE('\" . $fs['search'] . \"', '%Y-%m-%d')\";\n                            $store_fmt = __(\"Y-m-d\") === 'Y-m-d' ? '%Y-%m-%d' : '%d/%m/%Y';\n                            $qry .= 'STR_TO_DATE(' . $prefix . $fs['field'] . ', \\'' . $store_fmt . '\\') ';\n                        }\n\n                        $qry .= $qop . ' ' . $fs['search'];\n                    }\n                } elseif ($fs['field'] == 'status_label') {\n                    $qry_pattern = '%p%field %op %value';\n                    $qry .= str_replace(\n                        [\n                            '%p',\n                            '%field',\n                            '%op',\n                            '%value'\n                        ],\n                        [\n                            'status.',\n                            'libelle_statut',\n                            $qop,\n                            $zdb->platform->quoteValue($fs['search'])\n                        ],\n                        $qry_pattern\n                    );\n                } else {\n                    $qry .= 'LOWER(' . $prefix . $fs['field'] . ') ' .\n                        $qop . ' ' . $zdb->platform->quoteValue($fs['search']);\n                }\n\n                if ($fs['log_op'] === AdvancedMembersList::OP_AND) {\n                    $select->where($qry);\n                } elseif ($fs['log_op'] === AdvancedMembersList::OP_OR) {\n                    $select->where($qry, PredicateSet::OP_OR);\n                }\n            }\n        }\n\n        return $select;\n    }\n\n    /**\n     * Login and password field cannot be empty.\n     *\n     * If those ones are not required, or if a file has been imported\n     * (from a CSV file for example), we fill here random values.\n     *\n     * @return boolean\n     */\n    public function emptyLogins()\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n            $select = $zdb->select(Adherent::TABLE);\n            $select->columns(\n                array('id_adh', 'login_adh', 'mdp_adh')\n            )->where(\n                array(\n                    'login_adh' => new Expression('NULL'),\n                    'login_adh' => '',\n                    'mdp_adh'   => new Expression('NULL'),\n                    'mdp_adh'   => ''\n                ),\n                PredicateSet::OP_OR\n            );\n\n            $results = $zdb->execute($select);\n\n            $processed = 0;\n            if ($results->count() > 0) {\n                $update = $zdb->update(Adherent::TABLE);\n                $update->set(\n                    array(\n                        'login_adh' => ':login',\n                        'mdp_adh'   => ':pass'\n                    )\n                )->where->equalTo(Adherent::PK, ':id');\n\n                $stmt = $zdb->sql->prepareStatementForSqlObject($update);\n\n                $p = new \\Galette\\Core\\Password($zdb);\n\n                foreach ($results as $m) {\n                    $dirty = false;\n                    if (\n                        $m->login_adh == ''\n                        || !isset($m->login_adh)\n                        || $m->login_adh == 'NULL'\n                    ) {\n                        $m->login_adh = $p->makeRandomPassword(15);\n                        $dirty = true;\n                    }\n\n                    if (\n                        $m->mdp_adh == ''\n                        || !isset($m->mdp_adh)\n                        || $m->mdp_adh == 'NULL'\n                    ) {\n                        $randomp = $p->makeRandomPassword(15);\n                        $m->mdp_adh = password_hash(\n                            $randomp,\n                            PASSWORD_BCRYPT\n                        );\n                        $dirty = true;\n                    }\n\n                    if ($dirty === true) {\n                        $stmt->execute(\n                            array(\n                                'login' => $m->login_adh,\n                                'pass'  => $m->mdp_adh,\n                                'id'    => $m->id_adh\n                            )\n                        );\n                        $processed++;\n                    }\n                }\n            }\n            $zdb->connection->commit();\n            $this->count = $processed;\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            Analog::log(\n                'An error occurred trying to retrieve members with ' .\n                'empty logins/passwords (' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads data to produce a Pie chart based on members state of dues\n     *\n     * @return void\n     */\n    public function getRemindersCount()\n    {\n        global $zdb;\n\n        $reminders = array();\n\n        $soon_date = new \\DateTime();\n        $soon_date->modify('+1 month');\n\n        $now = new \\DateTime();\n\n        $select = $zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            array(\n                'cnt' => new Expression('count(a.' . Adherent::PK . ')')\n            )\n        );\n\n        $select->join(\n            array('parent' => PREFIX_DB . self::TABLE),\n            'a.parent_id=parent.' . self::PK,\n            array(),\n            $select::JOIN_LEFT\n        );\n\n        $select->where\n            ->lessThan('a.date_echeance', $soon_date->format('Y-m-d'))\n            ->greaterThanOrEqualTo('a.date_echeance', $now->format('Y-m-d'));\n        $select\n            ->where('a.activite_adh=true')\n            ->where('a.bool_exempt_adh=false');\n\n        $select_wo_mail = clone $select;\n\n        $select->where(\n            '(a.email_adh != \\'\\' OR a.parent_id IS NOT NULL AND parent.email_adh != \\'\\')'\n        );\n        $select_wo_mail->where(\n            '(a.email_adh = \\'\\' OR a.email_adh IS NULL) AND (parent.email_adh = \\'\\' OR parent.email_adh IS NULL)'\n        );\n\n        $results = $zdb->execute($select);\n        $res = $results->current();\n        $reminders['impending'] = $res->cnt;\n\n        $results_wo_mail = $zdb->execute($select_wo_mail);\n        $res_wo_mail = $results_wo_mail->current();\n        $reminders['nomail']['impending'] = $res_wo_mail->cnt;\n\n        $select = $zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            array(\n                'cnt' => new Expression('count(a.' . Adherent::PK . ')')\n            )\n        );\n\n        $select->join(\n            array('parent' => PREFIX_DB . self::TABLE),\n            'a.parent_id=parent.' . self::PK,\n            array(),\n            $select::JOIN_LEFT\n        );\n\n        $select->where\n            ->lessThan('a.date_echeance', $now->format('Y-m-d'));\n        $select\n            ->where('a.activite_adh=true')\n            ->where('a.bool_exempt_adh=false');\n\n        $select_wo_mail = clone $select;\n\n        $select->where(\n            '(a.email_adh != \\'\\' OR a.parent_id IS NOT NULL AND parent.email_adh != \\'\\')'\n        );\n\n        $select_wo_mail->where(\n            '(a.email_adh = \\'\\' OR a.email_adh IS NULL) AND (parent.email_adh = \\'\\' OR parent.email_adh IS NULL)'\n        );\n\n        $results = $zdb->execute($select);\n        $res = $results->current();\n        $reminders['late'] = $res->cnt;\n\n        $results_wo_mail = $zdb->execute($select_wo_mail);\n        $res_wo_mail = $results_wo_mail->current();\n        $reminders['nomail']['late'] = $res_wo_mail->cnt;\n\n        return $reminders;\n    }\n\n    /**\n     * Get count for current query\n     *\n     * @return int\n     */\n    public function getCount()\n    {\n        return $this->count;\n    }\n\n    /**\n     * Get registered errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get all existing emails\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array ['email' => 'id_adh']\n     */\n    public static function getEmails(Db $zdb)\n    {\n        $emails = [];\n        $select = $zdb->select(self::TABLE);\n        $select->columns([\n            self::PK,\n            'email_adh'\n        ]);\n        $select->where('email_adh != \\'\\' AND email_adh IS NOT NULL');\n        $rows = $zdb->execute($select);\n        foreach ($rows as $row) {\n            $emails[$row->email_adh] = $row->{self::PK};\n        }\n        return $emails;\n    }\n\n    /**\n     * Get current filters\n     *\n     * @return MembersList\n     */\n    public function getFilters()\n    {\n        return $this->filters;\n    }\n\n    /**\n     * Get members list to instanciate dropdowns\n     *\n     * @param Db      $zdb     Database instance\n     * @param integer $current Current member\n     *\n     * @return array\n     */\n    public function getSelectizedMembers(Db $zdb, $current = null)\n    {\n        $members = [];\n        $required_fields = array(\n            'id_adh',\n            'nom_adh',\n            'prenom_adh',\n            'pseudo_adh'\n        );\n        $list_members = $this->getList(false, $required_fields);\n\n        if (count($list_members) > 0) {\n            foreach ($list_members as $member) {\n                $pk = Adherent::PK;\n\n                $members[$member->$pk] = Adherent::getNameWithCase(\n                    $member->nom_adh,\n                    $member->prenom_adh,\n                    false,\n                    $member->id_adh,\n                    $member->pseudo_adh\n                );\n            }\n        }\n\n        //check if current attached member is part of the list\n        if ($current !== null && !isset($members[$current])) {\n            $members =\n                [$current => Adherent::getSName($zdb, $current, true, true)] +\n                $members\n            ;\n        }\n\n        return $members;\n    }\n}\n"], "fixing_code": ["<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Zend Db wrapper\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-07-27\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\nuse Laminas\\Db\\Adapter\\Driver\\DriverInterface;\nuse Laminas\\Db\\Adapter\\Driver\\ConnectionInterface;\nuse Laminas\\Db\\Adapter\\Platform\\PlatformInterface;\nuse Laminas\\Db\\Adapter\\Driver\\StatementInterface;\nuse Laminas\\Db\\Sql\\Insert;\nuse Laminas\\Db\\Sql\\Update;\nuse Laminas\\Db\\Sql\\Select;\nuse Laminas\\Db\\Sql\\Delete;\nuse Laminas\\Db\\ResultSet;\nuse Laminas\\Db\\Sql\\Sql;\nuse Laminas\\Db\\Sql\\SqlInterface;\n\n/**\n * Zend Db wrapper\n *\n * @category  Core\n * @name      Db\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://framework.zend.com/apidoc/2.2/namespaces/Zend.Db.html\n * @since     Available since 0.7dev - 2011-07-27\n *\n * @property Adapter $db\n * @property Sql $sql\n * @property DriverInterface $driver\n * @property ConnectionInterface $connection\n * @property PlatformInterface $platform\n * @property string $query_string\n * @property string $type_db\n */\nclass Db\n{\n    /** @var Adapter */\n    private $db;\n    /** @var string */\n    private $type_db;\n    /** @var Sql */\n    private $sql;\n    /** @var array */\n    private $options;\n    /** @var string */\n    private $last_query;\n\n    public const MYSQL = 'mysql';\n    public const PGSQL = 'pgsql';\n\n    public const MYSQL_DEFAULT_PORT = 3306;\n    public const PGSQL_DEFAULT_PORT = 5432;\n\n    /**\n     * Main constructor\n     *\n     * @param array $dsn Connection information\n     *                   If not set, database constants will be used.\n     */\n    public function __construct($dsn = null)\n    {\n        $_type = null;\n\n        if ($dsn !== null && is_array($dsn)) {\n            $_type_db = $dsn['TYPE_DB'];\n            $_host_db = $dsn['HOST_DB'];\n            $_port_db = $dsn['PORT_DB'];\n            $_user_db = $dsn['USER_DB'];\n            $_pwd_db = $dsn['PWD_DB'];\n            $_name_db = $dsn['NAME_DB'];\n        } else {\n            $_type_db = TYPE_DB;\n            $_host_db = HOST_DB;\n            $_port_db = PORT_DB;\n            $_user_db = USER_DB;\n            $_pwd_db = PWD_DB;\n            $_name_db = NAME_DB;\n        }\n\n        try {\n            if ($_type_db === self::MYSQL) {\n                $_type = 'Pdo_Mysql';\n            } elseif ($_type_db === self::PGSQL) {\n                $_type = 'Pdo_Pgsql';\n            } else {\n                throw new \\Exception(\"Type $_type_db not known (dsn: $_user_db@$_host_db(:$_port_db)/$_name_db)\");\n            }\n\n            $this->type_db = $_type_db;\n            $this->options = array(\n                'driver'   => $_type,\n                'hostname' => $_host_db,\n                'port'     => $_port_db,\n                'username' => $_user_db,\n                'password' => $_pwd_db,\n                'database' => $_name_db\n            );\n            if ($_type_db === self::MYSQL && !defined('NON_UTF_DBCONNECT')) {\n                $this->options['charset'] = 'utf8';\n            }\n\n            $this->doConnection();\n        } catch (Throwable $e) {\n            // perhaps factory() failed to load the specified Adapter class\n            Analog::log(\n                '[Db] Error (' . $e->getCode() . '|' .\n                $e->getMessage() . ')',\n                Analog::ALERT\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Do database connection\n     *\n     * @return void\n     */\n    private function doConnection()\n    {\n        $this->db = new Adapter($this->options);\n        $this->db->getDriver()->getConnection()->connect();\n        $this->sql = new Sql($this->db);\n\n        if (!$this->isPostgres()) {\n            $this->db->query(\"SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\");\n        }\n    }\n\n    /**\n     * To store Db in session\n     *\n     * @return array\n     */\n    public function __sleep()\n    {\n        return ['type_db', 'options'];\n    }\n\n    /**\n     * Connect again to the database on wakeup\n     *\n     * @return void\n     */\n    public function __wakeup()\n    {\n        $this->doConnection();\n    }\n\n    /**\n     * Retrieve current database version\n     *\n     * @param boolean $check_table Check if table exists, defaults to false\n     *\n     * @return float\n     *\n     * @throw LogicException\n     */\n    public function getDbVersion($check_table = false)\n    {\n        try {\n            if ($check_table === true) {\n                $exists = count($this->getTables(PREFIX_DB . 'database')) === 1;\n            } else {\n                $exists = true;\n            }\n\n            if ($exists === true) {\n                $select = $this->select('database');\n                $select->columns(\n                    array('version')\n                )->limit(1);\n\n                $results = $this->execute($select);\n                $result = $results->current();\n                return number_format(\n                    $result->version,\n                    3,\n                    '.',\n                    ''\n                );\n            } else {\n                return 0.63;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot check database version: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw new \\LogicException('Cannot check database version');\n        }\n    }\n\n    /**\n     * Check if database version suits our needs\n     *\n     * @return boolean\n     */\n    public function checkDbVersion()\n    {\n        if (GALETTE_MODE === 'DEV') {\n            Analog::log(\n                'Database version not checked in DEV mode.',\n                Analog::INFO\n            );\n            return true;\n        }\n\n        try {\n            return $this->getDbVersion() === GALETTE_DB_VERSION;\n        } catch (\\LogicException $e) {\n            return false;\n        }\n    }\n\n    /**\n     * Peform a select query on the whole table\n     *\n     * @param string $table Table name\n     *\n     * @return array\n     */\n    public function selectAll($table)\n    {\n        return $this->db->query(\n            'SELECT * FROM ' . PREFIX_DB . $table,\n            Adapter::QUERY_MODE_EXECUTE\n        );\n    }\n\n    /**\n     * Test if database can be contacted. Mostly used for installation\n     *\n     * @param string $type db type\n     * @param string $user database's user\n     * @param string $pass password for the user\n     * @param string $host which host we want to connect to\n     * @param string $port which tcp port we want to connect to\n     * @param string $db   database name\n     *\n     * @return true\n     */\n    public static function testConnectivity(\n        $type,\n        $user = null,\n        $pass = null,\n        $host = null,\n        $port = null,\n        $db = null\n    ) {\n        $_type = null;\n        try {\n            if ($type === self::MYSQL) {\n                $_type = 'Pdo_Mysql';\n            } elseif ($type === self::PGSQL) {\n                $_type = 'Pdo_Pgsql';\n            } else {\n                throw new \\Exception();\n            }\n\n            $_options = array(\n                'driver'   => $_type,\n                'hostname' => $host,\n                'port'     => $port,\n                'username' => $user,\n                'password' => $pass,\n                'database' => $db\n            );\n\n            $_db = new Adapter($_options);\n            $_db->getDriver()->getConnection()->connect();\n\n            return true;\n        } catch (Throwable $e) {\n            // perhaps failed to load the specified Adapter class\n            Analog::log(\n                '[' . __METHOD__ . '] Connection error (' . $e->getCode() . '|' .\n                $e->getMessage() . ')',\n                Analog::ALERT\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Drop test table if it exists, so we can make all checks.\n     *\n     * @return void\n     */\n    public function dropTestTable()\n    {\n        try {\n            $this->db->query('DROP TABLE IF EXISTS galette_test');\n            Analog::log('Test table successfully dropped.', Analog::DEBUG);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot drop test table! ' . $e->getMessage(),\n                Analog::WARNING\n            );\n        }\n    }\n\n    /**\n     * Checks GRANT access for install time\n     *\n     * @param string $mode are we at install time (i) or update time (u) ?\n     *\n     * @return array containing each test. Each array entry could\n     *           be either true or contains an exception of false if test did not\n     *           ran.\n     */\n    public function grantCheck($mode = 'i')\n    {\n        Analog::log(\n            'Check for database rights (mode ' . $mode . ')',\n            Analog::DEBUG\n        );\n        $stop = false;\n        $results = array(\n            'create' => false,\n            'insert' => false,\n            'select' => false,\n            'update' => false,\n            'delete' => false,\n            'drop'   => false\n        );\n        if ($mode === 'u') {\n            $results['alter'] = false;\n        }\n\n        //can Galette CREATE tables?\n        try {\n            $sql = 'CREATE TABLE galette_test (\n                test_id INTEGER NOT NULL,\n                test_text VARCHAR(20)\n            )';\n            $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n            $results['create'] = true;\n        } catch (Throwable $e) {\n            Analog::log('Cannot CREATE TABLE', Analog::WARNING);\n            //if we cannot create tables, we cannot check other permissions\n            $stop = true;\n            $results['create'] = $e;\n        }\n\n        //all those tests need the table to exists\n        if (!$stop) {\n            if ($mode == 'u') {\n                //can Galette ALTER tables? (only for update mode)\n                try {\n                    $sql = 'ALTER TABLE galette_test ALTER test_text SET DEFAULT \\'nothing\\'';\n                    $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n                    $results['alter'] = true;\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot ALTER TABLE | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['alter'] = $e;\n                }\n            }\n\n            //can Galette INSERT records ?\n            $values = array(\n                'test_id'      => 1,\n                'test_text'    => 'a simple text'\n            );\n            try {\n                $insert = $this->sql->insert('galette_test');\n                $insert->values($values);\n\n                $res = $this->execute($insert);\n\n                if ($res->count() === 1) {\n                    $results['insert'] = true;\n                } else {\n                    throw new \\Exception('No row inserted!');\n                }\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot INSERT records | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                //if we cannot insert records, some others tests cannot be done\n                $stop = true;\n                $results['insert'] = $e;\n            }\n\n            //all those tests need that the first record exists\n            if (!$stop) {\n                //can Galette UPDATE records ?\n                $values = array(\n                    'test_text' => 'another simple text'\n                );\n                try {\n                    $update = $this->sql->update('galette_test');\n                    $update->set($values)->where(\n                        array('test_id' => 1)\n                    );\n                    $res = $this->execute($update);\n                    if ($res->count() === 1) {\n                        $results['update'] = true;\n                    } else {\n                        throw new \\Exception('No row updated!');\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot UPDATE records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['update'] = $e;\n                }\n\n                //can Galette SELECT records ?\n                try {\n                    $select = $this->sql->select('galette_test');\n                    $select->where(['test_id' => 1]);\n                    $res = $this->execute($select);\n                    $pass = $res->count() === 1;\n\n                    if ($pass) {\n                        $results['select'] = true;\n                    } else {\n                        throw new \\Exception('Select is empty!');\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot SELECT records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['select'] = $e;\n                }\n\n                //can Galette DELETE records ?\n                try {\n                    $delete = $this->sql->delete('galette_test');\n                    $delete->where(array('test_id' => 1));\n                    $this->execute($delete);\n                    $results['delete'] = true;\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Cannot DELETE records | ' . $e->getMessage(),\n                        Analog::WARNING\n                    );\n                    $results['delete'] = $e;\n                }\n            }\n\n            //can Galette DROP tables ?\n            try {\n                $sql = 'DROP TABLE galette_test';\n                $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE);\n                $results['drop'] = true;\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot DROP TABLE | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                $results['drop'] = $e;\n            }\n        }\n\n        return $results;\n    }\n\n    /**\n     * Get a list of Galette's tables\n     *\n     * @param string $prefix Specified table prefix, PREFIX_DB if null\n     *\n     * @return array\n     */\n    public function getTables($prefix = null)\n    {\n        $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n        $tmp_tables_list = $metadata->getTableNames();\n\n        if ($prefix === null) {\n            $prefix = PREFIX_DB;\n        }\n\n        $tables_list = array();\n        //filter table_list: we only want PREFIX_DB tables\n        foreach ($tmp_tables_list as $t) {\n            if (preg_match('/^' . $prefix . '/', $t)) {\n                $tables_list[] = $t;\n            }\n        }\n        return $tables_list;\n    }\n\n    /**\n     * Get columns for a specified table\n     *\n     * @param string $table Table name\n     *\n     * @return array\n     */\n    public function getColumns($table)\n    {\n        $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n        $table = $metadata->getTable(PREFIX_DB . $table);\n        return $table->getColumns();\n    }\n\n    /**\n     * Converts recursively database to UTF-8\n     *\n     * @param string  $prefix       Specified table prefix\n     * @param boolean $content_only Proceed only content (no table conversion)\n     *\n     * @return void\n     */\n    public function convertToUTF($prefix = null, $content_only = false)\n    {\n        if ($this->isPostgres()) {\n            Analog::log(\n                'Cannot change encoding on PostgreSQL database',\n                Analog::INFO\n            );\n            return;\n        }\n        if ($prefix === null) {\n            $prefix = PREFIX_DB;\n        }\n\n        try {\n            $tables = $this->getTables($prefix);\n\n            foreach ($tables as $table) {\n                if ($content_only === false) {\n                    //Change whole table charset\n                    //CONVERT TO instruction will take care of each fields,\n                    //but converting data stay our problem.\n                    $query = 'ALTER TABLE ' . $table .\n                        ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci';\n\n                    $this->db->query(\n                        $query,\n                        Adapter::QUERY_MODE_EXECUTE\n                    );\n\n                    Analog::log(\n                        'Charset successfully changed for table `' . $table . '`',\n                        Analog::DEBUG\n                    );\n                }\n\n                //Data conversion\n                if ($table != $prefix . 'pictures') {\n                    $this->convertContentToUTF($prefix, $table);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while converting to utf table ' .\n                $table . ' (' . $e->getMessage() . ')',\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Converts dtabase content to UTF-8\n     *\n     * @param string $prefix Specified table prefix\n     * @param string $table  the table we want to convert datas from\n     *\n     * @return void\n     */\n    private function convertContentToUTF($prefix, $table)\n    {\n\n        try {\n            $query = 'SET NAMES latin1';\n            $this->db->query(\n                $query,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot SET NAMES on table `' . $table . '`. ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n\n        try {\n            $metadata = \\Laminas\\Db\\Metadata\\Source\\Factory::createSourceFromAdapter($this->db);\n            $tbl = $metadata->getTable($table);\n            $constraints = $tbl->getConstraints();\n            $pkeys = array();\n\n            foreach ($constraints as $constraint) {\n                if ($constraint->getType() === 'PRIMARY KEY') {\n                    $pkeys = $constraint->getColumns();\n                }\n            }\n\n            if (count($pkeys) == 0) {\n                //no primary key! How to do an update without that?\n                //Prior to 0.7, l10n and dynamic_fields tables does not\n                //contains any primary key. Since encoding conversion is done\n                //_before_ the SQL upgrade, we'll have to manually\n                //check these ones\n                if (preg_match('/' . $prefix . 'dynamic_fields/', $table) !== 0) {\n                    $pkeys = array(\n                        'item_id',\n                        'field_id',\n                        'field_form',\n                        'val_index'\n                    );\n                } elseif (preg_match('/' . $prefix . 'l10n/', $table) !== 0) {\n                    $pkeys = array(\n                        'text_orig',\n                        'text_locale'\n                    );\n                } else {\n                    //not a know case, we do not perform any update.\n                    throw new \\Exception(\n                        'Cannot define primary key for table `' . $table .\n                        '`, aborting'\n                    );\n                }\n            }\n\n            $select = $this->sql->select($table);\n            $results = $this->execute($select);\n\n            foreach ($results as $row) {\n                $data = array();\n                $where = array();\n\n                //build where\n                foreach ($pkeys as $k) {\n                    $where[$k] = $row->$k;\n                }\n\n                //build data\n                foreach ($row as $key => $value) {\n                    $data[$key] = $value;\n                }\n\n                //finally, update data!\n                $update = $this->sql->update($table);\n                $update->set($data)->where($where);\n                $this->execute($update);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while converting contents to UTF-8 for table ' .\n                $table . ' (' . $e->getMessage() . ')',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Is current database using Postgresql?\n     *\n     * @return boolean\n     */\n    public function isPostgres()\n    {\n        return $this->type_db === self::PGSQL;\n    }\n\n    /**\n     * Instanciate a select query\n     *\n     * @param string $table Table name, without prefix\n     * @param string $alias Tables alias, optionnal\n     *\n     * @return Select\n     */\n    public function select($table, $alias = null)\n    {\n        if ($alias === null) {\n            return $this->sql->select(\n                PREFIX_DB . $table\n            );\n        } else {\n            return $this->sql->select(\n                array(\n                    $alias => PREFIX_DB . $table\n                )\n            );\n        }\n    }\n\n    /**\n     * Instanciate an insert query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Insert\n     */\n    public function insert($table)\n    {\n        return $this->sql->insert(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Instanciate an update query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Update\n     */\n    public function update($table)\n    {\n        return $this->sql->update(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Instanciate a delete query\n     *\n     * @param string $table Table name, without prefix\n     *\n     * @return Delete\n     */\n    public function delete($table)\n    {\n        return $this->sql->delete(\n            PREFIX_DB . $table\n        );\n    }\n\n    /**\n     * Execute query string\n     *\n     * @param SqlInterface $sql SQL object\n     *\n     * @return StatementInterface|ResultSet\\ResultSet\n     */\n    public function execute($sql)\n    {\n        try {\n            $query_string = $this->sql->buildSqlString($sql);\n            $this->last_query = $query_string;\n            $this->log($query_string);\n            return $this->db->query(\n                $query_string,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n        } catch (Throwable $e) {\n            $msg = 'Query error: ';\n            if (isset($query_string)) {\n                $msg .= $query_string;\n            }\n            Analog::log(\n                $msg . ' ' . $e->__toString(),\n                Analog::ERROR\n            );\n            if ($sql instanceof Insert && $this->isDuplicateException($e)) {\n                throw new \\OverflowException('Duplicate entry', 0, $e);\n            }\n            throw $e;\n        }\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the variable we want to retrieve\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n            case 'db':\n                return $this->db;\n            case 'sql':\n                return $this->sql;\n            case 'driver':\n                return $this->db->getDriver();\n            case 'connection':\n                return $this->db->getDriver()->getConnection();\n            case 'platform':\n                return $this->db->getPlatform();\n            case 'query_string':\n                return $this->last_query;\n            case 'type_db':\n                return $this->type_db;\n        }\n    }\n\n    /**\n     * Get database information\n     *\n     * @return array\n     */\n    public function getInfos()\n    {\n        $infos = [\n            'engine'    => null,\n            'version'   => null,\n            'size'      => null,\n            'log_size'  => null,\n            'sql_mode'  => ''\n        ];\n\n        if ($this->isPostgres()) {\n            $infos['engine'] = 'PostgreSQL';\n            $sql = 'SHOW server_version';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n            $infos['version'] = $result['server_version'];\n\n            $sql = 'SELECT pg_database_size(\\'' . NAME_DB . '\\')';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n            $infos['size'] = (string)round($result['pg_database_size'] / 1024 / 1024);\n        } else {\n            $sql = 'SELECT @@sql_mode as mode, @@version AS version, @@version_comment AS version_comment';\n            $result = $this->db->query($sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n\n            $infos['engine']    = $result['version_comment'];\n            $infos['version']   = $result['version'];\n            $infos['sql_mode']  = $result['mode'];\n\n            $size_sql = 'SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 1) AS dbsize' .\n                ' FROM information_schema.tables WHERE table_schema=\"' . NAME_DB . '\"';\n            $result = $this->db->query($size_sql, Adapter::QUERY_MODE_EXECUTE)\n                ->current();\n\n            $infos['size'] = $result['dbsize'];\n        }\n\n        return $infos;\n    }\n\n    /**\n     * Handle sequence on PostgreSQL\n     *\n     * When inserting a value on a field with a sequence,\n     * this one is not incremented.\n     * This happens when installing system values (for status, titles, ...)\n     *\n     * @see https://bugs.galette.eu/issues/1158\n     * @see https://bugs.galette.eu/issues/1374\n     *\n     * @param string  $table    Table name\n     * @param integer $expected Expected value\n     *\n     * @return void\n     */\n    public function handleSequence($table, $expected)\n    {\n        if ($this->isPostgres()) {\n            //check for Postgres sequence\n            //see https://bugs.galette.eu/issues/1158\n            //see https://bugs.galette.eu/issues/1374\n            $seq = $table . '_id_seq';\n\n            $select = $this->select($seq);\n            $select->columns(['last_value']);\n            $results = $this->execute($select);\n            $result = $results->current();\n            if ($result->last_value < $expected) {\n                $this->db->query(\n                    'SELECT setval(\\'' . PREFIX_DB . $seq . '\\', ' . $expected . ')',\n                    Adapter::QUERY_MODE_EXECUTE\n                );\n            }\n        }\n    }\n\n    /**\n     * Check if current exception is on a duplicate key\n     *\n     * @param Throwable $exception Exception to check\n     *\n     * @return boolean\n     */\n    public function isDuplicateException($exception)\n    {\n        return $exception instanceof \\PDOException\n            && (\n                (!$this->isPostgres() && $exception->getCode() == 23000)\n                || ($this->isPostgres() && $exception->getCode() == 23505)\n            )\n        ;\n    }\n\n    /**\n     * Drops a table\n     *\n     * @param string  $table   Table name, without prefix\n     * @param boolean $maymiss Whether the table can be missing, defaults to false\n     *\n     * @return void\n     */\n    public function drop($table, $maymiss = false)\n    {\n        $sql = 'DROP TABLE ';\n        if ($maymiss === true) {\n            $sql .= 'IF EXISTS ';\n        }\n        $sql .= PREFIX_DB . $table;\n        $this->db->query(\n            $sql,\n            \\Laminas\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE\n        );\n    }\n\n    /**\n     * Log queries in specific file\n     *\n     * @param string $query Query to add in logs\n     *\n     * @return void\n     */\n    protected function log($query)\n    {\n        if (GALETTE_MODE == 'DEV' || defined('GALETTE_SQL_DEBUG')) {\n            $logfile = GALETTE_LOGS_PATH . 'galette_sql.log';\n            file_put_contents($logfile, $query . \"\\n\", FILE_APPEND);\n        }\n    }\n\n    /**\n     * Get last generated value\n     *\n     * @param object $entity Entity instance\n     *\n     * @return integer\n     */\n    public function getLastGeneratedValue($entity): int\n    {\n        return (int)$this->driver->getLastGeneratedValue(\n            $this->isPostgres() ?\n                PREFIX_DB . $entity::TABLE . '_id_seq'\n                : null\n        );\n    }\n\n    /**\n     * Get MySQL warnings\n     *\n     * @return array\n     */\n    public function getWarnings(): array\n    {\n        $results = $this->db->query('SHOW WARNINGS', Adapter::QUERY_MODE_EXECUTE);\n\n        $warnings = [];\n        foreach ($results as $result) {\n            $warnings[] = $result;\n        }\n\n        return $warnings;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Logo handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-09-13\n */\n\nnamespace Galette\\Core;\n\nuse Analog\\Analog;\n\n/**\n * This class stores and serve the logo.\n * If no custom logo is found, we take galette's default one.\n *\n * @category  Core\n * @name      Logo\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-09-13\n */\nclass Logo extends Picture\n{\n    protected $id = 'custom_logo';\n    //database wants a member id (integer), not a string.\n    //  Will be used to query the correct id\n    protected $db_id = 0;\n    protected $custom = true;\n\n    /**\n     * Default constructor.\n     */\n    public function __construct()\n    {\n        parent::__construct($this->id);\n    }\n\n    /**\n     * Gets the default picture to show, anyways\n     *\n     * @see Picture::getDefaultPicture()\n     *\n     * @return void\n     */\n    protected function getDefaultPicture()\n    {\n        $this->file_path = realpath(_CURRENT_THEME_PATH . 'images/galette.png');\n        $this->format = 'png';\n        $this->mime = 'image/png';\n        $this->custom = false;\n    }\n\n    /**\n     * Returns the relevant query to check if picture exists in database.\n     *\n     * @see picture::getCheckFileQuery()\n     *\n     * @return string SELECT query\n     */\n    protected function getCheckFileQuery()\n    {\n        global $zdb;\n\n        $select = $zdb->select(self::TABLE);\n        $select->columns(\n            array(\n                'picture',\n                'format'\n            )\n        );\n        $select->where([self::PK => $this->db_id]);\n        return $select;\n    }\n\n    /**\n     * Returns custom state\n     *\n     * @return boolean\n     */\n    public function isCustom()\n    {\n        return $this->custom;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Mailing features\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-08-27\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Filters\\MailingsList;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * Mailing features\n *\n * @category  Core\n * @name      MailingHistory\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-08-27\n */\nclass MailingHistory extends History\n{\n    public const TABLE = 'mailing_history';\n    public const PK = 'mailing_id';\n\n    public const FILTER_DC_SENT = 0;\n    public const FILTER_SENT = 1;\n    public const FILTER_NOT_SENT = 2;\n\n    private $mailing = null;\n    private $id;\n    private $date;\n    private $subject;\n    private $message;\n    private $recipients;\n    private $sender;\n    private $sender_name;\n    private $sender_address;\n    private $sent = false;\n\n    private $senders;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                $zdb         Database\n     * @param Login             $login       Login\n     * @param Preferences       $preferences Preferences\n     * @param MailingsList|null $filters     Filtering\n     * @param Mailing|null      $mailing     Mailing\n     */\n    public function __construct(Db $zdb, Login $login, Preferences $preferences, MailingsList $filters = null, Mailing $mailing = null)\n    {\n        parent::__construct($zdb, $login, $preferences, $filters);\n        $this->mailing = $mailing;\n    }\n\n    /**\n     * Get the entire history list\n     *\n     * @return array\n     */\n    public function getHistory()\n    {\n        try {\n            $select = $this->zdb->select($this->getTableName(), 'a');\n            $select->join(\n                array('b' => PREFIX_DB . Adherent::TABLE),\n                'a.mailing_sender=b.' . Adherent::PK,\n                array('nom_adh', 'prenom_adh'),\n                $select::JOIN_LEFT\n            );\n            $this->buildWhereClause($select);\n            $select->order($this->buildOrderClause());\n            $this->buildLists($select);\n            $this->proceedCount($select);\n            //add limits to retrieve only relevant rows\n            $this->filters->setLimits($select);\n            $results = $this->zdb->execute($select);\n\n            $ret = array();\n            foreach ($results as $r) {\n                if ($r['mailing_sender'] !== null && $r['mailing_sender_name'] === null) {\n                    $r['mailing_sender_name']\n                        = Adherent::getSName($this->zdb, $r['mailing_sender']);\n                }\n                $body_resume = $r['mailing_body'];\n                if (strlen($body_resume) > 150) {\n                    $body_resume = substr($body_resume, 0, 150);\n                    $body_resume .= '[...]';\n                }\n                if (function_exists('tidy_parse_string')) {\n                    //if tidy extension is present, we use it to clean a bit\n                    $tidy_config = array(\n                        'clean'             => true,\n                        'show-body-only'    => true,\n                        'wrap' => 0,\n                    );\n                    $tidy = tidy_parse_string($body_resume, $tidy_config, 'UTF8');\n                    $tidy->cleanRepair();\n                    $r['mailing_body_resume'] = tidy_get_output($tidy);\n                } else {\n                    //if it is not... Well, let's serve the text as it.\n                    $r['mailing_body_resume'] = $body_resume;\n                }\n\n                $attachments = 0;\n                if (file_exists(GALETTE_ATTACHMENTS_PATH . $r[self::PK])) {\n                    $rdi = new \\RecursiveDirectoryIterator(\n                        GALETTE_ATTACHMENTS_PATH . $r[self::PK],\n                        \\FilesystemIterator::SKIP_DOTS\n                    );\n                    $contents = new \\RecursiveIteratorIterator(\n                        $rdi,\n                        \\RecursiveIteratorIterator::CHILD_FIRST\n                    );\n                    foreach ($contents as $path) {\n                        if ($path->isFile()) {\n                            $attachments++;\n                        }\n                    }\n                }\n                $r['attachments'] = $attachments;\n                $ret[] = $r;\n            }\n            return $ret;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to get history. | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds users and actions lists\n     *\n     * @param \\Laminas\\Db\\Sql\\Select $select Original select\n     *\n     * @return void\n     */\n    private function buildLists($select)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->quantifier('DISTINCT')->columns(['mailing_sender']);\n            $select->order(['mailing_sender ASC']);\n\n            $results = $this->zdb->execute($select);\n\n            $this->senders = [];\n            foreach ($results as $result) {\n                $sender = $result->mailing_sender;\n                if ($sender != null) {\n                    $this->senders[$sender] = Adherent::getSName($this->zdb, (int)$sender);\n                } elseif ($result->mailing_sender_name != null || $result->mailing_sender_address != null) {\n                    $this->senders[$result->mailing_sender_address] = $result->mailing_sender_name;\n                } else {\n                    $this->senders[-1] = _('Superadmin');\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list senders from mailing history! | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the order clause\n     *\n     * @return string SQL ORDER clause\n     */\n    protected function buildOrderClause()\n    {\n        $order = array();\n\n        switch ($this->filters->orderby) {\n            case MailingsList::ORDERBY_DATE:\n                $order[] = 'mailing_date ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SENDER:\n                $order[] = 'mailing_sender ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SUBJECT:\n                $order[] = 'mailing_subject ' . $this->filters->ordered;\n                break;\n            case MailingsList::ORDERBY_SENT:\n                $order[] = 'mailing_sent ' . $this->filters->ordered;\n                break;\n        }\n\n        return $order;\n    }\n\n    /**\n     * Builds where clause, for filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return string SQL WHERE clause\n     */\n    private function buildWhereClause($select)\n    {\n        try {\n            if ($this->filters->start_date_filter != null) {\n                $d = new \\DateTime($this->filters->raw_start_date_filter);\n                $select->where->greaterThanOrEqualTo(\n                    'mailing_date',\n                    $d->format('Y-m-d')\n                );\n            }\n\n            if ($this->filters->end_date_filter != null) {\n                $d = new \\DateTime($this->filters->raw_end_date_filter);\n                $select->where->lessThanOrEqualTo(\n                    'mailing_date',\n                    $d->format('Y-m-d')\n                );\n            }\n\n            if ($this->filters->sender_filter != null && $this->filters->sender_filter != '0') {\n                $sender = $this->filters->sender_filter;\n                if ($sender == '-1') {\n                    $select->where('mailing_sender IS NULL');\n                } else {\n                    $select->where->equalTo(\n                        'mailing_sender',\n                        $sender\n                    );\n                }\n            }\n\n            switch ($this->filters->sent_filter) {\n                case self::FILTER_SENT:\n                    $select->where('mailing_sent = true');\n                    break;\n                case self::FILTER_NOT_SENT:\n                    $select->where('mailing_sent = false');\n                    break;\n                case self::FILTER_DC_SENT:\n                    //nothing to do here.\n                    break;\n            }\n\n\n            if ($this->filters->subject_filter != '') {\n                $token = $this->zdb->platform->quoteValue(\n                    '%' . strtolower($this->filters->subject_filter) . '%'\n                );\n\n                $select->where(\n                    'LOWER(mailing_subject) LIKE ' .\n                    $token\n                );\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Count history entries from the query\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function proceedCount($select)\n    {\n        try {\n            $countSelect = clone $select;\n            $countSelect->reset($countSelect::COLUMNS);\n            $countSelect->reset($countSelect::JOINS);\n            $countSelect->reset($countSelect::ORDER);\n            $countSelect->columns(\n                array(\n                    self::PK => new Expression('COUNT(' . self::PK . ')')\n                )\n            );\n\n            $results = $this->zdb->execute($countSelect);\n            $result = $results->current();\n\n            $k = self::PK;\n            $this->count = $result->$k;\n            if ($this->count > 0) {\n                $this->filters->setCounter($this->count);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot count history | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load mailing from an existing one\n     *\n     * @param Db             $zdb     Database instance\n     * @param integer        $id      Model identifier\n     * @param GaletteMailing $mailing Mailing object\n     * @param boolean        $new     True if we create a 'new' mailing,\n     *                                false otherwise (from preview for example)\n     *\n     * @return boolean\n     */\n    public static function loadFrom(Db $zdb, $id, $mailing, $new = true)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where(['mailing_id' => $id]);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n\n            return $mailing->loadFromHistory($result, $new);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to load mailing model #' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store a mailing in the history\n     *\n     * @param boolean $sent Defaults to false\n     *\n     * @return boolean\n     */\n    public function storeMailing($sent = false)\n    {\n        if ($this->mailing instanceof Mailing) {\n            if ($this->mailing->sender_name != null) {\n                $this->sender_name = $this->mailing->getSenderName();\n                $this->sender_address = $this->mailing->getSenderAddress();\n            }\n            $this->sender = $this->login->id;\n            $this->subject = $this->mailing->subject;\n            $this->message = $this->mailing->message;\n            $this->recipients = $this->mailing->recipients;\n            $this->sent = $sent;\n            $this->date = date('Y-m-d H:i:s');\n            if (!$this->mailing->existsInHistory()) {\n                $this->store();\n                $this->mailing->id = $this->id;\n                $this->mailing->moveAttachments($this->id);\n            } else {\n                if ($this->mailing->tmp_path !== false) {\n                    //attachments are still in a temporary path, move them\n                    $this->mailing->moveAttachments($this->id ?? $this->mailing->history_id);\n                }\n                //existing stored mailing. Just update row.\n                $this->update();\n            }\n        } else {\n            Analog::log(\n                '[' . __METHOD__ .\n                '] Mailing should be an instance of Mailing',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Update in the database\n     *\n     * @return boolean\n     */\n    public function update()\n    {\n        try {\n            $_recipients = array();\n            if ($this->recipients != null) {\n                foreach ($this->recipients as $_r) {\n                    $_recipients[$_r->id] = $_r->sname . ' <' . $_r->email . '>';\n                }\n            }\n\n            $sender = ($this->sender === 0) ?\n                new Expression('NULL') : $this->sender;\n            $sender_name = ($this->sender_name === null) ?\n                new Expression('NULL') : $this->sender_name;\n            $sender_address = ($this->sender_address === null) ?\n                new Expression('NULL') : $this->sender_address;\n\n            $values = array(\n                'mailing_sender'            => $sender,\n                'mailing_sender_name'       => $sender_name,\n                'mailing_sender_address'    => $sender_address,\n                'mailing_subject'           => $this->subject,\n                'mailing_body'              => $this->message,\n                'mailing_date'              => $this->date,\n                'mailing_recipients'        => serialize($_recipients),\n                'mailing_sent'              => ($this->sent) ?\n                    true :\n                    ($this->zdb->isPostgres() ? 'false' : 0)\n            );\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set($values);\n            $update->where([self::PK => $this->mailing->history_id]);\n            $this->zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurend updating Mailing | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store in the database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        try {\n            $_recipients = array();\n            if ($this->recipients != null) {\n                foreach ($this->recipients as $_r) {\n                    $_recipients[$_r->id] = $_r->sname . ' <' . $_r->email . '>';\n                }\n            }\n\n            $sender = null;\n            if ($this->sender === 0) {\n                $sender = new Expression('NULL');\n            } else {\n                $sender = $this->sender;\n            }\n            $sender_name = ($this->sender_name === null) ?\n                new Expression('NULL') : $this->sender_name;\n            $sender_address = ($this->sender_address === null) ?\n                new Expression('NULL') : $this->sender_address;\n\n            $values = array(\n                'mailing_sender'            => $sender,\n                'mailing_sender_name'       => $sender_name,\n                'mailing_sender_address'    => $sender_address,\n                'mailing_subject'           => $this->subject,\n                'mailing_body'              => $this->message,\n                'mailing_date'              => $this->date,\n                'mailing_recipients'        => serialize($_recipients),\n                'mailing_sent'              => ($this->sent) ?\n                    true :\n                    ($this->zdb->isPostgres() ? 'false' : 0)\n            );\n\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($values);\n            $this->zdb->execute($insert);\n\n            $this->id = $this->zdb->getLastGeneratedValue($this);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurend storing Mailing | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified entries\n     *\n     * @param integer|array $ids  Mailing history entries identifiers\n     * @param History       $hist History instance\n     *\n     * @return boolean\n     */\n    public function removeEntries($ids, History $hist)\n    {\n        $list = array();\n        if (is_numeric($ids)) {\n            //we've got only one identifier\n            $list[] = $ids;\n        } else {\n            $list = $ids;\n        }\n\n        if (is_array($list)) {\n            try {\n                foreach ($list as $id) {\n                    $mailing = new Mailing($this->preferences, [], $id);\n                    $mailing->removeAttachments();\n                }\n\n                $this->zdb->connection->beginTransaction();\n\n                //delete members\n                $delete = $this->zdb->delete(self::TABLE);\n                $delete->where->in(self::PK, $list);\n                $this->zdb->execute($delete);\n\n                //commit all changes\n                $this->zdb->connection->commit();\n\n                //add an history entry\n                $hist->add(\n                    _T(\"Delete mailing entries\")\n                );\n\n                return true;\n            } catch (Throwable $e) {\n                $this->zdb->connection->rollBack();\n                Analog::log(\n                    'Unable to delete selected mailing history entries |' .\n                    $e->getMessage(),\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } else {\n            //not numeric and not an array: incorrect.\n            Analog::log(\n                'Asking to remove mailing entries, but without ' .\n                'providing an array or a single numeric value.',\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Get table's name\n     *\n     * @param boolean $prefixed Whether table name should be prefixed\n     *\n     * @return string\n     */\n    protected function getTableName($prefixed = false)\n    {\n        if ($prefixed === true) {\n            return PREFIX_DB . self::TABLE;\n        } else {\n            return self::TABLE;\n        }\n    }\n\n    /**\n     * Get table's PK\n     *\n     * @return string\n     */\n    protected function getPk()\n    {\n        return self::PK;\n    }\n\n    /**\n     * Get count for current query\n     *\n     * @return int\n     */\n    public function getCount()\n    {\n        return $this->count;\n    }\n\n    /**\n     * Get senders list\n     *\n     * @return array\n     */\n    public function getSendersList()\n    {\n        return $this->senders;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Password for galette. The original code was found\n * in includes/functions.inc.php\n *\n * PHP version 5\n *\n * Copyright \u00a9 2003-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Georges Khaznadar (password encryption, images) <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2003-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-02-28\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Entity\\Adherent;\n\n/**\n * Temporary password management\n *\n * @category  Core\n * @name      Password\n * @package   Galette\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Georges Khaznadar (password encryption, images) <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-06-16\n */\n\nclass Password extends AbstractPassword\n{\n    public const TABLE = 'tmppasswds';\n    public const PK = Adherent::PK;\n\n    /** @var integer Overrides default password size */\n    public const DEFAULT_SIZE = 50;\n    /** @var string Overrides default character set */\n    protected $chars = 'abcdefghjkmnpqrstuvwxyz0123456789&@{[]}%#+*:ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    private $zdb;\n\n    /**\n     * Default constructor\n     *\n     * @param Db      $zdb   Database instance:\n     * @param boolean $clean Whether we should clean expired passwords in database\n     */\n    public function __construct(Db $zdb, bool $clean = true)\n    {\n        $this->zdb = $zdb;\n        if ($clean === true) {\n            $this->cleanExpired();\n        }\n    }\n\n    /**\n     * Remove all old password entries\n     *\n     * @param int $id_adh Member identifier\n     *\n     * @return boolean\n     */\n    private function removeOldEntries(int $id_adh): bool\n    {\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $id_adh]);\n\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Temporary passwords for `' . $id_adh . '` has been removed.',\n                    Analog::DEBUG\n                );\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error has occurred removing old tmppasswords ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Generates a new password for specified member\n     *\n     * @param int $id_adh Member identifier\n     *\n     * @return boolean\n     */\n    public function generateNewPassword($id_adh): bool\n    {\n        //first of all, we'll remove all existant entries for specified id\n        $this->removeOldEntries($id_adh);\n\n        //second, generate a new password and store it in the database\n        $password = $this->makeRandomPassword();\n        $hash = password_hash($password, PASSWORD_BCRYPT);\n\n        try {\n            $values = array(\n                self::PK               => $id_adh,\n                'tmp_passwd'           => $hash,\n                'date_crea_tmp_passwd' => date('Y-m-d H:i:s')\n            );\n\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($values);\n\n            $add = $this->zdb->execute($insert);\n            if ($add) {\n                Analog::log(\n                    'New passwords temporary set for `' . $id_adh . '`.',\n                    Analog::DEBUG\n                );\n                $this->setPassword($password);\n                $this->setHash($hash);\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                \"An error occurred trying to add temporary password entry. \" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove expired passwords queries (older than 24 hours)\n     *\n     * @return boolean\n     */\n    protected function cleanExpired(): bool\n    {\n        $date = new \\DateTime();\n        $date->sub(new \\DateInterval('PT24H'));\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where->lessThan(\n                'date_crea_tmp_passwd',\n                $date->format('Y-m-d H:i:s')\n            );\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Old Temporary passwords have been deleted.',\n                    Analog::DEBUG\n                );\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred deleting expired temporary passwords. ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Check if requested hash is valid\n     *\n     * @param string $hash the hash\n     *\n     * @return false|int false if hash is not valid, member id otherwise\n     */\n    public function isHashValid(string $hash)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array(self::PK)\n            )->where(array('tmp_passwd' => $hash));\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $pk = self::PK;\n                return $result->$pk;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred getting requested hash. ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove a hash that has been used (ie. once password has been updated)\n     *\n     * @param string $hash hash\n     *\n     * @return boolean\n     */\n    public function removeHash(string $hash): bool\n    {\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                array('tmp_passwd' => $hash)\n            );\n\n            $del = $this->zdb->execute($delete);\n            if ($del) {\n                Analog::log(\n                    'Used hash has been successfully remove',\n                    Analog::DEBUG\n                );\n                return true;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred attempting to delete used hash' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Picture handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2006-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Core\n * @package   Galette\n *\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2006-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\n\nnamespace Galette\\Core;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Repository\\Members;\nuse Galette\\IO\\FileInterface;\nuse Galette\\IO\\FileTrait;\n\n/**\n * Picture handling\n *\n * @name Picture\n * @category  Core\n * @package   Galette\n * @author    Fr\u00e9d\u00e9ric Jacquot <unknown@unknow.com>\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2006-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\nclass Picture implements FileInterface\n{\n    use FileTrait;\n\n    //constants that will not be overrided\n    public const SQL_ERROR = -10;\n    public const SQL_BLOB_ERROR = -11;\n    //constants that can be overrided\n    //(do not use self::CONSTANT, but get_class[$this]::CONSTANT)\n    public const TABLE = 'pictures';\n    public const PK = Adherent::PK;\n\n    protected $tbl_prefix = '';\n\n    protected $id;\n    protected $height;\n    protected $width;\n    protected $optimal_height;\n    protected $optimal_width;\n    protected $file_path;\n    protected $format;\n    protected $mime;\n    protected $has_picture = false;\n    protected $store_path = GALETTE_PHOTOS_PATH;\n    protected $max_width = 200;\n    protected $max_height = 200;\n    private $insert_stmt;\n\n    /**\n     * Default constructor.\n     *\n     * @param int $id_adh the id of the member\n     */\n    public function __construct($id_adh = '')\n    {\n\n        $this->init(\n            null,\n            array('jpeg', 'jpg', 'png', 'gif'),\n            array(\n                'jpg'    =>    'image/jpeg',\n                'png'    =>    'image/png',\n                'gif'    =>    'image/gif'\n            )\n        );\n\n        // '!==' needed, otherwise ''==0\n        if ($id_adh !== '' && $id_adh !== null) {\n            $this->id = $id_adh;\n            if (!isset($this->db_id)) {\n                $this->db_id = $id_adh;\n            }\n\n            //if file does not exists on the FileSystem, check for it in the database\n            if (!$this->checkFileOnFS()) {\n                if ($this->checkFileInDB()) {\n                    $this->has_picture = true;\n                }\n            } else {\n                $this->has_picture = true;\n            }\n        }\n\n        // if we still have no picture, take the default one\n        if (empty($this->file_path)) {\n            $this->getDefaultPicture();\n        }\n\n        //we should not have an empty file_path, but...\n        if (!empty($this->file_path)) {\n            $this->setSizes();\n        }\n    }\n\n    /**\n     * \"Magic\" function called on unserialize\n     *\n     * @return void\n     */\n    public function __wakeup()\n    {\n        //if file has been deleted since we store our object in the session,\n        //we try to retrieve it\n        if (!$this->checkFileOnFS()) {\n            //if file does not exists on the FileSystem,\n            //check for it in the database\n            //$this->checkFileInDB();\n        } else {\n            $this->has_picture = false;\n        }\n\n        // if we still have no picture, take the default one\n        if (empty($this->file_path)) {\n            $this->getDefaultPicture();\n        }\n\n        //we should not have an empty file_path, but...\n        if (!empty($this->file_path)) {\n            $this->setSizes();\n        }\n    }\n\n    /**\n     * Check if current file is present on the File System\n     *\n     * @return boolean true if file is present on FS, false otherwise\n     */\n    private function checkFileOnFS()\n    {\n        $file_wo_ext = $this->store_path . $this->id;\n        if (file_exists($file_wo_ext . '.jpg')) {\n            $this->file_path = realpath($file_wo_ext . '.jpg');\n            $this->format = 'jpg';\n            $this->mime = 'image/jpeg';\n            return true;\n        } elseif (file_exists($file_wo_ext . '.png')) {\n            $this->file_path = realpath($file_wo_ext . '.png');\n            $this->format = 'png';\n            $this->mime = 'image/png';\n            return true;\n        } elseif (file_exists($file_wo_ext . '.gif')) {\n            $this->file_path = realpath($file_wo_ext . '.gif');\n            $this->format = 'gif';\n            $this->mime = 'image/gif';\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if current file is present in the database,\n     *   and copy it to the File System\n     *\n     * @return boolean true if file is present in the DB, false otherwise\n     */\n    private function checkFileInDB()\n    {\n        global $zdb;\n\n        try {\n            $select = $this->getCheckFileQuery();\n            $results = $zdb->execute($select);\n            $pic = $results->current();\n\n            if ($pic) {\n                // we must regenerate the picture file\n                $file_wo_ext = $this->store_path . $this->id;\n                file_put_contents(\n                    $file_wo_ext . '.' . $pic->format,\n                    $pic->picture\n                );\n\n                $this->format = $pic->format;\n                switch ($this->format) {\n                    case 'jpg':\n                        $this->mime = 'image/jpeg';\n                        break;\n                    case 'png':\n                        $this->mime = 'image/png';\n                        break;\n                    case 'gif':\n                        $this->mime = 'image/gif';\n                        break;\n                }\n                $this->file_path = realpath($file_wo_ext . '.' . $this->format);\n                return true;\n            }\n        } catch (Throwable $e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns the relevant query to check if picture exists in database.\n     *\n     * @return string SELECT query\n     */\n    protected function getCheckFileQuery()\n    {\n        global $zdb;\n        $class = get_class($this);\n\n        $select = $zdb->select($this->tbl_prefix . $class::TABLE);\n        $select->columns(\n            array(\n                'picture',\n                'format'\n            )\n        );\n        $select->where(array($class::PK => $this->db_id));\n        return $select;\n    }\n\n    /**\n     * Gets the default picture to show, anyways\n     *\n     * @return void\n     */\n    protected function getDefaultPicture()\n    {\n        $this->file_path = realpath(_CURRENT_THEME_PATH . 'images/default.png');\n        $this->format = 'png';\n        $this->mime = 'image/png';\n        $this->has_picture = false;\n    }\n\n    /**\n     * Set picture sizes\n     *\n     * @return void\n     */\n    private function setSizes()\n    {\n        list($width, $height) = getimagesize($this->file_path);\n        $this->height = $height;\n        $this->width = $width;\n        $this->optimal_height = $height;\n        $this->optimal_width = $width;\n\n        if ($this->height > $this->width) {\n            if ($this->height > $this->max_height) {\n                $ratio = $this->max_height / $this->height;\n                $this->optimal_height = $this->max_height;\n                $this->optimal_width = $this->width * $ratio;\n            }\n        } else {\n            if ($this->width > $this->max_width) {\n                $ratio = $this->max_width / $this->width;\n                $this->optimal_width = $this->max_width;\n                $this->optimal_height = $this->height * $ratio;\n            }\n        }\n    }\n\n    /**\n     * Get image file contents\n     *\n     * @return mixed\n     */\n    public function getContents()\n    {\n        readfile($this->file_path);\n    }\n\n    /**\n     * Set header and displays the picture.\n     *\n     * @param Response $response Reponse\n     *\n     * @return object the binary file\n     */\n    public function display(\\Slim\\Http\\Response $response)\n    {\n        $response = $response->withHeader('Content-Type', $this->mime)\n            ->withHeader('Content-Transfer-Encoding', 'binary')\n            ->withHeader('Expires', '0')\n            ->withHeader('Cache-Control', 'must-revalidate')\n            ->withHeader('Pragma', 'public');\n\n        $stream = fopen('php://memory', 'r+');\n        fwrite($stream, file_get_contents($this->file_path));\n        rewind($stream);\n\n        return $response->withBody(new \\Slim\\Http\\Stream($stream));\n    }\n\n    /**\n     * Deletes a picture, from both database and filesystem\n     *\n     * @param boolean $transaction Whether to use a transaction here or not\n     *\n     * @return boolean true if image was successfully deleted, false otherwise\n     */\n    public function delete($transaction = true)\n    {\n        global $zdb;\n        $class = get_class($this);\n\n        try {\n            if ($transaction === true) {\n                $zdb->connection->beginTransaction();\n            }\n\n            $delete = $zdb->delete($this->tbl_prefix . $class::TABLE);\n            $delete->where([$class::PK => $this->db_id]);\n            $del = $zdb->execute($delete);\n\n            if (!$del->count() > 0) {\n                Analog::log(\n                    'Unable to remove picture database entry for ' . $this->db_id,\n                    Analog::ERROR\n                );\n                //it may be possible image is missing in the database.\n                //let's try to remove file anyway.\n            }\n\n            $file_wo_ext = $this->store_path . $this->id;\n\n            // take back default picture\n            $this->getDefaultPicture();\n            // fix sizes\n            $this->setSizes();\n\n            $success = false;\n            $_file = null;\n            if (file_exists($file_wo_ext . '.jpg')) {\n                //return unlink($file_wo_ext . '.jpg');\n                $_file = $file_wo_ext . '.jpg';\n                $success = unlink($_file);\n            } elseif (file_exists($file_wo_ext . '.png')) {\n                //return unlink($file_wo_ext . '.png');\n                $_file = $file_wo_ext . '.png';\n                $success = unlink($_file);\n            } elseif (file_exists($file_wo_ext . '.gif')) {\n                //return unlink($file_wo_ext . '.gif');\n                $_file = $file_wo_ext . '.gif';\n                $success = unlink($_file);\n            }\n\n            if ($_file !== null && $success !== true) {\n                //unable to remove file that exists!\n                if ($transaction === true) {\n                    $zdb->connection->rollBack();\n                }\n                Analog::log(\n                    'The file ' . $_file .\n                    ' was found on the disk but cannot be removed.',\n                    Analog::ERROR\n                );\n                return false;\n            } else {\n                if ($transaction === true) {\n                    $zdb->connection->commit();\n                }\n                $this->has_picture = false;\n                return true;\n            }\n        } catch (Throwable $e) {\n            if ($transaction === true) {\n                $zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred attempting to delete picture ' . $this->db_id .\n                'from database | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Stores an image on the disk and in the database\n     *\n     * @param object  $file the uploaded file\n     * @param boolean $ajax If the image cames from an ajax call (dnd)\n     *\n     * @return true|false result of the storage process\n     */\n    public function store($file, $ajax = false)\n    {\n        /** TODO: fix max size (by preferences ?) */\n        global $zdb;\n\n        $class = get_class($this);\n\n        $name = $file['name'];\n        $tmpfile = $file['tmp_name'];\n\n        //First, does the file have a valid name?\n        $reg = \"/^([^\" . implode('', $this->bad_chars) . \"]+)\\.(\" .\n            implode('|', $this->allowed_extensions) . \")$/i\";\n        if (preg_match($reg, $name, $matches)) {\n            Analog::log(\n                '[' . $class . '] Filename and extension are OK, proceed.',\n                Analog::DEBUG\n            );\n            $extension = strtolower($matches[2]);\n            if ($extension == 'jpeg') {\n                //jpeg is an allowed extension,\n                //but we change it to jpg to reduce further tests :)\n                $extension = 'jpg';\n            }\n        } else {\n            $erreg = \"/^([^\" . implode('', $this->bad_chars) . \"]+)\\.(.*)/i\";\n            $m = preg_match($erreg, $name, $errmatches);\n\n            $err_msg = '[' . $class . '] ';\n            if ($m == 1) {\n                //ok, we got a good filename and an extension. Extension is bad :)\n                $err_msg .= 'Invalid extension for file ' . $name . '.';\n                $ret = self::INVALID_EXTENSION;\n            } else {\n                $err_msg = 'Invalid filename `' . $name . '` (Tip: ';\n                $err_msg .= preg_replace(\n                    '|%s|',\n                    htmlentities($this->getBadChars()),\n                    \"file name should not contain any of: %s). \"\n                );\n                $ret = self::INVALID_FILENAME;\n            }\n\n            Analog::log(\n                $err_msg,\n                Analog::ERROR\n            );\n            return $ret;\n        }\n\n        //Second, let's check file size\n        if ($file['size'] > ($this->maxlenght * 1024)) {\n            Analog::log(\n                '[' . $class . '] File is too big (' . ($file['size'] * 1024) .\n                'Ko for maximum authorized ' . ($this->maxlenght * 1024) .\n                'Ko',\n                Analog::ERROR\n            );\n            return self::FILE_TOO_BIG;\n        } else {\n            Analog::log('[' . $class . '] Filesize is OK, proceed', Analog::DEBUG);\n        }\n\n        $current = getimagesize($tmpfile);\n\n        if (!in_array($current['mime'], $this->allowed_mimes)) {\n            Analog::log(\n                '[' . $class . '] Mimetype `' . $current['mime'] . '` not allowed',\n                Analog::ERROR\n            );\n            return self::MIME_NOT_ALLOWED;\n        } else {\n            Analog::log(\n                '[' . $class . '] Mimetype is allowed, proceed',\n                Analog::DEBUG\n            );\n        }\n\n        $this->delete();\n\n        $new_file = $this->store_path .\n            $this->id . '.' . $extension;\n        if ($ajax === true) {\n            rename($tmpfile, $new_file);\n        } else {\n            move_uploaded_file($tmpfile, $new_file);\n        }\n\n        // current[0] gives width ; current[1] gives height\n        if ($current[0] > $this->max_width || $current[1] > $this->max_height) {\n            /** FIXME: what if image cannot be resized?\n                Should'nt we want to stop the process here? */\n            $this->resizeImage($new_file, $extension);\n        }\n\n        return $this->storeInDb($zdb, $this->db_id, $new_file, $extension);\n    }\n\n    /**\n     * Stores an image in the database\n     *\n     * @param Db     $zdb  Database instance\n     * @param int    $id   Member ID\n     * @param string $file File path on disk\n     * @param string $ext  File extension\n     *\n     * @return boolean\n     */\n    private function storeInDb(Db $zdb, $id, $file, $ext)\n    {\n        $f = fopen($file, 'r');\n        $picture = '';\n        while ($r = fread($f, 8192)) {\n            $picture .= $r;\n        }\n        fclose($f);\n\n        $class = get_class($this);\n\n        try {\n            $zdb->connection->beginTransaction();\n            $stmt = $this->insert_stmt;\n            if ($stmt == null) {\n                $insert = $zdb->insert($this->tbl_prefix . $class::TABLE);\n                $insert->values(\n                    array(\n                        $class::PK  => ':' . $class::PK,\n                        'picture'   => ':picture',\n                        'format'    => ':format'\n                    )\n                );\n                $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n                $container = $stmt->getParameterContainer();\n                $container->offsetSet(\n                    'picture', //'picture',\n                    ':picture',\n                    $container::TYPE_LOB\n                );\n                $stmt->setParameterContainer($container);\n                $this->insert_stmt = $stmt;\n            }\n\n            $stmt->execute(\n                array(\n                    $class::PK  => $id,\n                    'picture'   => $picture,\n                    'format'    => $ext\n                )\n            );\n            $zdb->connection->commit();\n            $this->has_picture = true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            Analog::log(\n                'An error occurred storing picture in database: ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return self::SQL_ERROR;\n        }\n\n        return true;\n    }\n\n    /**\n     * Check for missing images in database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return void\n     */\n    public function missingInDb(Db $zdb)\n    {\n        $existing_disk = array();\n\n        //retrieve files on disk\n        if ($handle = opendir($this->store_path)) {\n            while (false !== ($entry = readdir($handle))) {\n                $reg = \"/^(\\d+)\\.(\" .\n                    implode('|', $this->allowed_extensions) . \")$/i\";\n                if (preg_match($reg, $entry, $matches)) {\n                    $id = $matches[1];\n                    $extension = strtolower($matches[2]);\n                    if ($extension == 'jpeg') {\n                        //jpeg is an allowed extension,\n                        //but we change it to jpg to reduce further tests :)\n                        $extension = 'jpg';\n                    }\n                    $existing_disk[$id] = array(\n                        'name'  => $entry,\n                        'id'    => $id,\n                        'ext'   => $extension\n                    );\n                }\n            }\n            closedir($handle);\n\n            if (count($existing_disk) === 0) {\n                //no image on disk, nothing to do :)\n                return;\n            }\n\n            //retrieve files in database\n            $class = get_class($this);\n            $select = $zdb->select($this->tbl_prefix . $class::TABLE);\n            $select\n                ->columns(array($class::PK))\n                ->where->in($class::PK, array_keys($existing_disk));\n\n            $results = $zdb->execute($select);\n\n            $existing_db = array();\n            foreach ($results as $result) {\n                $existing_db[] = (int)$result[self::PK];\n            }\n\n            $existing_diff = array_diff(array_keys($existing_disk), $existing_db);\n\n            //retrieve valid members ids\n            $members = new Members();\n            $valids = $members->getArrayList(\n                $existing_diff,\n                null,\n                false,\n                false,\n                array(self::PK)\n            );\n\n            foreach ($valids as $valid) {\n                $file = $existing_disk[$valid->id_adh];\n                $this->storeInDb(\n                    $zdb,\n                    $file['id'],\n                    $this->store_path . $file['id'] . '.' . $file['ext'],\n                    $file['ext']\n                );\n            }\n        } else {\n            Analog::log(\n                'Something went wrong opening images directory ' .\n                $this->store_path,\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Resize the image if it exceed max allowed sizes\n     *\n     * @param string $source the source image\n     * @param string $ext    file's extension\n     * @param string $dest   the destination image.\n     *                       If null, we'll use the source image. Defaults to null\n     *\n     * @return void\n     */\n    private function resizeImage($source, $ext, $dest = null)\n    {\n        $class = get_class($this);\n\n        if (function_exists(\"gd_info\")) {\n            $gdinfo = gd_info();\n            $h = $this->max_height;\n            $w = $this->max_width;\n            if ($dest == null) {\n                $dest = $source;\n            }\n\n            switch (strtolower($ext)) {\n                case 'jpg':\n                    if (!$gdinfo['JPEG Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no JPEG Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                case 'png':\n                    if (!$gdinfo['PNG Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no PNG Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                case 'gif':\n                    if (!$gdinfo['GIF Create Support']) {\n                        Analog::log(\n                            '[' . $class . '] GD has no GIF Support - ' .\n                            'pictures could not be resized!',\n                            Analog::ERROR\n                        );\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            list($cur_width, $cur_height, $cur_type, $curattr)\n                = getimagesize($source);\n\n            $ratio = $cur_width / $cur_height;\n\n            // calculate image size according to ratio\n            if ($cur_width > $cur_height) {\n                $h = $w / $ratio;\n            } else {\n                $w = $h * $ratio;\n            }\n\n            $thumb = imagecreatetruecolor($w, $h);\n            switch ($ext) {\n                case 'jpg':\n                    $image = imagecreatefromjpeg($source);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagejpeg($thumb, $dest);\n                    break;\n                case 'png':\n                    $image = imagecreatefrompng($source);\n                    // Turn off alpha blending and set alpha flag. That prevent alpha\n                    // transparency to be saved as an arbitrary color (black in my tests)\n                    imagealphablending($thumb, false);\n                    imagealphablending($image, false);\n                    imagesavealpha($thumb, true);\n                    imagesavealpha($image, true);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagepng($thumb, $dest);\n                    break;\n                case 'gif':\n                    $image = imagecreatefromgif($source);\n                    imagecopyresampled($thumb, $image, 0, 0, 0, 0, $w, $h, $cur_width, $cur_height);\n                    imagegif($thumb, $dest);\n                    break;\n            }\n        } else {\n            Analog::log(\n                '[' . $class . '] GD is not present - ' .\n                'pictures could not be resized!',\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Returns current file optimal height (resized)\n     *\n     * @return int optimal height\n     */\n    public function getOptimalHeight()\n    {\n        return (int)round($this->optimal_height, 1);\n    }\n\n    /**\n     * Returns current file height\n     *\n     * @return int current height\n     */\n    public function getHeight()\n    {\n        return $this->height;\n    }\n\n    /**\n     * Returns current file optimal width (resized)\n     *\n     * @return int optimal width\n     */\n    public function getOptimalWidth()\n    {\n        return (int)round($this->optimal_width, 1);\n    }\n\n    /**\n     * Returns current file width\n     *\n     * @return int current width\n     */\n    public function getWidth()\n    {\n        return $this->width;\n    }\n\n    /**\n     * Returns current file format\n     *\n     * @return string\n     */\n    public function getFormat()\n    {\n        return $this->format;\n    }\n\n    /**\n     * Have we got a picture ?\n     *\n     * @return bool True if a picture matches adherent's id, false otherwise\n     */\n    public function hasPicture()\n    {\n        return $this->has_picture;\n    }\n\n    /**\n     * Returns current file full path\n     *\n     * @return string full file path\n     */\n    public function getPath()\n    {\n        return $this->file_path;\n    }\n\n    /**\n     * Returns current mime type\n     *\n     * @return string\n     */\n    public function getMime()\n    {\n        return $this->mime;\n    }\n\n    /**\n     * Return textual error message\n     *\n     * @param int $code The error code\n     *\n     * @return string Localized message\n     */\n    public function getErrorMessage($code)\n    {\n        $error = null;\n        switch ($code) {\n            case self::SQL_ERROR:\n            case self::SQL_BLOB_ERROR:\n                $error = _T(\"An SQL error has occurred.\");\n                break;\n        }\n\n        if ($error === null) {\n            $error = $this->getErrorMessageFromCode($code);\n        }\n\n        return $error;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Abstract dynamic field\n *\n * PHP version 5\n *\n * Copyright \u00a9 2012-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  DynamicFields\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.1dev - 2012-07-28\n */\n\nnamespace Galette\\DynamicFields;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\Db;\nuse Galette\\Entity\\DynamicFieldsHandle;\nuse Galette\\Features\\Translatable;\nuse Galette\\Features\\I18n;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Predicate\\Expression as PredicateExpression;\n\n/**\n * Abstract dynamic field\n *\n * @name      DynamicField\n * @category  DynamicFields\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2014 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\n\nabstract class DynamicField\n{\n    use Translatable;\n    use I18n;\n\n    public const TABLE = 'field_types';\n    public const PK = 'field_id';\n\n    /** Separator field */\n    public const SEPARATOR = 0;\n    /** Simple text field */\n    public const TEXT = 1;\n    /** Line field */\n    public const LINE = 2;\n    /** Choice field (listbox) */\n    public const CHOICE = 3;\n    /** Date field */\n    public const DATE = 4;\n    /** Boolean field (checkbox) */\n    public const BOOLEAN = 5;\n    /** File field (upload) */\n    public const FILE = 6;\n\n    public const PERM_USER_WRITE = 0;\n    public const PERM_ADMIN = 1;\n    public const PERM_STAFF = 2;\n    public const PERM_MANAGER = 3;\n    public const PERM_USER_READ = 4;\n\n    public const DEFAULT_MAX_FILE_SIZE = 1024;\n    public const VALUES_FIELD_LENGTH = 100;\n\n    protected $has_data = false;\n    protected $has_width = false;\n    protected $has_height = false;\n    protected $has_size = false;\n    protected $multi_valued = false;\n    protected $fixed_values = false;\n    protected $has_permissions = true;\n\n    protected $id;\n    protected $index;\n    protected $perm;\n    protected $required;\n    protected $width;\n    protected $height;\n    protected $repeat;\n    protected $size;\n    protected $old_size;\n    protected $values;\n    protected $form;\n\n    protected $errors;\n\n    protected $zdb;\n\n    /**\n     * Default constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load field from its id\n     *\n     * @param Db  $zdb Database instance\n     * @param int $id  Field id\n     *\n     * @return DynamicField|false\n     */\n    public static function loadFieldType(Db $zdb, $id)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where(['field_id' => $id]);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $field_type = $result->field_type;\n                $field_type = self::getFieldType($zdb, $field_type);\n                $field_type->loadFromRs($result);\n                return $field_type;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | Unable to retrieve field `' . $id .\n                '` information | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n        return false;\n    }\n\n    /**\n     * Get correct field type instance\n     *\n     * @param Db  $zdb Database instance\n     * @param int $t   Field type\n     * @param int $id  Optional dynamic field id (to load data)\n     *\n     * @return DynamicField\n     */\n    public static function getFieldType(Db $zdb, $t, $id = null)\n    {\n        $df = null;\n        switch ($t) {\n            case self::SEPARATOR:\n                $df = new Separator($zdb, $id);\n                break;\n            case self::TEXT:\n                $df = new Text($zdb, $id);\n                break;\n            case self::LINE:\n                $df = new Line($zdb, $id);\n                break;\n            case self::CHOICE:\n                $df = new Choice($zdb, $id);\n                break;\n            case self::DATE:\n                $df = new Date($zdb, $id);\n                break;\n            case self::BOOLEAN:\n                $df = new Boolean($zdb, $id);\n                break;\n            case self::FILE:\n                $df = new File($zdb, $id);\n                break;\n            default:\n                throw new \\Exception('Unknown field type ' . $t . '!');\n                break;\n        }\n        return $df;\n    }\n\n    /**\n     * Load field\n     *\n     * @param integer $id Id\n     *\n     * @return void\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->where([self::PK => $id]);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if ($result) {\n                $this->loadFromRs($result);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to retrieve field type for field ' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Load field type from a db ResultSet\n     *\n     * @param ResultSet $rs     ResultSet\n     * @param boolean   $values Whether to load values. Defaults to true\n     *\n     * @return void\n     */\n    public function loadFromRs($rs, $values = true)\n    {\n        $this->id = (int)$rs->field_id;\n        $this->name = $rs->field_name;\n        $this->index = (int)$rs->field_index;\n        $this->perm = (int)$rs->field_perm;\n        $this->required = ($rs->field_required == 1 ? true : false);\n        $this->width = $rs->field_width;\n        $this->height = $rs->field_height;\n        $this->repeat = $rs->field_repeat;\n        $this->size = $rs->field_size;\n        $this->form = $rs->field_form;\n        if ($values && $this->hasFixedValues()) {\n            $this->loadFixedValues();\n        }\n    }\n\n    /**\n     * Retrieve fixed values table name\n     *\n     * @param integer $id       Field ID\n     * @param boolean $prefixed Whether table name should be prefixed\n     *\n     * @return string\n     */\n    public static function getFixedValuesTableName($id, $prefixed = false)\n    {\n        $name = 'field_contents_' . $id;\n        if ($prefixed === true) {\n            $name = PREFIX_DB . $name;\n        }\n        return $name;\n    }\n\n    /**\n     * Returns an array of fixed valued for a field of type 'choice'.\n     *\n     * @return void\n     */\n    private function loadFixedValues()\n    {\n        try {\n            $val_select = $this->zdb->select(\n                self::getFixedValuesTableName($this->id)\n            );\n\n            $val_select->columns(\n                array(\n                    'val'\n                )\n            )->order('id');\n\n            $results = $this->zdb->execute($val_select);\n            $this->values = array();\n            if ($results) {\n                foreach ($results as $val) {\n                    $this->values[] = $val->val;\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n        }\n    }\n\n    /**\n     * Get field type\n     *\n     * @return integer\n     */\n    abstract public function getType();\n\n    /**\n     * Get field type name\n     *\n     * @return String\n     */\n    public function getTypeName()\n    {\n        $types = $this->getFieldsTypesNames();\n        if (isset($types[$this->getType()])) {\n            return $types[$this->getType()];\n        } else {\n            throw new \\RuntimeException(\n                'Unknow type ' . $this->getType()\n            );\n        }\n    }\n\n    /**\n     * Does the field handle data?\n     *\n     * @return boolean\n     */\n    public function hasData()\n    {\n        return $this->has_data;\n    }\n\n    /**\n     * Does the field has width?\n     *\n     * @return boolean\n     */\n    public function hasWidth()\n    {\n        return $this->has_width;\n    }\n\n    /**\n     * Does the field has height?\n     *\n     * @return boolean\n     */\n    public function hasHeight()\n    {\n        return $this->has_height;\n    }\n\n    /**\n     * Does the field has a size?\n     *\n     * @return boolean\n     */\n    public function hasSize()\n    {\n        return $this->has_size;\n    }\n\n    /**\n     * Is the field multi valued?\n     *\n     * @return boolean\n     */\n    public function isMultiValued()\n    {\n        return $this->multi_valued;\n    }\n\n    /**\n     * Does the field has fixed values?\n     *\n     * @return boolean\n     */\n    public function hasFixedValues()\n    {\n        return $this->fixed_values;\n    }\n\n    /**\n     * Does the field require permissions?\n     *\n     * @return boolean\n     */\n    public function hasPermissions()\n    {\n        return $this->has_permissions;\n    }\n\n\n    /**\n     * Get field id\n     *\n     * @return integer\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Get field Permissions\n     *\n     * @return integer\n     */\n    public function getPerm()\n    {\n        return $this->perm;\n    }\n\n\n    /**\n     * Is field required?\n     *\n     * @return boolean\n     */\n    public function isRequired()\n    {\n        return $this->required;\n    }\n\n    /**\n     * Get field width\n     *\n     * @return integer\n     */\n    public function getWidth()\n    {\n        return $this->width;\n    }\n\n    /**\n     * Get field height\n     *\n     * @return integer\n     */\n    public function getHeight()\n    {\n        return $this->height;\n    }\n\n    /**\n     * Is current field repeatable?\n     *\n     * @return boolean\n     */\n    public function isRepeatable()\n    {\n        return $this->repeat != null && trim($this->repeat) != '' && (int)$this->repeat >= 0;\n    }\n\n    /**\n     * Get fields repetitions\n     *\n     * @return integer|boolean\n     */\n    public function getRepeat()\n    {\n        return $this->repeat;\n    }\n\n    /**\n     * Get field size\n     *\n     * @return integer\n     */\n    public function getSize()\n    {\n        return $this->size;\n    }\n\n    /**\n     * Get field index\n     *\n     * @return integer\n     */\n    public function getIndex()\n    {\n        return $this->index;\n    }\n\n    /**\n     * Retrieve permissions names for display\n     *\n     * @return array\n     */\n    public static function getPermsNames()\n    {\n        return [\n            self::PERM_USER_WRITE => _T(\"User, read/write\"),\n            self::PERM_STAFF      => _T(\"Staff member\"),\n            self::PERM_ADMIN      => _T(\"Administrator\"),\n            self::PERM_MANAGER    => _T(\"Group manager\"),\n            self::PERM_USER_READ  => _T(\"User, read only\")\n        ];\n    }\n\n    /**\n     * Retrieve forms names\n     *\n     * @return array\n     */\n    public static function getFormsNames()\n    {\n        return [\n            'adh'       => _T(\"Members\"),\n            'contrib'   => _T(\"Contributions\"),\n            'trans'     => _T(\"Transactions\")\n        ];\n    }\n\n    /**\n     * Retrieve form name\n     *\n     * @param string $form_name Form name\n     *\n     * @return string\n     */\n    public static function getFormTitle($form_name)\n    {\n        $names = self::getFormsNames();\n        return $names[$form_name];\n    }\n\n    /**\n     * Get permission name\n     *\n     * @return string\n     */\n    public function getPermName()\n    {\n        $perms = self::getPermsNames();\n        return $perms[$this->getPerm()];\n    }\n\n    /**\n     * Get form\n     *\n     * @return string\n     */\n    public function getForm()\n    {\n        return $this->form;\n    }\n\n    /**\n     * Get field values\n     *\n     * @param boolean $imploded Whether to implode values\n     *\n     * @return array\n     */\n    public function getValues($imploded = false)\n    {\n        if (!is_array($this->values)) {\n            return false;\n        }\n        if ($imploded === true) {\n            return implode(\"\\n\", $this->values);\n        } else {\n            return $this->values;\n        }\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values All values to check, basically the $_POST array\n     *                      after sending the form\n     *\n     * @return true|array\n     */\n    public function check($values)\n    {\n        $this->errors = [];\n        $this->warnings = [];\n\n        if (\n            (!isset($values['field_name']) || $values['field_name'] == '')\n            && get_class($this) != '\\Galette\\DynamicField\\Separator'\n        ) {\n            $this->errors[] = _T('Missing required field name!');\n        } else {\n            if ($this->old_name === null && $this->name !== null && $this->name != $values['field_name']) {\n                $this->old_name = $this->name;\n            }\n            $this->name = $values['field_name'];\n        }\n\n        if (!isset($values['field_perm']) || $values['field_perm'] === '') {\n            $this->errors[] = _T('Missing required field permissions!');\n        } else {\n            if (in_array($values['field_perm'], array_keys(self::getPermsNames()))) {\n                $this->perm = $values['field_perm'];\n            } else {\n                $this->errors[] = _T('Unknown permission!');\n            }\n        }\n\n        if ($this->id === null) {\n            if (!isset($values['form_name']) || $values['form_name'] == '') {\n                $this->errors[] = _T('Missing required form!');\n            } else {\n                if (in_array($values['form_name'], array_keys(self::getFormsNames()))) {\n                    $this->form = $values['form_name'];\n                } else {\n                    $this->errors[] = _T('Unknown form!');\n                }\n            }\n        }\n\n        $this->required = $values['field_required'] ?? false;\n\n        if (count($this->errors) === 0 && $this->isDuplicate($values['form_name'], $this->name, $this->id)) {\n            $this->errors[] = _T(\"- Field name already used.\");\n        }\n\n        if ($this->hasWidth() && isset($values['field_width']) && trim($values['field_width']) != '') {\n            $this->width = $values['field_width'];\n        }\n\n        if ($this->hasHeight() && isset($values['field_height']) && trim($values['field_height']) != '') {\n            $this->height = $values['field_height'];\n        }\n\n        if ($this->hasSize() && isset($values['field_size']) && trim($values['field_size']) != '') {\n            $this->size = $values['field_size'];\n        }\n\n        if (isset($values['field_repeat']) && trim($values['field_repeat']) != '') {\n            $this->repeat = $values['field_repeat'];\n        }\n\n        if ($this->hasFixedValues() && isset($values['fixed_values'])) {\n            $fixed_values = [];\n            foreach (explode(\"\\n\", $values['fixed_values']) as $val) {\n                $val = trim($val);\n                $len = mb_strlen($val);\n                if ($len > 0) {\n                    $fixed_values[] = $val;\n                    if ($len > $this->size) {\n                        if ($this->old_size === null) {\n                            $this->old_size = $this->size;\n                        }\n                        $this->size = $len;\n                    }\n                }\n            }\n\n            $this->values = $fixed_values;\n        }\n\n        if ($this->id == null) {\n            $this->index = $this->getNewIndex();\n        }\n\n        if (count($this->errors) === 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Store the field type\n     *\n     * @param array $values All values to check, basically the $_POST array\n     *                      after sending the form\n     *\n     * @return boolean\n     */\n    public function store($values)\n    {\n        if (!$this->check($values)) {\n            return false;\n        }\n\n        $isnew = ($this->id === null);\n        if ($this->old_name !== null) {\n            $this->deleteTranslation($this->old_name);\n            $this->addTranslation($this->name);\n        }\n\n        try {\n            $values = array(\n                'field_name'        => strip_tags($this->name),\n                'field_perm'        => $this->perm,\n                'field_required'    => $this->required,\n                'field_width'       => ($this->width === null ? new Expression('NULL') : $this->width),\n                'field_height'      => ($this->height === null ? new Expression('NULL') : $this->height),\n                'field_size'        => ($this->size === null ? new Expression('NULL') : $this->size),\n                'field_repeat'      => ($this->repeat === null ? new Expression('NULL') : $this->repeat),\n                'field_form'        => $this->form,\n                'field_index'       => $this->index\n            );\n\n            if ($this->required === false) {\n                //Handle booleans for postgres ; bugs #18899 and #19354\n                $values['field_required'] = $this->zdb->isPostgres() ? 'false' : 0;\n            }\n\n            if (!$isnew) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where([self::PK => $this->id]);\n                $this->zdb->execute($update);\n            } else {\n                $values['field_type'] = $this->getType();\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $this->zdb->execute($insert);\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                if ($this->name != '') {\n                    $this->addTranslation($this->name);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing field | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            $this->errors[] = _T(\"An error occurred storing the field.\");\n        }\n\n        if (count($this->errors) === 0 && $this->hasFixedValues()) {\n            $contents_table = self::getFixedValuesTableName($this->id, true);\n\n            try {\n                $this->zdb->drop(str_replace(PREFIX_DB, '', $contents_table), true);\n                $field_size = ((int)$this->size > 0) ? $this->size : 1;\n                $this->zdb->db->query(\n                    'CREATE TABLE ' . $contents_table .\n                    ' (id INTEGER NOT NULL,val varchar(' . $field_size .\n                    ') NOT NULL)',\n                    \\Laminas\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE\n                );\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Unable to manage fields values table ' .\n                    $contents_table . ' | ' . $e->getMessage(),\n                    Analog::ERROR\n                );\n                $this->errors[] = _T(\"An error occurred creating field values table\");\n            }\n\n            if (count($this->errors) == 0 && is_array($this->values)) {\n                $contents_table = self::getFixedValuesTableName($this->id);\n                try {\n                    $this->zdb->connection->beginTransaction();\n\n                    $insert = $this->zdb->insert($contents_table);\n                    $insert->values(\n                        array(\n                            'id'    => ':id',\n                            'val'   => ':val'\n                        )\n                    );\n                    $stmt = $this->zdb->sql->prepareStatementForSqlObject($insert);\n\n                    $cnt_values = count($this->values);\n                    for ($i = 0; $i < $cnt_values; $i++) {\n                        $stmt->execute(\n                            array(\n                                'id'    => $i,\n                                'val'   => $this->values[$i]\n                            )\n                        );\n                    }\n                    $this->zdb->connection->commit();\n                } catch (Throwable $e) {\n                    $this->zdb->connection->rollBack();\n                    Analog::log(\n                        'Unable to store field ' . $this->id . ' values (' .\n                        $e->getMessage() . ')',\n                        Analog::ERROR\n                    );\n                    $this->warnings[] = _T('An error occurred storing dynamic field values :(');\n                }\n            }\n        }\n\n        if (count($this->errors) === 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Get new index\n     *\n     * @return integer\n     */\n    protected function getNewIndex()\n    {\n        $select = $this->zdb->select(self::TABLE);\n        $select->columns(\n            array(\n                'idx' => new \\Laminas\\Db\\Sql\\Expression('COUNT(*) + 1')\n            )\n        );\n        $select->where(['field_form' => $this->form]);\n        $results = $this->zdb->execute($select);\n        $result = $results->current();\n        $idx = $result->idx;\n        return $idx;\n    }\n\n    /**\n     * Is field duplicated?\n     *\n     * @return boolean\n     */\n    public function isDuplicate()\n    {\n        //let's consider field is duplicated, in case of future errors\n        $duplicated = true;\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array(\n                    'cnt' => new \\Laminas\\Db\\Sql\\Expression('COUNT(' . self::PK . ')')\n                )\n            )->where(\n                array(\n                    'field_form' => $this->form,\n                    'field_name' => $this->name\n                )\n            );\n\n            if ($this->id !== null) {\n                $select->where->addPredicate(\n                    new PredicateExpression(\n                        'field_id NOT IN (?)',\n                        array($this->id)\n                    )\n                );\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dup = $result->cnt;\n            if (!$dup > 0) {\n                $duplicated = false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred checking field duplicity' . $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n        return $duplicated;\n    }\n    /**\n     * Move a dynamic field\n     *\n     * @param string $action What to do (either 'up' or 'down')\n     *\n     * @return boolean\n     */\n    public function move($action)\n    {\n        try {\n            $this->zdb->connection->beginTransaction();\n\n            $old_rank = $this->index;\n\n            $direction = $action == 'up' ? -1 : 1;\n            $new_rank = $old_rank + $direction;\n            $update = $this->zdb->update(self::TABLE);\n            $update->set([\n                    'field_index' => $old_rank\n            ])->where([\n                    'field_index'   => $new_rank,\n                    'field_form'    => $this->form\n            ]);\n            $this->zdb->execute($update);\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array(\n                    'field_index' => $new_rank\n                )\n            )->where(\n                array(\n                    self::PK        => $this->id\n                )\n            );\n            $this->zdb->execute($update);\n            $this->zdb->connection->commit();\n\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to change field ' . $this->id . ' rank | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Delete a dynamic field\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        try {\n            if ($this->hasFixedValues()) {\n                $contents_table = self::getFixedValuesTableName($this->id);\n                $this->zdb->drop($contents_table);\n            }\n\n            $this->zdb->connection->beginTransaction();\n            $old_rank = $this->index;\n\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array(\n                    'field_index' => new \\Laminas\\Db\\Sql\\Expression('field_index-1')\n                )\n            )->where\n                ->greaterThan('field_index', $old_rank)\n                ->equalTo('field_form', $this->form);\n            $this->zdb->execute($update);\n\n            //remove associated values\n            $delete = $this->zdb->delete(DynamicFieldsHandle::TABLE);\n            $delete->where(\n                array(\n                    'field_id'      => $this->id,\n                    'field_form'    => $this->form\n                )\n            );\n            $result = $this->zdb->execute($delete);\n            if (!$result) {\n                throw new \\RuntimeException('Unable to remove associated values for field ' . $this->id . '!');\n            }\n\n            //remove field type\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where(\n                array(\n                    'field_id'      => $this->id,\n                    'field_form'    => $this->form\n                )\n            );\n            $result = $this->zdb->execute($delete);\n            if (!$result) {\n                throw new \\RuntimeException('Unable to remove field ' . $this->id . '!');\n            }\n\n            $this->deleteTranslation($this->name);\n\n            $this->zdb->connection->commit();\n\n            return true;\n        } catch (Throwable $e) {\n            if ($this->zdb->connection->inTransaction()) {\n                //because of DROP autocommit on mysql...\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred deleting field | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Retrieve fields types names\n     *\n     * @return array\n     */\n    public static function getFieldsTypesNames()\n    {\n        $names = [\n            self::SEPARATOR => _T(\"separator\"),\n            self::TEXT      => _T(\"free text\"),\n            self::LINE      => _T(\"single line\"),\n            self::CHOICE    => _T(\"choice\"),\n            self::DATE      => _T(\"date\"),\n            self::BOOLEAN   => _T(\"boolean\"),\n            self::FILE      => _T(\"file\")\n        ];\n        return $names;\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get warnings\n     *\n     * @return array\n     */\n    public function getWarnings()\n    {\n        return $this->warnings;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Member class for galette\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-06-02\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Features\\Socials;\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Picture;\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Core\\Password;\nuse Galette\\Core\\Preferences;\nuse Galette\\Core\\History;\nuse Galette\\Repository\\Groups;\nuse Galette\\Core\\Login;\nuse Galette\\Repository\\Members;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Member class for galette\n *\n * @category  Entity\n * @name      Adherent\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 02-06-2009\n *\n * @property integer $id\n * @property integer|Title $title Either a title id or an instance of Title\n * @property string $stitle Title label\n * @property string company_name\n * @property string $name\n * @property string $surname\n * @property string $nickname\n * @property string $birthdate Localized birth date\n * @property string $rbirthdate Raw birth date\n * @property string $birth_place\n * @property integer $gender\n * @property string $sgender Gender label\n * @property string $job\n * @property string $language\n * @property integer $status\n * @property string $sstatus Status label\n * @property string $address\n * @property string $address_continuation\n * @property string $zipcode\n * @property string $town\n * @property string $country\n * @property string $phone\n * @property string $gsm\n * @property string $email\n * @property string $gnupgid\n * @property string $fingerprint\n * @property string $login\n * @property string $creation_date Localized creation date\n * @property string $modification_date Localized modification date\n * @property string $due_date Localized due date\n * @property string $others_infos\n * @property string $others_infos_admin\n * @property Picture $picture\n * @property array $groups\n * @property array $managed_groups\n * @property integer|Adherent $parent Parent id if parent dep is not loaded, Adherent instance otherwise\n * @property array $children\n * @property boolean $admin better to rely on isAdmin()\n * @property boolean $staff better to rely on isStaff()\n * @property boolean $due_free better to rely on isDueFree()\n * @property boolean $appears_in_list better to rely on appearsInMembersList()\n * @property boolean $active better to rely on isActive()\n * @property boolean $duplicate better to rely on isDuplicate()\n * @property string $sadmin yes/no\n * @property string $sstaff yes/no\n * @property string $sdue_free yes/no\n * @property string $sappears_in_list yes/no\n * @property string $sactive yes/no\n * @property string $sfullname\n * @property string $sname\n * @property string $saddress Concatened address and continuation\n * @property string $contribstatus State of member contributions\n * @property string $days_remaining\n * @property-read integer $parent_id\n * @property Social $social Social networks/Contact\n * @property string $number Member number\n *\n */\nclass Adherent\n{\n    use Dynamics;\n    use Socials;\n\n    public const TABLE = 'adherents';\n    public const PK = 'id_adh';\n\n    public const NC = 0;\n    public const MAN = 1;\n    public const WOMAN = 2;\n\n    public const AFTER_ADD_DEFAULT = 0;\n    public const AFTER_ADD_TRANS = 1;\n    public const AFTER_ADD_NEW = 2;\n    public const AFTER_ADD_SHOW = 3;\n    public const AFTER_ADD_LIST = 4;\n    public const AFTER_ADD_HOME = 5;\n\n    private $_id;\n    //Identity\n    private $_title;\n    private $_company_name;\n    private $_name;\n    private $_surname;\n    private $_nickname;\n    private $_birthdate;\n    private $_birth_place;\n    private $_gender;\n    private $_job;\n    private $_language;\n    private $_active;\n    private $_status;\n    //Contact information\n    private $_address;\n    private $_address_continuation; /** TODO: remove */\n    private $_zipcode;\n    private $_town;\n    private $_country;\n    private $_phone;\n    private $_gsm;\n    private $_email;\n    private $_gnupgid;\n    private $_fingerprint;\n    //Galette relative information\n    private $_appears_in_list;\n    private $_admin;\n    private $_staff;\n    private $_due_free;\n    private $_login;\n    private $_password;\n    private $_creation_date;\n    private $_modification_date;\n    private $_due_date;\n    private $_others_infos;\n    private $_others_infos_admin;\n    private $_picture;\n    private $_oldness;\n    private $_days_remaining;\n    private $_groups;\n    private $_managed_groups;\n    private $_parent;\n    private $_children;\n    private $_duplicate = false;\n    private $_socials;\n    private $_number;\n\n    private $_row_classes;\n\n    private $_self_adh = false;\n    private $_deps = array(\n        'picture'   => true,\n        'groups'    => true,\n        'dues'      => true,\n        'parent'    => false,\n        'children'  => false,\n        'dynamics'  => false,\n        'socials'   => false\n    );\n\n    private $zdb;\n    private $preferences;\n    private $fields;\n    private $history;\n\n    private $parent_fields = [\n        'adresse_adh',\n        'adresse2_adh',\n        'cp_adh',\n        'ville_adh',\n        'email_adh'\n    ];\n\n    private $errors = [];\n\n    private $sendmail = false;\n\n    /**\n     * Default constructor\n     *\n     * @param Db          $zdb  Database instance\n     * @param mixed       $args Either a ResultSet row, its id or its\n     *                          login or its email for to load s specific\n     *                          member, or null to just instantiate object\n     * @param false|array $deps Dependencies configuration, see Adherent::$_deps\n     */\n    public function __construct(Db $zdb, $args = null, $deps = null)\n    {\n        global $i18n;\n\n        $this->zdb = $zdb;\n\n        if ($deps !== null) {\n            if (is_array($deps)) {\n                $this->_deps = array_merge(\n                    $this->_deps,\n                    $deps\n                );\n            } elseif ($deps === false) {\n                //no dependencies\n                $this->_deps = array_fill_keys(\n                    array_keys($this->_deps),\n                    false\n                );\n            } else {\n                Analog::log(\n                    '$deps should be an array, ' . gettype($deps) . ' given!',\n                    Analog::WARNING\n                );\n            }\n        }\n\n        if ($args == null || is_int($args)) {\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            } else {\n                $this->_active = true;\n                $this->_language = $i18n->getID();\n                $this->_creation_date = date(\"Y-m-d\");\n                $this->_status = $this->getDefaultStatus();\n                $this->_title = null;\n                $this->_gender = self::NC;\n                $gp = new Password($this->zdb);\n                $this->_password = $gp->makeRandomPassword();\n                $this->_picture = new Picture();\n                $this->_admin = false;\n                $this->_staff = false;\n                $this->_due_free = false;\n                $this->_appears_in_list = false;\n                $this->_parent = null;\n\n                if ($this->_deps['dynamics'] === true) {\n                    $this->loadDynamicFields();\n                }\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        } elseif (is_string($args)) {\n            $this->loadFromLoginOrMail($args);\n        }\n    }\n\n    /**\n     * Loads a member from its id\n     *\n     * @param int $id the identifier for the member to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'a');\n\n            $select->join(\n                array('b' => PREFIX_DB . Status::TABLE),\n                'a.' . Status::PK . '=b.' . Status::PK,\n                array('priorite_statut')\n            )->where(array(self::PK => $id));\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() === 0) {\n                return false;\n            }\n\n            $this->loadFromRS($results->current());\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member form id `' . $id . '` | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads a member from its login\n     *\n     * @param string $login login for the member to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function loadFromLoginOrMail($login)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            if (GaletteMail::isValidEmail($login)) {\n                //we got a valid email address, use it\n                $select->where(array('email_adh' => $login));\n            } else {\n                ///we did not get an email address, consider using login\n                $select->where(array('login_adh' => $login));\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $this->loadFromRS($result);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member form login `' . $login . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->_self_adh = false;\n        $this->_id = $r->id_adh;\n        //Identity\n        if ($r->titre_adh !== null) {\n            $this->_title = new Title((int)$r->titre_adh);\n        }\n        $this->_company_name = $r->societe_adh;\n        $this->_name = $r->nom_adh;\n        $this->_surname = $r->prenom_adh;\n        $this->_nickname = $r->pseudo_adh;\n        if ($r->ddn_adh != '1901-01-01') {\n            $this->_birthdate = $r->ddn_adh;\n        }\n        $this->_birth_place = $r->lieu_naissance;\n        $this->_gender = (int)$r->sexe_adh;\n        $this->_job = $r->prof_adh;\n        $this->_language = $r->pref_lang;\n        $this->_active = ($r->activite_adh == 1) ? true : false;\n        $this->_status = (int)$r->id_statut;\n        //Contact information\n        $this->_address = $r->adresse_adh;\n        /** TODO: remove and merge with address */\n        $this->_address_continuation = $r->adresse2_adh;\n        $this->_zipcode = $r->cp_adh;\n        $this->_town = $r->ville_adh;\n        $this->_country = $r->pays_adh;\n        $this->_phone = $r->tel_adh;\n        $this->_gsm = $r->gsm_adh;\n        $this->_email = $r->email_adh;\n        $this->_gnupgid = $r->gpgid;\n        $this->_fingerprint = $r->fingerprint;\n        //Galette relative information\n        $this->_appears_in_list = ($r->bool_display_info == 1) ? true : false;\n        $this->_admin = ($r->bool_admin_adh == 1) ? true : false;\n        if (\n            isset($r->priorite_statut)\n            && $r->priorite_statut < Members::NON_STAFF_MEMBERS\n        ) {\n            $this->_staff = true;\n        }\n        $this->_due_free = ($r->bool_exempt_adh == 1) ? true : false;\n        $this->_login = $r->login_adh;\n        $this->_password = $r->mdp_adh;\n        $this->_creation_date = $r->date_crea_adh;\n        if ($r->date_modif_adh != '1901-01-01') {\n            $this->_modification_date = $r->date_modif_adh;\n        } else {\n            $this->_modification_date = $this->_creation_date;\n        }\n        $this->_due_date = $r->date_echeance;\n        $this->_others_infos = $r->info_public_adh;\n        $this->_others_infos_admin = $r->info_adh;\n        $this->_number = $r->num_adh;\n\n        if ($r->parent_id !== null) {\n            $this->_parent = (int)$r->parent_id;\n            if ($this->_deps['parent'] === true) {\n                $this->loadParent();\n            }\n        }\n\n        if ($this->_deps['children'] === true) {\n            $this->loadChildren();\n        }\n\n        if ($this->_deps['picture'] === true) {\n            $this->_picture = new Picture($this->_id);\n        }\n\n        if ($this->_deps['groups'] === true) {\n            $this->loadGroups();\n        }\n\n        if ($this->_deps['dues'] === true) {\n            $this->checkDues();\n        }\n\n        if ($this->_deps['dynamics'] === true) {\n            $this->loadDynamicFields();\n        }\n\n        if ($this->_deps['socials'] === true) {\n            $this->loadSocials();\n        }\n    }\n\n    /**\n     * Load member parent\n     *\n     * @return void\n     */\n    private function loadParent()\n    {\n        if (!$this->_parent instanceof Adherent) {\n            $deps = array_fill_keys(array_keys($this->_deps), false);\n            $this->_parent = new Adherent($this->zdb, (int)$this->_parent, $deps);\n        }\n    }\n\n    /**\n     * Load member children\n     *\n     * @return void\n     */\n    private function loadChildren()\n    {\n        $this->_children = array();\n        try {\n            $id = self::PK;\n            $select = $this->zdb->select(self::TABLE);\n            $select->columns(\n                array($id)\n            )->where(['parent_id' => $this->_id]);\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() > 0) {\n                foreach ($results as $row) {\n                    $deps = $this->_deps;\n                    $deps['children'] = false;\n                    $deps['parent'] = false;\n                    $this->_children[] = new Adherent($this->zdb, (int)$row->$id, $deps);\n                }\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load children for member #' . $this->_id . ' | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load member groups\n     *\n     * @return void\n     */\n    public function loadGroups()\n    {\n        $this->_groups = Groups::loadGroups($this->_id);\n        $this->_managed_groups = Groups::loadManagedGroups($this->_id);\n    }\n\n    /**\n     * Load member social network/contact information\n     *\n     * @return void\n     */\n    public function loadSocials()\n    {\n        $this->_socials = Social::getListForMember($this->_id);\n    }\n\n    /**\n     * Retrieve status from preferences\n     *\n     * @return pref_statut\n     *\n     */\n    private function getDefaultStatus()\n    {\n        global $preferences;\n        if ($preferences->pref_statut != '') {\n            return $preferences->pref_statut;\n        } else {\n            Analog::log(\n                'Unable to get pref_statut; is it defined in preferences?',\n                Analog::ERROR\n            );\n            return Status::DEFAULT_STATUS;\n        }\n    }\n\n    /**\n     * Check for dues status\n     *\n     * @return void\n     */\n    private function checkDues()\n    {\n        //how many days since our beloved member has been created\n        $date_now = new \\DateTime();\n        $this->_oldness = $date_now->diff(\n            new \\DateTime($this->_creation_date)\n        )->days;\n\n        if ($this->isDueFree()) {\n            //no fee required, we don't care about dates\n            $this->_row_classes .= ' cotis-exempt';\n        } else {\n            //ok, fee is required. Let's check the dates\n            if ($this->_due_date == '') {\n                $this->_row_classes .= ' cotis-never';\n            } else {\n                $date_end = new \\DateTime($this->_due_date);\n                $date_diff = $date_now->diff($date_end);\n                $this->_days_remaining = ($date_diff->invert == 1)\n                    ? $date_diff->days * -1\n                    : $date_diff->days;\n\n                if ($this->_days_remaining == 0) {\n                    $this->_row_classes .= ' cotis-lastday';\n                } elseif ($this->_days_remaining < 0) {\n                    //check if member is still active\n                    $this->_row_classes .= $this->isActive() ? ' cotis-late' : ' cotis-old';\n                } elseif ($this->_days_remaining < 30) {\n                    $this->_row_classes .= ' cotis-soon';\n                } else {\n                    $this->_row_classes .= ' cotis-ok';\n                }\n            }\n        }\n    }\n\n    /**\n     * Is member admin?\n     *\n     * @return bool\n     */\n    public function isAdmin()\n    {\n        return $this->_admin;\n    }\n\n    /**\n     * Is user member of staff?\n     *\n     * @return bool\n     */\n    public function isStaff()\n    {\n        return $this->_staff;\n    }\n\n    /**\n     * Is member freed of dues?\n     *\n     * @return bool\n     */\n    public function isDueFree()\n    {\n        return $this->_due_free;\n    }\n\n    /**\n     * Is member in specified group?\n     *\n     * @param string $group_name Group name\n     *\n     * @return boolean\n     */\n    public function isGroupMember($group_name)\n    {\n        if (is_array($this->_groups)) {\n            foreach ($this->_groups as $g) {\n                if ($g->getName() == $group_name) {\n                    return true;\n                    break;\n                }\n            }\n        } else {\n            Analog::log(\n                'Calling ' . __METHOD__ . ' without groups loaded!',\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Is member manager of specified group?\n     *\n     * @param string $group_name Group name\n     *\n     * @return boolean\n     */\n    public function isGroupManager($group_name)\n    {\n        if (is_array($this->_managed_groups)) {\n            foreach ($this->_managed_groups as $mg) {\n                if ($mg->getName() == $group_name) {\n                    return true;\n                    break;\n                }\n            }\n        } else {\n            Analog::log(\n                'Calling ' . __METHOD__ . ' without groups loaded!',\n                Analog::ERROR\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Does current member represents a company?\n     *\n     * @return boolean\n     */\n    public function isCompany()\n    {\n        return trim($this->_company_name ?? '') != '';\n    }\n\n    /**\n     * Is current member a man?\n     *\n     * @return boolean\n     */\n    public function isMan()\n    {\n        return (int)$this->_gender === self::MAN;\n    }\n\n    /**\n     * Is current member a woman?\n     *\n     * @return boolean\n     */\n    public function isWoman()\n    {\n        return (int)$this->_gender === self::WOMAN;\n    }\n\n\n    /**\n     * Can member appears in public members list?\n     *\n     * @return bool\n     */\n    public function appearsInMembersList()\n    {\n        return $this->_appears_in_list;\n    }\n\n    /**\n     * Is member active?\n     *\n     * @return bool\n     */\n    public function isActive()\n    {\n        return $this->_active;\n    }\n\n    /**\n     * Does member have uploaded a picture?\n     *\n     * @return bool\n     */\n    public function hasPicture()\n    {\n        return $this->_picture->hasPicture();\n    }\n\n    /**\n     * Does member have a parent?\n     *\n     * @return bool\n     */\n    public function hasParent()\n    {\n        return !empty($this->_parent);\n    }\n\n    /**\n     * Does member have children?\n     *\n     * @return bool\n     */\n    public function hasChildren()\n    {\n        if ($this->_children === null) {\n            if ($this->id) {\n                Analog::log(\n                    'Children has not been loaded!',\n                    Analog::WARNING\n                );\n            }\n            return false;\n        } else {\n            return count($this->_children) > 0;\n        }\n    }\n\n    /**\n     * Get row class related to current fee status\n     *\n     * @param boolean $public we want the class for public pages\n     *\n     * @return string the class to apply\n     */\n    public function getRowClass($public = false)\n    {\n        $strclass = ($this->isActive()) ? 'active' : 'inactive';\n        if ($public === false) {\n            $strclass .= $this->_row_classes;\n        }\n        return $strclass;\n    }\n\n    /**\n     * Get current member due status\n     *\n     * @return string i18n string representing state of due\n     */\n    public function getDues()\n    {\n        $ret = '';\n        $date_now = new \\DateTime();\n        if ($this->isDueFree()) {\n            $ret = _T(\"Freed of dues\");\n        } elseif ($this->_due_date == '') {\n            $patterns = array('/%days/', '/%date/');\n            $cdate = new \\DateTime($this->_creation_date);\n            $replace = array(\n                $this->_oldness,\n                $cdate->format(__(\"Y-m-d\"))\n            );\n            if ($this->_active) {\n                $ret = preg_replace(\n                    $patterns,\n                    $replace,\n                    _T(\"Never contributed: Registered %days days ago (since %date)\")\n                );\n            } else {\n                $ret = _T(\"Never contributed\");\n            }\n        } elseif ($this->_days_remaining == 0) {\n            $ddate = new \\DateTime($this->_due_date);\n            $date_diff = $date_now->diff($ddate);\n            if ($date_diff->invert == 0) {\n                $ret = _T(\"Last day!\");\n            } else {\n                $ret = _T(\"Late since today!\");\n            }\n        } elseif ($this->_days_remaining < 0) {\n            $ddate = new \\DateTime($this->_due_date);\n            $patterns = array('/%days/', '/%date/');\n            $replace = array(\n                $this->_days_remaining * -1,\n                $ddate->format(__(\"Y-m-d\"))\n            );\n            if ($this->_active) {\n                $ret = preg_replace(\n                    $patterns,\n                    $replace,\n                    _T(\"Late of %days days (since %date)\")\n                );\n            } else {\n                $ret = _T(\"No longer member\");\n            }\n        } else {\n            $ddate = new \\DateTime($this->_due_date);\n            $patterns = array('/%days/', '/%date/');\n            $replace = array(\n                $this->_days_remaining,\n                $ddate->format(__(\"Y-m-d\"))\n            );\n            $ret = preg_replace(\n                $patterns,\n                $replace,\n                _T(\"%days days remaining (ending on %date)\")\n            );\n        }\n        return $ret;\n    }\n\n    /**\n     * Retrieve Full name and surname for the specified member id\n     *\n     * @param Db      $zdb   Database instance\n     * @param integer $id    Member id\n     * @param boolean $wid   Add member id\n     * @param boolean $wnick Add member nickname\n     *\n     * @return string formatted Name and Surname\n     */\n    public static function getSName($zdb, $id, $wid = false, $wnick = false)\n    {\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where([self::PK => $id]);\n\n            $results = $zdb->execute($select);\n            $row = $results->current();\n            return self::getNameWithCase(\n                $row->nom_adh,\n                $row->prenom_adh,\n                false,\n                ($wid === true ? $row->id_adh : false),\n                ($wnick === true ? $row->pseudo_adh : false)\n            );\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot get formatted name for member form id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get member name with correct case\n     *\n     * @param string        $name    Member name\n     * @param string        $surname Mmeber surname\n     * @param false|Title   $title   Member title to show or false\n     * @param false|integer $id      Member id to display or false\n     * @param false|string  $nick    Member nickname to display or false\n     *\n     * @return string\n     */\n    public static function getNameWithCase($name, $surname, $title = false, $id = false, $nick = false)\n    {\n        $str = '';\n\n        if ($title !== false && $title instanceof Title) {\n            $str .= $title->tshort . ' ';\n        }\n\n        $str .= mb_strtoupper($name ?? '', 'UTF-8') . ' ' .\n            ucwords(mb_strtolower($surname ?? '', 'UTF-8'), \" \\t\\r\\n\\f\\v-_|\");\n\n        if ($id !== false || $nick !== false) {\n            $str .= ' (';\n        }\n        if ($nick !== false) {\n            $str .= $nick;\n        }\n        if ($id !== false) {\n            if ($nick !== false && !empty($nick)) {\n                $str .= ', ';\n            }\n            $str .= $id;\n        }\n        if ($id !== false || $nick !== false) {\n            $str .= ')';\n        }\n        return strip_tags($str);\n    }\n\n    /**\n     * Change password for a given user\n     *\n     * @param Db     $zdb    Database instance\n     * @param string $id_adh Member identifier\n     * @param string $pass   New password\n     *\n     * @return boolean\n     */\n    public static function updatePassword(Db $zdb, $id_adh, $pass)\n    {\n        try {\n            $cpass = password_hash($pass, PASSWORD_BCRYPT);\n\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array('mdp_adh' => $cpass)\n            )->where([self::PK => $id_adh]);\n            $zdb->execute($update);\n            Analog::log(\n                'Password for `' . $id_adh . '` has been updated.',\n                Analog::DEBUG\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred while updating password for `' . $id_adh .\n                '` | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    private function getFieldLabel($field)\n    {\n        $label = $this->fields[$field]['label'];\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label ?? '', ':'));\n        return $label;\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public static function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Mark as self membership\n     *\n     * @return void\n     */\n    public function setSelfMembership()\n    {\n        $this->_self_adh = true;\n    }\n\n    /**\n     * Is member up to date?\n     *\n     * @return boolean\n     */\n    public function isUp2Date()\n    {\n        if ($this->_deps['dues']) {\n            if ($this->isDueFree()) {\n                //member is due free, he's up to date.\n                return true;\n            } else {\n                //let's check from end date, if present\n                if ($this->_due_date == null) {\n                    return false;\n                } else {\n                    $ech = new \\DateTime($this->_due_date);\n                    $now = new \\DateTime();\n                    $now->setTime(0, 0, 0);\n                    return $ech >= $now;\n                }\n            }\n        } else {\n            throw new \\RuntimeException(\n                'Cannot check if member is up to date, dues deps is disabled!'\n            );\n        }\n    }\n\n    /**\n     * Set dependencies\n     *\n     * @param Preferences $preferences Preferences instance\n     * @param array       $fields      Members fields configuration\n     * @param History     $history     History instance\n     *\n     * @return void\n     */\n    public function setDependencies(\n        Preferences $preferences,\n        array $fields,\n        History $history\n    ) {\n        $this->preferences = $preferences;\n        $this->fields = $fields;\n        $this->history = $history;\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        $this->errors = array();\n\n        //Sanitize\n        foreach ($values as &$rawvalue) {\n            if (is_string($rawvalue)) {\n                $rawvalue = strip_tags($rawvalue);\n            }\n        }\n\n        $fields = self::getDbFields($this->zdb);\n\n        //reset company name if needed\n        if (!isset($values['is_company'])) {\n            unset($values['is_company']);\n            $values['societe_adh'] = '';\n        }\n\n        //no parent if checkbox was unchecked\n        if (\n            !isset($values['attach'])\n            && empty($this->_id)\n            && isset($values['parent_id'])\n        ) {\n            unset($values['parent_id']);\n        }\n\n        if (isset($values['duplicate'])) {\n            //if we're duplicating, keep a trace (if an error occurs)\n            $this->_duplicate = true;\n        }\n\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = $values[$key];\n                if ($value !== true && $value !== false) {\n                    $value = trim($value ?? '');\n                }\n            } elseif (empty($this->_id)) {\n                switch ($key) {\n                    case 'bool_admin_adh':\n                    case 'bool_exempt_adh':\n                    case 'bool_display_info':\n                        $value = 0;\n                        break;\n                    case 'activite_adh':\n                        //values that are set at object instantiation\n                        $value = true;\n                        break;\n                    case 'date_crea_adh':\n                    case 'sexe_adh':\n                    case 'titre_adh':\n                    case 'id_statut':\n                    case 'pref_lang':\n                    case 'parent_id':\n                        //values that are set at object instantiation\n                        $value = $this->$prop;\n                        break;\n                    case self::PK:\n                        $value = null;\n                        break;\n                    default:\n                        $value = '';\n                        break;\n                }\n            } else {\n                //keep stored value on update\n                if ($prop != '_password' || isset($values['mdp_adh']) && isset($values['mdp_adh2'])) {\n                    $value = $this->$prop;\n                } else {\n                    $value = null;\n                }\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // fill up the adherent structure\n                if ($value !== null && $value !== true && $value !== false && !is_object($value)) {\n                    $value = stripslashes($value);\n                }\n                $this->$prop = $value;\n\n                // now, check validity\n                if ($value !== null && $value != '') {\n                    if ($key !== 'mdp_adh') {\n                        $this->validate($key, $value, $values);\n                    }\n                } elseif (empty($this->_id)) {\n                    //ensure login and password are not empty\n                    if (($key == 'login_adh' || $key == 'mdp_adh') && !isset($required[$key])) {\n                        $p = new Password($this->zdb);\n                        $generated_value = $p->makeRandomPassword(15);\n                        if ($key == 'login_adh') {\n                            //'@' is not permitted in logins\n                            $this->$prop = str_replace('@', 'a', $generated_value);\n                        } else {\n                            $this->$prop = $generated_value;\n                        }\n                    }\n                }\n            }\n        }\n\n        //password checks need data to be previously set\n        if (isset($values['mdp_adh'])) {\n            $this->validate('mdp_adh', $values['mdp_adh'], $values);\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            $prop = '_' . $this->fields[$key]['propname'];\n\n            if (!isset($disabled[$key])) {\n                $mandatory_missing = false;\n                if (!isset($this->$prop) || $this->$prop == '') {\n                    $mandatory_missing = true;\n                } elseif ($key === 'titre_adh' && $this->$prop == '-1') {\n                    $mandatory_missing = true;\n                }\n\n                if ($mandatory_missing === true) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        //attach to/detach from parent\n        if (isset($values['detach_parent'])) {\n            $this->_parent = null;\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n        $this->checkSocials($values);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a member' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            $this->checkDues();\n\n            Analog::log(\n                'Member checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Validate data for given key\n     * Set valid data in current object, also resets errors list\n     *\n     * @param string $field  Field name\n     * @param mixed  $value  Value we want to set\n     * @param array  $values All values, for some references\n     *\n     * @return void\n     */\n    public function validate($field, $value, $values)\n    {\n        global $preferences;\n\n        $prop = '_' . $this->fields[$field]['propname'];\n\n        if ($value === null || (is_string($value) && trim($value) == '')) {\n            //empty values are OK\n            $this->$prop = $value;\n            return;\n        }\n\n        switch ($field) {\n            // dates\n            case 'date_crea_adh':\n            case 'date_modif_adh_':\n            case 'ddn_adh':\n            case 'date_echeance':\n                try {\n                    $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                    if ($d === false) {\n                        //try with non localized date\n                        $d = \\DateTime::createFromFormat(\"Y-m-d\", $value);\n                        if ($d === false) {\n                            throw new \\Exception('Incorrect format');\n                        }\n                    }\n\n                    if ($field === 'ddn_adh') {\n                        $now = new \\DateTime();\n                        $now->setTime(0, 0, 0);\n                        $d->setTime(0, 0, 0);\n\n                        $diff = $now->diff($d);\n                        $days = (int)$diff->format('%R%a');\n                        if ($days >= 0) {\n                            $this->errors[] = _T('- Birthdate must be set in the past!');\n                        }\n\n                        $years = (int)$diff->format('%R%Y');\n                        if ($years <= -200) {\n                            $this->errors[] = str_replace(\n                                '%years',\n                                $years * -1,\n                                _T('- Members must be less than 200 years old (currently %years)!')\n                            );\n                        }\n                    }\n                    $this->$prop = $d->format('Y-m-d');\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'Wrong date format. field: ' . $field .\n                        ', value: ' . $value . ', expected fmt: ' .\n                        __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                        Analog::INFO\n                    );\n                    $this->errors[] = str_replace(\n                        array(\n                            '%date_format',\n                            '%field'\n                        ),\n                        array(\n                            __(\"Y-m-d\"),\n                            $this->getFieldLabel($field)\n                        ),\n                        _T(\"- Wrong date format (%date_format) for %field!\")\n                    );\n                }\n                break;\n            case 'titre_adh':\n                if ($value !== null && $value !== '') {\n                    if ($value == '-1') {\n                        $this->$prop = null;\n                    } elseif (!$value instanceof Title) {\n                        $this->$prop = new Title((int)$value);\n                    }\n                } else {\n                    $this->$prop = null;\n                }\n                break;\n            case 'email_adh':\n                if (!GaletteMail::isValidEmail($value)) {\n                    $this->errors[] = _T(\"- Non-valid E-Mail address!\") .\n                        ' (' . $this->getFieldLabel($field) . ')';\n                }\n                if ($field == 'email_adh') {\n                    try {\n                        $select = $this->zdb->select(self::TABLE);\n                        $select->columns(\n                            array(self::PK)\n                        )->where(array('email_adh' => $value));\n                        if (!empty($this->_id)) {\n                            $select->where->notEqualTo(\n                                self::PK,\n                                $this->_id\n                            );\n                        }\n\n                        $results = $this->zdb->execute($select);\n                        if ($results->count() !== 0) {\n                            $this->errors[] = _T(\"- This E-Mail address is already used by another member!\");\n                        }\n                    } catch (Throwable $e) {\n                        Analog::log(\n                            'An error occurred checking member email unicity.',\n                            Analog::ERROR\n                        );\n                        $this->errors[] = _T(\"An error has occurred while looking if login already exists.\");\n                    }\n                }\n                break;\n            case 'login_adh':\n                /** FIXME: add a preference for login length */\n                if (strlen($value) < 2) {\n                    $this->errors[] = str_replace(\n                        '%i',\n                        2,\n                        _T(\"- The username must be composed of at least %i characters!\")\n                    );\n                } else {\n                    //check if login does not contain the @ character\n                    if (strpos($value, '@') != false) {\n                        $this->errors[] = _T(\"- The username cannot contain the @ character\");\n                    } else {\n                        //check if login is already taken\n                        try {\n                            $select = $this->zdb->select(self::TABLE);\n                            $select->columns(\n                                array(self::PK)\n                            )->where(array('login_adh' => $value));\n                            if (!empty($this->_id)) {\n                                $select->where->notEqualTo(\n                                    self::PK,\n                                    $this->_id\n                                );\n                            }\n\n                            $results = $this->zdb->execute($select);\n                            if (\n                                $results->count() !== 0\n                                || $value == $preferences->pref_admin_login\n                            ) {\n                                $this->errors[] = _T(\"- This username is already in use, please choose another one!\");\n                            }\n                        } catch (Throwable $e) {\n                            Analog::log(\n                                'An error occurred checking member login uniqueness.',\n                                Analog::ERROR\n                            );\n                            $this->errors[] = _T(\"An error has occurred while looking if login already exists.\");\n                        }\n                    }\n                }\n                break;\n            case 'mdp_adh':\n                if (\n                    $this->_self_adh !== true\n                    && (!isset($values['mdp_adh2'])\n                    || $values['mdp_adh2'] != $value)\n                ) {\n                    $this->errors[] = _T(\"- The passwords don't match!\");\n                } elseif (\n                    $this->_self_adh === true\n                    && !crypt($value, $values['mdp_crypt']) == $values['mdp_crypt']\n                ) {\n                    $this->errors[] = _T(\"Password misrepeated: \");\n                } else {\n                    $pinfos = password_get_info($value);\n                    //check if value is already a hash\n                    if ($pinfos['algo'] == 0) {\n                        $this->$prop = password_hash(\n                            $value,\n                            PASSWORD_BCRYPT\n                        );\n\n                        $pwcheck = new \\Galette\\Util\\Password($preferences);\n                        $pwcheck->setAdherent($this);\n                        if (!$pwcheck->isValid($value)) {\n                            $this->errors = array_merge(\n                                $this->errors,\n                                $pwcheck->getErrors()\n                            );\n                        }\n                    }\n                }\n                break;\n            case 'id_statut':\n                try {\n                    $this->$prop = (int)$value;\n                    //check if status exists\n                    $select = $this->zdb->select(Status::TABLE);\n                    $select->where([Status::PK => $value]);\n\n                    $results = $this->zdb->execute($select);\n                    $result = $results->current();\n                    if (!$result) {\n                        $this->errors[] = str_replace(\n                            '%id',\n                            $value,\n                            _T(\"Status #%id does not exists in database.\")\n                        );\n                        break;\n                    }\n                } catch (Throwable $e) {\n                    Analog::log(\n                        'An error occurred checking status existence: ' . $e->getMessage(),\n                        Analog::ERROR\n                    );\n                    $this->errors[] = _T(\"An error has occurred while looking if status does exists.\");\n                }\n                break;\n            case 'sexe_adh':\n                if (in_array($value, [self::NC, self::MAN, self::WOMAN])) {\n                    $this->$prop = (int)$value;\n                } else {\n                    $this->errors[] = _T(\"Gender %gender does not exists!\");\n                }\n                break;\n            case 'parent_id':\n                $this->$prop = ($value instanceof Adherent) ? (int)$value->id : (int)$value;\n                $this->loadParent();\n                break;\n        }\n    }\n\n    /**\n     * Store the member\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $hist, $emitter, $login;\n        $event = null;\n\n        if (!$login->isAdmin() && !$login->isStaff() && !$login->isGroupManager() && $this->id == '') {\n            if ($this->preferences->pref_bool_create_member) {\n                $this->_parent = $login->id;\n            }\n        }\n\n        try {\n            $values = array();\n            $fields = self::getDbFields($this->zdb);\n\n            foreach ($fields as $field) {\n                if (\n                    $field !== 'date_modif_adh'\n                    || empty($this->_id)\n                ) {\n                    $prop = '_' . $this->fields[$field]['propname'];\n                    if (\n                        ($field === 'bool_admin_adh'\n                        || $field === 'bool_exempt_adh'\n                        || $field === 'bool_display_info'\n                        || $field === 'activite_adh')\n                        && $this->$prop === false\n                    ) {\n                        //Handle booleans for postgres ; bugs #18899 and #19354\n                        $values[$field] = $this->zdb->isPostgres() ? 'false' : 0;\n                    } elseif ($field === 'parent_id') {\n                        //handle parents\n                        if ($this->_parent === null) {\n                            $values['parent_id'] = new Expression('NULL');\n                        } elseif ($this->parent instanceof Adherent) {\n                            $values['parent_id'] = $this->_parent->id;\n                        } else {\n                            $values['parent_id'] = $this->_parent;\n                        }\n                    } else {\n                        $values[$field] = $this->$prop;\n                    }\n                }\n            }\n\n            //an empty value will cause date to be set to 1901-01-01, a null\n            //will result in 0000-00-00. We want a database NULL value here.\n            if (!$this->_birthdate) {\n                $values['ddn_adh'] = new Expression('NULL');\n            }\n            if (!$this->_due_date) {\n                $values['date_echeance'] = new Expression('NULL');\n            }\n\n            if ($this->_title instanceof Title) {\n                $values['titre_adh'] = $this->_title->id;\n            } else {\n                $values['titre_adh'] = new Expression('NULL');\n            }\n\n            if (!$this->_parent) {\n                $values['parent_id'] = new Expression('NULL');\n            }\n\n            if (!$this->_number) {\n                $values['num_adh'] = new Expression('NULL');\n            }\n\n            //fields that cannot be null\n            $notnull = [\n                '_surname'  => 'prenom_adh',\n                '_nickname' => 'pseudo_adh',\n                '_address'  => 'adresse_adh',\n                '_zipcode'  => 'cp_adh',\n                '_town'     => 'ville_adh'\n            ];\n            foreach ($notnull as $prop => $field) {\n                if ($this->$prop === null) {\n                    $values[$field] = '';\n                }\n            }\n\n            $success = false;\n            if (empty($this->_id)) {\n                //we're inserting a new member\n                unset($values[self::PK]);\n                //set modification date\n                $this->_modification_date = date('Y-m-d');\n                $values['date_modif_adh'] = $this->_modification_date;\n\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n                    $this->_picture = new Picture($this->_id);\n                    // logging\n                    if ($this->_self_adh) {\n                        $hist->add(\n                            _T(\"Self_subscription as a member: \") .\n                            $this->getNameWithCase($this->_name, $this->_surname),\n                            $this->sname\n                        );\n                    } else {\n                        $hist->add(\n                            _T(\"Member card added\"),\n                            $this->sname\n                        );\n                    }\n                    $success = true;\n\n                    $event = 'member.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new member.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new member!'\n                    );\n                }\n            } else {\n                //we're editing an existing member\n                if (!$this->isDueFree()) {\n                    // deadline\n                    $due_date = Contribution::getDueDate($this->zdb, $this->_id);\n                    if ($due_date) {\n                        $values['date_echeance'] = $due_date;\n                    }\n                }\n\n                if (!$this->_password) {\n                    unset($values['mdp_adh']);\n                }\n\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values);\n                $update->where([self::PK => $this->_id]);\n\n                $edit = $this->zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $this->updateModificationDate();\n                    $hist->add(\n                        _T(\"Member card updated\"),\n                        $this->sname\n                    );\n                }\n                $success = true;\n                $event = 'member.edit';\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore();\n                $this->storeSocials($this->id);\n            }\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n            return $success;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Update member modification date\n     *\n     * @return void\n     */\n    private function updateModificationDate()\n    {\n        try {\n            $modif_date = date('Y-m-d');\n            $update = $this->zdb->update(self::TABLE);\n            $update->set(\n                array('date_modif_adh' => $modif_date)\n            )->where([self::PK => $this->_id]);\n\n            $edit = $this->zdb->execute($update);\n            $this->_modification_date = $modif_date;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong updating modif date :\\'( | ' .\n                $e->getMessage() . \"\\n\" . $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrieve\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array(\n            'admin', 'staff', 'due_free', 'appears_in_list', 'active',\n            'row_classes', 'oldness', 'duplicate'\n        );\n        if (!defined('GALETTE_TESTS')) {\n            $forbidden[] = 'password'; //keep that for tests only\n        }\n\n        $virtuals = array(\n            'sadmin', 'sstaff', 'sdue_free', 'sappears_in_list', 'sactive',\n            'stitle', 'sstatus', 'sfullname', 'sname', 'saddress',\n            'rbirthdate', 'sgender', 'contribstatus',\n        );\n\n        $socials = array('website', 'msn', 'jabber', 'icq');\n\n        if (in_array($name, $forbidden)) {\n            switch ($name) {\n                case 'admin':\n                    return $this->isAdmin();\n                case 'staff':\n                    return $this->isStaff();\n                case 'due_free':\n                    return $this->isDueFree();\n                case 'appears_in_list':\n                    return $this->appearsInMembersList();\n                case 'active':\n                    return $this->isActive();\n                case 'duplicate':\n                    return $this->isDuplicate();\n                default:\n                    throw new \\RuntimeException(\"Call to __get for '$name' is forbidden!\");\n            }\n        }\n\n        if (in_array($name, $virtuals)) {\n            if (substr($name, 0, 1) !== '_') {\n                $real = '_' . substr($name, 1);\n            } else {\n                $real = $name;\n            }\n            switch ($name) {\n                case 'sadmin':\n                case 'sdue_free':\n                case 'sappears_in_list':\n                case 'sstaff':\n                    return (($this->$real) ? _T(\"Yes\") : _T(\"No\"));\n                    break;\n                case 'sactive':\n                    return (($this->$real) ? _T(\"Active\") : _T(\"Inactive\"));\n                    break;\n                case 'stitle':\n                    if (isset($this->_title) && $this->_title instanceof Title) {\n                        return $this->_title->tshort;\n                    } else {\n                        return null;\n                    }\n                    break;\n                case 'sstatus':\n                    $status = new Status($this->zdb);\n                    return $status->getLabel($this->_status);\n                    break;\n                case 'sfullname':\n                    return $this->getNameWithCase(\n                        $this->_name,\n                        $this->_surname,\n                        (isset($this->_title) ? $this->title : false)\n                    );\n                    break;\n                case 'saddress':\n                    $address = $this->_address;\n                    if ($this->_address_continuation !== '' && $this->_address_continuation !== null) {\n                        $address .= \"\\n\" . $this->_address_continuation;\n                    }\n                    return $address;\n                    break;\n                case 'sname':\n                    return $this->getNameWithCase($this->_name, $this->_surname);\n                    break;\n                case 'rbirthdate':\n                    return $this->_birthdate;\n                    break;\n                case 'sgender':\n                    switch ($this->gender) {\n                        case self::MAN:\n                            return _T('Man');\n                        case self::WOMAN:\n                            return _T('Woman');\n                        default:\n                            return _T('Unspecified');\n                    }\n                    break;\n                case 'contribstatus':\n                    return $this->getDues();\n                    break;\n            }\n        }\n\n        //for backward compatibility\n        if (in_array($name, $socials)) {\n            $values = Social::getListForMember($this->_id, $name);\n            return $values[0] ?? null;\n        }\n\n        if (substr($name, 0, 1) !== '_') {\n            $rname = '_' . $name;\n        } else {\n            $rname = $name;\n        }\n\n        switch ($name) {\n            case 'id':\n            case 'id_statut':\n                if ($this->$rname !== null) {\n                    return (int)$this->$rname;\n                } else {\n                    return null;\n                }\n                break;\n            case 'address':\n            case 'address_continuation':\n                return $this->$rname ?? '';\n                break;\n            case 'birthdate':\n            case 'creation_date':\n            case 'modification_date':\n            case 'due_date':\n                if ($this->$rname != '') {\n                    try {\n                        $d = new \\DateTime($this->$rname);\n                        return $d->format(__(\"Y-m-d\"));\n                    } catch (Throwable $e) {\n                        //oops, we've got a bad date :/\n                        Analog::log(\n                            'Bad date (' . $this->$rname . ') | ' .\n                            $e->getMessage(),\n                            Analog::INFO\n                        );\n                        return $this->$rname;\n                    }\n                }\n                break;\n            case 'parent_id':\n                return ($this->_parent instanceof Adherent) ? (int)$this->_parent->id : (int)$this->_parent;\n                break;\n            default:\n                if (!property_exists($this, $rname)) {\n                    Analog::log(\n                        \"Unknown property '$rname'\",\n                        Analog::WARNING\n                    );\n                    return null;\n                } else {\n                    return $this->$rname;\n                }\n                break;\n        }\n    }\n\n    /**\n     * Get member email\n     * If member does not have an email address, but is attached to\n     * another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getEmail()\n    {\n        $email = $this->_email;\n        if (empty($email)) {\n            $this->loadParent();\n            $email = $this->parent->email;\n        }\n\n        return $email;\n    }\n\n    /**\n     * Get member address.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getAddress()\n    {\n        $address = $this->_address;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $address = $this->parent->address;\n        }\n\n        return $address;\n    }\n\n    /**\n     * Get member address continuation.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getAddressContinuation()\n    {\n        $address = $this->_address;\n        $address_continuation = $this->_address_continuation;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $address_continuation = $this->parent->address_continuation;\n        }\n\n        return $address_continuation;\n    }\n\n    /**\n     * Get member zipcode.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getZipcode()\n    {\n        $address = $this->_address;\n        $zip = $this->_zipcode;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $zip = $this->parent->zipcode;\n        }\n\n        return $zip;\n    }\n\n    /**\n     * Get member town.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getTown()\n    {\n        $address = $this->_address;\n        $town = $this->_town;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $town = $this->parent->town;\n        }\n\n        return $town;\n    }\n\n    /**\n     * Get member country.\n     * If member does not have an address, but is attached to another member, we'll take information from its parent.\n     *\n     * @return string\n     */\n    public function getCountry()\n    {\n        $address = $this->_address;\n        $country = $this->_country;\n        if (empty($address) && $this->hasParent()) {\n            $this->loadParent();\n            $country = $this->parent->country;\n        }\n\n        return $country;\n    }\n\n    /**\n     * Get member age\n     *\n     * @return string\n     */\n    public function getAge()\n    {\n        if ($this->_birthdate == null) {\n            return '';\n        }\n\n        $d = \\DateTime::createFromFormat('Y-m-d', $this->_birthdate);\n        if ($d === false) {\n            Analog::log(\n                'Invalid birthdate: ' . $this->_birthdate,\n                Analog::ERROR\n            );\n            return;\n        }\n\n        return str_replace(\n            '%age',\n            $d->diff(new \\DateTime())->y,\n            _T(' (%age years old)')\n        );\n    }\n\n    /**\n     * Get parent inherited fields\n     *\n     * @return array\n     */\n    public function getParentFields()\n    {\n        return $this->parent_fields;\n    }\n\n    /**\n     * Handle files (photo and dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n        // picture upload\n        if (isset($files['photo'])) {\n            if ($files['photo']['error'] === UPLOAD_ERR_OK) {\n                if ($files['photo']['tmp_name'] != '') {\n                    if (is_uploaded_file($files['photo']['tmp_name'])) {\n                        $res = $this->picture->store($files['photo']);\n                        if ($res < 0) {\n                            $this->errors[]\n                                = $this->picture->getErrorMessage($res);\n                        }\n                    }\n                }\n            } elseif ($files['photo']['error'] !== UPLOAD_ERR_NO_FILE) {\n                Analog::log(\n                    $this->picture->getPhpErrorMessage($files['photo']['error']),\n                    Analog::WARNING\n                );\n                $this->errors[] = $this->picture->getPhpErrorMessage(\n                    $files['photo']['error']\n                );\n            }\n        }\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a member files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Set member as duplicate\n     *\n     * @return void\n     */\n    public function setDuplicate()\n    {\n        //mark as duplicated\n        $this->_duplicate = true;\n        $infos = $this->_others_infos_admin;\n        $this->_others_infos_admin = str_replace(\n            ['%name', '%id'],\n            [$this->sname, $this->_id],\n            _T('Duplicated from %name (%id)')\n        );\n        if (!empty($infos)) {\n            $this->_others_infos_admin .= \"\\n\" . $infos;\n        }\n        //drop id_adh\n        $this->_id = null;\n        //drop email, must be unique\n        $this->_email = null;\n        //drop creation date\n        $this->_creation_date = date(\"Y-m-d\");\n        //drop login\n        $this->_login = null;\n        //reset picture\n        $this->_picture = new Picture();\n        //remove birthdate\n        $this->_birthdate = null;\n        //remove surname\n        $this->_surname = null;\n        //not admin\n        $this->_admin = false;\n        //not due free\n        $this->_due_free = false;\n    }\n\n    /**\n     * Get current errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get user groups\n     *\n     * @return array\n     */\n    public function getGroups()\n    {\n        return $this->_groups;\n    }\n\n    /**\n     * Get user managed groups\n     *\n     * @return array\n     */\n    public function getManagedGroups()\n    {\n        return $this->_managed_groups;\n    }\n\n    /**\n     * Can current logged-in user create member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canCreate(Login $login): bool\n    {\n        global $preferences;\n\n        if ($this->id && $login->id == $this->id || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        if ($preferences->pref_bool_create_member && $login->isLogged()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Can current logged-in user edit member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canEdit(Login $login): bool\n    {\n        //admin and staff users can edit, as well as member itself\n        if ($this->id && $login->id == $this->id || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can edit their child cards\n        if ($this->hasParent() && $this->parent_id === $login->id) {\n            return true;\n        }\n\n        //group managers can edit members of groups they manage\n        if ($login->isGroupManager()) {\n            foreach ($this->getGroups() as $g) {\n                if ($login->isGroupManager($g->getId())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Can current logged-in user display member\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        return $this->canEdit($login);\n    }\n\n    /**\n     * Are we currently duplicated a member?\n     *\n     * @return boolean\n     */\n    public function isDuplicate(): bool\n    {\n        return $this->_duplicate;\n    }\n\n    /**\n     * Flag creation mail sending\n     *\n     * @param boolean $send True (default) to send creation email\n     *\n     * @return Adherent\n     */\n    public function setSendmail($send = true): self\n    {\n        $this->sendmail = $send;\n        return $this;\n    }\n\n    /**\n     * Should we send administrative emails to member?\n     *\n     * @return boolean\n     */\n    public function sendEMail()\n    {\n        return $this->sendmail;\n    }\n\n    /**\n     * Set member parent\n     *\n     * @param integer $id Parent identifier\n     *\n     * @return $this\n     */\n    public function setParent(int $id): self\n    {\n        $this->_parent = $id;\n        $this->loadParent();\n        return $this;\n    }\n\n    /**\n     * Reset dependencies to load\n     *\n     * @return $this\n     */\n    public function disableAllDeps(): self\n    {\n        foreach ($this->_deps as &$dep) {\n            $dep = false;\n        }\n        return $this;\n    }\n\n    /**\n     * Enable all dependencies to load\n     *\n     * @return $this\n     */\n    public function enableAllDeps(): self\n    {\n        foreach ($this->_deps as &$dep) {\n            $dep = true;\n        }\n        return $this;\n    }\n\n    /**\n     * Enable a load dependency\n     *\n     * @param string $name Dependency name\n     *\n     * @return $this\n     */\n    public function enableDep(string $name): self\n    {\n        if (!isset($this->_deps[$name])) {\n            Analog::log(\n                'dependency ' . $name . ' does not exists!',\n                Analog::WARNING\n            );\n        } else {\n            $this->_deps[$name] = true;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Enable a load dependency\n     *\n     * @param string $name Dependency name\n     *\n     * @return $this\n     */\n    public function disableDep(string $name): self\n    {\n        if (!isset($this->_deps[$name])) {\n            Analog::log(\n                'dependency ' . $name . ' does not exists!',\n                Analog::WARNING\n            );\n        } else {\n            $this->_deps[$name] = false;\n        }\n\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Contribution class for galette\n * Manage membership fees and donations.\n *\n * PHP version 5\n *\n * Copyright \u00a9 2010-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Galette\\IO\\ExternalScript;\nuse Galette\\IO\\PdfContribution;\nuse Galette\\Repository\\PaymentTypes;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Contribution class for galette\n * Manage membership fees and donations.\n *\n * @category  Entity\n * @name      Contribution\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n *\n * @property integer $id\n * @property string $date\n * @property DateTime $raw_date\n * @property integer $member\n * @property ContributionsTypes $type\n * @property integer $amount\n * @property integer $payment_type\n * @property integer $orig_amount\n * @property string $info\n * @property string $begin_date\n * @property DateTime $raw_begin_date\n * @property string $end_date\n * @property DateTime $raw_end_date\n * @property Transaction|null $transaction\n * @property integer $extension\n * @property integer $duration\n * @property string $spayment_type\n * @property integer $model\n */\nclass Contribution\n{\n    use Dynamics;\n\n    public const TABLE = 'cotisations';\n    public const PK = 'id_cotis';\n\n    public const TYPE_FEE = 'fee';\n    public const TYPE_DONATION = 'donation';\n\n    private $_id;\n    private $_date;\n    private $_member;\n    private $_type;\n    private $_amount;\n    private $_payment_type;\n    private $_orig_amount;\n    private $_info;\n    private $_begin_date;\n    private $_end_date;\n    private $_transaction = null;\n    private $_is_cotis;\n    private $_extension;\n\n    //fields list and their translation\n    private $_fields;\n\n    /** @var Db */\n    private $zdb;\n    /** @var Login */\n    private $login;\n    /** @var array */\n    private $errors;\n\n    private $sendmail = false;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                 $zdb   Database\n     * @param Login              $login Login instance\n     * @param null|int|ResultSet $args  Either a ResultSet row to load\n     *                                  a specific contribution, or an type id\n     *                                  to just instantiate object\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n\n        global $preferences;\n        $this->_payment_type = (int)$preferences->pref_default_paymenttype;\n\n        /*\n         * Fields configuration. Each field is an array and must reflect:\n         * array(\n         *   (string)label,\n         *   (string) property name\n         * )\n         *\n         * I'd prefer a static private variable for this...\n         * But call to the _T function does not seem to be allowed there :/\n         */\n        $this->_fields = array(\n            'id_cotis'            => array(\n                'label'    => _T('Contribution id'), //not a field in the form\n                'propname' => 'id'\n            ),\n            Adherent::PK          => array(\n                'label'    => _T(\"Contributor:\"),\n                'propname' => 'member'\n            ),\n            ContributionsTypes::PK => array(\n                'label'    => _T(\"Contribution type:\"),\n                'propname' => 'type'\n            ),\n            'montant_cotis'       => array(\n                'label'    => _T(\"Amount:\"),\n                'propname' => 'amount'\n            ),\n            'type_paiement_cotis' => array(\n                'label'    => _T(\"Payment type:\"),\n                'propname' => 'payment_type'\n            ),\n            'info_cotis'          => array(\n                'label'    => _T(\"Comments:\"),\n                'propname' => 'info'\n            ),\n            'date_enreg'          => array(\n                'label'    => _T('Date'), //not a field in the form\n                'propname' => 'date'\n            ),\n            'date_debut_cotis'    => array(\n                'label'    => _T(\"Date of contribution:\"),\n                'cotlabel' => _T(\"Start date of membership:\"), //if contribution is a membership fee, label differs\n                'propname' => 'begin_date'\n            ),\n            'date_fin_cotis'      => array(\n                'label'    => _T(\"End date of membership:\"),\n                'propname' => 'end_date'\n            ),\n            Transaction::PK       => array(\n                'label'    => _T('Transaction ID'), //not a field in the form\n                'propname' => 'transaction'\n            ),\n            //this one is not really a field, but is required in some cases...\n            //adding it here make more simple to check required fields\n            'duree_mois_cotis'    => array(\n                'label'    => _T(\"Membership extension:\"),\n                'propname' => 'extension'\n            )\n        );\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_array($args)) {\n            $this->_date = date(\"Y-m-d\");\n            if (isset($args['adh']) && $args['adh'] != '') {\n                $this->_member = (int)$args['adh'];\n            }\n            if (isset($args['trans'])) {\n                $this->_transaction = new Transaction($this->zdb, $this->login, (int)$args['trans']);\n                if (!isset($this->_member)) {\n                    $this->_member = (int)$this->_transaction->member;\n                }\n                $this->_amount = $this->_transaction->getMissingAmount();\n            }\n            $this->type = (int)$args['type'];\n            //calculate begin date for membership fee\n            $this->_begin_date = $this->_date;\n            if ($this->_is_cotis) {\n                $curend = self::getDueDate($this->zdb, $this->_member);\n                if ($curend != '') {\n                    $dend = new \\DateTime($curend);\n                    $now = date('Y-m-d');\n                    $dnow = new \\DateTime($now);\n                    if ($dend < $dnow) {\n                        // Member didn't renew on time\n                        $this->_begin_date = $now;\n                    } else {\n                        $this->_begin_date = $curend;\n                    }\n                }\n                $this->retrieveEndDate();\n            }\n            if (isset($args['payment_type'])) {\n                $this->_payment_type = $args['payment_type'];\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Sets end contribution date\n     *\n     * @return void\n     */\n    private function retrieveEndDate()\n    {\n        global $preferences;\n\n        $bdate = new \\DateTime($this->_begin_date);\n        if ($preferences->pref_beg_membership != '') {\n            //case beginning of membership\n            list($j, $m) = explode('/', $preferences->pref_beg_membership);\n            $edate = new \\DateTime($bdate->format('Y') . '-' . $m . '-' . $j);\n            while ($edate <= $bdate) {\n                $edate->modify('+1 year');\n            }\n\n            if ($preferences->pref_membership_offermonths > 0) {\n                //count days until end of membership date\n                $diff1 = (int)$bdate->diff($edate)->format('%a');\n\n                //count days between end of membership date and offered months\n                $tdate = clone $edate;\n                $tdate->modify('-' . $preferences->pref_membership_offermonths . ' month');\n                $diff2 = (int)$edate->diff($tdate)->format('%a');\n\n                //when number of days until end of membership is less than for offered months, it's free :)\n                if ($diff1 <= $diff2) {\n                    $edate->modify('+1 year');\n                }\n            }\n\n            $this->_end_date = $edate->format('Y-m-d');\n        } elseif ($preferences->pref_membership_ext != '') {\n            //case membership extension\n            if ($this->_extension == null) {\n                $this->_extension = $preferences->pref_membership_ext;\n            }\n            $dext = new \\DateInterval('P' . $this->_extension . 'M');\n            $edate = $bdate->add($dext);\n            $this->_end_date = $edate->format('Y-m-d');\n        } else {\n            throw new \\RuntimeException(\n                'Unable to define end date; none of pref_beg_membership nor pref_membership_ext are defined!'\n            );\n        }\n    }\n\n    /**\n     * Loads a contribution from its id\n     *\n     * @param int $id the identifier for the contribution to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'c');\n            $select->join(\n                array('a' => PREFIX_DB . Adherent::TABLE),\n                'c.' . Adherent::PK . '=a.' . Adherent::PK,\n                array()\n            );\n            //restrict query on current member id if he's not admin nor staff member\n            if (!$this->login->isAdmin() && !$this->login->isStaff()) {\n                if (!$this->login->isLogged()) {\n                    Analog::log(\n                        'Non-logged-in users cannot load contribution id `' . $id,\n                        Analog::ERROR\n                    );\n                    return false;\n                }\n                if (!$this->login->isGroupManager()) {\n                    $select->where\n                        ->nest()\n                            ->equalTo('a.' . Adherent::PK, $this->login->id)\n                            ->or\n                            ->equalTo('a.parent_id', $this->login->id)\n                        ->unnest()\n                        ->and\n                        ->equalTo('c.' . self::PK, $id)\n                    ;\n                } else {\n                    $select->where([\n                        Adherent::PK    => $this->login->id,\n                        self::PK        => $id\n                    ]);\n                }\n            } else {\n                $select->where->equalTo(self::PK, $id);\n            }\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $row = $results->current();\n                $this->loadFromRS($row);\n                return true;\n            } else {\n                Analog::log(\n                    'No contribution #' . $id . ' (user ' . $this->login->id . ')',\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred attempting to load contribution #' . $id .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = self::PK;\n        $this->_id = (int)$r->$pk;\n        $this->_date = $r->date_enreg;\n        $this->_amount = (int)$r->montant_cotis;\n        //save original amount, we need it for transactions parts calculations\n        $this->_orig_amount = (int)$r->montant_cotis;\n        $this->_payment_type = $r->type_paiement_cotis;\n        $this->_info = $r->info_cotis;\n        $this->_begin_date = $r->date_debut_cotis;\n        $enddate = $r->date_fin_cotis;\n        //do not work with knows bad dates...\n        //the one with BC comes from 0.63/pgsql demo... Why the hell a so\n        //strange date? don't know :(\n        if (\n            $enddate !== '0000-00-00'\n            && $enddate !== '1901-01-01'\n            && $enddate !== '0001-01-01 BC'\n        ) {\n            $this->_end_date = $r->date_fin_cotis;\n        }\n        $adhpk = Adherent::PK;\n        $this->_member = (int)$r->$adhpk;\n\n        $transpk = Transaction::PK;\n        if ($r->$transpk != '') {\n            $this->_transaction = new Transaction($this->zdb, $this->login, (int)$r->$transpk);\n        }\n\n        $this->type = (int)$r->id_type_cotis;\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        global $preferences;\n        $this->errors = array();\n\n        $fields = array_keys($this->_fields);\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->_fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = trim($values[$key]);\n            } else {\n                $value = '';\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // fill up the adherent structure\n                //$this->$prop = stripslashes($value); //not relevant here!\n\n                // now, check validity\n                switch ($key) {\n                    // dates\n                    case 'date_enreg':\n                    case 'date_debut_cotis':\n                    case 'date_fin_cotis':\n                        if ($value != '') {\n                            try {\n                                $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                                if ($d === false) {\n                                    throw new \\Exception('Incorrect format');\n                                }\n                                $this->$prop = $d->format('Y-m-d');\n                            } catch (Throwable $e) {\n                                Analog::log(\n                                    'Wrong date format. field: ' . $key .\n                                    ', value: ' . $value . ', expected fmt: ' .\n                                    __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                                    Analog::INFO\n                                );\n                                $this->errors[] = str_replace(\n                                    array(\n                                        '%date_format',\n                                        '%field'\n                                    ),\n                                    array(\n                                        __(\"Y-m-d\"),\n                                        $this->_fields[$key]['label']\n                                    ),\n                                    _T(\"- Wrong date format (%date_format) for %field!\")\n                                );\n                            }\n                        }\n                        break;\n                    case Adherent::PK:\n                        if ($value != '') {\n                            $this->_member = (int)$value;\n                        }\n                        break;\n                    case ContributionsTypes::PK:\n                        if ($value != '') {\n                            $this->type = (int)$value;\n                        }\n                        break;\n                    case 'montant_cotis':\n                        if (!empty($value)) {\n                            $this->_amount = $value;\n                        }\n                        $value = strtr($value, ',', '.');\n                        if (!is_numeric($value) && $value !== '') {\n                            $this->errors[] = _T(\"- The amount must be an integer!\");\n                        }\n                        break;\n                    case 'type_paiement_cotis':\n                        $ptypes = new PaymentTypes(\n                            $this->zdb,\n                            $preferences,\n                            $this->login\n                        );\n                        $ptlist = $ptypes->getList();\n                        if (isset($ptlist[$value])) {\n                            $this->_payment_type = $value;\n                        } else {\n                            $this->errors[] = _T(\"- Unknown payment type\");\n                        }\n                        break;\n                    case 'info_cotis':\n                        $this->_info = $value;\n                        break;\n                    case Transaction::PK:\n                        if ($value != '') {\n                            $this->_transaction = new Transaction($this->zdb, $this->login, (int)$value);\n                        }\n                        break;\n                    case 'duree_mois_cotis':\n                        if ($value != '') {\n                            if (!is_numeric($value) || $value <= 0) {\n                                $this->errors[] = _T(\"- The duration must be a positive integer!\");\n                            }\n                            $this->$prop = $value;\n                            $this->retrieveEndDate();\n                        }\n                        break;\n                }\n            }\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            if ($val === 1) {\n                $prop = '_' . $this->_fields[$key]['propname'];\n                if (\n                    !isset($disabled[$key])\n                    && (!isset($this->$prop)\n                    || (!is_object($this->$prop) && trim($this->$prop) == '')\n                    || (is_object($this->$prop) && trim($this->$prop->id) == ''))\n                ) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        if ($this->_transaction != null && $this->_amount != null) {\n            $missing = $this->_transaction->getMissingAmount();\n            //calculate new missing amount\n            $missing = $missing + $this->_orig_amount - $this->_amount;\n            if ($missing < 0) {\n                $this->errors[] = _T(\"- Sum of all contributions exceed corresponding transaction amount.\");\n            }\n        }\n\n        if ($this->isFee() && count($this->errors) == 0) {\n            $overlap = $this->checkOverlap();\n            if ($overlap !== true) {\n                //method directly return error message\n                $this->errors[] = $overlap;\n            }\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been threw attempting to edit/store a contribution' .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            Analog::log(\n                'Contribution checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Check that membership fees does not overlap\n     *\n     * @return boolean|string True if all is ok, false if error,\n     * error message if overlap\n     */\n    public function checkOverlap()\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 'c');\n            $select->columns(\n                array('date_debut_cotis', 'date_fin_cotis')\n            )->join(\n                array('ct' => PREFIX_DB . ContributionsTypes::TABLE),\n                'c.' . ContributionsTypes::PK . '=ct.' . ContributionsTypes::PK,\n                array()\n            )->where([Adherent::PK => $this->_member])\n                ->where(array('cotis_extension' => new Expression('true')))\n                ->where->nest->nest\n                ->greaterThanOrEqualTo('date_debut_cotis', $this->_begin_date)\n                ->lessThan('date_debut_cotis', $this->_end_date)\n                ->unnest\n                ->or->nest\n                ->greaterThan('date_fin_cotis', $this->_begin_date)\n                ->lessThanOrEqualTo('date_fin_cotis', $this->_end_date);\n\n            if ($this->id != '') {\n                $select->where->notEqualTo(self::PK, $this->id);\n            }\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $d = new \\DateTime($result->date_debut_cotis);\n\n                return _T(\"- Membership period overlaps period starting at \") .\n                    $d->format(__(\"Y-m-d\"));\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred checking overlapping fee. ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the contribution\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $hist, $emitter;\n\n        $event = null;\n\n        if (count($this->errors) > 0) {\n            throw new \\RuntimeException(\n                'Existing errors prevents storing contribution: ' .\n                print_r($this->errors, true)\n            );\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array();\n            $fields = self::getDbFields($this->zdb);\n            foreach ($fields as $field) {\n                $prop = '_' . $this->_fields[$field]['propname'];\n                switch ($field) {\n                    case ContributionsTypes::PK:\n                    case Transaction::PK:\n                        if (isset($this->$prop)) {\n                            $values[$field] = $this->$prop->id;\n                        }\n                        break;\n                    default:\n                        $values[$field] = $this->$prop;\n                        break;\n                }\n            }\n\n            //no end date, let's take database defaults\n            if (!$this->isFee() && !$this->_end_date) {\n                unset($values['date_fin_cotis']);\n            }\n\n            $success = false;\n            if (!isset($this->_id) || $this->_id == '') {\n                //we're inserting a new contribution\n                unset($values[self::PK]);\n\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Contribution added\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                    $success = true;\n                    $event = 'contribution.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new contribution.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new contribution!'\n                    );\n                }\n            } else {\n                //we're editing an existing contribution\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where([self::PK => $this->_id]);\n                $edit = $this->zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Contribution updated\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                }\n\n                if ($edit === false) {\n                    throw new \\Exception(\n                        'An error occurred updating contribution # ' . $this->_id . '!'\n                    );\n                }\n                $success = true;\n                $event = 'contribution.edit';\n            }\n            //update deadline\n            if ($this->isFee()) {\n                $this->updateDeadline();\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore(true);\n            }\n\n            $this->zdb->connection->commit();\n            $this->_orig_amount = $this->_amount;\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            if ($this->zdb->connection->inTransaction()) {\n                $this->zdb->connection->rollBack();\n            }\n            throw $e;\n        }\n    }\n\n    /**\n     * Update member dead line\n     *\n     * @return boolean\n     */\n    private function updateDeadline()\n    {\n        try {\n            $due_date = self::getDueDate($this->zdb, $this->_member);\n\n            if ($due_date != '') {\n                $date_fin_update = $due_date;\n            } else {\n                $date_fin_update = new Expression('NULL');\n            }\n\n            $update = $this->zdb->update(Adherent::TABLE);\n            $update->set(\n                array('date_echeance' => $date_fin_update)\n            )->where(\n                [Adherent::PK => $this->_member]\n            );\n            $this->zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred updating member ' . $this->_member .\n                '\\'s deadline |' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove contribution from database\n     *\n     * @param boolean $transaction Activate transaction mode (defaults to true)\n     *\n     * @return boolean\n     */\n    public function remove($transaction = true)\n    {\n        global $emitter;\n\n        try {\n            if ($transaction) {\n                $this->zdb->connection->beginTransaction();\n            }\n\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $this->_id]);\n            $del = $this->zdb->execute($delete);\n            if ($del->count() > 0) {\n                $this->updateDeadline();\n                $this->dynamicsRemove(true);\n            } else {\n                Analog::log(\n                    'Contribution has not been removed!',\n                    Analog::WARNING\n                );\n                return false;\n            }\n            if ($transaction) {\n                $this->zdb->connection->commit();\n            }\n            $emitter->emit('contribution.remove', $this);\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred trying to remove contribution #' .\n                $this->_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    public function getFieldLabel($field)\n    {\n        $label = $this->_fields[$field]['label'];\n        if ($this->isFee() && $field == 'date_debut_cotis') {\n            $label = $this->_fields[$field]['cotlabel'];\n        }\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label, ':'));\n        return $label;\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public static function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Get the relevant CSS class for current contribution\n     *\n     * @return string current contribution row class\n     */\n    public function getRowClass()\n    {\n        return ($this->_end_date != $this->_begin_date && $this->_is_cotis) ?\n            'cotis-normal' : 'cotis-give';\n    }\n\n    /**\n     * Retrieve member due date\n     *\n     * @param Db      $zdb       Database instance\n     * @param integer $member_id Member identifier\n     *\n     * @return date\n     */\n    public static function getDueDate(Db $zdb, $member_id)\n    {\n        if (!$member_id) {\n            return '';\n        }\n        try {\n            $select = $zdb->select(self::TABLE, 'c');\n            $select->columns(\n                array(\n                    'max_date' => new Expression('MAX(date_fin_cotis)')\n                )\n            )->join(\n                array('ct' => PREFIX_DB . ContributionsTypes::TABLE),\n                'c.' . ContributionsTypes::PK . '=ct.' . ContributionsTypes::PK,\n                array()\n            )->where(\n                [Adherent::PK => $member_id]\n            )->where(\n                array('cotis_extension' => new Expression('true'))\n            );\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n            $due_date = $result->max_date;\n\n            //avoid bad dates in postgres and bad mysql return from zenddb\n            if ($due_date == '0001-01-01 BC' || $due_date == '1901-01-01') {\n                $due_date = '';\n            }\n            return $due_date;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred trying to retrieve member\\'s due date',\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Detach a contribution from a transaction\n     *\n     * @param Db    $zdb        Database instance\n     * @param Login $login      Login instance\n     * @param int   $trans_id   Transaction identifier\n     * @param int   $contrib_id Contribution identifier\n     *\n     * @return boolean\n     */\n    public static function unsetTransactionPart(Db $zdb, Login $login, $trans_id, $contrib_id)\n    {\n        try {\n            //first, we check if contribution is part of transaction\n            $c = new Contribution($zdb, $login, (int)$contrib_id);\n            if ($c->isTransactionPartOf($trans_id)) {\n                $update = $zdb->update(self::TABLE);\n                $update->set(\n                    array(Transaction::PK => null)\n                )->where(\n                    [self::PK => $contrib_id]\n                );\n                $zdb->execute($update);\n                return true;\n            } else {\n                Analog::log(\n                    'Contribution #' . $contrib_id .\n                    ' is not actually part of transaction #' . $trans_id,\n                    Analog::WARNING\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to detach contribution #' . $contrib_id .\n                ' to transaction #' . $trans_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set a contribution as a transaction part\n     *\n     * @param Db  $zdb        Database instance\n     * @param int $trans_id   Transaction identifier\n     * @param int $contrib_id Contribution identifier\n     *\n     * @return boolean\n     */\n    public static function setTransactionPart(Db $zdb, $trans_id, $contrib_id)\n    {\n        try {\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array(Transaction::PK => $trans_id)\n            )->where([self::PK => $contrib_id]);\n\n            $zdb->execute($update);\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to attach contribution #' . $contrib_id .\n                ' to transaction #' . $trans_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Is current contribution a membership fee\n     *\n     * @return boolean\n     */\n    public function isFee()\n    {\n        return $this->_is_cotis;\n    }\n\n    /**\n     * Is current contribution part of specified transaction\n     *\n     * @param int $id Transaction identifier\n     *\n     * @return boolean\n     */\n    public function isTransactionPartOf($id)\n    {\n        if ($this->isTransactionPart()) {\n            return $id == $this->_transaction->id;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Is current contribution part of transaction\n     *\n     * @return boolean\n     */\n    public function isTransactionPart()\n    {\n        return $this->_transaction != null;\n    }\n\n    /**\n     * Execute post contribution script\n     *\n     * @param ExternalScript $es     External script to execute\n     * @param array          $extra  Extra information on contribution\n     *                               Defaults to null\n     * @param array          $pextra Extra information on payment\n     *                               Defaults to null\n     *\n     * @return mixed Script return value on success, values and script output on fail\n     */\n    public function executePostScript(\n        ExternalScript $es,\n        $extra = null,\n        $pextra = null\n    ) {\n        global $preferences;\n\n        $payment = array(\n            'type'  => $this->getPaymentType()\n        );\n\n        if ($pextra !== null && is_array($pextra)) {\n            $payment = array_merge($payment, $pextra);\n        }\n\n        if (!file_exists(GALETTE_CACHE_DIR . '/pdf_contribs')) {\n            @mkdir(GALETTE_CACHE_DIR . '/pdf_contribs');\n        }\n\n        $voucher_path = null;\n        if ($this->_id !== null) {\n            $voucher = new PdfContribution($this, $this->zdb, $preferences);\n            $voucher->store(GALETTE_CACHE_DIR . '/pdf_contribs');\n            $voucher_path = $voucher->getPath();\n        }\n\n        $contrib = array(\n            'id'        => (int)$this->_id,\n            'date'      => $this->_date,\n            'type'      => $this->getRawType(),\n            'amount'    => $this->amount,\n            'voucher'   => $voucher_path,\n            'category'  => array(\n                'id'    => $this->type->id,\n                'label' => $this->type->libelle\n            ),\n            'payment'   => $payment\n        );\n\n        if ($this->_member !== null) {\n            $m = new Adherent($this->zdb, (int)$this->_member);\n            $member = array(\n                'id'            => (int)$this->_member,\n                'name'          => $m->sfullname,\n                'email'         => $m->email,\n                'organization'  => ($m->isCompany() ? 1 : 0),\n                'status'        => array(\n                    'id'    => $m->status,\n                    'label' => $m->sstatus\n                ),\n                'country'       => $m->country\n            );\n\n            if ($m->isCompany()) {\n                $member['organization_name'] = $m->company_name;\n            }\n\n            $contrib['member'] = $member;\n        }\n\n        if ($extra !== null && is_array($extra)) {\n            $contrib = array_merge($contrib, $extra);\n        }\n\n        $res = $es->send($contrib);\n\n        if ($res !== true) {\n            Analog::log(\n                'An error occurred calling post contribution ' .\n                \"script:\\n\" . $es->getOutput(),\n                Analog::ERROR\n            );\n            $res = _T(\"Contribution information\") . \"\\n\";\n            $res .= print_r($contrib, true);\n            $res .= \"\\n\\n\" . _T(\"Script output\") . \"\\n\";\n            $res .= $es->getOutput();\n        }\n\n        return $res;\n    }\n    /**\n     * Get raw contribution type\n     *\n     * @return string\n     */\n    public function getRawType()\n    {\n        if ($this->isFee()) {\n            return 'membership';\n        } else {\n            return 'donation';\n        }\n    }\n\n    /**\n     * Get contribution type label\n     *\n     * @return string\n     */\n    public function getTypeLabel()\n    {\n        if ($this->isFee()) {\n            return _T(\"Membership\");\n        } else {\n            return _T(\"Donation\");\n        }\n    }\n\n    /**\n     * Get payment type label\n     *\n     * @return string\n     */\n    public function getPaymentType()\n    {\n        if ($this->_payment_type === null) {\n            return '-';\n        }\n\n        $ptype = new PaymentType($this->zdb, (int)$this->payment_type);\n        return $ptype->getName(false);\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrieve\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n\n        $forbidden = array('is_cotis');\n        $virtuals = array('duration', 'spayment_type', 'model', 'raw_date',\n            'raw_begin_date', 'raw_end_date'\n        );\n\n        $rname = '_' . $name;\n\n        if (in_array($name, $forbidden)) {\n            Analog::log(\n                \"Call to __get for '$name' is forbidden!\",\n                Analog::WARNING\n            );\n\n            switch ($name) {\n                case 'is_cotis':\n                    return $this->isFee();\n                    break;\n                default:\n                    throw new \\RuntimeException(\"Call to __get for '$name' is forbidden!\");\n            }\n        } elseif (\n            property_exists($this, $rname)\n            || in_array($name, $virtuals)\n        ) {\n            switch ($name) {\n                case 'raw_date':\n                case 'raw_begin_date':\n                case 'raw_end_date':\n                    $rname = '_' . substr($name, 4);\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d;\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            throw $e;\n                        }\n                    }\n                    break;\n                case 'date':\n                case 'begin_date':\n                case 'end_date':\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$rname;\n                        }\n                    }\n                    break;\n                case 'duration':\n                    if ($this->_is_cotis) {\n                        $date_end = new \\DateTime($this->_end_date);\n                        $date_start = new \\DateTime($this->_begin_date);\n                        $diff = $date_end->diff($date_start);\n                        return $diff->format('%y') * 12 + $diff->format('%m');\n                    } else {\n                        return '';\n                    }\n                    break;\n                case 'spayment_type':\n                    return $this->getPaymentType();\n                    break;\n                case 'model':\n                    if ($this->_is_cotis === null) {\n                        return null;\n                    }\n                    return ($this->isFee()) ?\n                        PdfModel::INVOICE_MODEL : PdfModel::RECEIPT_MODEL;\n                    break;\n                default:\n                    return $this->$rname;\n                    break;\n            }\n        } else {\n            Analog::log(\n                \"Unknown property '$rname'\",\n                Analog::WARNING\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Global setter method\n     *\n     * @param string $name  name of the property we want to assign a value to\n     * @param object $value a relevant value for the property\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        global $preferences;\n\n        $forbidden = array('fields', 'is_cotis', 'end_date');\n\n        if (!in_array($name, $forbidden)) {\n            $rname = '_' . $name;\n            switch ($name) {\n                case 'transaction':\n                    if (is_int($value)) {\n                        $this->$rname = new Transaction($this->zdb, $this->login, $value);\n                    } else {\n                        Analog::log(\n                            'Trying to set a transaction from an id that is not an integer.',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'type':\n                    if (is_int($value)) {\n                        //set type\n                        $this->$rname = new ContributionsTypes($this->zdb, $value);\n                        //set is_cotis according to type\n                        if ($this->$rname->extension == 1) {\n                            $this->_is_cotis = true;\n                        } else {\n                            $this->_is_cotis = false;\n                        }\n                    } else {\n                        Analog::log(\n                            'Trying to set a type from an id that is not an integer.',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'begin_date':\n                    try {\n                        $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                        if ($d === false) {\n                            throw new \\Exception('Incorrect format');\n                        }\n                        $this->_begin_date = $d->format('Y-m-d');\n                    } catch (Throwable $e) {\n                        Analog::log(\n                            'Wrong date format. field: ' . $name .\n                            ', value: ' . $value . ', expected fmt: ' .\n                            __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                            Analog::INFO\n                        );\n                        $this->errors[] = str_replace(\n                            array(\n                                '%date_format',\n                                '%field'\n                            ),\n                            array(\n                                __(\"Y-m-d\"),\n                                $this->_fields['date_debut_cotis']['label']\n                            ),\n                            _T(\"- Wrong date format (%date_format) for %field!\")\n                        );\n                    }\n                    break;\n                case 'amount':\n                    if (is_numeric($value) && $value > 0) {\n                        $this->$rname = $value;\n                    } else {\n                        Analog::log(\n                            'Trying to set an amount with a non numeric value, ' .\n                            'or with a zero value',\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                case 'member':\n                    if (is_int($value)) {\n                        //set type\n                        $this->$rname = $value;\n                    }\n                    break;\n                case 'payment_type':\n                    $ptypes = new PaymentTypes(\n                        $this->zdb,\n                        $preferences,\n                        $this->login\n                    );\n                    $list = $ptypes->getList();\n                    if (isset($list[$value])) {\n                        $this->_payment_type = $value;\n                    } else {\n                        Analog::log(\n                            'Unknown payment type ' . $value,\n                            Analog::WARNING\n                        );\n                    }\n                    break;\n                default:\n                    Analog::log(\n                        '[' . __CLASS__ . ']: Trying to set an unknown property (' .\n                        $name . ')',\n                        Analog::WARNING\n                    );\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Flag creation mail sending\n     *\n     * @param boolean $send True (default) to send creation email\n     *\n     * @return Contribution\n     */\n    public function setSendmail($send = true)\n    {\n        $this->sendmail = $send;\n        return $this;\n    }\n\n    /**\n     * Should we send administrative emails to member?\n     *\n     * @return boolean\n     */\n    public function sendEMail()\n    {\n        return $this->sendmail;\n    }\n\n    /**\n     * Handle files (dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been threw attempting to edit/store a contribution files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Get required fields list\n     *\n     * @return array\n     */\n    public function getRequired(): array\n    {\n        return [\n            'id_type_cotis'     => 1,\n            'id_adh'            => 1,\n            'date_enreg'        => 1,\n            'date_debut_cotis'  => 1,\n            'date_fin_cotis'    => $this->isFee() ? 1 : 0,\n            'montant_cotis'     => $this->isFee() ? 1 : 0\n        ];\n    }\n\n    /**\n     * Can current logged-in user display contribution\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        //non-logged-in members cannot show contributions\n        if (!$login->isLogged()) {\n            return false;\n        }\n\n        //admin and staff users can edit, as well as member itself\n        if (!$this->id || $this->id && $login->id == $this->_member || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can see their children contributions\n        $parent = new Adherent($this->zdb);\n        $parent\n            ->disableAllDeps()\n            ->enableDep('children')\n            ->load($this->login->id);\n        if ($parent->hasChildren()) {\n            foreach ($parent->children as $child) {\n                if ($child->id === $this->_member) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return false;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Entitleds handling\n *\n * PHP version 5\n *\n * Copyright \u00a9 2007-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2007-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2007-10-27\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Core\\Db;\nuse Galette\\Features\\I18n;\n\n/**\n * Entitled handling. Manage:\n *      - id\n *      - label\n *      - extra (that may differ from one entity to another)\n *\n * @category  Entity\n * @name      Entitled\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2007-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2007-10-27\n *\n * @property integer $id\n * @property string $label\n * @property string $libelle\n * @property mixed $third\n * @property mixed $extension\n */\n\nabstract class Entitled\n{\n    use I18n;\n\n    public const ID_NOT_EXITS = -1;\n\n    private $zdb;\n    private $table;\n    private $fpk;\n    private $flabel;\n    private $fthird;\n    private $used;\n\n    public static $fields;\n    protected static $defaults;\n\n    /** @var string|false */\n    protected $order_field = false;\n\n    private $id;\n    private $label;\n    private $third;\n\n    private $errors = array();\n\n    /**\n     * Default constructor\n     *\n     * @param Db     $zdb    Database\n     * @param string $table  Table name\n     * @param string $fpk    Primary key field name\n     * @param string $flabel Label fields name\n     * @param string $fthird The third field name\n     * @param string $used   Table name for isUsed function\n     * @param mixed  $args   Either an int or a resultset to load\n     */\n    public function __construct(Db $zdb, $table, $fpk, $flabel, $fthird, $used, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->table = $table;\n        $this->fpk = $fpk;\n        $this->flabel = $flabel;\n        $this->fthird = $fthird;\n        $this->used = $used;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n    }\n\n    /**\n     * Loads an entry from its id\n     *\n     * @param int $id Entry ID\n     *\n     * @return boolean true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select($this->table);\n            $select->where([$this->fpk => $id]);\n\n            $results = $this->zdb->execute($select);\n            if ($results->count() > 0) {\n                $result = $results->current();\n                $this->loadFromRS($result);\n\n                return true;\n            } else {\n                Analog::log(\n                    'Unknown ID ' . $id,\n                    Analog::ERROR\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load ' . $this->getType() . ' from id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = $this->fpk;\n        $this->id = $r->$pk;\n        $flabel = $this->flabel;\n        $this->label = $r->$flabel;\n        $fthird = $this->fthird;\n        $this->third = $r->$fthird;\n    }\n\n    /**\n     * Set defaults at install time\n     *\n     * @return boolean\n     * @throws Throwable\n     */\n    public function installInit()\n    {\n        $class = get_class($this);\n\n        try {\n            //first, we drop all values\n            $delete = $this->zdb->delete($this->table);\n            $this->zdb->execute($delete);\n\n            $values = array();\n            foreach ($class::$fields as $key => $f) {\n                $values[$f] = ':' . $key;\n            }\n\n            $insert = $this->zdb->insert($this->table);\n            $insert->values($values);\n            $stmt = $this->zdb->sql->prepareStatementForSqlObject($insert);\n\n            $this->zdb->handleSequence(\n                $this->table,\n                count(static::$defaults)\n            );\n\n            $fnames = array_values($values);\n            foreach ($class::$defaults as $d) {\n                $val = null;\n                if (isset($d['priority'])) {\n                    $val = $d['priority'];\n                } else {\n                    $val = $d['extension'];\n                }\n\n                $stmt->execute(\n                    array(\n                        $fnames[0]  => $d['id'],\n                        $fnames[1]  => $d['libelle'],\n                        $fnames[2]  => $val\n                    )\n                );\n            }\n\n            Analog::log(\n                'Defaults (' . $this->getType() .\n                ') were successfully stored into database.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to initialize defaults (' . $this->getType() . ').' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get list in an array built as:\n     * $array[id] = \"translated label\"\n     *\n     * @param boolean|null $extent Filter on (non) cotisations types\n     *\n     * @return array|false\n     */\n    public function getList(bool $extent = null)\n    {\n        $list = array();\n\n        try {\n            $select = $this->zdb->select($this->table);\n            $fields = array($this->fpk, $this->flabel);\n            if (\n                $this->order_field !== false\n                && $this->order_field !== $this->fpk\n                && $this->order_field !== $this->flabel\n            ) {\n                $fields[] = $this->order_field;\n            }\n            $select->quantifier('DISTINCT');\n            $select->columns($fields);\n\n            if ($this->order_field !== false) {\n                $select->order($this->order_field, $this->fpk);\n            }\n            if ($extent !== null) {\n                if ($extent === true) {\n                    $select->where(array($this->fthird => new Expression('true')));\n                } elseif ($extent === false) {\n                    $select->where(array($this->fthird => new Expression('false')));\n                }\n            }\n\n            $results = $this->zdb->execute($select);\n\n            foreach ($results as $r) {\n                $fpk = $this->fpk;\n                $flabel = $this->flabel;\n                $list[$r->$fpk] = _T($r->$flabel);\n            }\n            return $list;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Complete list\n     *\n     * @return array of all objects if succeeded, false otherwise\n     */\n    public function getCompleteList()\n    {\n        $list = array();\n\n        try {\n            $select = $this->zdb->select($this->table);\n            if ($this->order_field !== false) {\n                $select->order(array($this->order_field, $this->fpk));\n            }\n\n            $results = $this->zdb->execute($select);\n\n            if ($results->count() == 0) {\n                Analog::log(\n                    'No entries (' . $this->getType() . ') defined in database.',\n                    Analog::INFO\n                );\n            } else {\n                $pk = $this->fpk;\n                $flabel = $this->flabel;\n                $fprio = $this->fthird;\n\n                foreach ($results as $r) {\n                    $list[$r->$pk] = array(\n                        'name'  => _T($r->$flabel),\n                        'extra' => $r->$fprio\n                    );\n                }\n            }\n            return $list;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list entries (' . $this->getType() .\n                ') | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get a entry\n     *\n     * @param integer $id Entry ID\n     *\n     * @return mixed|false Row if succeed ; false: no such id\n     */\n    public function get($id)\n    {\n        if (!is_numeric($id)) {\n            $this->errors[] = _T(\"ID must be an integer!\");\n            return false;\n        }\n\n        try {\n            $select = $this->zdb->select($this->table);\n            $select->where([$this->fpk => $id]);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if (!$result) {\n                $this->errors[] = _T(\"Label does not exist\");\n                return false;\n            }\n\n            return $result;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get a label\n     *\n     * @param integer $id         Id\n     * @param boolean $translated Do we want translated or original label?\n     *                            Defaults to true.\n     *\n     * @return string\n     */\n    public function getLabel($id, $translated = true)\n    {\n        $res = $this->get($id);\n        if ($res === false) {\n            //get() already logged\n            return self::ID_NOT_EXITS;\n        };\n        $field = $this->flabel;\n        return ($translated) ? _T($res->$field) : $res->$field;\n    }\n\n    /**\n     * Get an ID from a label\n     *\n     * @param string $label The label\n     *\n     * @return int|false Return id if it exists false otherwise\n     */\n    public function getIdByLabel($label)\n    {\n        try {\n            $pk = $this->fpk;\n            $select = $this->zdb->select($this->table);\n            $select->columns(array($pk))\n                ->where(array($this->flabel => $label));\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                return $result->$pk;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to retrieve ' . $this->getType() . ' from label `' .\n                $label . '` | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Add a new entry\n     *\n     * @param string  $label The label\n     * @param integer $extra Extra values (priority for statuses,\n     *                       extension for contributions types, ...)\n     *\n     * @return integer id if success ; -1 : DB error ; -2 : label already exists\n     */\n    public function add($label, $extra)\n    {\n        // Avoid duplicates.\n        $ret = $this->getIdByLabel($label);\n\n        if ($ret !== false) {\n            Analog::log(\n                $this->getType() . ' with label `' . $label . '` already exists',\n                Analog::WARNING\n            );\n            return -2;\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array(\n                $this->flabel  => $label,\n                $this->fthird  => $extra\n            );\n\n            $insert = $this->zdb->insert($this->table);\n            $insert->values($values);\n\n            $ret = $this->zdb->execute($insert);\n\n            if ($ret->count() > 0) {\n                Analog::log(\n                    'New ' . $this->getType() . ' `' . $label .\n                    '` added successfully.',\n                    Analog::INFO\n                );\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                $this->addTranslation($label);\n            } else {\n                throw new \\Exception('New ' . $this->getType() . ' not added.');\n            }\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to add new entry `' . $label . '` | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Update in database.\n     *\n     * @param integer $id    Entry ID\n     * @param string  $label The label\n     * @param integer $extra Extra values (priority for statuses,\n     *                       extension for contributions types, ...)\n     *\n     * @return ID_NOT_EXITS|boolean\n     */\n    public function update($id, $label, $extra)\n    {\n        $ret = $this->get($id);\n        if (!$ret) {\n            /* get() already logged and set $this->error. */\n            return self::ID_NOT_EXITS;\n        }\n\n        $class = get_class($this);\n\n        try {\n            $oldlabel = $ret->{$this->flabel};\n            $this->zdb->connection->beginTransaction();\n            $values = array(\n                $this->flabel  => $label,\n                $this->fthird  => $extra\n            );\n\n            $update = $this->zdb->update($this->table);\n            $update->set($values);\n            $update->where([$this->fpk => $id]);\n\n            $ret = $this->zdb->execute($update);\n\n            if ($oldlabel != $label) {\n                $this->deleteTranslation($oldlabel);\n                $this->addTranslation($label);\n            }\n\n            Analog::log(\n                $this->getType() . ' #' . $id . ' updated successfully.',\n                Analog::INFO\n            );\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to update ' . $this->getType() . ' #' . $id . ' | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Delete entry\n     *\n     * @param integer $id Entry ID\n     *\n     * @return ID_NOT_EXITS|boolean\n     */\n    public function delete($id)\n    {\n        $ret = $this->get($id);\n        if (!$ret) {\n            /* get() already logged */\n            return self::ID_NOT_EXITS;\n        }\n\n        if ($this->isUsed($id)) {\n            $this->errors[] = _T(\"Cannot delete this label: it's still used\");\n            return false;\n        }\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $delete = $this->zdb->delete($this->table);\n            $delete->where([$this->fpk => $id]);\n\n            $this->zdb->execute($delete);\n            $this->deleteTranslation($ret->{$this->flabel});\n\n            Analog::log(\n                $this->getType() . ' ' . $id . ' deleted successfully.',\n                Analog::INFO\n            );\n\n            $this->zdb->connection->commit();\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Unable to delete ' . $this->getType() . ' ' . $id .\n                ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Check if this entry is used.\n     *\n     * @param integer $id Entry ID\n     *\n     * @return boolean\n     */\n    public function isUsed($id)\n    {\n        try {\n            $select = $this->zdb->select($this->used);\n            $select->where([$this->fpk => $id]);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n\n            if ($result !== null) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to check if ' . $this->getType . ' `' . $id .\n                '` is used. | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            //in case of error, we consider that it is used, to avoid errors\n            return true;\n        }\n    }\n\n    /**\n     * Get textual type representation\n     *\n     * @return string\n     */\n    abstract protected function getType();\n\n    /**\n     * Get translated textual representation\n     *\n     * @return string\n     */\n    abstract public function getI18nType();\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrive\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array();\n        $virtuals = array('extension', 'libelle');\n        if (\n            in_array($name, $virtuals)\n            || !in_array($name, $forbidden)\n            && isset($this->$name)\n        ) {\n            switch ($name) {\n                case 'libelle':\n                    return _T($this->label);\n                    break;\n                case 'extension':\n                    return $this->third;\n                    break;\n                default:\n                    return $this->$name;\n                    break;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors(): array\n    {\n        return $this->errors;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Group entity\n *\n * PHP version 5\n *\n * Copyright \u00a9 2012-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2012-01-17\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Login;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * Group entity\n *\n * @category  Entity\n * @name      Group\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2012-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2012-01-17\n */\nclass Group\n{\n    public const TABLE = 'groups';\n    public const PK = 'id_group';\n    //relations tables\n    public const GROUPSUSERS_TABLE = 'groups_members';\n    public const GROUPSMANAGERS_TABLE = 'groups_managers';\n\n    public const MEMBER_TYPE = 0;\n    public const MANAGER_TYPE = 1;\n\n    private $id;\n    private $group_name;\n    private $parent_group;\n    private $managers;\n    private $members;\n    private $groups;\n    private $creation_date;\n    private $count_members;\n    private $isempty;\n\n    /**\n     * Default constructor\n     *\n     * @param null|int|ResultSet $args Either a ResultSet row or its id for to load\n     *                                 a specific group, or null to just\n     *                                 instanciate object\n     */\n    public function __construct($args = null)\n    {\n        if ($args == null || is_int($args)) {\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n    }\n\n    /**\n     * Loads a group from its id\n     *\n     * @param int $id the identifiant for the group to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->where(array(self::PK => $id));\n\n            $results = $zdb->execute($select);\n\n            if ($results->count() > 0) {\n                $this->loadFromRS($results->current());\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load group form id `' . $id . '` | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->id = $r->id_group;\n        $this->group_name = $r->group_name;\n        $this->creation_date = $r->creation_date;\n        if ($r->parent_group) {\n            $this->parent_group = new Group((int)$r->parent_group);\n        }\n        $adhpk = Adherent::PK;\n        if (isset($r->members)) {\n            //we're from a list, we just want members count\n            $this->count_members = $r->members;\n        } else {\n            //we're probably from a single group, let's load sub entities\n            //$this->loadPersons(self::MEMBER_TYPE);\n            //$this->loadPersons(self::MANAGER_TYPE);\n            //$this->loadSubGroups();\n        }\n    }\n\n    /**\n     * Loads members for the current group\n     *\n     * @param int $type Either self::MEMBER_TYPE or self::MANAGER_TYPE\n     *\n     * @return void\n     */\n    private function loadPersons($type)\n    {\n        global $zdb;\n\n        if ($this->id) {\n            try {\n                $join = null;\n                switch ($type) {\n                    case self::MEMBER_TYPE:\n                        $join = PREFIX_DB . self::GROUPSUSERS_TABLE;\n                        break;\n                    case self::MANAGER_TYPE:\n                        $join = PREFIX_DB . self::GROUPSMANAGERS_TABLE;\n                        break;\n                }\n\n                $select = $zdb->select(Adherent::TABLE, 'a');\n                $select->join(\n                    array('g' => $join),\n                    'g.' . Adherent::PK . '=a.' . Adherent::PK,\n                    array()\n                )->where([\n                    'g.' . self::PK => $this->id\n                ])->order(\n                    'nom_adh ASC',\n                    'prenom_adh ASC'\n                );\n\n                $results = $zdb->execute($select);\n                $members = array();\n\n                $deps = array(\n                    'picture'   => false,\n                    'groups'    => false,\n                    'dues'      => false\n                );\n\n                foreach ($results as $m) {\n                    $members[] = new Adherent($zdb, $m, $deps);\n                }\n\n                if ($type === self::MEMBER_TYPE) {\n                    $this->members = $members;\n                } else {\n                    $this->managers = $members;\n                }\n            } catch (Throwable $e) {\n                Analog::log(\n                    'Cannot get group persons | ' . $e->getMessage(),\n                    Analog::WARNING\n                );\n                throw $e;\n            }\n        }\n    }\n\n    /**\n     * Load sub-groups\n     *\n     * @return void\n     */\n    private function loadSubGroups()\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE, 'a');\n\n            if (!$this->login->isAdmin() && !$this->login->isStaff()) {\n                $select->join(\n                    array('b' => PREFIX_DB . self::GROUPSMANAGERS_TABLE),\n                    'a.' . self::PK . '=b.' . self::PK,\n                    array()\n                )->where(['b.' . Adherent::PK => $this->login->id]);\n            }\n\n            $select->where(['parent_group' => $this->id])\n                ->order('group_name ASC');\n\n            $results = $zdb->execute($select);\n            $groups = array();\n            $grppk = self::PK;\n            foreach ($results as $m) {\n                $group = new Group((int)$m->$grppk);\n                $group->setLogin($this->login);\n                $groups[] = $group;\n            }\n            $this->groups = $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot get subgroup for group ' . $this->group_name .\n                ' (' . $this->id . ')| ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified group\n     *\n     * @param boolean $cascade Also remove members and managers\n     *\n     * @return boolean\n     */\n    public function remove($cascade = false)\n    {\n        global $zdb;\n        $transaction = false;\n\n        try {\n            if (!$zdb->connection->inTransaction()) {\n                $zdb->connection->beginTransaction();\n                $transaction = true;\n            }\n\n            if ($cascade === true) {\n                $subgroups = $this->getGroups();\n                if (count($subgroups) > 0) {\n                    Analog::log(\n                        'Cascading remove ' . $this->group_name .\n                        '. Subgroups, their members and managers will be detached.',\n                        Analog::INFO\n                    );\n                    foreach ($subgroups as $subgroup) {\n                        $subgroup->remove(true);\n                    }\n                }\n\n                Analog::log(\n                    'Cascading remove ' . $this->group_name .\n                    '. Members and managers will be detached.',\n                    Analog::INFO\n                );\n\n                //delete members\n                $delete = $zdb->delete(self::GROUPSUSERS_TABLE);\n                $delete->where([self::PK => $this->id]);\n                $zdb->execute($delete);\n\n                //delete managers\n                $delete = $zdb->delete(self::GROUPSMANAGERS_TABLE);\n                $delete->where([self::PK => $this->id]);\n                $zdb->execute($delete);\n            }\n\n            //delete group itself\n            $delete = $zdb->delete(self::TABLE);\n            $delete->where([self::PK => $this->id]);\n            $zdb->execute($delete);\n\n            //commit all changes\n            if ($transaction) {\n                $zdb->connection->commit();\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $zdb->connection->rollBack();\n            }\n            if ($e->getCode() == 23000) {\n                Analog::log(\n                    str_replace(\n                        '%group',\n                        $this->group_name,\n                        'Group \"%group\" still have members!'\n                    ),\n                    Analog::WARNING\n                );\n                $this->isempty = false;\n            } else {\n                Analog::log(\n                    'Unable to delete group ' . $this->group_name .\n                    ' (' . $this->id . ') |' . $e->getMessage(),\n                    Analog::ERROR\n                );\n                throw $e;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Is group empty? (after first deletion try)\n     *\n     * @return boolean\n     */\n    public function isEmpty()\n    {\n        return $this->isempty;\n    }\n\n    /**\n     * Detach a group from its parent\n     *\n     * @return boolean\n     */\n    public function detach()\n    {\n        global $zdb, $hist;\n\n        try {\n            $update = $zdb->update(self::TABLE);\n            $update->set(\n                array('parent_group' => new Expression('NULL'))\n            )->where(\n                [self::PK => $this->id]\n            );\n\n            $edit = $zdb->execute($update);\n\n            //edit == 0 does not mean there were an error, but that there\n            //were nothing to change\n            if ($edit->count() > 0) {\n                $this->parent_group = null;\n                $hist->add(\n                    _T(\"Group has been detached from its parent\"),\n                    $this->group_name\n                );\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong detaching group `' . $this->group_name .\n                '` (' . $this->id . ') from its parent:\\'( | ' .\n                $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the group\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        global $zdb, $hist;\n\n        try {\n            $values = array(\n                self::PK     => $this->id,\n                'group_name' => $this->group_name\n            );\n\n            if ($this->parent_group) {\n                $values['parent_group'] = $this->parent_group->getId();\n            }\n\n            if (!isset($this->id) || $this->id == '') {\n                //we're inserting a new group\n                unset($values[self::PK]);\n                $this->creation_date = date(\"Y-m-d H:i:s\");\n                $values['creation_date'] = $this->creation_date;\n\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->id = $zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Group added\"),\n                        $this->group_name\n                    );\n                    return true;\n                } else {\n                    $hist->add(_T(\"Fail to add new group.\"));\n                    throw new \\Exception(\n                        'An error occurred inserting new group!'\n                    );\n                }\n            } else {\n                //we're editing an existing group\n                $update = $zdb->update(self::TABLE);\n                $update\n                    ->set($values)\n                    ->where([self::PK => $this->id]);\n\n                $edit = $zdb->execute($update);\n\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Group updated\"),\n                        $this->group_name\n                    );\n                }\n                return true;\n            }\n            /** FIXME: also store members and managers? */\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Is current logged-in user manager of the group?\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function isManager(Login $login)\n    {\n        if ($login->isAdmin() || $login->isStaff()) {\n            //admins as well as staff members are managers for all groups!\n            return true;\n        } else {\n            //let's check if current logged-in user is part of group managers\n            foreach ($this->managers as $manager) {\n                if ($login->login == $manager->login) {\n                    return true;\n                    break;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get group id\n     *\n     * @return integer\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Get Level of the group\n     *\n     * @return integer\n     */\n    public function getLevel()\n    {\n        if ($this->parent_group) {\n            return $this->parent_group->getLevel() + 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Get the full name of the group \"foo / bar\"\n     *\n     * @return string\n     */\n    public function getFullName()\n    {\n        if ($this->parent_group) {\n            return $this->parent_group->getFullName() . ' / ' . $this->group_name;\n        }\n        return $this->group_name;\n    }\n\n    /**\n     * Get the indented short name of the group \"  >> bar\"\n     *\n     * @return string\n     */\n    public function getIndentName()\n    {\n        if (($level = $this->getLevel())) {\n            return str_repeat(\"&nbsp;\", 3 * $level) . '&raquo; ' . $this->group_name;\n        }\n        return $this->group_name;\n    }\n\n    /**\n     * Get group name\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->group_name;\n    }\n\n    /**\n     * Get group members\n     *\n     * @return Adherent[]\n     */\n    public function getMembers()\n    {\n        if (!is_array($this->members)) {\n            $this->loadPersons(self::MEMBER_TYPE);\n        }\n        return $this->members;\n    }\n\n    /**\n     * Get groups managers\n     *\n     * @return Adherent[]\n     */\n    public function getManagers()\n    {\n        if (!is_array($this->managers)) {\n            $this->loadPersons(self::MANAGER_TYPE);\n        }\n        return $this->managers;\n    }\n\n    /**\n     * Get subgroups\n     *\n     * @return Group[]\n     */\n    public function getGroups()\n    {\n        if (!is_array($this->groups)) {\n            $this->loadSubGroups();\n        }\n        return $this->groups;\n    }\n\n    /**\n     * Get parent group\n     *\n     * @return Group\n     */\n    public function getParentGroup()\n    {\n        return $this->parent_group;\n    }\n\n    /**\n     * Get group creation date\n     *\n     * @param boolean $formatted Return date formatted, raw if false\n     *\n     * @return string\n     */\n    public function getCreationDate($formatted = true)\n    {\n        if ($formatted === true) {\n            $date = new \\DateTime($this->creation_date);\n            return $date->format(__(\"Y-m-d\"));\n        } else {\n            return $this->creation_date;\n        }\n    }\n\n    /**\n     * Get member count\n     *\n     * @param boolean $force Force members load, defaults to false\n     *\n     * @return int\n     */\n    public function getMemberCount($force = false)\n    {\n        if (isset($this->members) && is_array($this->members)) {\n            return count($this->members);\n        } elseif (isset($this->count_members)) {\n            return $this->count_members;\n        } else {\n            if ($force === true) {\n                return count($this->getMembers());\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Group name\n     *\n     * @return Group\n     */\n    public function setName($name)\n    {\n        $this->group_name = $name;\n        return $this;\n    }\n\n    /**\n     * Set all subgroups\n     *\n     * @param array $groups Groups id\n     *\n     * @return Group\n     */\n    public function setSubgroups($groups)\n    {\n        $this->groups = $groups;\n        return $this;\n    }\n\n    /**\n     * check if can Set parent group\n     *\n     * @param Group $group Parent group\n     *\n     * @return boolean\n     */\n    public function canSetParentGroup(Group $group)\n    {\n        do {\n            if ($group->getId() == $this->getId()) {\n                return false;\n            }\n        } while ($group = $group->getParentGroup());\n\n        return true;\n    }\n\n    /**\n     * Set parent group\n     *\n     * @param int $id Parent group identifier\n     *\n     * @return Group\n     */\n    public function setParentGroup($id)\n    {\n        $group = new Group((int)$id);\n\n        if (!$this->canSetParentGroup($group)) {\n            //does not seem to work :/\n            throw new \\Exception(\n                sprintf(\n                    _T('Group `%1$s` cannot be set as parent!'),\n                    $group->getName()\n                )\n            );\n        }\n\n        $this->parent_group = $group;\n        return $this;\n    }\n\n    /**\n     * Set members\n     *\n     * @param Adherent[] $members Members list\n     *\n     * @return void\n     */\n    public function setMembers($members)\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //first, remove current groups members\n            $delete = $zdb->delete(self::GROUPSUSERS_TABLE);\n            $delete->where([self::PK => $this->id]);\n            $zdb->execute($delete);\n\n            Analog::log(\n                'Group members has been removed for `' . $this->group_name .\n                '`, we can now store new ones.',\n                Analog::INFO\n            );\n\n            $insert = $zdb->insert(self::GROUPSUSERS_TABLE);\n            $insert->values(\n                array(\n                    self::PK        => ':group',\n                    Adherent::PK    => ':adh'\n                )\n            );\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n            if (is_array($members)) {\n                foreach ($members as $m) {\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $this->id,\n                            'adh'   => $m->id\n                        )\n                    );\n\n                    if ($result) {\n                        Analog::log(\n                            'Member `' . $m->sname . '` attached to group `' .\n                            $this->group_name . '`.',\n                            Analog::DEBUG\n                        );\n                    } else {\n                        Analog::log(\n                            'An error occurred trying to attach member `' .\n                            $m->sname . '` to group `' . $this->group_name .\n                            '` (' . $this->id . ').',\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to attach `' . $m->sname . '` ' .\n                            'to ' . $this->group_name . '(' . $this->id . ')'\n                        );\n                    }\n                }\n            }\n            //commit all changes\n            $zdb->connection->commit();\n\n            Analog::log(\n                'Group members updated successfully.',\n                Analog::INFO\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            $messages = array();\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                'Unable to attach members to group `' . $this->group_name .\n                '` (' . $this->id . ')|' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set managers\n     *\n     * @param Adherent[] $members Managers list\n     *\n     * @return boolean\n     */\n    public function setManagers($members)\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //first, remove current groups managers\n            $delete = $zdb->delete(self::GROUPSMANAGERS_TABLE);\n            $delete->where([self::PK => $this->id]);\n            $zdb->execute($delete);\n\n            Analog::log(\n                'Group managers has been removed for `' . $this->group_name .\n                '`, we can now store new ones.',\n                Analog::INFO\n            );\n\n            $insert = $zdb->insert(self::GROUPSMANAGERS_TABLE);\n            $insert->values(\n                array(\n                    self::PK        => ':group',\n                    Adherent::PK    => ':adh'\n                )\n            );\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n            if (is_array($members)) {\n                foreach ($members as $m) {\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $this->id,\n                            'adh'   => $m->id\n                        )\n                    );\n\n                    if ($result) {\n                        Analog::log(\n                            'Manager `' . $m->sname . '` attached to group `' .\n                            $this->group_name . '`.',\n                            Analog::DEBUG\n                        );\n                    } else {\n                        Analog::log(\n                            'An error occurred trying to attach manager `' .\n                            $m->sname . '` to group `' . $this->group_name .\n                            '` (' . $this->id . ').',\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to attach `' . $m->sname . '` ' .\n                            'to ' . $this->group_name . '(' . $this->id . ')'\n                        );\n                    }\n                }\n            }\n            //commit all changes\n            $zdb->connection->commit();\n\n            Analog::log(\n                'Groups managers updated successfully.',\n                Analog::INFO\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            $messages = array();\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                'Unable to attach managers to group `' . $this->group_name .\n                '` (' . $this->id . ')|' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Set login instance\n     *\n     * @param Login $login Login instance\n     *\n     * @return Group\n     */\n    public function setLogin(Login $login)\n    {\n        $this->login = $login;\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Import model\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.6dev - 2013-09-26\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\n\n/**\n * Import model entity\n *\n * @category  Entity\n * @name      ImportModel\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.6dev - 2013-09-26\n */\nclass ImportModel\n{\n    public const TABLE = 'import_model';\n    public const PK = 'model_id';\n\n    private $id;\n    private $fields;\n    private $creation_date;\n\n    /**\n     * Loads model\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load()\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1);\n\n            $results = $zdb->execute($select);\n            $result = $results->current();\n\n            if ($result) {\n                $this->loadFromRS($result);\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load import model | ' . $e->getMessage() .\n                \"\\n\" . $e->__toString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $this->id = $r->model_id;\n        $this->fields = unserialize($r->model_fields);\n        $this->creation_date = $r->model_creation_date;\n    }\n\n    /**\n     * Remove model\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function remove($zdb)\n    {\n        try {\n            $result = $zdb->db->query(\n                'TRUNCATE TABLE ' . PREFIX_DB . self::TABLE,\n                Adapter::QUERY_MODE_EXECUTE\n            );\n\n            if ($result) {\n                $this->id = null;\n                $this->fields = null;\n                $this->creation_date = null;\n                return true;\n            }\n\n            return false;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to remove import model ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store the model\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function store($zdb)\n    {\n        try {\n            $values = array(\n                self::PK        => $this->id,\n                'model_fields'  => serialize($this->fields)\n            );\n\n            if (!isset($this->id) || $this->id == '') {\n                //we're inserting a new model\n                unset($values[self::PK]);\n                $this->creation_date = date(\"Y-m-d H:i:s\");\n                $values['model_creation_date'] = $this->creation_date;\n\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($values);\n                $results = $zdb->execute($insert);\n\n                if ($results->count() > 0) {\n                    return true;\n                } else {\n                    throw new \\Exception(\n                        'An error occurred inserting new import model!'\n                    );\n                }\n            } else {\n                //we're editing an existing model\n                $update = $zdb->update(self::TABLE);\n                $update->set($values);\n                $update->where([self::PK => $this->id]);\n                $zdb->execute($update);\n                return true;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Something went wrong storing import model :\\'( | ' .\n                $e->getMessage() . \"\\n\" . $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get fields\n     *\n     * @return array\n     */\n    public function getFields()\n    {\n        return $this->fields;\n    }\n\n    /**\n     * Get creation date\n     *\n     * @param boolean $formatted Return date formatted, raw if false\n     *\n     * @return string\n     */\n    public function getCreationDate($formatted = true)\n    {\n        if ($formatted === true) {\n            $date = new \\DateTime($this->creation_date);\n            return $date->format(__(\"Y-m-d\"));\n        } else {\n            return $this->creation_date;\n        }\n    }\n\n    /**\n     * Set fields\n     *\n     * @param array $fields Fields list\n     *\n     * @return void\n     */\n    public function setFields($fields)\n    {\n        $this->fields = $fields;\n        return $this;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Payment type\n *\n * PHP version 5\n *\n * Copyright \u00a9 2018-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2018-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.2dev - 2018-07-23\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Analog\\Analog;\nuse Galette\\Features\\I18n;\nuse Galette\\Features\\Translatable;\n\n/**\n * Payment type\n *\n * @category  Entity\n * @name      PaymentType\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2018-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.2dev - 2018-07-23\n */\n\nclass PaymentType\n{\n    use Translatable;\n    use I18n;\n\n    public const TABLE = 'paymenttypes';\n    public const PK = 'type_id';\n\n    private $zdb;\n    private $id;\n\n    public const OTHER = 6;\n    public const CASH = 1;\n    public const CREDITCARD = 2;\n    public const CHECK = 3;\n    public const TRANSFER = 4;\n    public const PAYPAL = 5;\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a payment type from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where([self::PK => $id]);\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n\n            $this->id = $id;\n            $this->name = $res->type_name;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading payment type #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load payment type from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->name = $rs->type_name;\n    }\n\n    /**\n     * Store payment type in database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        $data = array(\n            'type_name' => $this->name\n        );\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                if ($this->old_name !== null) {\n                    $this->deleteTranslation($this->old_name);\n                    $this->addTranslation($this->name);\n                }\n\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($data)->where([self::PK => $this->id]);\n                $this->zdb->execute($update);\n            } else {\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $this->zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n\n                $this->addTranslation($this->name);\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing payment type: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current title\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        $id = (int)$this->id;\n        if ($this->isSystemType()) {\n            throw new \\RuntimeException(_T(\"You cannot delete system payment types!\"));\n        }\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $id]);\n            $this->zdb->execute($delete);\n            $this->deleteTranslation($this->name);\n            Analog::log(\n                'Payment type #' . $id . ' (' . $this->name\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete payment type ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'id':\n            case 'name':\n                return $this->$name;\n                break;\n            default:\n                Analog::log(\n                    'Unable to get Title property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'name':\n                if (trim($value) === '') {\n                    Analog::log(\n                        'Name cannot be empty',\n                        Analog::WARNING\n                    );\n                } else {\n                    $this->old_name = $this->name;\n                    $this->name     = $value;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Get system payment types\n     *\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return array\n     */\n    public function getSystemTypes($translated = true)\n    {\n        if ($translated) {\n            $systypes = [\n                self::OTHER         => _T(\"Other\"),\n                self::CASH          => _T(\"Cash\"),\n                self::CREDITCARD    => _T(\"Credit card\"),\n                self::CHECK         => _T(\"Check\"),\n                self::TRANSFER      => _T(\"Transfer\"),\n                self::PAYPAL        => _T(\"Paypal\")\n            ];\n        } else {\n            $systypes = [\n                self::OTHER         => \"Other\",\n                self::CASH          => \"Cash\",\n                self::CREDITCARD    => \"Credit card\",\n                self::CHECK         => \"Check\",\n                self::TRANSFER      => \"Transfer\",\n                self::PAYPAL        => \"Paypal\"\n            ];\n        }\n        return $systypes;\n    }\n\n    /**\n     * Is current payment a system one\n     *\n     * @return boolean\n     *\n     */\n    public function isSystemType()\n    {\n        return isset($this->getSystemTypes()[$this->id]);\n    }\n\n    /**\n     * Simple text representation\n     *\n     * @return string\n     */\n    public function __toString()\n    {\n        return $this->getName();\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * PDF Model\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-19\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Preferences;\nuse Galette\\Features\\Replacements;\nuse Galette\\Repository\\PdfModels;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\n\n/**\n * PDF Model\n *\n * @category  Entity\n * @name      PdfModel\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-19\n *\n * @property integer $id\n * @property string $name\n * @property integer $type\n * @property string $header\n * @property string $footer\n * @property string $title\n * @property string $subtitle\n * @property string $body\n * @property string $styles\n * @property PdfMain $parent\n */\n\nabstract class PdfModel\n{\n    use Replacements;\n\n    public const TABLE = 'pdfmodels';\n    public const PK = 'model_id';\n\n    public const MAIN_MODEL = 1;\n    public const INVOICE_MODEL = 2;\n    public const RECEIPT_MODEL = 3;\n    public const ADHESION_FORM_MODEL = 4;\n\n    private $id;\n    private $name;\n    private $type;\n    private $header;\n    private $footer;\n    private $title;\n    private $subtitle;\n    private $body;\n    private $styles;\n    private $parent;\n\n    /**\n     * Main constructor\n     *\n     * @param Db          $zdb         Database instance\n     * @param Preferences $preferences Galette preferences\n     * @param int         $type        Model type\n     * @param mixed       $args        Arguments\n     */\n    public function __construct(Db $zdb, Preferences $preferences, $type, $args = null)\n    {\n        global $container, $login;\n        $this->router = $container->get('router');\n        $this->preferences = $preferences;\n        $this\n            ->setDb($zdb)\n            ->setLogin($login);\n        $this->type = $type;\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        } else {\n            $this->load($type);\n        }\n\n        $this->setPatterns($this->getMainPatterns());\n        $this->setMain();\n    }\n\n    /**\n     * Load a Model from its identifier\n     *\n     * @param int     $id   Identifier\n     * @param boolean $init Init data if required model is missing\n     *\n     * @return void\n     */\n    protected function load($id, $init = true)\n    {\n        global $login;\n\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)\n                ->where([self::PK => $id]);\n\n            $results = $this->zdb->execute($select);\n\n            $count = $results->count();\n            if ($count === 0) {\n                if ($init === true) {\n                    $models = new PdfModels($this->zdb, $this->preferences, $login);\n                    $models->installInit();\n                    $this->load($id, false);\n                } else {\n                    throw new \\RuntimeException('Model not found!');\n                }\n            } else {\n                $this->loadFromRs($results->current());\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading model #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load model from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    protected function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = (int)$rs->$pk;\n\n        $callback = function ($matches) {\n            return _T($matches[1]);\n        };\n        $this->name = preg_replace_callback(\n            '/_T\\(\"([^\\\"]+)\"\\)/',\n            $callback,\n            $rs->model_name\n        );\n\n        $this->title = $rs->model_title;\n        $this->subtitle = $rs->model_subtitle;\n        $this->header = $rs->model_header;\n        $this->footer = $rs->model_footer;\n        $this->body = $rs->model_body;\n        $this->styles .= $rs->model_styles;\n\n        if ($this->id > self::MAIN_MODEL) {\n            //FIXME: for now, parent will always be a PdfMain\n            $this->parent = new PdfMain(\n                $this->zdb,\n                $this->preferences,\n                (int)$rs->model_parent\n            );\n        }\n    }\n\n    /**\n     * Store model in database\n     *\n     * @return boolean\n     */\n    public function store()\n    {\n        $title = $this->title;\n        if ($title === null || trim($title) === '') {\n            $title = new Expression('NULL');\n        }\n\n        $subtitle = $this->subtitle;\n        if ($subtitle === null || trim($subtitle) === '') {\n            $subtitle = new Expression('NULL');\n        }\n\n        $data = array(\n            'model_header'      => $this->header,\n            'model_footer'      => $this->footer,\n            'model_type'        => $this->type,\n            'model_title'       => $title,\n            'model_subtitle'    => $subtitle,\n            'model_body'        => $this->body,\n            'model_styles'      => $this->styles\n        );\n\n        try {\n            if ($this->id !== null) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($data)->where(\n                    [self::PK => $this->id]\n                );\n                $this->zdb->execute($update);\n            } else {\n                $data['model_name'] = $this->name;\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $this->zdb->execute($insert);\n                if (!($add->count() > 0)) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing model: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get object class for specified type\n     *\n     * @param int $type Type\n     *\n     * @return string\n     */\n    public static function getTypeClass(int $type)\n    {\n        $class = null;\n        switch ($type) {\n            case self::INVOICE_MODEL:\n                $class = 'PdfInvoice';\n                break;\n            case self::RECEIPT_MODEL:\n                $class = 'PdfReceipt';\n                break;\n            case self::ADHESION_FORM_MODEL:\n                $class = 'PdfAdhesionFormModel';\n                break;\n            default:\n                $class = 'PdfMain';\n                break;\n        }\n        $class = 'Galette\\\\Entity\\\\' . $class;\n        return $class;\n    }\n\n    /**\n     * Check length\n     *\n     * @param string  $value The value\n     * @param int     $chars Length\n     * @param string  $field Field name\n     * @param boolean $empty Can value be empty\n     *\n     * @return void\n     */\n    protected function checkChars($value, $chars, $field, $empty = false)\n    {\n        if ($value !== null && trim($value) !== '') {\n            if (mb_strlen($value) > $chars) {\n                throw new \\LengthException(\n                    str_replace(\n                        array('%field', '%chars'),\n                        array($field, $chars),\n                        _T(\"%field should be less than %chars characters long.\")\n                    )\n                );\n            }\n        } else {\n            if ($empty === false) {\n                throw new \\UnexpectedValueException(\n                    str_replace(\n                        '%field',\n                        $field,\n                        _T(\"%field should not be empty!\")\n                    )\n                );\n            }\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'name':\n            case 'id':\n            case 'header':\n            case 'footer':\n            case 'body':\n            case 'title':\n            case 'subtitle':\n            case 'type':\n            case 'styles':\n            case 'patterns':\n            case 'replaces':\n                return $this->$name;\n                break;\n            case 'hstyles':\n                $value = null;\n\n                //get header and footer from parent if not defined in current model\n                if (\n                    $this->id > self::MAIN_MODEL\n                    && $this->parent !== null\n                ) {\n                    $value = $this->parent->styles;\n                }\n\n                $value .= $this->styles;\n                return $value;\n                break;\n            case 'hheader':\n            case 'hfooter':\n            case 'htitle':\n            case 'hsubtitle':\n            case 'hbody':\n                $pname = substr($name, 1);\n                $prop_value = $this->$pname ?? '';\n\n                //get header and footer from parent if not defined in current model\n                if (\n                    $this->id > self::MAIN_MODEL\n                    && $this->parent !== null\n                    && ($pname === 'footer'\n                    || $pname === 'header')\n                    && trim($prop_value) === ''\n                ) {\n                    $prop_value = $this->parent->$pname;\n                }\n\n                $value = $this->proceedReplacements($prop_value);\n                return $value;\n                break;\n            default:\n                Analog::log(\n                    'Unable to get PdfModel property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'type':\n                if (\n                    $value === self::MAIN_MODEL\n                    || $value === self::INVOICE_MODEL\n                    || $value === self::RECEIPT_MODEL\n                    || $value === self::ADHESION_FORM_MODEL\n                ) {\n                    $this->$name = $value;\n                } else {\n                    throw new \\UnexpectedValueException(\n                        str_replace(\n                            '%type',\n                            $value,\n                            _T(\"Unknown type %type!\")\n                        )\n                    );\n                }\n                break;\n            case 'name':\n                try {\n                    $this->checkChars($value, 50, _T(\"Name\"));\n                    $this->$name = $value;\n                } catch (Throwable $e) {\n                    throw $e;\n                }\n                break;\n            case 'title':\n            case 'subtitle':\n                if ($name == 'title') {\n                    $field = _T(\"Title\");\n                } else {\n                    $field = _T(\"Subtitle\");\n                }\n                try {\n                    $this->checkChars($value, 100, $field, true);\n                    $this->$name = $value;\n                } catch (Throwable $e) {\n                    throw $e;\n                }\n                break;\n            case 'header':\n            case 'footer':\n            case 'body':\n                if ($value === null || trim($value) === '') {\n                    if ($name !== 'body' && get_class($this) === 'PdfMain') {\n                        throw new \\UnexpectedValueException(\n                            _T(\"header and footer should not be empty!\")\n                        );\n                    } elseif ($name === 'body' && get_class($this) !== 'PdfMain') {\n                        throw new \\UnexpectedValueException(\n                            _T(\"body should not be empty!\")\n                        );\n                    }\n                }\n\n                $this->$name = $value;\n                break;\n            case 'styles':\n                $this->styles = $value;\n                break;\n            default:\n                Analog::log(\n                    'Unable to set PdfModel property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Reminders\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-11\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Features\\Replacements;\nuse Throwable;\nuse Analog\\Analog;\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\History;\n\n/**\n * Reminders\n *\n * @category  Entity\n * @name      Reminder\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.5dev - 2013-02-11\n */\n\nclass Reminder\n{\n    use Replacements;\n\n    public const TABLE = 'reminders';\n    public const PK = 'reminder_id';\n\n    private $id;\n    private $type;\n    private $dest;\n    private $date;\n    /** @var boolean */\n    private $success = false;\n    /** @var boolean */\n    private $nomail;\n    private $comment;\n    private $msg;\n\n    public const IMPENDING = 1;\n    public const LATE = 2;\n\n    /**\n     * Main constructor\n     *\n     * @param mixed $args Arguments\n     */\n    public function __construct($args = null)\n    {\n        if ($args !== null) {\n            if (is_int($args)) {\n                $this->load($args);\n            } elseif (is_object($args)) {\n                $this->loadFromRs($args);\n            } else {\n                Analog::log(\n                    __METHOD__ . ': unknonw arg',\n                    Analog::WARNING\n                );\n            }\n        }\n    }\n\n    /**\n     * Load a reminder from its id\n     *\n     * @param int $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        global $zdb;\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1)\n                ->where([self::PK => $id]);\n\n            $results = $zdb->execute($select);\n            $this->loadFromRs($results->current());\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading reminder #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load reminder from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        global $zdb;\n\n        try {\n            $pk = self::PK;\n            $this->id = $rs->$pk;\n            $this->type = $rs->reminder_type;\n            $this->dest = new Adherent($zdb, (int)$rs->reminder_dest);\n            $this->date = $rs->reminder_date;\n            $this->success = $rs->reminder_success;\n            $this->nomail = $rs->reminder_nomail;\n            $this->comment = $rs->reminder_comment;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ': incorrect ResultSet. Error: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Store reminder in database and history\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    private function store($zdb)\n    {\n        $now = new \\DateTime();\n        $data = array(\n            'reminder_type'     => $this->type,\n            'reminder_dest'     => $this->dest->id,\n            'reminder_date'     => $now->format('Y-m-d'),\n            'reminder_success'  => ($this->success) ?\n                true :\n                ($zdb->isPostgres() ? 'false' : 0),\n            'reminder_nomail'   => ($this->nomail) ?\n                true :\n                ($zdb->isPostgres() ? 'false' : 0)\n        );\n        try {\n            $insert = $zdb->insert(self::TABLE);\n            $insert->values($data);\n\n            $add = $zdb->execute($insert);\n            if (!($add->count() > 0)) {\n                Analog::log('Reminder not stored!', Analog::ERROR);\n                return false;\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing reminder: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Was reminder sent successfully?\n     *\n     * @return boolean\n     */\n    public function isSuccess()\n    {\n        return $this->success;\n    }\n\n    /**\n     * Did member had an email when reminder was sent?\n     *\n     * @return boolean\n     */\n    public function hasMail()\n    {\n        return !$this->nomail;\n    }\n\n    /**\n     * Send the reminder\n     *\n     * @param Texts   $texts Text object\n     * @param History $hist  History\n     * @param Db      $zdb   Database instance\n     *\n     * @return boolean\n     */\n    public function send(Texts $texts, History $hist, Db $zdb)\n    {\n        global $preferences;\n\n        $this->success = false;\n\n        $type_name = 'late';\n        if ($this->type === self::IMPENDING) {\n            $type_name = 'impending';\n        }\n\n        if ($this->hasMail()) {\n            $texts->setMember($this->dest)\n                ->setNoContribution();\n\n            $texts->getTexts(\n                $type_name . 'duedate',\n                $this->dest->language\n            );\n\n            $mail = new GaletteMail($preferences);\n            $mail->setSubject($texts->getSubject());\n            $mail->setRecipients(\n                array(\n                    $this->dest->getEmail() => $this->dest->sname\n                )\n            );\n            $mail->setMessage($texts->getBody());\n            $sent = $mail->send();\n\n            $details = str_replace(\n                array(\n                    '%name',\n                    '%mail',\n                    '%days'\n                ),\n                array(\n                    $this->dest->sname,\n                    $this->dest->getEmail(),\n                    $this->dest->days_remaining\n                ),\n                _T(\"%name <%mail> (%days days)\")\n            );\n\n            if ($sent == GaletteMail::MAIL_SENT) {\n                $this->success = true;\n                $msg = '';\n                if ($type_name == 'late') {\n                    $msg = _T(\"Sent reminder email for late membership\");\n                } else {\n                    $msg = _T(\"Sent reminder email for impending membership\");\n                }\n                $this->msg = $details;\n                $hist->add($msg, $details);\n            } else {\n                if ($type_name == 'late') {\n                    $msg = _T(\"A problem happened while sending late membership email\");\n                } else {\n                    $msg = _T(\"A problem happened while sending impending membership email\");\n                }\n                $this->msg = $details;\n                $hist->add($msg, $details);\n            }\n        } else {\n            $this->nomail = true;\n            $str = str_replace(\n                '%membership',\n                $type_name,\n                _T(\"Unable to send %membership reminder (no email address).\")\n            );\n            $details = str_replace(\n                array(\n                    '%name',\n                    '%id',\n                    '%days'\n                ),\n                array(\n                    $this->dest->sname,\n                    $this->dest->id,\n                    $this->dest->days_remaining\n                ),\n                _T(\"%name (#%id - %days days)\")\n            );\n            $hist->add($str, $details);\n            $this->msg = $this->dest->sname;\n        }\n        //store reminder in database\n        $this->store($zdb);\n        return $this->success;\n    }\n\n    /**\n     * Retrieve message\n     *\n     * @return string\n     */\n    public function getMessage()\n    {\n        return $this->msg;\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ($name) {\n            case 'member_id':\n                return $this->dest->id;\n            case 'type':\n            case 'date':\n                return $this->$name;\n            default:\n                Analog::log(\n                    'Unable to get Reminder property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'type':\n                if (\n                    $value === self::IMPENDING\n                    || $value === self::LATE\n                ) {\n                    $this->type = $value;\n                } else {\n                    throw new \\UnexpectedValueException(\n                        'Unknown type!'\n                    );\n                }\n                break;\n            case 'dest':\n                if ($this->type !== null && $value instanceof Adherent) {\n                    $this->dest = $value;\n\n                    if ($value->getEmail() != '') {\n                        $this->nomail = false;\n                    }\n                } else {\n                    if (!$value instanceof Adherent) {\n                        throw new \\UnexpectedValueException(\n                            'Please provide a member object.'\n                        );\n                    } else {\n                        throw new \\UnderflowException(\n                            'Please set reminder type first.'\n                        );\n                    }\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Saved search\n *\n * PHP version 5\n *\n * Copyright \u00a9 2019-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2019-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.3dev - 2019-03-25\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Galette\\Core;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\Login;\nuse Analog\\Analog;\n\n/**\n * Saved search\n *\n * @category  Entity\n * @name      SavedSearch\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2019-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.3dev - 2019-03-25\n */\n\nclass SavedSearch\n{\n    public const TABLE = 'searches';\n    public const PK = 'search_id';\n\n    private $zdb;\n    private $id;\n    private $name;\n    private $parameters = [];\n    private $author_id;\n    private $creation_date;\n    private $form;\n\n    private $login;\n    private $errors = [];\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb   Database instance\n     * @param Login $login Login instance\n     * @param mixed $args  Arguments\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n        $this->creation_date = date('Y-m-d H:i:s');\n\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a saved search from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where([self::PK => $id]);\n            if ($this->login->isSuperAdmin()) {\n                $select->where(Adherent::PK . ' IS NULL');\n            } else {\n                $select->where([Adherent::PK => $this->login->id]);\n            }\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n\n            $this->loadFromRs($res);\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading saved search #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load a saved search from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->name = $rs->name;\n        $this->parameters = json_decode($rs->parameters, true);\n        $this->author_id = $rs->id_adh;\n        $this->creation_date = $rs->creation_date;\n        $this->form = $rs->form;\n    }\n\n    /**\n     * Check and set values\n     *\n     * @param array $values Values to set\n     *\n     * @return boolean\n     */\n    public function check($values)\n    {\n        $this->errors = [];\n        $mandatory = [\n            'form'  => _T('Form is mandatory!')\n        ];\n\n        foreach ($values as $key => $value) {\n            if (in_array($key, ['nbshow', 'page'])) {\n                continue;\n            }\n            if (empty($value) && isset($mandatory[$key])) {\n                $this->errors[] = $mandatory[$key];\n            }\n            $this->$key = $value;\n            unset($mandatory[$key]);\n        }\n\n        if (count($mandatory)) {\n            $this->errors = array_merge($this->errors, $mandatory);\n        }\n\n        if ($this->id === null && !$this->login->isSuperAdmin()) {\n            //set author for new searches\n            $this->author_id = $this->login->id;\n        }\n\n        return (count($this->errors) === 0);\n    }\n\n    /**\n     * Store saved search in database\n     *\n     * @return boolean|null\n     */\n    public function store()\n    {\n        $parameters = json_encode($this->parameters);\n        $data = array(\n            'name'              => $this->name,\n            'parameters'        => $parameters,\n            'id_adh'            => $this->author_id,\n            'creation_date'     => ($this->creation_date !== null ? $this->creation_date : date('Y-m-d H:i:s')),\n            'form'              => $this->form\n        );\n\n        try {\n            $insert = $this->zdb->insert(self::TABLE);\n            $insert->values($data);\n            $add = $this->zdb->execute($insert);\n            if (!$add->count() > 0) {\n                Analog::log('Not stored!', Analog::ERROR);\n                return false;\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing saved search: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current saved search\n     *\n     * @return boolean\n     */\n    public function remove()\n    {\n        $id = (int)$this->id;\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $id]);\n            $this->zdb->execute($delete);\n            Analog::log(\n                'Saved search #' . $id . ' (' . $this->name\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (\\RuntimeException $re) {\n            throw $re;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete saved search ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        $forbidden = [];\n        $virtuals = ['sparameters'];\n        if (\n            in_array($name, $virtuals)\n            || !in_array($name, $forbidden)\n            && isset($this->$name)\n        ) {\n            switch ($name) {\n                case 'creation_date':\n                    if ($this->$name != '') {\n                        try {\n                            $d = new \\DateTime($this->$name);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$name . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$name;\n                        }\n                    }\n                    break;\n                case 'sparameters':\n                    include_once GALETTE_ROOT . 'includes/fields_defs/members_fields.php';\n                    $parameters = [];\n                    foreach ((array)$this->parameters as $key => $parameter) {\n                        if (isset($members_fields[$key])) {\n                            $key = $members_fields[$key]['label'];\n                        }\n                        if (is_array($parameter) || is_object($parameter)) {\n                            $parameter = json_encode($parameter);\n                        }\n                        $parameters[$key] = $parameter;\n                    }\n                    return $parameters;\n                    break;\n                default:\n                    if (!property_exists($this, $name)) {\n                        Analog::log(\n                            \"Unknown property '$name'\",\n                            Analog::WARNING\n                        );\n                        return null;\n                    } else {\n                        return $this->$name;\n                    }\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'form':\n                if (!in_array($value, $this->getKnownForms())) {\n                    $this->errors[] = str_replace('%form', $value, _T(\"Unknown form %form!\"));\n                }\n                $this->form = $value;\n                break;\n            case 'parameters':\n                if (!is_array($value)) {\n                    Analog::log(\n                        'Search parameters must be an array!',\n                        Analog::ERROR\n                    );\n                }\n                $this->parameters = $value;\n                break;\n            case 'name':\n                if (trim($value) === '') {\n                    $this->errors[] = _T(\"Name cannot be empty!\");\n                }\n                $this->name = $value;\n                break;\n            case 'author_id':\n                $this->author_id = (int)$value;\n                break;\n            default:\n                Analog::log(\n                    str_replace(\n                        ['%class', '%property'],\n                        [self::class, $name],\n                        'Unable to set %class property %property'\n                    ),\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Get known forms\n     *\n     * @return array\n     */\n    public function getKnownForms()\n    {\n        return [\n            'Adherent'\n        ];\n    }\n\n    /**\n     * Get errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Social networks/Contacts\n *\n * PHP version 5\n *\n * Copyright \u00a9 2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.6dev - 2021-10-23\n */\n\nnamespace Galette\\Entity;\n\nuse Galette\\Core\\GaletteMail;\nuse Galette\\Features\\I18n;\nuse Laminas\\Db\\ResultSet\\ResultSet;\nuse Laminas\\Db\\Sql\\Expression;\nuse Throwable;\nuse Galette\\Core\\Db;\nuse Analog\\Analog;\n\n/**\n * Social networks/Contacts\n *\n * @category  Entity\n * @name      Social\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.9.6dev - 2021-10-23\n */\n\nclass Social\n{\n    use I18n;\n\n    public const TABLE = 'socials';\n    public const PK = 'id_social';\n\n    public const MASTODON = 'mastodon';\n    public const TWITTER = 'twitter';\n    public const FACEBOOK = 'facebook';\n    public const LINKEDIN = 'linkedin';\n    public const VIADEO = 'viadeo';\n    public const JABBER = 'jabber';\n    public const ICQ = 'icq';\n    public const WEBSITE = 'website';\n    public const BLOG = 'blog';\n\n    /** @var Db */\n    private $zdb;\n    /** @var int */\n    private $id;\n    /** @var string */\n    private $type;\n    /** @var string */\n    private $url;\n    /** @var int */\n    private $id_adh;\n    /** @var Adherent */\n    private $member;\n\n    /**\n     * Main constructor\n     *\n     * @param Db    $zdb  Database instance\n     * @param mixed $args Arguments\n     */\n    public function __construct(Db $zdb, $args = null)\n    {\n        $this->zdb = $zdb;\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif (is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a social from its identifier\n     *\n     * @param integer $id Identifier\n     *\n     * @return void\n     */\n    private function load(int $id): void\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE);\n            $select->limit(1)->where([self::PK => $id]);\n\n            $results = $this->zdb->execute($select);\n            $res = $results->current();\n            $this->loadFromRs($res);\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading social #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n        }\n    }\n\n    /**\n     * Get socials for a member\n     *\n     * @param int|null    $id_adh Member id\n     * @param string|null $type   Type to retrieve\n     *\n     * @return array\n     *\n     * @throws Throwable\n     */\n    public static function getListForMember(int $id_adh = null, string $type = null): array\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(self::TABLE);\n\n            if ($id_adh === null) {\n                $select->where(Adherent::PK . ' IS NULL');\n            } else {\n                $select->where([Adherent::PK => $id_adh]);\n            }\n\n            if ($type !== null) {\n                $select->where(['type' => $type]);\n            }\n\n            $select->order(self::PK);\n\n            $results = $zdb->execute($select);\n            $socials = [];\n            foreach ($results as $r) {\n                $socials[$r->{self::PK}] = new Social($zdb, $r);\n            }\n            return $socials;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading socials for member #' . $id_adh . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load social from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $this->id = $rs->{self::PK};\n        $this->setLinkedMember((int)$rs->{Adherent::PK});\n        $this->type = $rs->type;\n        $this->url = $rs->url;\n    }\n\n    /**\n     * Store social in database\n     *\n     * @return boolean\n     */\n    public function store(): bool\n    {\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                $update = $this->zdb->update(self::TABLE);\n                $update->set(['url' => $this->url])->where(\n                    [self::PK => $this->id]\n                );\n                $this->zdb->execute($update);\n            } else {\n                $insert = $this->zdb->insert(self::TABLE);\n                $id_adh = $this->{Adherent::PK} > 0 ? $this->{Adherent::PK} : new Expression('NULL');\n                $insert->values([\n                    'type'          => $this->type,\n                    'url'           => $this->url,\n                    Adherent::PK    => $id_adh\n                ]);\n                $add = $this->zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $this->zdb->getLastGeneratedValue($this);\n                if (!in_array($this->type, $this->getSystemTypes(false))) {\n                    $this->addTranslation($this->type);\n                }\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing social: ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current social\n     *\n     * @param array|null $ids IDs to remove, default to current id\n     *\n     * @return boolean\n     */\n    public function remove(array $ids = null): bool\n    {\n        if ($ids == null) {\n            $ids[] = $this->id;\n        }\n\n        try {\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $ids]);\n            $this->zdb->execute($delete);\n            Analog::log(\n                'Social #' . implode(', #', $ids)  . ' deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete social #' . implode(', #', $ids) . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get(string $name)\n    {\n        return $this->$name;\n    }\n\n    /**\n     * Display URL the best way\n     *\n     * @return string\n     */\n    public function displayUrl(): string\n    {\n        if (isValidWebUrl($this->url)) {\n            return sprintf('<a href=\"%1$s\">%1$s</a>', $this->url);\n        }\n\n        if (GaletteMail::isValidEmail($this->url)) {\n            return sprintf('<a href=\"mailto:%1$s\">%1$s</a>', $this->url);\n        }\n\n        return $this->url;\n    }\n\n    /**\n     * Set type\n     *\n     * @param string $type Type\n     *\n     * @return $this\n     */\n    public function setType(string $type): self\n    {\n        $this->type = $type;\n        return $this;\n    }\n\n    /**\n     * Set linked member\n     *\n     * @param int|null $id Member id\n     *\n     * @return $this\n     */\n    public function setLinkedMember(int $id = null): self\n    {\n        $this->{Adherent::PK} = $id;\n        if ($this->{Adherent::PK} > 0) {\n            $this->member = new Adherent($this->zdb, $this->{Adherent::PK});\n        }\n        return $this;\n    }\n\n    /**\n     * Set URL\n     *\n     * @param string $url Value to set\n     *\n     * @return $this\n     */\n    public function setUrl(string $url): self\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    /**\n     * Get system social types\n     *\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return array\n     */\n    public function getSystemTypes(bool $translated = true): array\n    {\n        if ($translated) {\n            $systypes = [\n                self::MASTODON => _T('Mastodon'),\n                self::TWITTER => _T('Twitter'),\n                self::FACEBOOK => _T('Facebook'),\n                self::LINKEDIN => _T('LinkedIn'),\n                self::VIADEO => _T('Viadeo'),\n                self::JABBER => _T('Jabber'),\n                self::ICQ => _T('ICQ'),\n                self::WEBSITE => _T('Website'),\n                self::BLOG => _T('Blog')\n            ];\n        } else {\n            $systypes = [\n                self::MASTODON => 'mastodon',\n                self::TWITTER => 'twitter',\n                self::FACEBOOK => 'facebook',\n                self::LINKEDIN => 'linkedin',\n                self::VIADEO => 'viadeo',\n                self::JABBER => 'jabber',\n                self::ICQ => 'icq',\n                self::WEBSITE => 'website',\n                self::BLOG => 'blog'\n            ];\n        }\n        return $systypes;\n    }\n\n    /**\n     * Get system social types\n     *\n     * @param string  $type       Social type\n     * @param boolean $translated Return translated types (default) or not\n     *\n     * @return string\n     */\n    public function getSystemType(string $type, bool $translated = true): string\n    {\n        return $this->getSystemTypes($translated)[$type] ?? _T($type);\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Title\n *\n * PHP version 5\n *\n * Copyright \u00a9 2013-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2013-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7.4dev - 2013-01-27\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\n\n/**\n * Title\n *\n * @category  Entity\n * @name      Title\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-03-04\n */\n\nclass Title\n{\n    public const TABLE = 'titles';\n    public const PK = 'id_title';\n\n    private $id;\n    private $short;\n    private $long;\n\n    public const MR = 1;\n    public const MRS = 2;\n    public const MISS = 3;\n\n    /**\n     * Main constructor\n     *\n     * @param mixed $args Arguments\n     */\n    public function __construct($args = null)\n    {\n        if (is_int($args)) {\n            $this->load($args);\n        } elseif ($args !== null && is_object($args)) {\n            $this->loadFromRs($args);\n        }\n    }\n\n    /**\n     * Load a title from its identifier\n     *\n     * @param int $id Identifier\n     *\n     * @return void\n     */\n    private function load($id)\n    {\n        global $zdb;\n        try {\n            $select = $zdb->select(self::TABLE);\n            $select->limit(1)->where([self::PK => $id]);\n\n            $results = $zdb->execute($select);\n            $res = $results->current();\n\n            $this->id = $id;\n            $this->short = $res->short_label;\n            $this->long = $res->long_label;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred loading title #' . $id . \"Message:\\n\" .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Load title from a db ResultSet\n     *\n     * @param ResultSet $rs ResultSet\n     *\n     * @return void\n     */\n    private function loadFromRs($rs)\n    {\n        $pk = self::PK;\n        $this->id = $rs->$pk;\n        $this->short = $rs->short_label;\n        if ($rs->long_label === 'NULL') {\n            //mysql's null...\n            $this->long = null;\n        } else {\n            $this->long = $rs->long_label;\n        }\n    }\n\n    /**\n     * Store title in database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function store($zdb)\n    {\n        $data = array(\n            'short_label'   => $this->short,\n            'long_label'    => $this->long\n        );\n        try {\n            if ($this->id !== null && $this->id > 0) {\n                $update = $zdb->update(self::TABLE);\n                $update->set($data)->where([self::PK => $this->id]);\n                $zdb->execute($update);\n            } else {\n                $insert = $zdb->insert(self::TABLE);\n                $insert->values($data);\n                $add = $zdb->execute($insert);\n                if (!$add->count() > 0) {\n                    Analog::log('Not stored!', Analog::ERROR);\n                    return false;\n                }\n\n                $this->id = $zdb->getLastGeneratedValue($this);\n            }\n            return true;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred storing title: ' . $e->getMessage() .\n                \"\\n\" . print_r($data, true),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove current title\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return boolean\n     */\n    public function remove($zdb)\n    {\n        $id = (int)$this->id;\n        if ($id === self::MR || $id === self::MRS) {\n            throw new \\RuntimeException(_T(\"You cannot delete Mr. or Mrs. titles!\"));\n        }\n\n        try {\n            $delete = $zdb->delete(self::TABLE);\n            $delete->where([self::PK => $id]);\n            $zdb->execute($delete);\n            Analog::log(\n                'Title #' . $id . ' (' . $this->short\n                . ') deleted successfully.',\n                Analog::INFO\n            );\n            return true;\n        } catch (\\RuntimeException $re) {\n            throw $re;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to delete title ' . $id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Getter\n     *\n     * @param string $name Property name\n     *\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        global $lang;\n\n        switch ($name) {\n            case 'id':\n                return $this->$name;\n                break;\n            case 'short':\n            case 'long':\n                if (\n                    $name === 'long'\n                    && ($this->long == null || trim($this->long) === '')\n                ) {\n                    $name = 'short';\n                }\n                return $this->$name;\n                break;\n            case 'tshort':\n            case 'tlong':\n                $rname = null;\n                if ($name === 'tshort') {\n                    $rname = 'short';\n                } else {\n                    if ($this->long !== null && trim($this->long) !== '') {\n                        $rname = 'long';\n                    } else {\n                        //switch back to short version if long does not exists\n                        $rname = 'short';\n                    }\n                }\n                if (isset($lang) && isset($lang[$this->$rname])) {\n                    return _T($this->$rname);\n                } else {\n                    return $this->$rname;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to get Title property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n\n    /**\n     * Setter\n     *\n     * @param string $name  Property name\n     * @param mixed  $value Property value\n     *\n     * @return void\n     */\n    public function __set($name, $value)\n    {\n        switch ($name) {\n            case 'short':\n            case 'long':\n                if (trim($value) === '') {\n                    Analog::log(\n                        'Trying to set empty value for title' . $name,\n                        Analog::WARNING\n                    );\n                } else {\n                    $this->$name = $value;\n                }\n                break;\n            default:\n                Analog::log(\n                    'Unable to set property ' . $name,\n                    Analog::WARNING\n                );\n                break;\n        }\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Transaction class for galette\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Entity\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-07-31\n */\n\nnamespace Galette\\Entity;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Galette\\Repository\\Contributions;\nuse Galette\\Core\\Db;\nuse Galette\\Core\\History;\nuse Galette\\Core\\Login;\nuse Galette\\Features\\Dynamics;\n\n/**\n * Transaction class for galette\n *\n * @category  Entity\n * @name      Transaction\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2010-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2010-03-11\n *\n * @property integer $id\n * @property date $date\n * @property integer $amount\n * @property string $description\n * @property integer $member\n */\nclass Transaction\n{\n    use Dynamics;\n\n    public const TABLE = 'transactions';\n    public const PK = 'trans_id';\n\n    private $_id;\n    private $_date;\n    private $_amount;\n    private $_description;\n    private $_member;\n\n    //fields list and their translation\n    private $_fields;\n\n    private $zdb;\n    private $login;\n\n    private $errors;\n\n    /**\n     * Default constructor\n     *\n     * @param Db                 $zdb   Database instance\n     * @param Login              $login Login instance\n     * @param null|int|ResultSet $args  Either a ResultSet row or its id for to load\n     *                                  a specific transaction, or null to just\n     *                                  instantiate object\n     */\n    public function __construct(Db $zdb, Login $login, $args = null)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n\n        /*\n         * Fields configuration. Each field is an array and must reflect:\n         * array(\n         *   (string)label,\n         *   (string) propname\n         * )\n         *\n         * I'd prefer a static private variable for this...\n         * But call to the _T function does not seem to be allowed there :/\n         */\n        $this->_fields = array(\n            self::PK            => array(\n                'label'    => null, //not a field in the form\n                'propname' => 'id'\n            ),\n            'trans_date'          => array(\n                'label'    => _T(\"Date:\"), //not a field in the form\n                'propname' => 'date'\n            ),\n            'trans_amount'       => array(\n                'label'    => _T(\"Amount:\"),\n                'propname' => 'amount'\n            ),\n            'trans_desc'          => array(\n                'label'    => _T(\"Description:\"),\n                'propname' => 'description'\n            ),\n            Adherent::PK          => array(\n                'label'    => _T(\"Originator:\"),\n                'propname' => 'member'\n            )\n        );\n        if ($args == null || is_int($args)) {\n            $this->_date = date(\"Y-m-d\");\n\n            if (is_int($args) && $args > 0) {\n                $this->load($args);\n            }\n        } elseif (is_object($args)) {\n            $this->loadFromRS($args);\n        }\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Loads a transaction from its id\n     *\n     * @param int $id the identifier for the transaction to load\n     *\n     * @return bool true if query succeed, false otherwise\n     */\n    public function load($id)\n    {\n        try {\n            $select = $this->zdb->select(self::TABLE, 't');\n            $select->where([self::PK => $id]);\n            $select->join(\n                array('a' => PREFIX_DB . Adherent::TABLE),\n                't.' . Adherent::PK . '=a.' . Adherent::PK,\n                array()\n            );\n\n            //restrict query on current member id if he's not admin nor staff member\n            if (!$this->login->isAdmin() && !$this->login->isStaff() && !$this->login->isGroupManager()) {\n                if (!$this->login->isLogged()) {\n                    Analog::log(\n                        'Non-logged-in users cannot load transaction id `' . $id,\n                        Analog::ERROR\n                    );\n                    return false;\n                }\n                $select->where\n                    ->nest()\n                        ->equalTo('a.' . Adherent::PK, $this->login->id)\n                        ->or\n                        ->equalTo('a.parent_id', $this->login->id)\n                    ->unnest()\n                    ->and\n                    ->equalTo('t.' . self::PK, $id)\n                ;\n            } else {\n                $select->where->equalTo(self::PK, $id);\n            }\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            if ($result) {\n                $this->loadFromRS($result);\n                return true;\n            } else {\n                Analog::log(\n                    'Transaction id `' . $id . '` does not exists',\n                    Analog::WARNING\n                );\n                return false;\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load transaction form id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove transaction (and all associated contributions) from database\n     *\n     * @param History $hist        History\n     * @param boolean $transaction Activate transaction mode (defaults to true)\n     *\n     * @return boolean\n     */\n    public function remove(History $hist, $transaction = true)\n    {\n        global $emitter;\n\n        try {\n            if ($transaction) {\n                $this->zdb->connection->beginTransaction();\n            }\n\n            //remove associated contributions if needeed\n            if ($this->getDispatchedAmount() > 0) {\n                $c = new Contributions($this->zdb, $this->login);\n                $clist = $c->getListFromTransaction($this->_id);\n                $cids = array();\n                foreach ($clist as $cid) {\n                    $cids[] = $cid->id;\n                }\n                $rem = $c->remove($cids, $hist, false);\n            }\n\n            //remove transaction itself\n            $delete = $this->zdb->delete(self::TABLE);\n            $delete->where([self::PK => $this->_id]);\n            $del = $this->zdb->execute($delete);\n            if ($del->count() > 0) {\n                $this->dynamicsRemove(true);\n            } else {\n                Analog::log(\n                    'Transaction has not been removed!',\n                    Analog::WARNING\n                );\n                return false;\n            }\n\n            if ($transaction) {\n                $this->zdb->connection->commit();\n            }\n\n            $emitter->emit('transaction.remove', $this);\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction) {\n                $this->zdb->connection->rollBack();\n            }\n            Analog::log(\n                'An error occurred trying to remove transaction #' .\n                $this->_id . ' | ' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Populate object from a resultset row\n     *\n     * @param ResultSet $r the resultset row\n     *\n     * @return void\n     */\n    private function loadFromRS($r)\n    {\n        $pk = self::PK;\n        $this->_id = $r->$pk;\n        $this->_date = $r->trans_date;\n        $this->_amount = $r->trans_amount;\n        $this->_description = $r->trans_desc;\n        $adhpk = Adherent::PK;\n        $this->_member = (int)$r->$adhpk;\n\n        $this->loadDynamicFields();\n    }\n\n    /**\n     * Check posted values validity\n     *\n     * @param array $values   All values to check, basically the $_POST array\n     *                        after sending the form\n     * @param array $required Array of required fields\n     * @param array $disabled Array of disabled fields\n     *\n     * @return true|array\n     */\n    public function check($values, $required, $disabled)\n    {\n        $this->errors = array();\n\n        $fields = array_keys($this->_fields);\n        foreach ($fields as $key) {\n            //first, let's sanitize values\n            $key = strtolower($key);\n            $prop = '_' . $this->_fields[$key]['propname'];\n\n            if (isset($values[$key])) {\n                $value = trim($values[$key]);\n            } else {\n                $value = '';\n            }\n\n            // if the field is enabled, check it\n            if (!isset($disabled[$key])) {\n                // now, check validity\n                if ($value != '') {\n                    switch ($key) {\n                        // dates\n                        case 'trans_date':\n                            try {\n                                $d = \\DateTime::createFromFormat(__(\"Y-m-d\"), $value);\n                                if ($d === false) {\n                                    throw new \\Exception('Incorrect format');\n                                }\n                                $this->$prop = $d->format('Y-m-d');\n                            } catch (Throwable $e) {\n                                Analog::log(\n                                    'Wrong date format. field: ' . $key .\n                                    ', value: ' . $value . ', expected fmt: ' .\n                                    __(\"Y-m-d\") . ' | ' . $e->getMessage(),\n                                    Analog::INFO\n                                );\n                                $this->errors[] = str_replace(\n                                    array(\n                                        '%date_format',\n                                        '%field'\n                                    ),\n                                    array(\n                                        __(\"Y-m-d\"),\n                                        $this->getFieldLabel($key)\n                                    ),\n                                    _T(\"- Wrong date format (%date_format) for %field!\")\n                                );\n                            }\n                            break;\n                        case Adherent::PK:\n                            $this->_member = (int)$value;\n                            break;\n                        case 'trans_amount':\n                            $this->_amount = $value;\n                            $value = strtr($value, ',', '.');\n                            if (!is_numeric($value)) {\n                                $this->errors[] = _T(\"- The amount must be an integer!\");\n                            }\n                            break;\n                        case 'trans_desc':\n                            /** TODO: retrieve field length from database and check that */\n                            $this->_description = $value;\n                            if (mb_strlen($value) > 150) {\n                                $this->errors[] = _T(\"- Transaction description must be 150 characters long maximum.\");\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n\n        // missing required fields?\n        foreach ($required as $key => $val) {\n            if ($val === 1) {\n                $prop = '_' . $this->_fields[$key]['propname'];\n                if (!isset($disabled[$key]) && !isset($this->$prop)) {\n                    $this->errors[] = str_replace(\n                        '%field',\n                        '<a href=\"#' . $key . '\">' . $this->getFieldLabel($key) . '</a>',\n                        _T(\"- Mandatory field %field empty.\")\n                    );\n                }\n            }\n        }\n\n        if ($this->_id != '') {\n            $dispatched = $this->getDispatchedAmount();\n            if ($dispatched > $this->_amount) {\n                $this->errors[] = _T(\"- Sum of all contributions exceed corresponding transaction amount.\");\n            }\n        }\n\n        $this->dynamicsCheck($values, $required, $disabled);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a transaction' .\n                print_r($this->errors, true),\n                Analog::DEBUG\n            );\n            return $this->errors;\n        } else {\n            Analog::log(\n                'Transaction checked successfully.',\n                Analog::DEBUG\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Store the transaction\n     *\n     * @param History $hist History\n     *\n     * @return boolean\n     */\n    public function store(History $hist)\n    {\n        global $emitter;\n\n        $event = null;\n\n        try {\n            $this->zdb->connection->beginTransaction();\n            $values = array();\n            $fields = $this->getDbFields($this->zdb);\n            /** FIXME: quote? */\n            foreach ($fields as $field) {\n                $prop = '_' . $this->_fields[$field]['propname'];\n                $values[$field] = $this->$prop;\n            }\n\n            $success = false;\n            if (!isset($this->_id) || $this->_id == '') {\n                //we're inserting a new transaction\n                unset($values[self::PK]);\n                $insert = $this->zdb->insert(self::TABLE);\n                $insert->values($values);\n                $add = $this->zdb->execute($insert);\n                if ($add->count() > 0) {\n                    $this->_id = $this->zdb->getLastGeneratedValue($this);\n\n                    // logging\n                    $hist->add(\n                        _T(\"Transaction added\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                    $success = true;\n                    $event = 'transaction.add';\n                } else {\n                    $hist->add(_T(\"Fail to add new transaction.\"));\n                    throw new \\RuntimeException(\n                        'An error occurred inserting new transaction!'\n                    );\n                }\n            } else {\n                //we're editing an existing transaction\n                $update = $this->zdb->update(self::TABLE);\n                $update->set($values)->where([self::PK => $this->_id]);\n                $edit = $this->zdb->execute($update);\n                //edit == 0 does not mean there were an error, but that there\n                //were nothing to change\n                if ($edit->count() > 0) {\n                    $hist->add(\n                        _T(\"Transaction updated\"),\n                        Adherent::getSName($this->zdb, $this->_member)\n                    );\n                }\n                $success = true;\n                $event = 'transaction.edit';\n            }\n\n            //dynamic fields\n            if ($success) {\n                $success = $this->dynamicsStore(true);\n            }\n\n            $this->zdb->connection->commit();\n\n            //send event at the end of process, once all has been stored\n            if ($event !== null) {\n                $emitter->emit($event, $this);\n            }\n\n            return true;\n        } catch (Throwable $e) {\n            $this->zdb->connection->rollBack();\n            Analog::log(\n                'Something went wrong :\\'( | ' . $e->getMessage() . \"\\n\" .\n                $e->getTraceAsString(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve amount that has already been dispatched into contributions\n     *\n     * @return double\n     */\n    public function getDispatchedAmount(): float\n    {\n        if (empty($this->_id)) {\n            return (double)0;\n        }\n\n        try {\n            $select = $this->zdb->select(Contribution::TABLE);\n            $select->columns(\n                array(\n                    'sum' => new Expression('SUM(montant_cotis)')\n                )\n            )->where([self::PK => $this->_id]);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dispatched_amount = $result->sum;\n            return (double)$dispatched_amount;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred retrieving dispatched amounts | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve amount that has not yet been dispatched into contributions\n     *\n     * @return double\n     */\n    public function getMissingAmount()\n    {\n        if (empty($this->_id)) {\n            return (double)$this->amount;\n        }\n\n        try {\n            $select = $this->zdb->select(Contribution::TABLE);\n            $select->columns(\n                array(\n                    'sum' => new Expression('SUM(montant_cotis)')\n                )\n            )->where([self::PK => $this->_id]);\n\n            $results = $this->zdb->execute($select);\n            $result = $results->current();\n            $dispatched_amount = $result->sum;\n            return (double)$this->_amount - (double)$dispatched_amount;\n        } catch (Throwable $e) {\n            Analog::log(\n                'An error occurred retrieving missing amounts | ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Retrieve fields from database\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array\n     */\n    public function getDbFields(Db $zdb)\n    {\n        $columns = $zdb->getColumns(self::TABLE);\n        $fields = array();\n        foreach ($columns as $col) {\n            $fields[] = $col->getName();\n        }\n        return $fields;\n    }\n\n    /**\n     * Get the relevant CSS class for current transaction\n     *\n     * @return string current transaction row class\n     */\n    public function getRowClass()\n    {\n        return ($this->getMissingAmount() == 0) ?\n            'transaction-normal' : 'transaction-uncomplete';\n    }\n\n    /**\n     * Global getter method\n     *\n     * @param string $name name of the property we want to retrive\n     *\n     * @return false|object the called property\n     */\n    public function __get($name)\n    {\n        $forbidden = array();\n\n        $rname = '_' . $name;\n        if (!in_array($name, $forbidden) && property_exists($this, $rname)) {\n            switch ($name) {\n                case 'date':\n                    if ($this->$rname != '') {\n                        try {\n                            $d = new \\DateTime($this->$rname);\n                            return $d->format(__(\"Y-m-d\"));\n                        } catch (Throwable $e) {\n                            //oops, we've got a bad date :/\n                            Analog::log(\n                                'Bad date (' . $this->$rname . ') | ' .\n                                $e->getMessage(),\n                                Analog::INFO\n                            );\n                            return $this->$rname;\n                        }\n                    }\n                    break;\n                case 'id':\n                    if ($this->$rname !== null) {\n                        return (int)$this->$rname;\n                    }\n                    return null;\n                case 'amount':\n                    if ($this->$rname !== null) {\n                        return (double)$this->$rname;\n                    }\n                    return null;\n                default:\n                    return $this->$rname;\n            }\n        } else {\n            Analog::log(\n                sprintf(\n                    'Property %1$s does not exists for transaction',\n                    $name\n                ),\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Get field label\n     *\n     * @param string $field Field name\n     *\n     * @return string\n     */\n    public function getFieldLabel($field)\n    {\n        $label = $this->_fields[$field]['label'];\n        //replace \"&nbsp;\"\n        $label = str_replace('&nbsp;', ' ', $label);\n        //remove trailing ':' and then trim\n        $label = trim(trim($label, ':'));\n        return $label;\n    }\n\n    /**\n     * Handle files (dynamics files)\n     *\n     * @param array $files Files sent\n     *\n     * @return array|true\n     */\n    public function handleFiles($files)\n    {\n        $this->errors = [];\n\n        $this->dynamicsFiles($files);\n\n        if (count($this->errors) > 0) {\n            Analog::log(\n                'Some errors has been thew attempting to edit/store a transaction files' . \"\\n\" .\n                print_r($this->errors, true),\n                Analog::ERROR\n            );\n            return $this->errors;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Can current logged-in user display transaction\n     *\n     * @param Login $login Login instance\n     *\n     * @return boolean\n     */\n    public function canShow(Login $login): bool\n    {\n        //non-logged-in members cannot show contributions\n        if (!$login->isLogged()) {\n            return false;\n        }\n\n        //admin and staff users can edit, as well as member itself\n        if (!$this->id || $this->id && $login->id == $this->_member || $login->isAdmin() || $login->isStaff()) {\n            return true;\n        }\n\n        //parent can see their children transactions\n        $parent = new Adherent($this->zdb);\n        $parent\n            ->disableAllDeps()\n            ->enableDep('children')\n            ->load($this->login->id);\n        if ($parent->hasChildren()) {\n            foreach ($parent->children as $child) {\n                if ($child->id === $this->_member) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return false;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Groups entity\n *\n * PHP version 5\n *\n * Copyright \u00a9 2011-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-10-25\n */\n\nnamespace Galette\\Repository;\n\nuse Throwable;\nuse Analog\\Analog;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Predicate\\PredicateSet;\nuse Galette\\Entity\\Group;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Core\\Login;\nuse Galette\\Core\\Db;\n\n/**\n * Groups entitiy\n *\n * @category  Repository\n * @name      Groups\n * @package   Galette\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2011-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2011-10-25\n */\nclass Groups\n{\n\n    /**\n     * Constructor\n     *\n     * @param Db    $zdb   Database instance\n     * @param Login $login Login instance\n     */\n    public function __construct(Db $zdb, Login $login)\n    {\n        $this->zdb = $zdb;\n        $this->login = $login;\n    }\n\n    /**\n     * Get simple groups list (only id and names)\n     *\n     * @param boolean $as_groups Retrieve Group[]\n     *\n     * @return array\n     */\n    public static function getSimpleList($as_groups = false)\n    {\n        global $zdb;\n\n        try {\n            $select = $zdb->select(Group::TABLE);\n            if ($as_groups === false) {\n                $select->columns(\n                    array(Group::PK, 'group_name')\n                );\n            }\n            $groups = array();\n            $gpk = Group::PK;\n\n            $results = $zdb->execute($select);\n\n            foreach ($results as $row) {\n                if ($as_groups === false) {\n                    $groups[$row->$gpk] = $row->group_name;\n                } else {\n                    $groups[$row->$gpk] = new Group($row);\n                }\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups (simple) | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get groups list\n     *\n     * @param boolean $full Return full list or root only\n     * @param int     $id   Group ID to retrieve\n     *\n     * @return Group[]\n     */\n    public function getList($full = true, $id = null)\n    {\n        try {\n            $select = $this->zdb->select(Group::TABLE, 'a');\n            $select->join(\n                array('b' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                'a.' . Group::PK . '=b.' . Group::PK,\n                array('members' => new Expression('count(b.' . Group::PK . ')')),\n                $select::JOIN_LEFT\n            );\n\n            if (!$this->login->isAdmin() && !$this->login->isStaff() && $full === true) {\n                $select->join(\n                    array('c' => PREFIX_DB . Group::GROUPSMANAGERS_TABLE),\n                    'a.' . Group::PK . '=c.' . Group::PK,\n                    array()\n                )->where(['c.' . Adherent::PK => $this->login->id]);\n            }\n\n            if ($full !== true) {\n                $select->where('parent_group IS NULL');\n            }\n\n            if ($id !== null) {\n                $select->where(\n                    array(\n                        'a.' . Group::PK => $id,\n                        'a.parent_group' => $id\n                    ),\n                    PredicateSet::OP_OR\n                );\n            }\n\n            $select->group('a.' . Group::PK)\n                ->group('a.group_name')\n                ->group('a.creation_date')\n                ->group('a.parent_group')\n                ->order('a.group_name ASC');\n\n            $groups = array();\n\n            $results = $this->zdb->execute($select);\n\n            foreach ($results as $row) {\n                $group = new Group($row);\n                $group->setLogin($this->login);\n                $groups[$group->getFullName()] = $group;\n            }\n            if ($full) { // Order by tree name instead of name\n                ksort($groups);\n                Analog::log(\n                    'Groups SORTED: ' . print_r(array_keys($groups), true),\n                    Analog::DEBUG\n                );\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads managed groups for specific member\n     *\n     * @param int     $id       Memebr id\n     * @param boolean $as_group Retrieve Group[] or int[]\n     *\n     * @return array\n     */\n    public static function loadManagedGroups($id, $as_group = true)\n    {\n        return self::loadGroups($id, true, $as_group);\n    }\n\n    /**\n     * Loads groups for specific member\n     *\n     * @param int     $id       Member id\n     * @param boolean $managed  Retrieve managed groups (defaults to false)\n     * @param boolean $as_group Retrieve Group[] or int[]\n     *\n     * @return array\n     */\n    public static function loadGroups($id, $managed = false, $as_group = true)\n    {\n        global $zdb;\n        try {\n            $join_table = ($managed) ?\n                Group::GROUPSMANAGERS_TABLE : Group::GROUPSUSERS_TABLE;\n\n            $select = $zdb->select(Group::TABLE, 'a');\n            $select->join(\n                array(\n                    'b' => PREFIX_DB . $join_table\n                ),\n                'a.' . Group::PK . '=b.' . Group::PK,\n                array()\n            )->where(array('b.' . Adherent::PK => $id));\n\n            $results = $zdb->execute($select);\n\n            $groups = array();\n            foreach ($results as $r) {\n                if ($as_group === true) {\n                    $groups[] = new Group($r);\n                } else {\n                    $gpk = Group::PK;\n                    $groups[] = $r->$gpk;\n                }\n            }\n            return $groups;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load member groups for id `' . $id . '` | ' .\n                $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Add a member to specified groups\n     *\n     * @param Adherent $adh         Member\n     * @param array    $groups      Groups Groups list. Each entry must contain\n     *                              the group id, name each value separated\n     *                              by a pipe.\n     * @param boolean  $manager     Add member as manager, defaults to false\n     * @param boolean  $transaction Does a SQL transaction already exists? Defaults\n     *                              to false.\n     *\n     * @return boolean\n     */\n    public static function addMemberToGroups($adh, $groups, $manager = false, $transaction = false)\n    {\n        global $zdb;\n        try {\n            if ($transaction === false) {\n                $zdb->connection->beginTransaction();\n            }\n\n            $table = null;\n            if ($manager === true) {\n                $table = Group::GROUPSMANAGERS_TABLE;\n            } else {\n                $table = Group::GROUPSUSERS_TABLE;\n            }\n\n            //first, remove current groups members\n            $delete = $zdb->delete($table);\n            $delete->where([Adherent::PK => $adh->id]);\n            $zdb->execute($delete);\n\n            $msg = null;\n            if ($manager === true) {\n                $msg = 'Member `' . $adh->sname . '` has been detached from groups he manages';\n            } else {\n                $msg = 'Member `' . $adh->sname . '` has been detached of its groups';\n            }\n            Analog::log(\n                $msg . ', we can now store new ones.',\n                Analog::INFO\n            );\n\n            //we proceed, if groups has been specified\n            if (is_array($groups)) {\n                $insert = $zdb->insert($table);\n                $insert->values(\n                    array(\n                        Group::PK       => ':group',\n                        Adherent::PK    => ':adh'\n                    )\n                );\n                $stmt = $zdb->sql->prepareStatementForSqlObject($insert);\n\n                foreach ($groups as $group) {\n                    list($gid, $gname) = explode('|', $group);\n\n                    $result = $stmt->execute(\n                        array(\n                            'group' => $gid,\n                            'adh'   => $adh->id\n                        )\n                    );\n\n                    if ($result) {\n                        $msg = 'Member `' . $adh->sname . '` attached to group `' .\n                            $gname . '` (' . $gid . ')';\n                        if ($manager === true) {\n                            $msg .= ' as a manager';\n                        }\n                        Analog::log(\n                            $msg,\n                            Analog::DEBUG\n                        );\n                    } else {\n                        $msg = 'Unable to attach member `' .\n                            $adh->sname . '` (' . $adh->id . ') to group `' .\n                            $gname . '` (' . $gid . ').';\n                        if ($manager === true) {\n                            $msg .= ' as a manager';\n                        }\n                        Analog::log(\n                            $msg,\n                            Analog::ERROR\n                        );\n                        throw new \\Exception($msg);\n                    }\n                }\n            }\n            if ($transaction === false) {\n                //commit all changes\n                $zdb->connection->commit();\n            }\n            return true;\n        } catch (Throwable $e) {\n            if ($transaction === false) {\n                $zdb->connection->rollBack();\n            }\n            $msg = 'Unable to add member `' . $adh->sname . '` (' . $adh->id .\n                ') to specified groups ' . print_r($groups, true);\n            if ($manager === true) {\n                $msg .= ' as a manager';\n            }\n            do {\n                $messages[] = $e->getMessage();\n            } while ($e = $e->getPrevious());\n            Analog::log(\n                $msg . ' |' . implode(\"\\n\", $messages),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove members from all their groups\n     *\n     * @param array $ids Members ids\n     *\n     * @return void\n     */\n    public static function removeMembersFromGroups(array $ids)\n    {\n        global $zdb;\n\n        try {\n            $del_qry = $zdb->delete(Group::GROUPSUSERS_TABLE);\n            $del_qry->where->in(Adherent::PK, $ids);\n            $zdb->execute($del_qry);\n\n            $del_qry = $zdb->delete(Group::GROUPSMANAGERS_TABLE);\n            $del_qry->where->in(Adherent::PK, $ids);\n            $zdb->execute($del_qry);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Unable to remove member #' . $id . ' from his groups: ' .\n                $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove member from all his groups\n     *\n     * @param int $id Member's id\n     *\n     * @return void\n     */\n    public static function removeMemberFromGroups($id)\n    {\n        self::removeMembersFromGroups([$id]);\n    }\n\n    /**\n     * Check if groupname is unique\n     *\n     * @param Db     $zdb  Database instance\n     * @param string $name Requested name\n     *\n     * @return boolean\n     */\n    public static function isUnique(Db $zdb, $name)\n    {\n        try {\n            $select = $zdb->select(Group::TABLE);\n            $select->columns(\n                array('group_name')\n            )->where(array('group_name' => $name));\n            $results = $zdb->execute($select);\n            return !($results->count() > 0);\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list groups (simple) | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get managed users id list\n     *\n     * @param array $groups List of managed groups.\n     *                      If empty, Groups::loadManagedGroups() will be called\n     *\n     * @return array|false\n     */\n    public function getManagerUsers(array $groups = [])\n    {\n        if (!$this->login->isGroupManager()) {\n            return false;\n        }\n        if (!count($groups)) {\n            $groups = self::loadManagedGroups($this->login->id, false);\n        }\n\n        $select = $this->zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            [Adherent::PK]\n        )->join(\n            array('b' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n            'a.' . Adherent::PK . '=b.' . Adherent::PK,\n            []\n        )->where->in('b.' . Group::PK, $groups);\n\n        $results = $this->zdb->execute($select);\n\n        $ids_adh = array();\n        foreach ($results as $r) {\n            $ids_adh[] = $r->id_adh;\n        }\n        return $ids_adh;\n    }\n}\n", "<?php\n\n/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */\n\n/**\n * Members class\n *\n * PHP version 5\n *\n * Copyright \u00a9 2009-2021 The Galette Team\n *\n * This file is part of Galette (http://galette.tuxfamily.org).\n *\n * Galette is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Galette is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Galette. If not, see <http://www.gnu.org/licenses/>.\n *\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n * @since     Available since 0.7dev - 2009-02-28\n */\n\nnamespace Galette\\Repository;\n\nuse Galette\\Entity\\Social;\nuse Throwable;\nuse Galette\\DynamicFields\\DynamicField;\nuse Galette\\Entity\\DynamicFieldsHandle;\nuse Analog\\Analog;\nuse Laminas\\Db\\Adapter\\Adapter;\nuse Laminas\\Db\\Sql\\Expression;\nuse Laminas\\Db\\Sql\\Select;\nuse Laminas\\Db\\Sql\\Predicate\\PredicateSet;\nuse Laminas\\Db\\Sql\\Predicate\\Operator;\nuse Galette\\Entity\\Adherent;\nuse Galette\\Entity\\Contribution;\nuse Galette\\Entity\\Transaction;\nuse Galette\\Entity\\Reminder;\nuse Galette\\Filters\\MembersList;\nuse Galette\\Filters\\AdvancedMembersList;\nuse Galette\\Core\\Picture;\nuse Galette\\Entity\\Group;\nuse Galette\\Repository\\Groups;\nuse Galette\\Entity\\Status;\nuse Galette\\Core\\Db;\n\n/**\n * Members class for galette\n *\n * @name Members\n * @category  Repository\n * @package   Galette\n *\n * @author    Johan Cwiklinski <johan@x-tnd.be>\n * @copyright 2009-2021 The Galette Team\n * @license   http://www.gnu.org/licenses/gpl-3.0.html GPL License 3.0 or (at your option) any later version\n * @link      http://galette.tuxfamily.org\n */\nclass Members\n{\n    public const TABLE = Adherent::TABLE;\n    public const PK = Adherent::PK;\n\n    public const ALL_ACCOUNTS = 0;\n    public const ACTIVE_ACCOUNT = 1;\n    public const INACTIVE_ACCOUNT = 2;\n\n    public const SHOW_LIST = 0;\n    public const SHOW_PUBLIC_LIST = 1;\n    public const SHOW_ARRAY_LIST = 2;\n    public const SHOW_STAFF = 3;\n    public const SHOW_MANAGED = 4;\n    public const SHOW_EXPORT = 5;\n\n    public const FILTER_NAME = 0;\n    public const FILTER_ADDRESS = 1;\n    public const FILTER_MAIL = 2;\n    public const FILTER_JOB = 3;\n    public const FILTER_INFOS = 4;\n    public const FILTER_DC_EMAIL = 5;\n    public const FILTER_W_EMAIL = 6;\n    public const FILTER_WO_EMAIL = 7;\n    public const FILTER_COMPANY_NAME = 8;\n    public const FILTER_DC_PUBINFOS = 9;\n    public const FILTER_W_PUBINFOS = 10;\n    public const FILTER_WO_PUBINFOS = 11;\n    public const FILTER_ID = 12;\n    public const FILTER_NUMBER = 13;\n\n    public const MEMBERSHIP_ALL = 0;\n    public const MEMBERSHIP_UP2DATE = 3;\n    public const MEMBERSHIP_NEARLY = 1;\n    public const MEMBERSHIP_LATE = 2;\n    public const MEMBERSHIP_NEVER = 4;\n    public const MEMBERSHIP_STAFF = 5;\n    public const MEMBERSHIP_ADMIN = 6;\n    public const MEMBERSHIP_NONE = 7;\n\n    public const ORDERBY_NAME = 'name';\n    public const ORDERBY_NICKNAME = 'nickname';\n    public const ORDERBY_STATUS = 'status';\n    public const ORDERBY_FEE_STATUS = 'fee_status';\n    public const ORDERBY_MODIFDATE = 'modif_date';\n    public const ORDERBY_ID = 'id';\n\n    public const NON_STAFF_MEMBERS = 30;\n\n    private $filters = false;\n    private $count = null;\n    private $errors = array();\n\n    /**\n     * Default constructor\n     *\n     * @param MembersList $filters Filtering\n     */\n    public function __construct($filters = null)\n    {\n        if ($filters === null) {\n            $this->filters = new MembersList();\n        } else {\n            $this->filters = $filters;\n        }\n    }\n\n    /**\n     * Get staff members list\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $limit      true to LIMIT query\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getStaffMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $limit = true\n    ) {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            $count,\n            true,\n            false,\n            $limit\n        );\n    }\n\n    /**\n     * Get managed members list (for groups managers)\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $limit      true to LIMIT query\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getManagedMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $limit = true\n    ) {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            $count,\n            false,\n            true,\n            $limit\n        );\n    }\n\n    /**\n     * Get members list\n     *\n     * @param bool    $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     * @param boolean $count      true if we want to count members\n     * @param boolean $staff      true if we want only staff members\n     * @param boolean $managed    true if we want only managed groups\n     * @param boolean $limit      true if we want records pagination\n     * @param boolean $export     true if we are exporting\n     *\n     * @return Adherent[]|Laminas\\Db\\ResultSet\n     */\n    public function getMembersList(\n        $as_members = false,\n        $fields = null,\n        $count = true,\n        $staff = false,\n        $managed = false,\n        $limit = true,\n        $export = false\n    ) {\n        global $zdb;\n\n        if ($limit === true) {\n            //force count if limit is active\n            $count = true;\n        }\n\n        try {\n            $_mode = self::SHOW_LIST;\n            if ($staff !== false) {\n                $_mode = self::SHOW_STAFF;\n            }\n            if ($managed !== false) {\n                $_mode = self::SHOW_MANAGED;\n            }\n            if ($export !== false) {\n                $_mode = self::SHOW_EXPORT;\n            }\n\n            $select = $this->buildSelect(\n                $_mode,\n                $fields,\n                false,\n                $count\n            );\n\n            //add limits to retrieve only relavant rows\n            if ($limit === true) {\n                $this->filters->setLimits($select);\n            }\n\n            $rows = $zdb->execute($select);\n            $this->filters->query = $zdb->query_string;\n\n            $members = array();\n            if ($as_members) {\n                $deps = array(\n                    'picture'   => false,\n                    'groups'    => false\n                );\n                foreach ($rows as $row) {\n                    $members[] = new Adherent($zdb, $row, $deps);\n                }\n            } else {\n                $members = $rows;\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Remove specified members\n     *\n     * @param integer|array $ids Members identifiers to delete\n     *\n     * @return boolean\n     */\n    public function removeMembers($ids)\n    {\n        global $zdb, $hist, $emitter;\n\n        $processed = array();\n        $list = array();\n        if (is_array($ids)) {\n            $list = $ids;\n        } elseif (is_numeric($ids)) {\n            $list = [(int)$ids];\n        } else {\n            return false;\n        }\n\n        try {\n            $zdb->connection->beginTransaction();\n\n            //Retrieve some information\n            $select = $zdb->select(self::TABLE);\n            $select->columns(\n                array(self::PK, 'nom_adh', 'prenom_adh', 'email_adh')\n            )->where->in(self::PK, $list);\n\n            $results = $zdb->execute($select);\n\n            $infos = null;\n            foreach ($results as $member) {\n                $str_adh = $member->id_adh . ' (' . $member->nom_adh . ' ' .\n                    $member->prenom_adh . ')';\n                $infos .= $str_adh . \"\\n\";\n\n                $p = new Picture($member->id_adh);\n                if ($p->hasPicture()) {\n                    if (!$p->delete(false)) {\n                        Analog::log(\n                            'Unable to delete picture for member ' . $str_adh,\n                            Analog::ERROR\n                        );\n                        throw new \\Exception(\n                            'Unable to delete picture for member ' .\n                            $str_adh\n                        );\n                    } else {\n                        $hist->add(\n                            _T(\"Member Picture deleted\"),\n                            $str_adh\n                        );\n                    }\n                }\n\n                $processed[] = [\n                    'id_adh' => $member->id_adh,\n                    'nom_adh' => $member->nom_adh,\n                    'prenom_adh' => $member->prenom_adh,\n                    'email_adh' => $member->email_adh\n                ];\n            }\n\n            //delete contributions\n            $del_qry = $zdb->delete(Contribution::TABLE);\n            $del_qry->where->in(\n                self::PK,\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //get transactions\n            $select = $zdb->select(Transaction::TABLE);\n            $select->where->in(self::PK, $list);\n            $results = $zdb->execute($select);\n\n            //if members has transactions;\n            //reset link with other contributions\n            //and remove them\n            if ($results->count() > 0) {\n                $transactions = [];\n                foreach ($results as $transaction) {\n                    $transactions[] = $transaction[Transaction::PK];\n                }\n\n                $update = $zdb->update(Contribution::TABLE);\n                $update->set([\n                    Transaction::PK => new Expression('NULL')\n                ])->where->in(\n                    Transaction::PK,\n                    $transactions\n                );\n                $zdb->execute($update);\n            }\n\n            //delete transactions\n            $del_qry = $zdb->delete(Transaction::TABLE);\n            $del_qry->where->in(self::PK, $list);\n            $zdb->execute($del_qry);\n\n            //delete groups membership/mamagmentship\n            Groups::removeMembersFromGroups($list);\n\n            //delete reminders\n            $del_qry = $zdb->delete(Reminder::TABLE);\n            $del_qry->where->in(\n                'reminder_dest',\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //delete dynamic fields values\n            $del_qry = $zdb->delete(DynamicFieldsHandle::TABLE);\n            $del_qry->where(['field_form' => 'adh']);\n            $del_qry->where->in('item_id', $list);\n            $zdb->execute($del_qry);\n\n            //delete members\n            $del_qry = $zdb->delete(self::TABLE);\n            $del_qry->where->in(\n                self::PK,\n                $list\n            );\n            $zdb->execute($del_qry);\n\n            //commit all changes\n            $zdb->connection->commit();\n\n            foreach ($processed as $p) {\n                $emitter->emit('member.remove', $p);\n            }\n\n            //add an history entry\n            $hist->add(\n                _T(\"Delete members cards, transactions and dues\"),\n                $infos\n            );\n\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            if ($e->getCode() == 23000) {\n                Analog::log(\n                    'Member still have existing dependencies in the ' .\n                    'database, maybe a mailing or some content from a ' .\n                    'plugin. Please remove dependencies before trying ' .\n                    'to remove him.',\n                    Analog::ERROR\n                );\n                $this->errors[] = _T(\"Cannot remove a member who still have dependencies (mailings, ...)\");\n            } else {\n                Analog::log(\n                    'Unable to delete selected member(s) |' .\n                    $e->getMessage(),\n                    Analog::ERROR\n                );\n                throw $e;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get members list\n     *\n     * @param boolean $as_members return the results as an array of\n     *                            Member object.\n     * @param array   $fields     field(s) name(s) to get. Should be a string or\n     *                            an array. If null, all fields will be\n     *                            returned\n     *\n     * @return Adherent[]|ResultSet\n     */\n    public function getList($as_members = false, $fields = null)\n    {\n        return $this->getMembersList(\n            $as_members,\n            $fields,\n            false,\n            false,\n            false,\n            true,\n            false\n        );\n    }\n\n    /**\n     * Get members list with public information available\n     *\n     * @param boolean $with_photos get only members which have uploaded a\n     *                             photo (for trombinoscope)\n     *\n     * @return Adherent[]\n     */\n    public function getPublicList($with_photos)\n    {\n        global $zdb;\n\n        try {\n            $select = $this->buildSelect(\n                self::SHOW_PUBLIC_LIST,\n                null,\n                $with_photos,\n                true\n            );\n\n            $this->filters->setLimits($select);\n\n            $results = $zdb->execute($select);\n            $members = array();\n            $deps = array(\n                'groups'    => false,\n                'dues'      => false,\n                'picture'   => $with_photos\n            );\n            foreach ($results as $row) {\n                $members[] = new Adherent($zdb, $row, $deps);\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot list members with public information (photos: '\n                . $with_photos . ') | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Get list of members that has been selected\n     *\n     * @param array   $ids         an array of members id that has been selected\n     * @param array   $orderby     SQL order clause (optionnal)\n     * @param boolean $with_photos Should photos be loaded?\n     * @param boolean $as_members  Return Adherent[] or simple ResultSet\n     * @param array   $fields      Fields to use\n     * @param boolean $export      True if we are exporting\n     * @param boolean $dues        True if load dues as Adherent dependency\n     * @param boolean $parent      True if load parent as Adherent dependency\n     *\n     * @return Adherent[]\n     */\n    public function getArrayList(\n        $ids,\n        $orderby = null,\n        $with_photos = false,\n        $as_members = true,\n        $fields = null,\n        $export = false,\n        $dues = false,\n        $parent = false\n    ) {\n        global $zdb;\n\n        if (!is_array($ids) || count($ids) < 1) {\n            Analog::log('No member selected for labels.', Analog::INFO);\n            return false;\n        }\n\n        try {\n            $damode = self::SHOW_ARRAY_LIST;\n            if ($export === true) {\n                $damode = self::SHOW_EXPORT;\n            }\n            $select = $this->buildSelect(\n                $damode,\n                $fields,\n                false,\n                false\n            );\n            $select->where->in('a.' . self::PK, $ids);\n            if (is_array($orderby) && count($orderby) > 0) {\n                foreach ($orderby as $o) {\n                    $select->order($o);\n                }\n            }\n\n            $results = $zdb->execute($select);\n\n            $members = array();\n            $deps = array(\n                'picture'   => $with_photos,\n                'groups'    => false,\n                'dues'      => $dues,\n                'parent'    => $parent\n            );\n            foreach ($results as $o) {\n                if ($as_members === true) {\n                    $members[] = new Adherent($zdb, $o, $deps);\n                } else {\n                    $members[] = $o;\n                }\n            }\n            return $members;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot load members form ids array | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the SELECT statement\n     *\n     * @param int   $mode   the current mode (see self::SHOW_*)\n     * @param array $fields fields list to retrieve\n     * @param bool  $photos true if we want to get only members with photos\n     *                      Default to false, only relevant for SHOW_PUBLIC_LIST\n     * @param bool  $count  true if we want to count members, defaults to false\n     *\n     * @return Select SELECT statement\n     */\n    private function buildSelect($mode, $fields, $photos, $count = false): Select\n    {\n        global $zdb, $login;\n\n        try {\n            if ($fields != null && is_array($fields) && !in_array('id_adh', $fields)) {\n                $fields[] = 'id_adh';\n            }\n            $fieldsList = ($fields != null)\n                            ? ((!is_array($fields) || count($fields) < 1) ? (array)'*'\n                            : $fields) : (array)'*';\n\n            $select = $zdb->select(self::TABLE, 'a');\n\n            $select->columns($fieldsList);\n\n            $select->quantifier('DISTINCT');\n\n            $select->join(\n                array('so' => PREFIX_DB . Social::TABLE),\n                'a.' . Adherent::PK . '=so.' . Adherent::PK,\n                array(),\n                $select::JOIN_LEFT\n            );\n\n            switch ($mode) {\n                case self::SHOW_STAFF:\n                case self::SHOW_LIST:\n                case self::SHOW_ARRAY_LIST:\n                case self::SHOW_EXPORT:\n                    $select->join(\n                        array('status' => PREFIX_DB . Status::TABLE),\n                        'a.' . Status::PK . '=status.' . Status::PK,\n                        array()\n                    );\n                    break;\n                case self::SHOW_MANAGED:\n                    $select->join(\n                        array('status' => PREFIX_DB . Status::TABLE),\n                        'a.' . Status::PK . '=status.' . Status::PK\n                    )->join(\n                        array('gr' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                        'a.' . Adherent::PK . '=gr.' . Adherent::PK,\n                        array()\n                    )->join(\n                        array('m' => PREFIX_DB . Group::GROUPSMANAGERS_TABLE),\n                        'gr.' . Group::PK . '=m.' . Group::PK,\n                        array()\n                    )->where(['m.' . Adherent::PK => $login->id]);\n                    break;\n                case self::SHOW_PUBLIC_LIST:\n                    if ($photos) {\n                        $select->join(\n                            array('picture' => PREFIX_DB . Picture::TABLE),\n                            'a.' . self::PK . '= picture.' . self::PK,\n                            array()\n                        );\n                    }\n                    break;\n            }\n\n            //check for contributions filtering\n            if (\n                $this->filters instanceof AdvancedMembersList\n                && $this->filters->withinContributions()\n            ) {\n                $select->join(\n                    array('ct' => PREFIX_DB . Contribution::TABLE),\n                    'ct.' . self::PK . '=a.' . self::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                );\n            }\n\n            //check if there are dynamic fields in filter\n            $hasDf = false;\n            $dfs = array();\n            if ($this->filters instanceof AdvancedMembersList) {\n                if (\n                    (bool)count($this->filters->free_search)\n                    && !isset($this->filters->free_search['empty'])\n                ) {\n                    $free_searches = $this->filters->free_search;\n                    foreach ($free_searches as $fs) {\n                        if (strpos($fs['field'], 'dyn_') === 0) {\n                            // simple dynamic fields\n                            $hasDf = true;\n                            $dfs[] = str_replace('dyn_', '', $fs['field']);\n                        }\n                    }\n                }\n            }\n\n            //check if there are dynamic fields for contributions in filter\n            $hasDfc = false;\n            $hasCdfc = false;\n            $cdfcs = array();\n\n            if (\n                $this->filters instanceof AdvancedMembersList\n                && $this->filters->withinContributions()\n            ) {\n                if (\n                    $this->filters->contrib_dynamic\n                    && count($this->filters->contrib_dynamic) > 0\n                    && !isset($this->filters->contrib_dynamic['empty'])\n                ) {\n                    $hasDfc = true;\n\n                    //check if there are dynamic fields in the filter\n                    foreach ($this->filters->contrib_dynamic as $k => $cd) {\n                        if (is_array($cd)) {\n                            $hasCdfc = true;\n                            $cdfcs[] = $k;\n                        }\n                    }\n                }\n            }\n\n            if ($hasDfc === true || $hasCdfc === true) {\n                $select->join(\n                    array('dfc' => PREFIX_DB . DynamicFieldsHandle::TABLE),\n                    'dfc.item_id=ct.' . Contribution::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                );\n            }\n\n            // simple dynamic fields\n            if ($hasDf === true) {\n                foreach ($dfs as $df) {\n                    $subselect = $zdb->select(DynamicFieldsHandle::TABLE, 'df');\n                    $subselect->columns(\n                        [\n                            'item_id'   => 'item_id',\n                            'val'       => 'field_val'\n                        ]\n                    );\n                    $subselect->where(['df.field_form' => 'adh']);\n                    $subselect->where(['df.field_id' => $df]);\n                    $select->join(\n                        array('df' . $df => $subselect),\n                        'a.id_adh = df' . $df . '.item_id',\n                        array(),\n                        $select::JOIN_LEFT\n                    );\n                }\n            }\n\n            // choice dynamic fields\n            if ($hasCdfc === true) {\n                $cdf_field = 'cdf.id';\n                if (TYPE_DB === 'pgsql') {\n                    $cdf_field .= '::text';\n                }\n\n                $cdf_field = 'cdfc.id';\n                if (TYPE_DB === 'pgsql') {\n                    $cdf_field .= '::text';\n                }\n                foreach ($cdfcs as $cdf) {\n                    $rcdf_field = str_replace(\n                        'cdfc.',\n                        'cdfc' . $cdf . '.',\n                        $cdf_field\n                    );\n                    $select->join(\n                        array('cdfc' . $cdf => DynamicField::getFixedValuesTableName($cdf, true)),\n                        $rcdf_field . '=dfc.field_val',\n                        array(),\n                        $select::JOIN_LEFT\n                    );\n                }\n            }\n\n            if ($mode == self::SHOW_LIST || $mode == self::SHOW_MANAGED) {\n                if ($this->filters !== false) {\n                    $this->buildWhereClause($select);\n                }\n            } elseif ($mode == self::SHOW_PUBLIC_LIST) {\n                $select->where(\n                    array(\n                        new PredicateSet(\n                            array(\n                                new Operator(\n                                    'date_echeance',\n                                    '>=',\n                                    date('Y-m-d')\n                                ),\n                                new Operator(\n                                    'bool_exempt_adh',\n                                    '=',\n                                    new Expression('true')\n                                )\n                            ),\n                            PredicateSet::OP_OR\n                        ),\n                        new PredicateSet(\n                            array(\n                                new Operator(\n                                    'bool_display_info',\n                                    '=',\n                                    new Expression('true')\n                                ),\n                                new Operator(\n                                    'activite_adh',\n                                    '=',\n                                    new Expression('true')\n                                )\n                            ),\n                            PredicateSet::OP_AND\n                        )\n                    )\n                );\n            }\n\n            if ($mode === self::SHOW_STAFF) {\n                $select->where->lessThan(\n                    'status.priorite_statut',\n                    self::NON_STAFF_MEMBERS\n                );\n            }\n\n            if ($count) {\n                $this->proceedCount($select);\n            }\n\n            $this->buildOrderClause($select, $fields);\n\n            return $select;\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot build SELECT clause for members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Count members from the query\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function proceedCount(Select $select)\n    {\n        global $zdb;\n\n        try {\n            $countSelect = clone $select;\n            $countSelect->reset($countSelect::COLUMNS);\n            $countSelect->reset($countSelect::ORDER);\n            $countSelect->reset($countSelect::HAVING);\n            $joins = $countSelect->joins;\n            $countSelect->reset($countSelect::JOINS);\n            foreach ($joins as $join) {\n                $countSelect->join(\n                    $join['name'],\n                    $join['on'],\n                    [],\n                    $join['type']\n                );\n                unset($join['columns']);\n            }\n            $countSelect->columns(\n                array(\n                    'count' => new Expression('count(DISTINCT a.' . self::PK . ')')\n                )\n            );\n\n            $have = $select->having;\n            if ($have->count() > 0) {\n                foreach ($have->getPredicates() as $h) {\n                    $countSelect->where($h);\n                }\n            }\n\n            $results = $zdb->execute($countSelect);\n\n            $this->count = (int)$results->current()->count;\n            if (isset($this->filters) && $this->count > 0) {\n                $this->filters->setCounter($this->count);\n            }\n        } catch (Throwable $e) {\n            Analog::log(\n                'Cannot count members | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds the order clause\n     *\n     * @param Select $select Original select\n     * @param array  $fields Fields list to ensure ORDER clause\n     *                       references selected fields. Optional.\n     *\n     * @return Select\n     */\n    private function buildOrderClause(Select $select, $fields = null): Select\n    {\n        $order = array();\n\n        switch ($this->filters->orderby) {\n            case self::ORDERBY_NICKNAME:\n                if ($this->canOrderBy('pseudo_adh', $fields)) {\n                    $order[] = 'pseudo_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_STATUS:\n                if ($this->canOrderBy('priorite_statut', $fields)) {\n                    $order[] = 'priorite_statut ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_MODIFDATE:\n                if ($this->canOrderBy('date_modif_adh', $fields)) {\n                    $order[] = 'date_modif_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case 'list_adh_contribstatus':\n            case self::ORDERBY_FEE_STATUS:\n                if ($this->canOrderBy('bool_exempt_adh', $fields)) {\n                    $order[] = 'bool_exempt_adh ' . $this->filters->getDirection();\n                }\n\n                if ($this->canOrderBy('date_echeance', $fields)) {\n                    $order[] = 'date_echeance ' . $this->filters->getDirection();\n                }\n                break;\n            case self::ORDERBY_ID:\n                if ($this->canOrderBy('id_adh', $fields)) {\n                    $order[] = 'id_adh ' . $this->filters->getDirection();\n                }\n                break;\n            case 'list_adh_name':\n            case 'nom_adh':\n            case 'prenom_adh':\n            case self::ORDERBY_NAME:\n                //defaults\n                break;\n            default:\n                if ($this->canOrderBy($this->filters->orderby, $fields)) {\n                    $order[] = $this->filters->orderby . ' ' . $this->filters->getDirection();\n                }\n                break;\n        }\n\n        //anyways, we want to order by firstname, lastname\n        if ($this->canOrderBy('nom_adh', $fields)) {\n            $order[] = 'nom_adh ' . $this->filters->getDirection();\n        }\n        if ($this->canOrderBy('prenom_adh', $fields)) {\n            $order[] = 'prenom_adh ' . $this->filters->getDirection();\n        }\n\n        $select->order($order);\n        return $select;\n    }\n\n    /**\n     * Is field allowed to order? it shoulsd be present in\n     * provided fields list (those that are SELECT'ed).\n     *\n     * @param string $field_name Field name to order by\n     * @param array  $fields     SELECTE'ed fields\n     *\n     * @return boolean\n     */\n    private function canOrderBy($field_name, $fields)\n    {\n        if ($fields === null) {\n            return true;\n        } elseif (!is_array($fields)) {\n            return false;\n        } elseif (in_array($field_name, $fields)) {\n            return true;\n        } else {\n            Analog::log(\n                'Trying to order by ' . $field_name . ' while it is not in ' .\n                'selected fields.',\n                Analog::WARNING\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Builds where clause, for filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function buildWhereClause(Select $select)\n    {\n        global $zdb, $login;\n\n        try {\n            if ($this->filters->email_filter == self::FILTER_W_EMAIL) {\n                $select->where('email_adh != \\'\\'');\n            }\n            if ($this->filters->email_filter == self::FILTER_WO_EMAIL) {\n                $select->where('(email_adh = \\'\\' OR email_adh IS NULL)');\n            }\n\n            if ($this->filters->filter_str != '') {\n                $token = $zdb->platform->quoteValue(\n                    '%' . strtolower($this->filters->filter_str) . '%'\n                );\n                switch ($this->filters->field_filter) {\n                    case self::FILTER_NAME:\n                        if (TYPE_DB === 'pgsql') {\n                            $sep = \" || ' ' || \";\n                            $pre = '';\n                            $post = '';\n                        } else {\n                            $sep = ', \" \", ';\n                            $pre = 'CONCAT(';\n                            $post = ')';\n                        }\n\n                        $select->where(\n                            '(' .\n                            $pre . 'LOWER(nom_adh)' . $sep .\n                            'LOWER(prenom_adh)' . $sep .\n                            'LOWER(pseudo_adh)' . $post . ' LIKE ' .\n                            $token\n                            . ' OR ' .\n                            $pre . 'LOWER(prenom_adh)' . $sep .\n                            'LOWER(nom_adh)' . $sep .\n                            'LOWER(pseudo_adh)' . $post . ' LIKE ' .\n                            $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_COMPANY_NAME:\n                        $select->where(\n                            'LOWER(societe_adh) LIKE ' .\n                            $token\n                        );\n                        break;\n                    case self::FILTER_ADDRESS:\n                        $select->where(\n                            '(' .\n                            'LOWER(adresse_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(adresse2_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'cp_adh LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(ville_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(pays_adh) LIKE ' . $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_MAIL:\n                        $select->where(\n                            '(' .\n                            'LOWER(email_adh) LIKE ' . $token\n                            . ' OR ' .\n                            'LOWER(so.url) LIKE ' . $token\n                            . ')'\n                        );\n                        break;\n                    case self::FILTER_JOB:\n                        $select->where(\n                            'LOWER(prof_adh) LIKE ' . $token\n                        );\n                        break;\n                    case self::FILTER_INFOS:\n                        $more = '';\n                        if ($login->isAdmin() || $login->isStaff()) {\n                            $more = ' OR LOWER(info_adh) LIKE ' . $token;\n                        }\n                        $select->where(\n                            '(LOWER(info_public_adh) LIKE ' .\n                            $token . $more . ')'\n                        );\n                        break;\n                    case self::FILTER_NUMBER:\n                        $select->where->equalTo('a.num_adh', $this->filters->filter_str);\n                        break;\n                    case self::FILTER_ID:\n                        $select->where->equalTo('a.id_adh', $this->filters->filter_str);\n                        break;\n                }\n            }\n\n            if ($this->filters->membership_filter) {\n                switch ($this->filters->membership_filter) {\n                    case self::MEMBERSHIP_NEARLY:\n                        $now = new \\DateTime();\n                        $duedate = new \\DateTime();\n                        $duedate->modify('+1 month');\n                        $select->where->greaterThan(\n                            'date_echeance',\n                            $now->format('Y-m-d')\n                        )->lessThanOrEqualTo(\n                            'date_echeance',\n                            $duedate->format('Y-m-d')\n                        );\n                        break;\n                    case self::MEMBERSHIP_LATE:\n                        $select->where\n                            ->lessThan(\n                                'date_echeance',\n                                date('Y-m-d', time())\n                            )->equalTo('bool_exempt_adh', new Expression('false'));\n                        break;\n                    case self::MEMBERSHIP_UP2DATE:\n                        $select->where(\n                            '(' . 'date_echeance >= \\'' . date('Y-m-d', time())\n                            . '\\' OR bool_exempt_adh=true)'\n                        );\n                        break;\n                    case self::MEMBERSHIP_NEVER:\n                        $select->where('date_echeance IS NULL')\n                            ->where('bool_exempt_adh = false');\n                        break;\n                    case self::MEMBERSHIP_STAFF:\n                        $select->where->lessThan(\n                            'status.priorite_statut',\n                            self::NON_STAFF_MEMBERS\n                        );\n                        break;\n                    case self::MEMBERSHIP_ADMIN:\n                        $select->where->equalTo('bool_admin_adh', true);\n                        break;\n                    case self::MEMBERSHIP_NONE:\n                        $select->where->equalTo('a.id_statut', Status::DEFAULT_STATUS);\n                        break;\n                }\n            }\n\n            if ($this->filters->filter_account) {\n                switch ($this->filters->filter_account) {\n                    case self::ACTIVE_ACCOUNT:\n                        $select->where('activite_adh=true');\n                        break;\n                    case self::INACTIVE_ACCOUNT:\n                        $select->where('activite_adh=false');\n                        break;\n                }\n            }\n\n            if ($this->filters->group_filter) {\n                $select->join(\n                    array('g' => PREFIX_DB . Group::GROUPSUSERS_TABLE),\n                    'a.' . Adherent::PK . '=g.' . Adherent::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                )->join(\n                    array('gs' => PREFIX_DB . Group::TABLE),\n                    'gs.' . Group::PK . '=g.' . Group::PK,\n                    array(),\n                    $select::JOIN_LEFT\n                )->where(\n                    '(g.' . Group::PK . ' = ' . $zdb->platform->quoteValue($this->filters->group_filter) .\n                    ' OR gs.parent_group = NULL OR gs.parent_group = ' .\n                    $this->filters->group_filter . ')'\n                );\n            }\n\n            if ($this->filters instanceof AdvancedMembersList) {\n                $this->buildAdvancedWhereClause($select);\n            }\n\n            return $select;\n        } catch (Throwable $e) {\n            Analog::log(\n                __METHOD__ . ' | ' . $e->getMessage(),\n                Analog::WARNING\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Builds where clause, for advanced filtering on simple list mode\n     *\n     * @param Select $select Original select\n     *\n     * @return void\n     */\n    private function buildAdvancedWhereClause(Select $select)\n    {\n        global $zdb, $login;\n\n        // Search members who belong to any (OR) or all (AND) listed groups.\n        // Idea is to build an array of members ID that fits groups selection\n        // we will use in the final query.\n        // The OR case is quite simple, AND is a bit more complex; since we must\n        // check each member do belongs to all listed groups.\n        if (\n            count($this->filters->groups_search) > 0\n            && !isset($this->filters->groups_search['empty'])\n        ) {\n            $groups_adh = [];\n            $wheregroups = [];\n\n            foreach ($this->filters->groups_search as $gs) { // then add a row for each group\n                $wheregroups[] = $gs['group'];\n            }\n\n            $gselect = $zdb->select(Group::GROUPSUSERS_TABLE, 'gu');\n            $gselect->columns(\n                array('id_adh')\n            )->join(\n                array('g' => PREFIX_DB . Group::TABLE),\n                'gu.id_group=g.' . Group::PK,\n                array(),\n                $select::JOIN_LEFT\n            )->where(\n                array(\n                    'g.id_group'        => ':group',\n                    'g.parent_group'    => ':pgroup'\n                ),\n                PredicateSet::OP_OR\n            );\n            $gselect->group(['gu.id_adh']);\n\n            $stmt = $zdb->sql->prepareStatementForSqlObject($gselect);\n\n            $mids = [];\n            $ids = [];\n            foreach ($this->filters->groups_search as $gs) { // then add a row for each ig/searched group pair\n                $gresults = $stmt->execute(\n                    array(\n                        'group'    => $gs['group'],\n                        'pgroup'   => $gs['group']\n                    )\n                );\n\n                switch ($this->filters->groups_search_log_op) {\n                    case AdvancedMembersList::OP_AND:\n                        foreach ($gresults as $gresult) {\n                            if (!isset($ids[$gresult['id_adh']])) {\n                                $ids[$gresult['id_adh']] = 0;\n                            }\n                            $ids[$gresult['id_adh']] += 1;\n                        }\n                        break;\n                    case AdvancedMembersList::OP_OR:\n                        foreach ($gresults as $gresult) {\n                            $mids[$gresult['id_adh']] = $gresult['id_adh'];\n                        }\n                        break;\n                }\n            }\n\n            if (count($ids)) {\n                foreach ($ids as $id_adh => $count) {\n                    if ($count == count($wheregroups)) {\n                        $mids[$id_adh] = $id_adh;\n                    }\n                }\n            }\n\n            if (count($mids)) {\n                //limit on found members\n                $select->where->in('a.id_adh', $mids);\n            } else {\n                //no match in groups, end of game.\n                $select->where('false = true');\n            }\n        }\n\n        //FIXME: should be retrieved from members_fields\n        $dates = [\n            'ddn_adh'               => 'birth_date',\n            'date_crea_adh'         => 'creation_date',\n            'date_modif_adh'        => 'modif_date',\n            'date_echeance'         => 'due_date',\n            'ct.date_enreg'         => 'contrib_creation_date',\n            'ct.date_debut_cotis'   => 'contrib_begin_date',\n            'ct.date_fin_cotis'     => 'contrib_end_date'\n        ];\n\n        foreach ($dates as $field => $property) {\n            $bprop = \"r{$property}_begin\";\n            if ($this->filters->$bprop) {\n                $d = new \\DateTime($this->filters->$bprop);\n                $select->where->greaterThanOrEqualTo(\n                    $field,\n                    $d->format('Y-m-d')\n                );\n            }\n            $eprop = \"r{$property}_end\";\n            if ($this->filters->$eprop) {\n                $d = new \\DateTime($this->filters->$eprop);\n                $select->where->lessThanOrEqualTo(\n                    $field,\n                    $d->format('Y-m-d')\n                );\n            }\n        }\n\n        if ($this->filters->show_public_infos) {\n            switch ($this->filters->show_public_infos) {\n                case self::FILTER_W_PUBINFOS:\n                    $select->where('bool_display_info = true');\n                    break;\n                case self::FILTER_WO_PUBINFOS:\n                    $select->where('bool_display_info = false');\n                    break;\n                case self::FILTER_DC_PUBINFOS:\n                    //nothing to do here.\n                    break;\n            }\n        }\n\n        if ($this->filters->status) {\n            $select->where->in(\n                'a.id_statut',\n                $this->filters->status\n            );\n        }\n\n        if (\n            $this->filters->contrib_min_amount\n            || $this->filters->contrib_max_amount\n        ) {\n            if ($this->filters->contrib_min_amount) {\n                $select->where->greaterThanOrEqualTo(\n                    'ct.montant_cotis',\n                    $this->filters->contrib_min_amount\n                );\n            }\n            if ($this->filters->contrib_max_amount) {\n                $select->where->lessThanOrEqualTo(\n                    'ct.montant_cotis',\n                    $this->filters->contrib_max_amount\n                );\n            }\n        }\n\n        if ($this->filters->contributions_types) {\n            $select->where->in(\n                'ct.id_type_cotis',\n                $this->filters->contributions_types\n            );\n        }\n\n        if ($this->filters->payments_types) {\n            $select->where->in(\n                'ct.type_paiement_cotis',\n                $this->filters->payments_types\n            );\n        }\n\n        if (\n            count($this->filters->contrib_dynamic) > 0\n            && !isset($this->filters->contrib_dynamic['empty'])\n        ) {\n            foreach ($this->filters->contrib_dynamic as $k => $cd) {\n                $qry = '';\n                $prefix = 'a.';\n                $field = null;\n                $qop = ' LIKE ';\n\n                if (is_array($cd)) {\n                    //dynamic choice spotted!\n                    $prefix = 'cdfc' . $k . '.';\n                    $qry = 'dfc.field_form = \\'contrib\\' AND ' .\n                        'dfc.field_id = ' . $k;\n                    $field = 'id';\n                    $select->where($qry);\n                    $select->where->in($prefix . $field, $cd);\n                } else {\n                    //dynamic field spotted!\n                    $prefix = 'dfc.';\n                    $qry = 'dfc.field_form = \\'contrib\\' AND ' .\n                        'dfc.field_id = ' . $k . ' AND ';\n                    $field = 'field_val';\n                    $qry .= 'LOWER(' . $prefix . $field . ') ' .\n                        $qop . ' ';\n                    $select->where($qry . $zdb->platform->quoteValue('%' . strtolower($cd) . '%'));\n                }\n            }\n        }\n\n        if (\n            count($this->filters->free_search) > 0\n            && !isset($this->filters->free_search['empty'])\n        ) {\n            foreach ($this->filters->free_search as $fs) {\n                $fs['search'] = mb_strtolower($fs['search']);\n                $qop = null;\n                switch ($fs['qry_op']) {\n                    case AdvancedMembersList::OP_EQUALS:\n                        $qop = '=';\n                        break;\n                    case AdvancedMembersList::OP_CONTAINS:\n                        $qop = 'LIKE';\n                        $fs['search'] = '%' . $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_NOT_EQUALS:\n                        $qop = '!=';\n                        break;\n                    case AdvancedMembersList::OP_NOT_CONTAINS:\n                        $qop = 'NOT LIKE';\n                        $fs['search'] = '%' . $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_STARTS_WITH:\n                        $qop = 'LIKE';\n                        $fs['search'] = $fs['search'] . '%';\n                        break;\n                    case AdvancedMembersList::OP_ENDS_WITH:\n                        $qop = 'LIKE';\n                        $fs['search'] = '%' . $fs['search'];\n                        break;\n                    case AdvancedMembersList::OP_BEFORE:\n                        $qop = '<';\n                        break;\n                    case AdvancedMembersList::OP_AFTER:\n                        $qop = '>';\n                        break;\n                    default:\n                        Analog::log(\n                            'Unknown query operator: ' . $fs['qry_op'] .\n                            ' (will fallback to equals)',\n                            Analog::WARNING\n                        );\n                        $qop = '=';\n                        break;\n                }\n\n                $qry = '';\n                $prefix = 'a.';\n                $dyn_field = false;\n                if (strpos($fs['field'], 'dyn_') === 0) {\n                    // simple dynamic field spotted!\n                    $index = str_replace('dyn_', '', $fs['field']);\n                    $dyn_field = DynamicField::loadFieldType($zdb, (int)$index);\n                    $prefix = 'df' . $index . '.';\n                    $fs['field'] = 'val';\n                }\n\n                //handle socials networks\n                if (strpos($fs['field'], 'socials_') === 0) {\n                    //social networks\n                    $type = str_replace('socials_', '', $fs['field']);\n                    $prefix = 'so.';\n                    $fs['field'] = 'url';\n                    $select->where(['so.type' => $type]);\n                }\n\n                if ($dyn_field && $dyn_field instanceof \\Galette\\DynamicFields\\Boolean) {\n                    if ($fs['search'] != 0) {\n                        $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                            $fs['search'];\n                    } else {\n                        $qry .= $prefix . $fs['field'] . ' IS NULL';\n                    }\n                } elseif (!strncmp($fs['field'], 'bool_', strlen('bool_'))) {\n                    $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                        $fs['search'];\n                } elseif (\n                    $fs['qry_op'] === AdvancedMembersList::OP_BEFORE\n                    || $fs['qry_op'] === AdvancedMembersList::OP_AFTER\n                ) {\n                    if ($prefix === 'a.') {\n                        //dates are OK in the main fields. no cast, just query!\n                        $qry .= $prefix . $fs['field'] . $qop . ' ' .\n                            $zdb->platform->quoteValue($fs['search']);\n                    } else {\n                        //dynamic dates are stored in their localized format :/\n                        //use current lang format to query for now\n                        if ($zdb->isPostgres()) {\n                            $fs['search'] = \"to_date('\" . $fs['search'] . \"', 'YYYY-MM-DD')\";\n                            $store_fmt = __(\"Y-m-d\") === 'Y-m-d' ? 'YYYY-MM-DD' : 'DD/MM/YYYY';\n                            $qry .= \"to_date('\" . $prefix . $fs['field'] . \"', '$store_fmt')\";\n                        } else {\n                            $fs['search'] = \"STR_TO_DATE('\" . $fs['search'] . \"', '%Y-%m-%d')\";\n                            $store_fmt = __(\"Y-m-d\") === 'Y-m-d' ? '%Y-%m-%d' : '%d/%m/%Y';\n                            $qry .= 'STR_TO_DATE(' . $prefix . $fs['field'] . ', \\'' . $store_fmt . '\\') ';\n                        }\n\n                        $qry .= $qop . ' ' . $fs['search'];\n                    }\n                } elseif ($fs['field'] == 'status_label') {\n                    $qry_pattern = '%p%field %op %value';\n                    $qry .= str_replace(\n                        [\n                            '%p',\n                            '%field',\n                            '%op',\n                            '%value'\n                        ],\n                        [\n                            'status.',\n                            'libelle_statut',\n                            $qop,\n                            $zdb->platform->quoteValue($fs['search'])\n                        ],\n                        $qry_pattern\n                    );\n                } else {\n                    $qry .= 'LOWER(' . $prefix . $fs['field'] . ') ' .\n                        $qop . ' ' . $zdb->platform->quoteValue($fs['search']);\n                }\n\n                if ($fs['log_op'] === AdvancedMembersList::OP_AND) {\n                    $select->where($qry);\n                } elseif ($fs['log_op'] === AdvancedMembersList::OP_OR) {\n                    $select->where($qry, PredicateSet::OP_OR);\n                }\n            }\n        }\n\n        return $select;\n    }\n\n    /**\n     * Login and password field cannot be empty.\n     *\n     * If those ones are not required, or if a file has been imported\n     * (from a CSV file for example), we fill here random values.\n     *\n     * @return boolean\n     */\n    public function emptyLogins()\n    {\n        global $zdb;\n\n        try {\n            $zdb->connection->beginTransaction();\n            $select = $zdb->select(Adherent::TABLE);\n            $select->columns(\n                array('id_adh', 'login_adh', 'mdp_adh')\n            )->where(\n                array(\n                    'login_adh' => new Expression('NULL'),\n                    'login_adh' => '',\n                    'mdp_adh'   => new Expression('NULL'),\n                    'mdp_adh'   => ''\n                ),\n                PredicateSet::OP_OR\n            );\n\n            $results = $zdb->execute($select);\n\n            $processed = 0;\n            if ($results->count() > 0) {\n                $update = $zdb->update(Adherent::TABLE);\n                $update->set(\n                    array(\n                        'login_adh' => ':login',\n                        'mdp_adh'   => ':pass'\n                    )\n                )->where->equalTo(Adherent::PK, ':id');\n\n                $stmt = $zdb->sql->prepareStatementForSqlObject($update);\n\n                $p = new \\Galette\\Core\\Password($zdb);\n\n                foreach ($results as $m) {\n                    $dirty = false;\n                    if (\n                        $m->login_adh == ''\n                        || !isset($m->login_adh)\n                        || $m->login_adh == 'NULL'\n                    ) {\n                        $m->login_adh = $p->makeRandomPassword(15);\n                        $dirty = true;\n                    }\n\n                    if (\n                        $m->mdp_adh == ''\n                        || !isset($m->mdp_adh)\n                        || $m->mdp_adh == 'NULL'\n                    ) {\n                        $randomp = $p->makeRandomPassword(15);\n                        $m->mdp_adh = password_hash(\n                            $randomp,\n                            PASSWORD_BCRYPT\n                        );\n                        $dirty = true;\n                    }\n\n                    if ($dirty === true) {\n                        $stmt->execute(\n                            array(\n                                'login' => $m->login_adh,\n                                'pass'  => $m->mdp_adh,\n                                'id'    => $m->id_adh\n                            )\n                        );\n                        $processed++;\n                    }\n                }\n            }\n            $zdb->connection->commit();\n            $this->count = $processed;\n            return true;\n        } catch (Throwable $e) {\n            $zdb->connection->rollBack();\n            Analog::log(\n                'An error occurred trying to retrieve members with ' .\n                'empty logins/passwords (' . $e->getMessage(),\n                Analog::ERROR\n            );\n            throw $e;\n        }\n    }\n\n    /**\n     * Loads data to produce a Pie chart based on members state of dues\n     *\n     * @return void\n     */\n    public function getRemindersCount()\n    {\n        global $zdb;\n\n        $reminders = array();\n\n        $soon_date = new \\DateTime();\n        $soon_date->modify('+1 month');\n\n        $now = new \\DateTime();\n\n        $select = $zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            array(\n                'cnt' => new Expression('count(a.' . Adherent::PK . ')')\n            )\n        );\n\n        $select->join(\n            array('parent' => PREFIX_DB . self::TABLE),\n            'a.parent_id=parent.' . self::PK,\n            array(),\n            $select::JOIN_LEFT\n        );\n\n        $select->where\n            ->lessThan('a.date_echeance', $soon_date->format('Y-m-d'))\n            ->greaterThanOrEqualTo('a.date_echeance', $now->format('Y-m-d'));\n        $select\n            ->where('a.activite_adh=true')\n            ->where('a.bool_exempt_adh=false');\n\n        $select_wo_mail = clone $select;\n\n        $select->where(\n            '(a.email_adh != \\'\\' OR a.parent_id IS NOT NULL AND parent.email_adh != \\'\\')'\n        );\n        $select_wo_mail->where(\n            '(a.email_adh = \\'\\' OR a.email_adh IS NULL) AND (parent.email_adh = \\'\\' OR parent.email_adh IS NULL)'\n        );\n\n        $results = $zdb->execute($select);\n        $res = $results->current();\n        $reminders['impending'] = $res->cnt;\n\n        $results_wo_mail = $zdb->execute($select_wo_mail);\n        $res_wo_mail = $results_wo_mail->current();\n        $reminders['nomail']['impending'] = $res_wo_mail->cnt;\n\n        $select = $zdb->select(Adherent::TABLE, 'a');\n        $select->columns(\n            array(\n                'cnt' => new Expression('count(a.' . Adherent::PK . ')')\n            )\n        );\n\n        $select->join(\n            array('parent' => PREFIX_DB . self::TABLE),\n            'a.parent_id=parent.' . self::PK,\n            array(),\n            $select::JOIN_LEFT\n        );\n\n        $select->where\n            ->lessThan('a.date_echeance', $now->format('Y-m-d'));\n        $select\n            ->where('a.activite_adh=true')\n            ->where('a.bool_exempt_adh=false');\n\n        $select_wo_mail = clone $select;\n\n        $select->where(\n            '(a.email_adh != \\'\\' OR a.parent_id IS NOT NULL AND parent.email_adh != \\'\\')'\n        );\n\n        $select_wo_mail->where(\n            '(a.email_adh = \\'\\' OR a.email_adh IS NULL) AND (parent.email_adh = \\'\\' OR parent.email_adh IS NULL)'\n        );\n\n        $results = $zdb->execute($select);\n        $res = $results->current();\n        $reminders['late'] = $res->cnt;\n\n        $results_wo_mail = $zdb->execute($select_wo_mail);\n        $res_wo_mail = $results_wo_mail->current();\n        $reminders['nomail']['late'] = $res_wo_mail->cnt;\n\n        return $reminders;\n    }\n\n    /**\n     * Get count for current query\n     *\n     * @return int\n     */\n    public function getCount()\n    {\n        return $this->count;\n    }\n\n    /**\n     * Get registered errors\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get all existing emails\n     *\n     * @param Db $zdb Database instance\n     *\n     * @return array ['email' => 'id_adh']\n     */\n    public static function getEmails(Db $zdb)\n    {\n        $emails = [];\n        $select = $zdb->select(self::TABLE);\n        $select->columns([\n            self::PK,\n            'email_adh'\n        ]);\n        $select->where('email_adh != \\'\\' AND email_adh IS NOT NULL');\n        $rows = $zdb->execute($select);\n        foreach ($rows as $row) {\n            $emails[$row->email_adh] = $row->{self::PK};\n        }\n        return $emails;\n    }\n\n    /**\n     * Get current filters\n     *\n     * @return MembersList\n     */\n    public function getFilters()\n    {\n        return $this->filters;\n    }\n\n    /**\n     * Get members list to instanciate dropdowns\n     *\n     * @param Db      $zdb     Database instance\n     * @param integer $current Current member\n     *\n     * @return array\n     */\n    public function getSelectizedMembers(Db $zdb, $current = null)\n    {\n        $members = [];\n        $required_fields = array(\n            'id_adh',\n            'nom_adh',\n            'prenom_adh',\n            'pseudo_adh'\n        );\n        $list_members = $this->getList(false, $required_fields);\n\n        if (count($list_members) > 0) {\n            foreach ($list_members as $member) {\n                $pk = Adherent::PK;\n\n                $members[$member->$pk] = Adherent::getNameWithCase(\n                    $member->nom_adh,\n                    $member->prenom_adh,\n                    false,\n                    $member->id_adh,\n                    $member->pseudo_adh\n                );\n            }\n        }\n\n        //check if current attached member is part of the list\n        if ($current !== null && !isset($members[$current])) {\n            $members =\n                [$current => Adherent::getSName($zdb, $current, true, true)] +\n                $members\n            ;\n        }\n\n        return $members;\n    }\n}\n"], "filenames": ["galette/lib/Galette/Core/Db.php", "galette/lib/Galette/Core/Logo.php", "galette/lib/Galette/Core/MailingHistory.php", "galette/lib/Galette/Core/Password.php", "galette/lib/Galette/Core/Picture.php", "galette/lib/Galette/DynamicFields/DynamicField.php", "galette/lib/Galette/Entity/Adherent.php", "galette/lib/Galette/Entity/Contribution.php", "galette/lib/Galette/Entity/Entitled.php", "galette/lib/Galette/Entity/Group.php", "galette/lib/Galette/Entity/ImportModel.php", "galette/lib/Galette/Entity/PaymentType.php", "galette/lib/Galette/Entity/PdfModel.php", "galette/lib/Galette/Entity/Reminder.php", "galette/lib/Galette/Entity/SavedSearch.php", "galette/lib/Galette/Entity/Social.php", "galette/lib/Galette/Entity/Title.php", "galette/lib/Galette/Entity/Transaction.php", "galette/lib/Galette/Repository/Groups.php", "galette/lib/Galette/Repository/Members.php"], "buggy_code_start_loc": [10, 10, 359, 11, 10, 146, 476, 582, 129, 182, 178, 103, 139, 114, 105, 117, 94, 157, 10, 644], "buggy_code_end_loc": [677, 104, 454, 99, 345, 722, 1633, 968, 594, 824, 179, 197, 235, 115, 229, 203, 193, 551, 281, 1159], "fixing_code_start_loc": [10, 10, 359, 11, 10, 146, 476, 582, 129, 182, 178, 103, 139, 114, 105, 117, 94, 157, 10, 644], "fixing_code_end_loc": [677, 104, 454, 99, 343, 720, 1631, 966, 594, 814, 179, 193, 235, 115, 227, 203, 189, 547, 279, 1159], "type": "CWE-89", "message": "Galette is a membership management web application built for non profit organizations and released under GPLv3. Versions prior to 0.9.6 are subject to SQL injection attacks by users with \"member\" privilege. Users are advised to upgrade to version 0.9.6 as soon as possible. There are no known workarounds.", "other": {"cve": {"id": "CVE-2021-41262", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-16T19:15:08.240", "lastModified": "2021-12-21T18:54:07.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Galette is a membership management web application built for non profit organizations and released under GPLv3. Versions prior to 0.9.6 are subject to SQL injection attacks by users with \"member\" privilege. Users are advised to upgrade to version 0.9.6 as soon as possible. There are no known workarounds."}, {"lang": "es", "value": "Galette es una aplicaci\u00f3n web de administraci\u00f3n de socios construida para organizaciones sin \u00e1nimo de lucro y publicada bajo GPLv3. Las versiones anteriores a 0.9.6 est\u00e1n sujetas a ataques de inyecci\u00f3n SQL por parte de usuarios con privilegios \"member\". Se recomienda a usuarios que actualicen a la versi\u00f3n 0.9.6 lo antes posible. No se presentan soluciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:galette:galette:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.6", "matchCriteriaId": "98F845B7-F89C-4664-BE48-681C2B16EFE2"}]}]}], "references": [{"url": "https://github.com/galette/galette/commit/8e940641b5ed46c3f471332827df388ea00a85d3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/galette/galette/security/advisories/GHSA-936f-xvgq-fg74", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/galette/galette/commit/8e940641b5ed46c3f471332827df388ea00a85d3"}}