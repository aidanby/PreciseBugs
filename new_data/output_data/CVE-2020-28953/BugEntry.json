{"buggy_code": ["package org.bigbluebutton.core.models\n\nimport org.bigbluebutton.common2.domain._\nimport org.bigbluebutton.common2.msgs.AnnotationVO\nimport org.bigbluebutton.core.apps.WhiteboardKeyUtil\nimport org.bigbluebutton.core.domain.MeetingState2x\n\nimport scala.collection.mutable.ArrayBuffer\nimport scala.collection.mutable.HashMap\nimport org.bigbluebutton.core.running.LiveMeeting\n\nobject Polls {\n\n  def handleStartPollReqMsg(state: MeetingState2x, userId: String, pollId: String, pollType: String,\n                            lm: LiveMeeting): Option[SimplePollOutVO] = {\n    def createPoll(pollId: String, numRespondents: Int): Option[Poll] = {\n      for {\n        poll <- PollFactory.createPoll(pollId, pollType, numRespondents, None)\n      } yield {\n        lm.polls.save(poll)\n        poll\n      }\n    }\n\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      pageId: String = if (pollId.contains(\"deskshare\")) \"deskshare\" else page.id\n      stampedPollId: String = pageId + \"/\" + System.currentTimeMillis()\n      numRespondents: Int = Users2x.numUsers(lm.users2x) - 1 // subtract the presenter\n\n      poll <- createPoll(stampedPollId, numRespondents)\n      simplePoll <- getSimplePoll(poll.id, lm.polls)\n    } yield {\n      startPoll(simplePoll.id, lm.polls)\n      simplePoll\n    }\n  }\n\n  def handleStopPollReqMsg(state: MeetingState2x, userId: String, lm: LiveMeeting): Option[String] = {\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      curPoll <- getRunningPollThatStartsWith(page.id, lm.polls)\n    } yield {\n      stopPoll(curPoll.id, lm.polls)\n      curPoll.id\n    }\n  }\n\n  def handleShowPollResultReqMsg(state: MeetingState2x, requesterId: String, pollId: String, lm: LiveMeeting): Option[(SimplePollResultOutVO, AnnotationVO)] = {\n    def sanitizeAnnotation(annotation: AnnotationVO): AnnotationVO = {\n      // Remove null values by wrapping value with Option\n      val shape = annotation.annotationInfo.collect {\n        case (key, value: Any) => key -> Option(value)\n      }\n\n      // Unwrap the value wrapped as Option\n      val shape2 = shape.collect {\n        case (key, Some(value)) => key -> value\n      }\n\n      annotation.copy(annotationInfo = shape2)\n    }\n\n    def updateWhiteboardAnnotation(annotation: AnnotationVO): AnnotationVO = {\n      lm.wbModel.updateAnnotation(annotation.wbId, annotation.userId, annotation)\n    }\n\n    def send(poll: SimplePollResultOutVO, shape: scala.collection.immutable.Map[String, Object]): Option[AnnotationVO] = {\n      for {\n        pod <- state.presentationPodManager.getDefaultPod()\n        pres <- pod.getCurrentPresentation()\n        page <- PresentationInPod.getCurrentPage(pres)\n      } yield {\n        val pageId = if (poll.id.contains(\"deskshare\")) \"deskshare\" else page.id\n        val updatedShape = shape + (\"whiteboardId\" -> pageId)\n        val annotation = new AnnotationVO(poll.id, WhiteboardKeyUtil.DRAW_END_STATUS,\n          WhiteboardKeyUtil.POLL_RESULT_TYPE, updatedShape, pageId, requesterId, -1)\n        val sanitizedShape = sanitizeAnnotation(annotation)\n        updateWhiteboardAnnotation(sanitizedShape)\n      }\n    }\n\n    for {\n      result <- getSimplePollResult(pollId, lm.polls)\n      shape = pollResultToWhiteboardShape(result)\n      annot <- send(result, shape)\n    } yield {\n      showPollResult(pollId, lm.polls)\n      (result, annot)\n    }\n  }\n\n  def handleGetCurrentPollReqMsg(state: MeetingState2x, requesterId: String, lm: LiveMeeting): Option[PollVO] = {\n    val poll = for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      curPoll <- getRunningPollThatStartsWith(page.id, lm.polls)\n    } yield curPoll\n\n    poll match {\n      case Some(p) => {\n        if (p.started && p.stopped && p.showResult) {\n          Some(p)\n        } else {\n          None\n        }\n      }\n      case None => {\n        None\n      }\n    }\n  }\n\n  def handleRespondToPollReqMsg(requesterId: String, pollId: String, questionId: Int, answerId: Int,\n                                lm: LiveMeeting): Option[(String, SimplePollResultOutVO)] = {\n\n    for {\n      poll <- getSimplePollResult(pollId, lm.polls)\n      pvo <- handleRespondToPoll(poll, requesterId, pollId, questionId, answerId, lm)\n    } yield {\n      (pollId, pvo)\n    }\n\n  }\n\n  def handleStartCustomPollReqMsg(state: MeetingState2x, requesterId: String, pollId: String, pollType: String,\n                                  answers: Seq[String], lm: LiveMeeting): Option[SimplePollOutVO] = {\n\n    def createPoll(pollId: String, numRespondents: Int): Option[Poll] = {\n      for {\n        poll <- PollFactory.createPoll(pollId, pollType, numRespondents, Some(answers))\n      } yield {\n        lm.polls.save(poll)\n        poll\n      }\n    }\n\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      pageId: String = if (pollId.contains(\"deskshare\")) \"deskshare\" else page.id\n      stampedPollId: String = pageId + \"/\" + System.currentTimeMillis()\n      numRespondents: Int = Users2x.numUsers(lm.users2x) - 1 // subtract the presenter\n      poll <- createPoll(stampedPollId, numRespondents)\n      simplePoll <- getSimplePoll(stampedPollId, lm.polls)\n    } yield {\n      startPoll(poll.id, lm.polls)\n      simplePoll\n    }\n  }\n\n  //\n  // Helper methods:\n  //\n  private def handleRespondToPoll(poll: SimplePollResultOutVO, requesterId: String, pollId: String, questionId: Int,\n                                  answerId: Int, lm: LiveMeeting): Option[SimplePollResultOutVO] = {\n    /*\n   * Hardcode to zero as we are assuming the poll has only one question.\n   * Our data model supports multiple question polls but for this\n   * release, we only have a simple poll which has one question per poll.\n   * (ralam june 23, 2015)\n   */\n    val questionId = 0\n\n    def storePollResult(responder: Responder): Option[SimplePollResultOutVO] = {\n      respondToQuestion(poll.id, questionId, answerId, responder, lm.polls)\n      for {\n        updatedPoll <- getSimplePollResult(poll.id, lm.polls)\n      } yield updatedPoll\n\n    }\n\n    for {\n      user <- Users2x.findWithIntId(lm.users2x, requesterId)\n      responder = new Responder(user.intId, user.name)\n      updatedPoll <- storePollResult(responder)\n    } yield {\n      updatedPoll\n    }\n\n  }\n\n  private def pollResultToWhiteboardShape(result: SimplePollResultOutVO): scala.collection.immutable.Map[String, Object] = {\n    val shape = new scala.collection.mutable.HashMap[String, Object]()\n    shape += \"numRespondents\" -> new Integer(result.numRespondents)\n    shape += \"numResponders\" -> new Integer(result.numResponders)\n    shape += \"type\" -> WhiteboardKeyUtil.POLL_RESULT_TYPE\n    shape += \"id\" -> result.id\n    shape += \"status\" -> WhiteboardKeyUtil.DRAW_END_STATUS\n\n    val answers = new ArrayBuffer[SimpleVoteOutVO]\n    result.answers.foreach(ans => {\n      answers += SimpleVoteOutVO(ans.id, ans.key, ans.numVotes)\n    })\n\n    shape += \"result\" -> answers\n\n    // Hardcode poll result display location for now to display result\n    // in bottom-right corner.\n    val shapeHeight = 6.66 * answers.size\n    val mapA = List(66.toFloat, 100 - shapeHeight, 34.toFloat, shapeHeight)\n\n    shape += \"points\" -> mapA\n    shape.toMap\n  }\n\n  def getRunningPollThatStartsWith(pollId: String, polls: Polls): Option[PollVO] = {\n    for {\n      poll <- polls.polls.values find { poll => poll.id.startsWith(pollId) && poll.isRunning() }\n    } yield poll.toPollVO()\n\n  }\n  //\n  //  def numPolls(polls: Polls): Int = {\n  //    polls.size\n  //  }\n  //\n  //  def addPoll(poll: Poll, model: PollModel) {\n  //    model.polls += poll.id -> poll\n  //  }\n  //\n  //  def hasCurrentPoll(model: PollModel): Boolean = {\n  //    model.currentPoll != None\n  //  }\n  //\n  //  def getCurrentPoll(model: PollModel): Option[PollVO] = {\n  //    model.currentPoll\n  //  }\n\n  def getPolls(polls: Polls): Array[PollVO] = {\n    val poll = new ArrayBuffer[PollVO]\n    polls.polls.values.foreach(p => {\n      poll += p.toPollVO()\n    })\n\n    poll.toArray\n  }\n\n  //  def clearPoll(pollID: String, model: PollModel): Boolean = {\n  //    var success = false\n  //    model.polls.get(pollID) match {\n  //      case Some(p) => {\n  //        p.clear\n  //        success = true\n  //      }\n  //      case None => success = false\n  //    }\n  //\n  //    success\n  //  }\n  //\n  def startPoll(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach {\n      p =>\n        p.start()\n        polls.currentPoll = Some(p)\n    }\n  }\n  //\n  //  def removePoll(pollID: String, model: PollModel): Boolean = {\n  //    var success = false\n  //    model.polls.get(pollID) match {\n  //      case Some(p) => {\n  //        model.polls -= p.id\n  //        success = true\n  //      }\n  //      case None => success = false\n  //    }\n  //\n  //    success\n  //  }\n  //\n  def stopPoll(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach (p => p.stop())\n  }\n\n  //  def hasPoll(pollId: String, model: PollModel): Boolean = {\n  //    model.polls.get(pollId) != None\n  //  }\n  //\n  def getSimplePoll(pollId: String, polls: Polls): Option[SimplePollOutVO] = {\n    var pvo: Option[SimplePollOutVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toSimplePollOutVO()))\n    pvo\n  }\n\n  def getSimplePollResult(pollId: String, polls: Polls): Option[SimplePollResultOutVO] = {\n    var pvo: Option[SimplePollResultOutVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toSimplePollResultOutVO()))\n    pvo\n  }\n\n  def getPoll(pollId: String, polls: Polls): Option[PollVO] = {\n    var pvo: Option[PollVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toPollVO()))\n    pvo\n  }\n\n  def showPollResult(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach {\n      p =>\n        p.showResult\n        polls.currentPoll = Some(p)\n    }\n  }\n\n  def respondToQuestion(pollId: String, questionID: Int, responseID: Int, responder: Responder, polls: Polls) {\n    polls.polls.get(pollId) match {\n      case Some(p) => {\n        p.respondToQuestion(questionID, responseID, responder)\n      }\n      case None =>\n    }\n  }\n\n}\n\nobject PollType {\n  val YesNoPollType = \"YN\"\n  val TrueFalsePollType = \"TF\"\n  val CustomPollType = \"CUSTOM\"\n  val LetterPollType = \"A-\"\n  val NumberPollType = \"1-\"\n}\n\nobject PollFactory {\n\n  val LetterArray = Array(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n  val NumberArray = Array(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\")\n\n  private def processYesNoPollType(qType: String): Question = {\n    val answers = new Array[Answer](2)\n\n    answers(0) = new Answer(0, \"Yes\", Some(\"Yes\"))\n    answers(1) = new Answer(1, \"No\", Some(\"No\"))\n\n    new Question(0, PollType.YesNoPollType, false, None, answers)\n  }\n\n  private def processTrueFalsePollType(qType: String): Question = {\n    val answers = new Array[Answer](2)\n\n    answers(0) = new Answer(0, \"True\", Some(\"True\"))\n    answers(1) = new Answer(1, \"False\", Some(\"False\"))\n\n    new Question(0, PollType.TrueFalsePollType, false, None, answers)\n  }\n\n  private def processLetterPollType(qType: String, multiResponse: Boolean): Option[Question] = {\n    val q = qType.split('-')\n    val numQs = q(1).toInt\n\n    var questionOption: Option[Question] = None\n\n    if (numQs > 0 && numQs <= 6) {\n      val answers = new Array[Answer](numQs)\n\n      for (i <- 0 until numQs) {\n        answers(i) = new Answer(i, LetterArray(i), Some(LetterArray(i)))\n        val question = new Question(0, PollType.LetterPollType, multiResponse, None, answers)\n        questionOption = Some(question)\n      }\n    }\n\n    questionOption\n  }\n\n  private def processNumberPollType(qType: String, multiResponse: Boolean): Option[Question] = {\n    val q = qType.split('-')\n    val numQs = q(1).toInt\n\n    var questionOption: Option[Question] = None\n\n    if (numQs > 0 && numQs <= 6) {\n      val answers = new Array[Answer](numQs)\n      for (i <- 0 until numQs) {\n        answers(i) = new Answer(i, NumberArray(i), Some(NumberArray(i)))\n        val question = new Question(0, PollType.NumberPollType, multiResponse, None, answers)\n        questionOption = Some(question)\n      }\n    }\n    questionOption\n  }\n\n  private def buildAnswers(answers: Seq[String]): Array[Answer] = {\n    val ans = new Array[Answer](answers.length)\n    for (i <- 0 until answers.length) {\n      ans(i) = new Answer(i, answers(i), Some(answers(i)))\n    }\n\n    ans\n  }\n\n  private def processCustomPollType(qType: String, multiResponse: Boolean, answers: Option[Seq[String]]): Option[Question] = {\n    var questionOption: Option[Question] = None\n\n    answers.foreach { ans =>\n      val someAnswers = buildAnswers(ans)\n      val question = new Question(0, PollType.CustomPollType, multiResponse, None, someAnswers)\n      questionOption = Some(question)\n    }\n\n    questionOption\n  }\n\n  private def createQuestion(qType: String, answers: Option[Seq[String]]): Option[Question] = {\n\n    val qt = qType.toUpperCase()\n    var questionOption: Option[Question] = None\n\n    if (qt.matches(PollType.YesNoPollType)) {\n      questionOption = Some(processYesNoPollType(qt))\n    } else if (qt.matches(PollType.TrueFalsePollType)) {\n      questionOption = Some(processTrueFalsePollType(qt))\n    } else if (qt.matches(PollType.CustomPollType)) {\n      questionOption = processCustomPollType(qt, false, answers)\n    } else if (qt.startsWith(PollType.LetterPollType)) {\n      questionOption = processLetterPollType(qt, false)\n    } else if (qt.startsWith(PollType.NumberPollType)) {\n      questionOption = processNumberPollType(qt, false)\n    }\n\n    questionOption\n  }\n\n  def createPoll(id: String, pollType: String, numRespondents: Int, answers: Option[Seq[String]]): Option[Poll] = {\n    var poll: Option[Poll] = None\n\n    createQuestion(pollType, answers) match {\n      case Some(question) => {\n        poll = Some(new Poll(id, Array(question), numRespondents, None))\n      }\n      case None => poll = None\n    }\n\n    poll\n  }\n}\n\ncase class QuestionResponsesVO(val questionID: String, val responseIDs: Array[String])\ncase class PollResponseVO(val pollID: String, val responses: Array[QuestionResponsesVO])\ncase class ResponderVO(responseID: String, user: Responder)\n\ncase class ResponseOutVO(id: String, text: String, responders: Array[Responder] = Array[Responder]())\ncase class QuestionOutVO(id: String, multiResponse: Boolean, question: String, responses: Array[ResponseOutVO])\n\nclass Poll(val id: String, val questions: Array[Question], val numRespondents: Int, val title: Option[String]) {\n  private var _started: Boolean = false\n  private var _stopped: Boolean = false\n  private var _showResult: Boolean = false\n  private var _numResponders: Int = 0\n\n  def showingResult() { _showResult = true }\n  def showResult(): Boolean = { _showResult }\n  def start() { _started = true }\n  def stop() { _stopped = true }\n  def isStarted(): Boolean = { return _started }\n  def isStopped(): Boolean = { return _stopped }\n  def isRunning(): Boolean = { return isStarted() && !isStopped() }\n  def clear() {\n    questions.foreach(q => { q.clear })\n    _started = false\n    _stopped = false\n  }\n\n  def hasResponses(): Boolean = {\n    questions.foreach(q => {\n      if (q.hasResponders) return true\n    })\n\n    return false\n  }\n\n  def respondToQuestion(questionID: Int, responseID: Int, responder: Responder) {\n    questions.foreach(q => {\n      if (q.id == questionID) {\n        q.respondToQuestion(responseID, responder)\n        _numResponders += 1\n      }\n    })\n  }\n\n  def toPollVO(): PollVO = {\n    val qvos = new ArrayBuffer[QuestionVO]\n    questions.foreach(q => {\n      qvos += q.toQuestionVO\n    })\n\n    new PollVO(id, qvos.toArray, title, _started, _stopped, _showResult)\n  }\n\n  def toSimplePollOutVO(): SimplePollOutVO = {\n    new SimplePollOutVO(id, questions(0).toSimpleAnswerOutVO())\n  }\n\n  def toSimplePollResultOutVO(): SimplePollResultOutVO = {\n    new SimplePollResultOutVO(id, questions(0).toSimpleVotesOutVO(), numRespondents, _numResponders)\n  }\n}\n\nclass Question(val id: Int, val questionType: String, val multiResponse: Boolean, val text: Option[String], val answers: Array[Answer]) {\n\n  def clear() {\n    answers.foreach(r => r.clear)\n  }\n\n  def hasResponders(): Boolean = {\n    answers.foreach(r => {\n      if (r.numResponders > 0) return true\n    })\n\n    return false\n  }\n\n  def respondToQuestion(id: Int, responder: Responder) {\n    answers.foreach(r => {\n      if (r.id == id) r.addResponder(responder)\n    })\n  }\n\n  def toQuestionVO(): QuestionVO = {\n    val rvos = new ArrayBuffer[AnswerVO]\n    answers.foreach(answer => {\n      val r = new AnswerVO(answer.id, answer.key, answer.text, Some(answer.getResponders))\n      rvos += r\n    })\n\n    new QuestionVO(id, questionType, multiResponse, text, Some(rvos.toArray))\n  }\n\n  def toSimpleAnswerOutVO(): Array[SimpleAnswerOutVO] = {\n    val rvos = new ArrayBuffer[SimpleAnswerOutVO]\n    answers.foreach(answer => {\n      rvos += answer.toSimpleAnswerOutVO()\n    })\n\n    rvos.toArray\n  }\n\n  def toSimpleVotesOutVO(): Array[SimpleVoteOutVO] = {\n    val rvos = new ArrayBuffer[SimpleVoteOutVO]\n    answers.foreach(answer => {\n      rvos += answer.toSimpleVoteOutVO()\n    })\n\n    rvos.toArray\n  }\n}\n\nclass Answer(val id: Int, val key: String, val text: Option[String]) {\n\n  val responders = new ArrayBuffer[Responder]()\n\n  def clear() {\n    responders.clear\n  }\n  def addResponder(responder: Responder) {\n    responders += responder\n  }\n\n  def numResponders(): Int = {\n    responders.length\n  }\n\n  def getResponders(): Array[Responder] = {\n    return responders.toArray\n  }\n\n  def toSimpleAnswerOutVO(): SimpleAnswerOutVO = {\n    new SimpleAnswerOutVO(id, key)\n  }\n\n  def toSimpleVoteOutVO(): SimpleVoteOutVO = {\n    new SimpleVoteOutVO(id, key, numResponders)\n  }\n}\n\nclass Polls {\n  private val polls = new HashMap[String, Poll]()\n  private var currentPoll: Option[Poll] = None\n\n  private def save(poll: Poll): Poll = {\n    polls += poll.id -> poll\n    poll\n  }\n\n  /*\n  private def remove(id: String): Option[Poll] = {\n    val poll = polls.get(id)\n    poll foreach (p => polls -= id)\n    poll\n  }\n  */\n\n  private def get(id: String): Option[Poll] = {\n    polls.get(id)\n  }\n\n}\n", "import RedisPubSub from '/imports/startup/server/redis';\nimport { check } from 'meteor/check';\nimport Polls from '/imports/api/polls';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials } from '/imports/api/common/server/helpers';\n\nexport default function publishVote(pollId, pollAnswerId) {\n  const REDIS_CONFIG = Meteor.settings.private.redis;\n  const CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\n  const EVENT_NAME = 'RespondToPollReqMsg';\n\n  const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n  check(pollAnswerId, Number);\n  check(pollId, String);\n\n  const selector = {\n    users: requesterUserId,\n    meetingId,\n    'answers.id': pollAnswerId,\n  };\n\n  const payload = {\n    requesterId: requesterUserId,\n    pollId,\n    questionId: 0,\n    answerId: pollAnswerId,\n  };\n\n  /*\n   We keep an array of people who were in the meeting at the time the poll\n   was started. The poll is published to them only.\n   Once they vote - their ID is removed and they cannot see the poll anymore\n  */\n  const modifier = {\n    $pull: {\n      users: requesterUserId,\n    },\n  };\n\n  const cb = (err) => {\n    if (err) {\n      return Logger.error(`Removing responded user from Polls collection: ${err}`);\n    }\n\n    return Logger.info(`Removed responded user=${requesterUserId} from poll (meetingId: ${meetingId}, `\n      + `pollId: ${pollId}!)`);\n  };\n\n  Polls.update(selector, modifier, cb);\n\n  return RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n}\n", "import { makeCall } from '/imports/ui/services/api';\nimport Polls from '/imports/api/polls';\n\nconst MAX_CHAR_LENGTH = 5;\n\nconst mapPolls = () => {\n  const poll = Polls.findOne({});\n  if (!poll) {\n    return { pollExists: false };\n  }\n\n  const { answers } = poll;\n  let stackOptions = false;\n\n  answers.map((obj) => {\n    if (stackOptions) return obj;\n    if (obj.key.length > MAX_CHAR_LENGTH) {\n      stackOptions = true;\n    }\n    return obj;\n  });\n\n  const amIRequester = poll.requester !== 'userId';\n\n  return {\n    poll: {\n      answers: poll.answers,\n      pollId: poll.id,\n      stackOptions,\n    },\n    pollExists: true,\n    amIRequester,\n    handleVote(pollId, answerId) {\n      makeCall('publishVote', pollId, answerId.id);\n    },\n  };\n};\n\nexport default { mapPolls };\n"], "fixing_code": ["package org.bigbluebutton.core.models\n\nimport org.bigbluebutton.common2.domain._\nimport org.bigbluebutton.common2.msgs.AnnotationVO\nimport org.bigbluebutton.core.apps.WhiteboardKeyUtil\nimport org.bigbluebutton.core.domain.MeetingState2x\n\nimport scala.collection.mutable.ArrayBuffer\nimport scala.collection.mutable.HashMap\nimport org.bigbluebutton.core.running.LiveMeeting\n\nobject Polls {\n\n  def handleStartPollReqMsg(state: MeetingState2x, userId: String, pollId: String, pollType: String,\n                            lm: LiveMeeting): Option[SimplePollOutVO] = {\n    def createPoll(pollId: String, numRespondents: Int): Option[Poll] = {\n      for {\n        poll <- PollFactory.createPoll(pollId, pollType, numRespondents, None)\n      } yield {\n        lm.polls.save(poll)\n        poll\n      }\n    }\n\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      pageId: String = if (pollId.contains(\"deskshare\")) \"deskshare\" else page.id\n      stampedPollId: String = pageId + \"/\" + System.currentTimeMillis()\n      numRespondents: Int = Users2x.numUsers(lm.users2x) - 1 // subtract the presenter\n\n      poll <- createPoll(stampedPollId, numRespondents)\n      simplePoll <- getSimplePoll(poll.id, lm.polls)\n    } yield {\n      startPoll(simplePoll.id, lm.polls)\n      simplePoll\n    }\n  }\n\n  def handleStopPollReqMsg(state: MeetingState2x, userId: String, lm: LiveMeeting): Option[String] = {\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      curPoll <- getRunningPollThatStartsWith(page.id, lm.polls)\n    } yield {\n      stopPoll(curPoll.id, lm.polls)\n      curPoll.id\n    }\n  }\n\n  def handleShowPollResultReqMsg(state: MeetingState2x, requesterId: String, pollId: String, lm: LiveMeeting): Option[(SimplePollResultOutVO, AnnotationVO)] = {\n    def sanitizeAnnotation(annotation: AnnotationVO): AnnotationVO = {\n      // Remove null values by wrapping value with Option\n      val shape = annotation.annotationInfo.collect {\n        case (key, value: Any) => key -> Option(value)\n      }\n\n      // Unwrap the value wrapped as Option\n      val shape2 = shape.collect {\n        case (key, Some(value)) => key -> value\n      }\n\n      annotation.copy(annotationInfo = shape2)\n    }\n\n    def updateWhiteboardAnnotation(annotation: AnnotationVO): AnnotationVO = {\n      lm.wbModel.updateAnnotation(annotation.wbId, annotation.userId, annotation)\n    }\n\n    def send(poll: SimplePollResultOutVO, shape: scala.collection.immutable.Map[String, Object]): Option[AnnotationVO] = {\n      for {\n        pod <- state.presentationPodManager.getDefaultPod()\n        pres <- pod.getCurrentPresentation()\n        page <- PresentationInPod.getCurrentPage(pres)\n      } yield {\n        val pageId = if (poll.id.contains(\"deskshare\")) \"deskshare\" else page.id\n        val updatedShape = shape + (\"whiteboardId\" -> pageId)\n        val annotation = new AnnotationVO(poll.id, WhiteboardKeyUtil.DRAW_END_STATUS,\n          WhiteboardKeyUtil.POLL_RESULT_TYPE, updatedShape, pageId, requesterId, -1)\n        val sanitizedShape = sanitizeAnnotation(annotation)\n        updateWhiteboardAnnotation(sanitizedShape)\n      }\n    }\n\n    for {\n      result <- getSimplePollResult(pollId, lm.polls)\n      shape = pollResultToWhiteboardShape(result)\n      annot <- send(result, shape)\n    } yield {\n      showPollResult(pollId, lm.polls)\n      (result, annot)\n    }\n  }\n\n  def handleGetCurrentPollReqMsg(state: MeetingState2x, requesterId: String, lm: LiveMeeting): Option[PollVO] = {\n    val poll = for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      curPoll <- getRunningPollThatStartsWith(page.id, lm.polls)\n    } yield curPoll\n\n    poll match {\n      case Some(p) => {\n        if (p.started && p.stopped && p.showResult) {\n          Some(p)\n        } else {\n          None\n        }\n      }\n      case None => {\n        None\n      }\n    }\n  }\n\n  def handleRespondToPollReqMsg(requesterId: String, pollId: String, questionId: Int, answerId: Int,\n                                lm: LiveMeeting): Option[(String, SimplePollResultOutVO)] = {\n\n    for {\n      poll <- getSimplePollResult(pollId, lm.polls)\n      pvo <- handleRespondToPoll(poll, requesterId, pollId, questionId, answerId, lm)\n    } yield {\n      (pollId, pvo)\n    }\n\n  }\n\n  def handleStartCustomPollReqMsg(state: MeetingState2x, requesterId: String, pollId: String, pollType: String,\n                                  answers: Seq[String], lm: LiveMeeting): Option[SimplePollOutVO] = {\n\n    def createPoll(pollId: String, numRespondents: Int): Option[Poll] = {\n      for {\n        poll <- PollFactory.createPoll(pollId, pollType, numRespondents, Some(answers))\n      } yield {\n        lm.polls.save(poll)\n        poll\n      }\n    }\n\n    for {\n      pod <- state.presentationPodManager.getDefaultPod()\n      pres <- pod.getCurrentPresentation()\n      page <- PresentationInPod.getCurrentPage(pres)\n      pageId: String = if (pollId.contains(\"deskshare\")) \"deskshare\" else page.id\n      stampedPollId: String = pageId + \"/\" + System.currentTimeMillis()\n      numRespondents: Int = Users2x.numUsers(lm.users2x) - 1 // subtract the presenter\n      poll <- createPoll(stampedPollId, numRespondents)\n      simplePoll <- getSimplePoll(stampedPollId, lm.polls)\n    } yield {\n      startPoll(poll.id, lm.polls)\n      simplePoll\n    }\n  }\n\n  //\n  // Helper methods:\n  //\n  private def handleRespondToPoll(poll: SimplePollResultOutVO, requesterId: String, pollId: String, questionId: Int,\n                                  answerId: Int, lm: LiveMeeting): Option[SimplePollResultOutVO] = {\n    /*\n   * Hardcode to zero as we are assuming the poll has only one question.\n   * Our data model supports multiple question polls but for this\n   * release, we only have a simple poll which has one question per poll.\n   * (ralam june 23, 2015)\n   */\n    val questionId = 0\n\n    def storePollResult(responder: Responder): Option[SimplePollResultOutVO] = {\n      respondToQuestion(poll.id, questionId, answerId, responder, lm.polls)\n      for {\n        updatedPoll <- getSimplePollResult(poll.id, lm.polls)\n      } yield updatedPoll\n\n    }\n\n    for {\n      user <- Users2x.findWithIntId(lm.users2x, requesterId)\n      responder = new Responder(user.intId, user.name)\n      updatedPoll <- storePollResult(responder)\n    } yield {\n      updatedPoll\n    }\n\n  }\n\n  private def pollResultToWhiteboardShape(result: SimplePollResultOutVO): scala.collection.immutable.Map[String, Object] = {\n    val shape = new scala.collection.mutable.HashMap[String, Object]()\n    shape += \"numRespondents\" -> new Integer(result.numRespondents)\n    shape += \"numResponders\" -> new Integer(result.numResponders)\n    shape += \"type\" -> WhiteboardKeyUtil.POLL_RESULT_TYPE\n    shape += \"id\" -> result.id\n    shape += \"status\" -> WhiteboardKeyUtil.DRAW_END_STATUS\n\n    val answers = new ArrayBuffer[SimpleVoteOutVO]\n    result.answers.foreach(ans => {\n      answers += SimpleVoteOutVO(ans.id, ans.key, ans.numVotes)\n    })\n\n    shape += \"result\" -> answers\n\n    // Hardcode poll result display location for now to display result\n    // in bottom-right corner.\n    val shapeHeight = 6.66 * answers.size\n    val mapA = List(66.toFloat, 100 - shapeHeight, 34.toFloat, shapeHeight)\n\n    shape += \"points\" -> mapA\n    shape.toMap\n  }\n\n  def getRunningPollThatStartsWith(pollId: String, polls: Polls): Option[PollVO] = {\n    for {\n      poll <- polls.polls.values find { poll => poll.id.startsWith(pollId) && poll.isRunning() }\n    } yield poll.toPollVO()\n\n  }\n  //\n  //  def numPolls(polls: Polls): Int = {\n  //    polls.size\n  //  }\n  //\n  //  def addPoll(poll: Poll, model: PollModel) {\n  //    model.polls += poll.id -> poll\n  //  }\n  //\n  //  def hasCurrentPoll(model: PollModel): Boolean = {\n  //    model.currentPoll != None\n  //  }\n  //\n  //  def getCurrentPoll(model: PollModel): Option[PollVO] = {\n  //    model.currentPoll\n  //  }\n\n  def getPolls(polls: Polls): Array[PollVO] = {\n    val poll = new ArrayBuffer[PollVO]\n    polls.polls.values.foreach(p => {\n      poll += p.toPollVO()\n    })\n\n    poll.toArray\n  }\n\n  //  def clearPoll(pollID: String, model: PollModel): Boolean = {\n  //    var success = false\n  //    model.polls.get(pollID) match {\n  //      case Some(p) => {\n  //        p.clear\n  //        success = true\n  //      }\n  //      case None => success = false\n  //    }\n  //\n  //    success\n  //  }\n  //\n  def startPoll(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach {\n      p =>\n        p.start()\n        polls.currentPoll = Some(p)\n    }\n  }\n  //\n  //  def removePoll(pollID: String, model: PollModel): Boolean = {\n  //    var success = false\n  //    model.polls.get(pollID) match {\n  //      case Some(p) => {\n  //        model.polls -= p.id\n  //        success = true\n  //      }\n  //      case None => success = false\n  //    }\n  //\n  //    success\n  //  }\n  //\n  def stopPoll(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach (p => p.stop())\n  }\n\n  //  def hasPoll(pollId: String, model: PollModel): Boolean = {\n  //    model.polls.get(pollId) != None\n  //  }\n  //\n  def getSimplePoll(pollId: String, polls: Polls): Option[SimplePollOutVO] = {\n    var pvo: Option[SimplePollOutVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toSimplePollOutVO()))\n    pvo\n  }\n\n  def getSimplePollResult(pollId: String, polls: Polls): Option[SimplePollResultOutVO] = {\n    var pvo: Option[SimplePollResultOutVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toSimplePollResultOutVO()))\n    pvo\n  }\n\n  def getPoll(pollId: String, polls: Polls): Option[PollVO] = {\n    var pvo: Option[PollVO] = None\n    polls.get(pollId) foreach (p => pvo = Some(p.toPollVO()))\n    pvo\n  }\n\n  def showPollResult(pollId: String, polls: Polls) {\n    polls.get(pollId) foreach {\n      p =>\n        p.showResult\n        polls.currentPoll = Some(p)\n    }\n  }\n\n  def respondToQuestion(pollId: String, questionID: Int, responseID: Int, responder: Responder, polls: Polls) {\n    polls.polls.get(pollId) match {\n      case Some(p) => {\n        if (!p._responders.exists(_ == responder)) {\n          p.addResponder(responder)\n          p.respondToQuestion(questionID, responseID, responder)\n        }\n      }\n      case None =>\n    }\n  }\n\n}\n\nobject PollType {\n  val YesNoPollType = \"YN\"\n  val TrueFalsePollType = \"TF\"\n  val CustomPollType = \"CUSTOM\"\n  val LetterPollType = \"A-\"\n  val NumberPollType = \"1-\"\n}\n\nobject PollFactory {\n\n  val LetterArray = Array(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n  val NumberArray = Array(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\")\n\n  private def processYesNoPollType(qType: String): Question = {\n    val answers = new Array[Answer](2)\n\n    answers(0) = new Answer(0, \"Yes\", Some(\"Yes\"))\n    answers(1) = new Answer(1, \"No\", Some(\"No\"))\n\n    new Question(0, PollType.YesNoPollType, false, None, answers)\n  }\n\n  private def processTrueFalsePollType(qType: String): Question = {\n    val answers = new Array[Answer](2)\n\n    answers(0) = new Answer(0, \"True\", Some(\"True\"))\n    answers(1) = new Answer(1, \"False\", Some(\"False\"))\n\n    new Question(0, PollType.TrueFalsePollType, false, None, answers)\n  }\n\n  private def processLetterPollType(qType: String, multiResponse: Boolean): Option[Question] = {\n    val q = qType.split('-')\n    val numQs = q(1).toInt\n\n    var questionOption: Option[Question] = None\n\n    if (numQs > 0 && numQs <= 6) {\n      val answers = new Array[Answer](numQs)\n\n      for (i <- 0 until numQs) {\n        answers(i) = new Answer(i, LetterArray(i), Some(LetterArray(i)))\n        val question = new Question(0, PollType.LetterPollType, multiResponse, None, answers)\n        questionOption = Some(question)\n      }\n    }\n\n    questionOption\n  }\n\n  private def processNumberPollType(qType: String, multiResponse: Boolean): Option[Question] = {\n    val q = qType.split('-')\n    val numQs = q(1).toInt\n\n    var questionOption: Option[Question] = None\n\n    if (numQs > 0 && numQs <= 6) {\n      val answers = new Array[Answer](numQs)\n      for (i <- 0 until numQs) {\n        answers(i) = new Answer(i, NumberArray(i), Some(NumberArray(i)))\n        val question = new Question(0, PollType.NumberPollType, multiResponse, None, answers)\n        questionOption = Some(question)\n      }\n    }\n    questionOption\n  }\n\n  private def buildAnswers(answers: Seq[String]): Array[Answer] = {\n    val ans = new Array[Answer](answers.length)\n    for (i <- 0 until answers.length) {\n      ans(i) = new Answer(i, answers(i), Some(answers(i)))\n    }\n\n    ans\n  }\n\n  private def processCustomPollType(qType: String, multiResponse: Boolean, answers: Option[Seq[String]]): Option[Question] = {\n    var questionOption: Option[Question] = None\n\n    answers.foreach { ans =>\n      val someAnswers = buildAnswers(ans)\n      val question = new Question(0, PollType.CustomPollType, multiResponse, None, someAnswers)\n      questionOption = Some(question)\n    }\n\n    questionOption\n  }\n\n  private def createQuestion(qType: String, answers: Option[Seq[String]]): Option[Question] = {\n\n    val qt = qType.toUpperCase()\n    var questionOption: Option[Question] = None\n\n    if (qt.matches(PollType.YesNoPollType)) {\n      questionOption = Some(processYesNoPollType(qt))\n    } else if (qt.matches(PollType.TrueFalsePollType)) {\n      questionOption = Some(processTrueFalsePollType(qt))\n    } else if (qt.matches(PollType.CustomPollType)) {\n      questionOption = processCustomPollType(qt, false, answers)\n    } else if (qt.startsWith(PollType.LetterPollType)) {\n      questionOption = processLetterPollType(qt, false)\n    } else if (qt.startsWith(PollType.NumberPollType)) {\n      questionOption = processNumberPollType(qt, false)\n    }\n\n    questionOption\n  }\n\n  def createPoll(id: String, pollType: String, numRespondents: Int, answers: Option[Seq[String]]): Option[Poll] = {\n    var poll: Option[Poll] = None\n\n    createQuestion(pollType, answers) match {\n      case Some(question) => {\n        poll = Some(new Poll(id, Array(question), numRespondents, None))\n      }\n      case None => poll = None\n    }\n\n    poll\n  }\n}\n\ncase class QuestionResponsesVO(val questionID: String, val responseIDs: Array[String])\ncase class PollResponseVO(val pollID: String, val responses: Array[QuestionResponsesVO])\ncase class ResponderVO(responseID: String, user: Responder)\n\ncase class ResponseOutVO(id: String, text: String, responders: Array[Responder] = Array[Responder]())\ncase class QuestionOutVO(id: String, multiResponse: Boolean, question: String, responses: Array[ResponseOutVO])\n\nclass Poll(val id: String, val questions: Array[Question], val numRespondents: Int, val title: Option[String]) {\n  private var _started: Boolean = false\n  private var _stopped: Boolean = false\n  private var _showResult: Boolean = false\n  private var _numResponders: Int = 0\n  var _responders = new ArrayBuffer[Responder]()\n\n  def addResponder(responder: Responder) {\n    _responders += (responder)\n  }\n\n  def showingResult() { _showResult = true }\n  def showResult(): Boolean = { _showResult }\n  def start() { _started = true }\n  def stop() { _stopped = true }\n  def isStarted(): Boolean = { return _started }\n  def isStopped(): Boolean = { return _stopped }\n  def isRunning(): Boolean = { return isStarted() && !isStopped() }\n  def clear() {\n    questions.foreach(q => { q.clear })\n    _started = false\n    _stopped = false\n  }\n\n  def hasResponses(): Boolean = {\n    questions.foreach(q => {\n      if (q.hasResponders) return true\n    })\n\n    return false\n  }\n\n  def respondToQuestion(questionID: Int, responseID: Int, responder: Responder) {\n    questions.foreach(q => {\n      if (q.id == questionID) {\n        q.respondToQuestion(responseID, responder)\n        _numResponders += 1\n      }\n    })\n  }\n\n  def toPollVO(): PollVO = {\n    val qvos = new ArrayBuffer[QuestionVO]\n    questions.foreach(q => {\n      qvos += q.toQuestionVO\n    })\n\n    new PollVO(id, qvos.toArray, title, _started, _stopped, _showResult)\n  }\n\n  def toSimplePollOutVO(): SimplePollOutVO = {\n    new SimplePollOutVO(id, questions(0).toSimpleAnswerOutVO())\n  }\n\n  def toSimplePollResultOutVO(): SimplePollResultOutVO = {\n    new SimplePollResultOutVO(id, questions(0).toSimpleVotesOutVO(), numRespondents, _numResponders)\n  }\n}\n\nclass Question(val id: Int, val questionType: String, val multiResponse: Boolean, val text: Option[String], val answers: Array[Answer]) {\n\n  def clear() {\n    answers.foreach(r => r.clear)\n  }\n\n  def hasResponders(): Boolean = {\n    answers.foreach(r => {\n      if (r.numResponders > 0) return true\n    })\n\n    return false\n  }\n\n  def respondToQuestion(id: Int, responder: Responder) {\n    answers.foreach(r => {\n      if (r.id == id) r.addResponder(responder)\n    })\n  }\n\n  def toQuestionVO(): QuestionVO = {\n    val rvos = new ArrayBuffer[AnswerVO]\n    answers.foreach(answer => {\n      val r = new AnswerVO(answer.id, answer.key, answer.text, Some(answer.getResponders))\n      rvos += r\n    })\n\n    new QuestionVO(id, questionType, multiResponse, text, Some(rvos.toArray))\n  }\n\n  def toSimpleAnswerOutVO(): Array[SimpleAnswerOutVO] = {\n    val rvos = new ArrayBuffer[SimpleAnswerOutVO]\n    answers.foreach(answer => {\n      rvos += answer.toSimpleAnswerOutVO()\n    })\n\n    rvos.toArray\n  }\n\n  def toSimpleVotesOutVO(): Array[SimpleVoteOutVO] = {\n    val rvos = new ArrayBuffer[SimpleVoteOutVO]\n    answers.foreach(answer => {\n      rvos += answer.toSimpleVoteOutVO()\n    })\n\n    rvos.toArray\n  }\n}\n\nclass Answer(val id: Int, val key: String, val text: Option[String]) {\n\n  val responders = new ArrayBuffer[Responder]()\n\n  def clear() {\n    responders.clear\n  }\n  def addResponder(responder: Responder) {\n    responders += responder\n  }\n\n  def numResponders(): Int = {\n    responders.length\n  }\n\n  def getResponders(): Array[Responder] = {\n    return responders.toArray\n  }\n\n  def toSimpleAnswerOutVO(): SimpleAnswerOutVO = {\n    new SimpleAnswerOutVO(id, key)\n  }\n\n  def toSimpleVoteOutVO(): SimpleVoteOutVO = {\n    new SimpleVoteOutVO(id, key, numResponders)\n  }\n}\n\nclass Polls {\n  private val polls = new HashMap[String, Poll]()\n  private var currentPoll: Option[Poll] = None\n\n  private def save(poll: Poll): Poll = {\n    polls += poll.id -> poll\n    poll\n  }\n\n  /*\n  private def remove(id: String): Option[Poll] = {\n    val poll = polls.get(id)\n    poll foreach (p => polls -= id)\n    poll\n  }\n  */\n\n  private def get(id: String): Option[Poll] = {\n    polls.get(id)\n  }\n\n}\n", "import RedisPubSub from '/imports/startup/server/redis';\nimport { check } from 'meteor/check';\nimport Polls from '/imports/api/polls';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials } from '/imports/api/common/server/helpers';\n\nexport default function publishVote(pollId, pollAnswerId) {\n  const REDIS_CONFIG = Meteor.settings.private.redis;\n  const CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\n  const EVENT_NAME = 'RespondToPollReqMsg';\n  const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n  check(pollAnswerId, Number);\n  check(pollId, String);\n\n  const waitingFor = Polls.findOne({ id: pollId }, {\n    feilds: {\n      users: 1,\n    },\n  });\n\n  const userResponded = !waitingFor.users.includes(requesterUserId);\n\n  if (userResponded) return null;\n\n  const selector = {\n    users: requesterUserId,\n    meetingId,\n    'answers.id': pollAnswerId,\n  };\n\n  const payload = {\n    requesterId: requesterUserId,\n    pollId,\n    questionId: 0,\n    answerId: pollAnswerId,\n  };\n\n  /*\n   We keep an array of people who were in the meeting at the time the poll\n   was started. The poll is published to them only.\n   Once they vote - their ID is removed and they cannot see the poll anymore\n  */\n  const modifier = {\n    $pull: {\n      users: requesterUserId,\n    },\n  };\n\n  const cb = (err) => {\n    if (err) {\n      return Logger.error(`Removing responded user from Polls collection: ${err}`);\n    }\n\n    Logger.info(`Removed responded user=${requesterUserId} from poll (meetingId: ${meetingId}, `\n      + `pollId: ${pollId}!)`);\n\n    return RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n  };\n\n  Polls.update(selector, modifier, cb);\n}\n", "import { makeCall } from '/imports/ui/services/api';\nimport Polls from '/imports/api/polls';\nimport { debounce } from 'lodash';\n\nconst MAX_CHAR_LENGTH = 5;\n\nconst handleVote = (pollId, answerId) => {\n  makeCall('publishVote', pollId, answerId.id);\n};\n\nconst mapPolls = () => {\n  const poll = Polls.findOne({});\n  if (!poll) {\n    return { pollExists: false };\n  }\n\n  const { answers } = poll;\n  let stackOptions = false;\n\n  answers.map((obj) => {\n    if (stackOptions) return obj;\n    if (obj.key.length > MAX_CHAR_LENGTH) {\n      stackOptions = true;\n    }\n    return obj;\n  });\n\n  const amIRequester = poll.requester !== 'userId';\n\n  return {\n    poll: {\n      answers: poll.answers,\n      pollId: poll.id,\n      stackOptions,\n    },\n    pollExists: true,\n    amIRequester,\n    handleVote: debounce(handleVote, 500, { leading: true, trailing: false }),\n  };\n};\n\nexport default { mapPolls };\n"], "filenames": ["akka-bbb-apps/src/main/scala/org/bigbluebutton/core/models/Polls.scala", "bigbluebutton-html5/imports/api/polls/server/methods/publishVote.js", "bigbluebutton-html5/imports/ui/components/polling/service.js"], "buggy_code_start_loc": [316, 11, 2], "buggy_code_end_loc": [457, 53, 36], "fixing_code_start_loc": [316, 10, 3], "fixing_code_end_loc": [466, 61, 39], "type": "NVD-CWE-noinfo", "message": "In BigBlueButton before 2.2.29, a user can vote more than once in a single poll.", "other": {"cve": {"id": "CVE-2020-28953", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-19T22:15:13.677", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In BigBlueButton before 2.2.29, a user can vote more than once in a single poll."}, {"lang": "es", "value": "En BigBlueButton versiones anteriores a 2.2.29, un usuario puede votar m\u00e1s de una vez en una sola encuesta"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.29", "matchCriteriaId": "5FA0DCDA-3F90-4D22-A5A1-E6CD7861C2B8"}]}]}], "references": [{"url": "https://github.com/bigbluebutton/bigbluebutton/commit/d2cb02b3bd670265c6b1ba003f87fc261e0ac3e1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/compare/v2.2.28...v2.2.29", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bigbluebutton/bigbluebutton/commit/d2cb02b3bd670265c6b1ba003f87fc261e0ac3e1"}}