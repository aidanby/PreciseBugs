{"buggy_code": ["#define _POSIX_C_SOURCE 200809L\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include \"util.h\"\n\nextern const char *argv0;\n\nstatic void\nvwarn(const char *fmt, va_list ap)\n{\n\tfprintf(stderr, \"%s: \", argv0);\n\tvfprintf(stderr, fmt, ap);\n\tif (fmt[0] && fmt[strlen(fmt) - 1] == ':') {\n\t\tputc(' ', stderr);\n\t\tperror(NULL);\n\t} else {\n\t\tputc('\\n', stderr);\n\t}\n}\n\nvoid\nwarn(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvwarn(fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nfatal(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvwarn(fmt, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nvoid *\nxmalloc(size_t n)\n{\n\tvoid *p;\n\n\tp = malloc(n);\n\tif (!p)\n\t\tfatal(\"malloc:\");\n\n\treturn p;\n}\n\nstatic void *\nreallocarray(void *p, size_t n, size_t m)\n{\n\tif (m && n > SIZE_MAX / m) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn realloc(p, n * m);\n}\n\nvoid *\nxreallocarray(void *p, size_t n, size_t m)\n{\n\tp = reallocarray(p, n, m);\n\tif (!p)\n\t\tfatal(\"reallocarray:\");\n\n\treturn p;\n}\n\nchar *\nxmemdup(const char *s, size_t n)\n{\n\tchar *p;\n\n\tp = xmalloc(n);\n\tmemcpy(p, s, n);\n\n\treturn p;\n}\n\nint\nxasprintf(char **s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tsize_t n;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(NULL, 0, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0)\n\t\tfatal(\"vsnprintf:\");\n\tn = ret + 1;\n\t*s = xmalloc(n);\n\tva_start(ap, fmt);\n\tret = vsnprintf(*s, n, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || (size_t)ret >= n)\n\t\tfatal(\"vsnprintf:\");\n\n\treturn ret;\n}\n\nvoid\nbufadd(struct buffer *buf, char c)\n{\n\tif (buf->len >= buf->cap) {\n\t\tbuf->cap = buf->cap ? buf->cap * 2 : 1 << 8;\n\t\tbuf->data = realloc(buf->data, buf->cap);\n\t\tif (!buf->data)\n\t\t\tfatal(\"realloc:\");\n\t}\n\tbuf->data[buf->len++] = c;\n}\n\nstruct string *\nmkstr(size_t n)\n{\n\tstruct string *str;\n\n\tstr = xmalloc(sizeof(*str) + n + 1);\n\tstr->n = n;\n\n\treturn str;\n}\n\nvoid\ndelevalstr(void *ptr)\n{\n\tstruct evalstring *str = ptr;\n\tstruct evalstringpart *p, *next;\n\n\tif (!str)\n\t\treturn;\n\tfor (p = str->parts; p; p = next) {\n\t\tnext = p->next;\n\t\tif (p->var)\n\t\t\tfree(p->var);\n\t\telse\n\t\t\tfree(p->str);\n\t\tfree(p);\n\t}\n\tfree(str);\n}\n\nvoid\ncanonpath(struct string *path)\n{\n\tchar *component[60];\n\tint n;\n\tchar *s, *d, *end;\n\n\tif (path->n == 0)\n\t\tfatal(\"empty path\");\n\ts = d = path->s;\n\tend = path->s + path->n;\n\tn = 0;\n\tif (*s == '/') {\n\t\t++s;\n\t\t++d;\n\t}\n\twhile (s < end) {\n\t\tswitch (s[0]) {\n\t\tcase '/':\n\t\t\t++s;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tswitch (s[1]) {\n\t\t\tcase '\\0': case '/':\n\t\t\t\ts += 2;\n\t\t\t\tcontinue;\n\t\t\tcase '.':\n\t\t\t\tif (s[2] != '/' && s[2] != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t\tif (n > 0) {\n\t\t\t\t\td = component[--n];\n\t\t\t\t} else {\n\t\t\t\t\t*d++ = s[0];\n\t\t\t\t\t*d++ = s[1];\n\t\t\t\t\t*d++ = s[2];\n\t\t\t\t}\n\t\t\t\ts += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == LEN(component))\n\t\t\tfatal(\"path has too many components: %s\", path->s);\n\t\tcomponent[n++] = d;\n\t\twhile (*s != '/' && *s != '\\0')\n\t\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t}\n\tif (d == path->s) {\n\t\t*d++ = '.';\n\t\t*d = '\\0';\n\t} else {\n\t\t*--d = '\\0';\n\t}\n\tpath->n = d - path->s;\n}\n\nint\nmakedirs(struct string *path, bool parent)\n{\n\tint ret;\n\tstruct stat st;\n\tchar *s, *end;\n\n\tret = 0;\n\tend = path->s + path->n;\n\tfor (s = end - parent; s > path->s; --s) {\n\t\tif (*s != '/' && *s)\n\t\t\tcontinue;\n\t\t*s = '\\0';\n\t\tif (stat(path->s, &st) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOENT) {\n\t\t\twarn(\"stat %s:\", path->s);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (s > path->s && s < end)\n\t\t*s = '/';\n\twhile (++s <= end - parent) {\n\t\tif (*s != '\\0')\n\t\t\tcontinue;\n\t\tif (ret == 0 && mkdir(path->s, 0777) < 0 && errno != EEXIST) {\n\t\t\twarn(\"mkdir %s:\", path->s);\n\t\t\tret = -1;\n\t\t}\n\t\tif (s < end)\n\t\t\t*s = '/';\n\t}\n\n\treturn ret;\n}\n\nint\nwritefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}\n"], "fixing_code": ["#define _POSIX_C_SOURCE 200809L\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include \"util.h\"\n\nextern const char *argv0;\n\nstatic void\nvwarn(const char *fmt, va_list ap)\n{\n\tfprintf(stderr, \"%s: \", argv0);\n\tvfprintf(stderr, fmt, ap);\n\tif (fmt[0] && fmt[strlen(fmt) - 1] == ':') {\n\t\tputc(' ', stderr);\n\t\tperror(NULL);\n\t} else {\n\t\tputc('\\n', stderr);\n\t}\n}\n\nvoid\nwarn(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvwarn(fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nfatal(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvwarn(fmt, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nvoid *\nxmalloc(size_t n)\n{\n\tvoid *p;\n\n\tp = malloc(n);\n\tif (!p)\n\t\tfatal(\"malloc:\");\n\n\treturn p;\n}\n\nstatic void *\nreallocarray(void *p, size_t n, size_t m)\n{\n\tif (m && n > SIZE_MAX / m) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn realloc(p, n * m);\n}\n\nvoid *\nxreallocarray(void *p, size_t n, size_t m)\n{\n\tp = reallocarray(p, n, m);\n\tif (!p)\n\t\tfatal(\"reallocarray:\");\n\n\treturn p;\n}\n\nchar *\nxmemdup(const char *s, size_t n)\n{\n\tchar *p;\n\n\tp = xmalloc(n);\n\tmemcpy(p, s, n);\n\n\treturn p;\n}\n\nint\nxasprintf(char **s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tsize_t n;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(NULL, 0, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0)\n\t\tfatal(\"vsnprintf:\");\n\tn = ret + 1;\n\t*s = xmalloc(n);\n\tva_start(ap, fmt);\n\tret = vsnprintf(*s, n, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || (size_t)ret >= n)\n\t\tfatal(\"vsnprintf:\");\n\n\treturn ret;\n}\n\nvoid\nbufadd(struct buffer *buf, char c)\n{\n\tif (buf->len >= buf->cap) {\n\t\tbuf->cap = buf->cap ? buf->cap * 2 : 1 << 8;\n\t\tbuf->data = realloc(buf->data, buf->cap);\n\t\tif (!buf->data)\n\t\t\tfatal(\"realloc:\");\n\t}\n\tbuf->data[buf->len++] = c;\n}\n\nstruct string *\nmkstr(size_t n)\n{\n\tstruct string *str;\n\n\tstr = xmalloc(sizeof(*str) + n + 1);\n\tstr->n = n;\n\n\treturn str;\n}\n\nvoid\ndelevalstr(void *ptr)\n{\n\tstruct evalstring *str = ptr;\n\tstruct evalstringpart *p, *next;\n\n\tif (!str)\n\t\treturn;\n\tfor (p = str->parts; p; p = next) {\n\t\tnext = p->next;\n\t\tif (p->var)\n\t\t\tfree(p->var);\n\t\telse\n\t\t\tfree(p->str);\n\t\tfree(p);\n\t}\n\tfree(str);\n}\n\nvoid\ncanonpath(struct string *path)\n{\n\tchar *component[60];\n\tint n;\n\tchar *s, *d, *end;\n\n\tif (path->n == 0)\n\t\tfatal(\"empty path\");\n\ts = d = path->s;\n\tend = path->s + path->n;\n\tn = 0;\n\tif (*s == '/') {\n\t\t++s;\n\t\t++d;\n\t}\n\twhile (s < end) {\n\t\tswitch (s[0]) {\n\t\tcase '/':\n\t\t\t++s;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tswitch (s[1]) {\n\t\t\tcase '\\0': case '/':\n\t\t\t\ts += 2;\n\t\t\t\tcontinue;\n\t\t\tcase '.':\n\t\t\t\tif (s[2] != '/' && s[2] != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t\tif (n > 0) {\n\t\t\t\t\td = component[--n];\n\t\t\t\t} else {\n\t\t\t\t\t*d++ = s[0];\n\t\t\t\t\t*d++ = s[1];\n\t\t\t\t\t*d++ = s[2];\n\t\t\t\t}\n\t\t\t\ts += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == LEN(component))\n\t\t\tfatal(\"path has too many components: %s\", path->s);\n\t\tcomponent[n++] = d;\n\t\twhile (*s != '/' && *s != '\\0')\n\t\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t}\n\tif (d == path->s) {\n\t\t*d++ = '.';\n\t\t*d = '\\0';\n\t} else {\n\t\t*--d = '\\0';\n\t}\n\tpath->n = d - path->s;\n}\n\nint\nmakedirs(struct string *path, bool parent)\n{\n\tint ret;\n\tstruct stat st;\n\tchar *s, *end;\n\n\tret = 0;\n\tend = path->s + path->n;\n\tfor (s = end - parent; s > path->s; --s) {\n\t\tif (*s != '/' && *s)\n\t\t\tcontinue;\n\t\t*s = '\\0';\n\t\tif (stat(path->s, &st) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOENT) {\n\t\t\twarn(\"stat %s:\", path->s);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (s > path->s && s < end)\n\t\t*s = '/';\n\twhile (++s <= end - parent) {\n\t\tif (*s != '\\0')\n\t\t\tcontinue;\n\t\tif (ret == 0 && mkdir(path->s, 0777) < 0 && errno != EEXIST) {\n\t\t\twarn(\"mkdir %s:\", path->s);\n\t\t\tret = -1;\n\t\t}\n\t\tif (s < end)\n\t\t\t*s = '/';\n\t}\n\n\treturn ret;\n}\n\nint\nwritefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}\n"], "filenames": ["util.c"], "buggy_code_start_loc": [261], "buggy_code_end_loc": [262], "fixing_code_start_loc": [261], "fixing_code_end_loc": [262], "type": "CWE-476", "message": "samurai 1.2 has a NULL pointer dereference in writefile() in util.c via a crafted build file.", "other": {"cve": {"id": "CVE-2021-30218", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-29T15:15:11.050", "lastModified": "2021-05-03T18:02:21.927", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "samurai 1.2 has a NULL pointer dereference in writefile() in util.c via a crafted build file."}, {"lang": "es", "value": "samurai versi\u00f3n 1.2, presenta una desreferencia del puntero NULL en la funci\u00f3n writefile() en el archivo util.c por medio de un archivo de compilaci\u00f3n dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samurai_project:samurai:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "6EAE8155-445A-4338-A9C0-A6BB5928821D"}]}]}], "references": [{"url": "https://github.com/michaelforney/samurai/commit/e84b6d99c85043fa1ba54851ee500540ec206918", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelforney/samurai/issues/67", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelforney/samurai/commit/e84b6d99c85043fa1ba54851ee500540ec206918"}}