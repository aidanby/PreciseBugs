{"buggy_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sps.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"decctx.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define READ_VLC_OFFSET(variable, vlctype, offset)   \\\n  if ((vlc = get_ ## vlctype(br)) == UVLC_ERROR) {   \\\n    errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);  \\\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; \\\n  } \\\n  variable = vlc + offset;\n\n#define READ_VLC(variable, vlctype)  READ_VLC_OFFSET(variable,vlctype,0)\n\n\nstatic int SubWidthC_tab[]  = { 1,2,2,1 };\nstatic int SubHeightC_tab[] = { 1,2,1,1 };\n\n\n// TODO if (!check_high(ctx, vlc, 15)) return false;\n// TODO if (!check_ulvc(ctx, vlc)) return false;\n\n\n// TODO: should be in some header-file of refpic.c\nextern bool read_short_term_ref_pic_set(error_queue* errqueue,\n                                        const seq_parameter_set* sps,\n                                        bitreader* br,\n                                        ref_pic_set* out_set,\n                                        int idxRps,  // index of the set to be read\n                                        const std::vector<ref_pic_set>& sets,\n                                        bool sliceRefPicSet);\n\nextern bool write_short_term_ref_pic_set(error_queue* errqueue,\n                                         const seq_parameter_set* sps,\n                                         CABAC_encoder& out,\n                                         const ref_pic_set* in_set, // which set to write\n                                         int idxRps,  // index of the set to be read\n                                         const std::vector<ref_pic_set>& sets, // previously read sets\n                                         bool sliceRefPicSet); // is this in the slice header?\n\n\nsps_range_extension::sps_range_extension()\n{\n  transform_skip_rotation_enabled_flag = 0;\n  transform_skip_context_enabled_flag  = 0;\n  implicit_rdpcm_enabled_flag = 0;\n  explicit_rdpcm_enabled_flag = 0;\n  extended_precision_processing_flag = 0;\n  intra_smoothing_disabled_flag = 0;\n  high_precision_offsets_enabled_flag = 0;\n  persistent_rice_adaptation_enabled_flag = 0;\n  cabac_bypass_alignment_enabled_flag = 0;\n}\n\n\nseq_parameter_set::seq_parameter_set()\n{\n  // TODO: this is dangerous\n  //memset(this,0,sizeof(seq_parameter_set));\n\n  sps_read = false;\n  //ref_pic_sets = NULL;\n}\n\n\nseq_parameter_set::~seq_parameter_set()\n{\n  //free(ref_pic_sets);\n}\n\n\nvoid seq_parameter_set::set_defaults(enum PresetSet)\n{\n  video_parameter_set_id = 0;\n  sps_max_sub_layers = 1;\n  sps_temporal_id_nesting_flag = 1;\n\n  profile_tier_level_.general.set_defaults(Profile_Main, 6,2); // TODO\n\n  seq_parameter_set_id = 0;\n  chroma_format_idc = 1;\n  ChromaArrayType = chroma_format_idc;\n\n  separate_colour_plane_flag = 0;\n  pic_width_in_luma_samples = 0;\n  pic_height_in_luma_samples = 0;\n  conformance_window_flag = 0;\n\n  conf_win_left_offset   = 0;\n  conf_win_right_offset  = 0;\n  conf_win_top_offset    = 0;\n  conf_win_bottom_offset = 0;\n\n  bit_depth_luma  =8;\n  bit_depth_chroma=8;\n\n  log2_max_pic_order_cnt_lsb = 8;\n  sps_sub_layer_ordering_info_present_flag = 0;\n\n  sps_max_dec_pic_buffering[0] = 1;\n  sps_max_num_reorder_pics[0]  = 0;\n  sps_max_latency_increase_plus1[0] = 0;\n\n  set_CB_log2size_range(4,4);\n  set_TB_log2size_range(3,4);\n  max_transform_hierarchy_depth_inter = 1;\n  max_transform_hierarchy_depth_intra = 1;\n\n  scaling_list_enable_flag = 0;\n  sps_scaling_list_data_present_flag = 0;\n\n  // TODO struct scaling_list_data scaling_list;\n\n  amp_enabled_flag = 0;\n  sample_adaptive_offset_enabled_flag = 0;\n  pcm_enabled_flag = 0;\n\n  pcm_sample_bit_depth_luma = 8;\n  pcm_sample_bit_depth_chroma = 8;\n  // TODO log2_min_pcm_luma_coding_block_size;\n  // TODO log2_diff_max_min_pcm_luma_coding_block_size;\n  pcm_loop_filter_disable_flag = 1;\n\n  // num_short_term_ref_pic_sets = 0;\n  // std::vector<ref_pic_set> ref_pic_sets; // [0 ; num_short_term_ref_pic_set (<=MAX_REF_PIC_SETS) )\n  ref_pic_sets.clear();\n\n  long_term_ref_pics_present_flag = 0;\n\n  num_long_term_ref_pics_sps = 0;\n\n  /* TODO\n  int  lt_ref_pic_poc_lsb_sps[MAX_NUM_LT_REF_PICS_SPS];\n  char used_by_curr_pic_lt_sps_flag[MAX_NUM_LT_REF_PICS_SPS];\n  */\n\n  sps_temporal_mvp_enabled_flag = 0;\n  strong_intra_smoothing_enable_flag = 0;\n  vui_parameters_present_flag = 0;\n\n  /*\n    if( vui_parameters_present_flag )\n      vui_parameters()\n  */\n\n  sps_extension_present_flag = 0;\n  sps_range_extension_flag = 0;\n  sps_multilayer_extension_flag = 0;\n  sps_extension_6bits = 0;\n}\n\n\nvoid seq_parameter_set::set_CB_log2size_range(int mini,int maxi)\n{\n  log2_min_luma_coding_block_size = mini;\n  log2_diff_max_min_luma_coding_block_size = maxi-mini;\n}\n\n\nvoid seq_parameter_set::set_TB_log2size_range(int mini,int maxi)\n{\n  log2_min_transform_block_size = mini;\n  log2_diff_max_min_transform_block_size = maxi-mini;\n}\n\n\nvoid seq_parameter_set::set_resolution(int w,int h)\n{\n  pic_width_in_luma_samples  = w;\n  pic_height_in_luma_samples = h;\n}\n\n\nde265_error seq_parameter_set::read(error_queue* errqueue, bitreader* br)\n{\n  int vlc;\n\n  video_parameter_set_id = get_bits(br,4);\n  sps_max_sub_layers     = get_bits(br,3) +1;\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  sps_temporal_id_nesting_flag = get_bits(br,1);\n\n  profile_tier_level_.read(br, sps_max_sub_layers);\n\n  READ_VLC(seq_parameter_set_id, uvlc);\n  if (seq_parameter_set_id >= DE265_MAX_SPS_SETS) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- decode chroma type ---\n\n  READ_VLC(chroma_format_idc, uvlc);\n\n  if (chroma_format_idc == 3) {\n    separate_colour_plane_flag = get_bits(br,1);\n  }\n  else {\n    separate_colour_plane_flag = 0;\n  }\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- picture size ---\n\n  READ_VLC(pic_width_in_luma_samples,  uvlc);\n  READ_VLC(pic_height_in_luma_samples, uvlc);\n\n  if (pic_width_in_luma_samples  == 0 ||\n      pic_height_in_luma_samples == 0) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (pic_width_in_luma_samples > MAX_PICTURE_WIDTH ||\n      pic_height_in_luma_samples> MAX_PICTURE_HEIGHT) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  conformance_window_flag = get_bits(br,1);\n\n  if (conformance_window_flag) {\n    READ_VLC(conf_win_left_offset,  uvlc);\n    READ_VLC(conf_win_right_offset, uvlc);\n    READ_VLC(conf_win_top_offset,   uvlc);\n    READ_VLC(conf_win_bottom_offset,uvlc);\n  }\n  else {\n    conf_win_left_offset  = 0;\n    conf_win_right_offset = 0;\n    conf_win_top_offset   = 0;\n    conf_win_bottom_offset= 0;\n  }\n\n  READ_VLC_OFFSET(bit_depth_luma,  uvlc, 8);\n  READ_VLC_OFFSET(bit_depth_chroma,uvlc, 8);\n  if (bit_depth_luma > 16 ||\n      bit_depth_chroma > 16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  READ_VLC_OFFSET(log2_max_pic_order_cnt_lsb, uvlc, 4);\n  if (log2_max_pic_order_cnt_lsb<4 ||\n      log2_max_pic_order_cnt_lsb>16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  MaxPicOrderCntLsb = 1<<(log2_max_pic_order_cnt_lsb);\n\n\n  // --- sub_layer_ordering_info ---\n\n  sps_sub_layer_ordering_info_present_flag = get_bits(br,1);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    vlc=get_uvlc(br);\n    if (vlc == UVLC_ERROR ||\n        vlc+1 > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    sps_max_dec_pic_buffering[i] = vlc+1;\n\n    // sps_max_num_reorder_pics[i]\n\n    READ_VLC(sps_max_num_reorder_pics[i], uvlc);\n\n\n    // sps_max_latency_increase[i]\n\n    READ_VLC(sps_max_latency_increase_plus1[i], uvlc);\n\n    SpsMaxLatencyPictures[i] = (sps_max_num_reorder_pics[i] +\n                                sps_max_latency_increase_plus1[i]-1);\n  }\n\n  // copy info to all layers if only specified once\n\n  if (sps_sub_layer_ordering_info_present_flag) {\n    int ref = sps_max_sub_layers-1;\n    assert(ref<7);\n\n    for (int i=0 ; i < sps_max_sub_layers-1; i++ ) {\n      sps_max_dec_pic_buffering[i] = sps_max_dec_pic_buffering[ref];\n      sps_max_num_reorder_pics[i]  = sps_max_num_reorder_pics[ref];\n      sps_max_latency_increase_plus1[i]  = sps_max_latency_increase_plus1[ref];\n    }\n  }\n\n\n  READ_VLC_OFFSET(log2_min_luma_coding_block_size, uvlc, 3);\n  READ_VLC       (log2_diff_max_min_luma_coding_block_size, uvlc);\n  READ_VLC_OFFSET(log2_min_transform_block_size, uvlc, 2);\n  READ_VLC(log2_diff_max_min_transform_block_size, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_inter, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_intra, uvlc);\n\n  if (log2_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size + log2_diff_max_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n  scaling_list_enable_flag = get_bits(br,1);\n\n  if (scaling_list_enable_flag) {\n\n    sps_scaling_list_data_present_flag = get_bits(br,1);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=read_scaling_list(br,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n    else {\n      set_default_scaling_lists(&scaling_list);\n    }\n  }\n\n  amp_enabled_flag = get_bits(br,1);\n  sample_adaptive_offset_enabled_flag = get_bits(br,1);\n  pcm_enabled_flag = get_bits(br,1);\n  if (pcm_enabled_flag) {\n    pcm_sample_bit_depth_luma = get_bits(br,4)+1;\n    pcm_sample_bit_depth_chroma = get_bits(br,4)+1;\n    READ_VLC_OFFSET(log2_min_pcm_luma_coding_block_size, uvlc, 3);\n    READ_VLC(log2_diff_max_min_pcm_luma_coding_block_size, uvlc);\n    pcm_loop_filter_disable_flag = get_bits(br,1);\n\n    if (pcm_sample_bit_depth_luma > bit_depth_luma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pcm_sample_bit_depth_chroma > bit_depth_chroma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n  else {\n    pcm_sample_bit_depth_luma = 0;\n    pcm_sample_bit_depth_chroma = 0;\n    log2_min_pcm_luma_coding_block_size = 0;\n    log2_diff_max_min_pcm_luma_coding_block_size = 0;\n    pcm_loop_filter_disable_flag = 0;\n  }\n\n  int num_short_term_ref_pic_sets;\n  READ_VLC(num_short_term_ref_pic_sets, uvlc);\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  ref_pic_sets.resize(num_short_term_ref_pic_sets);\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = read_short_term_ref_pic_set(errqueue,this,br,\n                                               &ref_pic_sets[i], i,\n                                               ref_pic_sets,\n                                               false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  long_term_ref_pics_present_flag = get_bits(br,1);\n\n  if (long_term_ref_pics_present_flag) {\n\n    READ_VLC(num_long_term_ref_pics_sps, uvlc);\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      lt_ref_pic_poc_lsb_sps[i] = get_bits(br, log2_max_pic_order_cnt_lsb);\n      used_by_curr_pic_lt_sps_flag[i] = get_bits(br,1);\n    }\n  }\n  else {\n    num_long_term_ref_pics_sps = 0; // NOTE: missing definition in standard !\n  }\n\n  sps_temporal_mvp_enabled_flag = get_bits(br,1);\n  strong_intra_smoothing_enable_flag = get_bits(br,1);\n\n  vui_parameters_present_flag = get_bits(br,1);\n  if (vui_parameters_present_flag) {\n    vui.read(errqueue, br, this);\n  }\n\n\n  sps_extension_present_flag = get_bits(br,1);\n  if (sps_extension_present_flag) {\n    sps_range_extension_flag = get_bits(br,1);\n    sps_multilayer_extension_flag = get_bits(br,1);\n    sps_extension_6bits = get_bits(br,6);\n  }\n  else {\n    sps_range_extension_flag = 0;\n  }\n\n  if (sps_range_extension_flag) {\n    de265_error err = range_extension.read(errqueue, br);\n    if (err != DE265_OK) { return err; }\n  }\n\n  /*\n  sps_extension_flag = get_bits(br,1);\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  */\n\n\n  de265_error err = compute_derived_values();\n  if (err != DE265_OK) { return err; }\n\n  sps_read = true;\n\n  return DE265_OK;\n}\n\n\nde265_error seq_parameter_set::compute_derived_values(bool sanitize_values)\n{\n  // --- compute derived values ---\n\n  SubWidthC  = SubWidthC_tab [chroma_format_idc];\n  SubHeightC = SubHeightC_tab[chroma_format_idc];\n\n  if (separate_colour_plane_flag) {\n    ChromaArrayType = 0;\n  }\n  else {\n    ChromaArrayType = chroma_format_idc;\n  }\n\n  if (ChromaArrayType==0) {\n    WinUnitX = 1;\n    WinUnitY = 1;\n  }\n  else {\n    WinUnitX = SubWidthC_tab [chroma_format_idc];\n    WinUnitY = SubHeightC_tab[chroma_format_idc];\n  }\n\n\n\n  BitDepth_Y   = bit_depth_luma;\n  QpBdOffset_Y = 6*(bit_depth_luma-8);\n  BitDepth_C   = bit_depth_chroma;\n  QpBdOffset_C = 6*(bit_depth_chroma-8);\n\n  Log2MinCbSizeY = log2_min_luma_coding_block_size;\n  Log2CtbSizeY = Log2MinCbSizeY + log2_diff_max_min_luma_coding_block_size;\n  MinCbSizeY = 1 << Log2MinCbSizeY;\n  CtbSizeY = 1 << Log2CtbSizeY;\n\n  PicWidthInMinCbsY = ceil_div(pic_width_in_luma_samples, MinCbSizeY);\n  PicWidthInCtbsY   = ceil_div(pic_width_in_luma_samples, CtbSizeY);\n  PicHeightInMinCbsY = ceil_div(pic_height_in_luma_samples, MinCbSizeY);\n  PicHeightInCtbsY   = ceil_div(pic_height_in_luma_samples,CtbSizeY);\n  PicSizeInMinCbsY   = PicWidthInMinCbsY * PicHeightInMinCbsY;\n  PicSizeInCtbsY = PicWidthInCtbsY * PicHeightInCtbsY;\n  PicSizeInSamplesY = pic_width_in_luma_samples * pic_height_in_luma_samples;\n\n  if (chroma_format_idc==0 || separate_colour_plane_flag) {\n    CtbWidthC  = 0;\n    CtbHeightC = 0;\n  }\n  else {\n    CtbWidthC  = CtbSizeY / SubWidthC;\n    CtbHeightC = CtbSizeY / SubHeightC;\n  }\n\n  Log2MinTrafoSize = log2_min_transform_block_size;\n  Log2MaxTrafoSize = log2_min_transform_block_size + log2_diff_max_min_transform_block_size;\n\n  if (max_transform_hierarchy_depth_inter > Log2CtbSizeY - Log2MinTrafoSize) {\n    if (sanitize_values) {\n      max_transform_hierarchy_depth_inter = Log2CtbSizeY - Log2MinTrafoSize;\n    } else {\n      fprintf(stderr,\"SPS error: transform hierarchy depth (inter) > CTB size - min TB size\\n\");\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n\n  if (max_transform_hierarchy_depth_intra > Log2CtbSizeY - Log2MinTrafoSize) {\n    if (sanitize_values) {\n      max_transform_hierarchy_depth_intra = Log2CtbSizeY - Log2MinTrafoSize;\n    } else {\n      fprintf(stderr,\"SPS error: transform hierarchy depth (intra) > CTB size - min TB size\\n\");\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n\n\n  if (sanitize_values) {\n    if (max_transform_hierarchy_depth_inter < Log2CtbSizeY - Log2MaxTrafoSize) {\n      max_transform_hierarchy_depth_inter = Log2CtbSizeY - Log2MaxTrafoSize;\n    }\n\n    if (max_transform_hierarchy_depth_intra < Log2CtbSizeY - Log2MaxTrafoSize) {\n      max_transform_hierarchy_depth_intra = Log2CtbSizeY - Log2MaxTrafoSize;\n    }\n  }\n\n\n  Log2MinPUSize = Log2MinCbSizeY-1;\n  PicWidthInMinPUs  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinPUSize);\n  PicHeightInMinPUs = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinPUSize);\n\n  Log2MinIpcmCbSizeY = log2_min_pcm_luma_coding_block_size;\n  Log2MaxIpcmCbSizeY = (log2_min_pcm_luma_coding_block_size +\n                        log2_diff_max_min_pcm_luma_coding_block_size);\n\n  // the following are not in the standard\n  PicWidthInTbsY  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicHeightInTbsY = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicSizeInTbsY = PicWidthInTbsY * PicHeightInTbsY;\n\n\n  if (range_extension.high_precision_offsets_enabled_flag) {\n    WpOffsetBdShiftY = 0;\n    WpOffsetBdShiftC = 0;\n    WpOffsetHalfRangeY = 1 << (BitDepth_Y - 1);\n    WpOffsetHalfRangeC = 1 << (BitDepth_C - 1);\n  }\n  else {\n    WpOffsetBdShiftY = ( BitDepth_Y - 8 );\n    WpOffsetBdShiftC = ( BitDepth_C - 8 );\n    WpOffsetHalfRangeY = 1 << 7;\n    WpOffsetHalfRangeC = 1 << 7;\n  }\n\n\n  // --- check SPS sanity ---\n\n  if (pic_width_in_luma_samples  % MinCbSizeY != 0 ||\n      pic_height_in_luma_samples % MinCbSizeY != 0) {\n    // TODO: warn that image size is coded wrong in bitstream (must be multiple of MinCbSizeY)\n    fprintf(stderr,\"SPS error: CB alignment\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (Log2MinTrafoSize > Log2MinCbSizeY) {\n    fprintf(stderr,\"SPS error: TB > CB\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (Log2MaxTrafoSize > libde265_min(Log2CtbSizeY,5)) {\n    fprintf(stderr,\"SPS error: TB_max > 32 or CTB\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  if (BitDepth_Y < 8 || BitDepth_Y > 16) {\n    fprintf(stderr,\"SPS error: bitdepth Y not in [8;16]\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (BitDepth_C < 8 || BitDepth_C > 16) {\n    fprintf(stderr,\"SPS error: bitdepth C not in [8;16]\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  sps_read = true;\n\n  return DE265_OK;\n}\n\n\n\nvoid seq_parameter_set::dump(int fd) const\n{\n  //#if (_MSC_VER >= 1500)\n  //#define LOG0(t) loginfo(LogHeaders, t)\n  //#define LOG1(t,d) loginfo(LogHeaders, t,d)\n  //#define LOG2(t,d1,d2) loginfo(LogHeaders, t,d1,d2)\n  //#define LOG3(t,d1,d2,d3) loginfo(LogHeaders, t,d1,d2,d3)\n\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n\n\n  LOG0(\"----------------- SPS -----------------\\n\");\n  LOG1(\"video_parameter_set_id  : %d\\n\", video_parameter_set_id);\n  LOG1(\"sps_max_sub_layers      : %d\\n\", sps_max_sub_layers);\n  LOG1(\"sps_temporal_id_nesting_flag : %d\\n\", sps_temporal_id_nesting_flag);\n\n  profile_tier_level_.dump(sps_max_sub_layers, fh);\n\n  LOG1(\"seq_parameter_set_id    : %d\\n\", seq_parameter_set_id);\n  LOG2(\"chroma_format_idc       : %d (%s)\\n\", chroma_format_idc,\n       chroma_format_idc == 0 ? \"monochrome\" :\n       chroma_format_idc == 1 ? \"4:2:0\" :\n       chroma_format_idc == 2 ? \"4:2:2\" :\n       chroma_format_idc == 3 ? \"4:4:4\" : \"unknown\");\n\n  if (chroma_format_idc == 3) {\n    LOG1(\"separate_colour_plane_flag : %d\\n\", separate_colour_plane_flag);\n  }\n\n  LOG1(\"pic_width_in_luma_samples  : %d\\n\", pic_width_in_luma_samples);\n  LOG1(\"pic_height_in_luma_samples : %d\\n\", pic_height_in_luma_samples);\n  LOG1(\"conformance_window_flag    : %d\\n\", conformance_window_flag);\n\n  if (conformance_window_flag) {\n    LOG1(\"conf_win_left_offset  : %d\\n\", conf_win_left_offset);\n    LOG1(\"conf_win_right_offset : %d\\n\", conf_win_right_offset);\n    LOG1(\"conf_win_top_offset   : %d\\n\", conf_win_top_offset);\n    LOG1(\"conf_win_bottom_offset: %d\\n\", conf_win_bottom_offset);\n  }\n\n  LOG1(\"bit_depth_luma   : %d\\n\", bit_depth_luma);\n  LOG1(\"bit_depth_chroma : %d\\n\", bit_depth_chroma);\n\n  LOG1(\"log2_max_pic_order_cnt_lsb : %d\\n\", log2_max_pic_order_cnt_lsb);\n  LOG1(\"sps_sub_layer_ordering_info_present_flag : %d\\n\", sps_sub_layer_ordering_info_present_flag);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n    LOG1(\"Layer %d\\n\",i);\n    LOG1(\"  sps_max_dec_pic_buffering      : %d\\n\", sps_max_dec_pic_buffering[i]);\n    LOG1(\"  sps_max_num_reorder_pics       : %d\\n\", sps_max_num_reorder_pics[i]);\n    LOG1(\"  sps_max_latency_increase_plus1 : %d\\n\", sps_max_latency_increase_plus1[i]);\n  }\n\n  LOG1(\"log2_min_luma_coding_block_size : %d\\n\", log2_min_luma_coding_block_size);\n  LOG1(\"log2_diff_max_min_luma_coding_block_size : %d\\n\",log2_diff_max_min_luma_coding_block_size);\n  LOG1(\"log2_min_transform_block_size   : %d\\n\", log2_min_transform_block_size);\n  LOG1(\"log2_diff_max_min_transform_block_size : %d\\n\", log2_diff_max_min_transform_block_size);\n  LOG1(\"max_transform_hierarchy_depth_inter : %d\\n\", max_transform_hierarchy_depth_inter);\n  LOG1(\"max_transform_hierarchy_depth_intra : %d\\n\", max_transform_hierarchy_depth_intra);\n  LOG1(\"scaling_list_enable_flag : %d\\n\", scaling_list_enable_flag);\n\n  if (scaling_list_enable_flag) {\n\n    LOG1(\"sps_scaling_list_data_present_flag : %d\\n\", sps_scaling_list_data_present_flag);\n    if (sps_scaling_list_data_present_flag) {\n\n      LOG0(\"scaling list logging output not implemented\");\n      //assert(0);\n      //scaling_list_data()\n    }\n  }\n\n  LOG1(\"amp_enabled_flag                    : %d\\n\", amp_enabled_flag);\n  LOG1(\"sample_adaptive_offset_enabled_flag : %d\\n\", sample_adaptive_offset_enabled_flag);\n  LOG1(\"pcm_enabled_flag                    : %d\\n\", pcm_enabled_flag);\n\n  if (pcm_enabled_flag) {\n    LOG1(\"pcm_sample_bit_depth_luma     : %d\\n\", pcm_sample_bit_depth_luma);\n    LOG1(\"pcm_sample_bit_depth_chroma   : %d\\n\", pcm_sample_bit_depth_chroma);\n    LOG1(\"log2_min_pcm_luma_coding_block_size : %d\\n\", log2_min_pcm_luma_coding_block_size);\n    LOG1(\"log2_diff_max_min_pcm_luma_coding_block_size : %d\\n\", log2_diff_max_min_pcm_luma_coding_block_size);\n    LOG1(\"pcm_loop_filter_disable_flag  : %d\\n\", pcm_loop_filter_disable_flag);\n  }\n\n  LOG1(\"num_short_term_ref_pic_sets : %d\\n\", ref_pic_sets.size());\n\n  for (int i = 0; i < ref_pic_sets.size(); i++) {\n    LOG1(\"ref_pic_set[ %2d ]: \",i);\n    dump_compact_short_term_ref_pic_set(&ref_pic_sets[i], 16, fh);\n  }\n\n  LOG1(\"long_term_ref_pics_present_flag : %d\\n\", long_term_ref_pics_present_flag);\n\n  if (long_term_ref_pics_present_flag) {\n\n    LOG1(\"num_long_term_ref_pics_sps : %d\\n\", num_long_term_ref_pics_sps);\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      LOG3(\"lt_ref_pic_poc_lsb_sps[%d] : %d   (used_by_curr_pic_lt_sps_flag=%d)\\n\",\n           i, lt_ref_pic_poc_lsb_sps[i], used_by_curr_pic_lt_sps_flag[i]);\n    }\n  }\n\n  LOG1(\"sps_temporal_mvp_enabled_flag      : %d\\n\", sps_temporal_mvp_enabled_flag);\n  LOG1(\"strong_intra_smoothing_enable_flag : %d\\n\", strong_intra_smoothing_enable_flag);\n  LOG1(\"vui_parameters_present_flag        : %d\\n\", vui_parameters_present_flag);\n\n  LOG1(\"sps_extension_present_flag    : %d\\n\", sps_extension_present_flag);\n  LOG1(\"sps_range_extension_flag      : %d\\n\", sps_range_extension_flag);\n  LOG1(\"sps_multilayer_extension_flag : %d\\n\", sps_multilayer_extension_flag);\n  LOG1(\"sps_extension_6bits           : %d\\n\", sps_extension_6bits);\n\n  LOG1(\"CtbSizeY     : %d\\n\", CtbSizeY);\n  LOG1(\"MinCbSizeY   : %d\\n\", MinCbSizeY);\n  LOG1(\"MaxCbSizeY   : %d\\n\", 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size));\n  LOG1(\"MinTBSizeY   : %d\\n\", 1<<log2_min_transform_block_size);\n  LOG1(\"MaxTBSizeY   : %d\\n\", 1<<(log2_min_transform_block_size + log2_diff_max_min_transform_block_size));\n\n  LOG1(\"PicWidthInCtbsY         : %d\\n\", PicWidthInCtbsY);\n  LOG1(\"PicHeightInCtbsY        : %d\\n\", PicHeightInCtbsY);\n  LOG1(\"SubWidthC               : %d\\n\", SubWidthC);\n  LOG1(\"SubHeightC              : %d\\n\", SubHeightC);\n\n  if (sps_range_extension_flag) {\n    range_extension.dump(fd);\n  }\n\n  if (vui_parameters_present_flag) {\n    vui.dump(fd);\n  }\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n  //#endif\n}\n\n\nstatic uint8_t default_ScalingList_4x4[16] = {\n  16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16\n};\n\nstatic uint8_t default_ScalingList_8x8_intra[64] = {\n  16,16,16,16,16,16,16,16,\n  16,16,17,16,17,16,17,18,\n  17,18,18,17,18,21,19,20,\n  21,20,19,21,24,22,22,24,\n  24,22,22,24,25,25,27,30,\n  27,25,25,29,31,35,35,31,\n  29,36,41,44,41,36,47,54,\n  54,47,65,70,65,88,88,115\n};\n\nstatic uint8_t default_ScalingList_8x8_inter[64] = {\n  16,16,16,16,16,16,16,16,\n  16,16,17,17,17,17,17,18,\n  18,18,18,18,18,20,20,20,\n  20,20,20,20,24,24,24,24,\n  24,24,24,24,25,25,25,25,\n  25,25,25,28,28,28,28,28,\n  28,33,33,33,33,33,41,41,\n  41,41,54,54,54,71,71,91\n};\n\n\nvoid fill_scaling_factor(uint8_t* scalingFactors, const uint8_t* sclist, int sizeId)\n{\n  const position* scan;\n  int width;\n  int subWidth;\n\n  switch (sizeId) {\n  case 0:\n    width=4;\n    subWidth=1;\n    scan = get_scan_order(2, 0 /* diag */);\n\n    for (int i=0;i<4*4;i++) {\n      scalingFactors[scan[i].x + width*scan[i].y] = sclist[i];\n    }\n    break;\n\n  case 1:\n    width=8;\n    subWidth=1;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      scalingFactors[scan[i].x + width*scan[i].y] = sclist[i];\n    }\n    break;\n\n  case 2:\n    width=8;\n    subWidth=2;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      for (int dy=0;dy<2;dy++)\n        for (int dx=0;dx<2;dx++)\n          {\n            int x = 2*scan[i].x+dx;\n            int y = 2*scan[i].y+dy;\n            scalingFactors[x+width*subWidth*y] = sclist[i];\n          }\n    }\n    break;\n\n  case 3:\n    width=8;\n    subWidth=4;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      for (int dy=0;dy<4;dy++)\n        for (int dx=0;dx<4;dx++)\n          {\n            int x = 4*scan[i].x+dx;\n            int y = 4*scan[i].y+dy;\n            scalingFactors[x+width*subWidth*y] = sclist[i];\n          }\n    }\n    break;\n\n  default:\n    assert(0);\n    break;\n  }\n\n\n  // --- dump matrix ---\n\n#if 0\n  for (int y=0;y<width;y++) {\n    for (int x=0;x<width;x++)\n      printf(\"%d,\",scalingFactors[x*subWidth + width*subWidth*subWidth*y]);\n\n    printf(\"\\n\");\n  }\n#endif\n}\n\n\nde265_error read_scaling_list(bitreader* br, const seq_parameter_set* sps,\n                              scaling_list_data* sclist, bool inPPS)\n{\n  int dc_coeff[4][6];\n\n  for (int sizeId=0;sizeId<4;sizeId++) {\n    //int n = ((sizeId==3) ? 2 : 6);\n    uint8_t scaling_list[6][32*32];\n\n    for (int matrixId=0 ; matrixId<6 ; matrixId += (sizeId==3 ? 3 : 1)) {\n      uint8_t* curr_scaling_list = scaling_list[matrixId];\n      int scaling_list_dc_coef;\n\n      int canonicalMatrixId = matrixId;\n      if (sizeId==3 && matrixId==1) { canonicalMatrixId=3; }\n\n\n      //printf(\"----- matrix %d\\n\",matrixId);\n\n      char scaling_list_pred_mode_flag = get_bits(br,1);\n      if (!scaling_list_pred_mode_flag) {\n        int scaling_list_pred_matrix_id_delta = get_uvlc(br);\n        if (scaling_list_pred_matrix_id_delta == UVLC_ERROR ||\n            scaling_list_pred_matrix_id_delta > matrixId) {\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        //printf(\"scaling_list_pred_matrix_id_delta=%d\\n\", scaling_list_pred_matrix_id_delta);\n\n        dc_coeff[sizeId][matrixId] = 16;\n        scaling_list_dc_coef       = 16;\n\n        if (scaling_list_pred_matrix_id_delta==0) {\n          if (sizeId==0) {\n            memcpy(curr_scaling_list, default_ScalingList_4x4, 16);\n          }\n          else {\n            if (canonicalMatrixId<3)\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_intra,64); }\n            else\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_inter,64); }\n          }\n        }\n        else {\n          // TODO: CHECK: for sizeID=3 and the second matrix, should we have delta=1 or delta=3 ?\n          if (sizeId==3) { assert(scaling_list_pred_matrix_id_delta==1); }\n\n          int mID = matrixId - scaling_list_pred_matrix_id_delta;\n\n          int len = (sizeId == 0 ? 16 : 64);\n          memcpy(curr_scaling_list, scaling_list[mID], len);\n\n          scaling_list_dc_coef       = dc_coeff[sizeId][mID];\n          dc_coeff[sizeId][matrixId] = dc_coeff[sizeId][mID];\n        }\n      }\n      else {\n        int nextCoef=8;\n        int coefNum = (sizeId==0 ? 16 : 64);\n        if (sizeId>1) {\n          scaling_list_dc_coef = get_svlc(br);\n          if (scaling_list_dc_coef < -7 ||\n              scaling_list_dc_coef > 247) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          scaling_list_dc_coef += 8;\n          nextCoef=scaling_list_dc_coef;\n          dc_coeff[sizeId][matrixId] = scaling_list_dc_coef;\n        }\n        else {\n          scaling_list_dc_coef = 16;\n        }\n        //printf(\"DC = %d\\n\",scaling_list_dc_coef);\n\n        for (int i=0;i<coefNum;i++) {\n          int scaling_list_delta_coef = get_svlc(br);\n          if (scaling_list_delta_coef < -128 ||\n              scaling_list_delta_coef >  127) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          nextCoef = (nextCoef + scaling_list_delta_coef + 256) % 256;\n          curr_scaling_list[i] = nextCoef;\n          //printf(\"curr %d = %d\\n\",i,nextCoef);\n        }\n      }\n\n\n      // --- generate ScalingFactor arrays ---\n\n      switch (sizeId) {\n      case 0:\n        fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0], curr_scaling_list, 0);\n        break;\n\n      case 1:\n        fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId][0][0], curr_scaling_list, 1);\n        break;\n\n      case 2:\n        fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId][0][0], curr_scaling_list, 2);\n        sclist->ScalingFactor_Size2[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n\n      case 3:\n        fill_scaling_factor(&sclist->ScalingFactor_Size3[matrixId][0][0], curr_scaling_list, 3);\n        sclist->ScalingFactor_Size3[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n      }\n    }\n  }\n\n\n  // --- fill 32x32 matrices for chroma\n\n  const position* scan = get_scan_order(3, 0 /* diag */);\n\t\n  for (int matrixId=0;matrixId<6;matrixId++)\n    if (matrixId!=0 && matrixId!=3) {\n      for (int i=0;i<64;i++) {\n\tint x = scan[i].x;\n\tint y = scan[i].y;\n\tint v = sclist->ScalingFactor_Size1[matrixId][y][x];\n\n\tfor (int dy=0;dy<4;dy++)\n\t  for (int dx=0;dx<4;dx++) {\n\t    sclist->ScalingFactor_Size3[matrixId][4*y+dy][4*x+dx] = v;\n\t  }\n      }\n\n      sclist->ScalingFactor_Size3[matrixId][0][0] = sclist->ScalingFactor_Size1[matrixId][0][0];\n    }\n  \n  return DE265_OK;\n}\n\n\nde265_error write_scaling_list(CABAC_encoder& out, const seq_parameter_set* sps,\n                              scaling_list_data* sclist, bool inPPS)\n{\n  assert(false);\n  // TODO\n\n  return DE265_OK;\n}\n\n\nvoid set_default_scaling_lists(scaling_list_data* sclist)\n{\n  // 4x4\n\n  for (int matrixId=0;matrixId<6;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0],\n                        default_ScalingList_4x4, 0);\n  }\n\n  // 8x8\n\n  for (int matrixId=0;matrixId<3;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId+0][0][0],\n                        default_ScalingList_8x8_intra, 1);\n    fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId+3][0][0],\n                        default_ScalingList_8x8_inter, 1);\n  }\n\n  // 16x16\n\n  for (int matrixId=0;matrixId<3;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId+0][0][0],\n                        default_ScalingList_8x8_intra, 2);\n    fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId+3][0][0],\n                        default_ScalingList_8x8_inter, 2);\n  }\n\n  // 32x32\n\n  fill_scaling_factor(&sclist->ScalingFactor_Size3[0][0][0],\n                      default_ScalingList_8x8_intra, 3);\n  fill_scaling_factor(&sclist->ScalingFactor_Size3[1][0][0],\n                      default_ScalingList_8x8_inter, 3);\n}\n\n\nde265_error seq_parameter_set::write(error_queue* errqueue, CABAC_encoder& out)\n{\n  out.write_bits(video_parameter_set_id, 4);\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  out.write_bits(sps_max_sub_layers-1, 3);\n\n  out.write_bit(sps_temporal_id_nesting_flag);\n\n  profile_tier_level_.write(out, sps_max_sub_layers);\n\n  out.write_uvlc(seq_parameter_set_id);\n\n\n  // --- encode chroma type ---\n\n  out.write_uvlc(chroma_format_idc);\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (chroma_format_idc == 3) {\n    out.write_bit(separate_colour_plane_flag);\n  }\n\n\n  // --- picture size ---\n\n  out.write_uvlc(pic_width_in_luma_samples);\n  out.write_uvlc(pic_height_in_luma_samples);\n\n  out.write_bit(conformance_window_flag);\n\n  if (conformance_window_flag) {\n    out.write_uvlc(conf_win_left_offset);\n    out.write_uvlc(conf_win_right_offset);\n    out.write_uvlc(conf_win_top_offset);\n    out.write_uvlc(conf_win_bottom_offset);\n  }\n\n\n  out.write_uvlc(bit_depth_luma-8);\n  out.write_uvlc(bit_depth_chroma-8);\n\n  out.write_uvlc(log2_max_pic_order_cnt_lsb-4);\n\n\n  // --- sub_layer_ordering_info ---\n\n  out.write_bit(sps_sub_layer_ordering_info_present_flag);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    if (sps_max_dec_pic_buffering[i] > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    out.write_uvlc(sps_max_dec_pic_buffering[i]-1);\n\n    // sps_max_num_reorder_pics[i]\n\n    out.write_uvlc(sps_max_num_reorder_pics[i]);\n\n\n    // sps_max_latency_increase[i]\n\n    out.write_uvlc(sps_max_latency_increase_plus1[i]);\n  }\n\n\n  out.write_uvlc(log2_min_luma_coding_block_size-3);\n  out.write_uvlc(log2_diff_max_min_luma_coding_block_size);\n  out.write_uvlc(log2_min_transform_block_size-2);\n  out.write_uvlc(log2_diff_max_min_transform_block_size);\n  out.write_uvlc(max_transform_hierarchy_depth_inter);\n  out.write_uvlc(max_transform_hierarchy_depth_intra);\n  out.write_bit(scaling_list_enable_flag);\n\n  if (scaling_list_enable_flag) {\n\n    out.write_bit(sps_scaling_list_data_present_flag);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=write_scaling_list(out,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n  }\n\n  out.write_bit(amp_enabled_flag);\n  out.write_bit(sample_adaptive_offset_enabled_flag);\n  out.write_bit(pcm_enabled_flag);\n  if (pcm_enabled_flag) {\n    out.write_bits(pcm_sample_bit_depth_luma  -1,4);\n    out.write_bits(pcm_sample_bit_depth_chroma-1,4);\n    out.write_uvlc(log2_min_pcm_luma_coding_block_size-3);\n    out.write_uvlc(log2_diff_max_min_pcm_luma_coding_block_size);\n    out.write_bit(pcm_loop_filter_disable_flag);\n  }\n\n  int num_short_term_ref_pic_sets = ref_pic_sets.size();\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  out.write_uvlc(num_short_term_ref_pic_sets);\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = write_short_term_ref_pic_set(errqueue,this,out,\n                                                &ref_pic_sets[i], i,\n                                                ref_pic_sets,\n                                                false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  out.write_bit(long_term_ref_pics_present_flag);\n\n  if (long_term_ref_pics_present_flag) {\n\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n    out.write_uvlc(num_long_term_ref_pics_sps);\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      out.write_bits(lt_ref_pic_poc_lsb_sps[i], log2_max_pic_order_cnt_lsb);\n      out.write_bit (used_by_curr_pic_lt_sps_flag[i]);\n    }\n  }\n\n  out.write_bit(sps_temporal_mvp_enabled_flag);\n  out.write_bit(strong_intra_smoothing_enable_flag);\n  out.write_bit(vui_parameters_present_flag);\n\n#if 0\n  if (vui_parameters_present_flag) {\n    assert(false);\n    /*\n      vui_parameters()\n        sps_extension_flag\n        u(1)\n        if( sps_extension_flag )\n          while( more_rbsp_data() )\n            sps_extension_data_flag\n              u(1)\n              rbsp_trailing_bits()\n    */\n  }\n#endif\n\n  out.write_bit(sps_extension_present_flag);\n\n#if 0\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  check_rbsp_trailing_bits(br);\n#endif\n\n  // --- compute derived values ---\n\n#if 0\n  BitDepth_Y   = bit_depth_luma;\n  QpBdOffset_Y = 6*(bit_depth_luma-8);\n  BitDepth_C   = bit_depth_chroma;\n  QpBdOffset_C = 6*(bit_depth_chroma-8);\n  Log2MinCbSizeY = log2_min_luma_coding_block_size;\n  Log2CtbSizeY = Log2MinCbSizeY + log2_diff_max_min_luma_coding_block_size;\n  MinCbSizeY = 1 << Log2MinCbSizeY;\n  CtbSizeY = 1 << Log2CtbSizeY;\n  PicWidthInMinCbsY = pic_width_in_luma_samples / MinCbSizeY;\n  PicWidthInCtbsY   = ceil_div(pic_width_in_luma_samples, CtbSizeY);\n  PicHeightInMinCbsY = pic_height_in_luma_samples / MinCbSizeY;\n  PicHeightInCtbsY   = ceil_div(pic_height_in_luma_samples,CtbSizeY);\n  PicSizeInMinCbsY   = PicWidthInMinCbsY * PicHeightInMinCbsY;\n  PicSizeInCtbsY = PicWidthInCtbsY * PicHeightInCtbsY;\n  PicSizeInSamplesY = pic_width_in_luma_samples * pic_height_in_luma_samples;\n  if (chroma_format_idc==0 || separate_colour_plane_flag) {\n    CtbWidthC  = 0;\n    CtbHeightC = 0;\n  }\n  else {\n    CtbWidthC  = CtbSizeY / SubWidthC;\n    CtbHeightC = CtbSizeY / SubHeightC;\n  }\n  Log2MinTrafoSize = log2_min_transform_block_size;\n  Log2MaxTrafoSize = log2_min_transform_block_size + log2_diff_max_min_transform_block_size;\n  Log2MinPUSize = Log2MinCbSizeY-1;\n  PicWidthInMinPUs  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinPUSize);\n  PicHeightInMinPUs = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinPUSize);\n  Log2MinIpcmCbSizeY = log2_min_pcm_luma_coding_block_size;\n  Log2MaxIpcmCbSizeY = (log2_min_pcm_luma_coding_block_size +\n                        log2_diff_max_min_pcm_luma_coding_block_size);\n  // the following are not in the standard\n  PicWidthInTbsY  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicHeightInTbsY = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicSizeInTbsY = PicWidthInTbsY * PicHeightInTbsY;\n  sps_read = true;\n#endif\n\n  return DE265_OK;\n}\n\n\nde265_error sps_range_extension::read(error_queue* errqueue, bitreader* br)\n{\n  transform_skip_rotation_enabled_flag    = get_bits(br,1);\n  transform_skip_context_enabled_flag     = get_bits(br,1);\n  implicit_rdpcm_enabled_flag             = get_bits(br,1);\n  explicit_rdpcm_enabled_flag             = get_bits(br,1);\n  extended_precision_processing_flag      = get_bits(br,1);\n  intra_smoothing_disabled_flag           = get_bits(br,1);\n  high_precision_offsets_enabled_flag     = get_bits(br,1);\n  persistent_rice_adaptation_enabled_flag = get_bits(br,1);\n  cabac_bypass_alignment_enabled_flag     = get_bits(br,1);\n\n  return DE265_OK;\n}\n\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\nvoid sps_range_extension::dump(int fd) const\n{\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n  LOG0(\"----------------- SPS-range-extension -----------------\\n\");\n  LOG1(\"transform_skip_rotation_enabled_flag    : %d\\n\", transform_skip_rotation_enabled_flag);\n  LOG1(\"transform_skip_context_enabled_flag     : %d\\n\", transform_skip_context_enabled_flag);\n  LOG1(\"implicit_rdpcm_enabled_flag             : %d\\n\", implicit_rdpcm_enabled_flag);\n  LOG1(\"explicit_rdpcm_enabled_flag             : %d\\n\", explicit_rdpcm_enabled_flag);\n  LOG1(\"extended_precision_processing_flag      : %d\\n\", extended_precision_processing_flag);\n  LOG1(\"intra_smoothing_disabled_flag           : %d\\n\", intra_smoothing_disabled_flag);\n  LOG1(\"high_precision_offsets_enabled_flag     : %d\\n\", high_precision_offsets_enabled_flag);\n  LOG1(\"persistent_rice_adaptation_enabled_flag : %d\\n\", persistent_rice_adaptation_enabled_flag);\n  LOG1(\"cabac_bypass_alignment_enabled_flag     : %d\\n\", cabac_bypass_alignment_enabled_flag);\n}\n#undef LOG1\n#undef LOG0\n", "/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"vui.h\"\n#include \"decctx.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define READ_VLC_OFFSET(variable, vlctype, offset)   \\\n  if ((vlc = get_ ## vlctype(br)) == UVLC_ERROR) {   \\\n    errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);  \\\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; \\\n  } \\\n  variable = vlc + offset;\n\n#define READ_VLC(variable, vlctype)  READ_VLC_OFFSET(variable,vlctype,0)\n\n\n#define NUM_SAR_PRESETS 17\n\nstatic uint16_t sar_presets[NUM_SAR_PRESETS+1][2] = {\n  { 0,0 },\n  { 1,1 },\n  { 12,11 },\n  { 10,11 },\n  { 16,11 },\n  { 40,33 },\n  { 24,11 },\n  { 20,11 },\n  { 32,11 },\n  { 80,33 },\n  { 18,11 },\n  { 15,11 },\n  { 64,33 },\n  { 160,99 },\n  { 4,3 },\n  { 3,2 },\n  { 2,1 }\n};\n\n#define EXTENDED_SAR 255\n\n\nconst char* get_video_format_name(enum VideoFormat format)\n{\n  switch (format) {\n  case VideoFormat_Component: return \"component\";\n  case VideoFormat_PAL:       return \"PAL\";\n  case VideoFormat_NTSC:      return \"NTSC\";\n  case VideoFormat_SECAM:     return \"SECAM\";\n  case VideoFormat_MAC:       return \"MAC\";\n  default:                    return \"unspecified\";\n  }\n}\n\n\nvideo_usability_information::video_usability_information()\n{\n  aspect_ratio_info_present_flag = false;\n  sar_width  = 0;\n  sar_height = 0;\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = false;\n  overscan_appropriate_flag  = false;\n\n\n  // --- video signal type ---\n\n  video_signal_type_present_flag = false;\n  video_format = VideoFormat_Unspecified;\n  video_full_range_flag = false;\n  colour_description_present_flag = false;\n  colour_primaries = 2;\n  transfer_characteristics = 2;\n  matrix_coeffs = 2;\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = false;\n  chroma_sample_loc_type_top_field    = 0;\n  chroma_sample_loc_type_bottom_field = 0;\n\n  neutral_chroma_indication_flag = false;\n  field_seq_flag = false;\n  frame_field_info_present_flag = false;\n\n  // --- default display window ---\n\n  default_display_window_flag = false;\n  def_disp_win_left_offset   = 0;\n  def_disp_win_right_offset  = 0;\n  def_disp_win_top_offset    = 0;\n  def_disp_win_bottom_offset = 0;\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = false;\n  vui_num_units_in_tick = 0;\n  vui_time_scale = 0;\n\n  vui_poc_proportional_to_timing_flag = false;\n  vui_num_ticks_poc_diff_one = 1;\n\n\n  // --- hrd parameters ---\n\n  vui_hrd_parameters_present_flag = false;\n \n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = false;\n  tiles_fixed_structure_flag = false;\n  motion_vectors_over_pic_boundaries_flag = true;\n  restricted_ref_pic_lists_flag = false;\n  min_spatial_segmentation_idc = 0;\n  max_bytes_per_pic_denom   = 2;\n  max_bits_per_min_cu_denom = 1;\n  log2_max_mv_length_horizontal = 15;\n  log2_max_mv_length_vertical   = 15;\n}\n\n\nde265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps)\n{\n  int vlc;\n\n  nal_hrd_parameters_present_flag = get_bits(br, 1);\n  vcl_hrd_parameters_present_flag = get_bits(br, 1);\n\n  if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)\n  {\n    sub_pic_hrd_params_present_flag = get_bits(br, 1);\n    if (sub_pic_hrd_params_present_flag)\n    {\n      tick_divisor_minus2 = get_bits(br, 8);\n      du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5);\n      sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1);\n      dpb_output_delay_du_length_minus1 = get_bits(br, 5);\n    }\n    bit_rate_scale = get_bits(br, 4);\n    cpb_size_scale = get_bits(br, 4);\n\n\n    if (sub_pic_hrd_params_present_flag)\n    {\n      cpb_size_du_scale = get_bits(br, 4);\n    }\n    initial_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    au_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    dpb_output_delay_length_minus1 = get_bits(br, 5);\n  }\n  int  i, j, nalOrVcl;\n\n  for (i = 0; i < sps->sps_max_sub_layers; i++)\n  {\n    fixed_pic_rate_general_flag[i] = get_bits(br, 1);\n    if (!fixed_pic_rate_general_flag[i])\n    {\n      fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1);\n    }\n    else\n    {\n      fixed_pic_rate_within_cvs_flag[i] = true;\n    }\n\n    low_delay_hrd_flag[i] = 0;// Infered to be 0 when not present\n    cpb_cnt_minus1[i] = 0;    // Infered to be 0 when not present\n\n    if (fixed_pic_rate_within_cvs_flag[i])\n    {\n      READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0);\n    }\n    else\n    {\n      low_delay_hrd_flag[i] = get_bits(br, 1);\n    }\n    if (!low_delay_hrd_flag[i])\n    {\n      READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n    }\n\n    for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)\n    {\n      if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) ||\n        ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag))\n      {\n        for (j = 0; j <= cpb_cnt_minus1[i]; j++)\n        {\n          READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0);\n\n          if (sub_pic_hrd_params_present_flag)\n          {\n            READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n            READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          }\n          cbr_flag[i][j][nalOrVcl] = get_bits(br, 1);\n        }\n      }\n    }\n  }\n  return DE265_OK;\n}\n\nde265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}\n\n\nvoid video_usability_information::dump(int fd) const\n{\n  //#if (_MSC_VER >= 1500)\n  //#define LOG0(t) loginfo(LogHeaders, t)\n  //#define LOG1(t,d) loginfo(LogHeaders, t,d)\n  //#define LOG2(t,d1,d2) loginfo(LogHeaders, t,d1,d2)\n  //#define LOG3(t,d1,d2,d3) loginfo(LogHeaders, t,d1,d2,d3)\n\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n\n  LOG0(\"----------------- VUI -----------------\\n\");\n  LOG2(\"sample aspect ratio        : %d:%d\\n\", sar_width,sar_height);\n  LOG1(\"overscan_info_present_flag : %d\\n\", overscan_info_present_flag);\n  LOG1(\"overscan_appropriate_flag  : %d\\n\", overscan_appropriate_flag);\n\n  LOG1(\"video_signal_type_present_flag: %d\\n\", video_signal_type_present_flag);\n  if (video_signal_type_present_flag) {\n    LOG1(\"  video_format                : %s\\n\", get_video_format_name(video_format));\n    LOG1(\"  video_full_range_flag       : %d\\n\", video_full_range_flag);\n    LOG1(\"  colour_description_present_flag : %d\\n\", colour_description_present_flag);\n    LOG1(\"  colour_primaries            : %d\\n\", colour_primaries);\n    LOG1(\"  transfer_characteristics    : %d\\n\", transfer_characteristics);\n    LOG1(\"  matrix_coeffs               : %d\\n\", matrix_coeffs);\n  }\n\n  LOG1(\"chroma_loc_info_present_flag: %d\\n\", chroma_loc_info_present_flag);\n  if (chroma_loc_info_present_flag) {\n    LOG1(\"  chroma_sample_loc_type_top_field   : %d\\n\", chroma_sample_loc_type_top_field);\n    LOG1(\"  chroma_sample_loc_type_bottom_field: %d\\n\", chroma_sample_loc_type_bottom_field);\n  }\n\n  LOG1(\"neutral_chroma_indication_flag: %d\\n\", neutral_chroma_indication_flag);\n  LOG1(\"field_seq_flag                : %d\\n\", field_seq_flag);\n  LOG1(\"frame_field_info_present_flag : %d\\n\", frame_field_info_present_flag);\n\n  LOG1(\"default_display_window_flag   : %d\\n\", default_display_window_flag);\n  LOG1(\"  def_disp_win_left_offset    : %d\\n\", def_disp_win_left_offset);\n  LOG1(\"  def_disp_win_right_offset   : %d\\n\", def_disp_win_right_offset);\n  LOG1(\"  def_disp_win_top_offset     : %d\\n\", def_disp_win_top_offset);\n  LOG1(\"  def_disp_win_bottom_offset  : %d\\n\", def_disp_win_bottom_offset);\n\n  LOG1(\"vui_timing_info_present_flag  : %d\\n\", vui_timing_info_present_flag);\n  if (vui_timing_info_present_flag) {\n    LOG1(\"  vui_num_units_in_tick       : %d\\n\", vui_num_units_in_tick);\n    LOG1(\"  vui_time_scale              : %d\\n\", vui_time_scale);\n  }\n\n  LOG1(\"vui_poc_proportional_to_timing_flag : %d\\n\", vui_poc_proportional_to_timing_flag);\n  LOG1(\"vui_num_ticks_poc_diff_one          : %d\\n\", vui_num_ticks_poc_diff_one);\n\n  LOG1(\"vui_hrd_parameters_present_flag : %d\\n\", vui_hrd_parameters_present_flag);\n  if (vui_hrd_parameters_present_flag) {\n    //hrd_parameters vui_hrd_parameters;\n  }\n\n\n  // --- bitstream restriction ---\n\n  LOG1(\"bitstream_restriction_flag         : %d\\n\", bitstream_restriction_flag);\n  if (bitstream_restriction_flag) {\n    LOG1(\"  tiles_fixed_structure_flag       : %d\\n\", tiles_fixed_structure_flag);\n    LOG1(\"  motion_vectors_over_pic_boundaries_flag : %d\\n\", motion_vectors_over_pic_boundaries_flag);\n    LOG1(\"  restricted_ref_pic_lists_flag    : %d\\n\", restricted_ref_pic_lists_flag);\n    LOG1(\"  min_spatial_segmentation_idc     : %d\\n\", min_spatial_segmentation_idc);\n    LOG1(\"  max_bytes_per_pic_denom          : %d\\n\", max_bytes_per_pic_denom);\n    LOG1(\"  max_bits_per_min_cu_denom        : %d\\n\", max_bits_per_min_cu_denom);\n    LOG1(\"  log2_max_mv_length_horizontal    : %d\\n\", log2_max_mv_length_horizontal);\n    LOG1(\"  log2_max_mv_length_vertical      : %d\\n\", log2_max_mv_length_vertical);\n  }\n\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n  //#endif\n}\n"], "fixing_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sps.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"decctx.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define READ_VLC_OFFSET(variable, vlctype, offset)   \\\n  if ((vlc = get_ ## vlctype(br)) == UVLC_ERROR) {   \\\n    errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);  \\\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; \\\n  } \\\n  variable = vlc + offset;\n\n#define READ_VLC(variable, vlctype)  READ_VLC_OFFSET(variable,vlctype,0)\n\n\nstatic int SubWidthC_tab[]  = { 1,2,2,1 };\nstatic int SubHeightC_tab[] = { 1,2,1,1 };\n\n\n// TODO if (!check_high(ctx, vlc, 15)) return false;\n// TODO if (!check_ulvc(ctx, vlc)) return false;\n\n\n// TODO: should be in some header-file of refpic.c\nextern bool read_short_term_ref_pic_set(error_queue* errqueue,\n                                        const seq_parameter_set* sps,\n                                        bitreader* br,\n                                        ref_pic_set* out_set,\n                                        int idxRps,  // index of the set to be read\n                                        const std::vector<ref_pic_set>& sets,\n                                        bool sliceRefPicSet);\n\nextern bool write_short_term_ref_pic_set(error_queue* errqueue,\n                                         const seq_parameter_set* sps,\n                                         CABAC_encoder& out,\n                                         const ref_pic_set* in_set, // which set to write\n                                         int idxRps,  // index of the set to be read\n                                         const std::vector<ref_pic_set>& sets, // previously read sets\n                                         bool sliceRefPicSet); // is this in the slice header?\n\n\nsps_range_extension::sps_range_extension()\n{\n  transform_skip_rotation_enabled_flag = 0;\n  transform_skip_context_enabled_flag  = 0;\n  implicit_rdpcm_enabled_flag = 0;\n  explicit_rdpcm_enabled_flag = 0;\n  extended_precision_processing_flag = 0;\n  intra_smoothing_disabled_flag = 0;\n  high_precision_offsets_enabled_flag = 0;\n  persistent_rice_adaptation_enabled_flag = 0;\n  cabac_bypass_alignment_enabled_flag = 0;\n}\n\n\nseq_parameter_set::seq_parameter_set()\n{\n  // TODO: this is dangerous\n  //memset(this,0,sizeof(seq_parameter_set));\n\n  sps_read = false;\n  //ref_pic_sets = NULL;\n}\n\n\nseq_parameter_set::~seq_parameter_set()\n{\n  //free(ref_pic_sets);\n}\n\n\nvoid seq_parameter_set::set_defaults(enum PresetSet)\n{\n  video_parameter_set_id = 0;\n  sps_max_sub_layers = 1;\n  sps_temporal_id_nesting_flag = 1;\n\n  profile_tier_level_.general.set_defaults(Profile_Main, 6,2); // TODO\n\n  seq_parameter_set_id = 0;\n  chroma_format_idc = 1;\n  ChromaArrayType = chroma_format_idc;\n\n  separate_colour_plane_flag = 0;\n  pic_width_in_luma_samples = 0;\n  pic_height_in_luma_samples = 0;\n  conformance_window_flag = 0;\n\n  conf_win_left_offset   = 0;\n  conf_win_right_offset  = 0;\n  conf_win_top_offset    = 0;\n  conf_win_bottom_offset = 0;\n\n  bit_depth_luma  =8;\n  bit_depth_chroma=8;\n\n  log2_max_pic_order_cnt_lsb = 8;\n  sps_sub_layer_ordering_info_present_flag = 0;\n\n  sps_max_dec_pic_buffering[0] = 1;\n  sps_max_num_reorder_pics[0]  = 0;\n  sps_max_latency_increase_plus1[0] = 0;\n\n  set_CB_log2size_range(4,4);\n  set_TB_log2size_range(3,4);\n  max_transform_hierarchy_depth_inter = 1;\n  max_transform_hierarchy_depth_intra = 1;\n\n  scaling_list_enable_flag = 0;\n  sps_scaling_list_data_present_flag = 0;\n\n  // TODO struct scaling_list_data scaling_list;\n\n  amp_enabled_flag = 0;\n  sample_adaptive_offset_enabled_flag = 0;\n  pcm_enabled_flag = 0;\n\n  pcm_sample_bit_depth_luma = 8;\n  pcm_sample_bit_depth_chroma = 8;\n  // TODO log2_min_pcm_luma_coding_block_size;\n  // TODO log2_diff_max_min_pcm_luma_coding_block_size;\n  pcm_loop_filter_disable_flag = 1;\n\n  // num_short_term_ref_pic_sets = 0;\n  // std::vector<ref_pic_set> ref_pic_sets; // [0 ; num_short_term_ref_pic_set (<=MAX_REF_PIC_SETS) )\n  ref_pic_sets.clear();\n\n  long_term_ref_pics_present_flag = 0;\n\n  num_long_term_ref_pics_sps = 0;\n\n  /* TODO\n  int  lt_ref_pic_poc_lsb_sps[MAX_NUM_LT_REF_PICS_SPS];\n  char used_by_curr_pic_lt_sps_flag[MAX_NUM_LT_REF_PICS_SPS];\n  */\n\n  sps_temporal_mvp_enabled_flag = 0;\n  strong_intra_smoothing_enable_flag = 0;\n  vui_parameters_present_flag = 0;\n\n  /*\n    if( vui_parameters_present_flag )\n      vui_parameters()\n  */\n\n  sps_extension_present_flag = 0;\n  sps_range_extension_flag = 0;\n  sps_multilayer_extension_flag = 0;\n  sps_extension_6bits = 0;\n}\n\n\nvoid seq_parameter_set::set_CB_log2size_range(int mini,int maxi)\n{\n  log2_min_luma_coding_block_size = mini;\n  log2_diff_max_min_luma_coding_block_size = maxi-mini;\n}\n\n\nvoid seq_parameter_set::set_TB_log2size_range(int mini,int maxi)\n{\n  log2_min_transform_block_size = mini;\n  log2_diff_max_min_transform_block_size = maxi-mini;\n}\n\n\nvoid seq_parameter_set::set_resolution(int w,int h)\n{\n  pic_width_in_luma_samples  = w;\n  pic_height_in_luma_samples = h;\n}\n\n\nde265_error seq_parameter_set::read(error_queue* errqueue, bitreader* br)\n{\n  int vlc;\n\n  video_parameter_set_id = get_bits(br,4);\n  sps_max_sub_layers     = get_bits(br,3) +1;\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  sps_temporal_id_nesting_flag = get_bits(br,1);\n\n  profile_tier_level_.read(br, sps_max_sub_layers);\n\n  READ_VLC(seq_parameter_set_id, uvlc);\n  if (seq_parameter_set_id >= DE265_MAX_SPS_SETS) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- decode chroma type ---\n\n  READ_VLC(chroma_format_idc, uvlc);\n\n  if (chroma_format_idc == 3) {\n    separate_colour_plane_flag = get_bits(br,1);\n  }\n  else {\n    separate_colour_plane_flag = 0;\n  }\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- picture size ---\n\n  READ_VLC(pic_width_in_luma_samples,  uvlc);\n  READ_VLC(pic_height_in_luma_samples, uvlc);\n\n  if (pic_width_in_luma_samples  == 0 ||\n      pic_height_in_luma_samples == 0) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (pic_width_in_luma_samples > MAX_PICTURE_WIDTH ||\n      pic_height_in_luma_samples> MAX_PICTURE_HEIGHT) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  conformance_window_flag = get_bits(br,1);\n\n  if (conformance_window_flag) {\n    READ_VLC(conf_win_left_offset,  uvlc);\n    READ_VLC(conf_win_right_offset, uvlc);\n    READ_VLC(conf_win_top_offset,   uvlc);\n    READ_VLC(conf_win_bottom_offset,uvlc);\n  }\n  else {\n    conf_win_left_offset  = 0;\n    conf_win_right_offset = 0;\n    conf_win_top_offset   = 0;\n    conf_win_bottom_offset= 0;\n  }\n\n  READ_VLC_OFFSET(bit_depth_luma,  uvlc, 8);\n  READ_VLC_OFFSET(bit_depth_chroma,uvlc, 8);\n  if (bit_depth_luma > 16 ||\n      bit_depth_chroma > 16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  READ_VLC_OFFSET(log2_max_pic_order_cnt_lsb, uvlc, 4);\n  if (log2_max_pic_order_cnt_lsb<4 ||\n      log2_max_pic_order_cnt_lsb>16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  MaxPicOrderCntLsb = 1<<(log2_max_pic_order_cnt_lsb);\n\n\n  // --- sub_layer_ordering_info ---\n\n  sps_sub_layer_ordering_info_present_flag = get_bits(br,1);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    vlc=get_uvlc(br);\n    if (vlc == UVLC_ERROR ||\n        vlc+1 > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    sps_max_dec_pic_buffering[i] = vlc+1;\n\n    // sps_max_num_reorder_pics[i]\n\n    READ_VLC(sps_max_num_reorder_pics[i], uvlc);\n\n\n    // sps_max_latency_increase[i]\n\n    READ_VLC(sps_max_latency_increase_plus1[i], uvlc);\n\n    SpsMaxLatencyPictures[i] = (sps_max_num_reorder_pics[i] +\n                                sps_max_latency_increase_plus1[i]-1);\n  }\n\n  // copy info to all layers if only specified once\n\n  if (sps_sub_layer_ordering_info_present_flag) {\n    int ref = sps_max_sub_layers-1;\n    assert(ref<7);\n\n    for (int i=0 ; i < sps_max_sub_layers-1; i++ ) {\n      sps_max_dec_pic_buffering[i] = sps_max_dec_pic_buffering[ref];\n      sps_max_num_reorder_pics[i]  = sps_max_num_reorder_pics[ref];\n      sps_max_latency_increase_plus1[i]  = sps_max_latency_increase_plus1[ref];\n    }\n  }\n\n\n  READ_VLC_OFFSET(log2_min_luma_coding_block_size, uvlc, 3);\n  READ_VLC       (log2_diff_max_min_luma_coding_block_size, uvlc);\n  READ_VLC_OFFSET(log2_min_transform_block_size, uvlc, 2);\n  READ_VLC(log2_diff_max_min_transform_block_size, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_inter, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_intra, uvlc);\n\n  if (log2_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size + log2_diff_max_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n  scaling_list_enable_flag = get_bits(br,1);\n\n  if (scaling_list_enable_flag) {\n\n    sps_scaling_list_data_present_flag = get_bits(br,1);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=read_scaling_list(br,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n    else {\n      set_default_scaling_lists(&scaling_list);\n    }\n  }\n\n  amp_enabled_flag = get_bits(br,1);\n  sample_adaptive_offset_enabled_flag = get_bits(br,1);\n  pcm_enabled_flag = get_bits(br,1);\n  if (pcm_enabled_flag) {\n    pcm_sample_bit_depth_luma = get_bits(br,4)+1;\n    pcm_sample_bit_depth_chroma = get_bits(br,4)+1;\n    READ_VLC_OFFSET(log2_min_pcm_luma_coding_block_size, uvlc, 3);\n    READ_VLC(log2_diff_max_min_pcm_luma_coding_block_size, uvlc);\n    pcm_loop_filter_disable_flag = get_bits(br,1);\n\n    if (pcm_sample_bit_depth_luma > bit_depth_luma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pcm_sample_bit_depth_chroma > bit_depth_chroma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n  else {\n    pcm_sample_bit_depth_luma = 0;\n    pcm_sample_bit_depth_chroma = 0;\n    log2_min_pcm_luma_coding_block_size = 0;\n    log2_diff_max_min_pcm_luma_coding_block_size = 0;\n    pcm_loop_filter_disable_flag = 0;\n  }\n\n  int num_short_term_ref_pic_sets;\n  READ_VLC(num_short_term_ref_pic_sets, uvlc);\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  ref_pic_sets.resize(num_short_term_ref_pic_sets);\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = read_short_term_ref_pic_set(errqueue,this,br,\n                                               &ref_pic_sets[i], i,\n                                               ref_pic_sets,\n                                               false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  long_term_ref_pics_present_flag = get_bits(br,1);\n\n  if (long_term_ref_pics_present_flag) {\n\n    READ_VLC(num_long_term_ref_pics_sps, uvlc);\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      lt_ref_pic_poc_lsb_sps[i] = get_bits(br, log2_max_pic_order_cnt_lsb);\n      used_by_curr_pic_lt_sps_flag[i] = get_bits(br,1);\n    }\n  }\n  else {\n    num_long_term_ref_pics_sps = 0; // NOTE: missing definition in standard !\n  }\n\n  sps_temporal_mvp_enabled_flag = get_bits(br,1);\n  strong_intra_smoothing_enable_flag = get_bits(br,1);\n\n  vui_parameters_present_flag = get_bits(br,1);\n  if (vui_parameters_present_flag) {\n    de265_error err = vui.read(errqueue, br, this);\n    if (err) {\n      return err;\n    }\n  }\n\n\n  sps_extension_present_flag = get_bits(br,1);\n  if (sps_extension_present_flag) {\n    sps_range_extension_flag = get_bits(br,1);\n    sps_multilayer_extension_flag = get_bits(br,1);\n    sps_extension_6bits = get_bits(br,6);\n  }\n  else {\n    sps_range_extension_flag = 0;\n  }\n\n  if (sps_range_extension_flag) {\n    de265_error err = range_extension.read(errqueue, br);\n    if (err != DE265_OK) { return err; }\n  }\n\n  /*\n  sps_extension_flag = get_bits(br,1);\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  */\n\n\n  de265_error err = compute_derived_values();\n  if (err != DE265_OK) { return err; }\n\n  sps_read = true;\n\n  return DE265_OK;\n}\n\n\nde265_error seq_parameter_set::compute_derived_values(bool sanitize_values)\n{\n  // --- compute derived values ---\n\n  SubWidthC  = SubWidthC_tab [chroma_format_idc];\n  SubHeightC = SubHeightC_tab[chroma_format_idc];\n\n  if (separate_colour_plane_flag) {\n    ChromaArrayType = 0;\n  }\n  else {\n    ChromaArrayType = chroma_format_idc;\n  }\n\n  if (ChromaArrayType==0) {\n    WinUnitX = 1;\n    WinUnitY = 1;\n  }\n  else {\n    WinUnitX = SubWidthC_tab [chroma_format_idc];\n    WinUnitY = SubHeightC_tab[chroma_format_idc];\n  }\n\n\n\n  BitDepth_Y   = bit_depth_luma;\n  QpBdOffset_Y = 6*(bit_depth_luma-8);\n  BitDepth_C   = bit_depth_chroma;\n  QpBdOffset_C = 6*(bit_depth_chroma-8);\n\n  Log2MinCbSizeY = log2_min_luma_coding_block_size;\n  Log2CtbSizeY = Log2MinCbSizeY + log2_diff_max_min_luma_coding_block_size;\n  MinCbSizeY = 1 << Log2MinCbSizeY;\n  CtbSizeY = 1 << Log2CtbSizeY;\n\n  PicWidthInMinCbsY = ceil_div(pic_width_in_luma_samples, MinCbSizeY);\n  PicWidthInCtbsY   = ceil_div(pic_width_in_luma_samples, CtbSizeY);\n  PicHeightInMinCbsY = ceil_div(pic_height_in_luma_samples, MinCbSizeY);\n  PicHeightInCtbsY   = ceil_div(pic_height_in_luma_samples,CtbSizeY);\n  PicSizeInMinCbsY   = PicWidthInMinCbsY * PicHeightInMinCbsY;\n  PicSizeInCtbsY = PicWidthInCtbsY * PicHeightInCtbsY;\n  PicSizeInSamplesY = pic_width_in_luma_samples * pic_height_in_luma_samples;\n\n  if (chroma_format_idc==0 || separate_colour_plane_flag) {\n    CtbWidthC  = 0;\n    CtbHeightC = 0;\n  }\n  else {\n    CtbWidthC  = CtbSizeY / SubWidthC;\n    CtbHeightC = CtbSizeY / SubHeightC;\n  }\n\n  Log2MinTrafoSize = log2_min_transform_block_size;\n  Log2MaxTrafoSize = log2_min_transform_block_size + log2_diff_max_min_transform_block_size;\n\n  if (max_transform_hierarchy_depth_inter > Log2CtbSizeY - Log2MinTrafoSize) {\n    if (sanitize_values) {\n      max_transform_hierarchy_depth_inter = Log2CtbSizeY - Log2MinTrafoSize;\n    } else {\n      fprintf(stderr,\"SPS error: transform hierarchy depth (inter) > CTB size - min TB size\\n\");\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n\n  if (max_transform_hierarchy_depth_intra > Log2CtbSizeY - Log2MinTrafoSize) {\n    if (sanitize_values) {\n      max_transform_hierarchy_depth_intra = Log2CtbSizeY - Log2MinTrafoSize;\n    } else {\n      fprintf(stderr,\"SPS error: transform hierarchy depth (intra) > CTB size - min TB size\\n\");\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n\n\n  if (sanitize_values) {\n    if (max_transform_hierarchy_depth_inter < Log2CtbSizeY - Log2MaxTrafoSize) {\n      max_transform_hierarchy_depth_inter = Log2CtbSizeY - Log2MaxTrafoSize;\n    }\n\n    if (max_transform_hierarchy_depth_intra < Log2CtbSizeY - Log2MaxTrafoSize) {\n      max_transform_hierarchy_depth_intra = Log2CtbSizeY - Log2MaxTrafoSize;\n    }\n  }\n\n\n  Log2MinPUSize = Log2MinCbSizeY-1;\n  PicWidthInMinPUs  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinPUSize);\n  PicHeightInMinPUs = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinPUSize);\n\n  Log2MinIpcmCbSizeY = log2_min_pcm_luma_coding_block_size;\n  Log2MaxIpcmCbSizeY = (log2_min_pcm_luma_coding_block_size +\n                        log2_diff_max_min_pcm_luma_coding_block_size);\n\n  // the following are not in the standard\n  PicWidthInTbsY  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicHeightInTbsY = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicSizeInTbsY = PicWidthInTbsY * PicHeightInTbsY;\n\n\n  if (range_extension.high_precision_offsets_enabled_flag) {\n    WpOffsetBdShiftY = 0;\n    WpOffsetBdShiftC = 0;\n    WpOffsetHalfRangeY = 1 << (BitDepth_Y - 1);\n    WpOffsetHalfRangeC = 1 << (BitDepth_C - 1);\n  }\n  else {\n    WpOffsetBdShiftY = ( BitDepth_Y - 8 );\n    WpOffsetBdShiftC = ( BitDepth_C - 8 );\n    WpOffsetHalfRangeY = 1 << 7;\n    WpOffsetHalfRangeC = 1 << 7;\n  }\n\n\n  // --- check SPS sanity ---\n\n  if (pic_width_in_luma_samples  % MinCbSizeY != 0 ||\n      pic_height_in_luma_samples % MinCbSizeY != 0) {\n    // TODO: warn that image size is coded wrong in bitstream (must be multiple of MinCbSizeY)\n    fprintf(stderr,\"SPS error: CB alignment\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (Log2MinTrafoSize > Log2MinCbSizeY) {\n    fprintf(stderr,\"SPS error: TB > CB\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (Log2MaxTrafoSize > libde265_min(Log2CtbSizeY,5)) {\n    fprintf(stderr,\"SPS error: TB_max > 32 or CTB\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  if (BitDepth_Y < 8 || BitDepth_Y > 16) {\n    fprintf(stderr,\"SPS error: bitdepth Y not in [8;16]\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (BitDepth_C < 8 || BitDepth_C > 16) {\n    fprintf(stderr,\"SPS error: bitdepth C not in [8;16]\\n\");\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  sps_read = true;\n\n  return DE265_OK;\n}\n\n\n\nvoid seq_parameter_set::dump(int fd) const\n{\n  //#if (_MSC_VER >= 1500)\n  //#define LOG0(t) loginfo(LogHeaders, t)\n  //#define LOG1(t,d) loginfo(LogHeaders, t,d)\n  //#define LOG2(t,d1,d2) loginfo(LogHeaders, t,d1,d2)\n  //#define LOG3(t,d1,d2,d3) loginfo(LogHeaders, t,d1,d2,d3)\n\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n\n\n  LOG0(\"----------------- SPS -----------------\\n\");\n  LOG1(\"video_parameter_set_id  : %d\\n\", video_parameter_set_id);\n  LOG1(\"sps_max_sub_layers      : %d\\n\", sps_max_sub_layers);\n  LOG1(\"sps_temporal_id_nesting_flag : %d\\n\", sps_temporal_id_nesting_flag);\n\n  profile_tier_level_.dump(sps_max_sub_layers, fh);\n\n  LOG1(\"seq_parameter_set_id    : %d\\n\", seq_parameter_set_id);\n  LOG2(\"chroma_format_idc       : %d (%s)\\n\", chroma_format_idc,\n       chroma_format_idc == 0 ? \"monochrome\" :\n       chroma_format_idc == 1 ? \"4:2:0\" :\n       chroma_format_idc == 2 ? \"4:2:2\" :\n       chroma_format_idc == 3 ? \"4:4:4\" : \"unknown\");\n\n  if (chroma_format_idc == 3) {\n    LOG1(\"separate_colour_plane_flag : %d\\n\", separate_colour_plane_flag);\n  }\n\n  LOG1(\"pic_width_in_luma_samples  : %d\\n\", pic_width_in_luma_samples);\n  LOG1(\"pic_height_in_luma_samples : %d\\n\", pic_height_in_luma_samples);\n  LOG1(\"conformance_window_flag    : %d\\n\", conformance_window_flag);\n\n  if (conformance_window_flag) {\n    LOG1(\"conf_win_left_offset  : %d\\n\", conf_win_left_offset);\n    LOG1(\"conf_win_right_offset : %d\\n\", conf_win_right_offset);\n    LOG1(\"conf_win_top_offset   : %d\\n\", conf_win_top_offset);\n    LOG1(\"conf_win_bottom_offset: %d\\n\", conf_win_bottom_offset);\n  }\n\n  LOG1(\"bit_depth_luma   : %d\\n\", bit_depth_luma);\n  LOG1(\"bit_depth_chroma : %d\\n\", bit_depth_chroma);\n\n  LOG1(\"log2_max_pic_order_cnt_lsb : %d\\n\", log2_max_pic_order_cnt_lsb);\n  LOG1(\"sps_sub_layer_ordering_info_present_flag : %d\\n\", sps_sub_layer_ordering_info_present_flag);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n    LOG1(\"Layer %d\\n\",i);\n    LOG1(\"  sps_max_dec_pic_buffering      : %d\\n\", sps_max_dec_pic_buffering[i]);\n    LOG1(\"  sps_max_num_reorder_pics       : %d\\n\", sps_max_num_reorder_pics[i]);\n    LOG1(\"  sps_max_latency_increase_plus1 : %d\\n\", sps_max_latency_increase_plus1[i]);\n  }\n\n  LOG1(\"log2_min_luma_coding_block_size : %d\\n\", log2_min_luma_coding_block_size);\n  LOG1(\"log2_diff_max_min_luma_coding_block_size : %d\\n\",log2_diff_max_min_luma_coding_block_size);\n  LOG1(\"log2_min_transform_block_size   : %d\\n\", log2_min_transform_block_size);\n  LOG1(\"log2_diff_max_min_transform_block_size : %d\\n\", log2_diff_max_min_transform_block_size);\n  LOG1(\"max_transform_hierarchy_depth_inter : %d\\n\", max_transform_hierarchy_depth_inter);\n  LOG1(\"max_transform_hierarchy_depth_intra : %d\\n\", max_transform_hierarchy_depth_intra);\n  LOG1(\"scaling_list_enable_flag : %d\\n\", scaling_list_enable_flag);\n\n  if (scaling_list_enable_flag) {\n\n    LOG1(\"sps_scaling_list_data_present_flag : %d\\n\", sps_scaling_list_data_present_flag);\n    if (sps_scaling_list_data_present_flag) {\n\n      LOG0(\"scaling list logging output not implemented\");\n      //assert(0);\n      //scaling_list_data()\n    }\n  }\n\n  LOG1(\"amp_enabled_flag                    : %d\\n\", amp_enabled_flag);\n  LOG1(\"sample_adaptive_offset_enabled_flag : %d\\n\", sample_adaptive_offset_enabled_flag);\n  LOG1(\"pcm_enabled_flag                    : %d\\n\", pcm_enabled_flag);\n\n  if (pcm_enabled_flag) {\n    LOG1(\"pcm_sample_bit_depth_luma     : %d\\n\", pcm_sample_bit_depth_luma);\n    LOG1(\"pcm_sample_bit_depth_chroma   : %d\\n\", pcm_sample_bit_depth_chroma);\n    LOG1(\"log2_min_pcm_luma_coding_block_size : %d\\n\", log2_min_pcm_luma_coding_block_size);\n    LOG1(\"log2_diff_max_min_pcm_luma_coding_block_size : %d\\n\", log2_diff_max_min_pcm_luma_coding_block_size);\n    LOG1(\"pcm_loop_filter_disable_flag  : %d\\n\", pcm_loop_filter_disable_flag);\n  }\n\n  LOG1(\"num_short_term_ref_pic_sets : %d\\n\", ref_pic_sets.size());\n\n  for (int i = 0; i < ref_pic_sets.size(); i++) {\n    LOG1(\"ref_pic_set[ %2d ]: \",i);\n    dump_compact_short_term_ref_pic_set(&ref_pic_sets[i], 16, fh);\n  }\n\n  LOG1(\"long_term_ref_pics_present_flag : %d\\n\", long_term_ref_pics_present_flag);\n\n  if (long_term_ref_pics_present_flag) {\n\n    LOG1(\"num_long_term_ref_pics_sps : %d\\n\", num_long_term_ref_pics_sps);\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      LOG3(\"lt_ref_pic_poc_lsb_sps[%d] : %d   (used_by_curr_pic_lt_sps_flag=%d)\\n\",\n           i, lt_ref_pic_poc_lsb_sps[i], used_by_curr_pic_lt_sps_flag[i]);\n    }\n  }\n\n  LOG1(\"sps_temporal_mvp_enabled_flag      : %d\\n\", sps_temporal_mvp_enabled_flag);\n  LOG1(\"strong_intra_smoothing_enable_flag : %d\\n\", strong_intra_smoothing_enable_flag);\n  LOG1(\"vui_parameters_present_flag        : %d\\n\", vui_parameters_present_flag);\n\n  LOG1(\"sps_extension_present_flag    : %d\\n\", sps_extension_present_flag);\n  LOG1(\"sps_range_extension_flag      : %d\\n\", sps_range_extension_flag);\n  LOG1(\"sps_multilayer_extension_flag : %d\\n\", sps_multilayer_extension_flag);\n  LOG1(\"sps_extension_6bits           : %d\\n\", sps_extension_6bits);\n\n  LOG1(\"CtbSizeY     : %d\\n\", CtbSizeY);\n  LOG1(\"MinCbSizeY   : %d\\n\", MinCbSizeY);\n  LOG1(\"MaxCbSizeY   : %d\\n\", 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size));\n  LOG1(\"MinTBSizeY   : %d\\n\", 1<<log2_min_transform_block_size);\n  LOG1(\"MaxTBSizeY   : %d\\n\", 1<<(log2_min_transform_block_size + log2_diff_max_min_transform_block_size));\n\n  LOG1(\"PicWidthInCtbsY         : %d\\n\", PicWidthInCtbsY);\n  LOG1(\"PicHeightInCtbsY        : %d\\n\", PicHeightInCtbsY);\n  LOG1(\"SubWidthC               : %d\\n\", SubWidthC);\n  LOG1(\"SubHeightC              : %d\\n\", SubHeightC);\n\n  if (sps_range_extension_flag) {\n    range_extension.dump(fd);\n  }\n\n  if (vui_parameters_present_flag) {\n    vui.dump(fd);\n  }\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n  //#endif\n}\n\n\nstatic uint8_t default_ScalingList_4x4[16] = {\n  16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16\n};\n\nstatic uint8_t default_ScalingList_8x8_intra[64] = {\n  16,16,16,16,16,16,16,16,\n  16,16,17,16,17,16,17,18,\n  17,18,18,17,18,21,19,20,\n  21,20,19,21,24,22,22,24,\n  24,22,22,24,25,25,27,30,\n  27,25,25,29,31,35,35,31,\n  29,36,41,44,41,36,47,54,\n  54,47,65,70,65,88,88,115\n};\n\nstatic uint8_t default_ScalingList_8x8_inter[64] = {\n  16,16,16,16,16,16,16,16,\n  16,16,17,17,17,17,17,18,\n  18,18,18,18,18,20,20,20,\n  20,20,20,20,24,24,24,24,\n  24,24,24,24,25,25,25,25,\n  25,25,25,28,28,28,28,28,\n  28,33,33,33,33,33,41,41,\n  41,41,54,54,54,71,71,91\n};\n\n\nvoid fill_scaling_factor(uint8_t* scalingFactors, const uint8_t* sclist, int sizeId)\n{\n  const position* scan;\n  int width;\n  int subWidth;\n\n  switch (sizeId) {\n  case 0:\n    width=4;\n    subWidth=1;\n    scan = get_scan_order(2, 0 /* diag */);\n\n    for (int i=0;i<4*4;i++) {\n      scalingFactors[scan[i].x + width*scan[i].y] = sclist[i];\n    }\n    break;\n\n  case 1:\n    width=8;\n    subWidth=1;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      scalingFactors[scan[i].x + width*scan[i].y] = sclist[i];\n    }\n    break;\n\n  case 2:\n    width=8;\n    subWidth=2;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      for (int dy=0;dy<2;dy++)\n        for (int dx=0;dx<2;dx++)\n          {\n            int x = 2*scan[i].x+dx;\n            int y = 2*scan[i].y+dy;\n            scalingFactors[x+width*subWidth*y] = sclist[i];\n          }\n    }\n    break;\n\n  case 3:\n    width=8;\n    subWidth=4;\n    scan = get_scan_order(3, 0 /* diag */);\n\n    for (int i=0;i<8*8;i++) {\n      for (int dy=0;dy<4;dy++)\n        for (int dx=0;dx<4;dx++)\n          {\n            int x = 4*scan[i].x+dx;\n            int y = 4*scan[i].y+dy;\n            scalingFactors[x+width*subWidth*y] = sclist[i];\n          }\n    }\n    break;\n\n  default:\n    assert(0);\n    break;\n  }\n\n\n  // --- dump matrix ---\n\n#if 0\n  for (int y=0;y<width;y++) {\n    for (int x=0;x<width;x++)\n      printf(\"%d,\",scalingFactors[x*subWidth + width*subWidth*subWidth*y]);\n\n    printf(\"\\n\");\n  }\n#endif\n}\n\n\nde265_error read_scaling_list(bitreader* br, const seq_parameter_set* sps,\n                              scaling_list_data* sclist, bool inPPS)\n{\n  int dc_coeff[4][6];\n\n  for (int sizeId=0;sizeId<4;sizeId++) {\n    //int n = ((sizeId==3) ? 2 : 6);\n    uint8_t scaling_list[6][32*32];\n\n    for (int matrixId=0 ; matrixId<6 ; matrixId += (sizeId==3 ? 3 : 1)) {\n      uint8_t* curr_scaling_list = scaling_list[matrixId];\n      int scaling_list_dc_coef;\n\n      int canonicalMatrixId = matrixId;\n      if (sizeId==3 && matrixId==1) { canonicalMatrixId=3; }\n\n\n      //printf(\"----- matrix %d\\n\",matrixId);\n\n      char scaling_list_pred_mode_flag = get_bits(br,1);\n      if (!scaling_list_pred_mode_flag) {\n        int scaling_list_pred_matrix_id_delta = get_uvlc(br);\n        if (scaling_list_pred_matrix_id_delta == UVLC_ERROR ||\n            scaling_list_pred_matrix_id_delta > matrixId) {\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        //printf(\"scaling_list_pred_matrix_id_delta=%d\\n\", scaling_list_pred_matrix_id_delta);\n\n        dc_coeff[sizeId][matrixId] = 16;\n        scaling_list_dc_coef       = 16;\n\n        if (scaling_list_pred_matrix_id_delta==0) {\n          if (sizeId==0) {\n            memcpy(curr_scaling_list, default_ScalingList_4x4, 16);\n          }\n          else {\n            if (canonicalMatrixId<3)\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_intra,64); }\n            else\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_inter,64); }\n          }\n        }\n        else {\n          // TODO: CHECK: for sizeID=3 and the second matrix, should we have delta=1 or delta=3 ?\n          if (sizeId==3) { assert(scaling_list_pred_matrix_id_delta==1); }\n\n          int mID = matrixId - scaling_list_pred_matrix_id_delta;\n\n          int len = (sizeId == 0 ? 16 : 64);\n          memcpy(curr_scaling_list, scaling_list[mID], len);\n\n          scaling_list_dc_coef       = dc_coeff[sizeId][mID];\n          dc_coeff[sizeId][matrixId] = dc_coeff[sizeId][mID];\n        }\n      }\n      else {\n        int nextCoef=8;\n        int coefNum = (sizeId==0 ? 16 : 64);\n        if (sizeId>1) {\n          scaling_list_dc_coef = get_svlc(br);\n          if (scaling_list_dc_coef < -7 ||\n              scaling_list_dc_coef > 247) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          scaling_list_dc_coef += 8;\n          nextCoef=scaling_list_dc_coef;\n          dc_coeff[sizeId][matrixId] = scaling_list_dc_coef;\n        }\n        else {\n          scaling_list_dc_coef = 16;\n        }\n        //printf(\"DC = %d\\n\",scaling_list_dc_coef);\n\n        for (int i=0;i<coefNum;i++) {\n          int scaling_list_delta_coef = get_svlc(br);\n          if (scaling_list_delta_coef < -128 ||\n              scaling_list_delta_coef >  127) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          nextCoef = (nextCoef + scaling_list_delta_coef + 256) % 256;\n          curr_scaling_list[i] = nextCoef;\n          //printf(\"curr %d = %d\\n\",i,nextCoef);\n        }\n      }\n\n\n      // --- generate ScalingFactor arrays ---\n\n      switch (sizeId) {\n      case 0:\n        fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0], curr_scaling_list, 0);\n        break;\n\n      case 1:\n        fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId][0][0], curr_scaling_list, 1);\n        break;\n\n      case 2:\n        fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId][0][0], curr_scaling_list, 2);\n        sclist->ScalingFactor_Size2[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n\n      case 3:\n        fill_scaling_factor(&sclist->ScalingFactor_Size3[matrixId][0][0], curr_scaling_list, 3);\n        sclist->ScalingFactor_Size3[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n      }\n    }\n  }\n\n\n  // --- fill 32x32 matrices for chroma\n\n  const position* scan = get_scan_order(3, 0 /* diag */);\n\t\n  for (int matrixId=0;matrixId<6;matrixId++)\n    if (matrixId!=0 && matrixId!=3) {\n      for (int i=0;i<64;i++) {\n\tint x = scan[i].x;\n\tint y = scan[i].y;\n\tint v = sclist->ScalingFactor_Size1[matrixId][y][x];\n\n\tfor (int dy=0;dy<4;dy++)\n\t  for (int dx=0;dx<4;dx++) {\n\t    sclist->ScalingFactor_Size3[matrixId][4*y+dy][4*x+dx] = v;\n\t  }\n      }\n\n      sclist->ScalingFactor_Size3[matrixId][0][0] = sclist->ScalingFactor_Size1[matrixId][0][0];\n    }\n  \n  return DE265_OK;\n}\n\n\nde265_error write_scaling_list(CABAC_encoder& out, const seq_parameter_set* sps,\n                              scaling_list_data* sclist, bool inPPS)\n{\n  assert(false);\n  // TODO\n\n  return DE265_OK;\n}\n\n\nvoid set_default_scaling_lists(scaling_list_data* sclist)\n{\n  // 4x4\n\n  for (int matrixId=0;matrixId<6;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0],\n                        default_ScalingList_4x4, 0);\n  }\n\n  // 8x8\n\n  for (int matrixId=0;matrixId<3;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId+0][0][0],\n                        default_ScalingList_8x8_intra, 1);\n    fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId+3][0][0],\n                        default_ScalingList_8x8_inter, 1);\n  }\n\n  // 16x16\n\n  for (int matrixId=0;matrixId<3;matrixId++) {\n    fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId+0][0][0],\n                        default_ScalingList_8x8_intra, 2);\n    fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId+3][0][0],\n                        default_ScalingList_8x8_inter, 2);\n  }\n\n  // 32x32\n\n  fill_scaling_factor(&sclist->ScalingFactor_Size3[0][0][0],\n                      default_ScalingList_8x8_intra, 3);\n  fill_scaling_factor(&sclist->ScalingFactor_Size3[1][0][0],\n                      default_ScalingList_8x8_inter, 3);\n}\n\n\nde265_error seq_parameter_set::write(error_queue* errqueue, CABAC_encoder& out)\n{\n  out.write_bits(video_parameter_set_id, 4);\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  out.write_bits(sps_max_sub_layers-1, 3);\n\n  out.write_bit(sps_temporal_id_nesting_flag);\n\n  profile_tier_level_.write(out, sps_max_sub_layers);\n\n  out.write_uvlc(seq_parameter_set_id);\n\n\n  // --- encode chroma type ---\n\n  out.write_uvlc(chroma_format_idc);\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (chroma_format_idc == 3) {\n    out.write_bit(separate_colour_plane_flag);\n  }\n\n\n  // --- picture size ---\n\n  out.write_uvlc(pic_width_in_luma_samples);\n  out.write_uvlc(pic_height_in_luma_samples);\n\n  out.write_bit(conformance_window_flag);\n\n  if (conformance_window_flag) {\n    out.write_uvlc(conf_win_left_offset);\n    out.write_uvlc(conf_win_right_offset);\n    out.write_uvlc(conf_win_top_offset);\n    out.write_uvlc(conf_win_bottom_offset);\n  }\n\n\n  out.write_uvlc(bit_depth_luma-8);\n  out.write_uvlc(bit_depth_chroma-8);\n\n  out.write_uvlc(log2_max_pic_order_cnt_lsb-4);\n\n\n  // --- sub_layer_ordering_info ---\n\n  out.write_bit(sps_sub_layer_ordering_info_present_flag);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    if (sps_max_dec_pic_buffering[i] > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    out.write_uvlc(sps_max_dec_pic_buffering[i]-1);\n\n    // sps_max_num_reorder_pics[i]\n\n    out.write_uvlc(sps_max_num_reorder_pics[i]);\n\n\n    // sps_max_latency_increase[i]\n\n    out.write_uvlc(sps_max_latency_increase_plus1[i]);\n  }\n\n\n  out.write_uvlc(log2_min_luma_coding_block_size-3);\n  out.write_uvlc(log2_diff_max_min_luma_coding_block_size);\n  out.write_uvlc(log2_min_transform_block_size-2);\n  out.write_uvlc(log2_diff_max_min_transform_block_size);\n  out.write_uvlc(max_transform_hierarchy_depth_inter);\n  out.write_uvlc(max_transform_hierarchy_depth_intra);\n  out.write_bit(scaling_list_enable_flag);\n\n  if (scaling_list_enable_flag) {\n\n    out.write_bit(sps_scaling_list_data_present_flag);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=write_scaling_list(out,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n  }\n\n  out.write_bit(amp_enabled_flag);\n  out.write_bit(sample_adaptive_offset_enabled_flag);\n  out.write_bit(pcm_enabled_flag);\n  if (pcm_enabled_flag) {\n    out.write_bits(pcm_sample_bit_depth_luma  -1,4);\n    out.write_bits(pcm_sample_bit_depth_chroma-1,4);\n    out.write_uvlc(log2_min_pcm_luma_coding_block_size-3);\n    out.write_uvlc(log2_diff_max_min_pcm_luma_coding_block_size);\n    out.write_bit(pcm_loop_filter_disable_flag);\n  }\n\n  int num_short_term_ref_pic_sets = ref_pic_sets.size();\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  out.write_uvlc(num_short_term_ref_pic_sets);\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = write_short_term_ref_pic_set(errqueue,this,out,\n                                                &ref_pic_sets[i], i,\n                                                ref_pic_sets,\n                                                false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  out.write_bit(long_term_ref_pics_present_flag);\n\n  if (long_term_ref_pics_present_flag) {\n\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n    out.write_uvlc(num_long_term_ref_pics_sps);\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      out.write_bits(lt_ref_pic_poc_lsb_sps[i], log2_max_pic_order_cnt_lsb);\n      out.write_bit (used_by_curr_pic_lt_sps_flag[i]);\n    }\n  }\n\n  out.write_bit(sps_temporal_mvp_enabled_flag);\n  out.write_bit(strong_intra_smoothing_enable_flag);\n  out.write_bit(vui_parameters_present_flag);\n\n#if 0\n  if (vui_parameters_present_flag) {\n    assert(false);\n    /*\n      vui_parameters()\n        sps_extension_flag\n        u(1)\n        if( sps_extension_flag )\n          while( more_rbsp_data() )\n            sps_extension_data_flag\n              u(1)\n              rbsp_trailing_bits()\n    */\n  }\n#endif\n\n  out.write_bit(sps_extension_present_flag);\n\n#if 0\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  check_rbsp_trailing_bits(br);\n#endif\n\n  // --- compute derived values ---\n\n#if 0\n  BitDepth_Y   = bit_depth_luma;\n  QpBdOffset_Y = 6*(bit_depth_luma-8);\n  BitDepth_C   = bit_depth_chroma;\n  QpBdOffset_C = 6*(bit_depth_chroma-8);\n  Log2MinCbSizeY = log2_min_luma_coding_block_size;\n  Log2CtbSizeY = Log2MinCbSizeY + log2_diff_max_min_luma_coding_block_size;\n  MinCbSizeY = 1 << Log2MinCbSizeY;\n  CtbSizeY = 1 << Log2CtbSizeY;\n  PicWidthInMinCbsY = pic_width_in_luma_samples / MinCbSizeY;\n  PicWidthInCtbsY   = ceil_div(pic_width_in_luma_samples, CtbSizeY);\n  PicHeightInMinCbsY = pic_height_in_luma_samples / MinCbSizeY;\n  PicHeightInCtbsY   = ceil_div(pic_height_in_luma_samples,CtbSizeY);\n  PicSizeInMinCbsY   = PicWidthInMinCbsY * PicHeightInMinCbsY;\n  PicSizeInCtbsY = PicWidthInCtbsY * PicHeightInCtbsY;\n  PicSizeInSamplesY = pic_width_in_luma_samples * pic_height_in_luma_samples;\n  if (chroma_format_idc==0 || separate_colour_plane_flag) {\n    CtbWidthC  = 0;\n    CtbHeightC = 0;\n  }\n  else {\n    CtbWidthC  = CtbSizeY / SubWidthC;\n    CtbHeightC = CtbSizeY / SubHeightC;\n  }\n  Log2MinTrafoSize = log2_min_transform_block_size;\n  Log2MaxTrafoSize = log2_min_transform_block_size + log2_diff_max_min_transform_block_size;\n  Log2MinPUSize = Log2MinCbSizeY-1;\n  PicWidthInMinPUs  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinPUSize);\n  PicHeightInMinPUs = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinPUSize);\n  Log2MinIpcmCbSizeY = log2_min_pcm_luma_coding_block_size;\n  Log2MaxIpcmCbSizeY = (log2_min_pcm_luma_coding_block_size +\n                        log2_diff_max_min_pcm_luma_coding_block_size);\n  // the following are not in the standard\n  PicWidthInTbsY  = PicWidthInCtbsY  << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicHeightInTbsY = PicHeightInCtbsY << (Log2CtbSizeY - Log2MinTrafoSize);\n  PicSizeInTbsY = PicWidthInTbsY * PicHeightInTbsY;\n  sps_read = true;\n#endif\n\n  return DE265_OK;\n}\n\n\nde265_error sps_range_extension::read(error_queue* errqueue, bitreader* br)\n{\n  transform_skip_rotation_enabled_flag    = get_bits(br,1);\n  transform_skip_context_enabled_flag     = get_bits(br,1);\n  implicit_rdpcm_enabled_flag             = get_bits(br,1);\n  explicit_rdpcm_enabled_flag             = get_bits(br,1);\n  extended_precision_processing_flag      = get_bits(br,1);\n  intra_smoothing_disabled_flag           = get_bits(br,1);\n  high_precision_offsets_enabled_flag     = get_bits(br,1);\n  persistent_rice_adaptation_enabled_flag = get_bits(br,1);\n  cabac_bypass_alignment_enabled_flag     = get_bits(br,1);\n\n  return DE265_OK;\n}\n\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\nvoid sps_range_extension::dump(int fd) const\n{\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n  LOG0(\"----------------- SPS-range-extension -----------------\\n\");\n  LOG1(\"transform_skip_rotation_enabled_flag    : %d\\n\", transform_skip_rotation_enabled_flag);\n  LOG1(\"transform_skip_context_enabled_flag     : %d\\n\", transform_skip_context_enabled_flag);\n  LOG1(\"implicit_rdpcm_enabled_flag             : %d\\n\", implicit_rdpcm_enabled_flag);\n  LOG1(\"explicit_rdpcm_enabled_flag             : %d\\n\", explicit_rdpcm_enabled_flag);\n  LOG1(\"extended_precision_processing_flag      : %d\\n\", extended_precision_processing_flag);\n  LOG1(\"intra_smoothing_disabled_flag           : %d\\n\", intra_smoothing_disabled_flag);\n  LOG1(\"high_precision_offsets_enabled_flag     : %d\\n\", high_precision_offsets_enabled_flag);\n  LOG1(\"persistent_rice_adaptation_enabled_flag : %d\\n\", persistent_rice_adaptation_enabled_flag);\n  LOG1(\"cabac_bypass_alignment_enabled_flag     : %d\\n\", cabac_bypass_alignment_enabled_flag);\n}\n#undef LOG1\n#undef LOG0\n", "/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"vui.h\"\n#include \"decctx.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define READ_VLC_OFFSET(variable, vlctype, offset)   \\\n  if ((vlc = get_ ## vlctype(br)) == UVLC_ERROR) {   \\\n    errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);  \\\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; \\\n  } \\\n  variable = vlc + offset;\n\n#define READ_VLC(variable, vlctype)  READ_VLC_OFFSET(variable,vlctype,0)\n\n\n#define NUM_SAR_PRESETS 17\n\nstatic uint16_t sar_presets[NUM_SAR_PRESETS+1][2] = {\n  { 0,0 },\n  { 1,1 },\n  { 12,11 },\n  { 10,11 },\n  { 16,11 },\n  { 40,33 },\n  { 24,11 },\n  { 20,11 },\n  { 32,11 },\n  { 80,33 },\n  { 18,11 },\n  { 15,11 },\n  { 64,33 },\n  { 160,99 },\n  { 4,3 },\n  { 3,2 },\n  { 2,1 }\n};\n\n#define EXTENDED_SAR 255\n\n\nconst char* get_video_format_name(enum VideoFormat format)\n{\n  switch (format) {\n  case VideoFormat_Component: return \"component\";\n  case VideoFormat_PAL:       return \"PAL\";\n  case VideoFormat_NTSC:      return \"NTSC\";\n  case VideoFormat_SECAM:     return \"SECAM\";\n  case VideoFormat_MAC:       return \"MAC\";\n  default:                    return \"unspecified\";\n  }\n}\n\n\nvideo_usability_information::video_usability_information()\n{\n  aspect_ratio_info_present_flag = false;\n  sar_width  = 0;\n  sar_height = 0;\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = false;\n  overscan_appropriate_flag  = false;\n\n\n  // --- video signal type ---\n\n  video_signal_type_present_flag = false;\n  video_format = VideoFormat_Unspecified;\n  video_full_range_flag = false;\n  colour_description_present_flag = false;\n  colour_primaries = 2;\n  transfer_characteristics = 2;\n  matrix_coeffs = 2;\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = false;\n  chroma_sample_loc_type_top_field    = 0;\n  chroma_sample_loc_type_bottom_field = 0;\n\n  neutral_chroma_indication_flag = false;\n  field_seq_flag = false;\n  frame_field_info_present_flag = false;\n\n  // --- default display window ---\n\n  default_display_window_flag = false;\n  def_disp_win_left_offset   = 0;\n  def_disp_win_right_offset  = 0;\n  def_disp_win_top_offset    = 0;\n  def_disp_win_bottom_offset = 0;\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = false;\n  vui_num_units_in_tick = 0;\n  vui_time_scale = 0;\n\n  vui_poc_proportional_to_timing_flag = false;\n  vui_num_ticks_poc_diff_one = 1;\n\n\n  // --- hrd parameters ---\n\n  vui_hrd_parameters_present_flag = false;\n \n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = false;\n  tiles_fixed_structure_flag = false;\n  motion_vectors_over_pic_boundaries_flag = true;\n  restricted_ref_pic_lists_flag = false;\n  min_spatial_segmentation_idc = 0;\n  max_bytes_per_pic_denom   = 2;\n  max_bits_per_min_cu_denom = 1;\n  log2_max_mv_length_horizontal = 15;\n  log2_max_mv_length_vertical   = 15;\n}\n\n\nde265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps)\n{\n  int vlc;\n\n  nal_hrd_parameters_present_flag = get_bits(br, 1);\n  vcl_hrd_parameters_present_flag = get_bits(br, 1);\n\n  if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)\n  {\n    sub_pic_hrd_params_present_flag = get_bits(br, 1);\n    if (sub_pic_hrd_params_present_flag)\n    {\n      tick_divisor_minus2 = get_bits(br, 8);\n      du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5);\n      sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1);\n      dpb_output_delay_du_length_minus1 = get_bits(br, 5);\n    }\n    bit_rate_scale = get_bits(br, 4);\n    cpb_size_scale = get_bits(br, 4);\n\n\n    if (sub_pic_hrd_params_present_flag)\n    {\n      cpb_size_du_scale = get_bits(br, 4);\n    }\n    initial_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    au_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    dpb_output_delay_length_minus1 = get_bits(br, 5);\n  }\n  int  i, j, nalOrVcl;\n\n  for (i = 0; i < sps->sps_max_sub_layers; i++)\n  {\n    fixed_pic_rate_general_flag[i] = get_bits(br, 1);\n    if (!fixed_pic_rate_general_flag[i])\n    {\n      fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1);\n    }\n    else\n    {\n      fixed_pic_rate_within_cvs_flag[i] = true;\n    }\n\n    low_delay_hrd_flag[i] = 0;// Infered to be 0 when not present\n    cpb_cnt_minus1[i] = 0;    // Infered to be 0 when not present\n\n    if (fixed_pic_rate_within_cvs_flag[i])\n    {\n      READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0);\n    }\n    else\n    {\n      low_delay_hrd_flag[i] = get_bits(br, 1);\n    }\n    if (!low_delay_hrd_flag[i])\n    {\n      READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n      if (cpb_cnt_minus1[i] > 31) {\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)\n    {\n      if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) ||\n        ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag))\n      {\n        for (j = 0; j <= cpb_cnt_minus1[i]; j++)\n        {\n          READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0);\n\n          if (sub_pic_hrd_params_present_flag)\n          {\n            READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n            READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          }\n          cbr_flag[i][j][nalOrVcl] = get_bits(br, 1);\n        }\n      }\n    }\n  }\n  return DE265_OK;\n}\n\nde265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n      if (err) {\n\treturn err;\n      }\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}\n\n\nvoid video_usability_information::dump(int fd) const\n{\n  //#if (_MSC_VER >= 1500)\n  //#define LOG0(t) loginfo(LogHeaders, t)\n  //#define LOG1(t,d) loginfo(LogHeaders, t,d)\n  //#define LOG2(t,d1,d2) loginfo(LogHeaders, t,d1,d2)\n  //#define LOG3(t,d1,d2,d3) loginfo(LogHeaders, t,d1,d2,d3)\n\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n\n  LOG0(\"----------------- VUI -----------------\\n\");\n  LOG2(\"sample aspect ratio        : %d:%d\\n\", sar_width,sar_height);\n  LOG1(\"overscan_info_present_flag : %d\\n\", overscan_info_present_flag);\n  LOG1(\"overscan_appropriate_flag  : %d\\n\", overscan_appropriate_flag);\n\n  LOG1(\"video_signal_type_present_flag: %d\\n\", video_signal_type_present_flag);\n  if (video_signal_type_present_flag) {\n    LOG1(\"  video_format                : %s\\n\", get_video_format_name(video_format));\n    LOG1(\"  video_full_range_flag       : %d\\n\", video_full_range_flag);\n    LOG1(\"  colour_description_present_flag : %d\\n\", colour_description_present_flag);\n    LOG1(\"  colour_primaries            : %d\\n\", colour_primaries);\n    LOG1(\"  transfer_characteristics    : %d\\n\", transfer_characteristics);\n    LOG1(\"  matrix_coeffs               : %d\\n\", matrix_coeffs);\n  }\n\n  LOG1(\"chroma_loc_info_present_flag: %d\\n\", chroma_loc_info_present_flag);\n  if (chroma_loc_info_present_flag) {\n    LOG1(\"  chroma_sample_loc_type_top_field   : %d\\n\", chroma_sample_loc_type_top_field);\n    LOG1(\"  chroma_sample_loc_type_bottom_field: %d\\n\", chroma_sample_loc_type_bottom_field);\n  }\n\n  LOG1(\"neutral_chroma_indication_flag: %d\\n\", neutral_chroma_indication_flag);\n  LOG1(\"field_seq_flag                : %d\\n\", field_seq_flag);\n  LOG1(\"frame_field_info_present_flag : %d\\n\", frame_field_info_present_flag);\n\n  LOG1(\"default_display_window_flag   : %d\\n\", default_display_window_flag);\n  LOG1(\"  def_disp_win_left_offset    : %d\\n\", def_disp_win_left_offset);\n  LOG1(\"  def_disp_win_right_offset   : %d\\n\", def_disp_win_right_offset);\n  LOG1(\"  def_disp_win_top_offset     : %d\\n\", def_disp_win_top_offset);\n  LOG1(\"  def_disp_win_bottom_offset  : %d\\n\", def_disp_win_bottom_offset);\n\n  LOG1(\"vui_timing_info_present_flag  : %d\\n\", vui_timing_info_present_flag);\n  if (vui_timing_info_present_flag) {\n    LOG1(\"  vui_num_units_in_tick       : %d\\n\", vui_num_units_in_tick);\n    LOG1(\"  vui_time_scale              : %d\\n\", vui_time_scale);\n  }\n\n  LOG1(\"vui_poc_proportional_to_timing_flag : %d\\n\", vui_poc_proportional_to_timing_flag);\n  LOG1(\"vui_num_ticks_poc_diff_one          : %d\\n\", vui_num_ticks_poc_diff_one);\n\n  LOG1(\"vui_hrd_parameters_present_flag : %d\\n\", vui_hrd_parameters_present_flag);\n  if (vui_hrd_parameters_present_flag) {\n    //hrd_parameters vui_hrd_parameters;\n  }\n\n\n  // --- bitstream restriction ---\n\n  LOG1(\"bitstream_restriction_flag         : %d\\n\", bitstream_restriction_flag);\n  if (bitstream_restriction_flag) {\n    LOG1(\"  tiles_fixed_structure_flag       : %d\\n\", tiles_fixed_structure_flag);\n    LOG1(\"  motion_vectors_over_pic_boundaries_flag : %d\\n\", motion_vectors_over_pic_boundaries_flag);\n    LOG1(\"  restricted_ref_pic_lists_flag    : %d\\n\", restricted_ref_pic_lists_flag);\n    LOG1(\"  min_spatial_segmentation_idc     : %d\\n\", min_spatial_segmentation_idc);\n    LOG1(\"  max_bytes_per_pic_denom          : %d\\n\", max_bytes_per_pic_denom);\n    LOG1(\"  max_bits_per_min_cu_denom        : %d\\n\", max_bits_per_min_cu_denom);\n    LOG1(\"  log2_max_mv_length_horizontal    : %d\\n\", log2_max_mv_length_horizontal);\n    LOG1(\"  log2_max_mv_length_vertical      : %d\\n\", log2_max_mv_length_vertical);\n  }\n\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n  //#endif\n}\n"], "filenames": ["libde265/sps.cc", "libde265/vui.cc"], "buggy_code_start_loc": [438, 203], "buggy_code_end_loc": [439, 363], "fixing_code_start_loc": [438, 204], "fixing_code_end_loc": [442, 370], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release.", "other": {"cve": {"id": "CVE-2022-1253", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-06T12:15:09.170", "lastModified": "2023-02-11T13:15:17.253", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en heap en el repositorio de GitHub strukturag/libde265 anterior a la versi\u00f3n 1.0.8 inclusive. La correcci\u00f3n est\u00e1 establecida en el commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 pero a\u00fan no pertenece a una versi\u00f3n oficial"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:struktur:libde265:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.8", "matchCriteriaId": "87EE3855-2DCA-49A4-B664-5FB6D6722B4A"}]}]}], "references": [{"url": "https://github.com/strukturag/libde265/commit/8e89fe0e175d2870c39486fdd09250b230ec10b8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1-other-strukturag/libde265", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5346", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/strukturag/libde265/commit/8e89fe0e175d2870c39486fdd09250b230ec10b8"}}