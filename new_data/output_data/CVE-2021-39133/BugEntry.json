{"buggy_code": ["package rundeck.controllers\n\nimport com.dtolabs.rundeck.app.api.plugins.ApiPluginListProvider\nimport com.dtolabs.rundeck.app.support.PluginResourceReq\nimport com.dtolabs.rundeck.core.authorization.AuthContext\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport org.rundeck.app.authorization.AppAuthContextProcessor\nimport org.rundeck.app.spi.AuthorizedServicesProvider\nimport org.rundeck.core.auth.AuthConstants\nimport com.dtolabs.rundeck.core.plugins.PluginValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginAdapterUtility\nimport grails.converters.JSON\nimport groovy.transform.CompileStatic\nimport org.springframework.web.multipart.MultipartFile\nimport org.springframework.web.servlet.support.RequestContextUtils\nimport rundeck.services.FrameworkService\nimport rundeck.services.PluginApiService\nimport rundeck.services.PluginService\nimport rundeck.services.UiPluginService\nimport rundeck.services.feature.FeatureService\n\nimport java.text.SimpleDateFormat\n\nimport static org.springframework.http.HttpStatus.NOT_FOUND\n\nclass PluginController extends ControllerBase {\n    private static final String RELATIVE_PLUGIN_UPLOAD_DIR = \"var/tmp/pluginUpload\"\n    private static final SimpleDateFormat PLUGIN_DATE_FMT = new SimpleDateFormat(\"EEE MMM dd hh:mm:ss Z yyyy\")\n    UiPluginService uiPluginService\n    PluginService pluginService\n    PluginApiService pluginApiService\n    FrameworkService frameworkService\n    def featureService\n    AppAuthContextProcessor rundeckAuthContextProcessor\n    AuthorizedServicesProvider rundeckAuthorizedServicesProvider\n    def messageSource\n\n    def pluginIcon(PluginResourceReq resourceReq) {\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n        def profile = uiPluginService.getProfileFor(resourceReq.service, resourceReq.name)\n        if (!profile.icon) {\n            response.status = 404\n            return render(view: '/404')\n        }\n        resourceReq.path = profile.icon\n        pluginFile(resourceReq)\n    }\n\n    def pluginFile(PluginResourceReq resourceReq) {\n        if (!resourceReq.path) {\n            resourceReq.errors.rejectValue('path', 'blank')\n        }\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n        def istream = uiPluginService.openResourceForPlugin(resourceReq.service, resourceReq.name, resourceReq.path)\n        if (null == istream) {\n            response.status = 404\n            return render(view: '/404')\n        }\n\n        def format = servletContext.getMimeType(resourceReq.path)\n\n        sendResponse(format, istream)\n\n    }\n\n    def pluginMessages(PluginResourceReq resourceReq) {\n        if (!resourceReq.path) {\n            resourceReq.errors.rejectValue('path', 'blank')\n        }\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n\n        List<Locale> locales = [RequestContextUtils.getLocale(request)]\n\n        def stem = resourceReq.path.lastIndexOf(\".\") >= 0 ? resourceReq.path.substring(\n                0,\n                resourceReq.path.lastIndexOf(\".\")\n        ) : resourceReq.path\n\n        def suffix = resourceReq.path.lastIndexOf(\".\") >= 0 ? resourceReq.path.substring(\n                resourceReq.path.lastIndexOf(\".\")\n        ) : ''\n\n        if (!locales) {\n            locales = [Locale.getDefault(), null]//defaults\n        } else {\n            locales.add(Locale.getDefault())\n            locales.add(null)\n        }\n\n        InputStream istream\n        List<String> langs = locales.collect { Locale locale ->\n            locale ? [\n                    locale.toLanguageTag(),\n                    locale.language\n            ] : null\n        }.flatten()\n\n        for (String lang : langs) {\n            def newpath = stem + (lang ? '_' + lang.replaceAll('-', '_') : '') + suffix\n            istream = uiPluginService.openResourceForPlugin(resourceReq.service, resourceReq.name, newpath)\n            if (istream != null) {\n                break\n            }\n        }\n\n        if (null == istream) {\n            response.status = 404\n            return render(view: '/404')\n        }\n        if (resourceReq.path.endsWith(\".properties\") && response.format == 'json') {\n            //parse java .properties content and emit as json\n            def jprops = new Properties()\n\n            try {\n                def reader = new InputStreamReader(istream, 'UTF-8')\n                jprops.load(reader)\n            } catch (IOException e) {\n                response.status = 500\n                return respond([status: 500])\n            } finally {\n                istream.close()\n            }\n            return render(contentType: 'application/json', text: new HashMap(jprops) as JSON)\n        }\n\n        def format = servletContext.getMimeType(resourceReq.path)\n\n        sendResponse(format, istream)\n    }\n\n    def listPlugins() {\n        String service = params.service\n\n        def providers = []\n        pluginApiService.listPlugins().each { svc ->\n            if (service && service != svc.service)\n                return\n\n            svc.providers.each { p ->\n                ApiPluginListProvider provider = new ApiPluginListProvider([\n                        service: svc.service,\n                        artifactName: p.pluginName,\n                        name: p.name,\n                        id: p.pluginId,\n                        builtin: p.builtin,\n                        pluginVersion: p.pluginVersion,\n                        title: p.title,\n                        description: p.description,\n                        author: p.pluginAuthor,\n                        iconUrl: p.iconUrl,\n                        providerMetadata: p.providerMetadata,\n                ])\n\n                providers.add(provider)\n            }\n        }\n        respond(\n                providers,\n                [formats: ['json']]\n        )\n    }\n\n    def listPluginsByService() {\n        def services = []\n        pluginApiService.listPlugins().each { svc ->\n            def providers = []\n            svc.providers.each { p ->\n                def provider = [:]\n                provider.artifactName = p.pluginName\n                provider.name = p.name\n                provider.id = p.pluginId\n                provider.builtin = p.builtin\n                provider.pluginVersion = p.pluginVersion\n                provider.title = p.title\n                provider.description = p.description\n                provider.author = p.pluginAuthor\n                providers.add(provider)\n            }\n            services.add([service: svc.service, providers: providers])\n        }\n        render(services as JSON)\n    }\n\n    /**\n     *  detail about a plugin artifact, provider, and properties\n     * @return\n     */\n    def pluginDetail() {\n        String pluginName = params.name\n        String service = params.service\n        String appVer = servletContext.getAttribute('version.number')\n\n        def desc = null\n        def instance = null\n        if(service== \"UI\") {\n            desc = pluginService.getPluginDescriptor(pluginName, uiPluginService.uiPluginProviderService)?.description\n        } else {\n            def pDescriptor = pluginService.getPluginDescriptor(pluginName, service)\n            instance = pDescriptor?.instance\n            desc = pDescriptor?.description\n        }\n\n        if(!desc) {\n            def psvc = frameworkService.rundeckFramework.getService(service)\n            desc = psvc?.listDescriptions()?.find { it.name == pluginName }\n        }\n        if (!desc) {\n            response.status = 404\n            renderErrorView('Not found')\n            return\n        }\n        def meta = frameworkService.getRundeckFramework().getPluginManager().getPluginMetadata(service,pluginName)\n        def terseDesc = [:]\n        terseDesc.id = meta?.pluginId ?: desc.name.encodeAsSHA256().substring(0,12)\n        terseDesc.name = desc.name\n        terseDesc.title = uiPluginService.getPluginMessage(\n            service,\n            pluginName,\n            \"plugin.title\",\n            desc.title,\n            RequestContextUtils.getLocale(request)\n        )\n        terseDesc.desc = uiPluginService.getPluginMessage(\n            service,\n            pluginName,\n            'plugin.description',\n            desc.description,\n            RequestContextUtils.getLocale(request)\n        )\n        if(service != \"UI\") {\n            def profile = uiPluginService.getProfileFor(service, pluginName)\n            if (profile.icon) {\n                terseDesc.iconUrl = createLink(\n                        controller: 'plugin',\n                        action: 'pluginIcon',\n                        params: [service: service, name: pluginName]\n                )\n            }\n            if (profile.providerMetadata) {\n                terseDesc.providerMetadata = profile.providerMetadata\n            }\n        }\n        terseDesc.ver = meta?.pluginFileVersion ?: appVer\n        terseDesc.rundeckCompatibilityVersion = meta?.rundeckCompatibilityVersion ?: 'unspecified'\n        terseDesc.targetHostCompatibility = meta?.targetHostCompatibility ?: 'all'\n        terseDesc.license = meta?.pluginLicense ?: 'unspecified'\n        terseDesc.sourceLink = meta?.pluginSourceLink\n        terseDesc.thirdPartyDependencies = meta?.pluginThirdPartyDependencies\n\n        terseDesc.props = pluginApiService.pluginPropertiesAsMap(\n            service,\n            pluginName,\n            desc.properties\n        )\n        terseDesc.projectMapping = desc.propertiesMapping\n        terseDesc.fwkMapping = desc.fwkPropertiesMapping\n        if(instance) {\n            //Check for custom config vue component\n            def customConfigProp = PluginAdapterUtility.getCustomConfigAnnotation(instance)\n            if(customConfigProp) terseDesc.vueConfigComponent = customConfigProp.vueConfigurationComponent()\n        }\n        if(params.project) {\n            AuthContext auth = rundeckAuthContextProcessor.getAuthContextForSubjectAndProject(request.subject, params.project)\n            def services = rundeckAuthorizedServicesProvider.getServicesWith(auth)\n            def dynamicProps = pluginService.\n                getDynamicProperties(frameworkService.rundeckFramework, service, pluginName, params.project, services)\n            if (dynamicProps) {\n                terseDesc.dynamicProps = dynamicProps\n            }\n        }\n\n        render(terseDesc as JSON)\n    }\n\n\n    /**\n     * Validate plugin config input.  JSON body: '{\"config\": {}}', response:\n     * '{\"valid\":true/false,\"errors\":{..}}'\n     * @param service\n     * @param name\n     * @return\n     */\n    def pluginPropertiesValidateAjax(String service, String name) {\n        if (requireAjax(controller: 'menu', action: 'index')) {\n            return\n        }\n        if (requireParams(['service', 'name'])) {\n            return\n        }\n        Map config = [:]\n        if (request.method == 'POST' && request.format == 'json') {\n            config = request.JSON.config\n        }\n        config = ParamsUtil.cleanMap(config)\n        PropertyScope ignoredScope=null\n        if(params.ignoredScope){\n            try{\n                ignoredScope=PropertyScope.valueOf(params.ignoredScope.toString())\n            } catch (IllegalArgumentException e) {\n                response.status = 400\n                return respond(\n                    [status: 400, formats: ['json']],\n                    (Object) [\n                        error: g.message(\n                            code: 'request.error.invalidrequest.message',\n                            args: [params.ignoredScope]\n                        )\n                    ]\n                )\n            }\n\n        }\n        def validation = pluginService.validatePluginConfig(service, name, config, ignoredScope)\n        if(!validation){\n            response.status=404\n\n            return render(contentType: 'application/json') {\n                valid false\n                delegate.error ('Provider not found for '+service+': '+name)\n            }\n        }\n        def errorsMap = validation.report.errors\n        def decomp = ParamsUtil.decomposeMap(errorsMap)\n//        System.err.println(\"config: $config, errors: $errorsMap, decomp: $decomp\")\n        render(contentType: 'application/json') {\n            valid validation.valid\n            delegate.errors decomp\n        }\n    }\n\n    /**\n     * List the installed plugin descriptions for a selected Service name\n     * @param project\n     * @param service\n     * @return\n     */\n    def pluginServiceDescriptions(String service) {\n        if (requireAjax(controller: 'menu', action: 'index')) {\n            return\n        }\n        if (requireParams(['service'])) {\n            return\n        }\n        Class serviceType\n        try {\n            serviceType = pluginService.getPluginTypeByService(service)\n        } catch (IllegalArgumentException e) {\n            return render(\n                [message: g.message(code: 'request.error.notfound.title')] as JSON,\n                status: NOT_FOUND,\n                contentType: 'application/json'\n            )\n        }\n        def descriptions = pluginService.listPlugins(serviceType)\n        def data = descriptions.values()?.description?.sort { a, b -> a.name <=> b.name }?.collect {desc->\n            def descMap = [\n                name       : desc.name,\n                title      : uiPluginService.getPluginMessage(\n                    service,\n                    desc.name,\n                    'plugin.title',\n                    desc.title ?: desc.name,\n                    RequestContextUtils.getLocale(request)\n                ),\n                description: uiPluginService.getPluginMessage(\n                    service,\n                    desc.name,\n                    'plugin.description',\n                    desc.description,\n                    RequestContextUtils.getLocale(request)\n                )\n            ]\n            def profile = uiPluginService.getProfileFor(service, desc.name)\n            if (profile.icon) {\n                descMap.iconUrl = createLink(\n                    controller: 'plugin',\n                    action: 'pluginIcon',\n                    params: [service: service, name: desc.name]\n                )\n            }\n            if (profile.providerMetadata) {\n                descMap.providerMetadata = profile.providerMetadata\n            }\n            descMap\n        }\n        def singularMessage = message(code: \"framework.service.${service}.label\", default: service)?.toString()\n        render(contentType: 'application/json') {\n            delegate.service service\n            delegate.descriptions data\n            labels(\n                singular: singularMessage,\n                indexed: message(\n                    code: \"framework.service.${service}.label.indexed\",\n                    default: singularMessage + ' {0}'\n                ),\n                plural: message(code: \"framework.service.${service}.label.plural\", default: singularMessage),\n                addButton: message(code: \"framework.service.${service}.add.title\", default: 'Add ' + singularMessage),\n                )\n        }\n    }\n\n    @CompileStatic\n    private def sendResponse(String contentType, InputStream stream) {\n        try {\n            response.contentType = contentType\n            response.outputStream << stream.bytes\n            response.flushBuffer()\n        } finally {\n            stream.close()\n        }\n    }\n\n    def uploadPlugin() {\n\n        if(featureService.featurePresent(Features.PLUGIN_SECURITY)){\n            renderErrorCodeAsJson(\"plugin.error.unauthorized.upload\")\n            return\n        }\n\n        AuthContext authContext = rundeckAuthContextProcessor.getAuthContextForSubject(session.subject)\n        boolean authorized = rundeckAuthContextProcessor.authorizeApplicationResourceType(authContext,\n                                                          \"system\",\n                                                          AuthConstants.ACTION_ADMIN)\n        if (!authorized) {\n            renderErrorCodeAsJson(\"request.error.unauthorized.title\")\n            return\n        }\n        if(!params.pluginFile || params.pluginFile.isEmpty()) {\n            renderErrorCodeAsJson(\"plugin.error.missing.upload.file\")\n            return\n        }\n        ensureUploadLocation()\n        File tmpFile = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR+\"/\"+params.pluginFile.originalFilename)\n        if(tmpFile.exists()) tmpFile.delete()\n        tmpFile << ((MultipartFile)params.pluginFile).inputStream\n        def errors = validateAndCopyPlugin(params.pluginFile.originalFilename, tmpFile)\n        tmpFile.delete()\n        def msg = [:]\n        if(!errors.isEmpty()) {\n            msg.err = errors.join(\", \")\n        } else {\n            msg.msg = \"done\"\n        }\n\n        render msg as JSON\n    }\n\n    def installPlugin() {\n        AuthContext authContext = rundeckAuthContextProcessor.getAuthContextForSubject(session.subject)\n        boolean authorized = rundeckAuthContextProcessor.authorizeApplicationResourceType(authContext,\n                                                                               \"system\",\n                                                                               AuthConstants.ACTION_ADMIN)\n        if (!authorized) {\n            renderErrorCodeAsJson(\"request.error.unauthorized.title\")\n            return\n        }\n        if(!params.pluginUrl) {\n            renderErrorCodeAsJson(\"plugin.error.missing.url\")\n            return\n        }\n        if(!params.pluginUrl.contains(\"/\")) {\n            renderErrorCodeAsJson(\"plugin.error.invalid.url\")\n            return\n        }\n        def parts = params.pluginUrl.split(\"/\")\n        String urlString = params.pluginUrl.startsWith(\"/\") ? \"file:\"+params.pluginUrl : params.pluginUrl\n\n        ensureUploadLocation()\n        File tmpFile = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR+\"/\"+parts.last())\n        if(tmpFile.exists()) tmpFile.delete()\n        try {\n            URI.create(urlString).toURL().withInputStream { inputStream ->\n                tmpFile << inputStream\n            }\n        } catch(Exception ex) {\n            def err  = [err: \"Failed to fetch plugin from URL. Error: ${ex.message}\"]\n            render err as JSON\n            return\n        }\n        def errors = validateAndCopyPlugin(parts.last(),tmpFile)\n        tmpFile.delete()\n        def msg = [:]\n        if(!errors.isEmpty()) {\n            msg.err = errors.join(\", \")\n        } else {\n            msg.msg = \"done\"\n        }\n        render msg as JSON\n    }\n\n    private def validateAndCopyPlugin(String pluginName, File tmpPluginFile) {\n        def errors = []\n        if(!PluginValidator.validate(tmpPluginFile)) {\n            errors.add(\"plugin.error.invalid.plugin\")\n        } else {\n            File newPlugin = new File(frameworkService.getRundeckFramework().libextDir,pluginName)\n            if(newPlugin.exists()) {\n                newPlugin.delete()\n            }\n            tmpPluginFile.withInputStream { inStream ->\n                newPlugin << inStream\n            }\n            flash.installSuccess = true\n        }\n        return errors\n    }\n\n    private String renderErrorCodeAsJson(String errCode) {\n        def err  = [err: messageSource.getMessage(errCode,null,RequestContextUtils.getLocale(request))]\n        render err as JSON\n    }\n\n    private def ensureUploadLocation() {\n        File uploadDir = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR)\n        if(!uploadDir.exists()) {\n            uploadDir.mkdirs()\n        }\n    }\n\n    private long toEpoch(String dateString) {\n        PLUGIN_DATE_FMT.parse(dateString).time\n    }\n}\n", "<template>\n  <div>\n    <div class=\"col-xs-12\">\n      <div class=\"input-group input-group-lg\">\n        <span class=\"input-group-addon\">Plugin URL</span>\n        <input\n          style=\"border: 1px solid #d6d7d6;background: #fff; border-right:0; padding-left:1em;\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"https://someurl.com/some-path/some-plugin.jar\"\n          v-model=\"pluginURL\"\n        >\n        <span class=\"input-group-btn\">\n          <a @click=\"submitUrl\" class=\"btn btn-default\" type=\"button\">Install</a>\n        </span>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nimport axios from \"axios\";\nexport default {\n  name: \"PluginUrlUploadForm\",\n  data() {\n    return {\n      pluginURL: \"\"\n    };\n  },\n  methods: {\n    submitUrl() {\n      this.$store.dispatch(\"overlay/openOverlay\", {\n        loadingMessage: \"Installing\",\n        loadingSpinner: true\n      });\n      axios({\n        method: \"post\",\n        headers: {\n          \"x-rundeck-ajax\": true\n        },\n        url: `${window._rundeck.rdBase}plugin/installPlugin?pluginUrl=${\n          this.pluginURL\n        }`,\n        withCredentials: true\n      }).then(response => {\n        this.$store.dispatch(\"overlay/openOverlay\");\n        if (response.data.err) {\n          this.$alert({\n            title: \"Error Uploading\",\n            content: response.data.err\n          });\n        } else {\n          this.$alert({\n            title: \"Plugin Installed\",\n            content: response.data.msg\n          });\n        }\n      });\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n</style>\n", "<template>\n  <div>\n    <div class=\"col-xs-12\">\n      <div class=\"input-group input-group-lg\">\n        <span class=\"input-group-addon\" id=\"sizing-addon1\">Choose a file</span>\n\n        <span class=\"control-fileupload\">\n          <span class=\"label\">{{fileName}}</span>\n          <input\n            class\n            type=\"file\"\n            id=\"files\"\n            ref=\"files\"\n            multiple\n            v-on:change=\"handleFilesUploads()\"\n          >\n        </span>\n\n        <span class=\"input-group-btn\">\n          <button class=\"btn btn-default\" v-on:click=\"submitFiles()\">Install</button>\n        </span>\n      </div>\n      <!-- /input-group -->\n    </div>\n  </div>\n</template>\n<script>\nimport { mapState, mapActions } from \"vuex\";\nimport axios from \"axios\";\nexport default {\n  name: \"UploadPluginForm\",\n  computed: {\n    fileName() {\n      if (this.files && this.files[0] && this.files[0].name) {\n        return this.files[0].name;\n      } else {\n        return \"\";\n      }\n    }\n  },\n  methods: {\n    submitFiles() {\n      // Initialize the form data and iteate over any\n      // file sent over appending the files to the form data.\n      let formData = new FormData();\n      for (var i = 0; i < this.files.length; i++) {\n        let file = this.files[i];\n\n        formData.append(\"pluginFile\", file);\n      }\n      this.$store.dispatch(\"overlay/openOverlay\", {\n        loadingMessage: \"Installing\",\n        loadingSpinner: true\n      });\n      axios({\n        method: \"post\",\n        headers: {\n          \"x-rundeck-ajax\": true,\n          \"Content-Type\": \"multipart/form-data\"\n        },\n        data: formData,\n        url: `${window._rundeck.rdBase}plugin/uploadPlugin`,\n        withCredentials: true\n      }).then(response => {\n        this.$store.dispatch(\"overlay/openOverlay\");\n        if (response.data.err) {\n          this.$alert({\n            title: \"Error Uploading\",\n            content: response.data.err\n          });\n        } else {\n          this.$alert({\n            title: \"Plugin Installed\",\n            content: response.data.msg\n          });\n        }\n      });\n    },\n    handleFilesUploads() {\n      this.files = this.$refs.files.files;\n    }\n  },\n  data() {\n    return {\n      files: \"\"\n    };\n  },\n  created() {}\n};\n</script>\n<style lang=\"scss\" scoped>\n/* input [type = file]\n----------------------------------------------- */\n\ninput[type=\"file\"] {\n  display: block !important;\n  right: 1px;\n  top: 1px;\n  height: 46px;\n  opacity: 0;\n  width: 100%;\n  background: none;\n  position: absolute;\n  overflow: hidden;\n  z-index: 2;\n}\n\n.control-fileupload {\n  display: block;\n  border: 1px solid #d6d7d6;\n  background: #fff;\n  // border-radius: 4px;\n  width: 100%;\n  height: 46px;\n  line-height: 36px;\n  padding: 0px 10px 2px 10px;\n  overflow: hidden;\n  position: relative;\n  border-right: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  &:before,\n  input,\n  .label {\n    cursor: pointer !important;\n  }\n  /* File upload button */\n  &:before {\n    padding: 4px 12px;\n    margin-bottom: 0;\n    margin-right: 10px;\n    margin-top: 4px;\n    font-size: 14px;\n    line-height: 20px;\n    color: #333333;\n    text-align: center;\n    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);\n    vertical-align: middle;\n    cursor: pointer;\n    background-color: #f5f5f5;\n    background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);\n    background-repeat: repeat-x;\n    border: 1px solid #cccccc;\n    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n    border-bottom-color: #b3b3b3;\n    border-radius: 4px;\n    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),\n      0 1px 2px rgba(0, 0, 0, 0.05);\n    transition: color 0.2s ease;\n    content: \"Browse\";\n    display: block;\n    position: absolute;\n    z-index: 1;\n    top: 2px;\n    right: 2px;\n    line-height: 20px;\n    text-align: center;\n  }\n  &:hover,\n  &:focus {\n    &:before {\n      color: #333333;\n      background-color: #e6e6e6;\n      color: #333333;\n      text-decoration: none;\n      background-position: 0 -15px;\n      transition: background-position 0.2s ease-out;\n    }\n  }\n\n  .label {\n    line-height: 35px;\n    color: #999999;\n    font-size: 20px;\n    font-weight: normal;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    position: relative;\n    z-index: 1;\n    margin-right: 90px;\n    margin-bottom: 0px;\n    margin-top: 4px;\n    cursor: text;\n  }\n}\n</style>\n", "package rundeck.controllers\n\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.common.Framework\nimport com.dtolabs.rundeck.core.common.IFramework\nimport com.dtolabs.rundeck.core.config.FeatureService\nimport com.dtolabs.rundeck.core.plugins.PluginMetadata\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.plugins.rundeck.UIPlugin\nimport com.dtolabs.rundeck.plugins.util.DescriptionBuilder\nimport com.dtolabs.rundeck.server.plugins.services.UIPluginProviderService\nimport grails.util.Described\nimport org.apache.logging.log4j.core.config.plugins.util.PluginManager\nimport org.grails.plugins.testing.GrailsMockMultipartFile\nimport com.dtolabs.rundeck.core.plugins.ServiceProviderLoader\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.plugins.notification.NotificationPlugin\nimport com.dtolabs.rundeck.core.plugins.DescribedPlugin\nimport grails.testing.web.controllers.ControllerUnitTest\nimport org.rundeck.app.authorization.AppAuthContextProcessor\nimport rundeck.services.FrameworkService\nimport rundeck.services.PluginApiService\nimport rundeck.services.PluginApiServiceSpec\nimport rundeck.services.PluginService\nimport rundeck.services.UiPluginService\nimport rundeck.services.FrameworkService\nimport spock.lang.Specification\n\nclass PluginControllerSpec extends Specification implements ControllerUnitTest<PluginController> {\n\n    String fakePluginId = \"fake\".encodeAsSHA256().substring(0,12)\n    static final String PLUGIN_FILE = \"rundeck-ui-plugin-examples-1.0-plugin.zip\"\n\n    File uploadTestBaseDir = File.createTempDir()\n    File uploadTestTargetDir = File.createTempDir()\n\n    static final String TEST_JSON1 = '''{\"config\":{\"actions._indexes\":\"dbd3da9c_1\",\"actions._type\":\"list\",\n\"actions.entry[dbd3da9c_1].type\":\"testaction1\",\"actions.entry[dbd3da9c_1].config.actions._type\":\"embedded\",\n\"actions.entry[dbd3da9c_1].config.actions.type\":\"\",\"actions.entry[dbd3da9c_1].config.actions.config.stringvalue\":\"asdf\",\n\"actions.entry[dbd3da9c_1].config.actions\":\"{stringvalue=asdf}\"},\"report\":{}}'''\n\n    void \"validate\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, expected, null) >>\n            new ValidatedPlugin(valid: true, report: Validator.buildReport().build())\n            0 * controller.pluginService._(*_)\n            response.status == 200\n            response.json != null\n            response.json.valid == true\n        where:\n            json            | expected\n            '{\"config\":{}}' | [:]\n            TEST_JSON1      | [actions: [[type: 'testaction1', config: [actions: [stringvalue: 'asdf']]]]]\n    }\n    void \"validate ignored scope\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            params.ignoredScope=scopeText\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, _,expectScope) >>\n            new ValidatedPlugin(valid: true, report: Validator.buildReport().build())\n            0 * controller.pluginService._(*_)\n            response.status == 200\n        where:\n            json       | scopeText   | expectScope\n            TEST_JSON1 | null        | null\n            TEST_JSON1 | 'Instance'  | PropertyScope.Instance\n            TEST_JSON1 | 'Project'   | PropertyScope.Project\n            TEST_JSON1 | 'Framework' | PropertyScope.Framework\n    }\n    void \"validate ignored scope invalid\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            params.ignoredScope=scopeText\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            0 * controller.pluginService._(*_)\n            response.status == 400\n            response.json!=null\n            response.json.error=='request.error.invalidrequest.message'\n\n        where:\n            json       | scopeText\n            TEST_JSON1 | 'wrong'\n            TEST_JSON1 | 'other'\n    }\n    void \"pluginPropertiesValidateAjax missing plugin\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, expected, null) >> null\n            0 * controller.pluginService._(*_)\n            response.status == 404\n            response.json != null\n            response.json.valid == false\n        where:\n            json            | expected\n            '{\"config\":{}}' | [:]\n            TEST_JSON1      | [actions: [[type: 'testaction1', config: [actions: [stringvalue: 'asdf']]]]]\n    }\n\n    void \"plugin detail\"() {\n        given:\n        controller.pluginService = Mock(PluginService)\n        def fwksvc = Mock(FrameworkService)\n        def fwk = Mock(Framework)\n        fwksvc.getRundeckFramework() >> fwk\n        fwk.getPluginManager() >> Mock(ServiceProviderLoader)\n        controller.frameworkService = fwksvc\n        controller.uiPluginService = Mock(UiPluginService)\n        controller.pluginApiService = Mock(PluginApiService)\n\n        when:\n        def fakePluginDesc = new PluginApiServiceSpec.FakePluginDescription()\n        params.name = \"fake\"\n        params.service = \"Notification\"\n        1 * controller.pluginService.getPluginDescriptor(\"fake\", 'Notification') >> new DescribedPlugin(null,fakePluginDesc,\"fake\")\n        1 * controller.frameworkService.rundeckFramework.pluginManager.getPluginMetadata(_,_) >> new PluginApiServiceSpec.FakePluginMetadata()\n        1 * controller.uiPluginService.getPluginMessage('Notification','fake','plugin.title','Fake Plugin',_)>>'plugin.title'\n        1 * controller.uiPluginService.getPluginMessage('Notification','fake','plugin.description','This is the best fake plugin',_)>>'plugin.description'\n        1 * controller.uiPluginService.getProfileFor('Notification','fake')>>[:]\n        1* controller.pluginApiService.pluginPropertiesAsMap('Notification','fake',_)>>[\n                [name:'prop1',apiData:true],\n                [name:'password',apiData:true]\n        ]\n        controller.pluginDetail()\n        def rj = response.json\n        def rp1 = rj.props.find { it.name == \"prop1\" }\n        def rp2 = rj.props.find { it.name == \"password\" }\n\n        then:\n        rj.id == fakePluginId\n        rj.name == \"fake\"\n        rj.title == 'plugin.title'\n        rj.desc == 'plugin.description'\n        rp1.name == \"prop1\"\n        rp1.apiData\n        rp2.name == \"password\"\n        rp2.apiData\n    }\n\n    void \"plugin detail no plugin or framework service\"() {\n        given:\n            controller.pluginService = Mock(PluginService)\n            def fwksvc = Mock(FrameworkService)\n            def fwk = Mock(Framework)\n            fwksvc.getRundeckFramework() >> fwk\n            fwk.getPluginManager() >> Mock(ServiceProviderLoader)\n            controller.frameworkService = fwksvc\n            controller.uiPluginService = Mock(UiPluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n\n        when:\n            def fakePluginDesc = new PluginApiServiceSpec.FakePluginDescription()\n            params.name = \"fake\"\n            params.service = \"Notification\"\n\n            controller.pluginDetail()\n\n        then:\n            response.status == 404\n            1 * controller.pluginService.getPluginDescriptor(\"fake\", 'Notification') >> null\n            1 * controller.frameworkService.rundeckFramework.getService('Notification') >> null\n\n    }\n\n    def \"plugin list filters by service\"() {\n        given:\n            params.service = a\n            controller.pluginService = Mock(PluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n            controller.uiPluginService = Mock(UiPluginService)\n\n            def plugins = [\n                    [\n                        service: 'WebhookEvent',\n                        providers: [\n                                [:],\n                                [:]],\n                    ],\n                    [\n                        service: 'Foo',\n                        providers: [[:]]\n                    ]\n            ]\n\n        when:\n            def result = controller.listPlugins()\n        then:\n            1 * controller.pluginApiService.listPlugins() >> plugins\n            response.json.size() == b\n\n        where:\n            a                | b\n            null             | 3\n            'WebhookEvent'   | 2\n    }\n\n    def \"plugin service descriptions\"() {\n        given:\n        controller.pluginService = Mock(PluginService)\n        controller.uiPluginService = Mock(UiPluginService)\n        def fakePluginDesc1 = new PluginApiServiceSpec.FakePluginDescription()\n        fakePluginDesc1.name = 'XYZfake'\n        def fakePluginDesc2 = new PluginApiServiceSpec.FakePluginDescription()\n        fakePluginDesc2.name = 'ABCfake'\n        request.addHeader('x-rundeck-ajax', 'true')\n        params.service = svcName\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label.indexed\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label.indexed\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label.plural\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label.plural\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.add.title\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.add.title\"\n        )\n        when:\n        def result = controller.pluginServiceDescriptions(svcName)\n        then:\n        1 * controller.pluginService.getPluginTypeByService(svcName) >> NotificationPlugin\n        1 * controller.pluginService.listPlugins(NotificationPlugin) >> [\n                XYZfake: new DescribedPlugin<NotificationPlugin>(null, fakePluginDesc1, 'XYZfake'),\n                ABCfake: new DescribedPlugin<NotificationPlugin>(null, fakePluginDesc2, 'ABCfake')\n            ]\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'ABCfake', 'plugin.title', _, _) >>\n            'ABC title'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'ABCfake', 'plugin.description', _, _) >>\n            'ABC desc'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'XYZfake', 'plugin.title', _, _) >>\n            'XYZ title'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'XYZfake', 'plugin.description', _, _) >>\n            'XYZ desc'\n            1 * controller.uiPluginService.getProfileFor(svcName,'XYZfake')>>[:]\n            1 * controller.uiPluginService.getProfileFor(svcName,'ABCfake')>>[:]\n            def json = response.json\n            json.service == svcName\n            json.descriptions\n            json.descriptions == [\n                [\n                        name       : 'ABCfake',\n                        title      : 'ABC title',\n                        description: 'ABC desc'\n                ],\n                [\n                        name       : 'XYZfake',\n                        title      : 'XYZ title',\n                        description: 'XYZ desc'\n                ],\n        ]\n        json.labels\n        json.labels.singular == 'framework.service.Notification.label'\n        json.labels.indexed == 'framework.service.Notification.label.indexed'\n        json.labels.plural == 'framework.service.Notification.label.plural'\n        json.labels.addButton == 'framework.service.Notification.add.title'\n\n        where:\n        svcName        | _\n        'Notification' | _\n    }\n\n    void \"upload plugin no file specified\"() {\n        setup:\n        controller.featureService = Mock(FeatureService)\n        controller.frameworkService = Mock(FrameworkService)\n\n        controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.missing.upload.file\",Locale.ENGLISH,\"A plugin file must be specified\")\n\n        when:\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.featureService.featurePresent(_) >> false\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"err\":\"A plugin file must be specified\"}'\n    }\n\n    void \"upload plugin, plugin security enabled\"() {\n        setup:\n        controller.featureService = Mock(FeatureService)\n        controller.frameworkService = Mock(FrameworkService)\n\n        controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.unauthorized.upload\",Locale.ENGLISH,\"Unable to upload plugins\")\n\n        when:\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.featureService.featurePresent(_) >> true\n        response.text == '{\"err\":\"Unable to upload plugins\"}'\n    }\n\n    void \"install plugin no plugin url specified\"() {\n        setup:\n        controller.frameworkService = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.missing.url\",Locale.ENGLISH,\"The plugin URL is required\")\n\n        when:\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"err\":\"The plugin URL is required\"}'\n    }\n\n    void \"upload plugin\"() {\n        setup:\n        File uploaded = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n        controller.featureService = Mock(FeatureService)\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n\n\n        when:\n        !uploaded.exists()\n        def pluginInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(PLUGIN_FILE)\n        request.addFile(new GrailsMockMultipartFile(\"pluginFile\",PLUGIN_FILE,\"application/octet-stream\",pluginInputStream))\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.featureService.featurePresent(_) >> false\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"msg\":\"done\"}'\n        uploaded.exists()\n\n        cleanup:\n        uploaded.delete()\n    }\n\n    void \"install plugin\"() {\n        setup:\n        File installed = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n\n        when:\n        !installed.exists()\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"msg\":\"done\"}'\n        installed.exists()\n\n        cleanup:\n        installed.delete()\n    }\n\n    void \"unauthorized install plugin fails\"() {\n        setup:\n        controller.frameworkService = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"request.error.unauthorized.title\",Locale.ENGLISH,\"Unauthorized\")\n\n        when:\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> false\n        response.text == '{\"err\":\"Unauthorized\"}'\n    }\n\n    def \"plugin detail for ui plugin\"() {\n        given:\n\n            params.name = 'test1'\n            params.service = 'UI'\n            controller.pluginService = Mock(PluginService)\n            controller.uiPluginService = Mock(UiPluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n            def uiPluginProviderService = Mock(UIPluginProviderService)\n            controller.frameworkService = Mock(FrameworkService)\n\n            def plugin = Mock(UIPlugin)\n            def description = DescriptionBuilder.builder().name('test1').build()\n            def pluginMeta = Mock(PluginMetadata)\n        when:\n            controller.pluginDetail()\n        then:\n            response.status == 200\n\n            response.contentType.startsWith 'application/json'\n\n            1 * controller.uiPluginService.getUiPluginProviderService() >> uiPluginProviderService\n            1 * controller.uiPluginService.getPluginMessage('UI', 'test1', 'plugin.title', _, _) >> 'ptitle'\n            1 * controller.uiPluginService.getPluginMessage('UI', 'test1', 'plugin.description', _, _) >>\n            'pdescription'\n            1 * controller.pluginApiService.pluginPropertiesAsMap('UI', 'test1', _) >> []\n            1 * controller.pluginService.getPluginDescriptor('test1', uiPluginProviderService) >>\n            new DescribedPlugin<UIPlugin>(plugin, description, 'test1')\n            1 * controller.frameworkService.getRundeckFramework() >> Mock(IFramework) {\n                1 * getPluginManager() >> Mock(ServiceProviderLoader) {\n                    1 * getPluginMetadata('UI', 'test1') >> pluginMeta\n                }\n            }\n    }\n}\n"], "fixing_code": ["package rundeck.controllers\n\nimport com.dtolabs.rundeck.app.api.plugins.ApiPluginListProvider\nimport com.dtolabs.rundeck.app.support.PluginResourceReq\nimport com.dtolabs.rundeck.core.authorization.AuthContext\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport org.rundeck.app.authorization.AppAuthContextProcessor\nimport org.rundeck.app.spi.AuthorizedServicesProvider\nimport org.rundeck.core.auth.AuthConstants\nimport com.dtolabs.rundeck.core.plugins.PluginValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginAdapterUtility\nimport grails.converters.JSON\nimport groovy.transform.CompileStatic\nimport org.springframework.web.multipart.MultipartFile\nimport org.springframework.web.multipart.MultipartHttpServletRequest\nimport org.springframework.web.servlet.support.RequestContextUtils\nimport rundeck.services.ApiService\nimport rundeck.services.FrameworkService\nimport rundeck.services.PluginApiService\nimport rundeck.services.PluginService\nimport rundeck.services.UiPluginService\n\nimport javax.servlet.http.HttpServletResponse\nimport java.text.SimpleDateFormat\n\nimport static org.springframework.http.HttpStatus.NOT_FOUND\n\nclass PluginController extends ControllerBase {\n    private static final String RELATIVE_PLUGIN_UPLOAD_DIR = \"var/tmp/pluginUpload\"\n    private static final SimpleDateFormat PLUGIN_DATE_FMT = new SimpleDateFormat(\"EEE MMM dd hh:mm:ss Z yyyy\")\n    static def allowedMethods = [\n        installPlugin: ['POST'],\n        uploadPlugin: ['POST']\n    ]\n    UiPluginService uiPluginService\n    PluginService pluginService\n    PluginApiService pluginApiService\n    FrameworkService frameworkService\n    ApiService apiService\n    def featureService\n    AppAuthContextProcessor rundeckAuthContextProcessor\n    AuthorizedServicesProvider rundeckAuthorizedServicesProvider\n    def messageSource\n\n    def pluginIcon(PluginResourceReq resourceReq) {\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n        def profile = uiPluginService.getProfileFor(resourceReq.service, resourceReq.name)\n        if (!profile.icon) {\n            response.status = 404\n            return render(view: '/404')\n        }\n        resourceReq.path = profile.icon\n        pluginFile(resourceReq)\n    }\n\n    def pluginFile(PluginResourceReq resourceReq) {\n        if (!resourceReq.path) {\n            resourceReq.errors.rejectValue('path', 'blank')\n        }\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n        def istream = uiPluginService.openResourceForPlugin(resourceReq.service, resourceReq.name, resourceReq.path)\n        if (null == istream) {\n            response.status = 404\n            return render(view: '/404')\n        }\n\n        def format = servletContext.getMimeType(resourceReq.path)\n\n        sendResponse(format, istream)\n\n    }\n\n    def pluginMessages(PluginResourceReq resourceReq) {\n        if (!resourceReq.path) {\n            resourceReq.errors.rejectValue('path', 'blank')\n        }\n        if (resourceReq.hasErrors()) {\n            request.errors = resourceReq.errors\n            response.status = 400\n            return render(view: '/common/error')\n        }\n\n        List<Locale> locales = [RequestContextUtils.getLocale(request)]\n\n        def stem = resourceReq.path.lastIndexOf(\".\") >= 0 ? resourceReq.path.substring(\n                0,\n                resourceReq.path.lastIndexOf(\".\")\n        ) : resourceReq.path\n\n        def suffix = resourceReq.path.lastIndexOf(\".\") >= 0 ? resourceReq.path.substring(\n                resourceReq.path.lastIndexOf(\".\")\n        ) : ''\n\n        if (!locales) {\n            locales = [Locale.getDefault(), null]//defaults\n        } else {\n            locales.add(Locale.getDefault())\n            locales.add(null)\n        }\n\n        InputStream istream\n        List<String> langs = locales.collect { Locale locale ->\n            locale ? [\n                    locale.toLanguageTag(),\n                    locale.language\n            ] : null\n        }.flatten()\n\n        for (String lang : langs) {\n            def newpath = stem + (lang ? '_' + lang.replaceAll('-', '_') : '') + suffix\n            istream = uiPluginService.openResourceForPlugin(resourceReq.service, resourceReq.name, newpath)\n            if (istream != null) {\n                break\n            }\n        }\n\n        if (null == istream) {\n            response.status = 404\n            return render(view: '/404')\n        }\n        if (resourceReq.path.endsWith(\".properties\") && response.format == 'json') {\n            //parse java .properties content and emit as json\n            def jprops = new Properties()\n\n            try {\n                def reader = new InputStreamReader(istream, 'UTF-8')\n                jprops.load(reader)\n            } catch (IOException e) {\n                response.status = 500\n                return respond([status: 500])\n            } finally {\n                istream.close()\n            }\n            return render(contentType: 'application/json', text: new HashMap(jprops) as JSON)\n        }\n\n        def format = servletContext.getMimeType(resourceReq.path)\n\n        sendResponse(format, istream)\n    }\n\n    def listPlugins() {\n        String service = params.service\n\n        def providers = []\n        pluginApiService.listPlugins().each { svc ->\n            if (service && service != svc.service)\n                return\n\n            svc.providers.each { p ->\n                ApiPluginListProvider provider = new ApiPluginListProvider([\n                        service: svc.service,\n                        artifactName: p.pluginName,\n                        name: p.name,\n                        id: p.pluginId,\n                        builtin: p.builtin,\n                        pluginVersion: p.pluginVersion,\n                        title: p.title,\n                        description: p.description,\n                        author: p.pluginAuthor,\n                        iconUrl: p.iconUrl,\n                        providerMetadata: p.providerMetadata,\n                ])\n\n                providers.add(provider)\n            }\n        }\n        respond(\n                providers,\n                [formats: ['json']]\n        )\n    }\n\n    def listPluginsByService() {\n        def services = []\n        pluginApiService.listPlugins().each { svc ->\n            def providers = []\n            svc.providers.each { p ->\n                def provider = [:]\n                provider.artifactName = p.pluginName\n                provider.name = p.name\n                provider.id = p.pluginId\n                provider.builtin = p.builtin\n                provider.pluginVersion = p.pluginVersion\n                provider.title = p.title\n                provider.description = p.description\n                provider.author = p.pluginAuthor\n                providers.add(provider)\n            }\n            services.add([service: svc.service, providers: providers])\n        }\n        render(services as JSON)\n    }\n\n    /**\n     *  detail about a plugin artifact, provider, and properties\n     * @return\n     */\n    def pluginDetail() {\n        String pluginName = params.name\n        String service = params.service\n        String appVer = servletContext.getAttribute('version.number')\n\n        def desc = null\n        def instance = null\n        if(service== \"UI\") {\n            desc = pluginService.getPluginDescriptor(pluginName, uiPluginService.uiPluginProviderService)?.description\n        } else {\n            def pDescriptor = pluginService.getPluginDescriptor(pluginName, service)\n            instance = pDescriptor?.instance\n            desc = pDescriptor?.description\n        }\n\n        if(!desc) {\n            def psvc = frameworkService.rundeckFramework.getService(service)\n            desc = psvc?.listDescriptions()?.find { it.name == pluginName }\n        }\n        if (!desc) {\n            response.status = 404\n            renderErrorView('Not found')\n            return\n        }\n        def meta = frameworkService.getRundeckFramework().getPluginManager().getPluginMetadata(service,pluginName)\n        def terseDesc = [:]\n        terseDesc.id = meta?.pluginId ?: desc.name.encodeAsSHA256().substring(0,12)\n        terseDesc.name = desc.name\n        terseDesc.title = uiPluginService.getPluginMessage(\n            service,\n            pluginName,\n            \"plugin.title\",\n            desc.title,\n            RequestContextUtils.getLocale(request)\n        )\n        terseDesc.desc = uiPluginService.getPluginMessage(\n            service,\n            pluginName,\n            'plugin.description',\n            desc.description,\n            RequestContextUtils.getLocale(request)\n        )\n        if(service != \"UI\") {\n            def profile = uiPluginService.getProfileFor(service, pluginName)\n            if (profile.icon) {\n                terseDesc.iconUrl = createLink(\n                        controller: 'plugin',\n                        action: 'pluginIcon',\n                        params: [service: service, name: pluginName]\n                )\n            }\n            if (profile.providerMetadata) {\n                terseDesc.providerMetadata = profile.providerMetadata\n            }\n        }\n        terseDesc.ver = meta?.pluginFileVersion ?: appVer\n        terseDesc.rundeckCompatibilityVersion = meta?.rundeckCompatibilityVersion ?: 'unspecified'\n        terseDesc.targetHostCompatibility = meta?.targetHostCompatibility ?: 'all'\n        terseDesc.license = meta?.pluginLicense ?: 'unspecified'\n        terseDesc.sourceLink = meta?.pluginSourceLink\n        terseDesc.thirdPartyDependencies = meta?.pluginThirdPartyDependencies\n\n        terseDesc.props = pluginApiService.pluginPropertiesAsMap(\n            service,\n            pluginName,\n            desc.properties\n        )\n        terseDesc.projectMapping = desc.propertiesMapping\n        terseDesc.fwkMapping = desc.fwkPropertiesMapping\n        if(instance) {\n            //Check for custom config vue component\n            def customConfigProp = PluginAdapterUtility.getCustomConfigAnnotation(instance)\n            if(customConfigProp) terseDesc.vueConfigComponent = customConfigProp.vueConfigurationComponent()\n        }\n        if(params.project) {\n            AuthContext auth = rundeckAuthContextProcessor.getAuthContextForSubjectAndProject(request.subject, params.project)\n            def services = rundeckAuthorizedServicesProvider.getServicesWith(auth)\n            def dynamicProps = pluginService.\n                getDynamicProperties(frameworkService.rundeckFramework, service, pluginName, params.project, services)\n            if (dynamicProps) {\n                terseDesc.dynamicProps = dynamicProps\n            }\n        }\n\n        render(terseDesc as JSON)\n    }\n\n\n    /**\n     * Validate plugin config input.  JSON body: '{\"config\": {}}', response:\n     * '{\"valid\":true/false,\"errors\":{..}}'\n     * @param service\n     * @param name\n     * @return\n     */\n    def pluginPropertiesValidateAjax(String service, String name) {\n        if (requireAjax(controller: 'menu', action: 'index')) {\n            return\n        }\n        if (requireParams(['service', 'name'])) {\n            return\n        }\n        Map config = [:]\n        if (request.method == 'POST' && request.format == 'json') {\n            config = request.JSON.config\n        }\n        config = ParamsUtil.cleanMap(config)\n        PropertyScope ignoredScope=null\n        if(params.ignoredScope){\n            try{\n                ignoredScope=PropertyScope.valueOf(params.ignoredScope.toString())\n            } catch (IllegalArgumentException e) {\n                response.status = 400\n                return respond(\n                    [status: 400, formats: ['json']],\n                    (Object) [\n                        error: g.message(\n                            code: 'request.error.invalidrequest.message',\n                            args: [params.ignoredScope]\n                        )\n                    ]\n                )\n            }\n\n        }\n        def validation = pluginService.validatePluginConfig(service, name, config, ignoredScope)\n        if(!validation){\n            response.status=404\n\n            return render(contentType: 'application/json') {\n                valid false\n                delegate.error ('Provider not found for '+service+': '+name)\n            }\n        }\n        def errorsMap = validation.report.errors\n        def decomp = ParamsUtil.decomposeMap(errorsMap)\n//        System.err.println(\"config: $config, errors: $errorsMap, decomp: $decomp\")\n        render(contentType: 'application/json') {\n            valid validation.valid\n            delegate.errors decomp\n        }\n    }\n\n    /**\n     * List the installed plugin descriptions for a selected Service name\n     * @param project\n     * @param service\n     * @return\n     */\n    def pluginServiceDescriptions(String service) {\n        if (requireAjax(controller: 'menu', action: 'index')) {\n            return\n        }\n        if (requireParams(['service'])) {\n            return\n        }\n        Class serviceType\n        try {\n            serviceType = pluginService.getPluginTypeByService(service)\n        } catch (IllegalArgumentException e) {\n            return render(\n                [message: g.message(code: 'request.error.notfound.title')] as JSON,\n                status: NOT_FOUND,\n                contentType: 'application/json'\n            )\n        }\n        def descriptions = pluginService.listPlugins(serviceType)\n        def data = descriptions.values()?.description?.sort { a, b -> a.name <=> b.name }?.collect {desc->\n            def descMap = [\n                name       : desc.name,\n                title      : uiPluginService.getPluginMessage(\n                    service,\n                    desc.name,\n                    'plugin.title',\n                    desc.title ?: desc.name,\n                    RequestContextUtils.getLocale(request)\n                ),\n                description: uiPluginService.getPluginMessage(\n                    service,\n                    desc.name,\n                    'plugin.description',\n                    desc.description,\n                    RequestContextUtils.getLocale(request)\n                )\n            ]\n            def profile = uiPluginService.getProfileFor(service, desc.name)\n            if (profile.icon) {\n                descMap.iconUrl = createLink(\n                    controller: 'plugin',\n                    action: 'pluginIcon',\n                    params: [service: service, name: desc.name]\n                )\n            }\n            if (profile.providerMetadata) {\n                descMap.providerMetadata = profile.providerMetadata\n            }\n            descMap\n        }\n        def singularMessage = message(code: \"framework.service.${service}.label\", default: service)?.toString()\n        render(contentType: 'application/json') {\n            delegate.service service\n            delegate.descriptions data\n            labels(\n                singular: singularMessage,\n                indexed: message(\n                    code: \"framework.service.${service}.label.indexed\",\n                    default: singularMessage + ' {0}'\n                ),\n                plural: message(code: \"framework.service.${service}.label.plural\", default: singularMessage),\n                addButton: message(code: \"framework.service.${service}.add.title\", default: 'Add ' + singularMessage),\n                )\n        }\n    }\n\n    @CompileStatic\n    private def sendResponse(String contentType, InputStream stream) {\n        try {\n            response.contentType = contentType\n            response.outputStream << stream.bytes\n            response.flushBuffer()\n        } finally {\n            stream.close()\n        }\n    }\n    protected boolean requireAjaxFormToken(){\n        boolean valid = false\n        withForm {\n            g.refreshFormTokensHeader()\n            valid = true\n        }.invalidToken {\n        }\n        if (!valid) {\n            apiService.renderErrorFormat(response, [\n                status: HttpServletResponse.SC_BAD_REQUEST,\n                code: 'request.error.invalidtoken.message',\n            ])\n        }\n        return valid\n    }\n\n    def uploadPlugin() {\n\n        if(featureService.featurePresent(Features.PLUGIN_SECURITY)){\n            renderErrorCodeAsJson(\"plugin.error.unauthorized.upload\")\n            return\n        }\n        if(!requireAjaxFormToken()){\n            return\n        }\n\n        AuthContext authContext = rundeckAuthContextProcessor.getAuthContextForSubject(session.subject)\n        boolean authorized = rundeckAuthContextProcessor.authorizeApplicationResourceType(authContext,\n                                                          \"system\",\n                                                          AuthConstants.ACTION_ADMIN)\n        if (!authorized) {\n            renderErrorCodeAsJson(\"request.error.unauthorized.title\")\n            return\n        }\n        if(!(request instanceof MultipartHttpServletRequest && request.getFile('pluginFile'))){\n            renderErrorCodeAsJson(\"plugin.error.missing.upload.file\")\n            return\n        }\n        def file = request.getFile('pluginFile')\n        ensureUploadLocation()\n        File tmpFile = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR+\"/\"+file.originalFilename)\n        if(tmpFile.exists()) tmpFile.delete()\n        tmpFile << file.inputStream\n        def errors = validateAndCopyPlugin(file.originalFilename, tmpFile)\n        tmpFile.delete()\n        def msg = [:]\n        if(!errors.isEmpty()) {\n            msg.err = errors.join(\", \")\n        } else {\n            msg.msg = \"done\"\n        }\n\n        render msg as JSON\n    }\n\n    def installPlugin() {\n        if(!requireAjaxFormToken()){\n            return\n        }\n        AuthContext authContext = rundeckAuthContextProcessor.getAuthContextForSubject(session.subject)\n        boolean authorized = rundeckAuthContextProcessor.authorizeApplicationResourceType(authContext,\n                                                                               \"system\",\n                                                                               AuthConstants.ACTION_ADMIN)\n        if (!authorized) {\n            renderErrorCodeAsJson(\"request.error.unauthorized.title\")\n            return\n        }\n        if(!params.pluginUrl) {\n            renderErrorCodeAsJson(\"plugin.error.missing.url\")\n            return\n        }\n        if(!params.pluginUrl.contains(\"/\")) {\n            renderErrorCodeAsJson(\"plugin.error.invalid.url\")\n            return\n        }\n        def parts = params.pluginUrl.split(\"/\")\n        String urlString = params.pluginUrl.startsWith(\"/\") ? \"file:\"+params.pluginUrl : params.pluginUrl\n\n        ensureUploadLocation()\n        File tmpFile = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR+\"/\"+parts.last())\n        if(tmpFile.exists()) tmpFile.delete()\n        try {\n            URI.create(urlString).toURL().withInputStream { inputStream ->\n                tmpFile << inputStream\n            }\n        } catch(Exception ex) {\n            def err  = [err: \"Failed to fetch plugin from URL. Error: ${ex.message}\"]\n            render err as JSON\n            return\n        }\n        def errors = validateAndCopyPlugin(parts.last(),tmpFile)\n        tmpFile.delete()\n        def msg = [:]\n        if(!errors.isEmpty()) {\n            msg.err = errors.join(\", \")\n        } else {\n            msg.msg = \"done\"\n        }\n        render msg as JSON\n    }\n\n    private def validateAndCopyPlugin(String pluginName, File tmpPluginFile) {\n        def errors = []\n        if(!PluginValidator.validate(tmpPluginFile)) {\n            errors.add(\"plugin.error.invalid.plugin\")\n        } else {\n            File newPlugin = new File(frameworkService.getRundeckFramework().libextDir,pluginName)\n            if(newPlugin.exists()) {\n                newPlugin.delete()\n            }\n            tmpPluginFile.withInputStream { inStream ->\n                newPlugin << inStream\n            }\n            flash.installSuccess = true\n        }\n        return errors\n    }\n\n    private String renderErrorCodeAsJson(String errCode) {\n        def err  = [err: messageSource.getMessage(errCode,null,RequestContextUtils.getLocale(request))]\n        render err as JSON\n    }\n\n    private def ensureUploadLocation() {\n        File uploadDir = new File(frameworkService.getRundeckFramework().baseDir,RELATIVE_PLUGIN_UPLOAD_DIR)\n        if(!uploadDir.exists()) {\n            uploadDir.mkdirs()\n        }\n    }\n\n    private long toEpoch(String dateString) {\n        PLUGIN_DATE_FMT.parse(dateString).time\n    }\n}\n", "<template>\n  <div>\n    <div class=\"col-xs-12\">\n      <div class=\"input-group input-group-lg\">\n        <span class=\"input-group-addon\">Plugin URL</span>\n        <input\n          style=\"border: 1px solid #d6d7d6;background: #fff; border-right:0; padding-left:1em;\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"https://someurl.com/some-path/some-plugin.jar\"\n          v-model=\"pluginURL\"\n        >\n        <span class=\"input-group-btn\">\n          <a @click=\"submitUrl\" class=\"btn btn-default\" type=\"button\">Install</a>\n        </span>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nimport {client} from \"@rundeck/ui-trellis/lib/modules/rundeckClient\"\nexport default {\n  name: \"PluginUrlUploadForm\",\n  data() {\n    return {\n      pluginURL: \"\"\n    };\n  },\n  methods: {\n    submitUrl() {\n      this.$store.dispatch(\"overlay/openOverlay\", {\n        loadingMessage: \"Installing\",\n        loadingSpinner: true\n      });\n      client.sendRequest({\n        baseUrl: window._rundeck.rdBase,\n        pathTemplate: `/plugin/installPlugin`,\n        queryParameters: {\n          pluginUrl: this.pluginURL\n        },\n        method: 'POST'\n      }).then(response => {\n        if (response.status === 200) {\n          this.$store.dispatch(\"overlay/openOverlay\");\n          if (response.parsedBody.err) {\n            this.$alert({\n              title: \"Error Uploading\",\n              content: response.parsedBody.err\n            });\n          } else {\n            this.$alert({\n              title: \"Plugin Installed\",\n              content: response.parsedBody.msg\n            });\n          }\n        }else if (response.status >= 300) {\n          this.$store.dispatch(\"overlay/openOverlay\");\n          let message = `Error: ${response.status}`\n          if (response.parsedBody && response.parsedBody.message) {\n            message = response.parsedBody.message\n          }else if (response.parsedBody && response.parsedBody.error) {\n            message = response.parsedBody.error\n          }\n          this.$alert({\n            title: \"Error Uploading\",\n            content: message\n          });\n        }\n      });\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n</style>\n", "<template>\n  <div>\n    <div class=\"col-xs-12\">\n      <div class=\"input-group input-group-lg\">\n        <span class=\"input-group-addon\" id=\"sizing-addon1\">Choose a file</span>\n\n        <span class=\"control-fileupload\">\n          <span class=\"label\">{{fileName}}</span>\n          <input\n            class\n            type=\"file\"\n            id=\"files\"\n            ref=\"files\"\n            multiple\n            v-on:change=\"handleFilesUploads()\"\n          >\n        </span>\n\n        <span class=\"input-group-btn\">\n          <button class=\"btn btn-default\" v-on:click=\"submitFiles()\">Install</button>\n        </span>\n      </div>\n      <!-- /input-group -->\n    </div>\n  </div>\n</template>\n<script>\nimport { mapState, mapActions } from \"vuex\";\nimport axios from \"axios\";\nimport {client} from \"@rundeck/ui-trellis/lib/modules/rundeckClient\"\nexport default {\n  name: \"UploadPluginForm\",\n  computed: {\n    fileName() {\n      if (this.files && this.files[0] && this.files[0].name) {\n        return this.files[0].name;\n      } else {\n        return \"\";\n      }\n    }\n  },\n  methods: {\n    submitFiles() {\n      // Initialize the form data and iteate over any\n      // file sent over appending the files to the form data.\n      let formData = new FormData();\n      for (var i = 0; i < this.files.length; i++) {\n        let file = this.files[i];\n\n        formData.append(\"pluginFile\", file);\n      }\n      this.$store.dispatch(\"overlay/openOverlay\", {\n        loadingMessage: \"Installing\",\n        loadingSpinner: true\n      });\n      //use axios instead of RundeckClient, to allow multipart form with file upload\n      axios({\n        method: \"post\",\n        headers: {\n          \"x-rundeck-ajax\": true,\n          \"Content-Type\": \"multipart/form-data\",\n          \"X-RUNDECK-TOKEN-KEY\": client.token,\n          \"X-RUNDECK-TOKEN-URI\": client.uri\n        },\n        data: formData,\n        url: `${window._rundeck.rdBase}plugin/uploadPlugin`,\n        withCredentials: true\n      }).then(response => {\n        this.$store.dispatch(\"overlay/openOverlay\");\n        client.token = response.headers['x-rundeck-token-key'] || client.token\n        client.uri = response.headers['x-rundeck-token-uri'] || client.uri\n        if (response.data.err) {\n          this.$alert({\n            title: \"Error Uploading\",\n            content: response.data.err\n          });\n        } else {\n          this.$alert({\n            title: \"Plugin Installed\",\n            content: response.data.msg\n          });\n        }\n      }).catch(result=>{\n        this.$store.dispatch(\"overlay/openOverlay\");\n        let message=result.message\n        if(result.response && result.response.data && result.response.data.message){\n          message=result.response.data.message\n        }\n        this.$alert({\n          title: \"Error Uploading\",\n          content: message\n        });\n      });\n    },\n    handleFilesUploads() {\n      this.files = this.$refs.files.files;\n    }\n  },\n  data() {\n    return {\n      files: \"\"\n    };\n  },\n  created() {}\n};\n</script>\n<style lang=\"scss\" scoped>\n/* input [type = file]\n----------------------------------------------- */\n\ninput[type=\"file\"] {\n  display: block !important;\n  right: 1px;\n  top: 1px;\n  height: 46px;\n  opacity: 0;\n  width: 100%;\n  background: none;\n  position: absolute;\n  overflow: hidden;\n  z-index: 2;\n}\n\n.control-fileupload {\n  display: block;\n  border: 1px solid #d6d7d6;\n  background: #fff;\n  // border-radius: 4px;\n  width: 100%;\n  height: 46px;\n  line-height: 36px;\n  padding: 0px 10px 2px 10px;\n  overflow: hidden;\n  position: relative;\n  border-right: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  &:before,\n  input,\n  .label {\n    cursor: pointer !important;\n  }\n  /* File upload button */\n  &:before {\n    padding: 4px 12px;\n    margin-bottom: 0;\n    margin-right: 10px;\n    margin-top: 4px;\n    font-size: 14px;\n    line-height: 20px;\n    color: #333333;\n    text-align: center;\n    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);\n    vertical-align: middle;\n    cursor: pointer;\n    background-color: #f5f5f5;\n    background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);\n    background-repeat: repeat-x;\n    border: 1px solid #cccccc;\n    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n    border-bottom-color: #b3b3b3;\n    border-radius: 4px;\n    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),\n      0 1px 2px rgba(0, 0, 0, 0.05);\n    transition: color 0.2s ease;\n    content: \"Browse\";\n    display: block;\n    position: absolute;\n    z-index: 1;\n    top: 2px;\n    right: 2px;\n    line-height: 20px;\n    text-align: center;\n  }\n  &:hover,\n  &:focus {\n    &:before {\n      color: #333333;\n      background-color: #e6e6e6;\n      color: #333333;\n      text-decoration: none;\n      background-position: 0 -15px;\n      transition: background-position 0.2s ease-out;\n    }\n  }\n\n  .label {\n    line-height: 35px;\n    color: #999999;\n    font-size: 20px;\n    font-weight: normal;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    position: relative;\n    z-index: 1;\n    margin-right: 90px;\n    margin-bottom: 0px;\n    margin-top: 4px;\n    cursor: text;\n  }\n}\n</style>\n", "package rundeck.controllers\n\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.common.Framework\nimport com.dtolabs.rundeck.core.common.IFramework\nimport com.dtolabs.rundeck.core.config.FeatureService\nimport com.dtolabs.rundeck.core.plugins.PluginMetadata\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.plugins.rundeck.UIPlugin\nimport com.dtolabs.rundeck.plugins.util.DescriptionBuilder\nimport com.dtolabs.rundeck.server.plugins.services.UIPluginProviderService\nimport grails.util.Described\nimport org.apache.logging.log4j.core.config.plugins.util.PluginManager\nimport org.grails.plugins.testing.GrailsMockMultipartFile\nimport com.dtolabs.rundeck.core.plugins.ServiceProviderLoader\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.plugins.notification.NotificationPlugin\nimport com.dtolabs.rundeck.core.plugins.DescribedPlugin\nimport grails.testing.web.controllers.ControllerUnitTest\nimport org.grails.web.servlet.mvc.SynchronizerTokensHolder\nimport org.rundeck.app.authorization.AppAuthContextProcessor\nimport rundeck.UtilityTagLib\nimport rundeck.services.ApiService\nimport rundeck.services.FrameworkService\nimport rundeck.services.PluginApiService\nimport rundeck.services.PluginApiServiceSpec\nimport rundeck.services.PluginService\nimport rundeck.services.UiPluginService\nimport rundeck.services.FrameworkService\nimport spock.lang.Specification\nimport spock.lang.Unroll\n\nimport javax.servlet.http.HttpServletResponse\n\nclass PluginControllerSpec extends Specification implements ControllerUnitTest<PluginController> {\n\n    String fakePluginId = \"fake\".encodeAsSHA256().substring(0,12)\n    static final String PLUGIN_FILE = \"rundeck-ui-plugin-examples-1.0-plugin.zip\"\n\n    File uploadTestBaseDir = File.createTempDir()\n    File uploadTestTargetDir = File.createTempDir()\n\n    static final String TEST_JSON1 = '''{\"config\":{\"actions._indexes\":\"dbd3da9c_1\",\"actions._type\":\"list\",\n\"actions.entry[dbd3da9c_1].type\":\"testaction1\",\"actions.entry[dbd3da9c_1].config.actions._type\":\"embedded\",\n\"actions.entry[dbd3da9c_1].config.actions.type\":\"\",\"actions.entry[dbd3da9c_1].config.actions.config.stringvalue\":\"asdf\",\n\"actions.entry[dbd3da9c_1].config.actions\":\"{stringvalue=asdf}\"},\"report\":{}}'''\n\n    def setup(){\n        grailsApplication.config.clear()\n        grailsApplication.config.rundeck.security.useHMacRequestTokens = 'false'\n        mockTagLib(UtilityTagLib)\n    }\n\n    void \"validate\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, expected, null) >>\n            new ValidatedPlugin(valid: true, report: Validator.buildReport().build())\n            0 * controller.pluginService._(*_)\n            response.status == 200\n            response.json != null\n            response.json.valid == true\n        where:\n            json            | expected\n            '{\"config\":{}}' | [:]\n            TEST_JSON1      | [actions: [[type: 'testaction1', config: [actions: [stringvalue: 'asdf']]]]]\n    }\n    void \"validate ignored scope\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            params.ignoredScope=scopeText\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, _,expectScope) >>\n            new ValidatedPlugin(valid: true, report: Validator.buildReport().build())\n            0 * controller.pluginService._(*_)\n            response.status == 200\n        where:\n            json       | scopeText   | expectScope\n            TEST_JSON1 | null        | null\n            TEST_JSON1 | 'Instance'  | PropertyScope.Instance\n            TEST_JSON1 | 'Project'   | PropertyScope.Project\n            TEST_JSON1 | 'Framework' | PropertyScope.Framework\n    }\n    void \"validate ignored scope invalid\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            params.ignoredScope=scopeText\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            0 * controller.pluginService._(*_)\n            response.status == 400\n            response.json!=null\n            response.json.error=='request.error.invalidrequest.message'\n\n        where:\n            json       | scopeText\n            TEST_JSON1 | 'wrong'\n            TEST_JSON1 | 'other'\n    }\n    void \"pluginPropertiesValidateAjax missing plugin\"() {\n        given:\n            request.content = json.bytes\n            request.contentType = 'application/json'\n            request.method = 'POST'\n            request.addHeader('x-rundeck-ajax', 'true')\n            def service = 'AService'\n            def name = 'someproperty'\n            params.service = service\n            params.name = name\n            controller.pluginService = Mock(PluginService)\n        when:\n            def result = controller.pluginPropertiesValidateAjax( service, name)\n        then:\n            1 * controller.pluginService.validatePluginConfig(service, name, expected, null) >> null\n            0 * controller.pluginService._(*_)\n            response.status == 404\n            response.json != null\n            response.json.valid == false\n        where:\n            json            | expected\n            '{\"config\":{}}' | [:]\n            TEST_JSON1      | [actions: [[type: 'testaction1', config: [actions: [stringvalue: 'asdf']]]]]\n    }\n\n    void \"plugin detail\"() {\n        given:\n        controller.pluginService = Mock(PluginService)\n        def fwksvc = Mock(FrameworkService)\n        def fwk = Mock(Framework)\n        fwksvc.getRundeckFramework() >> fwk\n        fwk.getPluginManager() >> Mock(ServiceProviderLoader)\n        controller.frameworkService = fwksvc\n        controller.uiPluginService = Mock(UiPluginService)\n        controller.pluginApiService = Mock(PluginApiService)\n\n        when:\n        def fakePluginDesc = new PluginApiServiceSpec.FakePluginDescription()\n        params.name = \"fake\"\n        params.service = \"Notification\"\n        1 * controller.pluginService.getPluginDescriptor(\"fake\", 'Notification') >> new DescribedPlugin(null,fakePluginDesc,\"fake\")\n        1 * controller.frameworkService.rundeckFramework.pluginManager.getPluginMetadata(_,_) >> new PluginApiServiceSpec.FakePluginMetadata()\n        1 * controller.uiPluginService.getPluginMessage('Notification','fake','plugin.title','Fake Plugin',_)>>'plugin.title'\n        1 * controller.uiPluginService.getPluginMessage('Notification','fake','plugin.description','This is the best fake plugin',_)>>'plugin.description'\n        1 * controller.uiPluginService.getProfileFor('Notification','fake')>>[:]\n        1* controller.pluginApiService.pluginPropertiesAsMap('Notification','fake',_)>>[\n                [name:'prop1',apiData:true],\n                [name:'password',apiData:true]\n        ]\n        controller.pluginDetail()\n        def rj = response.json\n        def rp1 = rj.props.find { it.name == \"prop1\" }\n        def rp2 = rj.props.find { it.name == \"password\" }\n\n        then:\n        rj.id == fakePluginId\n        rj.name == \"fake\"\n        rj.title == 'plugin.title'\n        rj.desc == 'plugin.description'\n        rp1.name == \"prop1\"\n        rp1.apiData\n        rp2.name == \"password\"\n        rp2.apiData\n    }\n\n    void \"plugin detail no plugin or framework service\"() {\n        given:\n            controller.pluginService = Mock(PluginService)\n            def fwksvc = Mock(FrameworkService)\n            def fwk = Mock(Framework)\n            fwksvc.getRundeckFramework() >> fwk\n            fwk.getPluginManager() >> Mock(ServiceProviderLoader)\n            controller.frameworkService = fwksvc\n            controller.uiPluginService = Mock(UiPluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n\n        when:\n            def fakePluginDesc = new PluginApiServiceSpec.FakePluginDescription()\n            params.name = \"fake\"\n            params.service = \"Notification\"\n\n            controller.pluginDetail()\n\n        then:\n            response.status == 404\n            1 * controller.pluginService.getPluginDescriptor(\"fake\", 'Notification') >> null\n            1 * controller.frameworkService.rundeckFramework.getService('Notification') >> null\n\n    }\n\n    def \"plugin list filters by service\"() {\n        given:\n            params.service = a\n            controller.pluginService = Mock(PluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n            controller.uiPluginService = Mock(UiPluginService)\n\n            def plugins = [\n                    [\n                        service: 'WebhookEvent',\n                        providers: [\n                                [:],\n                                [:]],\n                    ],\n                    [\n                        service: 'Foo',\n                        providers: [[:]]\n                    ]\n            ]\n\n        when:\n            def result = controller.listPlugins()\n        then:\n            1 * controller.pluginApiService.listPlugins() >> plugins\n            response.json.size() == b\n\n        where:\n            a                | b\n            null             | 3\n            'WebhookEvent'   | 2\n    }\n\n    def \"plugin service descriptions\"() {\n        given:\n        controller.pluginService = Mock(PluginService)\n        controller.uiPluginService = Mock(UiPluginService)\n        def fakePluginDesc1 = new PluginApiServiceSpec.FakePluginDescription()\n        fakePluginDesc1.name = 'XYZfake'\n        def fakePluginDesc2 = new PluginApiServiceSpec.FakePluginDescription()\n        fakePluginDesc2.name = 'ABCfake'\n        request.addHeader('x-rundeck-ajax', 'true')\n        params.service = svcName\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label.indexed\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label.indexed\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.label.plural\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.label.plural\"\n        )\n        messageSource.addMessage(\n                \"framework.service.${svcName}.add.title\",\n                Locale.ENGLISH,\n                \"framework.service.${svcName}.add.title\"\n        )\n        when:\n        def result = controller.pluginServiceDescriptions(svcName)\n        then:\n        1 * controller.pluginService.getPluginTypeByService(svcName) >> NotificationPlugin\n        1 * controller.pluginService.listPlugins(NotificationPlugin) >> [\n                XYZfake: new DescribedPlugin<NotificationPlugin>(null, fakePluginDesc1, 'XYZfake'),\n                ABCfake: new DescribedPlugin<NotificationPlugin>(null, fakePluginDesc2, 'ABCfake')\n            ]\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'ABCfake', 'plugin.title', _, _) >>\n            'ABC title'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'ABCfake', 'plugin.description', _, _) >>\n            'ABC desc'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'XYZfake', 'plugin.title', _, _) >>\n            'XYZ title'\n            1 * controller.uiPluginService.getPluginMessage(svcName, 'XYZfake', 'plugin.description', _, _) >>\n            'XYZ desc'\n            1 * controller.uiPluginService.getProfileFor(svcName,'XYZfake')>>[:]\n            1 * controller.uiPluginService.getProfileFor(svcName,'ABCfake')>>[:]\n            def json = response.json\n            json.service == svcName\n            json.descriptions\n            json.descriptions == [\n                [\n                        name       : 'ABCfake',\n                        title      : 'ABC title',\n                        description: 'ABC desc'\n                ],\n                [\n                        name       : 'XYZfake',\n                        title      : 'XYZ title',\n                        description: 'XYZ desc'\n                ],\n        ]\n        json.labels\n        json.labels.singular == 'framework.service.Notification.label'\n        json.labels.indexed == 'framework.service.Notification.label.indexed'\n        json.labels.plural == 'framework.service.Notification.label.plural'\n        json.labels.addButton == 'framework.service.Notification.add.title'\n\n        where:\n        svcName        | _\n        'Notification' | _\n    }\n\n    void \"upload plugin no file specified\"() {\n        setup:\n        controller.featureService = Mock(FeatureService)\n        controller.frameworkService = Mock(FrameworkService)\n\n        controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.missing.upload.file\",Locale.ENGLISH,\"A plugin file must be specified\")\n        controller.apiService=Mock(ApiService)\n        when:\n        request.method='POST'\n        setupFormTokens(params)\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.featureService.featurePresent(_) >> false\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"err\":\"A plugin file must be specified\"}'\n    }\n\n    void \"upload plugin, plugin security enabled\"() {\n        setup:\n        controller.featureService = Mock(FeatureService)\n        controller.frameworkService = Mock(FrameworkService)\n\n        controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.unauthorized.upload\",Locale.ENGLISH,\"Unable to upload plugins\")\n\n        when:\n            request.method='POST'\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.featureService.featurePresent(_) >> true\n        response.text == '{\"err\":\"Unable to upload plugins\"}'\n    }\n\n    void \"install plugin no plugin url specified\"() {\n        setup:\n        controller.frameworkService = Mock(FrameworkService)\n\n        controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"plugin.error.missing.url\",Locale.ENGLISH,\"The plugin URL is required\")\n        controller.apiService=Mock(ApiService)\n        when:\n        request.method='POST'\n        setupFormTokens(params)\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"err\":\"The plugin URL is required\"}'\n    }\n\n    void \"upload plugin\"() {\n        setup:\n        File uploaded = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n        controller.featureService = Mock(FeatureService)\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n        controller.apiService=Mock(ApiService)\n        when:\n        request.method='POST'\n        setupFormTokens(params)\n        !uploaded.exists()\n        def pluginInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(PLUGIN_FILE)\n        request.addFile(new GrailsMockMultipartFile(\"pluginFile\",PLUGIN_FILE,\"application/octet-stream\",pluginInputStream))\n        controller.uploadPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.featureService.featurePresent(_) >> false\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"msg\":\"done\"}'\n        uploaded.exists()\n\n        cleanup:\n        uploaded.delete()\n    }\n    @Unroll\n    void \"upload plugin requires POST method\"() {\n        setup:\n        def fwksvc = Mock(FrameworkService)\n\n        controller.featureService = Mock(FeatureService)\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n        controller.apiService=Mock(ApiService)\n        when: \"request made without POST method\"\n        request.method=method\n        setupFormTokens(params)\n        controller.uploadPlugin()\n\n        then:\n        response.status==405\n        where:\n            method << ['get', 'put', 'delete', 'head']\n    }\n    void \"upload plugin requires synch token\"() {\n        setup:\n            File uploaded = new File(uploadTestTargetDir,PLUGIN_FILE)\n            def fwksvc = Mock(FrameworkService)\n\n            controller.featureService = Mock(FeatureService)\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n            def fwk = Mock(Framework) {\n                getBaseDir() >> uploadTestBaseDir\n                getLibextDir() >> uploadTestTargetDir\n            }\n            fwksvc.getRundeckFramework() >> fwk\n            controller.frameworkService = fwksvc\n            controller.apiService=Mock(ApiService)\n        when: \"request made without synch token\"\n            request.method='POST'\n            !uploaded.exists()\n            def pluginInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(PLUGIN_FILE)\n            request.addFile(new GrailsMockMultipartFile(\"pluginFile\",PLUGIN_FILE,\"application/octet-stream\",pluginInputStream))\n            controller.uploadPlugin()\n\n        then:\n            0 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n            1 * controller.featureService.featurePresent(_) >> false\n            0 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n            response.text != '{\"msg\":\"done\"}'\n            !uploaded.exists()\n            1 * controller.apiService.renderErrorFormat(_,{\n                it.status== HttpServletResponse.SC_BAD_REQUEST\n                it.code== 'request.error.invalidtoken.message'\n            })\n\n        cleanup:\n            uploaded.delete()\n    }\n\n    void \"install plugin\"() {\n        setup:\n        File installed = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n        controller.apiService=Mock(ApiService)\n        when:\n        request.method='POST'\n        setupFormTokens(params)\n        !installed.exists()\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n        response.text == '{\"msg\":\"done\"}'\n        installed.exists()\n\n        cleanup:\n        installed.delete()\n    }\n    @Unroll\n    void \"install plugin requires POST method\"() {\n        setup:\n        File installed = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n        controller.apiService=Mock(ApiService)\n        when: \"request made without POST method\"\n        request.method=method\n        setupFormTokens(params)\n        !installed.exists()\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n            response.status==405\n            0 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n            0 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n            response.text != '{\"msg\":\"done\"}'\n            !installed.exists()\n\n        cleanup:\n        installed.delete()\n        where:\n            method << ['get', 'put', 'delete', 'head']\n    }\n\n    void \"install plugin requires synch token\"() {\n        setup:\n        File installed = new File(uploadTestTargetDir,PLUGIN_FILE)\n        def fwksvc = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        def fwk = Mock(Framework) {\n            getBaseDir() >> uploadTestBaseDir\n            getLibextDir() >> uploadTestTargetDir\n        }\n        fwksvc.getRundeckFramework() >> fwk\n        controller.frameworkService = fwksvc\n        controller.apiService=Mock(ApiService)\n        when: \"request made without synch token\"\n        request.method='POST'\n        !installed.exists()\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n            1 * controller.apiService.renderErrorFormat(_,{\n                it.status== HttpServletResponse.SC_BAD_REQUEST\n                it.code== 'request.error.invalidtoken.message'\n            })\n            0 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n            0 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> true\n            response.text != '{\"msg\":\"done\"}'\n            !installed.exists()\n        cleanup:\n        installed.delete()\n    }\n\n    protected setupFormTokens(params) {\n        def token = SynchronizerTokensHolder.store(session)\n        params[SynchronizerTokensHolder.TOKEN_KEY] = token.generateToken('/test')\n        params[SynchronizerTokensHolder.TOKEN_URI] = '/test'\n    }\n\n    void \"unauthorized install plugin fails\"() {\n        setup:\n        controller.frameworkService = Mock(FrameworkService)\n\n            controller.rundeckAuthContextProcessor = Mock(AppAuthContextProcessor)\n        messageSource.addMessage(\"request.error.unauthorized.title\",Locale.ENGLISH,\"Unauthorized\")\n        controller.apiService=Mock(ApiService)\n        when:\n        request.method='POST'\n        setupFormTokens(params)\n        def pluginUrl = Thread.currentThread().getContextClassLoader().getResource(PLUGIN_FILE)\n        params.pluginUrl = pluginUrl.toString()\n        controller.installPlugin()\n\n        then:\n        1 * controller.rundeckAuthContextProcessor.getAuthContextForSubject(_)\n        1 * controller.rundeckAuthContextProcessor.authorizeApplicationResourceType(_,_,_) >> false\n        response.text == '{\"err\":\"Unauthorized\"}'\n    }\n\n    def \"plugin detail for ui plugin\"() {\n        given:\n\n            params.name = 'test1'\n            params.service = 'UI'\n            controller.pluginService = Mock(PluginService)\n            controller.uiPluginService = Mock(UiPluginService)\n            controller.pluginApiService = Mock(PluginApiService)\n            def uiPluginProviderService = Mock(UIPluginProviderService)\n            controller.frameworkService = Mock(FrameworkService)\n\n            def plugin = Mock(UIPlugin)\n            def description = DescriptionBuilder.builder().name('test1').build()\n            def pluginMeta = Mock(PluginMetadata)\n        when:\n            controller.pluginDetail()\n        then:\n            response.status == 200\n\n            response.contentType.startsWith 'application/json'\n\n            1 * controller.uiPluginService.getUiPluginProviderService() >> uiPluginProviderService\n            1 * controller.uiPluginService.getPluginMessage('UI', 'test1', 'plugin.title', _, _) >> 'ptitle'\n            1 * controller.uiPluginService.getPluginMessage('UI', 'test1', 'plugin.description', _, _) >>\n            'pdescription'\n            1 * controller.pluginApiService.pluginPropertiesAsMap('UI', 'test1', _) >> []\n            1 * controller.pluginService.getPluginDescriptor('test1', uiPluginProviderService) >>\n            new DescribedPlugin<UIPlugin>(plugin, description, 'test1')\n            1 * controller.frameworkService.getRundeckFramework() >> Mock(IFramework) {\n                1 * getPluginManager() >> Mock(ServiceProviderLoader) {\n                    1 * getPluginMetadata('UI', 'test1') >> pluginMeta\n                }\n            }\n    }\n}\n"], "filenames": ["rundeckapp/grails-app/controllers/rundeck/controllers/PluginController.groovy", "rundeckapp/grails-spa/packages/ui/src/pages/repository/components/PluginURLUploadForm.vue", "rundeckapp/grails-spa/packages/ui/src/pages/repository/components/PluginUploadForm.vue", "rundeckapp/src/test/groovy/rundeck/controllers/PluginControllerSpec.groovy"], "buggy_code_start_loc": [15, 21, 29, 20], "buggy_code_end_loc": [461, 55, 76, 434], "fixing_code_start_loc": [16, 21, 30, 21], "fixing_code_end_loc": [491, 67, 93, 588], "type": "CWE-352", "message": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to version 3.3.14 and version 3.4.3, a user with `admin` access to the `system` resource type is potentially vulnerable to a CSRF attack that could cause the server to run untrusted code on all Rundeck editions. Patches are available in Rundeck versions 3.4.3 and 3.3.14.", "other": {"cve": {"id": "CVE-2021-39133", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-30T20:15:07.730", "lastModified": "2021-09-08T15:21:52.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to version 3.3.14 and version 3.4.3, a user with `admin` access to the `system` resource type is potentially vulnerable to a CSRF attack that could cause the server to run untrusted code on all Rundeck editions. Patches are available in Rundeck versions 3.4.3 and 3.3.14."}, {"lang": "es", "value": "Rundeck es un servicio de automatizaci\u00f3n de c\u00f3digo abierto con una consola web, herramientas de l\u00ednea de comandos y una WebAPI. Versiones anteriores a 3.3.14 y versi\u00f3n 3.4.3, un usuario con acceso \"admin\" al tipo de recurso \"system\" es potencialmente vulnerable a un ataque de tipo CSRF que podr\u00eda causar que el servidor ejecute c\u00f3digo no confiable en todas las ediciones de Rundeck. Los parches est\u00e1n disponibles en versiones 3.4.3 y 3.3.14 de Rundeck."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.14", "matchCriteriaId": "D748AEB1-DF73-46BF-89F4-90C4054DFDF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.3", "matchCriteriaId": "37695317-3B98-418C-9418-59BBC3D8554B"}]}]}], "references": [{"url": "https://github.com/rundeck/rundeck/commit/67c4eedeaf9509fc0b255aff15977a5229ef13b9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rundeck/rundeck/security/advisories/GHSA-3jmw-c69h-426c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rundeck/rundeck/commit/67c4eedeaf9509fc0b255aff15977a5229ef13b9"}}