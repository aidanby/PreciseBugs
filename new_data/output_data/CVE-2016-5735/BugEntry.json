{"buggy_code": ["/*---------------------------------------------------------------------------\n\n   pngquant:  RGBA -> RGBA-palette quantization program             rwpng.c\n\n  ---------------------------------------------------------------------------\n\n   \u00a9 1998-2000 by Greg Roelofs.\n   \u00a9 2009-2015 by Kornel Lesi\u0144ski.\n\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without modification,\n   are permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  ---------------------------------------------------------------------------*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#include \"png.h\"  /* if this include fails, you need to install libpng (e.g. libpng-devel package) and run ./configure */\n#include \"rwpng.h\"\n#if USE_LCMS\n#include \"lcms2.h\"\n#endif\n\n#ifndef Z_BEST_COMPRESSION\n#define Z_BEST_COMPRESSION 9\n#endif\n#ifndef Z_BEST_SPEED\n#define Z_BEST_SPEED 1\n#endif\n\n#ifdef _OPENMP\n#include <omp.h>\n#else\n#define omp_get_max_threads() 1\n#endif\n\n#if PNG_LIBPNG_VER < 10500\ntypedef png_const_charp png_const_bytep;\n#endif\n\nstatic void rwpng_error_handler(png_structp png_ptr, png_const_charp msg);\nint rwpng_read_image24_cocoa(FILE *infile, png24_image *mainprog_ptr);\n\n\nvoid rwpng_version_info(FILE *fp)\n{\n    const char *pngver = png_get_header_ver(NULL);\n\n#if USE_COCOA\n    fprintf(fp, \"   Color profiles are supported via Cocoa. Using libpng %s.\\n\", pngver);\n#elif USE_LCMS\n    fprintf(fp, \"   Color profiles are supported via Little CMS. Using libpng %s.\\n\", pngver);\n#else\n    fprintf(fp, \"   Compiled with no support for color profiles. Using libpng %s.\\n\", pngver);\n#endif\n\n#if PNG_LIBPNG_VER < 10600\n    if (strcmp(pngver, \"1.3.\") < 0) {\n        fputs(\"\\nWARNING: Your version of libpng is outdated and may produce corrupted files.\\n\"\n              \"Please recompile pngquant with the current version of libpng (1.6 or later).\\n\", fp);\n    } else if (strcmp(pngver, \"1.6.\") < 0) {\n        #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n        fputs(\"\\nWARNING: Your version of libpng is old and has buggy support for custom chunks.\\n\"\n              \"Please recompile pngquant with the current version of libpng (1.6 or later).\\n\", fp);\n        #endif\n    }\n#endif\n}\n\n\nstruct rwpng_read_data {\n    FILE *const fp;\n    png_size_t bytes_read;\n};\n\n#if !USE_COCOA\nstatic void user_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    struct rwpng_read_data *read_data = (struct rwpng_read_data *)png_get_io_ptr(png_ptr);\n\n    png_size_t read = fread(data, 1, length, read_data->fp);\n    if (!read) {\n        png_error(png_ptr, \"Read error\");\n    }\n    read_data->bytes_read += read;\n}\n#endif\n\nstruct rwpng_write_state {\n    FILE *outfile;\n    png_size_t maximum_file_size;\n    png_size_t bytes_written;\n    pngquant_error retval;\n};\n\nstatic void user_write_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    struct rwpng_write_state *write_state = (struct rwpng_write_state *)png_get_io_ptr(png_ptr);\n\n    if (SUCCESS != write_state->retval) {\n        return;\n    }\n\n    if (!fwrite(data, length, 1, write_state->outfile)) {\n        write_state->retval = CANT_WRITE_ERROR;\n    }\n\n    write_state->bytes_written += length;\n}\n\nstatic void user_flush_data(png_structp png_ptr)\n{\n    // libpng never calls this :(\n}\n\n\nstatic png_bytepp rwpng_create_row_pointers(png_infop info_ptr, png_structp png_ptr, unsigned char *base, unsigned int height, png_size_t rowbytes)\n{\n    if (!rowbytes) {\n        rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n    }\n\n    png_bytepp row_pointers = malloc(height * sizeof(row_pointers[0]));\n    if (!row_pointers) return NULL;\n    for(size_t row = 0; row < height; row++) {\n        row_pointers[row] = base + row * rowbytes;\n    }\n    return row_pointers;\n}\n\n#if !USE_COCOA\nstatic int read_chunk_callback(png_structp png_ptr, png_unknown_chunkp in_chunk)\n{\n    if (0 == memcmp(\"iCCP\", in_chunk->name, 5) ||\n        0 == memcmp(\"cHRM\", in_chunk->name, 5) ||\n        0 == memcmp(\"gAMA\", in_chunk->name, 5)) {\n        return 0; // not handled\n    }\n\n    struct rwpng_chunk **head = (struct rwpng_chunk **)png_get_user_chunk_ptr(png_ptr);\n\n    struct rwpng_chunk *chunk = malloc(sizeof(struct rwpng_chunk));\n    memcpy(chunk->name, in_chunk->name, 5);\n    chunk->size = in_chunk->size;\n    chunk->location = in_chunk->location;\n    chunk->data = in_chunk->size ? malloc(in_chunk->size) : NULL;\n    if (in_chunk->size) {\n        memcpy(chunk->data, in_chunk->data, in_chunk->size);\n    }\n\n    chunk->next = *head;\n    *head = chunk;\n\n    return 1; // marks as \"handled\", libpng won't store it\n}\n#endif\n\n/*\n   retval:\n     0 = success\n    21 = bad sig\n    22 = bad IHDR\n    24 = insufficient memory\n    25 = libpng error (via longjmp())\n    26 = wrong PNG color type (no alpha channel)\n */\n\n#if !USE_COCOA\nstatic void rwpng_warning_stderr_handler(png_structp png_ptr, png_const_charp msg) {\n    fprintf(stderr, \"  libpng warning: %s\\n\", msg);\n}\n\nstatic void rwpng_warning_silent_handler(png_structp png_ptr, png_const_charp msg) {\n}\n\nstatic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */\n    }\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}\n#endif\n\nstatic void rwpng_free_chunks(struct rwpng_chunk *chunk) {\n    if (!chunk) return;\n    rwpng_free_chunks(chunk->next);\n    free(chunk->data);\n    free(chunk);\n}\n\nvoid rwpng_free_image24(png24_image *image)\n{\n    free(image->row_pointers);\n    image->row_pointers = NULL;\n\n    free(image->rgba_data);\n    image->rgba_data = NULL;\n\n    rwpng_free_chunks(image->chunks);\n    image->chunks = NULL;\n}\n\nvoid rwpng_free_image8(png8_image *image)\n{\n    free(image->indexed_data);\n    image->indexed_data = NULL;\n\n    free(image->row_pointers);\n    image->row_pointers = NULL;\n\n    rwpng_free_chunks(image->chunks);\n    image->chunks = NULL;\n}\n\npngquant_error rwpng_read_image24(FILE *infile, png24_image *input_image_p, int verbose)\n{\n#if USE_COCOA\n    return rwpng_read_image24_cocoa(infile, input_image_p);\n#else\n    return rwpng_read_image24_libpng(infile, input_image_p, verbose);\n#endif\n}\n\n\nstatic pngquant_error rwpng_write_image_init(rwpng_png_image *mainprog_ptr, png_structpp png_ptr_p, png_infopp info_ptr_p, int fast_compression)\n{\n    /* could also replace libpng warning-handler (final NULL), but no need: */\n\n    *png_ptr_p = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, rwpng_error_handler, NULL);\n\n    if (!(*png_ptr_p)) {\n        return LIBPNG_INIT_ERROR;   /* out of memory */\n    }\n\n    *info_ptr_p = png_create_info_struct(*png_ptr_p);\n    if (!(*info_ptr_p)) {\n        png_destroy_write_struct(png_ptr_p, NULL);\n        return LIBPNG_INIT_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a PNG-writing\n     * libpng function, unless an alternate error handler was installed--\n     * but compatible error handlers must either use longjmp() themselves\n     * (as in this program) or exit immediately, so here we go: */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_write_struct(png_ptr_p, info_ptr_p);\n        return LIBPNG_INIT_ERROR;   /* libpng error (via longjmp()) */\n    }\n\n    png_set_compression_level(*png_ptr_p, fast_compression ? Z_BEST_SPEED : Z_BEST_COMPRESSION);\n    png_set_compression_mem_level(*png_ptr_p, fast_compression ? 9 : 5); // judging by optipng results, smaller mem makes libpng compress slightly better\n\n    return SUCCESS;\n}\n\n\nstatic void rwpng_write_end(png_infopp info_ptr_p, png_structpp png_ptr_p, png_bytepp row_pointers)\n{\n    png_write_info(*png_ptr_p, *info_ptr_p);\n\n    png_set_packing(*png_ptr_p);\n\n    png_write_image(*png_ptr_p, row_pointers);\n\n    png_write_end(*png_ptr_p, NULL);\n\n    png_destroy_write_struct(png_ptr_p, info_ptr_p);\n}\n\nstatic void rwpng_set_gamma(png_infop info_ptr, png_structp png_ptr, double gamma, rwpng_color_transform color)\n{\n    if (color != RWPNG_GAMA_ONLY && color != RWPNG_NONE) {\n        png_set_gAMA(png_ptr, info_ptr, gamma);\n    }\n    if (color == RWPNG_SRGB) {\n        png_set_sRGB(png_ptr, info_ptr, 0); // 0 = Perceptual\n    }\n}\n\npngquant_error rwpng_write_image8(FILE *outfile, const png8_image *mainprog_ptr)\n{\n    png_structp png_ptr;\n    png_infop info_ptr;\n\n    if (mainprog_ptr->num_palette > 256) return INVALID_ARGUMENT;\n\n    pngquant_error retval = rwpng_write_image_init((rwpng_png_image*)mainprog_ptr, &png_ptr, &info_ptr, mainprog_ptr->fast_compression);\n    if (retval) return retval;\n\n    struct rwpng_write_state write_state;\n    write_state = (struct rwpng_write_state){\n        .outfile = outfile,\n        .maximum_file_size = mainprog_ptr->maximum_file_size,\n        .retval = SUCCESS,\n    };\n    png_set_write_fn(png_ptr, &write_state, user_write_data, user_flush_data);\n\n    // Palette images generally don't gain anything from filtering\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, PNG_FILTER_VALUE_NONE);\n\n    rwpng_set_gamma(info_ptr, png_ptr, mainprog_ptr->gamma, mainprog_ptr->output_color);\n\n    /* set the image parameters appropriately */\n    int sample_depth;\n#if PNG_LIBPNG_VER > 10400 /* old libpng corrupts files with low depth */\n    if (mainprog_ptr->num_palette <= 2)\n        sample_depth = 1;\n    else if (mainprog_ptr->num_palette <= 4)\n        sample_depth = 2;\n    else if (mainprog_ptr->num_palette <= 16)\n        sample_depth = 4;\n    else\n#endif\n        sample_depth = 8;\n\n    struct rwpng_chunk *chunk = mainprog_ptr->chunks;\n    int chunk_num=0;\n    while(chunk) {\n        png_unknown_chunk pngchunk = {\n            .size = chunk->size,\n            .data = chunk->data,\n            .location = chunk->location,\n        };\n        memcpy(pngchunk.name, chunk->name, 5);\n        png_set_unknown_chunks(png_ptr, info_ptr, &pngchunk, 1);\n\n        #if defined(PNG_HAVE_IHDR) && PNG_LIBPNG_VER < 10600\n        png_set_unknown_chunk_location(png_ptr, info_ptr, chunk_num, pngchunk.location ? pngchunk.location : PNG_HAVE_IHDR);\n        #endif\n\n        chunk = chunk->next;\n        chunk_num++;\n    }\n\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n      sample_depth, PNG_COLOR_TYPE_PALETTE,\n      0, PNG_COMPRESSION_TYPE_DEFAULT,\n      PNG_FILTER_TYPE_BASE);\n\n    png_color palette[256];\n    png_byte trans[256];\n    unsigned int num_trans = 0;\n    for(unsigned int i = 0; i < mainprog_ptr->num_palette; i++) {\n        palette[i] = (png_color){\n            .red   = mainprog_ptr->palette[i].r,\n            .green = mainprog_ptr->palette[i].g,\n            .blue  = mainprog_ptr->palette[i].b,\n        };\n        trans[i] = mainprog_ptr->palette[i].a;\n        if (mainprog_ptr->palette[i].a < 255) {\n            num_trans = i+1;\n        }\n    }\n\n    png_set_PLTE(png_ptr, info_ptr, palette, mainprog_ptr->num_palette);\n\n    if (num_trans > 0) {\n        png_set_tRNS(png_ptr, info_ptr, trans, num_trans, NULL);\n    }\n\n    rwpng_write_end(&info_ptr, &png_ptr, mainprog_ptr->row_pointers);\n\n    if (SUCCESS == write_state.retval && write_state.maximum_file_size && write_state.bytes_written > write_state.maximum_file_size) {\n        return TOO_LARGE_FILE;\n    }\n\n    return write_state.retval;\n}\n\npngquant_error rwpng_write_image24(FILE *outfile, const png24_image *mainprog_ptr)\n{\n    png_structp png_ptr;\n    png_infop info_ptr;\n\n    pngquant_error retval = rwpng_write_image_init((rwpng_png_image*)mainprog_ptr, &png_ptr, &info_ptr, 0);\n    if (retval) return retval;\n\n    png_init_io(png_ptr, outfile);\n\n    rwpng_set_gamma(info_ptr, png_ptr, mainprog_ptr->gamma, mainprog_ptr->output_color);\n\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n                 8, PNG_COLOR_TYPE_RGB_ALPHA,\n                 0, PNG_COMPRESSION_TYPE_DEFAULT,\n                 PNG_FILTER_TYPE_BASE);\n\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    rwpng_write_end(&info_ptr, &png_ptr, row_pointers);\n\n    free(row_pointers);\n\n    return SUCCESS;\n}\n\nstatic void rwpng_error_handler(png_structp png_ptr, png_const_charp msg)\n{\n    rwpng_png_image  *mainprog_ptr;\n\n    /* This function, aside from the extra step of retrieving the \"error\n     * pointer\" (below) and the fact that it exists within the application\n     * rather than within libpng, is essentially identical to libpng's\n     * default error handler.  The second point is critical:  since both\n     * setjmp() and longjmp() are called from the same code, they are\n     * guaranteed to have compatible notions of how big a jmp_buf is,\n     * regardless of whether _BSD_SOURCE or anything else has (or has not)\n     * been defined. */\n\n    fprintf(stderr, \"  error: %s (libpng failed)\\n\", msg);\n    fflush(stderr);\n\n    mainprog_ptr = png_get_error_ptr(png_ptr);\n    if (mainprog_ptr == NULL) abort();\n\n    longjmp(mainprog_ptr->jmpbuf, 1);\n}\n"], "fixing_code": ["/*---------------------------------------------------------------------------\n\n   pngquant:  RGBA -> RGBA-palette quantization program             rwpng.c\n\n  ---------------------------------------------------------------------------\n\n   \u00a9 1998-2000 by Greg Roelofs.\n   \u00a9 2009-2015 by Kornel Lesi\u0144ski.\n\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without modification,\n   are permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  ---------------------------------------------------------------------------*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#include \"png.h\"  /* if this include fails, you need to install libpng (e.g. libpng-devel package) and run ./configure */\n#include \"rwpng.h\"\n#if USE_LCMS\n#include \"lcms2.h\"\n#endif\n\n#ifndef Z_BEST_COMPRESSION\n#define Z_BEST_COMPRESSION 9\n#endif\n#ifndef Z_BEST_SPEED\n#define Z_BEST_SPEED 1\n#endif\n\n#ifdef _OPENMP\n#include <omp.h>\n#else\n#define omp_get_max_threads() 1\n#endif\n\n#if PNG_LIBPNG_VER < 10500\ntypedef png_const_charp png_const_bytep;\n#endif\n\nstatic void rwpng_error_handler(png_structp png_ptr, png_const_charp msg);\nint rwpng_read_image24_cocoa(FILE *infile, png24_image *mainprog_ptr);\n\n\nvoid rwpng_version_info(FILE *fp)\n{\n    const char *pngver = png_get_header_ver(NULL);\n\n#if USE_COCOA\n    fprintf(fp, \"   Color profiles are supported via Cocoa. Using libpng %s.\\n\", pngver);\n#elif USE_LCMS\n    fprintf(fp, \"   Color profiles are supported via Little CMS. Using libpng %s.\\n\", pngver);\n#else\n    fprintf(fp, \"   Compiled with no support for color profiles. Using libpng %s.\\n\", pngver);\n#endif\n\n#if PNG_LIBPNG_VER < 10600\n    if (strcmp(pngver, \"1.3.\") < 0) {\n        fputs(\"\\nWARNING: Your version of libpng is outdated and may produce corrupted files.\\n\"\n              \"Please recompile pngquant with the current version of libpng (1.6 or later).\\n\", fp);\n    } else if (strcmp(pngver, \"1.6.\") < 0) {\n        #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n        fputs(\"\\nWARNING: Your version of libpng is old and has buggy support for custom chunks.\\n\"\n              \"Please recompile pngquant with the current version of libpng (1.6 or later).\\n\", fp);\n        #endif\n    }\n#endif\n}\n\n\nstruct rwpng_read_data {\n    FILE *const fp;\n    png_size_t bytes_read;\n};\n\n#if !USE_COCOA\nstatic void user_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    struct rwpng_read_data *read_data = (struct rwpng_read_data *)png_get_io_ptr(png_ptr);\n\n    png_size_t read = fread(data, 1, length, read_data->fp);\n    if (!read) {\n        png_error(png_ptr, \"Read error\");\n    }\n    read_data->bytes_read += read;\n}\n#endif\n\nstruct rwpng_write_state {\n    FILE *outfile;\n    png_size_t maximum_file_size;\n    png_size_t bytes_written;\n    pngquant_error retval;\n};\n\nstatic void user_write_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    struct rwpng_write_state *write_state = (struct rwpng_write_state *)png_get_io_ptr(png_ptr);\n\n    if (SUCCESS != write_state->retval) {\n        return;\n    }\n\n    if (!fwrite(data, length, 1, write_state->outfile)) {\n        write_state->retval = CANT_WRITE_ERROR;\n    }\n\n    write_state->bytes_written += length;\n}\n\nstatic void user_flush_data(png_structp png_ptr)\n{\n    // libpng never calls this :(\n}\n\n\nstatic png_bytepp rwpng_create_row_pointers(png_infop info_ptr, png_structp png_ptr, unsigned char *base, unsigned int height, png_size_t rowbytes)\n{\n    if (!rowbytes) {\n        rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n    }\n\n    png_bytepp row_pointers = malloc(height * sizeof(row_pointers[0]));\n    if (!row_pointers) return NULL;\n    for(size_t row = 0; row < height; row++) {\n        row_pointers[row] = base + row * rowbytes;\n    }\n    return row_pointers;\n}\n\n#if !USE_COCOA\nstatic int read_chunk_callback(png_structp png_ptr, png_unknown_chunkp in_chunk)\n{\n    if (0 == memcmp(\"iCCP\", in_chunk->name, 5) ||\n        0 == memcmp(\"cHRM\", in_chunk->name, 5) ||\n        0 == memcmp(\"gAMA\", in_chunk->name, 5)) {\n        return 0; // not handled\n    }\n\n    struct rwpng_chunk **head = (struct rwpng_chunk **)png_get_user_chunk_ptr(png_ptr);\n\n    struct rwpng_chunk *chunk = malloc(sizeof(struct rwpng_chunk));\n    memcpy(chunk->name, in_chunk->name, 5);\n    chunk->size = in_chunk->size;\n    chunk->location = in_chunk->location;\n    chunk->data = in_chunk->size ? malloc(in_chunk->size) : NULL;\n    if (in_chunk->size) {\n        memcpy(chunk->data, in_chunk->data, in_chunk->size);\n    }\n\n    chunk->next = *head;\n    *head = chunk;\n\n    return 1; // marks as \"handled\", libpng won't store it\n}\n#endif\n\n/*\n   retval:\n     0 = success\n    21 = bad sig\n    22 = bad IHDR\n    24 = insufficient memory\n    25 = libpng error (via longjmp())\n    26 = wrong PNG color type (no alpha channel)\n */\n\n#if !USE_COCOA\nstatic void rwpng_warning_stderr_handler(png_structp png_ptr, png_const_charp msg) {\n    fprintf(stderr, \"  libpng warning: %s\\n\", msg);\n}\n\nstatic void rwpng_warning_silent_handler(png_structp png_ptr, png_const_charp msg) {\n}\n\nstatic pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (rowbytes > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}\n#endif\n\nstatic void rwpng_free_chunks(struct rwpng_chunk *chunk) {\n    if (!chunk) return;\n    rwpng_free_chunks(chunk->next);\n    free(chunk->data);\n    free(chunk);\n}\n\nvoid rwpng_free_image24(png24_image *image)\n{\n    free(image->row_pointers);\n    image->row_pointers = NULL;\n\n    free(image->rgba_data);\n    image->rgba_data = NULL;\n\n    rwpng_free_chunks(image->chunks);\n    image->chunks = NULL;\n}\n\nvoid rwpng_free_image8(png8_image *image)\n{\n    free(image->indexed_data);\n    image->indexed_data = NULL;\n\n    free(image->row_pointers);\n    image->row_pointers = NULL;\n\n    rwpng_free_chunks(image->chunks);\n    image->chunks = NULL;\n}\n\npngquant_error rwpng_read_image24(FILE *infile, png24_image *input_image_p, int verbose)\n{\n#if USE_COCOA\n    return rwpng_read_image24_cocoa(infile, input_image_p);\n#else\n    return rwpng_read_image24_libpng(infile, input_image_p, verbose);\n#endif\n}\n\n\nstatic pngquant_error rwpng_write_image_init(rwpng_png_image *mainprog_ptr, png_structpp png_ptr_p, png_infopp info_ptr_p, int fast_compression)\n{\n    /* could also replace libpng warning-handler (final NULL), but no need: */\n\n    *png_ptr_p = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, rwpng_error_handler, NULL);\n\n    if (!(*png_ptr_p)) {\n        return LIBPNG_INIT_ERROR;   /* out of memory */\n    }\n\n    *info_ptr_p = png_create_info_struct(*png_ptr_p);\n    if (!(*info_ptr_p)) {\n        png_destroy_write_struct(png_ptr_p, NULL);\n        return LIBPNG_INIT_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a PNG-writing\n     * libpng function, unless an alternate error handler was installed--\n     * but compatible error handlers must either use longjmp() themselves\n     * (as in this program) or exit immediately, so here we go: */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_write_struct(png_ptr_p, info_ptr_p);\n        return LIBPNG_INIT_ERROR;   /* libpng error (via longjmp()) */\n    }\n\n    png_set_compression_level(*png_ptr_p, fast_compression ? Z_BEST_SPEED : Z_BEST_COMPRESSION);\n    png_set_compression_mem_level(*png_ptr_p, fast_compression ? 9 : 5); // judging by optipng results, smaller mem makes libpng compress slightly better\n\n    return SUCCESS;\n}\n\n\nstatic void rwpng_write_end(png_infopp info_ptr_p, png_structpp png_ptr_p, png_bytepp row_pointers)\n{\n    png_write_info(*png_ptr_p, *info_ptr_p);\n\n    png_set_packing(*png_ptr_p);\n\n    png_write_image(*png_ptr_p, row_pointers);\n\n    png_write_end(*png_ptr_p, NULL);\n\n    png_destroy_write_struct(png_ptr_p, info_ptr_p);\n}\n\nstatic void rwpng_set_gamma(png_infop info_ptr, png_structp png_ptr, double gamma, rwpng_color_transform color)\n{\n    if (color != RWPNG_GAMA_ONLY && color != RWPNG_NONE) {\n        png_set_gAMA(png_ptr, info_ptr, gamma);\n    }\n    if (color == RWPNG_SRGB) {\n        png_set_sRGB(png_ptr, info_ptr, 0); // 0 = Perceptual\n    }\n}\n\npngquant_error rwpng_write_image8(FILE *outfile, const png8_image *mainprog_ptr)\n{\n    png_structp png_ptr;\n    png_infop info_ptr;\n\n    if (mainprog_ptr->num_palette > 256) return INVALID_ARGUMENT;\n\n    pngquant_error retval = rwpng_write_image_init((rwpng_png_image*)mainprog_ptr, &png_ptr, &info_ptr, mainprog_ptr->fast_compression);\n    if (retval) return retval;\n\n    struct rwpng_write_state write_state;\n    write_state = (struct rwpng_write_state){\n        .outfile = outfile,\n        .maximum_file_size = mainprog_ptr->maximum_file_size,\n        .retval = SUCCESS,\n    };\n    png_set_write_fn(png_ptr, &write_state, user_write_data, user_flush_data);\n\n    // Palette images generally don't gain anything from filtering\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, PNG_FILTER_VALUE_NONE);\n\n    rwpng_set_gamma(info_ptr, png_ptr, mainprog_ptr->gamma, mainprog_ptr->output_color);\n\n    /* set the image parameters appropriately */\n    int sample_depth;\n#if PNG_LIBPNG_VER > 10400 /* old libpng corrupts files with low depth */\n    if (mainprog_ptr->num_palette <= 2)\n        sample_depth = 1;\n    else if (mainprog_ptr->num_palette <= 4)\n        sample_depth = 2;\n    else if (mainprog_ptr->num_palette <= 16)\n        sample_depth = 4;\n    else\n#endif\n        sample_depth = 8;\n\n    struct rwpng_chunk *chunk = mainprog_ptr->chunks;\n    int chunk_num=0;\n    while(chunk) {\n        png_unknown_chunk pngchunk = {\n            .size = chunk->size,\n            .data = chunk->data,\n            .location = chunk->location,\n        };\n        memcpy(pngchunk.name, chunk->name, 5);\n        png_set_unknown_chunks(png_ptr, info_ptr, &pngchunk, 1);\n\n        #if defined(PNG_HAVE_IHDR) && PNG_LIBPNG_VER < 10600\n        png_set_unknown_chunk_location(png_ptr, info_ptr, chunk_num, pngchunk.location ? pngchunk.location : PNG_HAVE_IHDR);\n        #endif\n\n        chunk = chunk->next;\n        chunk_num++;\n    }\n\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n      sample_depth, PNG_COLOR_TYPE_PALETTE,\n      0, PNG_COMPRESSION_TYPE_DEFAULT,\n      PNG_FILTER_TYPE_BASE);\n\n    png_color palette[256];\n    png_byte trans[256];\n    unsigned int num_trans = 0;\n    for(unsigned int i = 0; i < mainprog_ptr->num_palette; i++) {\n        palette[i] = (png_color){\n            .red   = mainprog_ptr->palette[i].r,\n            .green = mainprog_ptr->palette[i].g,\n            .blue  = mainprog_ptr->palette[i].b,\n        };\n        trans[i] = mainprog_ptr->palette[i].a;\n        if (mainprog_ptr->palette[i].a < 255) {\n            num_trans = i+1;\n        }\n    }\n\n    png_set_PLTE(png_ptr, info_ptr, palette, mainprog_ptr->num_palette);\n\n    if (num_trans > 0) {\n        png_set_tRNS(png_ptr, info_ptr, trans, num_trans, NULL);\n    }\n\n    rwpng_write_end(&info_ptr, &png_ptr, mainprog_ptr->row_pointers);\n\n    if (SUCCESS == write_state.retval && write_state.maximum_file_size && write_state.bytes_written > write_state.maximum_file_size) {\n        return TOO_LARGE_FILE;\n    }\n\n    return write_state.retval;\n}\n\npngquant_error rwpng_write_image24(FILE *outfile, const png24_image *mainprog_ptr)\n{\n    png_structp png_ptr;\n    png_infop info_ptr;\n\n    pngquant_error retval = rwpng_write_image_init((rwpng_png_image*)mainprog_ptr, &png_ptr, &info_ptr, 0);\n    if (retval) return retval;\n\n    png_init_io(png_ptr, outfile);\n\n    rwpng_set_gamma(info_ptr, png_ptr, mainprog_ptr->gamma, mainprog_ptr->output_color);\n\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n                 8, PNG_COLOR_TYPE_RGB_ALPHA,\n                 0, PNG_COMPRESSION_TYPE_DEFAULT,\n                 PNG_FILTER_TYPE_BASE);\n\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    rwpng_write_end(&info_ptr, &png_ptr, row_pointers);\n\n    free(row_pointers);\n\n    return SUCCESS;\n}\n\nstatic void rwpng_error_handler(png_structp png_ptr, png_const_charp msg)\n{\n    rwpng_png_image  *mainprog_ptr;\n\n    /* This function, aside from the extra step of retrieving the \"error\n     * pointer\" (below) and the fact that it exists within the application\n     * rather than within libpng, is essentially identical to libpng's\n     * default error handler.  The second point is critical:  since both\n     * setjmp() and longjmp() are called from the same code, they are\n     * guaranteed to have compatible notions of how big a jmp_buf is,\n     * regardless of whether _BSD_SOURCE or anything else has (or has not)\n     * been defined. */\n\n    fprintf(stderr, \"  error: %s (libpng failed)\\n\", msg);\n    fflush(stderr);\n\n    mainprog_ptr = png_get_error_ptr(png_ptr);\n    if (mainprog_ptr == NULL) abort();\n\n    longjmp(mainprog_ptr->jmpbuf, 1);\n}\n"], "filenames": ["rwpng.c"], "buggy_code_start_loc": [246], "buggy_code_end_loc": [306], "fixing_code_start_loc": [245], "fixing_code_end_loc": [307], "type": "CWE-190", "message": "Integer overflow in the rwpng_read_image24_libpng function in rwpng.c in pngquant 2.7.0 allows remote attackers to have unspecified impact via a crafted PNG file, which triggers a buffer overflow.", "other": {"cve": {"id": "CVE-2016-5735", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-23T04:29:01.477", "lastModified": "2020-06-28T15:15:10.620", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the rwpng_read_image24_libpng function in rwpng.c in pngquant 2.7.0 allows remote attackers to have unspecified impact via a crafted PNG file, which triggers a buffer overflow."}, {"lang": "es", "value": "Un desbordamiento de enteros en la funci\u00f3n rwpng_read_image24_libpng en pngquant 2.7.0 permite a los atacantes remotos provocar un impacto no especificado mediante un archivo PNG manipulado, lo cual provoca un desbordamiento de b\u00fafer."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pngquant:pngquant:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "82CC7C03-9215-44B0-8A63-87867C026393"}]}]}], "references": [{"url": "http://sf.snu.ac.kr/gil.hur/publications/shovel.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/pornel/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00028.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/pornel/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285"}}