{"buggy_code": ["/*\n * CUSE: Character device in Userspace\n *\n * Copyright (C) 2008-2009  SUSE Linux Products GmbH\n * Copyright (C) 2008-2009  Tejun Heo <tj@kernel.org>\n *\n * This file is released under the GPLv2.\n *\n * CUSE enables character devices to be implemented from userland much\n * like FUSE allows filesystems.  On initialization /dev/cuse is\n * created.  By opening the file and replying to the CUSE_INIT request\n * userland CUSE server can create a character device.  After that the\n * operation is very similar to FUSE.\n *\n * A CUSE instance involves the following objects.\n *\n * cuse_conn\t: contains fuse_conn and serves as bonding structure\n * channel\t: file handle connected to the userland CUSE server\n * cdev\t\t: the implemented character device\n * dev\t\t: generic device for cdev\n *\n * Note that 'channel' is what 'dev' is in FUSE.  As CUSE deals with\n * devices, it's called 'channel' to reduce confusion.\n *\n * channel determines when the character device dies.  When channel is\n * closed, everything begins to destruct.  The cuse_conn is taken off\n * the lookup table preventing further access from cdev, cdev and\n * generic device are removed and the base reference of cuse_conn is\n * put.\n *\n * On each open, the matching cuse_conn is looked up and if found an\n * additional reference is taken which is released when the file is\n * closed.\n */\n\n#include <linux/fuse.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/uio.h>\n\n#include \"fuse_i.h\"\n\n#define CUSE_CONNTBL_LEN\t64\n\nstruct cuse_conn {\n\tstruct list_head\tlist;\t/* linked on cuse_conntbl */\n\tstruct fuse_conn\tfc;\t/* fuse connection */\n\tstruct cdev\t\t*cdev;\t/* associated character device */\n\tstruct device\t\t*dev;\t/* device representing @cdev */\n\n\t/* init parameters, set once during initialization */\n\tbool\t\t\tunrestricted_ioctl;\n};\n\nstatic DEFINE_MUTEX(cuse_lock);\t\t/* protects registration */\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\nstatic struct class *cuse_class;\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}\n\n\n/**************************************************************************\n * CUSE frontend operations\n *\n * These are file operations for the character device.\n *\n * On open, CUSE opens a file from the FUSE mnt and stores it to\n * private_data of the open file.  All other ops call FUSE ops on the\n * FUSE file.\n */\n\nstatic ssize_t cuse_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = kiocb->ki_filp };\n\tloff_t pos = 0;\n\n\treturn fuse_direct_io(&io, to, &pos, FUSE_DIO_CUSE);\n}\n\nstatic ssize_t cuse_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = kiocb->ki_filp };\n\tloff_t pos = 0;\n\t/*\n\t * No locking or generic_write_checks(), the server is\n\t * responsible for locking and sanity checks.\n\t */\n\treturn fuse_direct_io(&io, from, &pos,\n\t\t\t      FUSE_DIO_WRITE | FUSE_DIO_CUSE);\n}\n\nstatic int cuse_open(struct inode *inode, struct file *file)\n{\n\tdev_t devt = inode->i_cdev->dev;\n\tstruct cuse_conn *cc = NULL, *pos;\n\tint rc;\n\n\t/* look up and get the connection */\n\tmutex_lock(&cuse_lock);\n\tlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\n\t\tif (pos->dev->devt == devt) {\n\t\t\tfuse_conn_get(&pos->fc);\n\t\t\tcc = pos;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&cuse_lock);\n\n\t/* dead? */\n\tif (!cc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Generic permission check is already done against the chrdev\n\t * file, proceed to open.\n\t */\n\trc = fuse_do_open(&cc->fc, 0, file, 0);\n\tif (rc)\n\t\tfuse_conn_put(&cc->fc);\n\treturn rc;\n}\n\nstatic int cuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_sync_release(ff, file->f_flags);\n\tfuse_conn_put(fc);\n\n\treturn 0;\n}\n\nstatic long cuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = 0;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = FUSE_IOCTL_COMPAT;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic const struct file_operations cuse_frontend_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read_iter\t\t= cuse_read_iter,\n\t.write_iter\t\t= cuse_write_iter,\n\t.open\t\t\t= cuse_open,\n\t.release\t\t= cuse_release,\n\t.unlocked_ioctl\t\t= cuse_file_ioctl,\n\t.compat_ioctl\t\t= cuse_file_compat_ioctl,\n\t.poll\t\t\t= fuse_file_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n/**************************************************************************\n * CUSE channel initialization and destruction\n */\n\nstruct cuse_devinfo {\n\tconst char\t\t*name;\n};\n\n/**\n * cuse_parse_one - parse one key=value pair\n * @pp: i/o parameter for the current position\n * @end: points to one past the end of the packed string\n * @keyp: out parameter for key\n * @valp: out parameter for value\n *\n * *@pp points to packed strings - \"key0=val0\\0key1=val1\\0\" which ends\n * at @end - 1.  This function parses one pair and set *@keyp to the\n * start of the key and *@valp to the start of the value.  Note that\n * the original string is modified such that the key string is\n * terminated with '\\0'.  *@pp is updated to point to the next string.\n *\n * RETURNS:\n * 1 on successful parse, 0 on EOF, -errno on failure.\n */\nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}\n\n/**\n * cuse_parse_dev_info - parse device info\n * @p: device info string\n * @len: length of device info string\n * @devinfo: out parameter for parsed device info\n *\n * Parse @p to extract device info and store it into @devinfo.  String\n * pointed to by @p is modified by parsing and @devinfo points into\n * them, so @p shouldn't be freed while @devinfo is in use.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void cuse_gendev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\n/**\n * cuse_process_init_reply - finish initializing CUSE channel\n *\n * This function creates the character device and sets up all the\n * required data structures for it.  Please read the comment at the\n * top of this file for high level overview.\n */\nstatic void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc), *pos;\n\tstruct cuse_init_out *arg = req->out.args[0].value;\n\tstruct page *page = req->pages[0];\n\tstruct cuse_devinfo devinfo = { };\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tdev_t devt;\n\tint rc, i;\n\n\tif (req->out.h.error ||\n\t    arg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {\n\t\tgoto err;\n\t}\n\n\tfc->minor = arg->minor;\n\tfc->max_read = max_t(unsigned, arg->max_read, 4096);\n\tfc->max_write = max_t(unsigned, arg->max_write, 4096);\n\n\t/* parse init reply */\n\tcc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\n\n\trc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,\n\t\t\t\t&devinfo);\n\tif (rc)\n\t\tgoto err;\n\n\t/* determine and reserve devt */\n\tdevt = MKDEV(arg->dev_major, arg->dev_minor);\n\tif (!MAJOR(devt))\n\t\trc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\n\telse\n\t\trc = register_chrdev_region(devt, 1, devinfo.name);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"CUSE: failed to register chrdev region\\n\");\n\t\tgoto err;\n\t}\n\n\t/* devt determined, create device */\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto err_region;\n\n\tdevice_initialize(dev);\n\tdev_set_uevent_suppress(dev, 1);\n\tdev->class = cuse_class;\n\tdev->devt = devt;\n\tdev->release = cuse_gendev_release;\n\tdev_set_drvdata(dev, cc);\n\tdev_set_name(dev, \"%s\", devinfo.name);\n\n\tmutex_lock(&cuse_lock);\n\n\t/* make sure the device-name is unique */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\n\t\tlist_for_each_entry(pos, &cuse_conntbl[i], list)\n\t\t\tif (!strcmp(dev_name(pos->dev), dev_name(dev)))\n\t\t\t\tgoto err_unlock;\n\t}\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t/* register cdev */\n\trc = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto err_unlock;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &cuse_frontend_fops;\n\n\trc = cdev_add(cdev, devt, 1);\n\tif (rc)\n\t\tgoto err_cdev;\n\n\tcc->dev = dev;\n\tcc->cdev = cdev;\n\n\t/* make the device available */\n\tlist_add(&cc->list, cuse_conntbl_head(devt));\n\tmutex_unlock(&cuse_lock);\n\n\t/* announce device availability */\n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\nout:\n\tkfree(arg);\n\t__free_page(page);\n\treturn;\n\nerr_cdev:\n\tcdev_del(cdev);\nerr_unlock:\n\tmutex_unlock(&cuse_lock);\n\tput_device(dev);\nerr_region:\n\tunregister_chrdev_region(devt, 1);\nerr:\n\tfuse_abort_conn(fc);\n\tgoto out;\n}\n\nstatic int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}\n\nstatic void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}\n\n/**\n * cuse_channel_open - open method for /dev/cuse\n * @inode: inode for /dev/cuse\n * @file: file struct being opened\n *\n * Userland CUSE server can create a CUSE device by opening /dev/cuse\n * and replying to the initialization request kernel sends.  This\n * function is responsible for handling CUSE device initialization.\n * Because the fd opened by this function is used during\n * initialization, this function only creates cuse_conn and sends\n * init.  The rest is delegated to a kthread.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_channel_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud;\n\tstruct cuse_conn *cc;\n\tint rc;\n\n\t/* set up cuse_conn */\n\tcc = kzalloc(sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tfuse_conn_init(&cc->fc);\n\n\tfud = fuse_dev_alloc(&cc->fc);\n\tif (!fud) {\n\t\tkfree(cc);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&cc->list);\n\tcc->fc.release = cuse_fc_release;\n\n\tcc->fc.initialized = 1;\n\trc = cuse_send_init(cc);\n\tif (rc) {\n\t\tfuse_dev_free(fud);\n\t\treturn rc;\n\t}\n\tfile->private_data = fud;\n\n\treturn 0;\n}\n\n/**\n * cuse_channel_release - release method for /dev/cuse\n * @inode: inode for /dev/cuse\n * @file: file struct being closed\n *\n * Disconnect the channel, deregister CUSE device and initiate\n * destruction by putting the default reference.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\n\t/* remove from the conntbl, no more access from this point on */\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t/* remove device */\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\n\trc = fuse_dev_release(inode, file);\t/* puts the base reference */\n\n\treturn rc;\n}\n\nstatic struct file_operations cuse_channel_fops; /* initialized during init */\n\n\n/**************************************************************************\n * Misc stuff and module initializatiion\n *\n * CUSE exports the same set of attributes to sysfs as fusectl.\n */\n\nstatic ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}\nstatic DEVICE_ATTR(waiting, 0400, cuse_class_waiting_show, NULL);\n\nstatic ssize_t cuse_class_abort_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\tfuse_abort_conn(&cc->fc);\n\treturn count;\n}\nstatic DEVICE_ATTR(abort, 0200, NULL, cuse_class_abort_store);\n\nstatic struct attribute *cuse_class_dev_attrs[] = {\n\t&dev_attr_waiting.attr,\n\t&dev_attr_abort.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cuse_class_dev);\n\nstatic struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};\n\nMODULE_ALIAS_MISCDEV(CUSE_MINOR);\nMODULE_ALIAS(\"devname:cuse\");\n\nstatic int __init cuse_init(void)\n{\n\tint i, rc;\n\n\t/* init conntbl */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\n\t\tINIT_LIST_HEAD(&cuse_conntbl[i]);\n\n\t/* inherit and extend fuse_dev_operations */\n\tcuse_channel_fops\t\t= fuse_dev_operations;\n\tcuse_channel_fops.owner\t\t= THIS_MODULE;\n\tcuse_channel_fops.open\t\t= cuse_channel_open;\n\tcuse_channel_fops.release\t= cuse_channel_release;\n\n\tcuse_class = class_create(THIS_MODULE, \"cuse\");\n\tif (IS_ERR(cuse_class))\n\t\treturn PTR_ERR(cuse_class);\n\n\tcuse_class->dev_groups = cuse_class_dev_groups;\n\n\trc = misc_register(&cuse_miscdev);\n\tif (rc) {\n\t\tclass_destroy(cuse_class);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cuse_exit(void)\n{\n\tmisc_deregister(&cuse_miscdev);\n\tclass_destroy(cuse_class);\n}\n\nmodule_init(cuse_init);\nmodule_exit(cuse_exit);\n\nMODULE_AUTHOR(\"Tejun Heo <tj@kernel.org>\");\nMODULE_DESCRIPTION(\"Character device in Userspace\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * CUSE: Character device in Userspace\n *\n * Copyright (C) 2008-2009  SUSE Linux Products GmbH\n * Copyright (C) 2008-2009  Tejun Heo <tj@kernel.org>\n *\n * This file is released under the GPLv2.\n *\n * CUSE enables character devices to be implemented from userland much\n * like FUSE allows filesystems.  On initialization /dev/cuse is\n * created.  By opening the file and replying to the CUSE_INIT request\n * userland CUSE server can create a character device.  After that the\n * operation is very similar to FUSE.\n *\n * A CUSE instance involves the following objects.\n *\n * cuse_conn\t: contains fuse_conn and serves as bonding structure\n * channel\t: file handle connected to the userland CUSE server\n * cdev\t\t: the implemented character device\n * dev\t\t: generic device for cdev\n *\n * Note that 'channel' is what 'dev' is in FUSE.  As CUSE deals with\n * devices, it's called 'channel' to reduce confusion.\n *\n * channel determines when the character device dies.  When channel is\n * closed, everything begins to destruct.  The cuse_conn is taken off\n * the lookup table preventing further access from cdev, cdev and\n * generic device are removed and the base reference of cuse_conn is\n * put.\n *\n * On each open, the matching cuse_conn is looked up and if found an\n * additional reference is taken which is released when the file is\n * closed.\n */\n\n#include <linux/fuse.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/uio.h>\n\n#include \"fuse_i.h\"\n\n#define CUSE_CONNTBL_LEN\t64\n\nstruct cuse_conn {\n\tstruct list_head\tlist;\t/* linked on cuse_conntbl */\n\tstruct fuse_conn\tfc;\t/* fuse connection */\n\tstruct cdev\t\t*cdev;\t/* associated character device */\n\tstruct device\t\t*dev;\t/* device representing @cdev */\n\n\t/* init parameters, set once during initialization */\n\tbool\t\t\tunrestricted_ioctl;\n};\n\nstatic DEFINE_MUTEX(cuse_lock);\t\t/* protects registration */\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\nstatic struct class *cuse_class;\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}\n\n\n/**************************************************************************\n * CUSE frontend operations\n *\n * These are file operations for the character device.\n *\n * On open, CUSE opens a file from the FUSE mnt and stores it to\n * private_data of the open file.  All other ops call FUSE ops on the\n * FUSE file.\n */\n\nstatic ssize_t cuse_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = kiocb->ki_filp };\n\tloff_t pos = 0;\n\n\treturn fuse_direct_io(&io, to, &pos, FUSE_DIO_CUSE);\n}\n\nstatic ssize_t cuse_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = kiocb->ki_filp };\n\tloff_t pos = 0;\n\t/*\n\t * No locking or generic_write_checks(), the server is\n\t * responsible for locking and sanity checks.\n\t */\n\treturn fuse_direct_io(&io, from, &pos,\n\t\t\t      FUSE_DIO_WRITE | FUSE_DIO_CUSE);\n}\n\nstatic int cuse_open(struct inode *inode, struct file *file)\n{\n\tdev_t devt = inode->i_cdev->dev;\n\tstruct cuse_conn *cc = NULL, *pos;\n\tint rc;\n\n\t/* look up and get the connection */\n\tmutex_lock(&cuse_lock);\n\tlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\n\t\tif (pos->dev->devt == devt) {\n\t\t\tfuse_conn_get(&pos->fc);\n\t\t\tcc = pos;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&cuse_lock);\n\n\t/* dead? */\n\tif (!cc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Generic permission check is already done against the chrdev\n\t * file, proceed to open.\n\t */\n\trc = fuse_do_open(&cc->fc, 0, file, 0);\n\tif (rc)\n\t\tfuse_conn_put(&cc->fc);\n\treturn rc;\n}\n\nstatic int cuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_sync_release(ff, file->f_flags);\n\tfuse_conn_put(fc);\n\n\treturn 0;\n}\n\nstatic long cuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = 0;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = FUSE_IOCTL_COMPAT;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic const struct file_operations cuse_frontend_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read_iter\t\t= cuse_read_iter,\n\t.write_iter\t\t= cuse_write_iter,\n\t.open\t\t\t= cuse_open,\n\t.release\t\t= cuse_release,\n\t.unlocked_ioctl\t\t= cuse_file_ioctl,\n\t.compat_ioctl\t\t= cuse_file_compat_ioctl,\n\t.poll\t\t\t= fuse_file_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n/**************************************************************************\n * CUSE channel initialization and destruction\n */\n\nstruct cuse_devinfo {\n\tconst char\t\t*name;\n};\n\n/**\n * cuse_parse_one - parse one key=value pair\n * @pp: i/o parameter for the current position\n * @end: points to one past the end of the packed string\n * @keyp: out parameter for key\n * @valp: out parameter for value\n *\n * *@pp points to packed strings - \"key0=val0\\0key1=val1\\0\" which ends\n * at @end - 1.  This function parses one pair and set *@keyp to the\n * start of the key and *@valp to the start of the value.  Note that\n * the original string is modified such that the key string is\n * terminated with '\\0'.  *@pp is updated to point to the next string.\n *\n * RETURNS:\n * 1 on successful parse, 0 on EOF, -errno on failure.\n */\nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}\n\n/**\n * cuse_parse_dev_info - parse device info\n * @p: device info string\n * @len: length of device info string\n * @devinfo: out parameter for parsed device info\n *\n * Parse @p to extract device info and store it into @devinfo.  String\n * pointed to by @p is modified by parsing and @devinfo points into\n * them, so @p shouldn't be freed while @devinfo is in use.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void cuse_gendev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\n/**\n * cuse_process_init_reply - finish initializing CUSE channel\n *\n * This function creates the character device and sets up all the\n * required data structures for it.  Please read the comment at the\n * top of this file for high level overview.\n */\nstatic void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc), *pos;\n\tstruct cuse_init_out *arg = req->out.args[0].value;\n\tstruct page *page = req->pages[0];\n\tstruct cuse_devinfo devinfo = { };\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tdev_t devt;\n\tint rc, i;\n\n\tif (req->out.h.error ||\n\t    arg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {\n\t\tgoto err;\n\t}\n\n\tfc->minor = arg->minor;\n\tfc->max_read = max_t(unsigned, arg->max_read, 4096);\n\tfc->max_write = max_t(unsigned, arg->max_write, 4096);\n\n\t/* parse init reply */\n\tcc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\n\n\trc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,\n\t\t\t\t&devinfo);\n\tif (rc)\n\t\tgoto err;\n\n\t/* determine and reserve devt */\n\tdevt = MKDEV(arg->dev_major, arg->dev_minor);\n\tif (!MAJOR(devt))\n\t\trc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\n\telse\n\t\trc = register_chrdev_region(devt, 1, devinfo.name);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"CUSE: failed to register chrdev region\\n\");\n\t\tgoto err;\n\t}\n\n\t/* devt determined, create device */\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto err_region;\n\n\tdevice_initialize(dev);\n\tdev_set_uevent_suppress(dev, 1);\n\tdev->class = cuse_class;\n\tdev->devt = devt;\n\tdev->release = cuse_gendev_release;\n\tdev_set_drvdata(dev, cc);\n\tdev_set_name(dev, \"%s\", devinfo.name);\n\n\tmutex_lock(&cuse_lock);\n\n\t/* make sure the device-name is unique */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\n\t\tlist_for_each_entry(pos, &cuse_conntbl[i], list)\n\t\t\tif (!strcmp(dev_name(pos->dev), dev_name(dev)))\n\t\t\t\tgoto err_unlock;\n\t}\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t/* register cdev */\n\trc = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto err_unlock;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &cuse_frontend_fops;\n\n\trc = cdev_add(cdev, devt, 1);\n\tif (rc)\n\t\tgoto err_cdev;\n\n\tcc->dev = dev;\n\tcc->cdev = cdev;\n\n\t/* make the device available */\n\tlist_add(&cc->list, cuse_conntbl_head(devt));\n\tmutex_unlock(&cuse_lock);\n\n\t/* announce device availability */\n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\nout:\n\tkfree(arg);\n\t__free_page(page);\n\treturn;\n\nerr_cdev:\n\tcdev_del(cdev);\nerr_unlock:\n\tmutex_unlock(&cuse_lock);\n\tput_device(dev);\nerr_region:\n\tunregister_chrdev_region(devt, 1);\nerr:\n\tfuse_abort_conn(fc);\n\tgoto out;\n}\n\nstatic int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}\n\nstatic void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}\n\n/**\n * cuse_channel_open - open method for /dev/cuse\n * @inode: inode for /dev/cuse\n * @file: file struct being opened\n *\n * Userland CUSE server can create a CUSE device by opening /dev/cuse\n * and replying to the initialization request kernel sends.  This\n * function is responsible for handling CUSE device initialization.\n * Because the fd opened by this function is used during\n * initialization, this function only creates cuse_conn and sends\n * init.  The rest is delegated to a kthread.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_channel_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud;\n\tstruct cuse_conn *cc;\n\tint rc;\n\n\t/* set up cuse_conn */\n\tcc = kzalloc(sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tfuse_conn_init(&cc->fc);\n\n\tfud = fuse_dev_alloc(&cc->fc);\n\tif (!fud) {\n\t\tkfree(cc);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&cc->list);\n\tcc->fc.release = cuse_fc_release;\n\n\tcc->fc.initialized = 1;\n\trc = cuse_send_init(cc);\n\tif (rc) {\n\t\tfuse_dev_free(fud);\n\t\treturn rc;\n\t}\n\tfile->private_data = fud;\n\n\treturn 0;\n}\n\n/**\n * cuse_channel_release - release method for /dev/cuse\n * @inode: inode for /dev/cuse\n * @file: file struct being closed\n *\n * Disconnect the channel, deregister CUSE device and initiate\n * destruction by putting the default reference.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nstatic int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\n\t/* remove from the conntbl, no more access from this point on */\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t/* remove device */\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\t/* Base reference is now owned by \"fud\" */\n\tfuse_conn_put(&cc->fc);\n\n\trc = fuse_dev_release(inode, file);\t/* puts the base reference */\n\n\treturn rc;\n}\n\nstatic struct file_operations cuse_channel_fops; /* initialized during init */\n\n\n/**************************************************************************\n * Misc stuff and module initializatiion\n *\n * CUSE exports the same set of attributes to sysfs as fusectl.\n */\n\nstatic ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}\nstatic DEVICE_ATTR(waiting, 0400, cuse_class_waiting_show, NULL);\n\nstatic ssize_t cuse_class_abort_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\tfuse_abort_conn(&cc->fc);\n\treturn count;\n}\nstatic DEVICE_ATTR(abort, 0200, NULL, cuse_class_abort_store);\n\nstatic struct attribute *cuse_class_dev_attrs[] = {\n\t&dev_attr_waiting.attr,\n\t&dev_attr_abort.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cuse_class_dev);\n\nstatic struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};\n\nMODULE_ALIAS_MISCDEV(CUSE_MINOR);\nMODULE_ALIAS(\"devname:cuse\");\n\nstatic int __init cuse_init(void)\n{\n\tint i, rc;\n\n\t/* init conntbl */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\n\t\tINIT_LIST_HEAD(&cuse_conntbl[i]);\n\n\t/* inherit and extend fuse_dev_operations */\n\tcuse_channel_fops\t\t= fuse_dev_operations;\n\tcuse_channel_fops.owner\t\t= THIS_MODULE;\n\tcuse_channel_fops.open\t\t= cuse_channel_open;\n\tcuse_channel_fops.release\t= cuse_channel_release;\n\n\tcuse_class = class_create(THIS_MODULE, \"cuse\");\n\tif (IS_ERR(cuse_class))\n\t\treturn PTR_ERR(cuse_class);\n\n\tcuse_class->dev_groups = cuse_class_dev_groups;\n\n\trc = misc_register(&cuse_miscdev);\n\tif (rc) {\n\t\tclass_destroy(cuse_class);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cuse_exit(void)\n{\n\tmisc_deregister(&cuse_miscdev);\n\tclass_destroy(cuse_class);\n}\n\nmodule_init(cuse_init);\nmodule_exit(cuse_exit);\n\nMODULE_AUTHOR(\"Tejun Heo <tj@kernel.org>\");\nMODULE_DESCRIPTION(\"Character device in Userspace\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["fs/fuse/cuse.c"], "buggy_code_start_loc": [551], "buggy_code_end_loc": [551], "fixing_code_start_loc": [552], "fixing_code_end_loc": [554], "type": "CWE-399", "message": "Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times.", "other": {"cve": {"id": "CVE-2015-1339", "sourceIdentifier": "security@ubuntu.com", "published": "2016-04-27T17:59:00.117", "lastModified": "2016-12-01T02:59:20.277", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times."}, {"lang": "es", "value": "Fuga de memoria en la funci\u00f3n cuse_channel_release en fs/fuse/cuse.c en el kernel de Linux en versiones anteriores a 4.4 permite a usuarios locales provocar una denegaci\u00f3n de servicio (consumo de memoria) o posiblemente tener otro impacto no especificado abriendo /dev/cuse muchas veces."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.6", "matchCriteriaId": "2B389602-4271-4CF2-BA64-4B0DAD8AB4A9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_debuginfo:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "B942E0F5-7FDC-4AE5-985D-25F4EA7406F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "BFF56CE7-91EF-4FF9-B306-5F00249D9FEA"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2c5816b4beccc8ba709144539f6fdd764f8fa49c", "source": "security@ubuntu.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00015.html", "source": "security@ubuntu.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00059.html", "source": "security@ubuntu.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/03/02/13", "source": "security@ubuntu.com", "tags": ["Patch"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=969356", "source": "security@ubuntu.com", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1314331", "source": "security@ubuntu.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c", "source": "security@ubuntu.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2015-1339", "source": "security@ubuntu.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c"}}