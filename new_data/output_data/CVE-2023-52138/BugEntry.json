{"buggy_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */\n\n/*\n *  Engrampa\n *\n *  Copyright (C) 2006 The Free Software Foundation, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include <config.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <glib.h>\n\n#include \"file-data.h\"\n#include \"file-utils.h\"\n#include \"glib-utils.h\"\n#include \"fr-command.h\"\n#include \"fr-command-cpio.h\"\n\nstatic void fr_command_cpio_class_init  (FrCommandCpioClass *class);\nstatic void fr_command_cpio_init        (FrCommand         *afile);\nstatic void fr_command_cpio_finalize    (GObject           *object);\n\n/* Parent Class */\n\nstatic FrCommandClass *parent_class = NULL;\n\n/* -- list -- */\n\nstatic time_t\nmktime_from_string (char *month,\n\t\t    char *mday,\n\t\t    char *year)\n{\n\tstruct tm tm = {0, };\n\n\ttm.tm_isdst = -1;\n\n\tif (month != NULL) {\n\t\tstatic const char *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\t                                \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\t\tint i;\n\n\t\tfor (i = 0; i < 12; i++) {\n\t\t\tif (strcmp (months[i], month) == 0) {\n\t\t\t\ttm.tm_mon = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ttm.tm_mday = atoi (mday);\n\tif (strchr (year, ':') != NULL) {\n\t\tchar **fields = g_strsplit (year, \":\", 2);\n\t\tif ((fields != NULL) && (g_strv_length (fields) == 2)) {\n\t        \ttime_t      now;\n        \t\tstruct tm  *now_tm;\n\n\t  \t\ttm.tm_hour = atoi (fields[0]);\n\t  \t\ttm.tm_min = atoi (fields[1]);\n\n\t  \t\tnow = time(NULL);\n\t  \t\tnow_tm = localtime (&now);\n\t  \t\ttm.tm_year = now_tm->tm_year;\n        \t}\n\t} else\n\t\ttm.tm_year = atoi (year) - 1900;\n\n\treturn mktime (&tm);\n}\n\nstatic void\nlist__process_line (char     *line,\n\t\t    gpointer  data)\n{\n\tFileData    *fdata;\n\tFrCommand   *comm = FR_COMMAND (data);\n\tchar       **fields;\n\tconst char  *name_field;\n\tchar        *name;\n\tint          ofs = 0;\n\n\tg_return_if_fail (line != NULL);\n\n\tfdata = file_data_new ();\n\n#ifdef __sun\n\tfields = split_line (line, 9);\n\tfdata->size = g_ascii_strtoull (fields[4], NULL, 10);\n\tfdata->modified = mktime_from_string (fields[5], fields[6], fields[8]);\n\tg_strfreev (fields);\n\n\tname_field = get_last_field (line, 10);\n#else /* !__sun */\n\t/* Handle char and block device files */\n\tif ((line[0] == 'c') || (line[0] == 'b')) {\n\t\tfields = split_line (line, 9);\n\t\tofs = 1;\n\t\tfdata->size = 0;\n\t\t/* FIXME: We should also specify the content type */\n\t}\n\telse {\n\t\tfields = split_line (line, 8);\n\t\tfdata->size = g_ascii_strtoull (fields[4], NULL, 10);\n\t}\n\tfdata->modified = mktime_from_string (fields[5+ofs], fields[6+ofs], fields[7+ofs]);\n\tg_strfreev (fields);\n\n\tname_field = get_last_field (line, 9+ofs);\n#endif /* !__sun */\n\n\tfields = g_strsplit (name_field, \" -> \", 2);\n\n\tif (fields[1] == NULL) {\n\t\tg_strfreev (fields);\n\t\tfields = g_strsplit (name_field, \" link to \", 2);\n\t}\n\n\tfdata->dir = line[0] == 'd';\n\n\tname = g_strcompress (fields[0]);\n\tif (*(fields[0]) == '/') {\n\t\tfdata->full_path = g_strdup (name);\n\t\tfdata->original_path = fdata->full_path;\n\t}\n\telse {\n\t\tfdata->full_path = g_strconcat (\"/\", name, NULL);\n\t\tfdata->original_path = fdata->full_path + 1;\n\t}\n\n\tif (fdata->dir && (name[strlen (name) - 1] != '/')) {\n\t\tchar *old_full_path = fdata->full_path;\n\t\tfdata->full_path = g_strconcat (old_full_path, \"/\", NULL);\n\t\tg_free (old_full_path);\n\t\tfdata->original_path = g_strdup (name);\n\t\tfdata->free_original_path = TRUE;\n\t}\n\tg_free (name);\n\n\tif (fields[1] != NULL)\n\t\tfdata->link = g_strcompress (fields[1]);\n\tg_strfreev (fields);\n\n\tif (fdata->dir)\n\t\tfdata->name = dir_name_from_path (fdata->full_path);\n\telse\n\t\tfdata->name = g_strdup (file_name_from_path (fdata->full_path));\n\tfdata->path = remove_level_from_path (fdata->full_path);\n\n\tif (*fdata->name == 0)\n\t\tfile_data_free (fdata);\n\telse\n\t\tfr_command_add_file (comm, fdata);\n}\n\nstatic void\nfr_command_cpio_list (FrCommand  *comm)\n{\n\tfr_process_set_out_line_func (comm->process, list__process_line, comm);\n\n\tfr_process_begin_command (comm->process, \"sh\");\n\tfr_process_add_arg (comm->process, \"-c\");\n\tfr_process_add_arg_concat (comm->process, CPIO_PATH \" -itv < \", comm->e_filename, NULL);\n\tfr_process_end_command (comm->process);\n\tfr_process_start (comm->process);\n}\n\nstatic void\nfr_command_cpio_extract (FrCommand *comm,\n\t\t\tconst char *from_file,\n\t\t\tGList      *file_list,\n\t\t\tconst char *dest_dir,\n\t\t\tgboolean    overwrite,\n\t\t\tgboolean    skip_older,\n\t\t\tgboolean    junk_paths)\n{\n\tGList   *scan;\n\tGString *cmd;\n\n\tfr_process_begin_command (comm->process, \"sh\");\n\tif (dest_dir != NULL)\n                fr_process_set_working_dir (comm->process, dest_dir);\n\tfr_process_add_arg (comm->process, \"-c\");\n\n\tcmd = g_string_new (\"cpio -idu --no-absolute-filenames \");\n\tfor (scan = file_list; scan; scan = scan->next) {\n\t\tchar *filepath = scan->data;\n\t\tchar *filename;\n\n\t\tif (filepath[0] == '/')\n\t\t\tfilename = g_shell_quote (filepath + 1);\n\t\telse\n\t\t\tfilename = g_shell_quote (filepath);\n\t\tg_string_append (cmd, filename);\n\t\tg_string_append (cmd, \" \");\n\n\t\tg_free (filename);\n\t}\n        g_string_append (cmd, \" < \");\n\tg_string_append (cmd, comm->e_filename);\n\tfr_process_add_arg (comm->process, cmd->str);\n\tg_string_free (cmd, TRUE);\n\n\tfr_process_end_command (comm->process);\n}\n\nconst char *cpio_mime_type[] = { \"application/x-cpio\", NULL };\n\nstatic const char **\nfr_command_cpio_get_mime_types (FrCommand *comm)\n{\n\treturn cpio_mime_type;\n}\n\nstatic FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}\n\nstatic const char *\nfr_command_cpio_get_packages (FrCommand  *comm,\n\t\t\t      const char *mime_type)\n{\n\treturn PACKAGES (\"cpio\");\n}\n\nstatic void\nfr_command_cpio_class_init (FrCommandCpioClass *class)\n{\n        GObjectClass   *gobject_class = G_OBJECT_CLASS (class);\n        FrCommandClass *afc;\n\n        parent_class = g_type_class_peek_parent (class);\n\tafc = (FrCommandClass*) class;\n\n\tgobject_class->finalize = fr_command_cpio_finalize;\n\n        afc->list             = fr_command_cpio_list;\n\tafc->extract          = fr_command_cpio_extract;\n\tafc->get_mime_types   = fr_command_cpio_get_mime_types;\n\tafc->get_capabilities = fr_command_cpio_get_capabilities;\n\tafc->get_packages     = fr_command_cpio_get_packages;\n}\n\nstatic void\nfr_command_cpio_init (FrCommand *comm)\n{\n\tcomm->propAddCanUpdate             = FALSE;\n\tcomm->propAddCanReplace            = FALSE;\n\tcomm->propAddCanStoreFolders       = FALSE;\n\tcomm->propExtractCanAvoidOverwrite = FALSE;\n\tcomm->propExtractCanSkipOlder      = FALSE;\n\tcomm->propExtractCanJunkPaths      = FALSE;\n\tcomm->propPassword                 = FALSE;\n\tcomm->propTest                     = FALSE;\n}\n\nstatic void\nfr_command_cpio_finalize (GObject *object)\n{\n        g_return_if_fail (object != NULL);\n        g_return_if_fail (FR_IS_COMMAND_CPIO (object));\n\n\t/* Chain up */\n        if (G_OBJECT_CLASS (parent_class)->finalize)\n\t\tG_OBJECT_CLASS (parent_class)->finalize (object);\n}\n\nGType\nfr_command_cpio_get_type ()\n{\n        static GType type = 0;\n\n        if (! type) {\n                GTypeInfo type_info = {\n\t\t\tsizeof (FrCommandCpioClass),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t(GClassInitFunc) fr_command_cpio_class_init,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tsizeof (FrCommandCpio),\n\t\t\t0,\n\t\t\t(GInstanceInitFunc) fr_command_cpio_init,\n\t\t\tNULL\n\t\t};\n\n\t\ttype = g_type_register_static (FR_TYPE_COMMAND,\n\t\t\t\t\t       \"FRCommandCpio\",\n\t\t\t\t\t       &type_info,\n\t\t\t\t\t       0);\n        }\n\n        return type;\n}\n", "/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */\n\n/*\n *  File-Roller\n *\n *  Copyright (C) 2012 The Free Software Foundation, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define _XOPEN_SOURCE       /* See feature_test_macros(7) */\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n#include <glib/gi18n.h>\n#include <json-glib/json-glib.h>\n#include \"file-data.h\"\n#include \"file-utils.h\"\n#include \"gio-utils.h\"\n#include \"glib-utils.h\"\n#include \"fr-command.h\"\n#include \"fr-command-unarchiver.h\"\n#include \"fr-error.h\"\n\n#define LSAR_SUPPORTED_FORMAT 2\n#define LSAR_DATE_FORMAT \"%Y-%m-%d %H:%M:%S %z\"\n\nstatic void fr_command_unarchiver_class_init  (FrCommandUnarchiverClass *class);\nstatic void fr_command_unarchiver_init        (FrCommand         *afile);\nstatic void fr_command_unarchiver_finalize    (GObject           *object);\n\n/* Parent Class */\n\nstatic FrCommandClass *parent_class = NULL;\n\n/* -- list -- */\n\nstatic void\nprocess_line (char     *line,\n\t      gpointer  data)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (data);\n\tg_memory_input_stream_add_data (G_MEMORY_INPUT_STREAM (unar_comm->stream), line, -1, NULL);\n}\n\nstatic time_t\nmktime_from_string (const char *time_s)\n{\n\tstruct tm tm = {0, };\n\ttm.tm_isdst = -1;\n\tstrptime (time_s, LSAR_DATE_FORMAT, &tm);\n\treturn mktime (&tm);\n}\n\nstatic void\nlist_command_completed (gpointer data)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (data);\n\tJsonParser          *parser;\n\tGError              *error = NULL;\n\n\tparser = json_parser_new ();\n\tif (json_parser_load_from_stream (parser, unar_comm->stream, NULL, &error)) {\n\t\tJsonObject *root;\n\n\t\troot = json_node_get_object (json_parser_get_root (parser));\n\n\t\tif (json_object_get_int_member (root, \"lsarFormatVersion\") == LSAR_SUPPORTED_FORMAT) {\n\t\t\tJsonArray *content;\n\t\t\tguint      i;\n\n\t\t\tcontent = json_object_get_array_member (root, \"lsarContents\");\n\t\t\tfor (i = 0; i < json_array_get_length (content); i++) {\n\t\t\t\tJsonObject *entry;\n\t\t\t\tFileData   *fdata;\n\t\t\t\tconst char *filename;\n\n\t\t\t\tentry = json_array_get_object_element (content, i);\n\t\t\t\tfdata = file_data_new ();\n\t\t\t\tfdata->size = json_object_get_int_member (entry, \"XADFileSize\");\n\t\t\t\tfdata->modified = mktime_from_string (json_object_get_string_member (entry, \"XADLastModificationDate\"));\n\t\t\t\tif (json_object_has_member (entry, \"XADIsEncrypted\"))\n\t\t\t\t\tfdata->encrypted = json_object_get_int_member (entry, \"XADIsEncrypted\") == 1;\n\n\t\t\t\tfilename = json_object_get_string_member (entry, \"XADFileName\");\n\t\t\t\tif (*filename == '/') {\n\t\t\t\t\tfdata->full_path = g_strdup (filename);\n\t\t\t\t\tfdata->original_path = fdata->full_path;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfdata->full_path = g_strconcat (\"/\", filename, NULL);\n\t\t\t\t\tfdata->original_path = fdata->full_path + 1;\n\t\t\t\t}\n\n\t\t\t\tfdata->link = NULL;\n\t\t\t\tif (json_object_has_member (entry, \"XADIsDirectory\"))\n\t\t\t\t\tfdata->dir = json_object_get_int_member (entry, \"XADIsDirectory\") == 1;\n\t\t\t\tif (fdata->dir)\n\t\t\t\t\tfdata->name = dir_name_from_path (fdata->full_path);\n\t\t\t\telse\n\t\t\t\t\tfdata->name = g_strdup (file_name_from_path (fdata->full_path));\n\t\t\t\tfdata->path = remove_level_from_path (fdata->full_path);\n\n\t\t\t\tfr_command_add_file (FR_COMMAND (unar_comm), fdata);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_object_unref (parser);\n}\n\nstatic void\nfr_command_unarchiver_list (FrCommand  *comm)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\n\t_g_object_unref (unar_comm->stream);\n\tunar_comm->stream = g_memory_input_stream_new ();\n\n\tfr_process_set_out_line_func (comm->process, process_line, comm);\n\n\tfr_process_begin_command (comm->process, \"lsar\");\n\tfr_process_set_end_func (comm->process, list_command_completed, comm);\n\tfr_process_add_arg (comm->process, \"-j\");\n\tif ((comm->password != NULL) && (comm->password[0] != '\\0'))\n\t\tfr_process_add_arg_concat (comm->process, \"-password=\", comm->password, NULL);\n\tfr_process_add_arg (comm->process, comm->filename);\n\tfr_process_end_command (comm->process);\n\n\tfr_process_start (comm->process);\n}\n\nstatic void\nprocess_line__extract (char     *line,\n\t\t       gpointer  data)\n{\n\tFrCommand           *comm = FR_COMMAND (data);\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\n\tif (line == NULL)\n\t\treturn;\n\n\tunar_comm->n_line++;\n\n\t/* the first line is the name of the archive */\n\tif (unar_comm->n_line == 1)\n\t\treturn;\n\n\tif (comm->n_files > 1) {\n\t\tdouble fraction = (double) ++comm->n_file / (comm->n_files + 1);\n\t\tfr_command_progress (comm, CLAMP (fraction, 0.0, 1.0));\n\t}\n\telse\n\t\tfr_command_message (comm, line);\n}\n\nstatic void\nfr_command_unarchiver_extract (FrCommand  *comm,\n\t\t\t       const char *from_file,\n\t\t\t       GList      *file_list,\n\t\t\t       const char *dest_dir,\n\t\t\t       gboolean    overwrite,\n\t\t\t       gboolean    skip_older,\n\t\t\t       gboolean    junk_paths)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\tGList               *scan;\n\n\tunar_comm->n_line = 0;\n\n\tfr_process_use_standard_locale (comm->process, TRUE);\n\tfr_process_set_out_line_func (comm->process,\n\t\t\t\t      process_line__extract,\n\t\t\t\t      comm);\n\n\tfr_process_begin_command (comm->process, \"unar\");\n\n\tif (overwrite)\n\t\tfr_process_add_arg (comm->process, \"-f\");\n\telse\n\t\tfr_process_add_arg (comm->process, \"-s\");\n\n\tfr_process_add_arg (comm->process, \"-D\");\n\n\tif ((comm->password != NULL) && (comm->password[0] != '\\0'))\n\t\tfr_process_add_arg_concat (comm->process, \"-password=\", comm->password, NULL);\n\n\tif (dest_dir != NULL)\n\t\tfr_process_add_arg_concat (comm->process, \"-output-directory=\", dest_dir, NULL);\n\n\tfr_process_add_arg (comm->process, comm->filename);\n\n\tfor (scan = file_list; scan; scan = scan->next) {\n\t\tchar *escaped;\n\n\t\tescaped = escape_str (scan->data, \"[?\");\n\t\tfr_process_add_arg (comm->process, escaped);\n\t\tg_free (escaped);\n\t}\n\n\tfr_process_end_command (comm->process);\n}\n\nstatic void\nfr_command_unarchiver_handle_error (FrCommand   *comm,\n\t\t\t\t    FrProcError *error)\n{\n\tGList *scan;\n\n#if 0\n\t{\n\t\tfor (scan = g_list_last (comm->process->err.raw); scan; scan = scan->prev)\n\t\t\tg_print (\"%s\\n\", (char*)scan->data);\n\t}\n#endif\n\n\tif (error->type == FR_PROC_ERROR_NONE)\n\t\treturn;\n\n\tif (error->type == FR_PROC_ERROR_COMMAND_ERROR) {\n\t\tfor (scan = g_list_last (comm->process->out.raw); scan; scan = scan->prev) {\n\t\t\tchar *line = scan->data;\n\n\t\t\tif ((strstr (line, \"This archive requires a password to unpack.\") != NULL)  ||\n\t\t\t    (strstr (line, \"Failed! (Missing or wrong password)\") != NULL)) {\n\n\t\t\t\terror->type = FR_PROC_ERROR_ASK_PASSWORD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst char *unarchiver_mime_type[] = { \"application/zip\",\n\t\t\t\t       \"application/x-cbr\",\n\t\t\t\t       \"application/x-rar\",\n\t\t\t\t       NULL };\n\nstatic const char **\nfr_command_unarchiver_get_mime_types (FrCommand *comm)\n{\n\treturn unarchiver_mime_type;\n}\n\nstatic FrCommandCaps\nfr_command_unarchiver_get_capabilities (FrCommand  *comm,\n\t\t\t\t\tconst char *mime_type,\n\t\t\t\t\tgboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_DO_NOTHING;\n\tif (is_program_available (\"lsar\", check_command) && is_program_available (\"unar\", check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}\n\nstatic const char *\nfr_command_unarchiver_get_packages (FrCommand  *comm,\n\t\t\t\t    const char *mime_type)\n{\n\treturn PACKAGES (\"unarchiver\");\n}\n\nstatic void\nfr_command_unarchiver_class_init (FrCommandUnarchiverClass *class)\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS (class);\n\tFrCommandClass *afc;\n\n\tparent_class = g_type_class_peek_parent (class);\n\tafc = (FrCommandClass*) class;\n\n\tgobject_class->finalize = fr_command_unarchiver_finalize;\n\n\tafc->list             = fr_command_unarchiver_list;\n\tafc->extract          = fr_command_unarchiver_extract;\n\tafc->handle_error     = fr_command_unarchiver_handle_error;\n\tafc->get_mime_types   = fr_command_unarchiver_get_mime_types;\n\tafc->get_capabilities = fr_command_unarchiver_get_capabilities;\n\tafc->get_packages     = fr_command_unarchiver_get_packages;\n}\n\nstatic void\nfr_command_unarchiver_init (FrCommand *comm)\n{\n\tFrCommandUnarchiver *unar_comm;\n\n\tcomm->propExtractCanAvoidOverwrite = TRUE;\n\tcomm->propExtractCanSkipOlder      = FALSE;\n\tcomm->propExtractCanJunkPaths      = FALSE;\n\tcomm->propPassword                 = TRUE;\n\tcomm->propTest                     = FALSE;\n\tcomm->propListFromFile             = FALSE;\n\n\tunar_comm = FR_COMMAND_UNARCHIVER (comm);\n\tunar_comm->stream = NULL;\n}\n\nstatic void\nfr_command_unarchiver_finalize (GObject *object)\n{\n\tFrCommandUnarchiver *unar_comm;\n\n\tg_return_if_fail (object != NULL);\n\tg_return_if_fail (FR_IS_COMMAND_UNARCHIVER (object));\n\n\tunar_comm = FR_COMMAND_UNARCHIVER (object);\n\t_g_object_unref (unar_comm->stream);\n\n\t/* Chain up */\n\tif (G_OBJECT_CLASS (parent_class)->finalize)\n\t\tG_OBJECT_CLASS (parent_class)->finalize (object);\n}\n\nGType\nfr_command_unarchiver_get_type ()\n{\n\tstatic GType type = 0;\n\n\tif (! type) {\n\t\tGTypeInfo type_info = {\n\t\t\tsizeof (FrCommandUnarchiverClass),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t(GClassInitFunc) fr_command_unarchiver_class_init,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tsizeof (FrCommandUnarchiver),\n\t\t\t0,\n\t\t\t(GInstanceInitFunc) fr_command_unarchiver_init,\n\t\t\tNULL\n\t\t};\n\n\t\ttype = g_type_register_static (FR_TYPE_COMMAND,\n\t\t\t\t\t       \"FrCommandUnarchiver\",\n\t\t\t\t\t       &type_info,\n\t\t\t\t\t       0);\n\t}\n\n\treturn type;\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */\n\n/*\n *  Engrampa\n *\n *  Copyright (C) 2006 The Free Software Foundation, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include <config.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <glib.h>\n\n#include \"file-data.h\"\n#include \"file-utils.h\"\n#include \"glib-utils.h\"\n#include \"fr-command.h\"\n#include \"fr-command-cpio.h\"\n\nstatic void fr_command_cpio_class_init  (FrCommandCpioClass *class);\nstatic void fr_command_cpio_init        (FrCommand         *afile);\nstatic void fr_command_cpio_finalize    (GObject           *object);\n\n/* Parent Class */\n\nstatic FrCommandClass *parent_class = NULL;\n\n/* -- list -- */\n\nstatic time_t\nmktime_from_string (char *month,\n\t\t    char *mday,\n\t\t    char *year)\n{\n\tstruct tm tm = {0, };\n\n\ttm.tm_isdst = -1;\n\n\tif (month != NULL) {\n\t\tstatic const char *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\t                                \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\t\tint i;\n\n\t\tfor (i = 0; i < 12; i++) {\n\t\t\tif (strcmp (months[i], month) == 0) {\n\t\t\t\ttm.tm_mon = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ttm.tm_mday = atoi (mday);\n\tif (strchr (year, ':') != NULL) {\n\t\tchar **fields = g_strsplit (year, \":\", 2);\n\t\tif ((fields != NULL) && (g_strv_length (fields) == 2)) {\n\t        \ttime_t      now;\n        \t\tstruct tm  *now_tm;\n\n\t  \t\ttm.tm_hour = atoi (fields[0]);\n\t  \t\ttm.tm_min = atoi (fields[1]);\n\n\t  \t\tnow = time(NULL);\n\t  \t\tnow_tm = localtime (&now);\n\t  \t\ttm.tm_year = now_tm->tm_year;\n        \t}\n\t} else\n\t\ttm.tm_year = atoi (year) - 1900;\n\n\treturn mktime (&tm);\n}\n\nstatic void\nlist__process_line (char     *line,\n\t\t    gpointer  data)\n{\n\tFileData    *fdata;\n\tFrCommand   *comm = FR_COMMAND (data);\n\tchar       **fields;\n\tconst char  *name_field;\n\tchar        *name;\n\tint          ofs = 0;\n\n\tg_return_if_fail (line != NULL);\n\n\tfdata = file_data_new ();\n\n#ifdef __sun\n\tfields = split_line (line, 9);\n\tfdata->size = g_ascii_strtoull (fields[4], NULL, 10);\n\tfdata->modified = mktime_from_string (fields[5], fields[6], fields[8]);\n\tg_strfreev (fields);\n\n\tname_field = get_last_field (line, 10);\n#else /* !__sun */\n\t/* Handle char and block device files */\n\tif ((line[0] == 'c') || (line[0] == 'b')) {\n\t\tfields = split_line (line, 9);\n\t\tofs = 1;\n\t\tfdata->size = 0;\n\t\t/* FIXME: We should also specify the content type */\n\t}\n\telse {\n\t\tfields = split_line (line, 8);\n\t\tfdata->size = g_ascii_strtoull (fields[4], NULL, 10);\n\t}\n\tfdata->modified = mktime_from_string (fields[5+ofs], fields[6+ofs], fields[7+ofs]);\n\tg_strfreev (fields);\n\n\tname_field = get_last_field (line, 9+ofs);\n#endif /* !__sun */\n\n\tfields = g_strsplit (name_field, \" -> \", 2);\n\n\tif (fields[1] == NULL) {\n\t\tg_strfreev (fields);\n\t\tfields = g_strsplit (name_field, \" link to \", 2);\n\t}\n\n\tfdata->dir = line[0] == 'd';\n\n\tname = g_strcompress (fields[0]);\n\tif (*(fields[0]) == '/') {\n\t\tfdata->full_path = g_strdup (name);\n\t\tfdata->original_path = fdata->full_path;\n\t}\n\telse {\n\t\tfdata->full_path = g_strconcat (\"/\", name, NULL);\n\t\tfdata->original_path = fdata->full_path + 1;\n\t}\n\n\tif (fdata->dir && (name[strlen (name) - 1] != '/')) {\n\t\tchar *old_full_path = fdata->full_path;\n\t\tfdata->full_path = g_strconcat (old_full_path, \"/\", NULL);\n\t\tg_free (old_full_path);\n\t\tfdata->original_path = g_strdup (name);\n\t\tfdata->free_original_path = TRUE;\n\t}\n\tg_free (name);\n\n\tif (fields[1] != NULL)\n\t\tfdata->link = g_strcompress (fields[1]);\n\tg_strfreev (fields);\n\n\tif (fdata->dir)\n\t\tfdata->name = dir_name_from_path (fdata->full_path);\n\telse\n\t\tfdata->name = g_strdup (file_name_from_path (fdata->full_path));\n\tfdata->path = remove_level_from_path (fdata->full_path);\n\n\tif (*fdata->name == 0)\n\t\tfile_data_free (fdata);\n\telse\n\t\tfr_command_add_file (comm, fdata);\n}\n\nstatic void\nfr_command_cpio_list (FrCommand  *comm)\n{\n\tfr_process_set_out_line_func (comm->process, list__process_line, comm);\n\n\tfr_process_begin_command (comm->process, \"sh\");\n\tfr_process_add_arg (comm->process, \"-c\");\n\tfr_process_add_arg_concat (comm->process, CPIO_PATH \" -itv < \", comm->e_filename, NULL);\n\tfr_process_end_command (comm->process);\n\tfr_process_start (comm->process);\n}\n\nstatic void\nfr_command_cpio_extract (FrCommand *comm,\n\t\t\tconst char *from_file,\n\t\t\tGList      *file_list,\n\t\t\tconst char *dest_dir,\n\t\t\tgboolean    overwrite,\n\t\t\tgboolean    skip_older,\n\t\t\tgboolean    junk_paths)\n{\n\tGList   *scan;\n\tGString *cmd;\n\n\tfr_process_begin_command (comm->process, \"sh\");\n\tif (dest_dir != NULL)\n                fr_process_set_working_dir (comm->process, dest_dir);\n\tfr_process_add_arg (comm->process, \"-c\");\n\n\tcmd = g_string_new (\"cpio -idu --no-absolute-filenames \");\n\tfor (scan = file_list; scan; scan = scan->next) {\n\t\tchar *filepath = scan->data;\n\t\tchar *filename;\n\n\t\tif (filepath[0] == '/')\n\t\t\tfilename = g_shell_quote (filepath + 1);\n\t\telse\n\t\t\tfilename = g_shell_quote (filepath);\n\t\tg_string_append (cmd, filename);\n\t\tg_string_append (cmd, \" \");\n\n\t\tg_free (filename);\n\t}\n        g_string_append (cmd, \" < \");\n\tg_string_append (cmd, comm->e_filename);\n\tfr_process_add_arg (comm->process, cmd->str);\n\tg_string_free (cmd, TRUE);\n\n\tfr_process_end_command (comm->process);\n}\n\nconst char *cpio_mime_type[] = { /*\"application/x-cpio\",*/ NULL };\n\nstatic const char **\nfr_command_cpio_get_mime_types (FrCommand *comm)\n{\n\treturn cpio_mime_type;\n}\n\nstatic FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n/*\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n\n\treturn capabilities;\n}\n\nstatic const char *\nfr_command_cpio_get_packages (FrCommand  *comm,\n\t\t\t      const char *mime_type)\n{\n\treturn PACKAGES (\"cpio\");\n}\n\nstatic void\nfr_command_cpio_class_init (FrCommandCpioClass *class)\n{\n        GObjectClass   *gobject_class = G_OBJECT_CLASS (class);\n        FrCommandClass *afc;\n\n        parent_class = g_type_class_peek_parent (class);\n\tafc = (FrCommandClass*) class;\n\n\tgobject_class->finalize = fr_command_cpio_finalize;\n\n        afc->list             = fr_command_cpio_list;\n\tafc->extract          = fr_command_cpio_extract;\n\tafc->get_mime_types   = fr_command_cpio_get_mime_types;\n\tafc->get_capabilities = fr_command_cpio_get_capabilities;\n\tafc->get_packages     = fr_command_cpio_get_packages;\n}\n\nstatic void\nfr_command_cpio_init (FrCommand *comm)\n{\n\tcomm->propAddCanUpdate             = FALSE;\n\tcomm->propAddCanReplace            = FALSE;\n\tcomm->propAddCanStoreFolders       = FALSE;\n\tcomm->propExtractCanAvoidOverwrite = FALSE;\n\tcomm->propExtractCanSkipOlder      = FALSE;\n\tcomm->propExtractCanJunkPaths      = FALSE;\n\tcomm->propPassword                 = FALSE;\n\tcomm->propTest                     = FALSE;\n}\n\nstatic void\nfr_command_cpio_finalize (GObject *object)\n{\n        g_return_if_fail (object != NULL);\n        g_return_if_fail (FR_IS_COMMAND_CPIO (object));\n\n\t/* Chain up */\n        if (G_OBJECT_CLASS (parent_class)->finalize)\n\t\tG_OBJECT_CLASS (parent_class)->finalize (object);\n}\n\nGType\nfr_command_cpio_get_type ()\n{\n        static GType type = 0;\n\n        if (! type) {\n                GTypeInfo type_info = {\n\t\t\tsizeof (FrCommandCpioClass),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t(GClassInitFunc) fr_command_cpio_class_init,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tsizeof (FrCommandCpio),\n\t\t\t0,\n\t\t\t(GInstanceInitFunc) fr_command_cpio_init,\n\t\t\tNULL\n\t\t};\n\n\t\ttype = g_type_register_static (FR_TYPE_COMMAND,\n\t\t\t\t\t       \"FRCommandCpio\",\n\t\t\t\t\t       &type_info,\n\t\t\t\t\t       0);\n        }\n\n        return type;\n}\n", "/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */\n\n/*\n *  File-Roller\n *\n *  Copyright (C) 2012 The Free Software Foundation, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define _XOPEN_SOURCE       /* See feature_test_macros(7) */\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n#include <glib/gi18n.h>\n#include <json-glib/json-glib.h>\n#include \"file-data.h\"\n#include \"file-utils.h\"\n#include \"gio-utils.h\"\n#include \"glib-utils.h\"\n#include \"fr-command.h\"\n#include \"fr-command-unarchiver.h\"\n#include \"fr-error.h\"\n\n#define LSAR_SUPPORTED_FORMAT 2\n#define LSAR_DATE_FORMAT \"%Y-%m-%d %H:%M:%S %z\"\n\nstatic void fr_command_unarchiver_class_init  (FrCommandUnarchiverClass *class);\nstatic void fr_command_unarchiver_init        (FrCommand         *afile);\nstatic void fr_command_unarchiver_finalize    (GObject           *object);\n\n/* Parent Class */\n\nstatic FrCommandClass *parent_class = NULL;\n\n/* -- list -- */\n\nstatic void\nprocess_line (char     *line,\n\t      gpointer  data)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (data);\n\tg_memory_input_stream_add_data (G_MEMORY_INPUT_STREAM (unar_comm->stream), line, -1, NULL);\n}\n\nstatic time_t\nmktime_from_string (const char *time_s)\n{\n\tstruct tm tm = {0, };\n\ttm.tm_isdst = -1;\n\tstrptime (time_s, LSAR_DATE_FORMAT, &tm);\n\treturn mktime (&tm);\n}\n\nstatic void\nlist_command_completed (gpointer data)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (data);\n\tJsonParser          *parser;\n\tGError              *error = NULL;\n\n\tparser = json_parser_new ();\n\tif (json_parser_load_from_stream (parser, unar_comm->stream, NULL, &error)) {\n\t\tJsonObject *root;\n\n\t\troot = json_node_get_object (json_parser_get_root (parser));\n\n\t\tif (json_object_get_int_member (root, \"lsarFormatVersion\") == LSAR_SUPPORTED_FORMAT) {\n\t\t\tJsonArray *content;\n\t\t\tguint      i;\n\n\t\t\tcontent = json_object_get_array_member (root, \"lsarContents\");\n\t\t\tfor (i = 0; i < json_array_get_length (content); i++) {\n\t\t\t\tJsonObject *entry;\n\t\t\t\tFileData   *fdata;\n\t\t\t\tconst char *filename;\n\n\t\t\t\tentry = json_array_get_object_element (content, i);\n\t\t\t\tfdata = file_data_new ();\n\t\t\t\tfdata->size = json_object_get_int_member (entry, \"XADFileSize\");\n\t\t\t\tfdata->modified = mktime_from_string (json_object_get_string_member (entry, \"XADLastModificationDate\"));\n\t\t\t\tif (json_object_has_member (entry, \"XADIsEncrypted\"))\n\t\t\t\t\tfdata->encrypted = json_object_get_int_member (entry, \"XADIsEncrypted\") == 1;\n\n\t\t\t\tfilename = json_object_get_string_member (entry, \"XADFileName\");\n\t\t\t\tif (*filename == '/') {\n\t\t\t\t\tfdata->full_path = g_strdup (filename);\n\t\t\t\t\tfdata->original_path = fdata->full_path;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfdata->full_path = g_strconcat (\"/\", filename, NULL);\n\t\t\t\t\tfdata->original_path = fdata->full_path + 1;\n\t\t\t\t}\n\n\t\t\t\tfdata->link = NULL;\n\t\t\t\tif (json_object_has_member (entry, \"XADIsDirectory\"))\n\t\t\t\t\tfdata->dir = json_object_get_int_member (entry, \"XADIsDirectory\") == 1;\n\t\t\t\tif (fdata->dir)\n\t\t\t\t\tfdata->name = dir_name_from_path (fdata->full_path);\n\t\t\t\telse\n\t\t\t\t\tfdata->name = g_strdup (file_name_from_path (fdata->full_path));\n\t\t\t\tfdata->path = remove_level_from_path (fdata->full_path);\n\n\t\t\t\tfr_command_add_file (FR_COMMAND (unar_comm), fdata);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_object_unref (parser);\n}\n\nstatic void\nfr_command_unarchiver_list (FrCommand  *comm)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\n\t_g_object_unref (unar_comm->stream);\n\tunar_comm->stream = g_memory_input_stream_new ();\n\n\tfr_process_set_out_line_func (comm->process, process_line, comm);\n\n\tfr_process_begin_command (comm->process, \"lsar\");\n\tfr_process_set_end_func (comm->process, list_command_completed, comm);\n\tfr_process_add_arg (comm->process, \"-j\");\n\tif ((comm->password != NULL) && (comm->password[0] != '\\0'))\n\t\tfr_process_add_arg_concat (comm->process, \"-password=\", comm->password, NULL);\n\tfr_process_add_arg (comm->process, comm->filename);\n\tfr_process_end_command (comm->process);\n\n\tfr_process_start (comm->process);\n}\n\nstatic void\nprocess_line__extract (char     *line,\n\t\t       gpointer  data)\n{\n\tFrCommand           *comm = FR_COMMAND (data);\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\n\tif (line == NULL)\n\t\treturn;\n\n\tunar_comm->n_line++;\n\n\t/* the first line is the name of the archive */\n\tif (unar_comm->n_line == 1)\n\t\treturn;\n\n\tif (comm->n_files > 1) {\n\t\tdouble fraction = (double) ++comm->n_file / (comm->n_files + 1);\n\t\tfr_command_progress (comm, CLAMP (fraction, 0.0, 1.0));\n\t}\n\telse\n\t\tfr_command_message (comm, line);\n}\n\nstatic void\nfr_command_unarchiver_extract (FrCommand  *comm,\n\t\t\t       const char *from_file,\n\t\t\t       GList      *file_list,\n\t\t\t       const char *dest_dir,\n\t\t\t       gboolean    overwrite,\n\t\t\t       gboolean    skip_older,\n\t\t\t       gboolean    junk_paths)\n{\n\tFrCommandUnarchiver *unar_comm = FR_COMMAND_UNARCHIVER (comm);\n\tGList               *scan;\n\n\tunar_comm->n_line = 0;\n\n\tfr_process_use_standard_locale (comm->process, TRUE);\n\tfr_process_set_out_line_func (comm->process,\n\t\t\t\t      process_line__extract,\n\t\t\t\t      comm);\n\n\tfr_process_begin_command (comm->process, \"unar\");\n\n\tif (overwrite)\n\t\tfr_process_add_arg (comm->process, \"-f\");\n\telse\n\t\tfr_process_add_arg (comm->process, \"-s\");\n\n\tfr_process_add_arg (comm->process, \"-D\");\n\n\tif ((comm->password != NULL) && (comm->password[0] != '\\0'))\n\t\tfr_process_add_arg_concat (comm->process, \"-password=\", comm->password, NULL);\n\n\tif (dest_dir != NULL)\n\t\tfr_process_add_arg_concat (comm->process, \"-output-directory=\", dest_dir, NULL);\n\n\tfr_process_add_arg (comm->process, comm->filename);\n\n\tfor (scan = file_list; scan; scan = scan->next) {\n\t\tchar *escaped;\n\n\t\tescaped = escape_str (scan->data, \"[?\");\n\t\tfr_process_add_arg (comm->process, escaped);\n\t\tg_free (escaped);\n\t}\n\n\tfr_process_end_command (comm->process);\n}\n\nstatic void\nfr_command_unarchiver_handle_error (FrCommand   *comm,\n\t\t\t\t    FrProcError *error)\n{\n\tGList *scan;\n\n#if 0\n\t{\n\t\tfor (scan = g_list_last (comm->process->err.raw); scan; scan = scan->prev)\n\t\t\tg_print (\"%s\\n\", (char*)scan->data);\n\t}\n#endif\n\n\tif (error->type == FR_PROC_ERROR_NONE)\n\t\treturn;\n\n\tif (error->type == FR_PROC_ERROR_COMMAND_ERROR) {\n\t\tfor (scan = g_list_last (comm->process->out.raw); scan; scan = scan->prev) {\n\t\t\tchar *line = scan->data;\n\n\t\t\tif ((strstr (line, \"This archive requires a password to unpack.\") != NULL)  ||\n\t\t\t    (strstr (line, \"Failed! (Missing or wrong password)\") != NULL)) {\n\n\t\t\t\terror->type = FR_PROC_ERROR_ASK_PASSWORD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst char *unarchiver_mime_type[] = { \"application/zip\",\n\t\t\t\t       \"application/x-cbr\",\n\t\t\t\t       \"application/x-rar\",\n\t\t\t\t       \"application/x-cpio\",\n\t\t\t\t       NULL };\n\nstatic const char **\nfr_command_unarchiver_get_mime_types (FrCommand *comm)\n{\n\treturn unarchiver_mime_type;\n}\n\nstatic FrCommandCaps\nfr_command_unarchiver_get_capabilities (FrCommand  *comm,\n\t\t\t\t\tconst char *mime_type,\n\t\t\t\t\tgboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_DO_NOTHING;\n\tif (is_program_available (\"lsar\", check_command) && is_program_available (\"unar\", check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}\n\nstatic const char *\nfr_command_unarchiver_get_packages (FrCommand  *comm,\n\t\t\t\t    const char *mime_type)\n{\n\treturn PACKAGES (\"unarchiver\");\n}\n\nstatic void\nfr_command_unarchiver_class_init (FrCommandUnarchiverClass *class)\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS (class);\n\tFrCommandClass *afc;\n\n\tparent_class = g_type_class_peek_parent (class);\n\tafc = (FrCommandClass*) class;\n\n\tgobject_class->finalize = fr_command_unarchiver_finalize;\n\n\tafc->list             = fr_command_unarchiver_list;\n\tafc->extract          = fr_command_unarchiver_extract;\n\tafc->handle_error     = fr_command_unarchiver_handle_error;\n\tafc->get_mime_types   = fr_command_unarchiver_get_mime_types;\n\tafc->get_capabilities = fr_command_unarchiver_get_capabilities;\n\tafc->get_packages     = fr_command_unarchiver_get_packages;\n}\n\nstatic void\nfr_command_unarchiver_init (FrCommand *comm)\n{\n\tFrCommandUnarchiver *unar_comm;\n\n\tcomm->propExtractCanAvoidOverwrite = TRUE;\n\tcomm->propExtractCanSkipOlder      = FALSE;\n\tcomm->propExtractCanJunkPaths      = FALSE;\n\tcomm->propPassword                 = TRUE;\n\tcomm->propTest                     = FALSE;\n\tcomm->propListFromFile             = FALSE;\n\n\tunar_comm = FR_COMMAND_UNARCHIVER (comm);\n\tunar_comm->stream = NULL;\n}\n\nstatic void\nfr_command_unarchiver_finalize (GObject *object)\n{\n\tFrCommandUnarchiver *unar_comm;\n\n\tg_return_if_fail (object != NULL);\n\tg_return_if_fail (FR_IS_COMMAND_UNARCHIVER (object));\n\n\tunar_comm = FR_COMMAND_UNARCHIVER (object);\n\t_g_object_unref (unar_comm->stream);\n\n\t/* Chain up */\n\tif (G_OBJECT_CLASS (parent_class)->finalize)\n\t\tG_OBJECT_CLASS (parent_class)->finalize (object);\n}\n\nGType\nfr_command_unarchiver_get_type ()\n{\n\tstatic GType type = 0;\n\n\tif (! type) {\n\t\tGTypeInfo type_info = {\n\t\t\tsizeof (FrCommandUnarchiverClass),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t(GClassInitFunc) fr_command_unarchiver_class_init,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tsizeof (FrCommandUnarchiver),\n\t\t\t0,\n\t\t\t(GInstanceInitFunc) fr_command_unarchiver_init,\n\t\t\tNULL\n\t\t};\n\n\t\ttype = g_type_register_static (FR_TYPE_COMMAND,\n\t\t\t\t\t       \"FrCommandUnarchiver\",\n\t\t\t\t\t       &type_info,\n\t\t\t\t\t       0);\n\t}\n\n\treturn type;\n}\n"], "filenames": ["src/fr-command-cpio.c", "src/fr-command-unarchiver.c"], "buggy_code_start_loc": [222, 249], "buggy_code_end_loc": [240, 249], "fixing_code_start_loc": [222, 250], "fixing_code_end_loc": [240, 251], "type": "CWE-22", "message": "Engrampa is an archive manager for the MATE environment. Engrampa is found to be vulnerable to a Path Traversal vulnerability that can be leveraged to achieve full Remote Command Execution (RCE) on the target. While handling CPIO archives, the Engrampa Archive manager follows symlink, cpio by default will follow stored symlinks while extracting and the Archiver will not check the symlink location, which leads to arbitrary file writes to unintended locations. When the victim extracts the archive, the attacker can craft a malicious cpio or ISO archive to achieve RCE on the target system. This vulnerability was fixed in commit 63d5dfa.\n", "other": {"cve": {"id": "CVE-2023-52138", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-05T15:15:08.393", "lastModified": "2024-02-29T01:42:06.987", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Engrampa is an archive manager for the MATE environment. Engrampa is found to be vulnerable to a Path Traversal vulnerability that can be leveraged to achieve full Remote Command Execution (RCE) on the target. While handling CPIO archives, the Engrampa Archive manager follows symlink, cpio by default will follow stored symlinks while extracting and the Archiver will not check the symlink location, which leads to arbitrary file writes to unintended locations. When the victim extracts the archive, the attacker can craft a malicious cpio or ISO archive to achieve RCE on the target system. This vulnerability was fixed in commit 63d5dfa.\n"}, {"lang": "es", "value": "Engrampa es un administrador de archivos para el entorno MATE. Se descubre que Engrampa es vulnerable a una vulnerabilidad de Path Traversa que se puede aprovechar para lograr una ejecuci\u00f3n remota de comandos (RCE) completa en el objetivo. Mientras maneja archivos CPIO, el administrador de archivos de Engrampa sigue el enlace simb\u00f3lico, cpio de forma predeterminada seguir\u00e1 los enlaces simb\u00f3licos almacenados durante la extracci\u00f3n y el Archiver no verificar\u00e1 la ubicaci\u00f3n del enlace simb\u00f3lico, lo que conduce a escrituras arbitrarias de archivos en ubicaciones no deseadas. Cuando la v\u00edctima extrae el archivo, el atacante puede crear un archivo cpio o ISO malicioso para lograr RCE en el sistema de destino. Esta vulnerabilidad se solucion\u00f3 en el commit 63d5dfa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-59"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-25"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mate-desktop:engrampa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.26.2", "matchCriteriaId": "FE120BC0-C0A9-48DB-B5CB-7C2596320D91"}]}]}], "references": [{"url": "https://github.com/mate-desktop/engrampa/commit/63d5dfa9005c6b16d0f0ccd888cc859fca78f970", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mate-desktop/engrampa/security/advisories/GHSA-c98h-v39w-3r7v", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00011.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4IOJ3QWXTZGCXFEHP72ELY22PZ4AX2CB/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/mate-desktop/engrampa/commit/63d5dfa9005c6b16d0f0ccd888cc859fca78f970"}}