{"buggy_code": ["/**\n * @file tree_schema.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang schema data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#ifdef __APPLE__\n#   include <sys/param.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml.h\"\n#include \"xpath.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"parser_yang.h\"\n\nstatic int lys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n                        int in_grp, int shallow, struct unres_schema *unres);\n\nAPI const struct lys_node_list *\nlys_is_key(const struct lys_node_leaf *node, uint8_t *index)\n{\n    struct lys_node *parent = (struct lys_node *)node;\n    struct lys_node_list *list;\n    uint8_t i;\n\n    if (!node || node->nodetype != LYS_LEAF) {\n        return NULL;\n    }\n\n    do {\n        parent = lys_parent(parent);\n    } while (parent && parent->nodetype == LYS_USES);\n\n    if (!parent || parent->nodetype != LYS_LIST) {\n        return NULL;\n    }\n\n    list = (struct lys_node_list*)parent;\n    for (i = 0; i < list->keys_size; i++) {\n        if (list->keys[i] == node) {\n            if (index) {\n                (*index) = i;\n            }\n            return list;\n        }\n    }\n    return NULL;\n}\n\nAPI const struct lys_node *\nlys_is_disabled(const struct lys_node *node, int recursive)\n{\n    int i;\n\n    if (!node) {\n        return NULL;\n    }\n\ncheck:\n    if (node->nodetype != LYS_INPUT && node->nodetype != LYS_OUTPUT) {\n        /* input/output does not have if-feature, so skip them */\n\n        /* check local if-features */\n        for (i = 0; i < node->iffeature_size; i++) {\n            if (!resolve_iffeature(&node->iffeature[i])) {\n                return node;\n            }\n        }\n    }\n\n    if (!recursive) {\n        return NULL;\n    }\n\n    /* go through parents */\n    if (node->nodetype == LYS_AUGMENT) {\n        /* go to parent actually means go to the target node */\n        node = ((struct lys_node_augment *)node)->target;\n        if (!node) {\n            /* unresolved augment, let's say it's enabled */\n            return NULL;\n        }\n    } else if (node->nodetype == LYS_EXT) {\n        return NULL;\n    } else if (node->parent) {\n        node = node->parent;\n    } else {\n        return NULL;\n    }\n\n    if (recursive == 2) {\n        /* continue only if the node cannot have a data instance */\n        if (node->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST)) {\n            return NULL;\n        }\n    }\n    goto check;\n}\n\nAPI const struct lys_type *\nlys_getnext_union_type(const struct lys_type *last, const struct lys_type *type)\n{\n    int found = 0;\n\n    if (!type || (type->base != LY_TYPE_UNION)) {\n        return NULL;\n    }\n\n    return lyp_get_next_union_type((struct lys_type *)type, (struct lys_type *)last, &found);\n}\n\nint\nlys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                int nam_len, LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node, *parent = NULL;\n    const struct lys_module *mod = NULL;\n    const char *node_mod_name;\n\n    assert(siblings && mod_name && name);\n    assert(!(type & (LYS_USES | LYS_GROUPING)));\n\n    /* fill the lengths in case the caller is so indifferent */\n    if (!mod_name_len) {\n        mod_name_len = strlen(mod_name);\n    }\n    if (!nam_len) {\n        nam_len = strlen(name);\n    }\n\n    while (siblings && (siblings->nodetype == LYS_USES)) {\n        siblings = siblings->child;\n    }\n    if (!siblings) {\n        /* unresolved uses */\n        return EXIT_FAILURE;\n    }\n\n    if (siblings->nodetype == LYS_GROUPING) {\n        for (node = siblings; (node->nodetype == LYS_GROUPING) && (node->prev != siblings); node = node->prev);\n        if (node->nodetype == LYS_GROUPING) {\n            /* we went through all the siblings, only groupings there - no valid sibling */\n            return EXIT_FAILURE;\n        }\n        /* update siblings to be valid */\n        siblings = node;\n    }\n\n    /* set parent correctly */\n    parent = lys_parent(siblings);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (!parent) {\n        /* handle situation when there is a top-level uses referencing a foreign grouping */\n        for (node = siblings; lys_parent(node) && (node->nodetype == LYS_USES); node = lys_parent(node));\n        mod = lys_node_module(node);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT))) {\n        if (!type || (node->nodetype & type)) {\n            /* module name comparison */\n            node_mod_name = lys_node_module(node)->name;\n            if (!ly_strequal(node_mod_name, mod_name, 1) && (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len])) {\n                continue;\n            }\n\n            /* direct name check */\n            if (ly_strequal(node->name, name, 1) || (!strncmp(node->name, name, nam_len) && !node->name[nam_len])) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nint\nlys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, int getnext_opts, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, getnext_opts))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nAPI const struct lys_node *\nlys_getnext(const struct lys_node *last, const struct lys_node *parent, const struct lys_module *module, int options)\n{\n    const struct lys_node *next, *aug_parent;\n    struct lys_node **snode;\n\n    if ((!parent && !module) || (module && module->type) || (parent && (parent->nodetype == LYS_USES) && !(options & LYS_GETNEXT_PARENTUSES))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!last) {\n        /* first call */\n\n        /* get know where to start */\n        if (parent) {\n            /* schema subtree */\n            snode = lys_child(parent, LYS_UNKNOWN);\n            /* do not return anything if the augment does not have any children */\n            if (!snode || !(*snode) || ((parent->nodetype == LYS_AUGMENT) && ((*snode)->parent != parent))) {\n                return NULL;\n            }\n            next = last = *snode;\n        } else {\n            /* top level data */\n            if (!(options & LYS_GETNEXT_NOSTATECHECK) && (module->disabled || !module->implemented)) {\n                /* nothing to return from a disabled/imported module */\n                return NULL;\n            }\n            next = last = module->data;\n        }\n    } else if ((last->nodetype == LYS_USES) && (options & LYS_GETNEXT_INTOUSES) && last->child) {\n        /* continue with uses content */\n        next = last->child;\n    } else {\n        /* continue after the last returned value */\n        next = last->next;\n    }\n\nrepeat:\n    if (parent && (parent->nodetype == LYS_AUGMENT) && next) {\n        /* do not return anything outside the parent augment */\n        aug_parent = next->parent;\n        do {\n            while (aug_parent && (aug_parent->nodetype != LYS_AUGMENT)) {\n                aug_parent = aug_parent->parent;\n            }\n            if (aug_parent) {\n                if (aug_parent == parent) {\n                    break;\n                }\n                aug_parent = ((struct lys_node_augment *)aug_parent)->target;\n            }\n\n        } while (aug_parent);\n        if (!aug_parent) {\n            return NULL;\n        }\n    }\n    while (next && (next->nodetype == LYS_GROUPING)) {\n        if (options & LYS_GETNEXT_WITHGROUPING) {\n            return next;\n        }\n        next = next->next;\n    }\n\n    if (!next) {     /* cover case when parent is augment */\n        if (!last || last->parent == parent || lys_parent(last) == parent) {\n            /* no next element */\n            return NULL;\n        }\n        last = lys_parent(last);\n        next = last->next;\n        goto repeat;\n    } else {\n        last = next;\n    }\n\n    if (!(options & LYS_GETNEXT_NOSTATECHECK) && lys_is_disabled(next, 0)) {\n        next = next->next;\n        goto repeat;\n    }\n\n    switch (next->nodetype) {\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (options & LYS_GETNEXT_WITHINOUT) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_CASE:\n        if (options & LYS_GETNEXT_WITHCASE) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_USES:\n        /* go into */\n        if (options & LYS_GETNEXT_WITHUSES) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_LIST:\n    case LYS_LEAFLIST:\n        return next;\n\n    case LYS_CONTAINER:\n        if (!((struct lys_node_container *)next)->presence && (options & LYS_GETNEXT_INTONPCONT)) {\n            if (next->child) {\n                /* go into */\n                next = next->child;\n            } else {\n                next = next->next;\n            }\n            goto repeat;\n        } else {\n            return next;\n        }\n\n    case LYS_CHOICE:\n        if (options & LYS_GETNEXT_WITHCHOICE) {\n            return next;\n        } else if (next->child) {\n            /* go into */\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    default:\n        /* we should not be here */\n        return NULL;\n    }\n}\n\nvoid\nlys_node_unlink(struct lys_node *node)\n{\n    struct lys_node *parent, *first, **pp = NULL;\n    struct lys_module *main_module;\n\n    if (!node) {\n        return;\n    }\n\n    /* unlink from data model if necessary */\n    if (node->module) {\n        /* get main module with data tree */\n        main_module = lys_node_module(node);\n        if (main_module->data == node) {\n            main_module->data = node->next;\n        }\n    }\n\n    /* store pointers to important nodes */\n    parent = node->parent;\n    if (parent && (parent->nodetype == LYS_AUGMENT)) {\n        /* handle augments - first, unlink it from the augment parent ... */\n        if (parent->child == node) {\n            parent->child = (node->next && node->next->parent == parent) ? node->next : NULL;\n        }\n\n        if (parent->flags & LYS_NOTAPPLIED) {\n            /* data are not connected in the target, so we cannot continue with the target as a parent */\n            parent = NULL;\n        } else {\n            /* data are connected in target, so we will continue with the target as a parent */\n            parent = ((struct lys_node_augment *)parent)->target;\n        }\n    }\n\n    /* unlink from parent */\n    if (parent) {\n        if (parent->nodetype == LYS_EXT) {\n            pp = (struct lys_node **)lys_ext_complex_get_substmt(lys_snode2stmt(node->nodetype),\n                                                                 (struct lys_ext_instance_complex*)parent, NULL);\n            if (*pp == node) {\n                *pp = node->next;\n            }\n        } else if (parent->child == node) {\n            parent->child = node->next;\n        }\n        node->parent = NULL;\n    }\n\n    /* unlink from siblings */\n    if (node->prev == node) {\n        /* there are no more siblings */\n        return;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last element */\n        if (parent) {\n            if (parent->nodetype == LYS_EXT) {\n                first = *(struct lys_node **)pp;\n            } else {\n                first = parent->child;\n            }\n        } else {\n            first = node;\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n        first->prev = node->prev;\n    }\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n\n    /* clean up the unlinked element */\n    node->next = NULL;\n    node->prev = node;\n}\n\nstruct lys_node_grp *\nlys_find_grouping_up(const char *name, struct lys_node *start)\n{\n    struct lys_node *par_iter, *iter, *stop;\n\n    for (par_iter = start; par_iter; par_iter = par_iter->parent) {\n        /* top-level augment, look into module (uses augment is handled correctly below) */\n        if (par_iter->parent && !par_iter->parent->parent && (par_iter->parent->nodetype == LYS_AUGMENT)) {\n            par_iter = lys_main_module(par_iter->parent->module)->data;\n            if (!par_iter) {\n                break;\n            }\n        }\n\n        if (par_iter->nodetype == LYS_EXT) {\n            /* we are in a top-level extension, search grouping in top-level groupings */\n            par_iter = lys_main_module(par_iter->module)->data;\n            if (!par_iter) {\n                /* not connected yet, wait */\n                return NULL;\n            }\n        } else if (par_iter->parent && (par_iter->parent->nodetype & (LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_USES))) {\n            continue;\n        }\n\n        for (iter = par_iter, stop = NULL; iter; iter = iter->prev) {\n            if (!stop) {\n                stop = par_iter;\n            } else if (iter == stop) {\n                break;\n            }\n            if (iter->nodetype != LYS_GROUPING) {\n                continue;\n            }\n\n            if (!strcmp(name, iter->name)) {\n                return (struct lys_node_grp *)iter;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * get next grouping in the root's subtree, in the\n * first call, tha last is NULL\n */\nstatic struct lys_node_grp *\nlys_get_next_grouping(struct lys_node_grp *lastgrp, struct lys_node *root)\n{\n    struct lys_node *last = (struct lys_node *)lastgrp;\n    struct lys_node *next;\n\n    assert(root);\n\n    if (!last) {\n        last = root;\n    }\n\n    while (1) {\n        if ((last->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n            next = last->child;\n        } else {\n            next = NULL;\n        }\n        if (!next) {\n            if (last == root) {\n                /* we are done */\n                return NULL;\n            }\n\n            /* no children, go to siblings */\n            next = last->next;\n        }\n        while (!next) {\n            /* go back through parents */\n            if (lys_parent(last) == root) {\n                /* we are done */\n                return NULL;\n            }\n            next = last->next;\n            last = lys_parent(last);\n        }\n\n        if (next->nodetype == LYS_GROUPING) {\n            return (struct lys_node_grp *)next;\n        }\n\n        last = next;\n    }\n}\n\n/* logs directly */\nint\nlys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module)\n{\n    struct lys_node *start, *stop, *iter;\n    struct lys_node_grp *grp;\n    int down, up;\n\n    assert(node);\n\n    if (!parent) {\n        assert(module);\n    } else {\n        module = parent->module;\n    }\n    module = lys_main_module(module);\n\n    switch (node->nodetype) {\n    case LYS_GROUPING:\n        /* 6.2.1, rule 6 */\n        if (parent) {\n            start = *lys_child(parent, LYS_GROUPING);\n            if (!start) {\n                down = 0;\n                start = parent;\n            } else {\n                down = 1;\n            }\n            if (parent->nodetype == LYS_EXT) {\n                up = 0;\n            } else {\n                up = 1;\n            }\n        } else {\n            down = up = 1;\n            start = module->data;\n        }\n        /* go up */\n        if (up && lys_find_grouping_up(node->name, start)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"grouping\", node->name);\n            return EXIT_FAILURE;\n        }\n        /* go down, because grouping can be defined after e.g. container in which is collision */\n        if (down) {\n            for (iter = start, stop = NULL; iter; iter = iter->prev) {\n                if (!stop) {\n                    stop = start;\n                } else if (iter == stop) {\n                    break;\n                }\n                if (!(iter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n                    continue;\n                }\n\n                grp = NULL;\n                while ((grp = lys_get_next_grouping(grp, iter))) {\n                    if (ly_strequal(node->name, grp->name, 1)) {\n                        LOGVAL(module->ctx, LYE_DUPID,LY_VLOG_LYS, node, \"grouping\", node->name);\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CONTAINER:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n        /* 6.2.1, rule 7 */\n        if (parent) {\n            iter = parent;\n            while (iter && (iter->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE | LYS_AUGMENT))) {\n                if (iter->nodetype == LYS_AUGMENT) {\n                    if (((struct lys_node_augment *)iter)->target) {\n                        /* augment is resolved, go up */\n                        iter = ((struct lys_node_augment *)iter)->target;\n                        continue;\n                    }\n                    /* augment is not resolved, this is the final parent */\n                    break;\n                }\n                iter = iter->parent;\n            }\n\n            if (!iter) {\n                stop = NULL;\n                iter = module->data;\n            } else if (iter->nodetype == LYS_EXT) {\n                stop = iter;\n                iter = (struct lys_node *)lys_child(iter, node->nodetype);\n                if (iter) {\n                    iter = *(struct lys_node **)iter;\n                }\n            } else {\n                stop = iter;\n                iter = iter->child;\n            }\n        } else {\n            stop = NULL;\n            iter = module->data;\n        }\n        while (iter) {\n            if (iter->nodetype & (LYS_USES | LYS_CASE)) {\n                iter = iter->child;\n                continue;\n            }\n\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CONTAINER | LYS_CHOICE | LYS_ANYDATA)) {\n                if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                    LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, strnodetype(node->nodetype), node->name);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* special case for choice - we must check the choice's name as\n             * well as the names of nodes under the choice\n             */\n            if (iter->nodetype == LYS_CHOICE) {\n                iter = iter->child;\n                continue;\n            }\n\n            /* go to siblings */\n            if (!iter->next) {\n                /* no sibling, go to parent's sibling */\n                do {\n                    /* for parent LYS_AUGMENT */\n                    if (iter->parent == stop) {\n                        iter = stop;\n                        break;\n                    }\n                    iter = lys_parent(iter);\n                    if (iter && iter->next) {\n                        break;\n                    }\n                } while (iter != stop);\n\n                if (iter == stop) {\n                    break;\n                }\n            }\n            iter = iter->next;\n        }\n        break;\n    case LYS_CASE:\n        /* 6.2.1, rule 8 */\n        if (parent) {\n            start = *lys_child(parent, LYS_CASE);\n        } else {\n            start = module->data;\n        }\n\n        LY_TREE_FOR(start, iter) {\n            if (!(iter->nodetype & (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST))) {\n                continue;\n            }\n\n            if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"case\", node->name);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* no check needed */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options)\n{\n    struct ly_ctx *ctx = child->module->ctx;\n    struct lys_node *iter, **pchild, *log_parent;\n    struct lys_node_inout *in, *out;\n    struct lys_node_case *c;\n    int type, shortcase = 0;\n    void *p;\n    struct lyext_substmt *info = NULL;\n\n    assert(child);\n\n    if (parent) {\n        type = parent->nodetype;\n        module = parent->module;\n        log_parent = parent;\n\n        if (type == LYS_USES) {\n            /* we are adding children to uses -> we must be copying grouping contents into it, so properly check the parent */\n            log_parent = lys_parent(log_parent);\n            while (log_parent && (log_parent->nodetype == LYS_USES)) {\n                log_parent = lys_parent(log_parent);\n            }\n            if (log_parent) {\n                type = log_parent->nodetype;\n            } else {\n                type = 0;\n            }\n        }\n    } else {\n        assert(module);\n        assert(!(child->nodetype & (LYS_INPUT | LYS_OUTPUT)));\n        type = 0;\n        log_parent = NULL;\n    }\n\n    /* checks */\n    switch (type) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_GROUPING:\n    case LYS_USES:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_CHOICE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"choice\");\n            return EXIT_FAILURE;\n        }\n        if (child->nodetype != LYS_CASE) {\n            shortcase = 1;\n        }\n        break;\n    case LYS_CASE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"case\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        if (!(child->nodetype & (LYS_INPUT | LYS_OUTPUT | LYS_GROUPING))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"rpc\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"The \\\"%s\\\" statement cannot have any data substatement.\",\n               strnodetype(log_parent->nodetype));\n        return EXIT_FAILURE;\n    case LYS_AUGMENT:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_UNKNOWN:\n        /* top level */\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_GROUPING\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_RPC | LYS_NOTIF | LYS_AUGMENT))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"(sub)module\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_EXT:\n        /* plugin-defined */\n        p = lys_ext_complex_get_substmt(lys_snode2stmt(child->nodetype), (struct lys_ext_instance_complex*)log_parent, &info);\n        if (!p) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype),\n                   ((struct lys_ext_instance_complex*)log_parent)->def->name);\n            return EXIT_FAILURE;\n        }\n        /* TODO check cardinality */\n        break;\n    }\n\n    /* check identifier uniqueness */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && lys_check_id(child, parent, module)) {\n        return EXIT_FAILURE;\n    }\n\n    if (child->parent) {\n        lys_node_unlink(child);\n    }\n\n    if ((child->nodetype & (LYS_INPUT | LYS_OUTPUT)) && parent->nodetype != LYS_EXT) {\n        /* find the implicit input/output node */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->nodetype == child->nodetype) {\n                break;\n            }\n        }\n        assert(iter);\n\n        /* switch the old implicit node (iter) with the new one (child) */\n        if (parent->child == iter) {\n            /* first child */\n            parent->child = child;\n        } else {\n            iter->prev->next = child;\n        }\n        child->prev = iter->prev;\n        child->next = iter->next;\n        if (iter->next) {\n            iter->next->prev = child;\n        } else {\n            /* last child */\n            parent->child->prev = child;\n        }\n        child->parent = parent;\n\n        /* isolate the node and free it */\n        iter->next = NULL;\n        iter->prev = iter;\n        iter->parent = NULL;\n        lys_node_free(iter, NULL, 0);\n    } else {\n        if (shortcase) {\n            /* create the implicit case to allow it to serve as a target of the augments,\n             * it won't be printed, but it will be present in the tree */\n            c = calloc(1, sizeof *c);\n            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);\n            c->name = lydict_insert(module->ctx, child->name, 0);\n            c->flags = LYS_IMPLICIT;\n            if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n                /* get config flag from parent */\n                c->flags |= parent->flags & LYS_CONFIG_MASK;\n            }\n            c->module = module;\n            c->nodetype = LYS_CASE;\n            c->prev = (struct lys_node*)c;\n            lys_node_addchild(parent, module, (struct lys_node*)c, options);\n            parent = (struct lys_node*)c;\n        }\n        /* connect the child correctly */\n        if (!parent) {\n            if (module->data) {\n                module->data->prev->next = child;\n                child->prev = module->data->prev;\n                module->data->prev = child;\n            } else {\n                module->data = child;\n            }\n        } else {\n            pchild = lys_child(parent, child->nodetype);\n            assert(pchild);\n\n            child->parent = parent;\n            if (!(*pchild)) {\n                /* the only/first child of the parent */\n                *pchild = child;\n                iter = child;\n            } else {\n                /* add a new child at the end of parent's child list */\n                iter = (*pchild)->prev;\n                iter->next = child;\n                child->prev = iter;\n            }\n            while (iter->next) {\n                iter = iter->next;\n                iter->parent = parent;\n            }\n            (*pchild)->prev = iter;\n        }\n    }\n\n    /* check config value (but ignore them in groupings and augments) */\n    for (iter = parent; iter && !(iter->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); iter = iter->parent);\n    if (parent && !iter) {\n        for (iter = child; iter && !(iter->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); iter = iter->parent);\n        if (!iter && (parent->flags & LYS_CONFIG_R) && (child->flags & LYS_CONFIG_W)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, child, \"true\", \"config\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* propagate information about status data presence */\n    if ((child->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) &&\n            (child->flags & LYS_INCL_STATUS)) {\n        for(iter = parent; iter; iter = lys_parent(iter)) {\n            /* store it only into container or list - the only data inner nodes */\n            if (iter->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n                if (iter->flags & LYS_INCL_STATUS) {\n                    /* done, someone else set it already from here */\n                    break;\n                }\n                /* set flag about including status data */\n                iter->flags |= LYS_INCL_STATUS;\n            }\n        }\n    }\n\n    /* create implicit input/output nodes to have available them as possible target for augment */\n    if ((child->nodetype & (LYS_RPC | LYS_ACTION)) && !child->child) {\n        in = calloc(1, sizeof *in);\n        out = calloc(1, sizeof *out);\n        if (!in || !out) {\n            LOGMEM(ctx);\n            free(in);\n            free(out);\n            return EXIT_FAILURE;\n        }\n        in->nodetype = LYS_INPUT;\n        in->name = lydict_insert(child->module->ctx, \"input\", 5);\n        out->nodetype = LYS_OUTPUT;\n        out->name = lydict_insert(child->module->ctx, \"output\", 6);\n        in->module = out->module = child->module;\n        in->parent = out->parent = child;\n        in->flags = out->flags = LYS_IMPLICIT;\n        in->next = (struct lys_node *)out;\n        in->prev = (struct lys_node *)out;\n        out->prev = (struct lys_node *)in;\n        child->child = (struct lys_node *)in;\n    }\n    return EXIT_SUCCESS;\n}\n\nconst struct lys_module *\nlys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision, int internal, int implement)\n{\n    char *enlarged_data = NULL;\n    struct lys_module *mod = NULL;\n    unsigned int len;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!internal && format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    switch (format) {\n    case LYS_IN_YIN:\n        mod = yin_read_module(ctx, data, revision, implement);\n        break;\n    case LYS_IN_YANG:\n        mod = yang_read_module(ctx, data, 0, revision, implement);\n        break;\n    default:\n        LOGERR(ctx, LY_EINVAL, \"Invalid schema input format.\");\n        break;\n    }\n\n    free(enlarged_data);\n\n    /* hack for NETCONF's edit-config's operation attribute. It is not defined in the schema, but since libyang\n     * implements YANG metadata (annotations), we need its definition. Because the ietf-netconf schema is not the\n     * internal part of libyang, we cannot add the annotation into the schema source, but we do it here to have\n     * the anotation definitions available in the internal schema structure. There is another hack in schema\n     * printers to do not print this internally added annotation. */\n    if (mod && ly_strequal(mod->name, \"ietf-netconf\", 0)) {\n        if (lyp_add_ietf_netconf_annotations_config(mod)) {\n            lys_free(mod, NULL, 1, 1);\n            return NULL;\n        }\n    }\n\n    return mod;\n}\n\nAPI const struct lys_module *\nlys_parse_mem(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format)\n{\n    return lys_parse_mem_(ctx, data, format, NULL, 0, 1);\n}\n\nstruct lys_submodule *\nlys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    char *enlarged_data = NULL;\n    struct lys_submodule *submod = NULL;\n    unsigned int len;\n\n    assert(module);\n    assert(data);\n\n    if (format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(module->ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submod = yin_read_submodule(module, data, unres);\n        break;\n    case LYS_IN_YANG:\n        submod = yang_read_submodule(module, data, 0, unres);\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    free(enlarged_data);\n    return submod;\n}\n\nAPI const struct lys_module *\nlys_parse_path(struct ly_ctx *ctx, const char *path, LYS_INFORMAT format)\n{\n    int fd;\n    const struct lys_module *ret;\n    const char *rev, *dot, *filename;\n    size_t len;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Opening file \\\"%s\\\" failed (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    ret = lys_parse_fd(ctx, fd, format);\n    close(fd);\n\n    if (!ret) {\n        /* error */\n        return NULL;\n    }\n\n    /* check that name and revision match filename */\n    filename = strrchr(path, '/');\n    if (!filename) {\n        filename = path;\n    } else {\n        filename++;\n    }\n    rev = strchr(filename, '@');\n    dot = strrchr(filename, '.');\n\n    /* name */\n    len = strlen(ret->name);\n    if (strncmp(filename, ret->name, len) ||\n            ((rev && rev != &filename[len]) || (!rev && dot != &filename[len]))) {\n        LOGWRN(ctx, \"File name \\\"%s\\\" does not match module name \\\"%s\\\".\", filename, ret->name);\n    }\n    if (rev) {\n        len = dot - ++rev;\n        if (!ret->rev_size || len != 10 || strncmp(ret->rev[0].date, rev, len)) {\n            LOGWRN(ctx, \"File name \\\"%s\\\" does not match module revision \\\"%s\\\".\", filename,\n                   ret->rev_size ? ret->rev[0].date : \"none\");\n        }\n    }\n\n    if (!ret->filepath) {\n        /* store URI */\n        char rpath[PATH_MAX];\n        if (realpath(path, rpath) != NULL) {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, rpath, 0);\n        } else {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, path, 0);\n        }\n    }\n\n    return ret;\n}\n\nAPI const struct lys_module *\nlys_parse_fd(struct ly_ctx *ctx, int fd, LYS_INFORMAT format)\n{\n    return lys_parse_fd_(ctx, fd, format, NULL, 1);\n}\n\nstatic void\nlys_parse_set_filename(struct ly_ctx *ctx, const char **filename, int fd)\n{\n#ifdef __APPLE__\n    char path[MAXPATHLEN];\n#else\n    int len;\n    char path[PATH_MAX], proc_path[32];\n#endif\n\n#ifdef __APPLE__\n    if (fcntl(fd, F_GETPATH, path) != -1) {\n        *filename = lydict_insert(ctx, path, 0);\n    }\n#else\n    /* get URI if there is /proc */\n    sprintf(proc_path, \"/proc/self/fd/%d\", fd);\n    if ((len = readlink(proc_path, path, PATH_MAX - 1)) > 0) {\n        *filename = lydict_insert(ctx, path, len);\n    }\n#endif\n}\n\nconst struct lys_module *\nlys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement)\n{\n    const struct lys_module *module;\n    size_t length;\n    char *addr;\n\n    if (!ctx || fd < 0) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(ctx, LY_EINVAL, \"Empty schema file.\");\n        return NULL;\n    }\n\n    module = lys_parse_mem_(ctx, addr, format, revision, 1, implement);\n    lyp_munmap(addr, length);\n\n    if (module && !module->filepath) {\n        lys_parse_set_filename(ctx, (const char **)&module->filepath, fd);\n    }\n\n    return module;\n}\n\nstruct lys_submodule *\nlys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    size_t length;\n    char *addr;\n\n    assert(module);\n    assert(fd >= 0);\n\n    if (lyp_mmap(module->ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(module->ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(module->ctx, LY_EINVAL, \"Empty submodule schema file.\");\n        return NULL;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submodule = yin_read_submodule(module, addr, unres);\n        break;\n    case LYS_IN_YANG:\n        submodule = yang_read_submodule(module, addr, 0, unres);\n        break;\n    default:\n        LOGINT(module->ctx);\n        return NULL;\n    }\n\n    lyp_munmap(addr, length);\n\n    if (submodule && !submodule->filepath) {\n        lys_parse_set_filename(module->ctx, (const char **)&submodule->filepath, fd);\n    }\n\n    return submodule;\n\n}\n\nAPI int\nlys_search_localfile(const char * const *searchpaths, int cwd, const char *name, const char *revision, char **localfile, LYS_INFORMAT *format)\n{\n    size_t len, flen, match_len = 0, dir_len;\n    int i, implicit_cwd = 0, ret = EXIT_FAILURE;\n    char *wd, *wn = NULL;\n    DIR *dir = NULL;\n    struct dirent *file;\n    char *match_name = NULL;\n    LYS_INFORMAT format_aux, match_format = 0;\n    unsigned int u;\n    struct ly_set *dirs;\n    struct stat st;\n\n    if (!localfile) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* start to fill the dir fifo with the context's search path (if set)\n     * and the current working directory */\n    dirs = ly_set_new();\n    if (!dirs) {\n        LOGMEM(NULL);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(name);\n    if (cwd) {\n        wd = get_current_dir_name();\n        if (!wd) {\n            LOGMEM(NULL);\n            goto cleanup;\n        } else {\n            /* add implicit current working directory (./) to be searched,\n             * this directory is not searched recursively */\n            if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n            implicit_cwd = 1;\n        }\n    }\n    if (searchpaths) {\n        for (i = 0; searchpaths[i]; i++) {\n            /* check for duplicities with the implicit current working directory */\n            if (implicit_cwd && !strcmp(dirs->set.g[0], searchpaths[i])) {\n                implicit_cwd = 0;\n                continue;\n            }\n            wd = strdup(searchpaths[i]);\n            if (!wd) {\n                LOGMEM(NULL);\n                goto cleanup;\n            } else if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n        }\n    }\n    wd = NULL;\n\n    /* start searching */\n    while (dirs->number) {\n        free(wd);\n        free(wn); wn = NULL;\n\n        dirs->number--;\n        wd = (char *)dirs->set.g[dirs->number];\n        dirs->set.g[dirs->number] = NULL;\n        LOGVRB(\"Searching for \\\"%s\\\" in %s.\", name, wd);\n\n        if (dir) {\n            closedir(dir);\n        }\n        dir = opendir(wd);\n        dir_len = strlen(wd);\n        if (!dir) {\n            LOGWRN(NULL, \"Unable to open directory \\\"%s\\\" for searching (sub)modules (%s).\", wd, strerror(errno));\n        } else {\n            while ((file = readdir(dir))) {\n                if (!strcmp(\".\", file->d_name) || !strcmp(\"..\", file->d_name)) {\n                    /* skip . and .. */\n                    continue;\n                }\n                free(wn);\n                if (asprintf(&wn, \"%s/%s\", wd, file->d_name) == -1) {\n                    LOGMEM(NULL);\n                    goto cleanup;\n                }\n                if (stat(wn, &st) == -1) {\n                    LOGWRN(NULL, \"Unable to get information about \\\"%s\\\" file in \\\"%s\\\" when searching for (sub)modules (%s)\",\n                           file->d_name, wd, strerror(errno));\n                    continue;\n                }\n                if (S_ISDIR(st.st_mode) && (dirs->number || !implicit_cwd)) {\n                    /* we have another subdirectory in searchpath to explore,\n                     * subdirectories are not taken into account in current working dir (dirs->set.g[0]) */\n                    if (ly_set_add(dirs, wn, 0) == -1) {\n                        goto cleanup;\n                    }\n                    /* continue with the next item in current directory */\n                    wn = NULL;\n                    continue;\n                } else if (!S_ISREG(st.st_mode)) {\n                    /* not a regular file (note that we see the target of symlinks instead of symlinks */\n                    continue;\n                }\n\n                /* here we know that the item is a file which can contain a module */\n                if (strncmp(name, file->d_name, len) ||\n                        (file->d_name[len] != '.' && file->d_name[len] != '@')) {\n                    /* different filename than the module we search for */\n                    continue;\n                }\n\n                /* get type according to filename suffix */\n                flen = strlen(file->d_name);\n                if (!strcmp(&file->d_name[flen - 4], \".yin\")) {\n                    format_aux = LYS_IN_YIN;\n                } else if (!strcmp(&file->d_name[flen - 5], \".yang\")) {\n                    format_aux = LYS_IN_YANG;\n                } else {\n                    /* not supportde suffix/file format */\n                    continue;\n                }\n\n                if (revision) {\n                    /* we look for the specific revision, try to get it from the filename */\n                    if (file->d_name[len] == '@') {\n                        /* check revision from the filename */\n                        if (strncmp(revision, &file->d_name[len + 1], strlen(revision))) {\n                            /* another revision */\n                            continue;\n                        } else {\n                            /* exact revision */\n                            free(match_name);\n                            match_name = wn;\n                            wn = NULL;\n                            match_len = dir_len + 1 + len;\n                            match_format = format_aux;\n                            goto success;\n                        }\n                    } else {\n                        /* continue trying to find exact revision match, use this only if not found */\n                        free(match_name);\n                        match_name = wn;\n                        wn = NULL;\n                        match_len = dir_len + 1 +len;\n                        match_format = format_aux;\n                        continue;\n                    }\n                } else {\n                    /* remember the revision and try to find the newest one */\n                    if (match_name) {\n                        if (file->d_name[len] != '@' || lyp_check_date(NULL, &file->d_name[len + 1])) {\n                            continue;\n                        } else if (match_name[match_len] == '@' &&\n                                (strncmp(&match_name[match_len + 1], &file->d_name[len + 1], LY_REV_SIZE - 1) >= 0)) {\n                            continue;\n                        }\n                        free(match_name);\n                    }\n\n                    match_name = wn;\n                    wn = NULL;\n                    match_len = dir_len + 1 + len;\n                    match_format = format_aux;\n                    continue;\n                }\n            }\n        }\n    }\n\nsuccess:\n    (*localfile) = match_name;\n    match_name = NULL;\n    if (format) {\n        (*format) = match_format;\n    }\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    free(wn);\n    free(wd);\n    if (dir) {\n        closedir(dir);\n    }\n    free(match_name);\n    for (u = 0; u < dirs->number; u++) {\n        free(dirs->set.g[u]);\n    }\n    ly_set_free(dirs);\n\n    return ret;\n}\n\nint\nlys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt)\n{\n    unsigned int u;\n\n    for (u = start; u < ext_size; u++) {\n        if (ext[u]->insubstmt == substmt) {\n            return u;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * duplicate extension instance\n */\nint\nlys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n            LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres)\n{\n    int i;\n    uint8_t u = 0;\n    struct lys_ext_instance **result;\n    struct unres_ext *info, *info_orig;\n    size_t len;\n\n    assert(new);\n\n    if (!size) {\n        if (orig) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n        (*new) = NULL;\n        return EXIT_SUCCESS;\n    }\n\n    (*new) = result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx), EXIT_FAILURE);\n    for (u = 0; u < size; u++) {\n        if (orig[u]) {\n            /* resolved extension instance, just duplicate it */\n            switch(orig[u]->ext_type) {\n            case LYEXT_FLAG:\n                result[u] = malloc(sizeof(struct lys_ext_instance));\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n                break;\n            case LYEXT_COMPLEX:\n                len = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->instance_size;\n                result[u] = calloc(1, len);\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n\n                ((struct lys_ext_instance_complex*)result[u])->substmt = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->substmt;\n                /* TODO duplicate data in extension instance content */\n                memcpy((void*)result[u] + sizeof(**orig), (void*)orig[u] + sizeof(**orig), len - sizeof(**orig));\n                break;\n            }\n            /* generic part */\n            result[u]->def = orig[u]->def;\n            result[u]->flags = LYEXT_OPT_CONTENT;\n            result[u]->arg_value = lydict_insert(ctx, orig[u]->arg_value, 0);\n            result[u]->parent = parent;\n            result[u]->parent_type = parent_type;\n            result[u]->insubstmt = orig[u]->insubstmt;\n            result[u]->insubstmt_index = orig[u]->insubstmt_index;\n            result[u]->ext_type = orig[u]->ext_type;\n            result[u]->priv = NULL;\n            result[u]->nodetype = LYS_EXT;\n            result[u]->module = mod;\n\n            /* extensions */\n            result[u]->ext_size = orig[u]->ext_size;\n            if (lys_ext_dup(ctx, mod, orig[u]->ext, orig[u]->ext_size, result[u],\n                            LYEXT_PAR_EXTINST, &result[u]->ext, shallow, unres)) {\n                goto error;\n            }\n\n            /* in case of shallow copy (duplication for deviation), duplicate only the link to private data\n             * in a new copy, otherwise (grouping instantiation) do not duplicate the private data */\n            if (shallow) {\n                result[u]->priv = orig[u]->priv;\n            }\n        } else {\n            /* original extension is not yet resolved, so duplicate it in unres */\n            i = unres_schema_find(unres, -1, &orig, UNRES_EXT);\n            if (i == -1) {\n                /* extension not found in unres */\n                LOGINT(ctx);\n                goto error;\n            }\n            info_orig = unres->str_snode[i];\n            info = malloc(sizeof *info);\n            LY_CHECK_ERR_GOTO(!info, LOGMEM(ctx), error);\n            info->datatype = info_orig->datatype;\n            if (info->datatype == LYS_IN_YIN) {\n                info->data.yin = lyxml_dup_elem(ctx, info_orig->data.yin, NULL, 1, 0);\n            } /* else TODO YANG */\n            info->parent = parent;\n            info->mod = mod;\n            info->parent_type = parent_type;\n            info->ext_index = u;\n            if (unres_schema_add_node(info->mod, unres, new, UNRES_EXT, (struct lys_node *)info) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    (*new) = NULL;\n    lys_extension_instances_free(ctx, result, u, NULL);\n    return EXIT_FAILURE;\n}\n\nstatic struct lys_restr *\nlys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}\n\nvoid\nlys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!restr) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, restr->ext, restr->ext_size, private_destructor);\n    lydict_remove(ctx, restr->expr);\n    lydict_remove(ctx, restr->dsc);\n    lydict_remove(ctx, restr->ref);\n    lydict_remove(ctx, restr->eapptag);\n    lydict_remove(ctx, restr->emsg);\n}\n\nAPI void\nlys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size,\n                   int shallow, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    uint8_t i;\n\n    for (i = 0; i < iffeature_size; ++i) {\n        lys_extension_instances_free(ctx, iffeature[i].ext, iffeature[i].ext_size, private_destructor);\n        if (!shallow) {\n            free(iffeature[i].expr);\n            free(iffeature[i].features);\n        }\n    }\n    free(iffeature);\n}\n\nstatic int\ntype_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n         LY_DATA_TYPE base, int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n    unsigned int u;\n\n    switch (base) {\n    case LY_TYPE_BINARY:\n        if (old->info.binary.length) {\n            new->info.binary.length = lys_restr_dup(mod, old->info.binary.length, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        new->info.bits.count = old->info.bits.count;\n        if (new->info.bits.count) {\n            new->info.bits.bit = calloc(new->info.bits.count, sizeof *new->info.bits.bit);\n            LY_CHECK_ERR_RETURN(!new->info.bits.bit, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.bits.count; u++) {\n                new->info.bits.bit[u].name = lydict_insert(mod->ctx, old->info.bits.bit[u].name, 0);\n                new->info.bits.bit[u].dsc = lydict_insert(mod->ctx, old->info.bits.bit[u].dsc, 0);\n                new->info.bits.bit[u].ref = lydict_insert(mod->ctx, old->info.bits.bit[u].ref, 0);\n                new->info.bits.bit[u].flags = old->info.bits.bit[u].flags;\n                new->info.bits.bit[u].pos = old->info.bits.bit[u].pos;\n                new->info.bits.bit[u].ext_size = old->info.bits.bit[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.bits.bit[u].ext, old->info.bits.bit[u].ext_size,\n                                &new->info.bits.bit[u], LYEXT_PAR_TYPE_BIT,\n                                &new->info.bits.bit[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        new->info.dec64.dig = old->info.dec64.dig;\n        new->info.dec64.div = old->info.dec64.div;\n        if (old->info.dec64.range) {\n            new->info.dec64.range = lys_restr_dup(mod, old->info.dec64.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        new->info.enums.count = old->info.enums.count;\n        if (new->info.enums.count) {\n            new->info.enums.enm = calloc(new->info.enums.count, sizeof *new->info.enums.enm);\n            LY_CHECK_ERR_RETURN(!new->info.enums.enm, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.enums.count; u++) {\n                new->info.enums.enm[u].name = lydict_insert(mod->ctx, old->info.enums.enm[u].name, 0);\n                new->info.enums.enm[u].dsc = lydict_insert(mod->ctx, old->info.enums.enm[u].dsc, 0);\n                new->info.enums.enm[u].ref = lydict_insert(mod->ctx, old->info.enums.enm[u].ref, 0);\n                new->info.enums.enm[u].flags = old->info.enums.enm[u].flags;\n                new->info.enums.enm[u].value = old->info.enums.enm[u].value;\n                new->info.enums.enm[u].ext_size = old->info.enums.enm[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.enums.enm[u].ext, old->info.enums.enm[u].ext_size,\n                                &new->info.enums.enm[u], LYEXT_PAR_TYPE_ENUM,\n                                &new->info.enums.enm[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        new->info.ident.count = old->info.ident.count;\n        if (old->info.ident.count) {\n            new->info.ident.ref = malloc(old->info.ident.count * sizeof *new->info.ident.ref);\n            LY_CHECK_ERR_RETURN(!new->info.ident.ref, LOGMEM(mod->ctx), -1);\n            memcpy(new->info.ident.ref, old->info.ident.ref, old->info.ident.count * sizeof *new->info.ident.ref);\n        } else {\n            /* there can be several unresolved base identities, duplicate them all */\n            i = -1;\n            do {\n                i = unres_schema_find(unres, i, old, UNRES_TYPE_IDENTREF);\n                if (i != -1) {\n                    if (unres_schema_add_str(mod, unres, new, UNRES_TYPE_IDENTREF, unres->str_snode[i]) == -1) {\n                        return -1;\n                    }\n                }\n                --i;\n            } while (i > -1);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        new->info.inst.req = old->info.inst.req;\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        if (old->info.num.range) {\n            new->info.num.range = lys_restr_dup(mod, old->info.num.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (old->info.lref.path) {\n            new->info.lref.path = lydict_insert(mod->ctx, old->info.lref.path, 0);\n            new->info.lref.req = old->info.lref.req;\n            if (!in_grp && unres_schema_add_node(mod, unres, new, UNRES_TYPE_LEAFREF, parent) == -1) {\n                return -1;\n            }\n        }\n        break;\n\n    case LY_TYPE_STRING:\n        if (old->info.str.length) {\n            new->info.str.length = lys_restr_dup(mod, old->info.str.length, 1, shallow, unres);\n        }\n        if (old->info.str.pat_count) {\n            new->info.str.patterns = lys_restr_dup(mod, old->info.str.patterns, old->info.str.pat_count, shallow, unres);\n            new->info.str.pat_count = old->info.str.pat_count;\n#ifdef LY_ENABLED_CACHE\n            if (!in_grp) {\n                new->info.str.patterns_pcre = malloc(new->info.str.pat_count * 2 * sizeof *new->info.str.patterns_pcre);\n                LY_CHECK_ERR_RETURN(!new->info.str.patterns_pcre, LOGMEM(mod->ctx), -1);\n                for (u = 0; u < new->info.str.pat_count; u++) {\n                    if (lyp_precompile_pattern(mod->ctx, &new->info.str.patterns[u].expr[1],\n                                              (pcre**)&new->info.str.patterns_pcre[2 * u],\n                                              (pcre_extra**)&new->info.str.patterns_pcre[2 * u + 1])) {\n                        free(new->info.str.patterns_pcre);\n                        new->info.str.patterns_pcre = NULL;\n                        return -1;\n                    }\n                }\n            }\n#endif\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        new->info.uni.has_ptr_type = old->info.uni.has_ptr_type;\n        new->info.uni.count = old->info.uni.count;\n        if (new->info.uni.count) {\n            new->info.uni.types = calloc(new->info.uni.count, sizeof *new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.uni.count; u++) {\n                if (lys_type_dup(mod, parent, &(new->info.uni.types[u]), &(old->info.uni.types[u]), in_grp,\n                        shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstruct yang_type *\nlys_yang_type_dup(struct lys_module *module, struct lys_node *parent, struct yang_type *old, struct lys_type *type,\n                  int in_grp, int shallow, struct unres_schema *unres)\n{\n    struct yang_type *new;\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(module->ctx), NULL);\n    new->flags = old->flags;\n    new->base = old->base;\n    new->name = lydict_insert(module->ctx, old->name, 0);\n    new->type = type;\n    if (!new->name) {\n        LOGMEM(module->ctx);\n        goto error;\n    }\n    if (type_dup(module, parent, type, old->type, new->base, in_grp, shallow, unres)) {\n        new->type->base = new->base;\n        lys_type_free(module->ctx, new->type, NULL);\n        memset(&new->type->info, 0, sizeof new->type->info);\n        goto error;\n    }\n    return new;\n\nerror:\n    free(new);\n    return NULL;\n}\n\nint\nlys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type, struct lys_type *prev_new,\n                        struct unres_schema *unres)\n{\n    struct lys_type new;\n    unsigned int i, top_type;\n    struct lys_ext_instance **ext;\n    uint8_t ext_size;\n    void *reloc;\n\n    if (!prev_new) {\n        /* this is the \"top-level\" type, meaning it is a real type and no typedef directly above */\n        top_type = 1;\n\n        memset(&new, 0, sizeof new);\n\n        new.base = type->base;\n        new.parent = (struct lys_tpdf *)parent;\n\n        prev_new = &new;\n    } else {\n        /* this is not top-level type, just a type of a typedef */\n        top_type = 0;\n    }\n\n    assert(type->der);\n    if (type->der->module) {\n        /* typedef, skip it, but keep the extensions */\n        ext_size = type->ext_size;\n        if (lys_ext_dup(mod->ctx, mod, type->ext, type->ext_size, prev_new, LYEXT_PAR_TYPE, &ext, 0, unres)) {\n            return -1;\n        }\n        if (prev_new->ext) {\n            reloc = realloc(prev_new->ext, (prev_new->ext_size + ext_size) * sizeof *prev_new->ext);\n            LY_CHECK_ERR_RETURN(!reloc, LOGMEM(mod->ctx), -1);\n            prev_new->ext = reloc;\n\n            memcpy(prev_new->ext + prev_new->ext_size, ext, ext_size * sizeof *ext);\n            free(ext);\n\n            prev_new->ext_size += ext_size;\n        } else {\n            prev_new->ext = ext;\n            prev_new->ext_size = ext_size;\n        }\n\n        if (lys_copy_union_leafrefs(mod, parent, &type->der->type, prev_new, unres)) {\n            return -1;\n        }\n    } else {\n        /* type, just make a deep copy */\n        switch (type->base) {\n        case LY_TYPE_UNION:\n            prev_new->info.uni.has_ptr_type = type->info.uni.has_ptr_type;\n            prev_new->info.uni.count = type->info.uni.count;\n            /* this cannot be a typedef anymore */\n            assert(prev_new->info.uni.count);\n\n            prev_new->info.uni.types = calloc(prev_new->info.uni.count, sizeof *prev_new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!prev_new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (i = 0; i < prev_new->info.uni.count; i++) {\n                if (lys_copy_union_leafrefs(mod, parent, &(type->info.uni.types[i]), &(prev_new->info.uni.types[i]), unres)) {\n                    return -1;\n                }\n            }\n\n            prev_new->der = type->der;\n            break;\n        default:\n            if (lys_type_dup(mod, parent, prev_new, type, 0, 0, unres)) {\n                return -1;\n            }\n            break;\n        }\n    }\n\n    if (top_type) {\n        memcpy(type, prev_new, sizeof *type);\n    }\n    return EXIT_SUCCESS;\n}\n\nAPI const void *\nlys_ext_instance_substmt(const struct lys_ext_instance *ext)\n{\n    if (!ext) {\n        return NULL;\n    }\n\n    switch (ext->insubstmt) {\n    case LYEXT_SUBSTMT_SELF:\n    case LYEXT_SUBSTMT_MODIFIER:\n    case LYEXT_SUBSTMT_VERSION:\n        return NULL;\n    case LYEXT_SUBSTMT_ARGUMENT:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return ((struct lys_ext_instance*)ext->parent)->arg_value;\n        }\n        break;\n    case LYEXT_SUBSTMT_BASE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            return ((struct lys_type*)ext->parent)->info.ident.ref[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_IDENT) {\n            return ((struct lys_ident*)ext->parent)->base[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_BELONGSTO:\n        if (ext->parent_type == LYEXT_PAR_MODULE && ((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_submodule*)ext->parent)->belongsto;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONFIG:\n    case LYEXT_SUBSTMT_MANDATORY:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            return &((struct lys_node*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONTACT:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->contact;\n        }\n        break;\n    case LYEXT_SUBSTMT_DEFAULT:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            switch (((struct lys_node*)ext->parent)->nodetype) {\n            case LYS_LEAF:\n            case LYS_LEAFLIST:\n                /* in case of leaf, the index is supposed to be 0, so it will return the\n                 * correct pointer despite the leaf structure does not have dflt as array */\n                return ((struct lys_node_leaflist*)ext->parent)->dflt[ext->insubstmt_index];\n            case LYS_CHOICE:\n                return ((struct lys_node_choice*)ext->parent)->dflt;\n            default:\n                /* internal error */\n                break;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->dflt;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->dflt[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->dflt[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_DESCRIPTION:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->dsc;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->dsc;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->dsc;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->dsc;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->dsc;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->dsc;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->dsc;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->dsc;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->dsc;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->dsc;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->dsc;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->dsc;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->dsc;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRTAG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->eapptag;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRMSG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->emsg;\n        }\n        break;\n    case LYEXT_SUBSTMT_DIGITS:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_DEC64) {\n            return &((struct lys_type*)ext->parent)->info.dec64.dig;\n        }\n        break;\n    case LYEXT_SUBSTMT_KEY:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return ((struct lys_node_list*)ext->parent)->keys;\n        }\n        break;\n    case LYEXT_SUBSTMT_MAX:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->max;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->max;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.max;\n        }\n        break;\n    case LYEXT_SUBSTMT_MIN:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->min;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->min;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.min;\n        }\n        break;\n    case LYEXT_SUBSTMT_NAMESPACE:\n        if (ext->parent_type == LYEXT_PAR_MODULE && !((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_module*)ext->parent)->ns;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORDEREDBY:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n            return &((struct lys_node_list*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORGANIZATION:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->org;\n        }\n        break;\n    case LYEXT_SUBSTMT_PATH:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n            return ((struct lys_type*)ext->parent)->info.lref.path;\n        }\n        break;\n    case LYEXT_SUBSTMT_POSITION:\n        if (ext->parent_type == LYEXT_PAR_TYPE_BIT) {\n            return &((struct lys_type_bit*)ext->parent)->pos;\n        }\n        break;\n    case LYEXT_SUBSTMT_PREFIX:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            /* covers also lys_submodule */\n            return ((struct lys_module*)ext->parent)->prefix;\n        } else if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->prefix;\n        }\n        break;\n    case LYEXT_SUBSTMT_PRESENCE:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_CONTAINER) {\n            return ((struct lys_node_container*)ext->parent)->presence;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return ((struct lys_refine*)ext->parent)->mod.presence;\n        }\n        break;\n    case LYEXT_SUBSTMT_REFERENCE:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->ref;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->ref;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->ref;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->ref;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->ref;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->ref;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->ref;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->ref;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->ref;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->ref;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->ref;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->ref;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->ref;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_REQINSTANCE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            if (((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n                return &((struct lys_type*)ext->parent)->info.lref.req;\n            } else if (((struct lys_type*)ext->parent)->base == LY_TYPE_INST) {\n                return &((struct lys_type*)ext->parent)->info.inst.req;\n            }\n        }\n        break;\n    case LYEXT_SUBSTMT_REVISIONDATE:\n        if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->rev;\n        } else if (ext->parent_type == LYEXT_PAR_INCLUDE) {\n            return ((struct lys_include*)ext->parent)->rev;\n        }\n        break;\n    case LYEXT_SUBSTMT_STATUS:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n        case LYEXT_PAR_IDENT:\n        case LYEXT_PAR_TPDF:\n        case LYEXT_PAR_EXT:\n        case LYEXT_PAR_FEATURE:\n        case LYEXT_PAR_TYPE_ENUM:\n        case LYEXT_PAR_TYPE_BIT:\n            /* in all structures the flags member is at the same offset */\n            return &((struct lys_node*)ext->parent)->flags;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_UNIQUE:\n        if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->unique[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return &((struct lys_node_list*)ext->parent)->unique[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_UNITS:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            /* units is at the same offset in both lys_node_leaf and lys_node_leaflist */\n            return ((struct lys_node_leaf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->units;\n        }\n        break;\n    case LYEXT_SUBSTMT_VALUE:\n        if (ext->parent_type == LYEXT_PAR_TYPE_ENUM) {\n            return &((struct lys_type_enum*)ext->parent)->value;\n        }\n        break;\n    case LYEXT_SUBSTMT_YINELEM:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return &((struct lys_ext*)ext->parent)->flags;\n        }\n        break;\n    }\n    LOGINT(ext->module->ctx);\n    return NULL;\n}\n\nstatic int\nlys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n            int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n\n    new->base = old->base;\n    new->der = old->der;\n    new->parent = (struct lys_tpdf *)parent;\n    new->ext_size = old->ext_size;\n    if (lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_TYPE, &new->ext, shallow, unres)) {\n        return -1;\n    }\n\n    i = unres_schema_find(unres, -1, old, UNRES_TYPE_DER);\n    if (i != -1) {\n        /* HACK (serious one) for unres */\n        /* nothing else we can do but duplicate it immediately */\n        if (((struct lyxml_elem *)old->der)->flags & LY_YANG_STRUCTURE_FLAG) {\n            new->der = (struct lys_tpdf *)lys_yang_type_dup(mod, parent, (struct yang_type *)old->der, new, in_grp,\n                                                            shallow, unres);\n        } else {\n            new->der = (struct lys_tpdf *)lyxml_dup_elem(mod->ctx, (struct lyxml_elem *)old->der, NULL, 1, 0);\n        }\n        /* all these unres additions can fail even though they did not before */\n        if (!new->der || (unres_schema_add_node(mod, unres, new, UNRES_TYPE_DER, parent) == -1)) {\n            return -1;\n        }\n        return EXIT_SUCCESS;\n    }\n\n    return type_dup(mod, parent, new, old, new->base, in_grp, shallow, unres);\n}\n\nvoid\nlys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i;\n\n    assert(ctx);\n    if (!type) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, type->ext, type->ext_size, private_destructor);\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        lys_restr_free(ctx, type->info.binary.length, private_destructor);\n        free(type->info.binary.length);\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; i++) {\n            lydict_remove(ctx, type->info.bits.bit[i].name);\n            lydict_remove(ctx, type->info.bits.bit[i].dsc);\n            lydict_remove(ctx, type->info.bits.bit[i].ref);\n            lys_iffeature_free(ctx, type->info.bits.bit[i].iffeature, type->info.bits.bit[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.bits.bit);\n        break;\n\n    case LY_TYPE_DEC64:\n        lys_restr_free(ctx, type->info.dec64.range, private_destructor);\n        free(type->info.dec64.range);\n        break;\n\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; i++) {\n            lydict_remove(ctx, type->info.enums.enm[i].name);\n            lydict_remove(ctx, type->info.enums.enm[i].dsc);\n            lydict_remove(ctx, type->info.enums.enm[i].ref);\n            lys_iffeature_free(ctx, type->info.enums.enm[i].iffeature, type->info.enums.enm[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.enums.enm);\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        lys_restr_free(ctx, type->info.num.range, private_destructor);\n        free(type->info.num.range);\n        break;\n\n    case LY_TYPE_LEAFREF:\n        lydict_remove(ctx, type->info.lref.path);\n        break;\n\n    case LY_TYPE_STRING:\n        lys_restr_free(ctx, type->info.str.length, private_destructor);\n        free(type->info.str.length);\n        for (i = 0; i < type->info.str.pat_count; i++) {\n            lys_restr_free(ctx, &type->info.str.patterns[i], private_destructor);\n#ifdef LY_ENABLED_CACHE\n            if (type->info.str.patterns_pcre) {\n                pcre_free((pcre*)type->info.str.patterns_pcre[2 * i]);\n                pcre_free_study((pcre_extra*)type->info.str.patterns_pcre[2 * i + 1]);\n            }\n#endif\n        }\n        free(type->info.str.patterns);\n#ifdef LY_ENABLED_CACHE\n        free(type->info.str.patterns_pcre);\n#endif\n        break;\n\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; i++) {\n            lys_type_free(ctx, &type->info.uni.types[i], private_destructor);\n        }\n        free(type->info.uni.types);\n        break;\n\n    case LY_TYPE_IDENT:\n        free(type->info.ident.ref);\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_INST, LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n}\n\nstatic void\nlys_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    lydict_remove(ctx, tpdf->name);\n    lydict_remove(ctx, tpdf->dsc);\n    lydict_remove(ctx, tpdf->ref);\n\n    lys_type_free(ctx, &tpdf->type, private_destructor);\n\n    lydict_remove(ctx, tpdf->units);\n    lydict_remove(ctx, tpdf->dflt);\n\n    lys_extension_instances_free(ctx, tpdf->ext, tpdf->ext_size, private_destructor);\n}\n\nstatic struct lys_when *\nlys_when_dup(struct lys_module *mod, struct lys_when *old, int shallow, struct unres_schema *unres)\n{\n    struct lys_when *new;\n\n    if (!old) {\n        return NULL;\n    }\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(mod->ctx), NULL);\n    new->cond = lydict_insert(mod->ctx, old->cond, 0);\n    new->dsc = lydict_insert(mod->ctx, old->dsc, 0);\n    new->ref = lydict_insert(mod->ctx, old->ref, 0);\n    new->ext_size = old->ext_size;\n    lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_WHEN, &new->ext, shallow, unres);\n\n    return new;\n}\n\nvoid\nlys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    if (!w) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, w->ext, w->ext_size, private_destructor);\n    lydict_remove(ctx, w->cond);\n    lydict_remove(ctx, w->dsc);\n    lydict_remove(ctx, w->ref);\n\n    free(w);\n}\n\nstatic void\nlys_augment_free(struct ly_ctx *ctx, struct lys_node_augment *aug,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct lys_node *next, *sub;\n\n    /* children from a resolved augment are freed under the target node */\n    if (!aug->target || (aug->flags & LYS_NOTAPPLIED)) {\n        LY_TREE_FOR_SAFE(aug->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, private_destructor);\n\n    lys_when_free(ctx, aug->when, private_destructor);\n}\n\nstatic void\nlys_ident_free(struct ly_ctx *ctx, struct lys_ident *ident,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!ident) {\n        return;\n    }\n\n    free(ident->base);\n    ly_set_free(ident->der);\n    lydict_remove(ctx, ident->name);\n    lydict_remove(ctx, ident->dsc);\n    lydict_remove(ctx, ident->ref);\n    lys_iffeature_free(ctx, ident->iffeature, ident->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, ident->ext, ident->ext_size, private_destructor);\n\n}\n\nstatic void\nlys_grp_free(struct ly_ctx *ctx, struct lys_node_grp *grp,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < grp->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &grp->tpdf[i], private_destructor);\n    }\n    free(grp->tpdf);\n}\n\nstatic void\nlys_rpc_action_free(struct ly_ctx *ctx, struct lys_node_rpc_action *rpc_act,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < rpc_act->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &rpc_act->tpdf[i], private_destructor);\n    }\n    free(rpc_act->tpdf);\n}\n\nstatic void\nlys_inout_free(struct ly_ctx *ctx, struct lys_node_inout *io,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_INPUT and LYS_OUTPUT */\n    for (i = 0; i < io->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &io->tpdf[i], private_destructor);\n    }\n    free(io->tpdf);\n\n    for (i = 0; i < io->must_size; i++) {\n        lys_restr_free(ctx, &io->must[i], private_destructor);\n    }\n    free(io->must);\n}\n\nstatic void\nlys_notif_free(struct ly_ctx *ctx, struct lys_node_notif *notif,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < notif->must_size; i++) {\n        lys_restr_free(ctx, &notif->must[i], private_destructor);\n    }\n    free(notif->must);\n\n    for (i = 0; i < notif->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &notif->tpdf[i], private_destructor);\n    }\n    free(notif->tpdf);\n}\nstatic void\nlys_anydata_free(struct ly_ctx *ctx, struct lys_node_anydata *anyxml,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < anyxml->must_size; i++) {\n        lys_restr_free(ctx, &anyxml->must[i], private_destructor);\n    }\n    free(anyxml->must);\n\n    lys_when_free(ctx, anyxml->when, private_destructor);\n}\n\nstatic void\nlys_leaf_free(struct ly_ctx *ctx, struct lys_node_leaf *leaf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* leafref backlinks */\n    ly_set_free((struct ly_set *)leaf->backlinks);\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], private_destructor);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, private_destructor);\n\n    lys_type_free(ctx, &leaf->type, private_destructor);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nlys_leaflist_free(struct ly_ctx *ctx, struct lys_node_leaflist *llist,\n                  void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (llist->backlinks) {\n        /* leafref backlinks */\n        ly_set_free(llist->backlinks);\n    }\n\n    for (i = 0; i < llist->must_size; i++) {\n        lys_restr_free(ctx, &llist->must[i], private_destructor);\n    }\n    free(llist->must);\n\n    for (i = 0; i < llist->dflt_size; i++) {\n        lydict_remove(ctx, llist->dflt[i]);\n    }\n    free(llist->dflt);\n\n    lys_when_free(ctx, llist->when, private_destructor);\n\n    lys_type_free(ctx, &llist->type, private_destructor);\n    lydict_remove(ctx, llist->units);\n}\n\nstatic void\nlys_list_free(struct ly_ctx *ctx, struct lys_node_list *list,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    /* handle only specific parts for LY_NODE_LIST */\n    lys_when_free(ctx, list->when, private_destructor);\n\n    for (i = 0; i < list->must_size; i++) {\n        lys_restr_free(ctx, &list->must[i], private_destructor);\n    }\n    free(list->must);\n\n    for (i = 0; i < list->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &list->tpdf[i], private_destructor);\n    }\n    free(list->tpdf);\n\n    free(list->keys);\n\n    for (i = 0; i < list->unique_size; i++) {\n        for (j = 0; j < list->unique[i].expr_size; j++) {\n            lydict_remove(ctx, list->unique[i].expr[j]);\n        }\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    lydict_remove(ctx, list->keys_str);\n}\n\nstatic void\nlys_container_free(struct ly_ctx *ctx, struct lys_node_container *cont,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LY_NODE_CONTAINER */\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &cont->tpdf[i], private_destructor);\n    }\n    free(cont->tpdf);\n\n    for (i = 0; i < cont->must_size; i++) {\n        lys_restr_free(ctx, &cont->must[i], private_destructor);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, private_destructor);\n}\n\nstatic void\nlys_feature_free(struct ly_ctx *ctx, struct lys_feature *f,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, f->name);\n    lydict_remove(ctx, f->dsc);\n    lydict_remove(ctx, f->ref);\n    lys_iffeature_free(ctx, f->iffeature, f->iffeature_size, 0, private_destructor);\n    ly_set_free(f->depfeatures);\n    lys_extension_instances_free(ctx, f->ext, f->ext_size, private_destructor);\n}\n\nstatic void\nlys_extension_free(struct ly_ctx *ctx, struct lys_ext *e,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, e->name);\n    lydict_remove(ctx, e->dsc);\n    lydict_remove(ctx, e->ref);\n    lydict_remove(ctx, e->argument);\n    lys_extension_instances_free(ctx, e->ext, e->ext_size, private_destructor);\n}\n\nstatic void\nlys_deviation_free(struct lys_module *module, struct lys_deviation *dev,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j, k;\n    struct ly_ctx *ctx;\n    struct lys_node *next, *elem;\n\n    ctx = module->ctx;\n\n    lydict_remove(ctx, dev->target_name);\n    lydict_remove(ctx, dev->dsc);\n    lydict_remove(ctx, dev->ref);\n    lys_extension_instances_free(ctx, dev->ext, dev->ext_size, private_destructor);\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    /* it could not be applied because it failed to be applied */\n    if (dev->orig_node) {\n        /* the module was freed, but we only need the context from orig_node, use ours */\n        if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n            /* it's actually a node subtree, we need to update modules on all the nodes :-/ */\n            LY_TREE_DFS_BEGIN(dev->orig_node, next, elem) {\n                elem->module = module;\n\n                LY_TREE_DFS_END(dev->orig_node, next, elem);\n            }\n            lys_node_free(dev->orig_node, NULL, 0);\n        } else {\n            /* it's just a shallow copy, freeing one node */\n            dev->orig_node->module = module;\n            lys_node_free(dev->orig_node, NULL, 1);\n        }\n    }\n\n    for (i = 0; i < dev->deviate_size; i++) {\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, private_destructor);\n\n        for (j = 0; j < dev->deviate[i].dflt_size; j++) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].mod == LY_DEVIATE_DEL) {\n            for (j = 0; j < dev->deviate[i].must_size; j++) {\n                lys_restr_free(ctx, &dev->deviate[i].must[j], private_destructor);\n            }\n            free(dev->deviate[i].must);\n\n            for (j = 0; j < dev->deviate[i].unique_size; j++) {\n                for (k = 0; k < dev->deviate[i].unique[j].expr_size; k++) {\n                    lydict_remove(ctx, dev->deviate[i].unique[j].expr[k]);\n                }\n                free(dev->deviate[i].unique[j].expr);\n            }\n            free(dev->deviate[i].unique);\n        }\n    }\n    free(dev->deviate);\n}\n\nstatic void\nlys_uses_free(struct ly_ctx *ctx, struct lys_node_uses *uses,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        lys_iffeature_free(ctx, uses->refine[i].iffeature, uses->refine[i].iffeature_size, 0, private_destructor);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], private_destructor);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, private_destructor);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n    }\n    free(uses->refine);\n\n    for (i = 0; i < uses->augment_size; i++) {\n        lys_augment_free(ctx, &uses->augment[i], private_destructor);\n    }\n    free(uses->augment);\n\n    lys_when_free(ctx, uses->when, private_destructor);\n}\n\nvoid\nlys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    assert(node->module);\n    assert(node->module->ctx);\n\n    ctx = node->module->ctx;\n\n    /* remove private object */\n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    /* common part */\n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    /* specific part */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        /* do nothing */\n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    /* again common part */\n    lys_node_unlink(node);\n    free(node);\n}\n\nAPI struct lys_module *\nlys_implemented_module(const struct lys_module *mod)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!mod || mod->implemented) {\n        /* invalid argument or the module itself is implemented */\n        return (struct lys_module *)mod;\n    }\n\n    ctx = mod->ctx;\n    for (i = 0; i < ctx->models.used; i++) {\n        if (!ctx->models.list[i]->implemented) {\n            continue;\n        }\n\n        if (ly_strequal(mod->name, ctx->models.list[i]->name, 1)) {\n            /* we have some revision of the module implemented */\n            return ctx->models.list[i];\n        }\n    }\n\n    /* we have no revision of the module implemented, return the module itself,\n     * it is up to the caller to set the module implemented when needed */\n    return (struct lys_module *)mod;\n}\n\n/* free_int_mods - flag whether to free the internal modules as well */\nstatic void\nmodule_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct ly_ctx *ctx;\n    struct lys_node *next, *iter;\n    unsigned int i;\n\n    assert(module->ctx);\n    ctx = module->ctx;\n\n    /* just free the import array, imported modules will stay in the context */\n    for (i = 0; i < module->imp_size; i++) {\n        lydict_remove(ctx, module->imp[i].prefix);\n        lydict_remove(ctx, module->imp[i].dsc);\n        lydict_remove(ctx, module->imp[i].ref);\n        lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor);\n    }\n    free(module->imp);\n\n    /* submodules don't have data tree, the data nodes\n     * are placed in the main module altogether */\n    if (!module->type) {\n        LY_TREE_FOR_SAFE(module->data, next, iter) {\n            lys_node_free(iter, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, module->dsc);\n    lydict_remove(ctx, module->ref);\n    lydict_remove(ctx, module->org);\n    lydict_remove(ctx, module->contact);\n    lydict_remove(ctx, module->filepath);\n\n    /* revisions */\n    for (i = 0; i < module->rev_size; i++) {\n        lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor);\n        lydict_remove(ctx, module->rev[i].dsc);\n        lydict_remove(ctx, module->rev[i].ref);\n    }\n    free(module->rev);\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        lys_ident_free(ctx, &module->ident[i], private_destructor);\n    }\n    module->ident_size = 0;\n    free(module->ident);\n\n    /* typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &module->tpdf[i], private_destructor);\n    }\n    free(module->tpdf);\n\n    /* extension instances */\n    lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor);\n\n    /* augment */\n    for (i = 0; i < module->augment_size; i++) {\n        lys_augment_free(ctx, &module->augment[i], private_destructor);\n    }\n    free(module->augment);\n\n    /* features */\n    for (i = 0; i < module->features_size; i++) {\n        lys_feature_free(ctx, &module->features[i], private_destructor);\n    }\n    free(module->features);\n\n    /* deviations */\n    for (i = 0; i < module->deviation_size; i++) {\n        lys_deviation_free(module, &module->deviation[i], private_destructor);\n    }\n    free(module->deviation);\n\n    /* extensions */\n    for (i = 0; i < module->extensions_size; i++) {\n        lys_extension_free(ctx, &module->extensions[i], private_destructor);\n    }\n    free(module->extensions);\n\n    lydict_remove(ctx, module->name);\n    lydict_remove(ctx, module->prefix);\n}\n\nvoid\nlys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (!submodule) {\n        return;\n    }\n\n    /* common part with struct ly_module */\n    module_free_common((struct lys_module *)submodule, private_destructor);\n\n    /* include */\n    for (i = 0; i < submodule->inc_size; i++) {\n        lydict_remove(submodule->ctx, submodule->inc[i].dsc);\n        lydict_remove(submodule->ctx, submodule->inc[i].ref);\n        lys_extension_instances_free(submodule->ctx, submodule->inc[i].ext, submodule->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n    }\n    free(submodule->inc);\n\n    free(submodule);\n}\n\nint\nlys_ingrouping(const struct lys_node *node)\n{\n    const struct lys_node *iter = node;\n    assert(node);\n\n    for(iter = node; iter && iter->nodetype != LYS_GROUPING; iter = lys_parent(iter));\n    if (!iter) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n/*\n * final: 0 - do not change config flags; 1 - inherit config flags from the parent; 2 - remove config flags\n */\nstatic struct lys_node *\nlys_node_dup_recursion(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                       struct unres_schema *unres, int shallow, int finalize)\n{\n    struct lys_node *retval = NULL, *iter, *p;\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, rc;\n    unsigned int size, size1, size2;\n    struct unres_list_uniq *unique_info;\n    uint16_t flags;\n\n    struct lys_node_container *cont = NULL;\n    struct lys_node_container *cont_orig = (struct lys_node_container *)node;\n    struct lys_node_choice *choice = NULL;\n    struct lys_node_choice *choice_orig = (struct lys_node_choice *)node;\n    struct lys_node_leaf *leaf = NULL;\n    struct lys_node_leaf *leaf_orig = (struct lys_node_leaf *)node;\n    struct lys_node_leaflist *llist = NULL;\n    struct lys_node_leaflist *llist_orig = (struct lys_node_leaflist *)node;\n    struct lys_node_list *list = NULL;\n    struct lys_node_list *list_orig = (struct lys_node_list *)node;\n    struct lys_node_anydata *any = NULL;\n    struct lys_node_anydata *any_orig = (struct lys_node_anydata *)node;\n    struct lys_node_uses *uses = NULL;\n    struct lys_node_uses *uses_orig = (struct lys_node_uses *)node;\n    struct lys_node_rpc_action *rpc = NULL;\n    struct lys_node_inout *io = NULL;\n    struct lys_node_notif *ntf = NULL;\n    struct lys_node_case *cs = NULL;\n    struct lys_node_case *cs_orig = (struct lys_node_case *)node;\n\n    /* we cannot just duplicate memory since the strings are stored in\n     * dictionary and we need to update dictionary counters.\n     */\n\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        cont = calloc(1, sizeof *cont);\n        retval = (struct lys_node *)cont;\n        break;\n\n    case LYS_CHOICE:\n        choice = calloc(1, sizeof *choice);\n        retval = (struct lys_node *)choice;\n        break;\n\n    case LYS_LEAF:\n        leaf = calloc(1, sizeof *leaf);\n        retval = (struct lys_node *)leaf;\n        break;\n\n    case LYS_LEAFLIST:\n        llist = calloc(1, sizeof *llist);\n        retval = (struct lys_node *)llist;\n        break;\n\n    case LYS_LIST:\n        list = calloc(1, sizeof *list);\n        retval = (struct lys_node *)list;\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        any = calloc(1, sizeof *any);\n        retval = (struct lys_node *)any;\n        break;\n\n    case LYS_USES:\n        uses = calloc(1, sizeof *uses);\n        retval = (struct lys_node *)uses;\n        break;\n\n    case LYS_CASE:\n        cs = calloc(1, sizeof *cs);\n        retval = (struct lys_node *)cs;\n        break;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n        rpc = calloc(1, sizeof *rpc);\n        retval = (struct lys_node *)rpc;\n        break;\n\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        io = calloc(1, sizeof *io);\n        retval = (struct lys_node *)io;\n        break;\n\n    case LYS_NOTIF:\n        ntf = calloc(1, sizeof *ntf);\n        retval = (struct lys_node *)ntf;\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);\n\n    /*\n     * duplicate generic part of the structure\n     */\n    retval->name = lydict_insert(ctx, node->name, 0);\n    retval->dsc = lydict_insert(ctx, node->dsc, 0);\n    retval->ref = lydict_insert(ctx, node->ref, 0);\n    retval->flags = node->flags;\n\n    retval->module = module;\n    retval->nodetype = node->nodetype;\n\n    retval->prev = retval;\n\n    /* copying unresolved extensions is not supported */\n    if (unres_schema_find(unres, -1, (void *)&node->ext, UNRES_EXT) == -1) {\n        retval->ext_size = node->ext_size;\n        if (lys_ext_dup(ctx, module, node->ext, node->ext_size, retval, LYEXT_PAR_NODE, &retval->ext, shallow, unres)) {\n            goto error;\n        }\n    }\n\n    if (node->iffeature_size) {\n        retval->iffeature_size = node->iffeature_size;\n        retval->iffeature = calloc(retval->iffeature_size, sizeof *retval->iffeature);\n        LY_CHECK_ERR_GOTO(!retval->iffeature, LOGMEM(ctx), error);\n    }\n\n    if (!shallow) {\n        for (i = 0; i < node->iffeature_size; ++i) {\n            resolve_iffeature_getsizes(&node->iffeature[i], &size1, &size2);\n            if (size1) {\n                /* there is something to duplicate */\n\n                /* duplicate compiled expression */\n                size = (size1 / 4) + (size1 % 4) ? 1 : 0;\n                retval->iffeature[i].expr = malloc(size * sizeof *retval->iffeature[i].expr);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].expr, LOGMEM(ctx), error);\n                memcpy(retval->iffeature[i].expr, node->iffeature[i].expr, size * sizeof *retval->iffeature[i].expr);\n\n                /* list of feature pointer must be updated to point to the resulting tree */\n                retval->iffeature[i].features = calloc(size2, sizeof *retval->iffeature[i].features);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].features, LOGMEM(ctx); free(retval->iffeature[i].expr), error);\n\n                for (j = 0; (unsigned int)j < size2; j++) {\n                    rc = unres_schema_dup(module, unres, &node->iffeature[i].features[j], UNRES_IFFEAT,\n                                          &retval->iffeature[i].features[j]);\n                    if (rc == EXIT_FAILURE) {\n                        /* feature is resolved in origin, so copy it\n                         * - duplication is used for instantiating groupings\n                         * and if-feature inside grouping is supposed to be\n                         * resolved inside the original grouping, so we want\n                         * to keep pointers to features from the grouping\n                         * context */\n                        retval->iffeature[i].features[j] = node->iffeature[i].features[j];\n                    } else if (rc == -1) {\n                        goto error;\n                    } /* else unres was duplicated */\n                }\n            }\n\n            /* duplicate if-feature's extensions */\n            retval->iffeature[i].ext_size = node->iffeature[i].ext_size;\n            if (lys_ext_dup(ctx, module, node->iffeature[i].ext, node->iffeature[i].ext_size,\n                            &retval->iffeature[i], LYEXT_PAR_IFFEATURE, &retval->iffeature[i].ext, shallow, unres)) {\n                goto error;\n            }\n        }\n\n        /* inherit config flags */\n        p = parent;\n        do {\n            for (iter = p; iter && (iter->nodetype == LYS_USES); iter = iter->parent);\n        } while (iter && iter->nodetype == LYS_AUGMENT && (p = lys_parent(iter)));\n        if (iter) {\n            flags = iter->flags & LYS_CONFIG_MASK;\n        } else {\n            /* default */\n            flags = LYS_CONFIG_W;\n        }\n\n        switch (finalize) {\n        case 1:\n            /* inherit config flags */\n            if (retval->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (retval->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    goto error;\n                }\n                break;\n            }\n\n            if (retval->nodetype != LYS_USES) {\n                retval->flags = (retval->flags & ~LYS_CONFIG_MASK) | flags;\n            }\n\n            /* inherit status */\n            if ((parent->flags & LYS_STATUS_MASK) > (retval->flags & LYS_STATUS_MASK)) {\n                /* but do it only in case the parent has a stonger status */\n                retval->flags &= ~LYS_STATUS_MASK;\n                retval->flags |= (parent->flags & LYS_STATUS_MASK);\n            }\n            break;\n        case 2:\n            /* erase config flags */\n            retval->flags &= ~LYS_CONFIG_MASK;\n            retval->flags &= ~LYS_CONFIG_SET;\n            break;\n        }\n\n        /* connect it to the parent */\n        if (lys_node_addchild(parent, retval->module, retval, 0)) {\n            goto error;\n        }\n\n        /* go recursively */\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            LY_TREE_FOR(node->child, iter) {\n                if (iter->nodetype & LYS_GROUPING) {\n                    /* do not instantiate groupings */\n                    continue;\n                }\n                if (!lys_node_dup_recursion(module, retval, iter, unres, 0, finalize)) {\n                    goto error;\n                }\n            }\n        }\n\n        if (finalize == 1) {\n            /* check that configuration lists have keys\n             * - we really want to check keys_size in original node, because the keys are\n             * not yet resolved here, it is done below in nodetype specific part */\n            if ((retval->nodetype == LYS_LIST) && (retval->flags & LYS_CONFIG_W)\n                    && !((struct lys_node_list *)node)->keys_size) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n                goto error;\n            }\n        }\n    } else {\n        memcpy(retval->iffeature, node->iffeature, retval->iffeature_size * sizeof *retval->iffeature);\n    }\n\n    /*\n     * duplicate specific part of the structure\n     */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        if (cont_orig->when) {\n            cont->when = lys_when_dup(module, cont_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cont->when, error);\n        }\n        cont->presence = lydict_insert(ctx, cont_orig->presence, 0);\n\n        if (cont_orig->must) {\n            cont->must = lys_restr_dup(module, cont_orig->must, cont_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!cont->must, error);\n            cont->must_size = cont_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        break;\n    case LYS_CHOICE:\n        if (choice_orig->when) {\n            choice->when = lys_when_dup(module, choice_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!choice->when, error);\n        }\n\n        if (!shallow) {\n            if (choice_orig->dflt) {\n                rc = lys_get_sibling(choice->child, lys_node_module(retval)->name, 0, choice_orig->dflt->name, 0,\n                                            LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST,\n                                            (const struct lys_node **)&choice->dflt);\n                if (rc) {\n                    if (rc == EXIT_FAILURE) {\n                        LOGINT(ctx);\n                    }\n                    goto error;\n                }\n            } else {\n                /* useless to check return value, we don't know whether\n                * there really wasn't any default defined or it just hasn't\n                * been resolved, we just hope for the best :)\n                */\n                unres_schema_dup(module, unres, choice_orig, UNRES_CHOICE_DFLT, choice);\n            }\n        } else {\n            choice->dflt = choice_orig->dflt;\n        }\n        break;\n\n    case LYS_LEAF:\n        if (lys_type_dup(module, retval, &(leaf->type), &(leaf_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        leaf->units = lydict_insert(module->ctx, leaf_orig->units, 0);\n\n        if (leaf_orig->dflt) {\n            leaf->dflt = lydict_insert(ctx, leaf_orig->dflt, 0);\n        }\n\n        if (leaf_orig->must) {\n            leaf->must = lys_restr_dup(module, leaf_orig->must, leaf_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!leaf->must, error);\n            leaf->must_size = leaf_orig->must_size;\n        }\n\n        if (leaf_orig->when) {\n            leaf->when = lys_when_dup(module, leaf_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!leaf->when, error);\n        }\n        break;\n\n    case LYS_LEAFLIST:\n        if (lys_type_dup(module, retval, &(llist->type), &(llist_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        llist->units = lydict_insert(module->ctx, llist_orig->units, 0);\n\n        llist->min = llist_orig->min;\n        llist->max = llist_orig->max;\n\n        if (llist_orig->must) {\n            llist->must = lys_restr_dup(module, llist_orig->must, llist_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!llist->must, error);\n            llist->must_size = llist_orig->must_size;\n        }\n\n        if (llist_orig->dflt) {\n            llist->dflt = malloc(llist_orig->dflt_size * sizeof *llist->dflt);\n            LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n            llist->dflt_size = llist_orig->dflt_size;\n\n            for (i = 0; i < llist->dflt_size; i++) {\n                llist->dflt[i] = lydict_insert(ctx, llist_orig->dflt[i], 0);\n            }\n        }\n\n        if (llist_orig->when) {\n            llist->when = lys_when_dup(module, llist_orig->when, shallow, unres);\n        }\n        break;\n\n    case LYS_LIST:\n        list->min = list_orig->min;\n        list->max = list_orig->max;\n\n        if (list_orig->must) {\n            list->must = lys_restr_dup(module, list_orig->must, list_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!list->must, error);\n            list->must_size = list_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        if (list_orig->keys_size) {\n            list->keys = calloc(list_orig->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n            list->keys_str = lydict_insert(ctx, list_orig->keys_str, 0);\n            list->keys_size = list_orig->keys_size;\n\n            if (!shallow) {\n                if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n                    goto error;\n                }\n            } else {\n                memcpy(list->keys, list_orig->keys, list_orig->keys_size * sizeof *list->keys);\n            }\n        }\n\n        if (list_orig->unique) {\n            list->unique = malloc(list_orig->unique_size * sizeof *list->unique);\n            LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n            list->unique_size = list_orig->unique_size;\n\n            for (i = 0; i < list->unique_size; ++i) {\n                list->unique[i].expr = malloc(list_orig->unique[i].expr_size * sizeof *list->unique[i].expr);\n                LY_CHECK_ERR_GOTO(!list->unique[i].expr, LOGMEM(ctx), error);\n                list->unique[i].expr_size = list_orig->unique[i].expr_size;\n                for (j = 0; j < list->unique[i].expr_size; j++) {\n                    list->unique[i].expr[j] = lydict_insert(ctx, list_orig->unique[i].expr[j], 0);\n\n                    /* if it stays in unres list, duplicate it also there */\n                    unique_info = malloc(sizeof *unique_info);\n                    LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);\n                    unique_info->list = (struct lys_node *)list;\n                    unique_info->expr = list->unique[i].expr[j];\n                    unique_info->trg_type = &list->unique[i].trg_type;\n                    unres_schema_dup(module, unres, &list_orig, UNRES_LIST_UNIQ, unique_info);\n                }\n            }\n        }\n\n        if (list_orig->when) {\n            list->when = lys_when_dup(module, list_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!list->when, error);\n        }\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        if (any_orig->must) {\n            any->must = lys_restr_dup(module, any_orig->must, any_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!any->must, error);\n            any->must_size = any_orig->must_size;\n        }\n\n        if (any_orig->when) {\n            any->when = lys_when_dup(module, any_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!any->when, error);\n        }\n        break;\n\n    case LYS_USES:\n        uses->grp = uses_orig->grp;\n\n        if (uses_orig->when) {\n            uses->when = lys_when_dup(module, uses_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!uses->when, error);\n        }\n        /* it is not needed to duplicate refine, nor augment. They are already applied to the uses children */\n        break;\n\n    case LYS_CASE:\n        if (cs_orig->when) {\n            cs->when = lys_when_dup(module, cs_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cs->when, error);\n        }\n        break;\n\n    case LYS_ACTION:\n    case LYS_RPC:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n        break;\n\n    default:\n        /* LY_NODE_AUGMENT */\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(retval, NULL, 0);\n    return NULL;\n}\n\nint\nlys_has_xpath(const struct lys_node *node)\n{\n    assert(node);\n\n    switch (node->nodetype) {\n    case LYS_AUGMENT:\n        if (((struct lys_node_augment *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CASE:\n        if (((struct lys_node_case *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CHOICE:\n        if (((struct lys_node_choice *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_ANYDATA:\n        if (((struct lys_node_anydata *)node)->when || ((struct lys_node_anydata *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAF:\n        if (((struct lys_node_leaf *)node)->when || ((struct lys_node_leaf *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAFLIST:\n        if (((struct lys_node_leaflist *)node)->when || ((struct lys_node_leaflist *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node)->when || ((struct lys_node_list *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_CONTAINER:\n        if (((struct lys_node_container *)node)->when || ((struct lys_node_container *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (((struct lys_node_inout *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_NOTIF:\n        if (((struct lys_node_notif *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_USES:\n        if (((struct lys_node_uses *)node)->when) {\n            return 1;\n        }\n        break;\n    default:\n        /* does not have XPath */\n        break;\n    }\n\n    return 0;\n}\n\nint\nlys_type_is_local(const struct lys_type *type)\n{\n    if (!type->der->module) {\n        /* build-in type */\n        return 1;\n    }\n    /* type->parent can be either a typedef or leaf/leaf-list, but module pointers are compatible */\n    return (lys_main_module(type->der->module) == lys_main_module(((struct lys_tpdf *)type->parent)->module));\n}\n\n/*\n * shallow -\n *         - do not inherit status from the parent\n */\nstruct lys_node *\nlys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n             struct unres_schema *unres, int shallow)\n{\n    struct lys_node *p = NULL;\n    int finalize = 0;\n    struct lys_node *result, *iter, *next;\n\n    if (!shallow) {\n        /* get know where in schema tree we are to know what should be done during instantiation of the grouping */\n        for (p = parent;\n             p && !(p->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC | LYS_ACTION | LYS_GROUPING));\n             p = lys_parent(p));\n        finalize = p ? ((p->nodetype == LYS_GROUPING) ? 0 : 2) : 1;\n    }\n\n    result = lys_node_dup_recursion(module, parent, node, unres, shallow, finalize);\n    if (finalize) {\n        /* check xpath expressions in the instantiated tree */\n        for (iter = next = result; iter; iter = next) {\n            if (lys_has_xpath(iter) && unres_schema_add_node(module, unres, iter, UNRES_XPATH, NULL) == -1) {\n                /* invalid xpath */\n                return NULL;\n            }\n\n            /* select next item */\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA | LYS_GROUPING)) {\n                /* child exception for leafs, leaflists and anyxml without children, ignore groupings */\n                next = NULL;\n            } else {\n                next = iter->child;\n            }\n            if (!next) {\n                /* no children, try siblings */\n                if (iter == result) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                iter = lys_parent(iter);\n                if (lys_parent(iter) == lys_parent(result)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @brief Switch contents of two same schema nodes. One of the nodes\n * is expected to be ashallow copy of the other.\n *\n * @param[in] node1 Node whose contents will be switched with \\p node2.\n * @param[in] node2 Node whose contents will be switched with \\p node1.\n */\nstatic void\nlys_node_switch(struct lys_node *node1, struct lys_node *node2)\n{\n    const size_t mem_size = 104;\n    uint8_t mem[mem_size];\n    size_t offset, size;\n\n    assert((node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype));\n\n    /*\n     * Initially, the nodes were really switched in the tree which\n     * caused problems for some other nodes with pointers (augments, leafrefs, ...)\n     * because their pointers were not being updated. Code kept in case there is\n     * a use of it in future (it took some debugging to cover all the cases).\n\n    * sibling next *\n    if (node1->prev->next) {\n        node1->prev->next = node2;\n    }\n\n    * sibling prev *\n    if (node1->next) {\n        node1->next->prev = node2;\n    } else {\n        for (child = node1->prev; child->prev->next; child = child->prev);\n        child->prev = node2;\n    }\n\n    * next *\n    node2->next = node1->next;\n    node1->next = NULL;\n\n    * prev *\n    if (node1->prev != node1) {\n        node2->prev = node1->prev;\n    }\n    node1->prev = node1;\n\n    * parent child *\n    if (node1->parent) {\n        if (node1->parent->child == node1) {\n            node1->parent->child = node2;\n        }\n    } else if (lys_main_module(node1->module)->data == node1) {\n        lys_main_module(node1->module)->data = node2;\n    }\n\n    * parent *\n    node2->parent = node1->parent;\n    node1->parent = NULL;\n\n    * child parent *\n    LY_TREE_FOR(node1->child, child) {\n        if (child->parent == node1) {\n            child->parent = node2;\n        }\n    }\n\n    * child *\n    node2->child = node1->child;\n    node1->child = NULL;\n    */\n\n    /* switch common node part */\n    offset = 3 * sizeof(char *);\n    size = sizeof(uint16_t) + 6 * sizeof(uint8_t) + sizeof(struct lys_ext_instance **) + sizeof(struct lys_iffeature *);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* switch node-specific data */\n    offset = sizeof(struct lys_node);\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        size = sizeof(struct lys_node_container) - offset;\n        break;\n    case LYS_CHOICE:\n        size = sizeof(struct lys_node_choice) - offset;\n        break;\n    case LYS_LEAF:\n        size = sizeof(struct lys_node_leaf) - offset;\n        break;\n    case LYS_LEAFLIST:\n        size = sizeof(struct lys_node_leaflist) - offset;\n        break;\n    case LYS_LIST:\n        size = sizeof(struct lys_node_list) - offset;\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        size = sizeof(struct lys_node_anydata) - offset;\n        break;\n    case LYS_CASE:\n        size = sizeof(struct lys_node_case) - offset;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        size = sizeof(struct lys_node_inout) - offset;\n        break;\n    case LYS_NOTIF:\n        size = sizeof(struct lys_node_notif) - offset;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        size = sizeof(struct lys_node_rpc_action) - offset;\n        break;\n    default:\n        assert(0);\n        LOGINT(node1->module->ctx);\n        return;\n    }\n    assert(size <= mem_size);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* typedefs were not copied to the backup node, so always reuse them,\n     * in leaves/leaf-lists we must correct the type parent pointer */\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        ((struct lys_node_container *)node1)->tpdf_size = ((struct lys_node_container *)node2)->tpdf_size;\n        ((struct lys_node_container *)node1)->tpdf = ((struct lys_node_container *)node2)->tpdf;\n        ((struct lys_node_container *)node2)->tpdf_size = 0;\n        ((struct lys_node_container *)node2)->tpdf = NULL;\n        break;\n    case LYS_LIST:\n        ((struct lys_node_list *)node1)->tpdf_size = ((struct lys_node_list *)node2)->tpdf_size;\n        ((struct lys_node_list *)node1)->tpdf = ((struct lys_node_list *)node2)->tpdf;\n        ((struct lys_node_list *)node2)->tpdf_size = 0;\n        ((struct lys_node_list *)node2)->tpdf = NULL;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        ((struct lys_node_rpc_action *)node1)->tpdf_size = ((struct lys_node_rpc_action *)node2)->tpdf_size;\n        ((struct lys_node_rpc_action *)node1)->tpdf = ((struct lys_node_rpc_action *)node2)->tpdf;\n        ((struct lys_node_rpc_action *)node2)->tpdf_size = 0;\n        ((struct lys_node_rpc_action *)node2)->tpdf = NULL;\n        break;\n    case LYS_NOTIF:\n        ((struct lys_node_notif *)node1)->tpdf_size = ((struct lys_node_notif *)node2)->tpdf_size;\n        ((struct lys_node_notif *)node1)->tpdf = ((struct lys_node_notif *)node2)->tpdf;\n        ((struct lys_node_notif *)node2)->tpdf_size = 0;\n        ((struct lys_node_notif *)node2)->tpdf = NULL;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        ((struct lys_node_inout *)node1)->tpdf_size = ((struct lys_node_inout *)node2)->tpdf_size;\n        ((struct lys_node_inout *)node1)->tpdf = ((struct lys_node_inout *)node2)->tpdf;\n        ((struct lys_node_inout *)node2)->tpdf_size = 0;\n        ((struct lys_node_inout *)node2)->tpdf = NULL;\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        ((struct lys_node_leaf *)node1)->type.parent = (struct lys_tpdf *)node1;\n        ((struct lys_node_leaf *)node2)->type.parent = (struct lys_tpdf *)node2;\n    default:\n        break;\n    }\n}\n\nvoid\nlys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv), int free_subs, int remove_from_ctx)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!module) {\n        return;\n    }\n\n    /* remove schema from the context */\n    ctx = module->ctx;\n    if (remove_from_ctx && ctx->models.used) {\n        for (i = 0; i < ctx->models.used; i++) {\n            if (ctx->models.list[i] == module) {\n                /* move all the models to not change the order in the list */\n                ctx->models.used--;\n                memmove(&ctx->models.list[i], ctx->models.list[i + 1], (ctx->models.used - i) * sizeof *ctx->models.list);\n                ctx->models.list[ctx->models.used] = NULL;\n                /* we are done */\n                break;\n            }\n        }\n    }\n\n    /* common part with struct ly_submodule */\n    module_free_common(module, private_destructor);\n\n    /* include */\n    for (i = 0; i < module->inc_size; i++) {\n        lydict_remove(ctx, module->inc[i].dsc);\n        lydict_remove(ctx, module->inc[i].ref);\n        lys_extension_instances_free(ctx, module->inc[i].ext, module->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n        if (free_subs) {\n            lys_submodule_free(module->inc[i].submodule, private_destructor);\n        }\n    }\n    free(module->inc);\n\n    /* specific items to free */\n    lydict_remove(ctx, module->ns);\n\n    free(module);\n}\n\nstatic void\nlys_features_disable_recursive(struct lys_feature *f)\n{\n    unsigned int i;\n    struct lys_feature *depf;\n\n    /* disable the feature */\n    f->flags &= ~LYS_FENABLED;\n\n    /* by disabling feature we have to disable also all features that depends on this feature */\n    if (f->depfeatures) {\n        for (i = 0; i < f->depfeatures->number; i++) {\n            depf = (struct lys_feature *)f->depfeatures->set.g[i];\n            if (depf->flags & LYS_FENABLED) {\n                lys_features_disable_recursive(depf);\n            }\n        }\n    }\n}\n\n/*\n * op: 1 - enable, 0 - disable\n */\nstatic int\nlys_features_change(const struct lys_module *module, const char *name, int op)\n{\n    int all = 0;\n    int i, j, k;\n    int progress, faili, failj, failk;\n\n    uint8_t fsize;\n    struct lys_feature *f;\n\n    if (!module || !name || !strlen(name)) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!strcmp(name, \"*\")) {\n        /* enable all */\n        all = 1;\n    }\n\n    progress = failk = 1;\n    while (progress && failk) {\n        for (i = -1, failk = progress = 0; i < module->inc_size; i++) {\n            if (i == -1) {\n                fsize = module->features_size;\n                f = module->features;\n            } else {\n                fsize = module->inc[i].submodule->features_size;\n                f = module->inc[i].submodule->features;\n            }\n\n            for (j = 0; j < fsize; j++) {\n                if (all || !strcmp(f[j].name, name)) {\n                    if ((op && (f[j].flags & LYS_FENABLED)) || (!op && !(f[j].flags & LYS_FENABLED))) {\n                        if (all) {\n                            /* skip already set features */\n                            continue;\n                        } else {\n                            /* feature already set correctly */\n                            return EXIT_SUCCESS;\n                        }\n                    }\n\n                    if (op) {\n                        /* check referenced features if they are enabled */\n                        for (k = 0; k < f[j].iffeature_size; k++) {\n                            if (!resolve_iffeature(&f[j].iffeature[k])) {\n                                if (all) {\n                                    faili = i;\n                                    failj = j;\n                                    failk = k + 1;\n                                    break;\n                                } else {\n                                    LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                           f[j].name, k + 1);\n                                    return EXIT_FAILURE;\n                                }\n                            }\n                        }\n\n                        if (k == f[j].iffeature_size) {\n                            /* the last check passed, do the change */\n                            f[j].flags |= LYS_FENABLED;\n                            progress++;\n                        }\n                    } else {\n                        lys_features_disable_recursive(&f[j]);\n                        progress++;\n                    }\n                    if (!all) {\n                        /* stop in case changing a single feature */\n                        return EXIT_SUCCESS;\n                    }\n                }\n            }\n        }\n    }\n    if (failk) {\n        /* print info about the last failing feature */\n        LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n               faili == -1 ? module->features[failj].name : module->inc[faili].submodule->features[failj].name, failk);\n        return EXIT_FAILURE;\n    }\n\n    if (all) {\n        return EXIT_SUCCESS;\n    } else {\n        /* the specified feature not found */\n        return EXIT_FAILURE;\n    }\n}\n\nAPI int\nlys_features_enable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 1);\n}\n\nAPI int\nlys_features_disable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 0);\n}\n\nAPI int\nlys_features_state(const struct lys_module *module, const char *feature)\n{\n    int i, j;\n\n    if (!module || !feature) {\n        return -1;\n    }\n\n    /* search for the specified feature */\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(feature, module->features[i].name)) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            if (!strcmp(feature, module->inc[j].submodule->features[i].name)) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    /* feature definition not found */\n    return -1;\n}\n\nAPI const char **\nlys_features_list(const struct lys_module *module, uint8_t **states)\n{\n    const char **result = NULL;\n    int i, j;\n    unsigned int count;\n\n    if (!module) {\n        return NULL;\n    }\n\n    count = module->features_size;\n    for (i = 0; i < module->inc_size; i++) {\n        count += module->inc[i].submodule->features_size;\n    }\n    result = malloc((count + 1) * sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(module->ctx), NULL);\n\n    if (states) {\n        *states = malloc((count + 1) * sizeof **states);\n        LY_CHECK_ERR_RETURN(!(*states), LOGMEM(module->ctx); free(result), NULL);\n    }\n    count = 0;\n\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        result[count] = module->features[i].name;\n        if (states) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                (*states)[count] = 1;\n            } else {\n                (*states)[count] = 0;\n            }\n        }\n        count++;\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            result[count] = module->inc[j].submodule->features[i].name;\n            if (states) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    (*states)[count] = 1;\n                } else {\n                    (*states)[count] = 0;\n                }\n            }\n            count++;\n        }\n    }\n\n    /* terminating NULL byte */\n    result[count] = NULL;\n\n    return result;\n}\n\nAPI struct lys_module *\nlys_node_module(const struct lys_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->module->type ? ((struct lys_submodule *)node->module)->belongsto : node->module;\n}\n\nAPI struct lys_module *\nlys_main_module(const struct lys_module *module)\n{\n    if (!module) {\n        return NULL;\n    }\n\n    return (module->type ? ((struct lys_submodule *)module)->belongsto : (struct lys_module *)module);\n}\n\nAPI struct lys_node *\nlys_parent(const struct lys_node *node)\n{\n    struct lys_node *parent;\n\n    if (!node) {\n        return NULL;\n    }\n\n    if (node->nodetype == LYS_EXT) {\n        if (((struct lys_ext_instance_complex*)node)->parent_type != LYEXT_PAR_NODE) {\n            return NULL;\n        }\n        parent = (struct lys_node*)((struct lys_ext_instance_complex*)node)->parent;\n    } else if (!node->parent) {\n        return NULL;\n    } else {\n        parent = node->parent;\n    }\n\n    if (parent->nodetype == LYS_AUGMENT) {\n        return ((struct lys_node_augment *)parent)->target;\n    } else {\n        return parent;\n    }\n}\n\nstruct lys_node **\nlys_child(const struct lys_node *node, LYS_NODE nodetype)\n{\n    void *pp;\n    assert(node);\n\n    if (node->nodetype == LYS_EXT) {\n        pp = lys_ext_complex_get_substmt(lys_snode2stmt(nodetype), (struct lys_ext_instance_complex*)node, NULL);\n        if (!pp) {\n            return NULL;\n        }\n        return (struct lys_node **)pp;\n    } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n        return NULL;\n    } else {\n        return (struct lys_node **)&node->child;\n    }\n}\n\nAPI void *\nlys_set_private(const struct lys_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lys_node *)node)->priv = priv;\n\n    return prev;\n}\n\nint\nlys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref)\n{\n    struct lys_node_leaf *iter;\n    struct ly_ctx *ctx = leafref_target->module->ctx;\n\n    if (!(leafref_target->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGINT(ctx);\n        return -1;\n    }\n\n    /* check for config flag */\n    if (((struct lys_node_leaf*)leafref)->type.info.lref.req != -1 &&\n            (leafref->flags & LYS_CONFIG_W) && (leafref_target->flags & LYS_CONFIG_R)) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, leafref,\n               \"The leafref %s is config but refers to a non-config %s.\",\n               strnodetype(leafref->nodetype), strnodetype(leafref_target->nodetype));\n        return -1;\n    }\n    /* check for cycles */\n    for (iter = leafref_target; iter && iter->type.base == LY_TYPE_LEAFREF; iter = iter->type.info.lref.target) {\n        if ((void *)iter == (void *)leafref) {\n            /* cycle detected */\n            LOGVAL(ctx, LYE_CIRC_LEAFREFS, LY_VLOG_LYS, leafref);\n            return -1;\n        }\n    }\n\n    /* create fake child - the ly_set structure to hold the list of\n     * leafrefs referencing the leaf(-list) */\n    if (!leafref_target->backlinks) {\n        leafref_target->backlinks = (void *)ly_set_new();\n        if (!leafref_target->backlinks) {\n            LOGMEM(ctx);\n            return -1;\n        }\n    }\n    ly_set_add(leafref_target->backlinks, leafref, 0);\n\n    return 0;\n}\n\n/* not needed currently */\n#if 0\n\nstatic const char *\nlys_data_path_reverse(const struct lys_node *node, char * const buf, uint32_t buf_len)\n{\n    struct lys_module *prev_mod;\n    uint32_t str_len, mod_len, buf_idx;\n\n    if (!(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGINT;\n        return NULL;\n    }\n\n    buf_idx = buf_len - 1;\n    buf[buf_idx] = '\\0';\n\n    while (node) {\n        if (lys_parent(node)) {\n            prev_mod = lys_node_module(lys_parent(node));\n        } else {\n            prev_mod = NULL;\n        }\n\n        if (node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            str_len = strlen(node->name);\n\n            if (prev_mod != node->module) {\n                mod_len = strlen(node->module->name);\n            } else {\n                mod_len = 0;\n            }\n\n            if (buf_idx < 1 + (mod_len ? mod_len + 1 : 0) + str_len) {\n                LOGINT;\n                return NULL;\n            }\n\n            buf_idx -= 1 + (mod_len ? mod_len + 1 : 0) + str_len;\n\n            buf[buf_idx] = '/';\n            if (mod_len) {\n                memcpy(buf + buf_idx + 1, node->module->name, mod_len);\n                buf[buf_idx + 1 + mod_len] = ':';\n            }\n            memcpy(buf + buf_idx + 1 + (mod_len ? mod_len + 1 : 0), node->name, str_len);\n        }\n\n        node = lys_parent(node);\n    }\n\n    return buf + buf_idx;\n}\n\n#endif\n\nAPI struct ly_set *\nlys_xpath_atomize(const struct lys_node *ctx_node, enum lyxp_node_type ctx_node_type, const char *expr, int options)\n{\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint32_t i;\n\n    if (!ctx_node || !expr) {\n        LOGARG;\n        return NULL;\n    }\n\n    /* adjust the root */\n    if ((ctx_node_type == LYXP_NODE_ROOT) || (ctx_node_type == LYXP_NODE_ROOT_CONFIG)) {\n        do {\n            ctx_node = lys_getnext(NULL, NULL, lys_node_module(ctx_node), LYS_GETNEXT_NOSTATECHECK);\n        } while ((ctx_node_type == LYXP_NODE_ROOT_CONFIG) && (ctx_node->flags & LYS_CONFIG_R));\n    }\n\n    memset(&set, 0, sizeof set);\n\n    if (options & LYXP_MUST) {\n        options &= ~LYXP_MUST;\n        options |= LYXP_SNODE_MUST;\n    } else if (options & LYXP_WHEN) {\n        options &= ~LYXP_WHEN;\n        options |= LYXP_SNODE_WHEN;\n    } else {\n        options |= LYXP_SNODE;\n    }\n\n    if (lyxp_atomize(expr, ctx_node, ctx_node_type, &set, options, NULL)) {\n        free(set.val.snodes);\n        LOGVAL(ctx_node->module->ctx, LYE_SPEC, LY_VLOG_LYS, ctx_node, \"Resolving XPath expression \\\"%s\\\" failed.\", expr);\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n\n    for (i = 0; i < set.used; ++i) {\n        switch (set.val.snodes[i].type) {\n        case LYXP_NODE_ELEM:\n            if (ly_set_add(ret_set, set.val.snodes[i].snode, LY_SET_OPT_USEASLIST) == -1) {\n                ly_set_free(ret_set);\n                free(set.val.snodes);\n                return NULL;\n            }\n            break;\n        default:\n            /* ignore roots, text and attr should not ever appear */\n            break;\n        }\n    }\n\n    free(set.val.snodes);\n    return ret_set;\n}\n\nAPI struct ly_set *\nlys_node_xpath_atomize(const struct lys_node *node, int options)\n{\n    const struct lys_node *next, *elem, *parent, *tmp;\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    for (parent = node; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n    if (!parent) {\n        /* not in input, output, or notification */\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n    if (!ret_set) {\n        return NULL;\n    }\n\n    LY_TREE_DFS_BEGIN(node, next, elem) {\n        if ((options & LYXP_NO_LOCAL) && !(elem->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))) {\n            /* elem has no dependencies from other subtrees and local nodes get discarded */\n            goto next_iter;\n        }\n\n        if (lyxp_node_atomize(elem, &set, 0)) {\n            ly_set_free(ret_set);\n            free(set.val.snodes);\n            return NULL;\n        }\n\n        for (i = 0; i < set.used; ++i) {\n            switch (set.val.snodes[i].type) {\n            case LYXP_NODE_ELEM:\n                if (options & LYXP_NO_LOCAL) {\n                    for (tmp = set.val.snodes[i].snode; tmp && (tmp != parent); tmp = lys_parent(tmp));\n                    if (tmp) {\n                        /* in local subtree, discard */\n                        break;\n                    }\n                }\n                if (ly_set_add(ret_set, set.val.snodes[i].snode, 0) == -1) {\n                    ly_set_free(ret_set);\n                    free(set.val.snodes);\n                    return NULL;\n                }\n                break;\n            default:\n                /* ignore roots, text and attr should not ever appear */\n                break;\n            }\n        }\n\n        free(set.val.snodes);\n        if (!(options & LYXP_RECURSIVE)) {\n            break;\n        }\nnext_iter:\n        LY_TREE_DFS_END(node, next, elem);\n    }\n\n    return ret_set;\n}\n\n/* logs */\nint\napply_aug(struct lys_node_augment *augment, struct unres_schema *unres)\n{\n    struct lys_node *child, *parent;\n    int clear_config;\n    unsigned int u;\n    uint8_t *v;\n    struct lys_ext_instance *ext;\n\n    assert(augment->target && (augment->flags & LYS_NOTAPPLIED));\n\n    if (!augment->child) {\n        /* nothing to apply */\n        goto success;\n    }\n\n    /* inherit config information from actual parent */\n    for (parent = augment->target; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); parent = lys_parent(parent));\n    clear_config = (parent) ? 1 : 0;\n    LY_TREE_FOR(augment->child, child) {\n        if (inherit_config_flag(child, augment->target->flags & LYS_CONFIG_MASK, clear_config)) {\n            return -1;\n        }\n    }\n\n    /* inherit extensions if any */\n    for (u = 0; u < augment->target->ext_size; u++) {\n        ext = augment->target->ext[u]; /* shortcut */\n        if (ext && ext->def->plugin && (ext->def->plugin->flags & LYEXT_OPT_INHERIT)) {\n            v = malloc(sizeof *v);\n            LY_CHECK_ERR_RETURN(!v, LOGMEM(augment->module->ctx), -1);\n            *v = u;\n            if (unres_schema_add_node(lys_main_module(augment->module), unres, &augment->target->ext,\n                    UNRES_EXT_FINALIZE, (struct lys_node *)v) == -1) {\n                /* something really bad happend since the extension finalization is not actually\n                 * being resolved while adding into unres, so something more serious with the unres\n                 * list itself must happened */\n                return -1;\n            }\n        }\n    }\n\n    /* reconnect augmenting data into the target - add them to the target child list */\n    if (augment->target->child) {\n        child = augment->target->child->prev;\n        child->next = augment->child;\n        augment->target->child->prev = augment->child->prev;\n        augment->child->prev = child;\n    } else {\n        augment->target->child = augment->child;\n    }\n\nsuccess:\n    /* remove the flag about not applicability */\n    augment->flags &= ~LYS_NOTAPPLIED;\n    return EXIT_SUCCESS;\n}\n\nstatic void\nremove_aug(struct lys_node_augment *augment)\n{\n    struct lys_node *last, *elem;\n\n    if ((augment->flags & LYS_NOTAPPLIED) || !augment->target) {\n        /* skip already not applied augment */\n        return;\n    }\n\n    elem = augment->child;\n    if (elem) {\n        LY_TREE_FOR(elem, last) {\n            if (!last->next || (last->next->parent != (struct lys_node *)augment)) {\n                break;\n            }\n        }\n        /* elem is first augment child, last is the last child */\n\n        /* parent child ptr */\n        if (augment->target->child == elem) {\n            augment->target->child = last->next;\n        }\n\n        /* parent child next ptr */\n        if (elem->prev->next) {\n            elem->prev->next = last->next;\n        }\n\n        /* parent child prev ptr */\n        if (last->next) {\n            last->next->prev = elem->prev;\n        } else if (augment->target->child) {\n            augment->target->child->prev = elem->prev;\n        }\n\n        /* update augment children themselves */\n        elem->prev = last;\n        last->next = NULL;\n    }\n\n    /* augment->target still keeps the resolved target, but for lys_augment_free()\n     * we have to keep information that this augment is not applied to free its data */\n    augment->flags |= LYS_NOTAPPLIED;\n}\n\n/*\n * @param[in] module - the module where the deviation is defined\n */\nstatic void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct lys_node_inout *inout;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent && (parent->nodetype == LYS_AUGMENT)) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n                        assert(lys_node_module(parent)->implemented);\n                        parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                        apply_aug((struct lys_node_augment *)parent, unres);\n                    }\n                } else if (parent && (parent->nodetype == LYS_USES)) {\n                    /* uses child */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT(module->ctx);\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node, 0);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, lys_node_module(dev->orig_node), dev->orig_node, 0);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT(module->ctx);\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent) {\n                if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                    /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                     * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                     * path), so we need to remember the augment as an addition */\n                    /* we also need to remember the parent uses so that we connect it back to it when switching deviation state */\n                    target->parent = parent;\n                } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                    /* re-create implicit node */\n                    inout = calloc(1, sizeof *inout);\n                    LY_CHECK_ERR_RETURN(!inout, LOGMEM(module->ctx), );\n\n                    inout->nodetype = target->nodetype;\n                    inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                    inout->module = target->module;\n                    inout->flags = LYS_IMPLICIT;\n\n                    /* insert it manually */\n                    assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                    parent->child->next = (struct lys_node *)inout;\n                    inout->prev = parent->child;\n                    parent->child->prev = (struct lys_node *)inout;\n                    inout->parent = parent;\n                }\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT(module->ctx);\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        /* contents are switched */\n        lys_node_switch(target, dev->orig_node);\n    }\n}\n\n/* temporarily removes or applies deviations, updates module deviation flag accordingly */\nvoid\nlys_enable_deviations(struct lys_module *module)\n{\n    uint32_t i = 0, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        while ((mod = ly_ctx_get_module_iter(module->ctx, &i))) {\n            if (mod == module) {\n                continue;\n            }\n\n            for (j = 0; j < mod->deviation_size; ++j) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 2);\n        module->deviated = 1;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nvoid\nlys_disable_deviations(struct lys_module *module)\n{\n    uint32_t i, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        i = module->ctx->models.used;\n        while (i--) {\n            mod = module->ctx->models.list[i];\n\n            if (mod == module) {\n                continue;\n            }\n\n            j = mod->deviation_size;\n            while (j--) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 1);\n        module->deviated = 2;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nstatic void\napply_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    lys_switch_deviation(dev, module, unres);\n\n    assert(dev->orig_node);\n    lys_node_module(dev->orig_node)->deviated = 1; /* main module */\n    dev->orig_node->module->deviated = 1;          /* possible submodule */\n}\n\nstatic void\nremove_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t idx = 0, j;\n    const struct lys_module *mod;\n    struct lys_module *target_mod, *target_submod;\n    const char *ptr;\n\n    if (dev->orig_node) {\n        target_mod = lys_node_module(dev->orig_node);\n        target_submod = dev->orig_node->module;\n    } else {\n        LOGINT(module->ctx);\n        return;\n    }\n    lys_switch_deviation(dev, module, unres);\n\n    /* clear the deviation flag if possible */\n    while ((mod = ly_ctx_get_module_iter(module->ctx, &idx))) {\n        if ((mod == module) || (mod == target_mod)) {\n            continue;\n        }\n\n        for (j = 0; j < mod->deviation_size; ++j) {\n            ptr = strstr(mod->deviation[j].target_name, target_mod->name);\n            if (ptr && (ptr[strlen(target_mod->name)] == ':')) {\n                /* some other module deviation targets the inspected module, flag remains */\n                break;\n            }\n        }\n\n        if (j < mod->deviation_size) {\n            break;\n        }\n    }\n\n    if (!mod) {\n        target_mod->deviated = 0;    /* main module */\n        target_submod->deviated = 0; /* possible submodule */\n    }\n}\n\nvoid\nlys_sub_module_apply_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v;\n    struct unres_schema *unres;\n\n    assert(module->implemented);\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* apply deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        apply_dev(&module->deviation[u], module, unres);\n    }\n    /* apply augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        apply_aug(&module->augment[u], unres);\n    }\n\n    /* apply deviations and augments defined in submodules */\n    for (v = 0; v < module->inc_size; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            apply_dev(&module->inc[v].submodule->deviation[u], module, unres);\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            apply_aug(&module->inc[v].submodule->augment[u], unres);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nvoid\nlys_sub_module_remove_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v, w;\n    struct unres_schema *unres;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* remove applied deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        /* the deviation could not be applied because it failed to be applied in the first place*/\n        if (module->deviation[u].orig_node) {\n            remove_dev(&module->deviation[u], module, unres);\n        }\n\n        /* Free the deviation's must array(s). These are shallow copies of the arrays\n           on the target node(s), so a deep free is not needed. */\n        for (v = 0; v < module->deviation[u].deviate_size; ++v) {\n            if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {\n                free(module->deviation[u].deviate[v].must);\n            }\n        }\n    }\n    /* remove applied augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        remove_aug(&module->augment[u]);\n    }\n\n    /* remove deviation and augments defined in submodules */\n    for (v = 0; v < module->inc_size && module->inc[v].submodule; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            if (module->inc[v].submodule->deviation[u].orig_node) {\n                remove_dev(&module->inc[v].submodule->deviation[u], module, unres);\n            }\n\n            /* Free the deviation's must array(s). These are shallow copies of the arrays\n               on the target node(s), so a deep free is not needed. */\n            for (w = 0; w < module->inc[v].submodule->deviation[u].deviate_size; ++w) {\n                if (module->inc[v].submodule->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {\n                    free(module->inc[v].submodule->deviation[u].deviate[w].must);\n                }\n            }\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            remove_aug(&module->inc[v].submodule->augment[u]);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nint\nlys_make_implemented_r(struct lys_module *module, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *root, *next, *node;\n    struct lys_module *target_module;\n    uint16_t i, j, k;\n\n    assert(module->implemented);\n    ctx = module->ctx;\n\n    for (i = 0; i < ctx->models.used; ++i) {\n        if (module == ctx->models.list[i]) {\n            continue;\n        }\n\n        if (!strcmp(module->name, ctx->models.list[i]->name) && ctx->models.list[i]->implemented) {\n            LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" in another revision already implemented.\", module->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    for (i = 0; i < module->augment_size; i++) {\n\n        /* make target module implemented if was not */\n        assert(module->augment[i].target);\n        target_module = lys_node_module(module->augment[i].target);\n        if (!target_module->implemented) {\n            target_module->implemented = 1;\n            if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                return -1;\n            }\n        }\n\n        /* apply augment */\n        if ((module->augment[i].flags & LYS_NOTAPPLIED) && apply_aug(&module->augment[i], unres)) {\n            return -1;\n        }\n    }\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        for (j = 0; j < module->ident[i].base_size; j++) {\n            resolve_identity_backlink_update(&module->ident[i], module->ident[i].base[j]);\n        }\n    }\n\n    /* process augments in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; ++i) {\n        module->inc[i].submodule->implemented = 1;\n\n        for (j = 0; j < module->inc[i].submodule->augment_size; j++) {\n\n            /* make target module implemented if it was not */\n            assert(module->inc[i].submodule->augment[j].target);\n            target_module = lys_node_module(module->inc[i].submodule->augment[j].target);\n            if (!target_module->implemented) {\n                target_module->implemented = 1;\n                if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n\n            /* apply augment */\n            if ((module->inc[i].submodule->augment[j].flags & LYS_NOTAPPLIED) && apply_aug(&module->inc[i].submodule->augment[j], unres)) {\n                return -1;\n            }\n        }\n\n        /* identities */\n        for (j = 0; j < module->inc[i].submodule->ident_size; j++) {\n            for (k = 0; k < module->inc[i].submodule->ident[j].base_size; k++) {\n                resolve_identity_backlink_update(&module->inc[i].submodule->ident[j],\n                                                 module->inc[i].submodule->ident[j].base[k]);\n            }\n        }\n    }\n\n    LY_TREE_FOR(module->data, root) {\n        /* handle leafrefs and recursively change the implemented flags in the leafref targets */\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_GROUPING) {\n                goto nextsibling;\n            }\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                if (((struct lys_node_leaf *)node)->type.base == LY_TYPE_LEAFREF) {\n                    if (unres_schema_add_node(module, unres, &((struct lys_node_leaf *)node)->type,\n                                              UNRES_TYPE_LEAFREF, node) == -1) {\n                        return -1;\n                    }\n                }\n            }\n\n            /* modified LY_TREE_DFS_END */\n            next = node->child;\n            /* child exception for leafs, leaflists and anyxml without children */\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                next = NULL;\n            }\n            if (!next) {\nnextsibling:\n                /* no children */\n                if (node == root) {\n                    /* we are done, root has no children */\n                    break;\n                }\n                /* try siblings */\n                next = node->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                node = lys_parent(node);\n                /* no siblings, go back through parents */\n                if (lys_parent(node) == lys_parent(root)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = node->next;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlys_set_implemented(const struct lys_module *module)\n{\n    struct unres_schema *unres;\n    int disabled = 0;\n\n    if (!module) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    module = lys_main_module(module);\n\n    if (module->disabled) {\n        disabled = 1;\n        lys_set_enabled(module);\n    }\n\n    if (module->implemented) {\n        return EXIT_SUCCESS;\n    }\n\n    unres = calloc(1, sizeof *unres);\n    if (!unres) {\n        LOGMEM(module->ctx);\n        if (disabled) {\n            /* set it back disabled */\n            lys_set_disabled(module);\n        }\n        return EXIT_FAILURE;\n    }\n    /* recursively make the module implemented */\n    ((struct lys_module *)module)->implemented = 1;\n    if (lys_make_implemented_r((struct lys_module *)module, unres)) {\n        goto error;\n    }\n\n    /* try again resolve augments in other modules possibly augmenting this one,\n     * since we have just enabled it\n     */\n    /* resolve rest of unres items */\n    if (unres->count && resolve_unres_schema((struct lys_module *)module, unres)) {\n        goto error;\n    }\n    unres_schema_free(NULL, &unres, 0);\n\n    LOGVRB(\"Module \\\"%s%s%s\\\" now implemented.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"));\n    return EXIT_SUCCESS;\n\nerror:\n    if (disabled) {\n        /* set it back disabled */\n        lys_set_disabled(module);\n    }\n\n    ((struct lys_module *)module)->implemented = 0;\n    unres_schema_free((struct lys_module *)module, &unres, 1);\n    return EXIT_FAILURE;\n}\n\nvoid\nlys_submodule_module_data_free(struct lys_submodule *submodule)\n{\n    struct lys_node *next, *elem;\n\n    /* remove parsed data */\n    LY_TREE_FOR_SAFE(submodule->belongsto->data, next, elem) {\n        if (elem->module == (struct lys_module *)submodule) {\n            lys_node_free(elem, NULL, 0);\n        }\n    }\n}\n\nAPI char *\nlys_path(const struct lys_node *node, int options)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYS, node, &buf, (options & LYS_PATH_FIRST_PREFIX) ? 0 : 1, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nAPI char *\nlys_data_path(const struct lys_node *node)\n{\n    char *result = NULL, buf[1024];\n    const char *separator, *name;\n    int i, used;\n    struct ly_set *set;\n    const struct lys_module *prev_mod;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    buf[0] = '\\0';\n    set = ly_set_new();\n    LY_CHECK_ERR_GOTO(!set, LOGMEM(node->module->ctx), cleanup);\n\n    while (node) {\n        ly_set_add(set, (void *)node, 0);\n        do {\n            node = lys_parent(node);\n        } while (node && (node->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    }\n\n    prev_mod = NULL;\n    used = 0;\n    for (i = set->number - 1; i > -1; --i) {\n        node = set->set.s[i];\n        if (node->nodetype == LYS_EXT) {\n            if (strcmp(((struct lys_ext_instance *)node)->def->name, \"yang-data\")) {\n                continue;\n            }\n            name = ((struct lys_ext_instance *)node)->arg_value;\n            separator = \":#\";\n        } else {\n            name = node->name;\n            separator = \":\";\n        }\n        used += sprintf(buf + used, \"/%s%s%s\", (lys_node_module(node) == prev_mod ? \"\" : lys_node_module(node)->name),\n                        (lys_node_module(node) == prev_mod ? \"\" : separator), name);\n        prev_mod = lys_node_module(node);\n    }\n\n    result = strdup(buf);\n    LY_CHECK_ERR_GOTO(!result, LOGMEM(node->module->ctx), cleanup);\n\ncleanup:\n    ly_set_free(set);\n    return result;\n}\n\nstruct lys_node_augment *\nlys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod, const struct lys_node *aug_target)\n{\n    struct lys_node *child;\n    struct lys_node_augment *aug;\n    int i, j, last_found;\n\n    assert(mod && aug_target);\n\n    if (!last) {\n        last_found = 1;\n    } else {\n        last_found = 0;\n    }\n\n    /* search module augments */\n    for (i = 0; i < mod->augment_size; ++i) {\n        if (!mod->augment[i].target) {\n            /* still unresolved, skip */\n            continue;\n        }\n\n        if (mod->augment[i].target == aug_target) {\n            if (last_found) {\n                /* next match after last */\n                return &mod->augment[i];\n            }\n\n            if (&mod->augment[i] == last) {\n                last_found = 1;\n            }\n        }\n    }\n\n    /* search submodule augments */\n    for (i = 0; i < mod->inc_size; ++i) {\n        for (j = 0; j < mod->inc[i].submodule->augment_size; ++j) {\n            if (!mod->inc[i].submodule->augment[j].target) {\n                continue;\n            }\n\n            if (mod->inc[i].submodule->augment[j].target == aug_target) {\n                if (last_found) {\n                    /* next match after last */\n                    return &mod->inc[i].submodule->augment[j];\n                }\n\n                if (&mod->inc[i].submodule->augment[j] == last) {\n                    last_found = 1;\n                }\n            }\n        }\n    }\n\n    /* we also need to check possible augments to choices */\n    LY_TREE_FOR(aug_target->child, child) {\n        if (child->nodetype == LYS_CHOICE) {\n            aug = lys_getnext_target_aug(last, mod, child);\n            if (aug) {\n                return aug;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nAPI struct ly_set *\nlys_find_path(const struct lys_module *cur_module, const struct lys_node *cur_node, const char *path)\n{\n    struct ly_set *ret;\n    int rc;\n\n    if ((!cur_module && !cur_node) || !path) {\n        return NULL;\n    }\n\n    rc = resolve_schema_nodeid(path, cur_node, cur_module, &ret, 1, 1);\n    if (rc == -1) {\n        return NULL;\n    }\n\n    return ret;\n}\n\nstatic void\nlys_extcomplex_free_str(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    const char **str, ***a;\n    int c;\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || !(*str)) {\n        return;\n    }\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* we have array */\n        a = (const char ***)str;\n        for (str = (*(const char ***)str), c = 0; str[c]; c++) {\n            lydict_remove(ctx, str[c]);\n        }\n        free(a[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            for (str = a[1], c = 0; str[c]; c++) {\n                lydict_remove(ctx, str[c]);\n            }\n            free(a[1]);\n        } else if (stmt == LY_STMT_ARGUMENT) {\n            free(a[1]);\n        }\n    } else {\n        lydict_remove(ctx, str[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            lydict_remove(ctx, str[1]);\n        }\n    }\n}\n\nvoid\nlys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i, j, k;\n    struct lyext_substmt *substmt;\n    void **pp, **start;\n    struct lys_node *siter, *snext;\n\n#define EXTCOMPLEX_FREE_STRUCT(STMT, TYPE, FUNC, FREE, ARGS...)                               \\\n    pp = lys_ext_complex_get_substmt(STMT, (struct lys_ext_instance_complex *)e[i], NULL);    \\\n    if (!pp || !(*pp)) { break; }                                                             \\\n    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */                    \\\n        for (start = pp = *pp; *pp; pp++) {                                                   \\\n            FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                             \\\n            if (FREE) { free(*pp); }                                                          \\\n        }                                                                                     \\\n        free(start);                                                                          \\\n    } else { /* single item */                                                                \\\n        FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                                 \\\n        if (FREE) { free(*pp); }                                                              \\\n    }\n\n    if (!size || !e) {\n        return;\n    }\n\n    for (i = 0; i < size; i++) {\n        if (!e[i]) {\n            continue;\n        }\n\n        if (e[i]->flags & (LYEXT_OPT_INHERIT)) {\n            /* no free, this is just a shadow copy of the original extension instance */\n        } else {\n            if (e[i]->flags & (LYEXT_OPT_YANG)) {\n                free(e[i]->def);     /* remove name of instance extension */\n                e[i]->def = NULL;\n                yang_free_ext_data((struct yang_ext_substmt *)e[i]->parent); /* remove backup part of yang file */\n            }\n            /* remove private object */\n            if (e[i]->priv && private_destructor) {\n                private_destructor((struct lys_node*)e[i], e[i]->priv);\n            }\n            lys_extension_instances_free(ctx, e[i]->ext, e[i]->ext_size, private_destructor);\n            lydict_remove(ctx, e[i]->arg_value);\n        }\n\n        if (e[i]->def && e[i]->def->plugin && e[i]->def->plugin->type == LYEXT_COMPLEX\n                && ((e[i]->flags & LYEXT_OPT_CONTENT) == 0)) {\n            substmt = ((struct lys_ext_instance_complex *)e[i])->substmt;\n            for (j = 0; substmt[j].stmt; j++) {\n                switch(substmt[j].stmt) {\n                case LY_STMT_DESCRIPTION:\n                case LY_STMT_REFERENCE:\n                case LY_STMT_UNITS:\n                case LY_STMT_ARGUMENT:\n                case LY_STMT_DEFAULT:\n                case LY_STMT_ERRTAG:\n                case LY_STMT_ERRMSG:\n                case LY_STMT_PREFIX:\n                case LY_STMT_NAMESPACE:\n                case LY_STMT_PRESENCE:\n                case LY_STMT_REVISIONDATE:\n                case LY_STMT_KEY:\n                case LY_STMT_BASE:\n                case LY_STMT_BELONGSTO:\n                case LY_STMT_CONTACT:\n                case LY_STMT_ORGANIZATION:\n                case LY_STMT_PATH:\n                    lys_extcomplex_free_str(ctx, (struct lys_ext_instance_complex *)e[i], substmt[j].stmt);\n                    break;\n                case LY_STMT_TYPE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPE, struct lys_type, lys_type_free, 1);\n                    break;\n                case LY_STMT_TYPEDEF:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPEDEF, struct lys_tpdf, lys_tpdf_free, 1);\n                    break;\n                case LY_STMT_IFFEATURE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_IFFEATURE, struct lys_iffeature, lys_iffeature_free, 0, 1, 0);\n                    break;\n                case LY_STMT_MAX:\n                case LY_STMT_MIN:\n                case LY_STMT_POSITION:\n                case LY_STMT_VALUE:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME && *pp) {\n                        for(k = 0; ((uint32_t**)(*pp))[k]; k++) {\n                            free(((uint32_t**)(*pp))[k]);\n                        }\n                    }\n                    free(*pp);\n                    break;\n                case LY_STMT_DIGITS:\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_MODULE:\n                    /* modules are part of the context, so they will be freed there */\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_ACTION:\n                case LY_STMT_ANYDATA:\n                case LY_STMT_ANYXML:\n                case LY_STMT_CASE:\n                case LY_STMT_CHOICE:\n                case LY_STMT_CONTAINER:\n                case LY_STMT_GROUPING:\n                case LY_STMT_INPUT:\n                case LY_STMT_LEAF:\n                case LY_STMT_LEAFLIST:\n                case LY_STMT_LIST:\n                case LY_STMT_NOTIFICATION:\n                case LY_STMT_OUTPUT:\n                case LY_STMT_RPC:\n                case LY_STMT_USES:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    LY_TREE_FOR_SAFE((struct lys_node *)(*pp), snext, siter) {\n                        lys_node_free(siter, NULL, 0);\n                    }\n                    *pp = NULL;\n                    break;\n                case LY_STMT_UNIQUE:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_UNIQUE, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                                lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                            }\n                            free((*(struct lys_unique**)pp)->expr);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                            lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                        }\n                        free((*(struct lys_unique**)pp)->expr);\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_LENGTH:\n                case LY_STMT_MUST:\n                case LY_STMT_PATTERN:\n                case LY_STMT_RANGE:\n                    EXTCOMPLEX_FREE_STRUCT(substmt[j].stmt, struct lys_restr, lys_restr_free, 1);\n                    break;\n                case LY_STMT_WHEN:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_WHEN, struct lys_when, lys_when_free, 0);\n                    break;\n                case LY_STMT_REVISION:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_REVISION, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                            lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                         (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                        lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                     (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                        free(*pp);\n                    }\n                    break;\n                default:\n                    /* nothing to free */\n                    break;\n                }\n            }\n        }\n\n        free(e[i]);\n    }\n    free(e);\n\n#undef EXTCOMPLEX_FREE_STRUCT\n}\n"], "fixing_code": ["/**\n * @file tree_schema.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang schema data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#ifdef __APPLE__\n#   include <sys/param.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml.h\"\n#include \"xpath.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"parser_yang.h\"\n\nstatic int lys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n                        int in_grp, int shallow, struct unres_schema *unres);\n\nAPI const struct lys_node_list *\nlys_is_key(const struct lys_node_leaf *node, uint8_t *index)\n{\n    struct lys_node *parent = (struct lys_node *)node;\n    struct lys_node_list *list;\n    uint8_t i;\n\n    if (!node || node->nodetype != LYS_LEAF) {\n        return NULL;\n    }\n\n    do {\n        parent = lys_parent(parent);\n    } while (parent && parent->nodetype == LYS_USES);\n\n    if (!parent || parent->nodetype != LYS_LIST) {\n        return NULL;\n    }\n\n    list = (struct lys_node_list*)parent;\n    for (i = 0; i < list->keys_size; i++) {\n        if (list->keys[i] == node) {\n            if (index) {\n                (*index) = i;\n            }\n            return list;\n        }\n    }\n    return NULL;\n}\n\nAPI const struct lys_node *\nlys_is_disabled(const struct lys_node *node, int recursive)\n{\n    int i;\n\n    if (!node) {\n        return NULL;\n    }\n\ncheck:\n    if (node->nodetype != LYS_INPUT && node->nodetype != LYS_OUTPUT) {\n        /* input/output does not have if-feature, so skip them */\n\n        /* check local if-features */\n        for (i = 0; i < node->iffeature_size; i++) {\n            if (!resolve_iffeature(&node->iffeature[i])) {\n                return node;\n            }\n        }\n    }\n\n    if (!recursive) {\n        return NULL;\n    }\n\n    /* go through parents */\n    if (node->nodetype == LYS_AUGMENT) {\n        /* go to parent actually means go to the target node */\n        node = ((struct lys_node_augment *)node)->target;\n        if (!node) {\n            /* unresolved augment, let's say it's enabled */\n            return NULL;\n        }\n    } else if (node->nodetype == LYS_EXT) {\n        return NULL;\n    } else if (node->parent) {\n        node = node->parent;\n    } else {\n        return NULL;\n    }\n\n    if (recursive == 2) {\n        /* continue only if the node cannot have a data instance */\n        if (node->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST)) {\n            return NULL;\n        }\n    }\n    goto check;\n}\n\nAPI const struct lys_type *\nlys_getnext_union_type(const struct lys_type *last, const struct lys_type *type)\n{\n    int found = 0;\n\n    if (!type || (type->base != LY_TYPE_UNION)) {\n        return NULL;\n    }\n\n    return lyp_get_next_union_type((struct lys_type *)type, (struct lys_type *)last, &found);\n}\n\nint\nlys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                int nam_len, LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node, *parent = NULL;\n    const struct lys_module *mod = NULL;\n    const char *node_mod_name;\n\n    assert(siblings && mod_name && name);\n    assert(!(type & (LYS_USES | LYS_GROUPING)));\n\n    /* fill the lengths in case the caller is so indifferent */\n    if (!mod_name_len) {\n        mod_name_len = strlen(mod_name);\n    }\n    if (!nam_len) {\n        nam_len = strlen(name);\n    }\n\n    while (siblings && (siblings->nodetype == LYS_USES)) {\n        siblings = siblings->child;\n    }\n    if (!siblings) {\n        /* unresolved uses */\n        return EXIT_FAILURE;\n    }\n\n    if (siblings->nodetype == LYS_GROUPING) {\n        for (node = siblings; (node->nodetype == LYS_GROUPING) && (node->prev != siblings); node = node->prev);\n        if (node->nodetype == LYS_GROUPING) {\n            /* we went through all the siblings, only groupings there - no valid sibling */\n            return EXIT_FAILURE;\n        }\n        /* update siblings to be valid */\n        siblings = node;\n    }\n\n    /* set parent correctly */\n    parent = lys_parent(siblings);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (!parent) {\n        /* handle situation when there is a top-level uses referencing a foreign grouping */\n        for (node = siblings; lys_parent(node) && (node->nodetype == LYS_USES); node = lys_parent(node));\n        mod = lys_node_module(node);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT))) {\n        if (!type || (node->nodetype & type)) {\n            /* module name comparison */\n            node_mod_name = lys_node_module(node)->name;\n            if (!ly_strequal(node_mod_name, mod_name, 1) && (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len])) {\n                continue;\n            }\n\n            /* direct name check */\n            if (ly_strequal(node->name, name, 1) || (!strncmp(node->name, name, nam_len) && !node->name[nam_len])) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nint\nlys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, int getnext_opts, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, getnext_opts))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nAPI const struct lys_node *\nlys_getnext(const struct lys_node *last, const struct lys_node *parent, const struct lys_module *module, int options)\n{\n    const struct lys_node *next, *aug_parent;\n    struct lys_node **snode;\n\n    if ((!parent && !module) || (module && module->type) || (parent && (parent->nodetype == LYS_USES) && !(options & LYS_GETNEXT_PARENTUSES))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!last) {\n        /* first call */\n\n        /* get know where to start */\n        if (parent) {\n            /* schema subtree */\n            snode = lys_child(parent, LYS_UNKNOWN);\n            /* do not return anything if the augment does not have any children */\n            if (!snode || !(*snode) || ((parent->nodetype == LYS_AUGMENT) && ((*snode)->parent != parent))) {\n                return NULL;\n            }\n            next = last = *snode;\n        } else {\n            /* top level data */\n            if (!(options & LYS_GETNEXT_NOSTATECHECK) && (module->disabled || !module->implemented)) {\n                /* nothing to return from a disabled/imported module */\n                return NULL;\n            }\n            next = last = module->data;\n        }\n    } else if ((last->nodetype == LYS_USES) && (options & LYS_GETNEXT_INTOUSES) && last->child) {\n        /* continue with uses content */\n        next = last->child;\n    } else {\n        /* continue after the last returned value */\n        next = last->next;\n    }\n\nrepeat:\n    if (parent && (parent->nodetype == LYS_AUGMENT) && next) {\n        /* do not return anything outside the parent augment */\n        aug_parent = next->parent;\n        do {\n            while (aug_parent && (aug_parent->nodetype != LYS_AUGMENT)) {\n                aug_parent = aug_parent->parent;\n            }\n            if (aug_parent) {\n                if (aug_parent == parent) {\n                    break;\n                }\n                aug_parent = ((struct lys_node_augment *)aug_parent)->target;\n            }\n\n        } while (aug_parent);\n        if (!aug_parent) {\n            return NULL;\n        }\n    }\n    while (next && (next->nodetype == LYS_GROUPING)) {\n        if (options & LYS_GETNEXT_WITHGROUPING) {\n            return next;\n        }\n        next = next->next;\n    }\n\n    if (!next) {     /* cover case when parent is augment */\n        if (!last || last->parent == parent || lys_parent(last) == parent) {\n            /* no next element */\n            return NULL;\n        }\n        last = lys_parent(last);\n        next = last->next;\n        goto repeat;\n    } else {\n        last = next;\n    }\n\n    if (!(options & LYS_GETNEXT_NOSTATECHECK) && lys_is_disabled(next, 0)) {\n        next = next->next;\n        goto repeat;\n    }\n\n    switch (next->nodetype) {\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (options & LYS_GETNEXT_WITHINOUT) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_CASE:\n        if (options & LYS_GETNEXT_WITHCASE) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_USES:\n        /* go into */\n        if (options & LYS_GETNEXT_WITHUSES) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_LIST:\n    case LYS_LEAFLIST:\n        return next;\n\n    case LYS_CONTAINER:\n        if (!((struct lys_node_container *)next)->presence && (options & LYS_GETNEXT_INTONPCONT)) {\n            if (next->child) {\n                /* go into */\n                next = next->child;\n            } else {\n                next = next->next;\n            }\n            goto repeat;\n        } else {\n            return next;\n        }\n\n    case LYS_CHOICE:\n        if (options & LYS_GETNEXT_WITHCHOICE) {\n            return next;\n        } else if (next->child) {\n            /* go into */\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    default:\n        /* we should not be here */\n        return NULL;\n    }\n}\n\nvoid\nlys_node_unlink(struct lys_node *node)\n{\n    struct lys_node *parent, *first, **pp = NULL;\n    struct lys_module *main_module;\n\n    if (!node) {\n        return;\n    }\n\n    /* unlink from data model if necessary */\n    if (node->module) {\n        /* get main module with data tree */\n        main_module = lys_node_module(node);\n        if (main_module->data == node) {\n            main_module->data = node->next;\n        }\n    }\n\n    /* store pointers to important nodes */\n    parent = node->parent;\n    if (parent && (parent->nodetype == LYS_AUGMENT)) {\n        /* handle augments - first, unlink it from the augment parent ... */\n        if (parent->child == node) {\n            parent->child = (node->next && node->next->parent == parent) ? node->next : NULL;\n        }\n\n        if (parent->flags & LYS_NOTAPPLIED) {\n            /* data are not connected in the target, so we cannot continue with the target as a parent */\n            parent = NULL;\n        } else {\n            /* data are connected in target, so we will continue with the target as a parent */\n            parent = ((struct lys_node_augment *)parent)->target;\n        }\n    }\n\n    /* unlink from parent */\n    if (parent) {\n        if (parent->nodetype == LYS_EXT) {\n            pp = (struct lys_node **)lys_ext_complex_get_substmt(lys_snode2stmt(node->nodetype),\n                                                                 (struct lys_ext_instance_complex*)parent, NULL);\n            if (*pp == node) {\n                *pp = node->next;\n            }\n        } else if (parent->child == node) {\n            parent->child = node->next;\n        }\n        node->parent = NULL;\n    }\n\n    /* unlink from siblings */\n    if (node->prev == node) {\n        /* there are no more siblings */\n        return;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last element */\n        if (parent) {\n            if (parent->nodetype == LYS_EXT) {\n                first = *(struct lys_node **)pp;\n            } else {\n                first = parent->child;\n            }\n        } else {\n            first = node;\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n        first->prev = node->prev;\n    }\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n\n    /* clean up the unlinked element */\n    node->next = NULL;\n    node->prev = node;\n}\n\nstruct lys_node_grp *\nlys_find_grouping_up(const char *name, struct lys_node *start)\n{\n    struct lys_node *par_iter, *iter, *stop;\n\n    for (par_iter = start; par_iter; par_iter = par_iter->parent) {\n        /* top-level augment, look into module (uses augment is handled correctly below) */\n        if (par_iter->parent && !par_iter->parent->parent && (par_iter->parent->nodetype == LYS_AUGMENT)) {\n            par_iter = lys_main_module(par_iter->parent->module)->data;\n            if (!par_iter) {\n                break;\n            }\n        }\n\n        if (par_iter->nodetype == LYS_EXT) {\n            /* we are in a top-level extension, search grouping in top-level groupings */\n            par_iter = lys_main_module(par_iter->module)->data;\n            if (!par_iter) {\n                /* not connected yet, wait */\n                return NULL;\n            }\n        } else if (par_iter->parent && (par_iter->parent->nodetype & (LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_USES))) {\n            continue;\n        }\n\n        for (iter = par_iter, stop = NULL; iter; iter = iter->prev) {\n            if (!stop) {\n                stop = par_iter;\n            } else if (iter == stop) {\n                break;\n            }\n            if (iter->nodetype != LYS_GROUPING) {\n                continue;\n            }\n\n            if (!strcmp(name, iter->name)) {\n                return (struct lys_node_grp *)iter;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * get next grouping in the root's subtree, in the\n * first call, tha last is NULL\n */\nstatic struct lys_node_grp *\nlys_get_next_grouping(struct lys_node_grp *lastgrp, struct lys_node *root)\n{\n    struct lys_node *last = (struct lys_node *)lastgrp;\n    struct lys_node *next;\n\n    assert(root);\n\n    if (!last) {\n        last = root;\n    }\n\n    while (1) {\n        if ((last->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n            next = last->child;\n        } else {\n            next = NULL;\n        }\n        if (!next) {\n            if (last == root) {\n                /* we are done */\n                return NULL;\n            }\n\n            /* no children, go to siblings */\n            next = last->next;\n        }\n        while (!next) {\n            /* go back through parents */\n            if (lys_parent(last) == root) {\n                /* we are done */\n                return NULL;\n            }\n            next = last->next;\n            last = lys_parent(last);\n        }\n\n        if (next->nodetype == LYS_GROUPING) {\n            return (struct lys_node_grp *)next;\n        }\n\n        last = next;\n    }\n}\n\n/* logs directly */\nint\nlys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module)\n{\n    struct lys_node *start, *stop, *iter;\n    struct lys_node_grp *grp;\n    int down, up;\n\n    assert(node);\n\n    if (!parent) {\n        assert(module);\n    } else {\n        module = parent->module;\n    }\n    module = lys_main_module(module);\n\n    switch (node->nodetype) {\n    case LYS_GROUPING:\n        /* 6.2.1, rule 6 */\n        if (parent) {\n            start = *lys_child(parent, LYS_GROUPING);\n            if (!start) {\n                down = 0;\n                start = parent;\n            } else {\n                down = 1;\n            }\n            if (parent->nodetype == LYS_EXT) {\n                up = 0;\n            } else {\n                up = 1;\n            }\n        } else {\n            down = up = 1;\n            start = module->data;\n        }\n        /* go up */\n        if (up && lys_find_grouping_up(node->name, start)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"grouping\", node->name);\n            return EXIT_FAILURE;\n        }\n        /* go down, because grouping can be defined after e.g. container in which is collision */\n        if (down) {\n            for (iter = start, stop = NULL; iter; iter = iter->prev) {\n                if (!stop) {\n                    stop = start;\n                } else if (iter == stop) {\n                    break;\n                }\n                if (!(iter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n                    continue;\n                }\n\n                grp = NULL;\n                while ((grp = lys_get_next_grouping(grp, iter))) {\n                    if (ly_strequal(node->name, grp->name, 1)) {\n                        LOGVAL(module->ctx, LYE_DUPID,LY_VLOG_LYS, node, \"grouping\", node->name);\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CONTAINER:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n        /* 6.2.1, rule 7 */\n        if (parent) {\n            iter = parent;\n            while (iter && (iter->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE | LYS_AUGMENT))) {\n                if (iter->nodetype == LYS_AUGMENT) {\n                    if (((struct lys_node_augment *)iter)->target) {\n                        /* augment is resolved, go up */\n                        iter = ((struct lys_node_augment *)iter)->target;\n                        continue;\n                    }\n                    /* augment is not resolved, this is the final parent */\n                    break;\n                }\n                iter = iter->parent;\n            }\n\n            if (!iter) {\n                stop = NULL;\n                iter = module->data;\n            } else if (iter->nodetype == LYS_EXT) {\n                stop = iter;\n                iter = (struct lys_node *)lys_child(iter, node->nodetype);\n                if (iter) {\n                    iter = *(struct lys_node **)iter;\n                }\n            } else {\n                stop = iter;\n                iter = iter->child;\n            }\n        } else {\n            stop = NULL;\n            iter = module->data;\n        }\n        while (iter) {\n            if (iter->nodetype & (LYS_USES | LYS_CASE)) {\n                iter = iter->child;\n                continue;\n            }\n\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CONTAINER | LYS_CHOICE | LYS_ANYDATA)) {\n                if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                    LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, strnodetype(node->nodetype), node->name);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* special case for choice - we must check the choice's name as\n             * well as the names of nodes under the choice\n             */\n            if (iter->nodetype == LYS_CHOICE) {\n                iter = iter->child;\n                continue;\n            }\n\n            /* go to siblings */\n            if (!iter->next) {\n                /* no sibling, go to parent's sibling */\n                do {\n                    /* for parent LYS_AUGMENT */\n                    if (iter->parent == stop) {\n                        iter = stop;\n                        break;\n                    }\n                    iter = lys_parent(iter);\n                    if (iter && iter->next) {\n                        break;\n                    }\n                } while (iter != stop);\n\n                if (iter == stop) {\n                    break;\n                }\n            }\n            iter = iter->next;\n        }\n        break;\n    case LYS_CASE:\n        /* 6.2.1, rule 8 */\n        if (parent) {\n            start = *lys_child(parent, LYS_CASE);\n        } else {\n            start = module->data;\n        }\n\n        LY_TREE_FOR(start, iter) {\n            if (!(iter->nodetype & (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST))) {\n                continue;\n            }\n\n            if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"case\", node->name);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* no check needed */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options)\n{\n    struct ly_ctx *ctx = child->module->ctx;\n    struct lys_node *iter, **pchild, *log_parent;\n    struct lys_node_inout *in, *out;\n    struct lys_node_case *c;\n    int type, shortcase = 0;\n    void *p;\n    struct lyext_substmt *info = NULL;\n\n    assert(child);\n\n    if (parent) {\n        type = parent->nodetype;\n        module = parent->module;\n        log_parent = parent;\n\n        if (type == LYS_USES) {\n            /* we are adding children to uses -> we must be copying grouping contents into it, so properly check the parent */\n            log_parent = lys_parent(log_parent);\n            while (log_parent && (log_parent->nodetype == LYS_USES)) {\n                log_parent = lys_parent(log_parent);\n            }\n            if (log_parent) {\n                type = log_parent->nodetype;\n            } else {\n                type = 0;\n            }\n        }\n    } else {\n        assert(module);\n        assert(!(child->nodetype & (LYS_INPUT | LYS_OUTPUT)));\n        type = 0;\n        log_parent = NULL;\n    }\n\n    /* checks */\n    switch (type) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_GROUPING:\n    case LYS_USES:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_CHOICE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"choice\");\n            return EXIT_FAILURE;\n        }\n        if (child->nodetype != LYS_CASE) {\n            shortcase = 1;\n        }\n        break;\n    case LYS_CASE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"case\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        if (!(child->nodetype & (LYS_INPUT | LYS_OUTPUT | LYS_GROUPING))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"rpc\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"The \\\"%s\\\" statement cannot have any data substatement.\",\n               strnodetype(log_parent->nodetype));\n        return EXIT_FAILURE;\n    case LYS_AUGMENT:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_UNKNOWN:\n        /* top level */\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_GROUPING\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_RPC | LYS_NOTIF | LYS_AUGMENT))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"(sub)module\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_EXT:\n        /* plugin-defined */\n        p = lys_ext_complex_get_substmt(lys_snode2stmt(child->nodetype), (struct lys_ext_instance_complex*)log_parent, &info);\n        if (!p) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype),\n                   ((struct lys_ext_instance_complex*)log_parent)->def->name);\n            return EXIT_FAILURE;\n        }\n        /* TODO check cardinality */\n        break;\n    }\n\n    /* check identifier uniqueness */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && lys_check_id(child, parent, module)) {\n        return EXIT_FAILURE;\n    }\n\n    if (child->parent) {\n        lys_node_unlink(child);\n    }\n\n    if ((child->nodetype & (LYS_INPUT | LYS_OUTPUT)) && parent->nodetype != LYS_EXT) {\n        /* find the implicit input/output node */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->nodetype == child->nodetype) {\n                break;\n            }\n        }\n        assert(iter);\n\n        /* switch the old implicit node (iter) with the new one (child) */\n        if (parent->child == iter) {\n            /* first child */\n            parent->child = child;\n        } else {\n            iter->prev->next = child;\n        }\n        child->prev = iter->prev;\n        child->next = iter->next;\n        if (iter->next) {\n            iter->next->prev = child;\n        } else {\n            /* last child */\n            parent->child->prev = child;\n        }\n        child->parent = parent;\n\n        /* isolate the node and free it */\n        iter->next = NULL;\n        iter->prev = iter;\n        iter->parent = NULL;\n        lys_node_free(iter, NULL, 0);\n    } else {\n        if (shortcase) {\n            /* create the implicit case to allow it to serve as a target of the augments,\n             * it won't be printed, but it will be present in the tree */\n            c = calloc(1, sizeof *c);\n            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);\n            c->name = lydict_insert(module->ctx, child->name, 0);\n            c->flags = LYS_IMPLICIT;\n            if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n                /* get config flag from parent */\n                c->flags |= parent->flags & LYS_CONFIG_MASK;\n            }\n            c->module = module;\n            c->nodetype = LYS_CASE;\n            c->prev = (struct lys_node*)c;\n            lys_node_addchild(parent, module, (struct lys_node*)c, options);\n            parent = (struct lys_node*)c;\n        }\n        /* connect the child correctly */\n        if (!parent) {\n            if (module->data) {\n                module->data->prev->next = child;\n                child->prev = module->data->prev;\n                module->data->prev = child;\n            } else {\n                module->data = child;\n            }\n        } else {\n            pchild = lys_child(parent, child->nodetype);\n            assert(pchild);\n\n            child->parent = parent;\n            if (!(*pchild)) {\n                /* the only/first child of the parent */\n                *pchild = child;\n                iter = child;\n            } else {\n                /* add a new child at the end of parent's child list */\n                iter = (*pchild)->prev;\n                iter->next = child;\n                child->prev = iter;\n            }\n            while (iter->next) {\n                iter = iter->next;\n                iter->parent = parent;\n            }\n            (*pchild)->prev = iter;\n        }\n    }\n\n    /* check config value (but ignore them in groupings and augments) */\n    for (iter = parent; iter && !(iter->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); iter = iter->parent);\n    if (parent && !iter) {\n        for (iter = child; iter && !(iter->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); iter = iter->parent);\n        if (!iter && (parent->flags & LYS_CONFIG_R) && (child->flags & LYS_CONFIG_W)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, child, \"true\", \"config\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* propagate information about status data presence */\n    if ((child->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) &&\n            (child->flags & LYS_INCL_STATUS)) {\n        for(iter = parent; iter; iter = lys_parent(iter)) {\n            /* store it only into container or list - the only data inner nodes */\n            if (iter->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n                if (iter->flags & LYS_INCL_STATUS) {\n                    /* done, someone else set it already from here */\n                    break;\n                }\n                /* set flag about including status data */\n                iter->flags |= LYS_INCL_STATUS;\n            }\n        }\n    }\n\n    /* create implicit input/output nodes to have available them as possible target for augment */\n    if ((child->nodetype & (LYS_RPC | LYS_ACTION)) && !child->child) {\n        in = calloc(1, sizeof *in);\n        out = calloc(1, sizeof *out);\n        if (!in || !out) {\n            LOGMEM(ctx);\n            free(in);\n            free(out);\n            return EXIT_FAILURE;\n        }\n        in->nodetype = LYS_INPUT;\n        in->name = lydict_insert(child->module->ctx, \"input\", 5);\n        out->nodetype = LYS_OUTPUT;\n        out->name = lydict_insert(child->module->ctx, \"output\", 6);\n        in->module = out->module = child->module;\n        in->parent = out->parent = child;\n        in->flags = out->flags = LYS_IMPLICIT;\n        in->next = (struct lys_node *)out;\n        in->prev = (struct lys_node *)out;\n        out->prev = (struct lys_node *)in;\n        child->child = (struct lys_node *)in;\n    }\n    return EXIT_SUCCESS;\n}\n\nconst struct lys_module *\nlys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision, int internal, int implement)\n{\n    char *enlarged_data = NULL;\n    struct lys_module *mod = NULL;\n    unsigned int len;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!internal && format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    switch (format) {\n    case LYS_IN_YIN:\n        mod = yin_read_module(ctx, data, revision, implement);\n        break;\n    case LYS_IN_YANG:\n        mod = yang_read_module(ctx, data, 0, revision, implement);\n        break;\n    default:\n        LOGERR(ctx, LY_EINVAL, \"Invalid schema input format.\");\n        break;\n    }\n\n    free(enlarged_data);\n\n    /* hack for NETCONF's edit-config's operation attribute. It is not defined in the schema, but since libyang\n     * implements YANG metadata (annotations), we need its definition. Because the ietf-netconf schema is not the\n     * internal part of libyang, we cannot add the annotation into the schema source, but we do it here to have\n     * the anotation definitions available in the internal schema structure. There is another hack in schema\n     * printers to do not print this internally added annotation. */\n    if (mod && ly_strequal(mod->name, \"ietf-netconf\", 0)) {\n        if (lyp_add_ietf_netconf_annotations_config(mod)) {\n            lys_free(mod, NULL, 1, 1);\n            return NULL;\n        }\n    }\n\n    return mod;\n}\n\nAPI const struct lys_module *\nlys_parse_mem(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format)\n{\n    return lys_parse_mem_(ctx, data, format, NULL, 0, 1);\n}\n\nstruct lys_submodule *\nlys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    char *enlarged_data = NULL;\n    struct lys_submodule *submod = NULL;\n    unsigned int len;\n\n    assert(module);\n    assert(data);\n\n    if (format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(module->ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submod = yin_read_submodule(module, data, unres);\n        break;\n    case LYS_IN_YANG:\n        submod = yang_read_submodule(module, data, 0, unres);\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    free(enlarged_data);\n    return submod;\n}\n\nAPI const struct lys_module *\nlys_parse_path(struct ly_ctx *ctx, const char *path, LYS_INFORMAT format)\n{\n    int fd;\n    const struct lys_module *ret;\n    const char *rev, *dot, *filename;\n    size_t len;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Opening file \\\"%s\\\" failed (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    ret = lys_parse_fd(ctx, fd, format);\n    close(fd);\n\n    if (!ret) {\n        /* error */\n        return NULL;\n    }\n\n    /* check that name and revision match filename */\n    filename = strrchr(path, '/');\n    if (!filename) {\n        filename = path;\n    } else {\n        filename++;\n    }\n    rev = strchr(filename, '@');\n    dot = strrchr(filename, '.');\n\n    /* name */\n    len = strlen(ret->name);\n    if (strncmp(filename, ret->name, len) ||\n            ((rev && rev != &filename[len]) || (!rev && dot != &filename[len]))) {\n        LOGWRN(ctx, \"File name \\\"%s\\\" does not match module name \\\"%s\\\".\", filename, ret->name);\n    }\n    if (rev) {\n        len = dot - ++rev;\n        if (!ret->rev_size || len != 10 || strncmp(ret->rev[0].date, rev, len)) {\n            LOGWRN(ctx, \"File name \\\"%s\\\" does not match module revision \\\"%s\\\".\", filename,\n                   ret->rev_size ? ret->rev[0].date : \"none\");\n        }\n    }\n\n    if (!ret->filepath) {\n        /* store URI */\n        char rpath[PATH_MAX];\n        if (realpath(path, rpath) != NULL) {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, rpath, 0);\n        } else {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, path, 0);\n        }\n    }\n\n    return ret;\n}\n\nAPI const struct lys_module *\nlys_parse_fd(struct ly_ctx *ctx, int fd, LYS_INFORMAT format)\n{\n    return lys_parse_fd_(ctx, fd, format, NULL, 1);\n}\n\nstatic void\nlys_parse_set_filename(struct ly_ctx *ctx, const char **filename, int fd)\n{\n#ifdef __APPLE__\n    char path[MAXPATHLEN];\n#else\n    int len;\n    char path[PATH_MAX], proc_path[32];\n#endif\n\n#ifdef __APPLE__\n    if (fcntl(fd, F_GETPATH, path) != -1) {\n        *filename = lydict_insert(ctx, path, 0);\n    }\n#else\n    /* get URI if there is /proc */\n    sprintf(proc_path, \"/proc/self/fd/%d\", fd);\n    if ((len = readlink(proc_path, path, PATH_MAX - 1)) > 0) {\n        *filename = lydict_insert(ctx, path, len);\n    }\n#endif\n}\n\nconst struct lys_module *\nlys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement)\n{\n    const struct lys_module *module;\n    size_t length;\n    char *addr;\n\n    if (!ctx || fd < 0) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(ctx, LY_EINVAL, \"Empty schema file.\");\n        return NULL;\n    }\n\n    module = lys_parse_mem_(ctx, addr, format, revision, 1, implement);\n    lyp_munmap(addr, length);\n\n    if (module && !module->filepath) {\n        lys_parse_set_filename(ctx, (const char **)&module->filepath, fd);\n    }\n\n    return module;\n}\n\nstruct lys_submodule *\nlys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    size_t length;\n    char *addr;\n\n    assert(module);\n    assert(fd >= 0);\n\n    if (lyp_mmap(module->ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(module->ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(module->ctx, LY_EINVAL, \"Empty submodule schema file.\");\n        return NULL;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submodule = yin_read_submodule(module, addr, unres);\n        break;\n    case LYS_IN_YANG:\n        submodule = yang_read_submodule(module, addr, 0, unres);\n        break;\n    default:\n        LOGINT(module->ctx);\n        return NULL;\n    }\n\n    lyp_munmap(addr, length);\n\n    if (submodule && !submodule->filepath) {\n        lys_parse_set_filename(module->ctx, (const char **)&submodule->filepath, fd);\n    }\n\n    return submodule;\n\n}\n\nAPI int\nlys_search_localfile(const char * const *searchpaths, int cwd, const char *name, const char *revision, char **localfile, LYS_INFORMAT *format)\n{\n    size_t len, flen, match_len = 0, dir_len;\n    int i, implicit_cwd = 0, ret = EXIT_FAILURE;\n    char *wd, *wn = NULL;\n    DIR *dir = NULL;\n    struct dirent *file;\n    char *match_name = NULL;\n    LYS_INFORMAT format_aux, match_format = 0;\n    unsigned int u;\n    struct ly_set *dirs;\n    struct stat st;\n\n    if (!localfile) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* start to fill the dir fifo with the context's search path (if set)\n     * and the current working directory */\n    dirs = ly_set_new();\n    if (!dirs) {\n        LOGMEM(NULL);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(name);\n    if (cwd) {\n        wd = get_current_dir_name();\n        if (!wd) {\n            LOGMEM(NULL);\n            goto cleanup;\n        } else {\n            /* add implicit current working directory (./) to be searched,\n             * this directory is not searched recursively */\n            if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n            implicit_cwd = 1;\n        }\n    }\n    if (searchpaths) {\n        for (i = 0; searchpaths[i]; i++) {\n            /* check for duplicities with the implicit current working directory */\n            if (implicit_cwd && !strcmp(dirs->set.g[0], searchpaths[i])) {\n                implicit_cwd = 0;\n                continue;\n            }\n            wd = strdup(searchpaths[i]);\n            if (!wd) {\n                LOGMEM(NULL);\n                goto cleanup;\n            } else if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n        }\n    }\n    wd = NULL;\n\n    /* start searching */\n    while (dirs->number) {\n        free(wd);\n        free(wn); wn = NULL;\n\n        dirs->number--;\n        wd = (char *)dirs->set.g[dirs->number];\n        dirs->set.g[dirs->number] = NULL;\n        LOGVRB(\"Searching for \\\"%s\\\" in %s.\", name, wd);\n\n        if (dir) {\n            closedir(dir);\n        }\n        dir = opendir(wd);\n        dir_len = strlen(wd);\n        if (!dir) {\n            LOGWRN(NULL, \"Unable to open directory \\\"%s\\\" for searching (sub)modules (%s).\", wd, strerror(errno));\n        } else {\n            while ((file = readdir(dir))) {\n                if (!strcmp(\".\", file->d_name) || !strcmp(\"..\", file->d_name)) {\n                    /* skip . and .. */\n                    continue;\n                }\n                free(wn);\n                if (asprintf(&wn, \"%s/%s\", wd, file->d_name) == -1) {\n                    LOGMEM(NULL);\n                    goto cleanup;\n                }\n                if (stat(wn, &st) == -1) {\n                    LOGWRN(NULL, \"Unable to get information about \\\"%s\\\" file in \\\"%s\\\" when searching for (sub)modules (%s)\",\n                           file->d_name, wd, strerror(errno));\n                    continue;\n                }\n                if (S_ISDIR(st.st_mode) && (dirs->number || !implicit_cwd)) {\n                    /* we have another subdirectory in searchpath to explore,\n                     * subdirectories are not taken into account in current working dir (dirs->set.g[0]) */\n                    if (ly_set_add(dirs, wn, 0) == -1) {\n                        goto cleanup;\n                    }\n                    /* continue with the next item in current directory */\n                    wn = NULL;\n                    continue;\n                } else if (!S_ISREG(st.st_mode)) {\n                    /* not a regular file (note that we see the target of symlinks instead of symlinks */\n                    continue;\n                }\n\n                /* here we know that the item is a file which can contain a module */\n                if (strncmp(name, file->d_name, len) ||\n                        (file->d_name[len] != '.' && file->d_name[len] != '@')) {\n                    /* different filename than the module we search for */\n                    continue;\n                }\n\n                /* get type according to filename suffix */\n                flen = strlen(file->d_name);\n                if (!strcmp(&file->d_name[flen - 4], \".yin\")) {\n                    format_aux = LYS_IN_YIN;\n                } else if (!strcmp(&file->d_name[flen - 5], \".yang\")) {\n                    format_aux = LYS_IN_YANG;\n                } else {\n                    /* not supportde suffix/file format */\n                    continue;\n                }\n\n                if (revision) {\n                    /* we look for the specific revision, try to get it from the filename */\n                    if (file->d_name[len] == '@') {\n                        /* check revision from the filename */\n                        if (strncmp(revision, &file->d_name[len + 1], strlen(revision))) {\n                            /* another revision */\n                            continue;\n                        } else {\n                            /* exact revision */\n                            free(match_name);\n                            match_name = wn;\n                            wn = NULL;\n                            match_len = dir_len + 1 + len;\n                            match_format = format_aux;\n                            goto success;\n                        }\n                    } else {\n                        /* continue trying to find exact revision match, use this only if not found */\n                        free(match_name);\n                        match_name = wn;\n                        wn = NULL;\n                        match_len = dir_len + 1 +len;\n                        match_format = format_aux;\n                        continue;\n                    }\n                } else {\n                    /* remember the revision and try to find the newest one */\n                    if (match_name) {\n                        if (file->d_name[len] != '@' || lyp_check_date(NULL, &file->d_name[len + 1])) {\n                            continue;\n                        } else if (match_name[match_len] == '@' &&\n                                (strncmp(&match_name[match_len + 1], &file->d_name[len + 1], LY_REV_SIZE - 1) >= 0)) {\n                            continue;\n                        }\n                        free(match_name);\n                    }\n\n                    match_name = wn;\n                    wn = NULL;\n                    match_len = dir_len + 1 + len;\n                    match_format = format_aux;\n                    continue;\n                }\n            }\n        }\n    }\n\nsuccess:\n    (*localfile) = match_name;\n    match_name = NULL;\n    if (format) {\n        (*format) = match_format;\n    }\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    free(wn);\n    free(wd);\n    if (dir) {\n        closedir(dir);\n    }\n    free(match_name);\n    for (u = 0; u < dirs->number; u++) {\n        free(dirs->set.g[u]);\n    }\n    ly_set_free(dirs);\n\n    return ret;\n}\n\nint\nlys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt)\n{\n    unsigned int u;\n\n    for (u = start; u < ext_size; u++) {\n        if (ext[u]->insubstmt == substmt) {\n            return u;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * duplicate extension instance\n */\nint\nlys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n            LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres)\n{\n    int i;\n    uint8_t u = 0;\n    struct lys_ext_instance **result;\n    struct unres_ext *info, *info_orig;\n    size_t len;\n\n    assert(new);\n\n    if (!size) {\n        if (orig) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n        (*new) = NULL;\n        return EXIT_SUCCESS;\n    }\n\n    (*new) = result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx), EXIT_FAILURE);\n    for (u = 0; u < size; u++) {\n        if (orig[u]) {\n            /* resolved extension instance, just duplicate it */\n            switch(orig[u]->ext_type) {\n            case LYEXT_FLAG:\n                result[u] = malloc(sizeof(struct lys_ext_instance));\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n                break;\n            case LYEXT_COMPLEX:\n                len = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->instance_size;\n                result[u] = calloc(1, len);\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n\n                ((struct lys_ext_instance_complex*)result[u])->substmt = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->substmt;\n                /* TODO duplicate data in extension instance content */\n                memcpy((void*)result[u] + sizeof(**orig), (void*)orig[u] + sizeof(**orig), len - sizeof(**orig));\n                break;\n            }\n            /* generic part */\n            result[u]->def = orig[u]->def;\n            result[u]->flags = LYEXT_OPT_CONTENT;\n            result[u]->arg_value = lydict_insert(ctx, orig[u]->arg_value, 0);\n            result[u]->parent = parent;\n            result[u]->parent_type = parent_type;\n            result[u]->insubstmt = orig[u]->insubstmt;\n            result[u]->insubstmt_index = orig[u]->insubstmt_index;\n            result[u]->ext_type = orig[u]->ext_type;\n            result[u]->priv = NULL;\n            result[u]->nodetype = LYS_EXT;\n            result[u]->module = mod;\n\n            /* extensions */\n            result[u]->ext_size = orig[u]->ext_size;\n            if (lys_ext_dup(ctx, mod, orig[u]->ext, orig[u]->ext_size, result[u],\n                            LYEXT_PAR_EXTINST, &result[u]->ext, shallow, unres)) {\n                goto error;\n            }\n\n            /* in case of shallow copy (duplication for deviation), duplicate only the link to private data\n             * in a new copy, otherwise (grouping instantiation) do not duplicate the private data */\n            if (shallow) {\n                result[u]->priv = orig[u]->priv;\n            }\n        } else {\n            /* original extension is not yet resolved, so duplicate it in unres */\n            i = unres_schema_find(unres, -1, &orig, UNRES_EXT);\n            if (i == -1) {\n                /* extension not found in unres */\n                LOGINT(ctx);\n                goto error;\n            }\n            info_orig = unres->str_snode[i];\n            info = malloc(sizeof *info);\n            LY_CHECK_ERR_GOTO(!info, LOGMEM(ctx), error);\n            info->datatype = info_orig->datatype;\n            if (info->datatype == LYS_IN_YIN) {\n                info->data.yin = lyxml_dup_elem(ctx, info_orig->data.yin, NULL, 1, 0);\n            } /* else TODO YANG */\n            info->parent = parent;\n            info->mod = mod;\n            info->parent_type = parent_type;\n            info->ext_index = u;\n            if (unres_schema_add_node(info->mod, unres, new, UNRES_EXT, (struct lys_node *)info) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    (*new) = NULL;\n    lys_extension_instances_free(ctx, result, u, NULL);\n    return EXIT_FAILURE;\n}\n\nstatic struct lys_restr *\nlys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        /* copying unresolved extensions is not supported */\n        if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {\n            result[i].ext_size = old[i].ext_size;\n            lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        }\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}\n\nvoid\nlys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!restr) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, restr->ext, restr->ext_size, private_destructor);\n    lydict_remove(ctx, restr->expr);\n    lydict_remove(ctx, restr->dsc);\n    lydict_remove(ctx, restr->ref);\n    lydict_remove(ctx, restr->eapptag);\n    lydict_remove(ctx, restr->emsg);\n}\n\nAPI void\nlys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size,\n                   int shallow, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    uint8_t i;\n\n    for (i = 0; i < iffeature_size; ++i) {\n        lys_extension_instances_free(ctx, iffeature[i].ext, iffeature[i].ext_size, private_destructor);\n        if (!shallow) {\n            free(iffeature[i].expr);\n            free(iffeature[i].features);\n        }\n    }\n    free(iffeature);\n}\n\nstatic int\ntype_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n         LY_DATA_TYPE base, int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n    unsigned int u;\n\n    switch (base) {\n    case LY_TYPE_BINARY:\n        if (old->info.binary.length) {\n            new->info.binary.length = lys_restr_dup(mod, old->info.binary.length, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        new->info.bits.count = old->info.bits.count;\n        if (new->info.bits.count) {\n            new->info.bits.bit = calloc(new->info.bits.count, sizeof *new->info.bits.bit);\n            LY_CHECK_ERR_RETURN(!new->info.bits.bit, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.bits.count; u++) {\n                new->info.bits.bit[u].name = lydict_insert(mod->ctx, old->info.bits.bit[u].name, 0);\n                new->info.bits.bit[u].dsc = lydict_insert(mod->ctx, old->info.bits.bit[u].dsc, 0);\n                new->info.bits.bit[u].ref = lydict_insert(mod->ctx, old->info.bits.bit[u].ref, 0);\n                new->info.bits.bit[u].flags = old->info.bits.bit[u].flags;\n                new->info.bits.bit[u].pos = old->info.bits.bit[u].pos;\n                new->info.bits.bit[u].ext_size = old->info.bits.bit[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.bits.bit[u].ext, old->info.bits.bit[u].ext_size,\n                                &new->info.bits.bit[u], LYEXT_PAR_TYPE_BIT,\n                                &new->info.bits.bit[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        new->info.dec64.dig = old->info.dec64.dig;\n        new->info.dec64.div = old->info.dec64.div;\n        if (old->info.dec64.range) {\n            new->info.dec64.range = lys_restr_dup(mod, old->info.dec64.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        new->info.enums.count = old->info.enums.count;\n        if (new->info.enums.count) {\n            new->info.enums.enm = calloc(new->info.enums.count, sizeof *new->info.enums.enm);\n            LY_CHECK_ERR_RETURN(!new->info.enums.enm, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.enums.count; u++) {\n                new->info.enums.enm[u].name = lydict_insert(mod->ctx, old->info.enums.enm[u].name, 0);\n                new->info.enums.enm[u].dsc = lydict_insert(mod->ctx, old->info.enums.enm[u].dsc, 0);\n                new->info.enums.enm[u].ref = lydict_insert(mod->ctx, old->info.enums.enm[u].ref, 0);\n                new->info.enums.enm[u].flags = old->info.enums.enm[u].flags;\n                new->info.enums.enm[u].value = old->info.enums.enm[u].value;\n                new->info.enums.enm[u].ext_size = old->info.enums.enm[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.enums.enm[u].ext, old->info.enums.enm[u].ext_size,\n                                &new->info.enums.enm[u], LYEXT_PAR_TYPE_ENUM,\n                                &new->info.enums.enm[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        new->info.ident.count = old->info.ident.count;\n        if (old->info.ident.count) {\n            new->info.ident.ref = malloc(old->info.ident.count * sizeof *new->info.ident.ref);\n            LY_CHECK_ERR_RETURN(!new->info.ident.ref, LOGMEM(mod->ctx), -1);\n            memcpy(new->info.ident.ref, old->info.ident.ref, old->info.ident.count * sizeof *new->info.ident.ref);\n        } else {\n            /* there can be several unresolved base identities, duplicate them all */\n            i = -1;\n            do {\n                i = unres_schema_find(unres, i, old, UNRES_TYPE_IDENTREF);\n                if (i != -1) {\n                    if (unres_schema_add_str(mod, unres, new, UNRES_TYPE_IDENTREF, unres->str_snode[i]) == -1) {\n                        return -1;\n                    }\n                }\n                --i;\n            } while (i > -1);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        new->info.inst.req = old->info.inst.req;\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        if (old->info.num.range) {\n            new->info.num.range = lys_restr_dup(mod, old->info.num.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (old->info.lref.path) {\n            new->info.lref.path = lydict_insert(mod->ctx, old->info.lref.path, 0);\n            new->info.lref.req = old->info.lref.req;\n            if (!in_grp && unres_schema_add_node(mod, unres, new, UNRES_TYPE_LEAFREF, parent) == -1) {\n                return -1;\n            }\n        }\n        break;\n\n    case LY_TYPE_STRING:\n        if (old->info.str.length) {\n            new->info.str.length = lys_restr_dup(mod, old->info.str.length, 1, shallow, unres);\n        }\n        if (old->info.str.pat_count) {\n            new->info.str.patterns = lys_restr_dup(mod, old->info.str.patterns, old->info.str.pat_count, shallow, unres);\n            new->info.str.pat_count = old->info.str.pat_count;\n#ifdef LY_ENABLED_CACHE\n            if (!in_grp) {\n                new->info.str.patterns_pcre = malloc(new->info.str.pat_count * 2 * sizeof *new->info.str.patterns_pcre);\n                LY_CHECK_ERR_RETURN(!new->info.str.patterns_pcre, LOGMEM(mod->ctx), -1);\n                for (u = 0; u < new->info.str.pat_count; u++) {\n                    if (lyp_precompile_pattern(mod->ctx, &new->info.str.patterns[u].expr[1],\n                                              (pcre**)&new->info.str.patterns_pcre[2 * u],\n                                              (pcre_extra**)&new->info.str.patterns_pcre[2 * u + 1])) {\n                        free(new->info.str.patterns_pcre);\n                        new->info.str.patterns_pcre = NULL;\n                        return -1;\n                    }\n                }\n            }\n#endif\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        new->info.uni.has_ptr_type = old->info.uni.has_ptr_type;\n        new->info.uni.count = old->info.uni.count;\n        if (new->info.uni.count) {\n            new->info.uni.types = calloc(new->info.uni.count, sizeof *new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.uni.count; u++) {\n                if (lys_type_dup(mod, parent, &(new->info.uni.types[u]), &(old->info.uni.types[u]), in_grp,\n                        shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstruct yang_type *\nlys_yang_type_dup(struct lys_module *module, struct lys_node *parent, struct yang_type *old, struct lys_type *type,\n                  int in_grp, int shallow, struct unres_schema *unres)\n{\n    struct yang_type *new;\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(module->ctx), NULL);\n    new->flags = old->flags;\n    new->base = old->base;\n    new->name = lydict_insert(module->ctx, old->name, 0);\n    new->type = type;\n    if (!new->name) {\n        LOGMEM(module->ctx);\n        goto error;\n    }\n    if (type_dup(module, parent, type, old->type, new->base, in_grp, shallow, unres)) {\n        new->type->base = new->base;\n        lys_type_free(module->ctx, new->type, NULL);\n        memset(&new->type->info, 0, sizeof new->type->info);\n        goto error;\n    }\n    return new;\n\nerror:\n    free(new);\n    return NULL;\n}\n\nint\nlys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type, struct lys_type *prev_new,\n                        struct unres_schema *unres)\n{\n    struct lys_type new;\n    unsigned int i, top_type;\n    struct lys_ext_instance **ext;\n    uint8_t ext_size;\n    void *reloc;\n\n    if (!prev_new) {\n        /* this is the \"top-level\" type, meaning it is a real type and no typedef directly above */\n        top_type = 1;\n\n        memset(&new, 0, sizeof new);\n\n        new.base = type->base;\n        new.parent = (struct lys_tpdf *)parent;\n\n        prev_new = &new;\n    } else {\n        /* this is not top-level type, just a type of a typedef */\n        top_type = 0;\n    }\n\n    assert(type->der);\n    if (type->der->module) {\n        /* typedef, skip it, but keep the extensions */\n        ext_size = type->ext_size;\n        if (lys_ext_dup(mod->ctx, mod, type->ext, type->ext_size, prev_new, LYEXT_PAR_TYPE, &ext, 0, unres)) {\n            return -1;\n        }\n        if (prev_new->ext) {\n            reloc = realloc(prev_new->ext, (prev_new->ext_size + ext_size) * sizeof *prev_new->ext);\n            LY_CHECK_ERR_RETURN(!reloc, LOGMEM(mod->ctx), -1);\n            prev_new->ext = reloc;\n\n            memcpy(prev_new->ext + prev_new->ext_size, ext, ext_size * sizeof *ext);\n            free(ext);\n\n            prev_new->ext_size += ext_size;\n        } else {\n            prev_new->ext = ext;\n            prev_new->ext_size = ext_size;\n        }\n\n        if (lys_copy_union_leafrefs(mod, parent, &type->der->type, prev_new, unres)) {\n            return -1;\n        }\n    } else {\n        /* type, just make a deep copy */\n        switch (type->base) {\n        case LY_TYPE_UNION:\n            prev_new->info.uni.has_ptr_type = type->info.uni.has_ptr_type;\n            prev_new->info.uni.count = type->info.uni.count;\n            /* this cannot be a typedef anymore */\n            assert(prev_new->info.uni.count);\n\n            prev_new->info.uni.types = calloc(prev_new->info.uni.count, sizeof *prev_new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!prev_new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (i = 0; i < prev_new->info.uni.count; i++) {\n                if (lys_copy_union_leafrefs(mod, parent, &(type->info.uni.types[i]), &(prev_new->info.uni.types[i]), unres)) {\n                    return -1;\n                }\n            }\n\n            prev_new->der = type->der;\n            break;\n        default:\n            if (lys_type_dup(mod, parent, prev_new, type, 0, 0, unres)) {\n                return -1;\n            }\n            break;\n        }\n    }\n\n    if (top_type) {\n        memcpy(type, prev_new, sizeof *type);\n    }\n    return EXIT_SUCCESS;\n}\n\nAPI const void *\nlys_ext_instance_substmt(const struct lys_ext_instance *ext)\n{\n    if (!ext) {\n        return NULL;\n    }\n\n    switch (ext->insubstmt) {\n    case LYEXT_SUBSTMT_SELF:\n    case LYEXT_SUBSTMT_MODIFIER:\n    case LYEXT_SUBSTMT_VERSION:\n        return NULL;\n    case LYEXT_SUBSTMT_ARGUMENT:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return ((struct lys_ext_instance*)ext->parent)->arg_value;\n        }\n        break;\n    case LYEXT_SUBSTMT_BASE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            return ((struct lys_type*)ext->parent)->info.ident.ref[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_IDENT) {\n            return ((struct lys_ident*)ext->parent)->base[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_BELONGSTO:\n        if (ext->parent_type == LYEXT_PAR_MODULE && ((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_submodule*)ext->parent)->belongsto;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONFIG:\n    case LYEXT_SUBSTMT_MANDATORY:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            return &((struct lys_node*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONTACT:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->contact;\n        }\n        break;\n    case LYEXT_SUBSTMT_DEFAULT:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            switch (((struct lys_node*)ext->parent)->nodetype) {\n            case LYS_LEAF:\n            case LYS_LEAFLIST:\n                /* in case of leaf, the index is supposed to be 0, so it will return the\n                 * correct pointer despite the leaf structure does not have dflt as array */\n                return ((struct lys_node_leaflist*)ext->parent)->dflt[ext->insubstmt_index];\n            case LYS_CHOICE:\n                return ((struct lys_node_choice*)ext->parent)->dflt;\n            default:\n                /* internal error */\n                break;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->dflt;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->dflt[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->dflt[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_DESCRIPTION:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->dsc;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->dsc;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->dsc;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->dsc;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->dsc;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->dsc;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->dsc;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->dsc;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->dsc;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->dsc;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->dsc;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->dsc;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->dsc;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRTAG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->eapptag;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRMSG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->emsg;\n        }\n        break;\n    case LYEXT_SUBSTMT_DIGITS:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_DEC64) {\n            return &((struct lys_type*)ext->parent)->info.dec64.dig;\n        }\n        break;\n    case LYEXT_SUBSTMT_KEY:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return ((struct lys_node_list*)ext->parent)->keys;\n        }\n        break;\n    case LYEXT_SUBSTMT_MAX:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->max;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->max;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.max;\n        }\n        break;\n    case LYEXT_SUBSTMT_MIN:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->min;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->min;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.min;\n        }\n        break;\n    case LYEXT_SUBSTMT_NAMESPACE:\n        if (ext->parent_type == LYEXT_PAR_MODULE && !((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_module*)ext->parent)->ns;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORDEREDBY:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n            return &((struct lys_node_list*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORGANIZATION:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->org;\n        }\n        break;\n    case LYEXT_SUBSTMT_PATH:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n            return ((struct lys_type*)ext->parent)->info.lref.path;\n        }\n        break;\n    case LYEXT_SUBSTMT_POSITION:\n        if (ext->parent_type == LYEXT_PAR_TYPE_BIT) {\n            return &((struct lys_type_bit*)ext->parent)->pos;\n        }\n        break;\n    case LYEXT_SUBSTMT_PREFIX:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            /* covers also lys_submodule */\n            return ((struct lys_module*)ext->parent)->prefix;\n        } else if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->prefix;\n        }\n        break;\n    case LYEXT_SUBSTMT_PRESENCE:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_CONTAINER) {\n            return ((struct lys_node_container*)ext->parent)->presence;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return ((struct lys_refine*)ext->parent)->mod.presence;\n        }\n        break;\n    case LYEXT_SUBSTMT_REFERENCE:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->ref;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->ref;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->ref;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->ref;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->ref;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->ref;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->ref;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->ref;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->ref;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->ref;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->ref;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->ref;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->ref;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_REQINSTANCE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            if (((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n                return &((struct lys_type*)ext->parent)->info.lref.req;\n            } else if (((struct lys_type*)ext->parent)->base == LY_TYPE_INST) {\n                return &((struct lys_type*)ext->parent)->info.inst.req;\n            }\n        }\n        break;\n    case LYEXT_SUBSTMT_REVISIONDATE:\n        if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->rev;\n        } else if (ext->parent_type == LYEXT_PAR_INCLUDE) {\n            return ((struct lys_include*)ext->parent)->rev;\n        }\n        break;\n    case LYEXT_SUBSTMT_STATUS:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n        case LYEXT_PAR_IDENT:\n        case LYEXT_PAR_TPDF:\n        case LYEXT_PAR_EXT:\n        case LYEXT_PAR_FEATURE:\n        case LYEXT_PAR_TYPE_ENUM:\n        case LYEXT_PAR_TYPE_BIT:\n            /* in all structures the flags member is at the same offset */\n            return &((struct lys_node*)ext->parent)->flags;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_UNIQUE:\n        if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->unique[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return &((struct lys_node_list*)ext->parent)->unique[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_UNITS:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            /* units is at the same offset in both lys_node_leaf and lys_node_leaflist */\n            return ((struct lys_node_leaf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->units;\n        }\n        break;\n    case LYEXT_SUBSTMT_VALUE:\n        if (ext->parent_type == LYEXT_PAR_TYPE_ENUM) {\n            return &((struct lys_type_enum*)ext->parent)->value;\n        }\n        break;\n    case LYEXT_SUBSTMT_YINELEM:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return &((struct lys_ext*)ext->parent)->flags;\n        }\n        break;\n    }\n    LOGINT(ext->module->ctx);\n    return NULL;\n}\n\nstatic int\nlys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n            int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n\n    new->base = old->base;\n    new->der = old->der;\n    new->parent = (struct lys_tpdf *)parent;\n    new->ext_size = old->ext_size;\n    if (lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_TYPE, &new->ext, shallow, unres)) {\n        return -1;\n    }\n\n    i = unres_schema_find(unres, -1, old, UNRES_TYPE_DER);\n    if (i != -1) {\n        /* HACK (serious one) for unres */\n        /* nothing else we can do but duplicate it immediately */\n        if (((struct lyxml_elem *)old->der)->flags & LY_YANG_STRUCTURE_FLAG) {\n            new->der = (struct lys_tpdf *)lys_yang_type_dup(mod, parent, (struct yang_type *)old->der, new, in_grp,\n                                                            shallow, unres);\n        } else {\n            new->der = (struct lys_tpdf *)lyxml_dup_elem(mod->ctx, (struct lyxml_elem *)old->der, NULL, 1, 0);\n        }\n        /* all these unres additions can fail even though they did not before */\n        if (!new->der || (unres_schema_add_node(mod, unres, new, UNRES_TYPE_DER, parent) == -1)) {\n            return -1;\n        }\n        return EXIT_SUCCESS;\n    }\n\n    return type_dup(mod, parent, new, old, new->base, in_grp, shallow, unres);\n}\n\nvoid\nlys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i;\n\n    assert(ctx);\n    if (!type) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, type->ext, type->ext_size, private_destructor);\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        lys_restr_free(ctx, type->info.binary.length, private_destructor);\n        free(type->info.binary.length);\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; i++) {\n            lydict_remove(ctx, type->info.bits.bit[i].name);\n            lydict_remove(ctx, type->info.bits.bit[i].dsc);\n            lydict_remove(ctx, type->info.bits.bit[i].ref);\n            lys_iffeature_free(ctx, type->info.bits.bit[i].iffeature, type->info.bits.bit[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.bits.bit);\n        break;\n\n    case LY_TYPE_DEC64:\n        lys_restr_free(ctx, type->info.dec64.range, private_destructor);\n        free(type->info.dec64.range);\n        break;\n\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; i++) {\n            lydict_remove(ctx, type->info.enums.enm[i].name);\n            lydict_remove(ctx, type->info.enums.enm[i].dsc);\n            lydict_remove(ctx, type->info.enums.enm[i].ref);\n            lys_iffeature_free(ctx, type->info.enums.enm[i].iffeature, type->info.enums.enm[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.enums.enm);\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        lys_restr_free(ctx, type->info.num.range, private_destructor);\n        free(type->info.num.range);\n        break;\n\n    case LY_TYPE_LEAFREF:\n        lydict_remove(ctx, type->info.lref.path);\n        break;\n\n    case LY_TYPE_STRING:\n        lys_restr_free(ctx, type->info.str.length, private_destructor);\n        free(type->info.str.length);\n        for (i = 0; i < type->info.str.pat_count; i++) {\n            lys_restr_free(ctx, &type->info.str.patterns[i], private_destructor);\n#ifdef LY_ENABLED_CACHE\n            if (type->info.str.patterns_pcre) {\n                pcre_free((pcre*)type->info.str.patterns_pcre[2 * i]);\n                pcre_free_study((pcre_extra*)type->info.str.patterns_pcre[2 * i + 1]);\n            }\n#endif\n        }\n        free(type->info.str.patterns);\n#ifdef LY_ENABLED_CACHE\n        free(type->info.str.patterns_pcre);\n#endif\n        break;\n\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; i++) {\n            lys_type_free(ctx, &type->info.uni.types[i], private_destructor);\n        }\n        free(type->info.uni.types);\n        break;\n\n    case LY_TYPE_IDENT:\n        free(type->info.ident.ref);\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_INST, LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n}\n\nstatic void\nlys_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    lydict_remove(ctx, tpdf->name);\n    lydict_remove(ctx, tpdf->dsc);\n    lydict_remove(ctx, tpdf->ref);\n\n    lys_type_free(ctx, &tpdf->type, private_destructor);\n\n    lydict_remove(ctx, tpdf->units);\n    lydict_remove(ctx, tpdf->dflt);\n\n    lys_extension_instances_free(ctx, tpdf->ext, tpdf->ext_size, private_destructor);\n}\n\nstatic struct lys_when *\nlys_when_dup(struct lys_module *mod, struct lys_when *old, int shallow, struct unres_schema *unres)\n{\n    struct lys_when *new;\n\n    if (!old) {\n        return NULL;\n    }\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(mod->ctx), NULL);\n    new->cond = lydict_insert(mod->ctx, old->cond, 0);\n    new->dsc = lydict_insert(mod->ctx, old->dsc, 0);\n    new->ref = lydict_insert(mod->ctx, old->ref, 0);\n    new->ext_size = old->ext_size;\n    lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_WHEN, &new->ext, shallow, unres);\n\n    return new;\n}\n\nvoid\nlys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    if (!w) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, w->ext, w->ext_size, private_destructor);\n    lydict_remove(ctx, w->cond);\n    lydict_remove(ctx, w->dsc);\n    lydict_remove(ctx, w->ref);\n\n    free(w);\n}\n\nstatic void\nlys_augment_free(struct ly_ctx *ctx, struct lys_node_augment *aug,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct lys_node *next, *sub;\n\n    /* children from a resolved augment are freed under the target node */\n    if (!aug->target || (aug->flags & LYS_NOTAPPLIED)) {\n        LY_TREE_FOR_SAFE(aug->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, private_destructor);\n\n    lys_when_free(ctx, aug->when, private_destructor);\n}\n\nstatic void\nlys_ident_free(struct ly_ctx *ctx, struct lys_ident *ident,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!ident) {\n        return;\n    }\n\n    free(ident->base);\n    ly_set_free(ident->der);\n    lydict_remove(ctx, ident->name);\n    lydict_remove(ctx, ident->dsc);\n    lydict_remove(ctx, ident->ref);\n    lys_iffeature_free(ctx, ident->iffeature, ident->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, ident->ext, ident->ext_size, private_destructor);\n\n}\n\nstatic void\nlys_grp_free(struct ly_ctx *ctx, struct lys_node_grp *grp,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < grp->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &grp->tpdf[i], private_destructor);\n    }\n    free(grp->tpdf);\n}\n\nstatic void\nlys_rpc_action_free(struct ly_ctx *ctx, struct lys_node_rpc_action *rpc_act,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < rpc_act->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &rpc_act->tpdf[i], private_destructor);\n    }\n    free(rpc_act->tpdf);\n}\n\nstatic void\nlys_inout_free(struct ly_ctx *ctx, struct lys_node_inout *io,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_INPUT and LYS_OUTPUT */\n    for (i = 0; i < io->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &io->tpdf[i], private_destructor);\n    }\n    free(io->tpdf);\n\n    for (i = 0; i < io->must_size; i++) {\n        lys_restr_free(ctx, &io->must[i], private_destructor);\n    }\n    free(io->must);\n}\n\nstatic void\nlys_notif_free(struct ly_ctx *ctx, struct lys_node_notif *notif,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < notif->must_size; i++) {\n        lys_restr_free(ctx, &notif->must[i], private_destructor);\n    }\n    free(notif->must);\n\n    for (i = 0; i < notif->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &notif->tpdf[i], private_destructor);\n    }\n    free(notif->tpdf);\n}\nstatic void\nlys_anydata_free(struct ly_ctx *ctx, struct lys_node_anydata *anyxml,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < anyxml->must_size; i++) {\n        lys_restr_free(ctx, &anyxml->must[i], private_destructor);\n    }\n    free(anyxml->must);\n\n    lys_when_free(ctx, anyxml->when, private_destructor);\n}\n\nstatic void\nlys_leaf_free(struct ly_ctx *ctx, struct lys_node_leaf *leaf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* leafref backlinks */\n    ly_set_free((struct ly_set *)leaf->backlinks);\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], private_destructor);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, private_destructor);\n\n    lys_type_free(ctx, &leaf->type, private_destructor);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nlys_leaflist_free(struct ly_ctx *ctx, struct lys_node_leaflist *llist,\n                  void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (llist->backlinks) {\n        /* leafref backlinks */\n        ly_set_free(llist->backlinks);\n    }\n\n    for (i = 0; i < llist->must_size; i++) {\n        lys_restr_free(ctx, &llist->must[i], private_destructor);\n    }\n    free(llist->must);\n\n    for (i = 0; i < llist->dflt_size; i++) {\n        lydict_remove(ctx, llist->dflt[i]);\n    }\n    free(llist->dflt);\n\n    lys_when_free(ctx, llist->when, private_destructor);\n\n    lys_type_free(ctx, &llist->type, private_destructor);\n    lydict_remove(ctx, llist->units);\n}\n\nstatic void\nlys_list_free(struct ly_ctx *ctx, struct lys_node_list *list,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    /* handle only specific parts for LY_NODE_LIST */\n    lys_when_free(ctx, list->when, private_destructor);\n\n    for (i = 0; i < list->must_size; i++) {\n        lys_restr_free(ctx, &list->must[i], private_destructor);\n    }\n    free(list->must);\n\n    for (i = 0; i < list->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &list->tpdf[i], private_destructor);\n    }\n    free(list->tpdf);\n\n    free(list->keys);\n\n    for (i = 0; i < list->unique_size; i++) {\n        for (j = 0; j < list->unique[i].expr_size; j++) {\n            lydict_remove(ctx, list->unique[i].expr[j]);\n        }\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    lydict_remove(ctx, list->keys_str);\n}\n\nstatic void\nlys_container_free(struct ly_ctx *ctx, struct lys_node_container *cont,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LY_NODE_CONTAINER */\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &cont->tpdf[i], private_destructor);\n    }\n    free(cont->tpdf);\n\n    for (i = 0; i < cont->must_size; i++) {\n        lys_restr_free(ctx, &cont->must[i], private_destructor);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, private_destructor);\n}\n\nstatic void\nlys_feature_free(struct ly_ctx *ctx, struct lys_feature *f,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, f->name);\n    lydict_remove(ctx, f->dsc);\n    lydict_remove(ctx, f->ref);\n    lys_iffeature_free(ctx, f->iffeature, f->iffeature_size, 0, private_destructor);\n    ly_set_free(f->depfeatures);\n    lys_extension_instances_free(ctx, f->ext, f->ext_size, private_destructor);\n}\n\nstatic void\nlys_extension_free(struct ly_ctx *ctx, struct lys_ext *e,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, e->name);\n    lydict_remove(ctx, e->dsc);\n    lydict_remove(ctx, e->ref);\n    lydict_remove(ctx, e->argument);\n    lys_extension_instances_free(ctx, e->ext, e->ext_size, private_destructor);\n}\n\nstatic void\nlys_deviation_free(struct lys_module *module, struct lys_deviation *dev,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j, k;\n    struct ly_ctx *ctx;\n    struct lys_node *next, *elem;\n\n    ctx = module->ctx;\n\n    lydict_remove(ctx, dev->target_name);\n    lydict_remove(ctx, dev->dsc);\n    lydict_remove(ctx, dev->ref);\n    lys_extension_instances_free(ctx, dev->ext, dev->ext_size, private_destructor);\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    /* it could not be applied because it failed to be applied */\n    if (dev->orig_node) {\n        /* the module was freed, but we only need the context from orig_node, use ours */\n        if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n            /* it's actually a node subtree, we need to update modules on all the nodes :-/ */\n            LY_TREE_DFS_BEGIN(dev->orig_node, next, elem) {\n                elem->module = module;\n\n                LY_TREE_DFS_END(dev->orig_node, next, elem);\n            }\n            lys_node_free(dev->orig_node, NULL, 0);\n        } else {\n            /* it's just a shallow copy, freeing one node */\n            dev->orig_node->module = module;\n            lys_node_free(dev->orig_node, NULL, 1);\n        }\n    }\n\n    for (i = 0; i < dev->deviate_size; i++) {\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, private_destructor);\n\n        for (j = 0; j < dev->deviate[i].dflt_size; j++) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].mod == LY_DEVIATE_DEL) {\n            for (j = 0; j < dev->deviate[i].must_size; j++) {\n                lys_restr_free(ctx, &dev->deviate[i].must[j], private_destructor);\n            }\n            free(dev->deviate[i].must);\n\n            for (j = 0; j < dev->deviate[i].unique_size; j++) {\n                for (k = 0; k < dev->deviate[i].unique[j].expr_size; k++) {\n                    lydict_remove(ctx, dev->deviate[i].unique[j].expr[k]);\n                }\n                free(dev->deviate[i].unique[j].expr);\n            }\n            free(dev->deviate[i].unique);\n        }\n    }\n    free(dev->deviate);\n}\n\nstatic void\nlys_uses_free(struct ly_ctx *ctx, struct lys_node_uses *uses,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        lys_iffeature_free(ctx, uses->refine[i].iffeature, uses->refine[i].iffeature_size, 0, private_destructor);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], private_destructor);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, private_destructor);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n    }\n    free(uses->refine);\n\n    for (i = 0; i < uses->augment_size; i++) {\n        lys_augment_free(ctx, &uses->augment[i], private_destructor);\n    }\n    free(uses->augment);\n\n    lys_when_free(ctx, uses->when, private_destructor);\n}\n\nvoid\nlys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    assert(node->module);\n    assert(node->module->ctx);\n\n    ctx = node->module->ctx;\n\n    /* remove private object */\n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    /* common part */\n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    /* specific part */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        /* do nothing */\n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    /* again common part */\n    lys_node_unlink(node);\n    free(node);\n}\n\nAPI struct lys_module *\nlys_implemented_module(const struct lys_module *mod)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!mod || mod->implemented) {\n        /* invalid argument or the module itself is implemented */\n        return (struct lys_module *)mod;\n    }\n\n    ctx = mod->ctx;\n    for (i = 0; i < ctx->models.used; i++) {\n        if (!ctx->models.list[i]->implemented) {\n            continue;\n        }\n\n        if (ly_strequal(mod->name, ctx->models.list[i]->name, 1)) {\n            /* we have some revision of the module implemented */\n            return ctx->models.list[i];\n        }\n    }\n\n    /* we have no revision of the module implemented, return the module itself,\n     * it is up to the caller to set the module implemented when needed */\n    return (struct lys_module *)mod;\n}\n\n/* free_int_mods - flag whether to free the internal modules as well */\nstatic void\nmodule_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct ly_ctx *ctx;\n    struct lys_node *next, *iter;\n    unsigned int i;\n\n    assert(module->ctx);\n    ctx = module->ctx;\n\n    /* just free the import array, imported modules will stay in the context */\n    for (i = 0; i < module->imp_size; i++) {\n        lydict_remove(ctx, module->imp[i].prefix);\n        lydict_remove(ctx, module->imp[i].dsc);\n        lydict_remove(ctx, module->imp[i].ref);\n        lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor);\n    }\n    free(module->imp);\n\n    /* submodules don't have data tree, the data nodes\n     * are placed in the main module altogether */\n    if (!module->type) {\n        LY_TREE_FOR_SAFE(module->data, next, iter) {\n            lys_node_free(iter, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, module->dsc);\n    lydict_remove(ctx, module->ref);\n    lydict_remove(ctx, module->org);\n    lydict_remove(ctx, module->contact);\n    lydict_remove(ctx, module->filepath);\n\n    /* revisions */\n    for (i = 0; i < module->rev_size; i++) {\n        lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor);\n        lydict_remove(ctx, module->rev[i].dsc);\n        lydict_remove(ctx, module->rev[i].ref);\n    }\n    free(module->rev);\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        lys_ident_free(ctx, &module->ident[i], private_destructor);\n    }\n    module->ident_size = 0;\n    free(module->ident);\n\n    /* typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &module->tpdf[i], private_destructor);\n    }\n    free(module->tpdf);\n\n    /* extension instances */\n    lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor);\n\n    /* augment */\n    for (i = 0; i < module->augment_size; i++) {\n        lys_augment_free(ctx, &module->augment[i], private_destructor);\n    }\n    free(module->augment);\n\n    /* features */\n    for (i = 0; i < module->features_size; i++) {\n        lys_feature_free(ctx, &module->features[i], private_destructor);\n    }\n    free(module->features);\n\n    /* deviations */\n    for (i = 0; i < module->deviation_size; i++) {\n        lys_deviation_free(module, &module->deviation[i], private_destructor);\n    }\n    free(module->deviation);\n\n    /* extensions */\n    for (i = 0; i < module->extensions_size; i++) {\n        lys_extension_free(ctx, &module->extensions[i], private_destructor);\n    }\n    free(module->extensions);\n\n    lydict_remove(ctx, module->name);\n    lydict_remove(ctx, module->prefix);\n}\n\nvoid\nlys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (!submodule) {\n        return;\n    }\n\n    /* common part with struct ly_module */\n    module_free_common((struct lys_module *)submodule, private_destructor);\n\n    /* include */\n    for (i = 0; i < submodule->inc_size; i++) {\n        lydict_remove(submodule->ctx, submodule->inc[i].dsc);\n        lydict_remove(submodule->ctx, submodule->inc[i].ref);\n        lys_extension_instances_free(submodule->ctx, submodule->inc[i].ext, submodule->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n    }\n    free(submodule->inc);\n\n    free(submodule);\n}\n\nint\nlys_ingrouping(const struct lys_node *node)\n{\n    const struct lys_node *iter = node;\n    assert(node);\n\n    for(iter = node; iter && iter->nodetype != LYS_GROUPING; iter = lys_parent(iter));\n    if (!iter) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n/*\n * final: 0 - do not change config flags; 1 - inherit config flags from the parent; 2 - remove config flags\n */\nstatic struct lys_node *\nlys_node_dup_recursion(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                       struct unres_schema *unres, int shallow, int finalize)\n{\n    struct lys_node *retval = NULL, *iter, *p;\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, rc;\n    unsigned int size, size1, size2;\n    struct unres_list_uniq *unique_info;\n    uint16_t flags;\n\n    struct lys_node_container *cont = NULL;\n    struct lys_node_container *cont_orig = (struct lys_node_container *)node;\n    struct lys_node_choice *choice = NULL;\n    struct lys_node_choice *choice_orig = (struct lys_node_choice *)node;\n    struct lys_node_leaf *leaf = NULL;\n    struct lys_node_leaf *leaf_orig = (struct lys_node_leaf *)node;\n    struct lys_node_leaflist *llist = NULL;\n    struct lys_node_leaflist *llist_orig = (struct lys_node_leaflist *)node;\n    struct lys_node_list *list = NULL;\n    struct lys_node_list *list_orig = (struct lys_node_list *)node;\n    struct lys_node_anydata *any = NULL;\n    struct lys_node_anydata *any_orig = (struct lys_node_anydata *)node;\n    struct lys_node_uses *uses = NULL;\n    struct lys_node_uses *uses_orig = (struct lys_node_uses *)node;\n    struct lys_node_rpc_action *rpc = NULL;\n    struct lys_node_inout *io = NULL;\n    struct lys_node_notif *ntf = NULL;\n    struct lys_node_case *cs = NULL;\n    struct lys_node_case *cs_orig = (struct lys_node_case *)node;\n\n    /* we cannot just duplicate memory since the strings are stored in\n     * dictionary and we need to update dictionary counters.\n     */\n\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        cont = calloc(1, sizeof *cont);\n        retval = (struct lys_node *)cont;\n        break;\n\n    case LYS_CHOICE:\n        choice = calloc(1, sizeof *choice);\n        retval = (struct lys_node *)choice;\n        break;\n\n    case LYS_LEAF:\n        leaf = calloc(1, sizeof *leaf);\n        retval = (struct lys_node *)leaf;\n        break;\n\n    case LYS_LEAFLIST:\n        llist = calloc(1, sizeof *llist);\n        retval = (struct lys_node *)llist;\n        break;\n\n    case LYS_LIST:\n        list = calloc(1, sizeof *list);\n        retval = (struct lys_node *)list;\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        any = calloc(1, sizeof *any);\n        retval = (struct lys_node *)any;\n        break;\n\n    case LYS_USES:\n        uses = calloc(1, sizeof *uses);\n        retval = (struct lys_node *)uses;\n        break;\n\n    case LYS_CASE:\n        cs = calloc(1, sizeof *cs);\n        retval = (struct lys_node *)cs;\n        break;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n        rpc = calloc(1, sizeof *rpc);\n        retval = (struct lys_node *)rpc;\n        break;\n\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        io = calloc(1, sizeof *io);\n        retval = (struct lys_node *)io;\n        break;\n\n    case LYS_NOTIF:\n        ntf = calloc(1, sizeof *ntf);\n        retval = (struct lys_node *)ntf;\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);\n\n    /*\n     * duplicate generic part of the structure\n     */\n    retval->name = lydict_insert(ctx, node->name, 0);\n    retval->dsc = lydict_insert(ctx, node->dsc, 0);\n    retval->ref = lydict_insert(ctx, node->ref, 0);\n    retval->flags = node->flags;\n\n    retval->module = module;\n    retval->nodetype = node->nodetype;\n\n    retval->prev = retval;\n\n    /* copying unresolved extensions is not supported */\n    if (unres_schema_find(unres, -1, (void *)&node->ext, UNRES_EXT) == -1) {\n        retval->ext_size = node->ext_size;\n        if (lys_ext_dup(ctx, module, node->ext, node->ext_size, retval, LYEXT_PAR_NODE, &retval->ext, shallow, unres)) {\n            goto error;\n        }\n    }\n\n    if (node->iffeature_size) {\n        retval->iffeature_size = node->iffeature_size;\n        retval->iffeature = calloc(retval->iffeature_size, sizeof *retval->iffeature);\n        LY_CHECK_ERR_GOTO(!retval->iffeature, LOGMEM(ctx), error);\n    }\n\n    if (!shallow) {\n        for (i = 0; i < node->iffeature_size; ++i) {\n            resolve_iffeature_getsizes(&node->iffeature[i], &size1, &size2);\n            if (size1) {\n                /* there is something to duplicate */\n\n                /* duplicate compiled expression */\n                size = (size1 / 4) + (size1 % 4) ? 1 : 0;\n                retval->iffeature[i].expr = malloc(size * sizeof *retval->iffeature[i].expr);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].expr, LOGMEM(ctx), error);\n                memcpy(retval->iffeature[i].expr, node->iffeature[i].expr, size * sizeof *retval->iffeature[i].expr);\n\n                /* list of feature pointer must be updated to point to the resulting tree */\n                retval->iffeature[i].features = calloc(size2, sizeof *retval->iffeature[i].features);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].features, LOGMEM(ctx); free(retval->iffeature[i].expr), error);\n\n                for (j = 0; (unsigned int)j < size2; j++) {\n                    rc = unres_schema_dup(module, unres, &node->iffeature[i].features[j], UNRES_IFFEAT,\n                                          &retval->iffeature[i].features[j]);\n                    if (rc == EXIT_FAILURE) {\n                        /* feature is resolved in origin, so copy it\n                         * - duplication is used for instantiating groupings\n                         * and if-feature inside grouping is supposed to be\n                         * resolved inside the original grouping, so we want\n                         * to keep pointers to features from the grouping\n                         * context */\n                        retval->iffeature[i].features[j] = node->iffeature[i].features[j];\n                    } else if (rc == -1) {\n                        goto error;\n                    } /* else unres was duplicated */\n                }\n            }\n\n            /* duplicate if-feature's extensions */\n            retval->iffeature[i].ext_size = node->iffeature[i].ext_size;\n            if (lys_ext_dup(ctx, module, node->iffeature[i].ext, node->iffeature[i].ext_size,\n                            &retval->iffeature[i], LYEXT_PAR_IFFEATURE, &retval->iffeature[i].ext, shallow, unres)) {\n                goto error;\n            }\n        }\n\n        /* inherit config flags */\n        p = parent;\n        do {\n            for (iter = p; iter && (iter->nodetype == LYS_USES); iter = iter->parent);\n        } while (iter && iter->nodetype == LYS_AUGMENT && (p = lys_parent(iter)));\n        if (iter) {\n            flags = iter->flags & LYS_CONFIG_MASK;\n        } else {\n            /* default */\n            flags = LYS_CONFIG_W;\n        }\n\n        switch (finalize) {\n        case 1:\n            /* inherit config flags */\n            if (retval->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (retval->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    goto error;\n                }\n                break;\n            }\n\n            if (retval->nodetype != LYS_USES) {\n                retval->flags = (retval->flags & ~LYS_CONFIG_MASK) | flags;\n            }\n\n            /* inherit status */\n            if ((parent->flags & LYS_STATUS_MASK) > (retval->flags & LYS_STATUS_MASK)) {\n                /* but do it only in case the parent has a stonger status */\n                retval->flags &= ~LYS_STATUS_MASK;\n                retval->flags |= (parent->flags & LYS_STATUS_MASK);\n            }\n            break;\n        case 2:\n            /* erase config flags */\n            retval->flags &= ~LYS_CONFIG_MASK;\n            retval->flags &= ~LYS_CONFIG_SET;\n            break;\n        }\n\n        /* connect it to the parent */\n        if (lys_node_addchild(parent, retval->module, retval, 0)) {\n            goto error;\n        }\n\n        /* go recursively */\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            LY_TREE_FOR(node->child, iter) {\n                if (iter->nodetype & LYS_GROUPING) {\n                    /* do not instantiate groupings */\n                    continue;\n                }\n                if (!lys_node_dup_recursion(module, retval, iter, unres, 0, finalize)) {\n                    goto error;\n                }\n            }\n        }\n\n        if (finalize == 1) {\n            /* check that configuration lists have keys\n             * - we really want to check keys_size in original node, because the keys are\n             * not yet resolved here, it is done below in nodetype specific part */\n            if ((retval->nodetype == LYS_LIST) && (retval->flags & LYS_CONFIG_W)\n                    && !((struct lys_node_list *)node)->keys_size) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n                goto error;\n            }\n        }\n    } else {\n        memcpy(retval->iffeature, node->iffeature, retval->iffeature_size * sizeof *retval->iffeature);\n    }\n\n    /*\n     * duplicate specific part of the structure\n     */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        if (cont_orig->when) {\n            cont->when = lys_when_dup(module, cont_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cont->when, error);\n        }\n        cont->presence = lydict_insert(ctx, cont_orig->presence, 0);\n\n        if (cont_orig->must) {\n            cont->must = lys_restr_dup(module, cont_orig->must, cont_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!cont->must, error);\n            cont->must_size = cont_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        break;\n    case LYS_CHOICE:\n        if (choice_orig->when) {\n            choice->when = lys_when_dup(module, choice_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!choice->when, error);\n        }\n\n        if (!shallow) {\n            if (choice_orig->dflt) {\n                rc = lys_get_sibling(choice->child, lys_node_module(retval)->name, 0, choice_orig->dflt->name, 0,\n                                            LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST,\n                                            (const struct lys_node **)&choice->dflt);\n                if (rc) {\n                    if (rc == EXIT_FAILURE) {\n                        LOGINT(ctx);\n                    }\n                    goto error;\n                }\n            } else {\n                /* useless to check return value, we don't know whether\n                * there really wasn't any default defined or it just hasn't\n                * been resolved, we just hope for the best :)\n                */\n                unres_schema_dup(module, unres, choice_orig, UNRES_CHOICE_DFLT, choice);\n            }\n        } else {\n            choice->dflt = choice_orig->dflt;\n        }\n        break;\n\n    case LYS_LEAF:\n        if (lys_type_dup(module, retval, &(leaf->type), &(leaf_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        leaf->units = lydict_insert(module->ctx, leaf_orig->units, 0);\n\n        if (leaf_orig->dflt) {\n            leaf->dflt = lydict_insert(ctx, leaf_orig->dflt, 0);\n        }\n\n        if (leaf_orig->must) {\n            leaf->must = lys_restr_dup(module, leaf_orig->must, leaf_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!leaf->must, error);\n            leaf->must_size = leaf_orig->must_size;\n        }\n\n        if (leaf_orig->when) {\n            leaf->when = lys_when_dup(module, leaf_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!leaf->when, error);\n        }\n        break;\n\n    case LYS_LEAFLIST:\n        if (lys_type_dup(module, retval, &(llist->type), &(llist_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        llist->units = lydict_insert(module->ctx, llist_orig->units, 0);\n\n        llist->min = llist_orig->min;\n        llist->max = llist_orig->max;\n\n        if (llist_orig->must) {\n            llist->must = lys_restr_dup(module, llist_orig->must, llist_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!llist->must, error);\n            llist->must_size = llist_orig->must_size;\n        }\n\n        if (llist_orig->dflt) {\n            llist->dflt = malloc(llist_orig->dflt_size * sizeof *llist->dflt);\n            LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n            llist->dflt_size = llist_orig->dflt_size;\n\n            for (i = 0; i < llist->dflt_size; i++) {\n                llist->dflt[i] = lydict_insert(ctx, llist_orig->dflt[i], 0);\n            }\n        }\n\n        if (llist_orig->when) {\n            llist->when = lys_when_dup(module, llist_orig->when, shallow, unres);\n        }\n        break;\n\n    case LYS_LIST:\n        list->min = list_orig->min;\n        list->max = list_orig->max;\n\n        if (list_orig->must) {\n            list->must = lys_restr_dup(module, list_orig->must, list_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!list->must, error);\n            list->must_size = list_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        if (list_orig->keys_size) {\n            list->keys = calloc(list_orig->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n            list->keys_str = lydict_insert(ctx, list_orig->keys_str, 0);\n            list->keys_size = list_orig->keys_size;\n\n            if (!shallow) {\n                if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n                    goto error;\n                }\n            } else {\n                memcpy(list->keys, list_orig->keys, list_orig->keys_size * sizeof *list->keys);\n            }\n        }\n\n        if (list_orig->unique) {\n            list->unique = malloc(list_orig->unique_size * sizeof *list->unique);\n            LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n            list->unique_size = list_orig->unique_size;\n\n            for (i = 0; i < list->unique_size; ++i) {\n                list->unique[i].expr = malloc(list_orig->unique[i].expr_size * sizeof *list->unique[i].expr);\n                LY_CHECK_ERR_GOTO(!list->unique[i].expr, LOGMEM(ctx), error);\n                list->unique[i].expr_size = list_orig->unique[i].expr_size;\n                for (j = 0; j < list->unique[i].expr_size; j++) {\n                    list->unique[i].expr[j] = lydict_insert(ctx, list_orig->unique[i].expr[j], 0);\n\n                    /* if it stays in unres list, duplicate it also there */\n                    unique_info = malloc(sizeof *unique_info);\n                    LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);\n                    unique_info->list = (struct lys_node *)list;\n                    unique_info->expr = list->unique[i].expr[j];\n                    unique_info->trg_type = &list->unique[i].trg_type;\n                    unres_schema_dup(module, unres, &list_orig, UNRES_LIST_UNIQ, unique_info);\n                }\n            }\n        }\n\n        if (list_orig->when) {\n            list->when = lys_when_dup(module, list_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!list->when, error);\n        }\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        if (any_orig->must) {\n            any->must = lys_restr_dup(module, any_orig->must, any_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!any->must, error);\n            any->must_size = any_orig->must_size;\n        }\n\n        if (any_orig->when) {\n            any->when = lys_when_dup(module, any_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!any->when, error);\n        }\n        break;\n\n    case LYS_USES:\n        uses->grp = uses_orig->grp;\n\n        if (uses_orig->when) {\n            uses->when = lys_when_dup(module, uses_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!uses->when, error);\n        }\n        /* it is not needed to duplicate refine, nor augment. They are already applied to the uses children */\n        break;\n\n    case LYS_CASE:\n        if (cs_orig->when) {\n            cs->when = lys_when_dup(module, cs_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cs->when, error);\n        }\n        break;\n\n    case LYS_ACTION:\n    case LYS_RPC:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n        break;\n\n    default:\n        /* LY_NODE_AUGMENT */\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(retval, NULL, 0);\n    return NULL;\n}\n\nint\nlys_has_xpath(const struct lys_node *node)\n{\n    assert(node);\n\n    switch (node->nodetype) {\n    case LYS_AUGMENT:\n        if (((struct lys_node_augment *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CASE:\n        if (((struct lys_node_case *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CHOICE:\n        if (((struct lys_node_choice *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_ANYDATA:\n        if (((struct lys_node_anydata *)node)->when || ((struct lys_node_anydata *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAF:\n        if (((struct lys_node_leaf *)node)->when || ((struct lys_node_leaf *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAFLIST:\n        if (((struct lys_node_leaflist *)node)->when || ((struct lys_node_leaflist *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node)->when || ((struct lys_node_list *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_CONTAINER:\n        if (((struct lys_node_container *)node)->when || ((struct lys_node_container *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (((struct lys_node_inout *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_NOTIF:\n        if (((struct lys_node_notif *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_USES:\n        if (((struct lys_node_uses *)node)->when) {\n            return 1;\n        }\n        break;\n    default:\n        /* does not have XPath */\n        break;\n    }\n\n    return 0;\n}\n\nint\nlys_type_is_local(const struct lys_type *type)\n{\n    if (!type->der->module) {\n        /* build-in type */\n        return 1;\n    }\n    /* type->parent can be either a typedef or leaf/leaf-list, but module pointers are compatible */\n    return (lys_main_module(type->der->module) == lys_main_module(((struct lys_tpdf *)type->parent)->module));\n}\n\n/*\n * shallow -\n *         - do not inherit status from the parent\n */\nstruct lys_node *\nlys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n             struct unres_schema *unres, int shallow)\n{\n    struct lys_node *p = NULL;\n    int finalize = 0;\n    struct lys_node *result, *iter, *next;\n\n    if (!shallow) {\n        /* get know where in schema tree we are to know what should be done during instantiation of the grouping */\n        for (p = parent;\n             p && !(p->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC | LYS_ACTION | LYS_GROUPING));\n             p = lys_parent(p));\n        finalize = p ? ((p->nodetype == LYS_GROUPING) ? 0 : 2) : 1;\n    }\n\n    result = lys_node_dup_recursion(module, parent, node, unres, shallow, finalize);\n    if (finalize) {\n        /* check xpath expressions in the instantiated tree */\n        for (iter = next = result; iter; iter = next) {\n            if (lys_has_xpath(iter) && unres_schema_add_node(module, unres, iter, UNRES_XPATH, NULL) == -1) {\n                /* invalid xpath */\n                return NULL;\n            }\n\n            /* select next item */\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA | LYS_GROUPING)) {\n                /* child exception for leafs, leaflists and anyxml without children, ignore groupings */\n                next = NULL;\n            } else {\n                next = iter->child;\n            }\n            if (!next) {\n                /* no children, try siblings */\n                if (iter == result) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                iter = lys_parent(iter);\n                if (lys_parent(iter) == lys_parent(result)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @brief Switch contents of two same schema nodes. One of the nodes\n * is expected to be ashallow copy of the other.\n *\n * @param[in] node1 Node whose contents will be switched with \\p node2.\n * @param[in] node2 Node whose contents will be switched with \\p node1.\n */\nstatic void\nlys_node_switch(struct lys_node *node1, struct lys_node *node2)\n{\n    const size_t mem_size = 104;\n    uint8_t mem[mem_size];\n    size_t offset, size;\n\n    assert((node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype));\n\n    /*\n     * Initially, the nodes were really switched in the tree which\n     * caused problems for some other nodes with pointers (augments, leafrefs, ...)\n     * because their pointers were not being updated. Code kept in case there is\n     * a use of it in future (it took some debugging to cover all the cases).\n\n    * sibling next *\n    if (node1->prev->next) {\n        node1->prev->next = node2;\n    }\n\n    * sibling prev *\n    if (node1->next) {\n        node1->next->prev = node2;\n    } else {\n        for (child = node1->prev; child->prev->next; child = child->prev);\n        child->prev = node2;\n    }\n\n    * next *\n    node2->next = node1->next;\n    node1->next = NULL;\n\n    * prev *\n    if (node1->prev != node1) {\n        node2->prev = node1->prev;\n    }\n    node1->prev = node1;\n\n    * parent child *\n    if (node1->parent) {\n        if (node1->parent->child == node1) {\n            node1->parent->child = node2;\n        }\n    } else if (lys_main_module(node1->module)->data == node1) {\n        lys_main_module(node1->module)->data = node2;\n    }\n\n    * parent *\n    node2->parent = node1->parent;\n    node1->parent = NULL;\n\n    * child parent *\n    LY_TREE_FOR(node1->child, child) {\n        if (child->parent == node1) {\n            child->parent = node2;\n        }\n    }\n\n    * child *\n    node2->child = node1->child;\n    node1->child = NULL;\n    */\n\n    /* switch common node part */\n    offset = 3 * sizeof(char *);\n    size = sizeof(uint16_t) + 6 * sizeof(uint8_t) + sizeof(struct lys_ext_instance **) + sizeof(struct lys_iffeature *);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* switch node-specific data */\n    offset = sizeof(struct lys_node);\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        size = sizeof(struct lys_node_container) - offset;\n        break;\n    case LYS_CHOICE:\n        size = sizeof(struct lys_node_choice) - offset;\n        break;\n    case LYS_LEAF:\n        size = sizeof(struct lys_node_leaf) - offset;\n        break;\n    case LYS_LEAFLIST:\n        size = sizeof(struct lys_node_leaflist) - offset;\n        break;\n    case LYS_LIST:\n        size = sizeof(struct lys_node_list) - offset;\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        size = sizeof(struct lys_node_anydata) - offset;\n        break;\n    case LYS_CASE:\n        size = sizeof(struct lys_node_case) - offset;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        size = sizeof(struct lys_node_inout) - offset;\n        break;\n    case LYS_NOTIF:\n        size = sizeof(struct lys_node_notif) - offset;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        size = sizeof(struct lys_node_rpc_action) - offset;\n        break;\n    default:\n        assert(0);\n        LOGINT(node1->module->ctx);\n        return;\n    }\n    assert(size <= mem_size);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* typedefs were not copied to the backup node, so always reuse them,\n     * in leaves/leaf-lists we must correct the type parent pointer */\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        ((struct lys_node_container *)node1)->tpdf_size = ((struct lys_node_container *)node2)->tpdf_size;\n        ((struct lys_node_container *)node1)->tpdf = ((struct lys_node_container *)node2)->tpdf;\n        ((struct lys_node_container *)node2)->tpdf_size = 0;\n        ((struct lys_node_container *)node2)->tpdf = NULL;\n        break;\n    case LYS_LIST:\n        ((struct lys_node_list *)node1)->tpdf_size = ((struct lys_node_list *)node2)->tpdf_size;\n        ((struct lys_node_list *)node1)->tpdf = ((struct lys_node_list *)node2)->tpdf;\n        ((struct lys_node_list *)node2)->tpdf_size = 0;\n        ((struct lys_node_list *)node2)->tpdf = NULL;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        ((struct lys_node_rpc_action *)node1)->tpdf_size = ((struct lys_node_rpc_action *)node2)->tpdf_size;\n        ((struct lys_node_rpc_action *)node1)->tpdf = ((struct lys_node_rpc_action *)node2)->tpdf;\n        ((struct lys_node_rpc_action *)node2)->tpdf_size = 0;\n        ((struct lys_node_rpc_action *)node2)->tpdf = NULL;\n        break;\n    case LYS_NOTIF:\n        ((struct lys_node_notif *)node1)->tpdf_size = ((struct lys_node_notif *)node2)->tpdf_size;\n        ((struct lys_node_notif *)node1)->tpdf = ((struct lys_node_notif *)node2)->tpdf;\n        ((struct lys_node_notif *)node2)->tpdf_size = 0;\n        ((struct lys_node_notif *)node2)->tpdf = NULL;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        ((struct lys_node_inout *)node1)->tpdf_size = ((struct lys_node_inout *)node2)->tpdf_size;\n        ((struct lys_node_inout *)node1)->tpdf = ((struct lys_node_inout *)node2)->tpdf;\n        ((struct lys_node_inout *)node2)->tpdf_size = 0;\n        ((struct lys_node_inout *)node2)->tpdf = NULL;\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        ((struct lys_node_leaf *)node1)->type.parent = (struct lys_tpdf *)node1;\n        ((struct lys_node_leaf *)node2)->type.parent = (struct lys_tpdf *)node2;\n    default:\n        break;\n    }\n}\n\nvoid\nlys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv), int free_subs, int remove_from_ctx)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!module) {\n        return;\n    }\n\n    /* remove schema from the context */\n    ctx = module->ctx;\n    if (remove_from_ctx && ctx->models.used) {\n        for (i = 0; i < ctx->models.used; i++) {\n            if (ctx->models.list[i] == module) {\n                /* move all the models to not change the order in the list */\n                ctx->models.used--;\n                memmove(&ctx->models.list[i], ctx->models.list[i + 1], (ctx->models.used - i) * sizeof *ctx->models.list);\n                ctx->models.list[ctx->models.used] = NULL;\n                /* we are done */\n                break;\n            }\n        }\n    }\n\n    /* common part with struct ly_submodule */\n    module_free_common(module, private_destructor);\n\n    /* include */\n    for (i = 0; i < module->inc_size; i++) {\n        lydict_remove(ctx, module->inc[i].dsc);\n        lydict_remove(ctx, module->inc[i].ref);\n        lys_extension_instances_free(ctx, module->inc[i].ext, module->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n        if (free_subs) {\n            lys_submodule_free(module->inc[i].submodule, private_destructor);\n        }\n    }\n    free(module->inc);\n\n    /* specific items to free */\n    lydict_remove(ctx, module->ns);\n\n    free(module);\n}\n\nstatic void\nlys_features_disable_recursive(struct lys_feature *f)\n{\n    unsigned int i;\n    struct lys_feature *depf;\n\n    /* disable the feature */\n    f->flags &= ~LYS_FENABLED;\n\n    /* by disabling feature we have to disable also all features that depends on this feature */\n    if (f->depfeatures) {\n        for (i = 0; i < f->depfeatures->number; i++) {\n            depf = (struct lys_feature *)f->depfeatures->set.g[i];\n            if (depf->flags & LYS_FENABLED) {\n                lys_features_disable_recursive(depf);\n            }\n        }\n    }\n}\n\n/*\n * op: 1 - enable, 0 - disable\n */\nstatic int\nlys_features_change(const struct lys_module *module, const char *name, int op)\n{\n    int all = 0;\n    int i, j, k;\n    int progress, faili, failj, failk;\n\n    uint8_t fsize;\n    struct lys_feature *f;\n\n    if (!module || !name || !strlen(name)) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!strcmp(name, \"*\")) {\n        /* enable all */\n        all = 1;\n    }\n\n    progress = failk = 1;\n    while (progress && failk) {\n        for (i = -1, failk = progress = 0; i < module->inc_size; i++) {\n            if (i == -1) {\n                fsize = module->features_size;\n                f = module->features;\n            } else {\n                fsize = module->inc[i].submodule->features_size;\n                f = module->inc[i].submodule->features;\n            }\n\n            for (j = 0; j < fsize; j++) {\n                if (all || !strcmp(f[j].name, name)) {\n                    if ((op && (f[j].flags & LYS_FENABLED)) || (!op && !(f[j].flags & LYS_FENABLED))) {\n                        if (all) {\n                            /* skip already set features */\n                            continue;\n                        } else {\n                            /* feature already set correctly */\n                            return EXIT_SUCCESS;\n                        }\n                    }\n\n                    if (op) {\n                        /* check referenced features if they are enabled */\n                        for (k = 0; k < f[j].iffeature_size; k++) {\n                            if (!resolve_iffeature(&f[j].iffeature[k])) {\n                                if (all) {\n                                    faili = i;\n                                    failj = j;\n                                    failk = k + 1;\n                                    break;\n                                } else {\n                                    LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                           f[j].name, k + 1);\n                                    return EXIT_FAILURE;\n                                }\n                            }\n                        }\n\n                        if (k == f[j].iffeature_size) {\n                            /* the last check passed, do the change */\n                            f[j].flags |= LYS_FENABLED;\n                            progress++;\n                        }\n                    } else {\n                        lys_features_disable_recursive(&f[j]);\n                        progress++;\n                    }\n                    if (!all) {\n                        /* stop in case changing a single feature */\n                        return EXIT_SUCCESS;\n                    }\n                }\n            }\n        }\n    }\n    if (failk) {\n        /* print info about the last failing feature */\n        LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n               faili == -1 ? module->features[failj].name : module->inc[faili].submodule->features[failj].name, failk);\n        return EXIT_FAILURE;\n    }\n\n    if (all) {\n        return EXIT_SUCCESS;\n    } else {\n        /* the specified feature not found */\n        return EXIT_FAILURE;\n    }\n}\n\nAPI int\nlys_features_enable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 1);\n}\n\nAPI int\nlys_features_disable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 0);\n}\n\nAPI int\nlys_features_state(const struct lys_module *module, const char *feature)\n{\n    int i, j;\n\n    if (!module || !feature) {\n        return -1;\n    }\n\n    /* search for the specified feature */\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(feature, module->features[i].name)) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            if (!strcmp(feature, module->inc[j].submodule->features[i].name)) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    /* feature definition not found */\n    return -1;\n}\n\nAPI const char **\nlys_features_list(const struct lys_module *module, uint8_t **states)\n{\n    const char **result = NULL;\n    int i, j;\n    unsigned int count;\n\n    if (!module) {\n        return NULL;\n    }\n\n    count = module->features_size;\n    for (i = 0; i < module->inc_size; i++) {\n        count += module->inc[i].submodule->features_size;\n    }\n    result = malloc((count + 1) * sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(module->ctx), NULL);\n\n    if (states) {\n        *states = malloc((count + 1) * sizeof **states);\n        LY_CHECK_ERR_RETURN(!(*states), LOGMEM(module->ctx); free(result), NULL);\n    }\n    count = 0;\n\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        result[count] = module->features[i].name;\n        if (states) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                (*states)[count] = 1;\n            } else {\n                (*states)[count] = 0;\n            }\n        }\n        count++;\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            result[count] = module->inc[j].submodule->features[i].name;\n            if (states) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    (*states)[count] = 1;\n                } else {\n                    (*states)[count] = 0;\n                }\n            }\n            count++;\n        }\n    }\n\n    /* terminating NULL byte */\n    result[count] = NULL;\n\n    return result;\n}\n\nAPI struct lys_module *\nlys_node_module(const struct lys_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->module->type ? ((struct lys_submodule *)node->module)->belongsto : node->module;\n}\n\nAPI struct lys_module *\nlys_main_module(const struct lys_module *module)\n{\n    if (!module) {\n        return NULL;\n    }\n\n    return (module->type ? ((struct lys_submodule *)module)->belongsto : (struct lys_module *)module);\n}\n\nAPI struct lys_node *\nlys_parent(const struct lys_node *node)\n{\n    struct lys_node *parent;\n\n    if (!node) {\n        return NULL;\n    }\n\n    if (node->nodetype == LYS_EXT) {\n        if (((struct lys_ext_instance_complex*)node)->parent_type != LYEXT_PAR_NODE) {\n            return NULL;\n        }\n        parent = (struct lys_node*)((struct lys_ext_instance_complex*)node)->parent;\n    } else if (!node->parent) {\n        return NULL;\n    } else {\n        parent = node->parent;\n    }\n\n    if (parent->nodetype == LYS_AUGMENT) {\n        return ((struct lys_node_augment *)parent)->target;\n    } else {\n        return parent;\n    }\n}\n\nstruct lys_node **\nlys_child(const struct lys_node *node, LYS_NODE nodetype)\n{\n    void *pp;\n    assert(node);\n\n    if (node->nodetype == LYS_EXT) {\n        pp = lys_ext_complex_get_substmt(lys_snode2stmt(nodetype), (struct lys_ext_instance_complex*)node, NULL);\n        if (!pp) {\n            return NULL;\n        }\n        return (struct lys_node **)pp;\n    } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n        return NULL;\n    } else {\n        return (struct lys_node **)&node->child;\n    }\n}\n\nAPI void *\nlys_set_private(const struct lys_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lys_node *)node)->priv = priv;\n\n    return prev;\n}\n\nint\nlys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref)\n{\n    struct lys_node_leaf *iter;\n    struct ly_ctx *ctx = leafref_target->module->ctx;\n\n    if (!(leafref_target->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGINT(ctx);\n        return -1;\n    }\n\n    /* check for config flag */\n    if (((struct lys_node_leaf*)leafref)->type.info.lref.req != -1 &&\n            (leafref->flags & LYS_CONFIG_W) && (leafref_target->flags & LYS_CONFIG_R)) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, leafref,\n               \"The leafref %s is config but refers to a non-config %s.\",\n               strnodetype(leafref->nodetype), strnodetype(leafref_target->nodetype));\n        return -1;\n    }\n    /* check for cycles */\n    for (iter = leafref_target; iter && iter->type.base == LY_TYPE_LEAFREF; iter = iter->type.info.lref.target) {\n        if ((void *)iter == (void *)leafref) {\n            /* cycle detected */\n            LOGVAL(ctx, LYE_CIRC_LEAFREFS, LY_VLOG_LYS, leafref);\n            return -1;\n        }\n    }\n\n    /* create fake child - the ly_set structure to hold the list of\n     * leafrefs referencing the leaf(-list) */\n    if (!leafref_target->backlinks) {\n        leafref_target->backlinks = (void *)ly_set_new();\n        if (!leafref_target->backlinks) {\n            LOGMEM(ctx);\n            return -1;\n        }\n    }\n    ly_set_add(leafref_target->backlinks, leafref, 0);\n\n    return 0;\n}\n\n/* not needed currently */\n#if 0\n\nstatic const char *\nlys_data_path_reverse(const struct lys_node *node, char * const buf, uint32_t buf_len)\n{\n    struct lys_module *prev_mod;\n    uint32_t str_len, mod_len, buf_idx;\n\n    if (!(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGINT;\n        return NULL;\n    }\n\n    buf_idx = buf_len - 1;\n    buf[buf_idx] = '\\0';\n\n    while (node) {\n        if (lys_parent(node)) {\n            prev_mod = lys_node_module(lys_parent(node));\n        } else {\n            prev_mod = NULL;\n        }\n\n        if (node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            str_len = strlen(node->name);\n\n            if (prev_mod != node->module) {\n                mod_len = strlen(node->module->name);\n            } else {\n                mod_len = 0;\n            }\n\n            if (buf_idx < 1 + (mod_len ? mod_len + 1 : 0) + str_len) {\n                LOGINT;\n                return NULL;\n            }\n\n            buf_idx -= 1 + (mod_len ? mod_len + 1 : 0) + str_len;\n\n            buf[buf_idx] = '/';\n            if (mod_len) {\n                memcpy(buf + buf_idx + 1, node->module->name, mod_len);\n                buf[buf_idx + 1 + mod_len] = ':';\n            }\n            memcpy(buf + buf_idx + 1 + (mod_len ? mod_len + 1 : 0), node->name, str_len);\n        }\n\n        node = lys_parent(node);\n    }\n\n    return buf + buf_idx;\n}\n\n#endif\n\nAPI struct ly_set *\nlys_xpath_atomize(const struct lys_node *ctx_node, enum lyxp_node_type ctx_node_type, const char *expr, int options)\n{\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint32_t i;\n\n    if (!ctx_node || !expr) {\n        LOGARG;\n        return NULL;\n    }\n\n    /* adjust the root */\n    if ((ctx_node_type == LYXP_NODE_ROOT) || (ctx_node_type == LYXP_NODE_ROOT_CONFIG)) {\n        do {\n            ctx_node = lys_getnext(NULL, NULL, lys_node_module(ctx_node), LYS_GETNEXT_NOSTATECHECK);\n        } while ((ctx_node_type == LYXP_NODE_ROOT_CONFIG) && (ctx_node->flags & LYS_CONFIG_R));\n    }\n\n    memset(&set, 0, sizeof set);\n\n    if (options & LYXP_MUST) {\n        options &= ~LYXP_MUST;\n        options |= LYXP_SNODE_MUST;\n    } else if (options & LYXP_WHEN) {\n        options &= ~LYXP_WHEN;\n        options |= LYXP_SNODE_WHEN;\n    } else {\n        options |= LYXP_SNODE;\n    }\n\n    if (lyxp_atomize(expr, ctx_node, ctx_node_type, &set, options, NULL)) {\n        free(set.val.snodes);\n        LOGVAL(ctx_node->module->ctx, LYE_SPEC, LY_VLOG_LYS, ctx_node, \"Resolving XPath expression \\\"%s\\\" failed.\", expr);\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n\n    for (i = 0; i < set.used; ++i) {\n        switch (set.val.snodes[i].type) {\n        case LYXP_NODE_ELEM:\n            if (ly_set_add(ret_set, set.val.snodes[i].snode, LY_SET_OPT_USEASLIST) == -1) {\n                ly_set_free(ret_set);\n                free(set.val.snodes);\n                return NULL;\n            }\n            break;\n        default:\n            /* ignore roots, text and attr should not ever appear */\n            break;\n        }\n    }\n\n    free(set.val.snodes);\n    return ret_set;\n}\n\nAPI struct ly_set *\nlys_node_xpath_atomize(const struct lys_node *node, int options)\n{\n    const struct lys_node *next, *elem, *parent, *tmp;\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    for (parent = node; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n    if (!parent) {\n        /* not in input, output, or notification */\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n    if (!ret_set) {\n        return NULL;\n    }\n\n    LY_TREE_DFS_BEGIN(node, next, elem) {\n        if ((options & LYXP_NO_LOCAL) && !(elem->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))) {\n            /* elem has no dependencies from other subtrees and local nodes get discarded */\n            goto next_iter;\n        }\n\n        if (lyxp_node_atomize(elem, &set, 0)) {\n            ly_set_free(ret_set);\n            free(set.val.snodes);\n            return NULL;\n        }\n\n        for (i = 0; i < set.used; ++i) {\n            switch (set.val.snodes[i].type) {\n            case LYXP_NODE_ELEM:\n                if (options & LYXP_NO_LOCAL) {\n                    for (tmp = set.val.snodes[i].snode; tmp && (tmp != parent); tmp = lys_parent(tmp));\n                    if (tmp) {\n                        /* in local subtree, discard */\n                        break;\n                    }\n                }\n                if (ly_set_add(ret_set, set.val.snodes[i].snode, 0) == -1) {\n                    ly_set_free(ret_set);\n                    free(set.val.snodes);\n                    return NULL;\n                }\n                break;\n            default:\n                /* ignore roots, text and attr should not ever appear */\n                break;\n            }\n        }\n\n        free(set.val.snodes);\n        if (!(options & LYXP_RECURSIVE)) {\n            break;\n        }\nnext_iter:\n        LY_TREE_DFS_END(node, next, elem);\n    }\n\n    return ret_set;\n}\n\n/* logs */\nint\napply_aug(struct lys_node_augment *augment, struct unres_schema *unres)\n{\n    struct lys_node *child, *parent;\n    int clear_config;\n    unsigned int u;\n    uint8_t *v;\n    struct lys_ext_instance *ext;\n\n    assert(augment->target && (augment->flags & LYS_NOTAPPLIED));\n\n    if (!augment->child) {\n        /* nothing to apply */\n        goto success;\n    }\n\n    /* inherit config information from actual parent */\n    for (parent = augment->target; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); parent = lys_parent(parent));\n    clear_config = (parent) ? 1 : 0;\n    LY_TREE_FOR(augment->child, child) {\n        if (inherit_config_flag(child, augment->target->flags & LYS_CONFIG_MASK, clear_config)) {\n            return -1;\n        }\n    }\n\n    /* inherit extensions if any */\n    for (u = 0; u < augment->target->ext_size; u++) {\n        ext = augment->target->ext[u]; /* shortcut */\n        if (ext && ext->def->plugin && (ext->def->plugin->flags & LYEXT_OPT_INHERIT)) {\n            v = malloc(sizeof *v);\n            LY_CHECK_ERR_RETURN(!v, LOGMEM(augment->module->ctx), -1);\n            *v = u;\n            if (unres_schema_add_node(lys_main_module(augment->module), unres, &augment->target->ext,\n                    UNRES_EXT_FINALIZE, (struct lys_node *)v) == -1) {\n                /* something really bad happend since the extension finalization is not actually\n                 * being resolved while adding into unres, so something more serious with the unres\n                 * list itself must happened */\n                return -1;\n            }\n        }\n    }\n\n    /* reconnect augmenting data into the target - add them to the target child list */\n    if (augment->target->child) {\n        child = augment->target->child->prev;\n        child->next = augment->child;\n        augment->target->child->prev = augment->child->prev;\n        augment->child->prev = child;\n    } else {\n        augment->target->child = augment->child;\n    }\n\nsuccess:\n    /* remove the flag about not applicability */\n    augment->flags &= ~LYS_NOTAPPLIED;\n    return EXIT_SUCCESS;\n}\n\nstatic void\nremove_aug(struct lys_node_augment *augment)\n{\n    struct lys_node *last, *elem;\n\n    if ((augment->flags & LYS_NOTAPPLIED) || !augment->target) {\n        /* skip already not applied augment */\n        return;\n    }\n\n    elem = augment->child;\n    if (elem) {\n        LY_TREE_FOR(elem, last) {\n            if (!last->next || (last->next->parent != (struct lys_node *)augment)) {\n                break;\n            }\n        }\n        /* elem is first augment child, last is the last child */\n\n        /* parent child ptr */\n        if (augment->target->child == elem) {\n            augment->target->child = last->next;\n        }\n\n        /* parent child next ptr */\n        if (elem->prev->next) {\n            elem->prev->next = last->next;\n        }\n\n        /* parent child prev ptr */\n        if (last->next) {\n            last->next->prev = elem->prev;\n        } else if (augment->target->child) {\n            augment->target->child->prev = elem->prev;\n        }\n\n        /* update augment children themselves */\n        elem->prev = last;\n        last->next = NULL;\n    }\n\n    /* augment->target still keeps the resolved target, but for lys_augment_free()\n     * we have to keep information that this augment is not applied to free its data */\n    augment->flags |= LYS_NOTAPPLIED;\n}\n\n/*\n * @param[in] module - the module where the deviation is defined\n */\nstatic void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct lys_node_inout *inout;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent && (parent->nodetype == LYS_AUGMENT)) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n                        assert(lys_node_module(parent)->implemented);\n                        parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                        apply_aug((struct lys_node_augment *)parent, unres);\n                    }\n                } else if (parent && (parent->nodetype == LYS_USES)) {\n                    /* uses child */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT(module->ctx);\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node, 0);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, lys_node_module(dev->orig_node), dev->orig_node, 0);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT(module->ctx);\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent) {\n                if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                    /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                     * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                     * path), so we need to remember the augment as an addition */\n                    /* we also need to remember the parent uses so that we connect it back to it when switching deviation state */\n                    target->parent = parent;\n                } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                    /* re-create implicit node */\n                    inout = calloc(1, sizeof *inout);\n                    LY_CHECK_ERR_RETURN(!inout, LOGMEM(module->ctx), );\n\n                    inout->nodetype = target->nodetype;\n                    inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                    inout->module = target->module;\n                    inout->flags = LYS_IMPLICIT;\n\n                    /* insert it manually */\n                    assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                    parent->child->next = (struct lys_node *)inout;\n                    inout->prev = parent->child;\n                    parent->child->prev = (struct lys_node *)inout;\n                    inout->parent = parent;\n                }\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT(module->ctx);\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        /* contents are switched */\n        lys_node_switch(target, dev->orig_node);\n    }\n}\n\n/* temporarily removes or applies deviations, updates module deviation flag accordingly */\nvoid\nlys_enable_deviations(struct lys_module *module)\n{\n    uint32_t i = 0, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        while ((mod = ly_ctx_get_module_iter(module->ctx, &i))) {\n            if (mod == module) {\n                continue;\n            }\n\n            for (j = 0; j < mod->deviation_size; ++j) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 2);\n        module->deviated = 1;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nvoid\nlys_disable_deviations(struct lys_module *module)\n{\n    uint32_t i, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        i = module->ctx->models.used;\n        while (i--) {\n            mod = module->ctx->models.list[i];\n\n            if (mod == module) {\n                continue;\n            }\n\n            j = mod->deviation_size;\n            while (j--) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 1);\n        module->deviated = 2;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nstatic void\napply_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    lys_switch_deviation(dev, module, unres);\n\n    assert(dev->orig_node);\n    lys_node_module(dev->orig_node)->deviated = 1; /* main module */\n    dev->orig_node->module->deviated = 1;          /* possible submodule */\n}\n\nstatic void\nremove_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t idx = 0, j;\n    const struct lys_module *mod;\n    struct lys_module *target_mod, *target_submod;\n    const char *ptr;\n\n    if (dev->orig_node) {\n        target_mod = lys_node_module(dev->orig_node);\n        target_submod = dev->orig_node->module;\n    } else {\n        LOGINT(module->ctx);\n        return;\n    }\n    lys_switch_deviation(dev, module, unres);\n\n    /* clear the deviation flag if possible */\n    while ((mod = ly_ctx_get_module_iter(module->ctx, &idx))) {\n        if ((mod == module) || (mod == target_mod)) {\n            continue;\n        }\n\n        for (j = 0; j < mod->deviation_size; ++j) {\n            ptr = strstr(mod->deviation[j].target_name, target_mod->name);\n            if (ptr && (ptr[strlen(target_mod->name)] == ':')) {\n                /* some other module deviation targets the inspected module, flag remains */\n                break;\n            }\n        }\n\n        if (j < mod->deviation_size) {\n            break;\n        }\n    }\n\n    if (!mod) {\n        target_mod->deviated = 0;    /* main module */\n        target_submod->deviated = 0; /* possible submodule */\n    }\n}\n\nvoid\nlys_sub_module_apply_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v;\n    struct unres_schema *unres;\n\n    assert(module->implemented);\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* apply deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        apply_dev(&module->deviation[u], module, unres);\n    }\n    /* apply augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        apply_aug(&module->augment[u], unres);\n    }\n\n    /* apply deviations and augments defined in submodules */\n    for (v = 0; v < module->inc_size; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            apply_dev(&module->inc[v].submodule->deviation[u], module, unres);\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            apply_aug(&module->inc[v].submodule->augment[u], unres);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nvoid\nlys_sub_module_remove_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v, w;\n    struct unres_schema *unres;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* remove applied deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        /* the deviation could not be applied because it failed to be applied in the first place*/\n        if (module->deviation[u].orig_node) {\n            remove_dev(&module->deviation[u], module, unres);\n        }\n\n        /* Free the deviation's must array(s). These are shallow copies of the arrays\n           on the target node(s), so a deep free is not needed. */\n        for (v = 0; v < module->deviation[u].deviate_size; ++v) {\n            if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {\n                free(module->deviation[u].deviate[v].must);\n            }\n        }\n    }\n    /* remove applied augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        remove_aug(&module->augment[u]);\n    }\n\n    /* remove deviation and augments defined in submodules */\n    for (v = 0; v < module->inc_size && module->inc[v].submodule; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            if (module->inc[v].submodule->deviation[u].orig_node) {\n                remove_dev(&module->inc[v].submodule->deviation[u], module, unres);\n            }\n\n            /* Free the deviation's must array(s). These are shallow copies of the arrays\n               on the target node(s), so a deep free is not needed. */\n            for (w = 0; w < module->inc[v].submodule->deviation[u].deviate_size; ++w) {\n                if (module->inc[v].submodule->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {\n                    free(module->inc[v].submodule->deviation[u].deviate[w].must);\n                }\n            }\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            remove_aug(&module->inc[v].submodule->augment[u]);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nint\nlys_make_implemented_r(struct lys_module *module, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *root, *next, *node;\n    struct lys_module *target_module;\n    uint16_t i, j, k;\n\n    assert(module->implemented);\n    ctx = module->ctx;\n\n    for (i = 0; i < ctx->models.used; ++i) {\n        if (module == ctx->models.list[i]) {\n            continue;\n        }\n\n        if (!strcmp(module->name, ctx->models.list[i]->name) && ctx->models.list[i]->implemented) {\n            LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" in another revision already implemented.\", module->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    for (i = 0; i < module->augment_size; i++) {\n\n        /* make target module implemented if was not */\n        assert(module->augment[i].target);\n        target_module = lys_node_module(module->augment[i].target);\n        if (!target_module->implemented) {\n            target_module->implemented = 1;\n            if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                return -1;\n            }\n        }\n\n        /* apply augment */\n        if ((module->augment[i].flags & LYS_NOTAPPLIED) && apply_aug(&module->augment[i], unres)) {\n            return -1;\n        }\n    }\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        for (j = 0; j < module->ident[i].base_size; j++) {\n            resolve_identity_backlink_update(&module->ident[i], module->ident[i].base[j]);\n        }\n    }\n\n    /* process augments in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; ++i) {\n        module->inc[i].submodule->implemented = 1;\n\n        for (j = 0; j < module->inc[i].submodule->augment_size; j++) {\n\n            /* make target module implemented if it was not */\n            assert(module->inc[i].submodule->augment[j].target);\n            target_module = lys_node_module(module->inc[i].submodule->augment[j].target);\n            if (!target_module->implemented) {\n                target_module->implemented = 1;\n                if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n\n            /* apply augment */\n            if ((module->inc[i].submodule->augment[j].flags & LYS_NOTAPPLIED) && apply_aug(&module->inc[i].submodule->augment[j], unres)) {\n                return -1;\n            }\n        }\n\n        /* identities */\n        for (j = 0; j < module->inc[i].submodule->ident_size; j++) {\n            for (k = 0; k < module->inc[i].submodule->ident[j].base_size; k++) {\n                resolve_identity_backlink_update(&module->inc[i].submodule->ident[j],\n                                                 module->inc[i].submodule->ident[j].base[k]);\n            }\n        }\n    }\n\n    LY_TREE_FOR(module->data, root) {\n        /* handle leafrefs and recursively change the implemented flags in the leafref targets */\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_GROUPING) {\n                goto nextsibling;\n            }\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                if (((struct lys_node_leaf *)node)->type.base == LY_TYPE_LEAFREF) {\n                    if (unres_schema_add_node(module, unres, &((struct lys_node_leaf *)node)->type,\n                                              UNRES_TYPE_LEAFREF, node) == -1) {\n                        return -1;\n                    }\n                }\n            }\n\n            /* modified LY_TREE_DFS_END */\n            next = node->child;\n            /* child exception for leafs, leaflists and anyxml without children */\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                next = NULL;\n            }\n            if (!next) {\nnextsibling:\n                /* no children */\n                if (node == root) {\n                    /* we are done, root has no children */\n                    break;\n                }\n                /* try siblings */\n                next = node->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                node = lys_parent(node);\n                /* no siblings, go back through parents */\n                if (lys_parent(node) == lys_parent(root)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = node->next;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlys_set_implemented(const struct lys_module *module)\n{\n    struct unres_schema *unres;\n    int disabled = 0;\n\n    if (!module) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    module = lys_main_module(module);\n\n    if (module->disabled) {\n        disabled = 1;\n        lys_set_enabled(module);\n    }\n\n    if (module->implemented) {\n        return EXIT_SUCCESS;\n    }\n\n    unres = calloc(1, sizeof *unres);\n    if (!unres) {\n        LOGMEM(module->ctx);\n        if (disabled) {\n            /* set it back disabled */\n            lys_set_disabled(module);\n        }\n        return EXIT_FAILURE;\n    }\n    /* recursively make the module implemented */\n    ((struct lys_module *)module)->implemented = 1;\n    if (lys_make_implemented_r((struct lys_module *)module, unres)) {\n        goto error;\n    }\n\n    /* try again resolve augments in other modules possibly augmenting this one,\n     * since we have just enabled it\n     */\n    /* resolve rest of unres items */\n    if (unres->count && resolve_unres_schema((struct lys_module *)module, unres)) {\n        goto error;\n    }\n    unres_schema_free(NULL, &unres, 0);\n\n    LOGVRB(\"Module \\\"%s%s%s\\\" now implemented.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"));\n    return EXIT_SUCCESS;\n\nerror:\n    if (disabled) {\n        /* set it back disabled */\n        lys_set_disabled(module);\n    }\n\n    ((struct lys_module *)module)->implemented = 0;\n    unres_schema_free((struct lys_module *)module, &unres, 1);\n    return EXIT_FAILURE;\n}\n\nvoid\nlys_submodule_module_data_free(struct lys_submodule *submodule)\n{\n    struct lys_node *next, *elem;\n\n    /* remove parsed data */\n    LY_TREE_FOR_SAFE(submodule->belongsto->data, next, elem) {\n        if (elem->module == (struct lys_module *)submodule) {\n            lys_node_free(elem, NULL, 0);\n        }\n    }\n}\n\nAPI char *\nlys_path(const struct lys_node *node, int options)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYS, node, &buf, (options & LYS_PATH_FIRST_PREFIX) ? 0 : 1, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nAPI char *\nlys_data_path(const struct lys_node *node)\n{\n    char *result = NULL, buf[1024];\n    const char *separator, *name;\n    int i, used;\n    struct ly_set *set;\n    const struct lys_module *prev_mod;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    buf[0] = '\\0';\n    set = ly_set_new();\n    LY_CHECK_ERR_GOTO(!set, LOGMEM(node->module->ctx), cleanup);\n\n    while (node) {\n        ly_set_add(set, (void *)node, 0);\n        do {\n            node = lys_parent(node);\n        } while (node && (node->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    }\n\n    prev_mod = NULL;\n    used = 0;\n    for (i = set->number - 1; i > -1; --i) {\n        node = set->set.s[i];\n        if (node->nodetype == LYS_EXT) {\n            if (strcmp(((struct lys_ext_instance *)node)->def->name, \"yang-data\")) {\n                continue;\n            }\n            name = ((struct lys_ext_instance *)node)->arg_value;\n            separator = \":#\";\n        } else {\n            name = node->name;\n            separator = \":\";\n        }\n        used += sprintf(buf + used, \"/%s%s%s\", (lys_node_module(node) == prev_mod ? \"\" : lys_node_module(node)->name),\n                        (lys_node_module(node) == prev_mod ? \"\" : separator), name);\n        prev_mod = lys_node_module(node);\n    }\n\n    result = strdup(buf);\n    LY_CHECK_ERR_GOTO(!result, LOGMEM(node->module->ctx), cleanup);\n\ncleanup:\n    ly_set_free(set);\n    return result;\n}\n\nstruct lys_node_augment *\nlys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod, const struct lys_node *aug_target)\n{\n    struct lys_node *child;\n    struct lys_node_augment *aug;\n    int i, j, last_found;\n\n    assert(mod && aug_target);\n\n    if (!last) {\n        last_found = 1;\n    } else {\n        last_found = 0;\n    }\n\n    /* search module augments */\n    for (i = 0; i < mod->augment_size; ++i) {\n        if (!mod->augment[i].target) {\n            /* still unresolved, skip */\n            continue;\n        }\n\n        if (mod->augment[i].target == aug_target) {\n            if (last_found) {\n                /* next match after last */\n                return &mod->augment[i];\n            }\n\n            if (&mod->augment[i] == last) {\n                last_found = 1;\n            }\n        }\n    }\n\n    /* search submodule augments */\n    for (i = 0; i < mod->inc_size; ++i) {\n        for (j = 0; j < mod->inc[i].submodule->augment_size; ++j) {\n            if (!mod->inc[i].submodule->augment[j].target) {\n                continue;\n            }\n\n            if (mod->inc[i].submodule->augment[j].target == aug_target) {\n                if (last_found) {\n                    /* next match after last */\n                    return &mod->inc[i].submodule->augment[j];\n                }\n\n                if (&mod->inc[i].submodule->augment[j] == last) {\n                    last_found = 1;\n                }\n            }\n        }\n    }\n\n    /* we also need to check possible augments to choices */\n    LY_TREE_FOR(aug_target->child, child) {\n        if (child->nodetype == LYS_CHOICE) {\n            aug = lys_getnext_target_aug(last, mod, child);\n            if (aug) {\n                return aug;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nAPI struct ly_set *\nlys_find_path(const struct lys_module *cur_module, const struct lys_node *cur_node, const char *path)\n{\n    struct ly_set *ret;\n    int rc;\n\n    if ((!cur_module && !cur_node) || !path) {\n        return NULL;\n    }\n\n    rc = resolve_schema_nodeid(path, cur_node, cur_module, &ret, 1, 1);\n    if (rc == -1) {\n        return NULL;\n    }\n\n    return ret;\n}\n\nstatic void\nlys_extcomplex_free_str(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    const char **str, ***a;\n    int c;\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || !(*str)) {\n        return;\n    }\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* we have array */\n        a = (const char ***)str;\n        for (str = (*(const char ***)str), c = 0; str[c]; c++) {\n            lydict_remove(ctx, str[c]);\n        }\n        free(a[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            for (str = a[1], c = 0; str[c]; c++) {\n                lydict_remove(ctx, str[c]);\n            }\n            free(a[1]);\n        } else if (stmt == LY_STMT_ARGUMENT) {\n            free(a[1]);\n        }\n    } else {\n        lydict_remove(ctx, str[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            lydict_remove(ctx, str[1]);\n        }\n    }\n}\n\nvoid\nlys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i, j, k;\n    struct lyext_substmt *substmt;\n    void **pp, **start;\n    struct lys_node *siter, *snext;\n\n#define EXTCOMPLEX_FREE_STRUCT(STMT, TYPE, FUNC, FREE, ARGS...)                               \\\n    pp = lys_ext_complex_get_substmt(STMT, (struct lys_ext_instance_complex *)e[i], NULL);    \\\n    if (!pp || !(*pp)) { break; }                                                             \\\n    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */                    \\\n        for (start = pp = *pp; *pp; pp++) {                                                   \\\n            FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                             \\\n            if (FREE) { free(*pp); }                                                          \\\n        }                                                                                     \\\n        free(start);                                                                          \\\n    } else { /* single item */                                                                \\\n        FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                                 \\\n        if (FREE) { free(*pp); }                                                              \\\n    }\n\n    if (!size || !e) {\n        return;\n    }\n\n    for (i = 0; i < size; i++) {\n        if (!e[i]) {\n            continue;\n        }\n\n        if (e[i]->flags & (LYEXT_OPT_INHERIT)) {\n            /* no free, this is just a shadow copy of the original extension instance */\n        } else {\n            if (e[i]->flags & (LYEXT_OPT_YANG)) {\n                free(e[i]->def);     /* remove name of instance extension */\n                e[i]->def = NULL;\n                yang_free_ext_data((struct yang_ext_substmt *)e[i]->parent); /* remove backup part of yang file */\n            }\n            /* remove private object */\n            if (e[i]->priv && private_destructor) {\n                private_destructor((struct lys_node*)e[i], e[i]->priv);\n            }\n            lys_extension_instances_free(ctx, e[i]->ext, e[i]->ext_size, private_destructor);\n            lydict_remove(ctx, e[i]->arg_value);\n        }\n\n        if (e[i]->def && e[i]->def->plugin && e[i]->def->plugin->type == LYEXT_COMPLEX\n                && ((e[i]->flags & LYEXT_OPT_CONTENT) == 0)) {\n            substmt = ((struct lys_ext_instance_complex *)e[i])->substmt;\n            for (j = 0; substmt[j].stmt; j++) {\n                switch(substmt[j].stmt) {\n                case LY_STMT_DESCRIPTION:\n                case LY_STMT_REFERENCE:\n                case LY_STMT_UNITS:\n                case LY_STMT_ARGUMENT:\n                case LY_STMT_DEFAULT:\n                case LY_STMT_ERRTAG:\n                case LY_STMT_ERRMSG:\n                case LY_STMT_PREFIX:\n                case LY_STMT_NAMESPACE:\n                case LY_STMT_PRESENCE:\n                case LY_STMT_REVISIONDATE:\n                case LY_STMT_KEY:\n                case LY_STMT_BASE:\n                case LY_STMT_BELONGSTO:\n                case LY_STMT_CONTACT:\n                case LY_STMT_ORGANIZATION:\n                case LY_STMT_PATH:\n                    lys_extcomplex_free_str(ctx, (struct lys_ext_instance_complex *)e[i], substmt[j].stmt);\n                    break;\n                case LY_STMT_TYPE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPE, struct lys_type, lys_type_free, 1);\n                    break;\n                case LY_STMT_TYPEDEF:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPEDEF, struct lys_tpdf, lys_tpdf_free, 1);\n                    break;\n                case LY_STMT_IFFEATURE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_IFFEATURE, struct lys_iffeature, lys_iffeature_free, 0, 1, 0);\n                    break;\n                case LY_STMT_MAX:\n                case LY_STMT_MIN:\n                case LY_STMT_POSITION:\n                case LY_STMT_VALUE:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME && *pp) {\n                        for(k = 0; ((uint32_t**)(*pp))[k]; k++) {\n                            free(((uint32_t**)(*pp))[k]);\n                        }\n                    }\n                    free(*pp);\n                    break;\n                case LY_STMT_DIGITS:\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_MODULE:\n                    /* modules are part of the context, so they will be freed there */\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_ACTION:\n                case LY_STMT_ANYDATA:\n                case LY_STMT_ANYXML:\n                case LY_STMT_CASE:\n                case LY_STMT_CHOICE:\n                case LY_STMT_CONTAINER:\n                case LY_STMT_GROUPING:\n                case LY_STMT_INPUT:\n                case LY_STMT_LEAF:\n                case LY_STMT_LEAFLIST:\n                case LY_STMT_LIST:\n                case LY_STMT_NOTIFICATION:\n                case LY_STMT_OUTPUT:\n                case LY_STMT_RPC:\n                case LY_STMT_USES:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    LY_TREE_FOR_SAFE((struct lys_node *)(*pp), snext, siter) {\n                        lys_node_free(siter, NULL, 0);\n                    }\n                    *pp = NULL;\n                    break;\n                case LY_STMT_UNIQUE:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_UNIQUE, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                                lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                            }\n                            free((*(struct lys_unique**)pp)->expr);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                            lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                        }\n                        free((*(struct lys_unique**)pp)->expr);\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_LENGTH:\n                case LY_STMT_MUST:\n                case LY_STMT_PATTERN:\n                case LY_STMT_RANGE:\n                    EXTCOMPLEX_FREE_STRUCT(substmt[j].stmt, struct lys_restr, lys_restr_free, 1);\n                    break;\n                case LY_STMT_WHEN:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_WHEN, struct lys_when, lys_when_free, 0);\n                    break;\n                case LY_STMT_REVISION:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_REVISION, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                            lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                         (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                        lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                     (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                        free(*pp);\n                    }\n                    break;\n                default:\n                    /* nothing to free */\n                    break;\n                }\n            }\n        }\n\n        free(e[i]);\n    }\n    free(e);\n\n#undef EXTCOMPLEX_FREE_STRUCT\n}\n"], "filenames": ["src/tree_schema.c"], "buggy_code_start_loc": [1604], "buggy_code_end_loc": [1606], "fixing_code_start_loc": [1604], "fixing_code_end_loc": [1609], "type": "CWE-476", "message": "A NULL pointer dereference is present in libyang before v1.0-r3 in the function lys_extension_instances_free() due to a copy of unresolved extensions in lys_restr_dup(). Applications that use libyang to parse untrusted input yang files may crash.", "other": {"cve": {"id": "CVE-2019-20398", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-22T22:15:10.627", "lastModified": "2020-01-23T20:13:02.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference is present in libyang before v1.0-r3 in the function lys_extension_instances_free() due to a copy of unresolved extensions in lys_restr_dup(). Applications that use libyang to parse untrusted input yang files may crash."}, {"lang": "es", "value": "Una desreferencia del puntero NULL est\u00e1 presente en libyang versiones anteriores a v1.0-r3, en la funci\u00f3n lys_extension_instances_free() debido a una copia de extensiones no resuelta en la funci\u00f3n lys_restr_dup(). Las aplicaciones que usan libyang para analizar archivos de entrada yang no confiables pueden bloquearse."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r1:*:*:*:*:*:*", "matchCriteriaId": "65E91322-5F67-43C2-8112-5ECAEC2A3C12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r2:*:*:*:*:*:*", "matchCriteriaId": "80A88DE4-93F8-40C3-AA52-A5F353F028AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r1:*:*:*:*:*:*", "matchCriteriaId": "05C120CA-50EF-4B6D-92C9-ED736219DB07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r2:*:*:*:*:*:*", "matchCriteriaId": "99D1FA55-3F56-4E09-B41E-B05C199B96B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r1:*:*:*:*:*:*", "matchCriteriaId": "35D48EC4-58D2-49C6-8049-920787733587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r2:*:*:*:*:*:*", "matchCriteriaId": "B57F3953-49D6-413C-A4AE-03125935FC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.14:r1:*:*:*:*:*:*", "matchCriteriaId": "DD62411F-A524-4E80-B540-780EA39CB6A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.15:r1:*:*:*:*:*:*", "matchCriteriaId": "FEF091B1-978A-4881-B1FC-6848CD1A7BBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r1:*:*:*:*:*:*", "matchCriteriaId": "0C50D690-9A4D-4B78-BF4E-A4D9B4074216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r2:*:*:*:*:*:*", "matchCriteriaId": "124A5D30-7451-4516-9AA2-963AE62DD679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r3:*:*:*:*:*:*", "matchCriteriaId": "C260D13B-82E9-4596-9116-61073B42D661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r1:*:*:*:*:*:*", "matchCriteriaId": "5F8D5FC0-959E-4014-9CB7-91378CC8B2BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r2:*:*:*:*:*:*", "matchCriteriaId": "DCBDA519-805B-4193-8092-75E2748A7BC3"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793935", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/commit/7852b272ef77f8098c35deea6c6f09cb78176f08", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/CESNET/libyang/compare/v1.0-r2...v1.0-r3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/issues/773", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CESNET/libyang/commit/7852b272ef77f8098c35deea6c6f09cb78176f08"}}