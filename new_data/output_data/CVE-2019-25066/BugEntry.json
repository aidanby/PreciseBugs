{"buggy_code": ["import json\nimport logging\nimport pexpect\nimport pwd\nimport subprocess\nimport syslog\nfrom jadi import component, service, interface\n\nimport aj\nfrom aj.api.http import BaseHttpHandler\nfrom aj.security.verifier import ClientCertificateVerificator\nfrom aj.util import public\n\n\n@public\nclass SudoError(Exception):\n    def __init__(self, message):\n        Exception.__init__(self)\n        self.message = message\n\n    def __str__(self):\n        return self.message\n\n\n@public\nclass SecurityError(Exception):\n    def __init__(self, permission):\n        Exception.__init__(self)\n        self.message = 'Permission \"%s\" is required' % permission\n\n    def __str__(self):\n        return self.message\n\n\n@public\n@service\nclass AuthenticationMiddleware(BaseHttpHandler):\n    def __init__(self, context):\n        self.context = context\n        self.auth = AuthenticationService.get(self.context)\n        if not hasattr(context, 'identity'):\n            context.identity = None\n\n    def handle(self, http_context):\n        if http_context.env['SSL_CLIENT_VALID']:\n            if not self.context.identity:\n                username = http_context.env['SSL_CLIENT_USER']\n                logging.info(\n                    'SSL client certificate %s verified as %s',\n                    http_context.env['SSL_CLIENT_DIGEST'],\n                    username\n                )\n                try:\n                    pwd.getpwnam(username)\n                    found = True\n                except KeyError:\n                    found = False\n                if found:\n                    self.auth.login(username)\n\n        http_context.add_header('X-Auth-Identity', str(self.context.identity or ''))\n\n\nclass AuthenticationError(Exception):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return self.message\n\n\n@interface\nclass AuthenticationProvider(object):\n    id = None\n    name = None\n    allows_sudo_elevation = False\n\n    def __init__(self, context):\n        self.context = context\n\n    def authenticate(self, username, password):\n        raise NotImplementedError\n\n    def authorize(self, username, permission):\n        raise NotImplementedError\n\n    def get_isolation_uid(self, username):\n        raise NotImplementedError\n\n    def get_profile(self, username):\n        return {}\n\n\n@component(AuthenticationProvider)\nclass OSAuthenticationProvider(AuthenticationProvider):\n    id = 'os'\n    name = 'OS users'\n    allows_sudo_elevation = True\n\n    def authenticate(self, username, password):\n        child = None\n        try:\n            child = pexpect.spawn('/bin/sh', ['-c', '/bin/su -c \"/bin/echo SUCCESS\" - %s' % username], timeout=5)\n            child.expect('.*:')\n            child.sendline(password)\n            result = child.expect(['su: .*', 'SUCCESS'])\n        except Exception as err:\n            if child and child.isalive():\n                child.close()\n            logging.error('Error checking password: %s', err)\n            return False\n        if result == 0:\n            return False\n        else:\n            return True\n\n    def authorize(self, username, permission):\n        return True\n\n    def get_isolation_uid(self, username):\n        return pwd.getpwnam(username).pw_uid\n\n\n@public\n@service\nclass AuthenticationService(object):\n    def __init__(self, context):\n        self.context = context\n\n    def get_provider(self):\n        provider_id = aj.config.data['auth'].get('provider', 'os')\n        for provider in AuthenticationProvider.all(self.context):\n            if provider.id == provider_id:\n                return provider\n        raise AuthenticationError('Authentication provider %s is unavailable' % provider_id)\n\n    def check_password(self, username, password):\n        return self.get_provider().authenticate(username, password)\n\n    def check_sudo_password(self, username, password):\n        if not aj.config.data['auth'].get('allow_sudo', False):\n            return False\n        sudo = subprocess.Popen(\n            ['sudo', '-S', '-k', '-u', username, '--', 'ls'],\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        o, e = sudo.communicate(password + '\\n')\n        if sudo.returncode != 0:\n            raise SudoError((o + e).splitlines()[-1].strip())\n        return True\n\n    def client_certificate_callback(self, connection, x509, errno, depth, result):\n        if depth == 0 and (errno == 9 or errno == 10):\n            return False  # expired / not yet valid\n        if not aj.config.data['ssl']['client_auth']['force']:\n            return True\n        user = ClientCertificateVerificator.get(aj.context).verify(x509)\n        return bool(user)\n\n    def get_identity(self):\n        return self.context.identity\n\n    def login(self, username, demote=True):\n        logging.info('Authenticating session as %s', username)\n        syslog.syslog(syslog.LOG_NOTICE | syslog.LOG_AUTH, '%s has logged in from %s' % (\n            username,\n            self.context.session.client_info['address'],\n        ))\n        if demote:\n            uid = self.get_provider().get_isolation_uid(username)\n            logging.debug('Authentication provider \"%s\" maps \"%s\" -> %i' % (\n                self.get_provider().name,\n                username,\n                uid,\n            ))\n            self.context.worker.demote(uid)\n        self.context.identity = username\n\n    def prepare_session_redirect(self, http_context, username, auth_info):\n        http_context.add_header('X-Session-Redirect', username)\n        http_context.add_header('X-Auth-Info', auth_info)\n\n\n@public\n@interface\nclass PermissionProvider(object):\n    def __init__(self, context):\n        self.context = context\n\n    def provide(self):\n        return []\n\n\n@public\nclass authorize(object):\n    def __init__(self, permission_id):\n        self.permission_id = permission_id\n\n    def check(self):\n        username = aj.worker.context.identity\n        provider = AuthenticationService.get(aj.worker.context).get_provider()\n        for permission in [\n            p\n            for permission_provider in PermissionProvider.all(aj.worker.context)\n            for p in permission_provider.provide()\n        ]:\n            if permission['id'] == self.permission_id:\n                if provider.authorize(username, permission):\n                    break\n                else:\n                    raise SecurityError(self.permission_id)\n        else:\n            raise SecurityError(self.permission_id)\n\n    def __call__(self, fx):\n        def wrapper(*args, **kwargs):\n            self.check()\n            return fx(*args, **kwargs)\n        return wrapper\n\n    def __enter__(self):\n        self.check()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n"], "fixing_code": ["import json\nimport logging\nimport pexpect\nimport pwd\nimport subprocess\nimport syslog\nfrom jadi import component, service, interface\nfrom six import PY3\n\nimport aj\nfrom aj.api.http import BaseHttpHandler\nfrom aj.security.verifier import ClientCertificateVerificator\nfrom aj.util import public\n\n\n@public\nclass SudoError(Exception):\n    def __init__(self, message):\n        Exception.__init__(self)\n        self.message = message\n\n    def __str__(self):\n        return self.message\n\n\n@public\nclass SecurityError(Exception):\n    def __init__(self, permission):\n        Exception.__init__(self)\n        self.message = 'Permission \"%s\" is required' % permission\n\n    def __str__(self):\n        return self.message\n\n\n@public\n@service\nclass AuthenticationMiddleware(BaseHttpHandler):\n    def __init__(self, context):\n        self.context = context\n        self.auth = AuthenticationService.get(self.context)\n        if not hasattr(context, 'identity'):\n            context.identity = None\n\n    def handle(self, http_context):\n        if http_context.env['SSL_CLIENT_VALID']:\n            if not self.context.identity:\n                username = http_context.env['SSL_CLIENT_USER']\n                logging.info(\n                    'SSL client certificate %s verified as %s',\n                    http_context.env['SSL_CLIENT_DIGEST'],\n                    username\n                )\n                try:\n                    pwd.getpwnam(username)\n                    found = True\n                except KeyError:\n                    found = False\n                if found:\n                    self.auth.login(username)\n\n        http_context.add_header('X-Auth-Identity', str(self.context.identity or ''))\n\n\nclass AuthenticationError(Exception):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return self.message\n\n\n@interface\nclass AuthenticationProvider(object):\n    id = None\n    name = None\n    allows_sudo_elevation = False\n\n    def __init__(self, context):\n        self.context = context\n\n    def authenticate(self, username, password):\n        raise NotImplementedError\n\n    def authorize(self, username, permission):\n        raise NotImplementedError\n\n    def get_isolation_uid(self, username):\n        raise NotImplementedError\n\n    def get_profile(self, username):\n        return {}\n\n\n@component(AuthenticationProvider)\nclass OSAuthenticationProvider(AuthenticationProvider):\n    id = 'os'\n    name = 'OS users'\n    allows_sudo_elevation = True\n\n    def authenticate(self, username, password):\n        child = None\n\n        if PY3:\n            from shlex import quote\n        else:\n            from pipes import quote\n\n        try:\n            child = pexpect.spawn('/bin/sh', ['-c', '/bin/su -c \"/bin/echo SUCCESS\" - %s' % quote(username)], timeout=5)\n            child.expect('.*:')\n            child.sendline(password)\n            result = child.expect(['su: .*', 'SUCCESS'])\n        except Exception as err:\n            if child and child.isalive():\n                child.close()\n            logging.error('Error checking password: %s', err)\n            return False\n        if result == 0:\n            return False\n        else:\n            return True\n\n    def authorize(self, username, permission):\n        return True\n\n    def get_isolation_uid(self, username):\n        return pwd.getpwnam(username).pw_uid\n\n\n@public\n@service\nclass AuthenticationService(object):\n    def __init__(self, context):\n        self.context = context\n\n    def get_provider(self):\n        provider_id = aj.config.data['auth'].get('provider', 'os')\n        for provider in AuthenticationProvider.all(self.context):\n            if provider.id == provider_id:\n                return provider\n        raise AuthenticationError('Authentication provider %s is unavailable' % provider_id)\n\n    def check_password(self, username, password):\n        return self.get_provider().authenticate(username, password)\n\n    def check_sudo_password(self, username, password):\n        if not aj.config.data['auth'].get('allow_sudo', False):\n            return False\n        sudo = subprocess.Popen(\n            ['sudo', '-S', '-k', '-u', username, '--', 'ls'],\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        o, e = sudo.communicate(password + '\\n')\n        if sudo.returncode != 0:\n            raise SudoError((o + e).splitlines()[-1].strip())\n        return True\n\n    def client_certificate_callback(self, connection, x509, errno, depth, result):\n        if depth == 0 and (errno == 9 or errno == 10):\n            return False  # expired / not yet valid\n        if not aj.config.data['ssl']['client_auth']['force']:\n            return True\n        user = ClientCertificateVerificator.get(aj.context).verify(x509)\n        return bool(user)\n\n    def get_identity(self):\n        return self.context.identity\n\n    def login(self, username, demote=True):\n        logging.info('Authenticating session as %s', username)\n        syslog.syslog(syslog.LOG_NOTICE | syslog.LOG_AUTH, '%s has logged in from %s' % (\n            username,\n            self.context.session.client_info['address'],\n        ))\n        if demote:\n            uid = self.get_provider().get_isolation_uid(username)\n            logging.debug('Authentication provider \"%s\" maps \"%s\" -> %i' % (\n                self.get_provider().name,\n                username,\n                uid,\n            ))\n            self.context.worker.demote(uid)\n        self.context.identity = username\n\n    def prepare_session_redirect(self, http_context, username, auth_info):\n        http_context.add_header('X-Session-Redirect', username)\n        http_context.add_header('X-Auth-Info', auth_info)\n\n\n@public\n@interface\nclass PermissionProvider(object):\n    def __init__(self, context):\n        self.context = context\n\n    def provide(self):\n        return []\n\n\n@public\nclass authorize(object):\n    def __init__(self, permission_id):\n        self.permission_id = permission_id\n\n    def check(self):\n        username = aj.worker.context.identity\n        provider = AuthenticationService.get(aj.worker.context).get_provider()\n        for permission in [\n            p\n            for permission_provider in PermissionProvider.all(aj.worker.context)\n            for p in permission_provider.provide()\n        ]:\n            if permission['id'] == self.permission_id:\n                if provider.authorize(username, permission):\n                    break\n                else:\n                    raise SecurityError(self.permission_id)\n        else:\n            raise SecurityError(self.permission_id)\n\n    def __call__(self, fx):\n        def wrapper(*args, **kwargs):\n            self.check()\n            return fx(*args, **kwargs)\n        return wrapper\n\n    def __enter__(self):\n        self.check()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n"], "filenames": ["ajenti-core/aj/auth.py"], "buggy_code_start_loc": [7], "buggy_code_end_loc": [104], "fixing_code_start_loc": [8], "fixing_code_end_loc": [111], "type": "CWE-78", "message": "A vulnerability has been found in ajenti 2.1.31 and classified as critical. This vulnerability affects unknown code of the component API. The manipulation leads to privilege escalation. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 2.1.32 is able to address this issue. The name of the patch is 7aa146b724e0e20cfee2c71ca78fafbf53a8767c. It is recommended to upgrade the affected component.", "other": {"cve": {"id": "CVE-2019-25066", "sourceIdentifier": "cna@vuldb.com", "published": "2022-06-09T17:15:08.250", "lastModified": "2022-06-15T17:46:00.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in ajenti 2.1.31 and classified as critical. This vulnerability affects unknown code of the component API. The manipulation leads to privilege escalation. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 2.1.32 is able to address this issue. The name of the patch is 7aa146b724e0e20cfee2c71ca78fafbf53a8767c. It is recommended to upgrade the affected component."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en ajenti versi\u00f3n 2.1.31 y Ha sido clasificada como cr\u00edtica. Esta vulnerabilidad afecta a c\u00f3digo desconocido de la API del componente. La manipulaci\u00f3n conlleva a una escalada de privilegios. El ataque puede ser iniciado remotamente. La explotaci\u00f3n ha sido revelada al p\u00fablico y puede ser usada. La actualizaci\u00f3n a versi\u00f3n 2.1.32 puede abordar este problema. El nombre del parche es 7aa146b724e0e20cfee2c71ca78fafbf53a8767c. Se recomienda actualizar el componente afectado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ajenti:ajenti:2.1.31:*:*:*:*:*:*:*", "matchCriteriaId": "6C48D0AD-9C6E-403C-9375-1429C9C35412"}]}]}], "references": [{"url": "https://github.com/ajenti/ajenti/commit/7aa146b724e0e20cfee2c71ca78fafbf53a8767c", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.143950", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/47497", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/ajenti/ajenti/commit/7aa146b724e0e20cfee2c71ca78fafbf53a8767c"}}