{"buggy_code": ["/* Configuration file parsing and CONFIG GET/SET commands implementation.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/*-----------------------------------------------------------------------------\n * Config file name-value maps.\n *----------------------------------------------------------------------------*/\n\ntypedef struct configEnum {\n    const char *name;\n    const int val;\n} configEnum;\n\nconfigEnum maxmemory_policy_enum[] = {\n    {\"volatile-lru\", MAXMEMORY_VOLATILE_LRU},\n    {\"volatile-lfu\", MAXMEMORY_VOLATILE_LFU},\n    {\"volatile-random\",MAXMEMORY_VOLATILE_RANDOM},\n    {\"volatile-ttl\",MAXMEMORY_VOLATILE_TTL},\n    {\"allkeys-lru\",MAXMEMORY_ALLKEYS_LRU},\n    {\"allkeys-lfu\",MAXMEMORY_ALLKEYS_LFU},\n    {\"allkeys-random\",MAXMEMORY_ALLKEYS_RANDOM},\n    {\"noeviction\",MAXMEMORY_NO_EVICTION},\n    {NULL, 0}\n};\n\nconfigEnum syslog_facility_enum[] = {\n    {\"user\",    LOG_USER},\n    {\"local0\",  LOG_LOCAL0},\n    {\"local1\",  LOG_LOCAL1},\n    {\"local2\",  LOG_LOCAL2},\n    {\"local3\",  LOG_LOCAL3},\n    {\"local4\",  LOG_LOCAL4},\n    {\"local5\",  LOG_LOCAL5},\n    {\"local6\",  LOG_LOCAL6},\n    {\"local7\",  LOG_LOCAL7},\n    {NULL, 0}\n};\n\nconfigEnum loglevel_enum[] = {\n    {\"debug\", LL_DEBUG},\n    {\"verbose\", LL_VERBOSE},\n    {\"notice\", LL_NOTICE},\n    {\"warning\", LL_WARNING},\n    {NULL,0}\n};\n\nconfigEnum supervised_mode_enum[] = {\n    {\"upstart\", SUPERVISED_UPSTART},\n    {\"systemd\", SUPERVISED_SYSTEMD},\n    {\"auto\", SUPERVISED_AUTODETECT},\n    {\"no\", SUPERVISED_NONE},\n    {NULL, 0}\n};\n\nconfigEnum aof_fsync_enum[] = {\n    {\"everysec\", AOF_FSYNC_EVERYSEC},\n    {\"always\", AOF_FSYNC_ALWAYS},\n    {\"no\", AOF_FSYNC_NO},\n    {NULL, 0}\n};\n\nconfigEnum repl_diskless_load_enum[] = {\n    {\"disabled\", REPL_DISKLESS_LOAD_DISABLED},\n    {\"on-empty-db\", REPL_DISKLESS_LOAD_WHEN_DB_EMPTY},\n    {\"swapdb\", REPL_DISKLESS_LOAD_SWAPDB},\n    {NULL, 0}\n};\n\nconfigEnum tls_auth_clients_enum[] = {\n    {\"no\", TLS_CLIENT_AUTH_NO},\n    {\"yes\", TLS_CLIENT_AUTH_YES},\n    {\"optional\", TLS_CLIENT_AUTH_OPTIONAL},\n    {NULL, 0}\n};\n\nconfigEnum oom_score_adj_enum[] = {\n    {\"no\", OOM_SCORE_ADJ_NO},\n    {\"yes\", OOM_SCORE_RELATIVE},\n    {\"relative\", OOM_SCORE_RELATIVE},\n    {\"absolute\", OOM_SCORE_ADJ_ABSOLUTE},\n    {NULL, 0}\n};\n\n/* Output buffer limits presets. */\nclientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {\n    {0, 0, 0}, /* normal */\n    {1024*1024*256, 1024*1024*64, 60}, /* slave */\n    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */\n};\n\n/* OOM Score defaults */\nint configOOMScoreAdjValuesDefaults[CONFIG_OOM_COUNT] = { 0, 200, 800 };\n\n/* Generic config infrastructure function pointers\n * int is_valid_fn(val, err)\n *     Return 1 when val is valid, and 0 when invalid.\n *     Optionally set err to a static error string.\n * int update_fn(val, prev, err)\n *     This function is called only for CONFIG SET command (not at config file parsing)\n *     It is called after the actual config is applied,\n *     Return 1 for success, and 0 for failure.\n *     Optionally set err to a static error string.\n *     On failure the config change will be reverted.\n */\n\n/* Configuration values that require no special handling to set, get, load or\n * rewrite. */\ntypedef struct boolConfigData {\n    int *config; /* The pointer to the server config this value is stored in */\n    const int default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(int val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(int val, int prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} boolConfigData;\n\ntypedef struct stringConfigData {\n    char **config; /* Pointer to the server config this value is stored in. */\n    const char *default_value; /* Default value of the config on rewrite. */\n    int (*is_valid_fn)(char* val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(char* val, char* prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n    int convert_empty_to_null; /* Boolean indicating if empty strings should\n                                  be stored as a NULL value. */\n} stringConfigData;\n\ntypedef struct enumConfigData {\n    int *config; /* The pointer to the server config this value is stored in */\n    configEnum *enum_value; /* The underlying enum type this data represents */\n    const int default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(int val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(int val, int prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} enumConfigData;\n\ntypedef enum numericType {\n    NUMERIC_TYPE_INT,\n    NUMERIC_TYPE_UINT,\n    NUMERIC_TYPE_LONG,\n    NUMERIC_TYPE_ULONG,\n    NUMERIC_TYPE_LONG_LONG,\n    NUMERIC_TYPE_ULONG_LONG,\n    NUMERIC_TYPE_SIZE_T,\n    NUMERIC_TYPE_SSIZE_T,\n    NUMERIC_TYPE_OFF_T,\n    NUMERIC_TYPE_TIME_T,\n} numericType;\n\ntypedef struct numericConfigData {\n    union {\n        int *i;\n        unsigned int *ui;\n        long *l;\n        unsigned long *ul;\n        long long *ll;\n        unsigned long long *ull;\n        size_t *st;\n        ssize_t *sst;\n        off_t *ot;\n        time_t *tt;\n    } config; /* The pointer to the numeric config this value is stored in */\n    int is_memory; /* Indicates if this value can be loaded as a memory value */\n    numericType numeric_type; /* An enum indicating the type of this value */\n    long long lower_bound; /* The lower bound of this numeric value */\n    long long upper_bound; /* The upper bound of this numeric value */\n    const long long default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(long long val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(long long val, long long prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} numericConfigData;\n\ntypedef union typeData {\n    boolConfigData yesno;\n    stringConfigData string;\n    enumConfigData enumd;\n    numericConfigData numeric;\n} typeData;\n\ntypedef struct typeInterface {\n    /* Called on server start, to init the server with default value */\n    void (*init)(typeData data);\n    /* Called on server start, should return 1 on success, 0 on error and should set err */\n    int (*load)(typeData data, sds *argc, int argv, char **err);\n    /* Called on server startup and CONFIG SET, returns 1 on success, 0 on error\n     * and can set a verbose err string, update is true when called from CONFIG SET */\n    int (*set)(typeData data, sds value, int update, char **err);\n    /* Called on CONFIG GET, required to add output to the client */\n    void (*get)(client *c, typeData data);\n    /* Called on CONFIG REWRITE, required to rewrite the config state */\n    void (*rewrite)(typeData data, const char *name, struct rewriteConfigState *state);\n} typeInterface;\n\ntypedef struct standardConfig {\n    const char *name; /* The user visible name of this config */\n    const char *alias; /* An alias that can also be used for this config */\n    const int modifiable; /* Can this value be updated by CONFIG SET? */\n    typeInterface interface; /* The function pointers that define the type interface */\n    typeData data; /* The type specific data exposed used by the interface */\n} standardConfig;\n\nstandardConfig configs[];\n\n/*-----------------------------------------------------------------------------\n * Enum access functions\n *----------------------------------------------------------------------------*/\n\n/* Get enum value from name. If there is no match INT_MIN is returned. */\nint configEnumGetValue(configEnum *ce, char *name) {\n    while(ce->name != NULL) {\n        if (!strcasecmp(ce->name,name)) return ce->val;\n        ce++;\n    }\n    return INT_MIN;\n}\n\n/* Get enum name from value. If no match is found NULL is returned. */\nconst char *configEnumGetName(configEnum *ce, int val) {\n    while(ce->name != NULL) {\n        if (ce->val == val) return ce->name;\n        ce++;\n    }\n    return NULL;\n}\n\n/* Wrapper for configEnumGetName() returning \"unknown\" instead of NULL if\n * there is no match. */\nconst char *configEnumGetNameOrUnknown(configEnum *ce, int val) {\n    const char *name = configEnumGetName(ce,val);\n    return name ? name : \"unknown\";\n}\n\n/* Used for INFO generation. */\nconst char *evictPolicyToString(void) {\n    return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);\n}\n\n/*-----------------------------------------------------------------------------\n * Config file parsing\n *----------------------------------------------------------------------------*/\n\nint yesnotoi(char *s) {\n    if (!strcasecmp(s,\"yes\")) return 1;\n    else if (!strcasecmp(s,\"no\")) return 0;\n    else return -1;\n}\n\nvoid appendServerSaveParams(time_t seconds, int changes) {\n    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));\n    server.saveparams[server.saveparamslen].seconds = seconds;\n    server.saveparams[server.saveparamslen].changes = changes;\n    server.saveparamslen++;\n}\n\nvoid resetServerSaveParams(void) {\n    zfree(server.saveparams);\n    server.saveparams = NULL;\n    server.saveparamslen = 0;\n}\n\nvoid queueLoadModule(sds path, sds *argv, int argc) {\n    int i;\n    struct moduleLoadQueueEntry *loadmod;\n\n    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));\n    loadmod->argv = zmalloc(sizeof(robj*)*argc);\n    loadmod->path = sdsnew(path);\n    loadmod->argc = argc;\n    for (i = 0; i < argc; i++) {\n        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));\n    }\n    listAddNodeTail(server.loadmodule_queue,loadmod);\n}\n\n/* Parse an array of CONFIG_OOM_COUNT sds strings, validate and populate\n * server.oom_score_adj_values if valid.\n */\n\nstatic int updateOOMScoreAdjValues(sds *args, char **err, int apply) {\n    int i;\n    int values[CONFIG_OOM_COUNT];\n\n    for (i = 0; i < CONFIG_OOM_COUNT; i++) {\n        char *eptr;\n        long long val = strtoll(args[i], &eptr, 10);\n\n        if (*eptr != '\\0' || val < -2000 || val > 2000) {\n            if (err) *err = \"Invalid oom-score-adj-values, elements must be between -2000 and 2000.\";\n            return C_ERR;\n        }\n\n        values[i] = val;\n    }\n\n    /* Verify that the values make sense. If they don't omit a warning but\n     * keep the configuration, which may still be valid for privileged processes.\n     */\n\n    if (values[CONFIG_OOM_REPLICA] < values[CONFIG_OOM_MASTER] ||\n        values[CONFIG_OOM_BGCHILD] < values[CONFIG_OOM_REPLICA]) {\n            serverLog(LOG_WARNING,\n                    \"The oom-score-adj-values configuration may not work for non-privileged processes! \"\n                    \"Please consult the documentation.\");\n    }\n\n    /* Store values, retain previous config for rollback in case we fail. */\n    int old_values[CONFIG_OOM_COUNT];\n    for (i = 0; i < CONFIG_OOM_COUNT; i++) {\n        old_values[i] = server.oom_score_adj_values[i];\n        server.oom_score_adj_values[i] = values[i];\n    }\n    \n    /* When parsing the config file, we want to apply only when all is done. */\n    if (!apply)\n        return C_OK;\n\n    /* Update */\n    if (setOOMScoreAdj(-1) == C_ERR) {\n        /* Roll back */\n        for (i = 0; i < CONFIG_OOM_COUNT; i++)\n            server.oom_score_adj_values[i] = old_values[i];\n\n        if (err)\n            *err = \"Failed to apply oom-score-adj-values configuration, check server logs.\";\n\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\nvoid initConfigValues() {\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        config->interface.init(config->data);\n    }\n}\n\nvoid loadServerConfigFromString(char *config) {\n    char *err = NULL;\n    int linenum = 0, totlines, i;\n    int slaveof_linenum = 0;\n    sds *lines;\n\n    lines = sdssplitlen(config,strlen(config),\"\\n\",1,&totlines);\n\n    for (i = 0; i < totlines; i++) {\n        sds *argv;\n        int argc;\n\n        linenum = i+1;\n        lines[i] = sdstrim(lines[i],\" \\t\\r\\n\");\n\n        /* Skip comments and blank lines */\n        if (lines[i][0] == '#' || lines[i][0] == '\\0') continue;\n\n        /* Split into arguments */\n        argv = sdssplitargs(lines[i],&argc);\n        if (argv == NULL) {\n            err = \"Unbalanced quotes in configuration line\";\n            goto loaderr;\n        }\n\n        /* Skip this line if the resulting command vector is empty. */\n        if (argc == 0) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n        sdstolower(argv[0]);\n\n        /* Iterate the configs that are standard */\n        int match = 0;\n        for (standardConfig *config = configs; config->name != NULL; config++) {\n            if ((!strcasecmp(argv[0],config->name) ||\n                (config->alias && !strcasecmp(argv[0],config->alias))))\n            {\n                if (argc != 2) {\n                    err = \"wrong number of arguments\";\n                    goto loaderr;\n                }\n                if (!config->interface.set(config->data, argv[1], 0, &err)) {\n                    goto loaderr;\n                }\n\n                match = 1;\n                break;\n            }\n        }\n\n        if (match) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n\n        /* Execute config directives */\n        if (!strcasecmp(argv[0],\"bind\") && argc >= 2) {\n            int j, addresses = argc-1;\n\n            if (addresses > CONFIG_BINDADDR_MAX) {\n                err = \"Too many bind addresses specified\"; goto loaderr;\n            }\n            /* Free old bind addresses */\n            for (j = 0; j < server.bindaddr_count; j++) {\n                zfree(server.bindaddr[j]);\n            }\n            for (j = 0; j < addresses; j++)\n                server.bindaddr[j] = zstrdup(argv[j+1]);\n            server.bindaddr_count = addresses;\n        } else if (!strcasecmp(argv[0],\"unixsocketperm\") && argc == 2) {\n            errno = 0;\n            server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);\n            if (errno || server.unixsocketperm > 0777) {\n                err = \"Invalid socket file permissions\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"save\")) {\n            if (argc == 3) {\n                int seconds = atoi(argv[1]);\n                int changes = atoi(argv[2]);\n                if (seconds < 1 || changes < 0) {\n                    err = \"Invalid save parameters\"; goto loaderr;\n                }\n                appendServerSaveParams(seconds,changes);\n            } else if (argc == 2 && !strcasecmp(argv[1],\"\")) {\n                resetServerSaveParams();\n            }\n        } else if (!strcasecmp(argv[0],\"dir\") && argc == 2) {\n            if (chdir(argv[1]) == -1) {\n                serverLog(LL_WARNING,\"Can't chdir to '%s': %s\",\n                    argv[1], strerror(errno));\n                exit(1);\n            }\n        } else if (!strcasecmp(argv[0],\"logfile\") && argc == 2) {\n            FILE *logfp;\n\n            zfree(server.logfile);\n            server.logfile = zstrdup(argv[1]);\n            if (server.logfile[0] != '\\0') {\n                /* Test if we are able to open the file. The server will not\n                 * be able to abort just for this problem later... */\n                logfp = fopen(server.logfile,\"a\");\n                if (logfp == NULL) {\n                    err = sdscatprintf(sdsempty(),\n                        \"Can't open the log file: %s\", strerror(errno));\n                    goto loaderr;\n                }\n                fclose(logfp);\n            }\n        } else if (!strcasecmp(argv[0],\"include\") && argc == 2) {\n            loadServerConfig(argv[1],NULL);\n        } else if ((!strcasecmp(argv[0],\"client-query-buffer-limit\")) && argc == 2) {\n             server.client_max_querybuf_len = memtoll(argv[1],NULL);\n        } else if ((!strcasecmp(argv[0],\"slaveof\") ||\n                    !strcasecmp(argv[0],\"replicaof\")) && argc == 3) {\n            slaveof_linenum = linenum;\n            sdsfree(server.masterhost);\n            if (!strcasecmp(argv[1], \"no\") && !strcasecmp(argv[2], \"one\")) {\n                server.masterhost = NULL;\n                continue;\n            }\n            server.masterhost = sdsnew(argv[1]);\n            char *ptr;\n            server.masterport = strtol(argv[2], &ptr, 10);\n            if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\\0') {\n                err = \"Invalid master port\"; goto loaderr;\n            }\n            server.repl_state = REPL_STATE_CONNECT;\n        } else if (!strcasecmp(argv[0],\"requirepass\") && argc == 2) {\n            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {\n                err = \"Password is longer than CONFIG_AUTHPASS_MAX_LEN\";\n                goto loaderr;\n            }\n            /* The old \"requirepass\" directive just translates to setting\n             * a password to the default user. The only thing we do\n             * additionally is to remember the cleartext password in this\n             * case, for backward compatibility with Redis <= 5. */\n            ACLSetUser(DefaultUser,\"resetpass\",-1);\n            sdsfree(server.requirepass);\n            server.requirepass = NULL;\n            if (sdslen(argv[1])) {\n                sds aclop = sdscatprintf(sdsempty(),\">%s\",argv[1]);\n                ACLSetUser(DefaultUser,aclop,sdslen(aclop));\n                sdsfree(aclop);\n                server.requirepass = sdsnew(argv[1]);\n            } else {\n                ACLSetUser(DefaultUser,\"nopass\",-1);\n            }\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-entries\") && argc == 2){\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-value\") && argc == 2) {\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"rename-command\") && argc == 3) {\n            struct redisCommand *cmd = lookupCommand(argv[1]);\n            int retval;\n\n            if (!cmd) {\n                err = \"No such command in rename-command\";\n                goto loaderr;\n            }\n\n            /* If the target command name is the empty string we just\n             * remove it from the command table. */\n            retval = dictDelete(server.commands, argv[1]);\n            serverAssert(retval == DICT_OK);\n\n            /* Otherwise we re-add the command under a different name. */\n            if (sdslen(argv[2]) != 0) {\n                sds copy = sdsdup(argv[2]);\n\n                retval = dictAdd(server.commands, copy, cmd);\n                if (retval != DICT_OK) {\n                    sdsfree(copy);\n                    err = \"Target command name already exists\"; goto loaderr;\n                }\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-config-file\") && argc == 2) {\n            zfree(server.cluster_configfile);\n            server.cluster_configfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        } else if (!strcasecmp(argv[0],\"oom-score-adj-values\") && argc == 1 + CONFIG_OOM_COUNT) {\n            if (updateOOMScoreAdjValues(&argv[1], &err, 0) == C_ERR) goto loaderr;\n        } else if (!strcasecmp(argv[0],\"notify-keyspace-events\") && argc == 2) {\n            int flags = keyspaceEventsStringToFlags(argv[1]);\n\n            if (flags == -1) {\n                err = \"Invalid event class character. Use 'g$lshzxeA'.\";\n                goto loaderr;\n            }\n            server.notify_keyspace_events = flags;\n        } else if (!strcasecmp(argv[0],\"user\") && argc >= 2) {\n            int argc_err;\n            if (ACLAppendUserForLoading(argv,argc,&argc_err) == C_ERR) {\n                char buf[1024];\n                char *errmsg = ACLSetUserStringError();\n                snprintf(buf,sizeof(buf),\"Error in user declaration '%s': %s\",\n                    argv[argc_err],errmsg);\n                err = buf;\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"loadmodule\") && argc >= 2) {\n            queueLoadModule(argv[1],&argv[2],argc-2);\n        } else if (!strcasecmp(argv[0],\"sentinel\")) {\n            /* argc == 1 is handled by main() as we need to enter the sentinel\n             * mode ASAP. */\n            if (argc != 1) {\n                if (!server.sentinel_mode) {\n                    err = \"sentinel directive while not in sentinel mode\";\n                    goto loaderr;\n                }\n                err = sentinelHandleConfiguration(argv+1,argc-1);\n                if (err) goto loaderr;\n            }\n        } else {\n            err = \"Bad directive or wrong number of arguments\"; goto loaderr;\n        }\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Sanity checks. */\n    if (server.cluster_enabled && server.masterhost) {\n        linenum = slaveof_linenum;\n        i = linenum-1;\n        err = \"replicaof directive not allowed in cluster mode\";\n        goto loaderr;\n    }\n\n    sdsfreesplitres(lines,totlines);\n    return;\n\nloaderr:\n    fprintf(stderr, \"\\n*** FATAL CONFIG FILE ERROR (Redis %s) ***\\n\",\n        REDIS_VERSION);\n    fprintf(stderr, \"Reading the configuration file, at line %d\\n\", linenum);\n    fprintf(stderr, \">>> '%s'\\n\", lines[i]);\n    fprintf(stderr, \"%s\\n\", err);\n    exit(1);\n}\n\n/* Load the server configuration from the specified filename.\n * The function appends the additional configuration directives stored\n * in the 'options' string to the config file before loading.\n *\n * Both filename and options can be NULL, in such a case are considered\n * empty. This way loadServerConfig can be used to just load a file or\n * just load a string. */\nvoid loadServerConfig(char *filename, char *options) {\n    sds config = sdsempty();\n    char buf[CONFIG_MAX_LINE+1];\n\n    /* Load the file content */\n    if (filename) {\n        FILE *fp;\n\n        if (filename[0] == '-' && filename[1] == '\\0') {\n            fp = stdin;\n        } else {\n            if ((fp = fopen(filename,\"r\")) == NULL) {\n                serverLog(LL_WARNING,\n                    \"Fatal error, can't open config file '%s': %s\",\n                    filename, strerror(errno));\n                exit(1);\n            }\n        }\n        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)\n            config = sdscat(config,buf);\n        if (fp != stdin) fclose(fp);\n    }\n    /* Append the additional options */\n    if (options) {\n        config = sdscat(config,\"\\n\");\n        config = sdscat(config,options);\n    }\n    loadServerConfigFromString(config);\n    sdsfree(config);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG SET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_set_bool_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int yn = yesnotoi(o->ptr); \\\n        if (yn == -1) goto badfmt; \\\n        _var = yn;\n\n#define config_set_numerical_field(_name,_var,min,max) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        if (getLongLongFromObject(o,&ll) == C_ERR) goto badfmt; \\\n        if (min != LLONG_MIN && ll < min) goto badfmt; \\\n        if (max != LLONG_MAX && ll > max) goto badfmt; \\\n        _var = ll;\n\n#define config_set_memory_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        ll = memtoll(o->ptr,&err); \\\n        if (err || ll < 0) goto badfmt; \\\n        _var = ll;\n\n#define config_set_special_field(_name) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) {\n\n#define config_set_special_field_with_alias(_name1,_name2) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name1) || \\\n               !strcasecmp(c->argv[2]->ptr,_name2)) {\n\n#define config_set_else } else\n\nvoid configSetCommand(client *c) {\n    robj *o;\n    long long ll;\n    int err;\n    char *errstr = NULL;\n    serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));\n    serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));\n    o = c->argv[3];\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        if(config->modifiable && (!strcasecmp(c->argv[2]->ptr,config->name) ||\n            (config->alias && !strcasecmp(c->argv[2]->ptr,config->alias))))\n        {\n            if (!config->interface.set(config->data,o->ptr,1,&errstr)) {\n                goto badfmt;\n            }\n            addReply(c,shared.ok);\n            return;\n        }\n    }\n\n    if (0) { /* this starts the config_set macros else-if chain. */\n\n    /* Special fields that can't be handled with general macros. */\n    config_set_special_field(\"requirepass\") {\n        if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;\n        /* The old \"requirepass\" directive just translates to setting\n         * a password to the default user. The only thing we do\n         * additionally is to remember the cleartext password in this\n         * case, for backward compatibility with Redis <= 5. */\n        ACLSetUser(DefaultUser,\"resetpass\",-1);\n        sdsfree(server.requirepass);\n        server.requirepass = NULL;\n        if (sdslen(o->ptr)) {\n            sds aclop = sdscatprintf(sdsempty(),\">%s\",(char*)o->ptr);\n            ACLSetUser(DefaultUser,aclop,sdslen(aclop));\n            sdsfree(aclop);\n            server.requirepass = sdsnew(o->ptr);\n        } else {\n            ACLSetUser(DefaultUser,\"nopass\",-1);\n        }\n    } config_set_special_field(\"save\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* Perform sanity check before setting the new config:\n         * - Even number of args\n         * - Seconds >= 1, changes >= 0 */\n        if (vlen & 1) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n        for (j = 0; j < vlen; j++) {\n            char *eptr;\n            long val;\n\n            val = strtoll(v[j], &eptr, 10);\n            if (eptr[0] != '\\0' ||\n                ((j & 1) == 0 && val < 1) ||\n                ((j & 1) == 1 && val < 0)) {\n                sdsfreesplitres(v,vlen);\n                goto badfmt;\n            }\n        }\n        /* Finally set the new config */\n        resetServerSaveParams();\n        for (j = 0; j < vlen; j += 2) {\n            time_t seconds;\n            int changes;\n\n            seconds = strtoll(v[j],NULL,10);\n            changes = strtoll(v[j+1],NULL,10);\n            appendServerSaveParams(seconds, changes);\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"dir\") {\n        if (chdir((char*)o->ptr) == -1) {\n            addReplyErrorFormat(c,\"Changing directory: %s\", strerror(errno));\n            return;\n        }\n    } config_set_special_field(\"client-output-buffer-limit\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */\n        if (vlen % 4) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n\n        /* Sanity check of single arguments, so that we either refuse the\n         * whole configuration string or accept it all, even if a single\n         * error in a single client class is present. */\n        for (j = 0; j < vlen; j++) {\n            long val;\n\n            if ((j % 4) == 0) {\n                int class = getClientTypeByName(v[j]);\n                if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            } else {\n                val = memtoll(v[j], &err);\n                if (err || val < 0) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            }\n        }\n        /* Finally set the new config */\n        for (j = 0; j < vlen; j += 4) {\n            int class;\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            class = getClientTypeByName(v[j]);\n            hard = memtoll(v[j+1],NULL);\n            soft = memtoll(v[j+2],NULL);\n            soft_seconds = strtoll(v[j+3],NULL,10);\n\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"oom-score-adj-values\") {\n        int vlen;\n        int success = 1;\n\n        sds *v = sdssplitlen(o->ptr, sdslen(o->ptr), \" \", 1, &vlen);\n        if (vlen != CONFIG_OOM_COUNT || updateOOMScoreAdjValues(v, &errstr, 1) == C_ERR)\n            success = 0;\n\n        sdsfreesplitres(v, vlen);\n        if (!success)\n            goto badfmt;\n    } config_set_special_field(\"notify-keyspace-events\") {\n        int flags = keyspaceEventsStringToFlags(o->ptr);\n\n        if (flags == -1) goto badfmt;\n        server.notify_keyspace_events = flags;\n    /* Numerical fields.\n     * config_set_numerical_field(name,var,min,max) */\n    } config_set_numerical_field(\n      \"watchdog-period\",ll,0,INT_MAX) {\n        if (ll)\n            enableWatchdog(ll);\n        else\n            disableWatchdog();\n    /* Memory fields.\n     * config_set_memory_field(name,var) */\n    } config_set_memory_field(\n      \"client-query-buffer-limit\",server.client_max_querybuf_len) {\n    /* Everything else is an error... */\n    } config_set_else {\n        addReplyErrorFormat(c,\"Unsupported CONFIG parameter: %s\",\n            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* On success we just return a generic OK for all the options. */\n    addReply(c,shared.ok);\n    return;\n\nbadfmt: /* Bad format errors */\n    if (errstr) {\n        addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s' - %s\",\n                (char*)o->ptr,\n                (char*)c->argv[2]->ptr,\n                errstr);\n    } else {\n        addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s'\",\n                (char*)o->ptr,\n                (char*)c->argv[2]->ptr);\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG GET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_get_string_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? _var : \"\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_bool_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? \"yes\" : \"no\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_numerical_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        ll2string(buf,sizeof(buf),_var); \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,buf); \\\n        matches++; \\\n    } \\\n} while(0);\n\n\nvoid configGetCommand(client *c) {\n    robj *o = c->argv[2];\n    void *replylen = addReplyDeferredLen(c);\n    char *pattern = o->ptr;\n    char buf[128];\n    int matches = 0;\n    serverAssertWithInfo(c,o,sdsEncodedObject(o));\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        if (stringmatch(pattern,config->name,1)) {\n            addReplyBulkCString(c,config->name);\n            config->interface.get(c,config->data);\n            matches++;\n        }\n        if (config->alias && stringmatch(pattern,config->alias,1)) {\n            addReplyBulkCString(c,config->alias);\n            config->interface.get(c,config->data);\n            matches++;\n        }\n    }\n\n    /* String values */\n    config_get_string_field(\"logfile\",server.logfile);\n\n    /* Numerical values */\n    config_get_numerical_field(\"client-query-buffer-limit\",server.client_max_querybuf_len);\n    config_get_numerical_field(\"watchdog-period\",server.watchdog_period);\n\n    /* Everything we can't handle with macros follows. */\n\n    if (stringmatch(pattern,\"dir\",1)) {\n        char buf[1024];\n\n        if (getcwd(buf,sizeof(buf)) == NULL)\n            buf[0] = '\\0';\n\n        addReplyBulkCString(c,\"dir\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"save\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < server.saveparamslen; j++) {\n            buf = sdscatprintf(buf,\"%jd %d\",\n                    (intmax_t)server.saveparams[j].seconds,\n                    server.saveparams[j].changes);\n            if (j != server.saveparamslen-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"save\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"client-output-buffer-limit\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%s %llu %llu %ld\",\n                    getClientTypeName(j),\n                    server.client_obuf_limits[j].hard_limit_bytes,\n                    server.client_obuf_limits[j].soft_limit_bytes,\n                    (long) server.client_obuf_limits[j].soft_limit_seconds);\n            if (j != CLIENT_TYPE_OBUF_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"client-output-buffer-limit\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"unixsocketperm\",1)) {\n        char buf[32];\n        snprintf(buf,sizeof(buf),\"%o\",server.unixsocketperm);\n        addReplyBulkCString(c,\"unixsocketperm\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"slaveof\",1) ||\n        stringmatch(pattern,\"replicaof\",1))\n    {\n        char *optname = stringmatch(pattern,\"slaveof\",1) ?\n                        \"slaveof\" : \"replicaof\";\n        char buf[256];\n\n        addReplyBulkCString(c,optname);\n        if (server.masterhost)\n            snprintf(buf,sizeof(buf),\"%s %d\",\n                server.masterhost, server.masterport);\n        else\n            buf[0] = '\\0';\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"notify-keyspace-events\",1)) {\n        sds flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n\n        addReplyBulkCString(c,\"notify-keyspace-events\");\n        addReplyBulkSds(c,flags);\n        matches++;\n    }\n    if (stringmatch(pattern,\"bind\",1)) {\n        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n\n        addReplyBulkCString(c,\"bind\");\n        addReplyBulkCString(c,aux);\n        sdsfree(aux);\n        matches++;\n    }\n    if (stringmatch(pattern,\"requirepass\",1)) {\n        addReplyBulkCString(c,\"requirepass\");\n        sds password = server.requirepass;\n        if (password) {\n            addReplyBulkCBuffer(c,password,sdslen(password));\n        } else {\n            addReplyBulkCString(c,\"\");\n        }\n        matches++;\n    }\n\n    if (stringmatch(pattern,\"oom-score-adj-values\",0)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CONFIG_OOM_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%d\", server.oom_score_adj_values[j]);\n            if (j != CONFIG_OOM_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n\n        addReplyBulkCString(c,\"oom-score-adj-values\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n\n    setDeferredMapLen(c,replylen,matches);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG REWRITE implementation\n *----------------------------------------------------------------------------*/\n\n#define REDIS_CONFIG_REWRITE_SIGNATURE \"# Generated by CONFIG REWRITE\"\n\n/* We use the following dictionary type to store where a configuration\n * option is mentioned in the old configuration file, so it's\n * like \"maxmemory\" -> list of line numbers (first line is zero). */\nuint64_t dictSdsCaseHash(const void *key);\nint dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\nvoid dictListDestructor(void *privdata, void *val);\n\n/* Sentinel config rewriting is implemented inside sentinel.c by\n * rewriteConfigSentinelOption(). */\nvoid rewriteConfigSentinelOption(struct rewriteConfigState *state);\n\ndictType optionToLineDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\ndictType optionSetDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* The config rewrite state. */\nstruct rewriteConfigState {\n    dict *option_to_line; /* Option -> list of config file lines map */\n    dict *rewritten;      /* Dictionary of already processed options */\n    int numlines;         /* Number of lines in current config */\n    sds *lines;           /* Current lines as an array of sds strings */\n    int has_tail;         /* True if we already added directives that were\n                             not present in the original config file. */\n    int force_all;        /* True if we want all keywords to be force\n                             written. Currently only used for testing. */\n};\n\n/* Append the new line to the current configuration state. */\nvoid rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {\n    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));\n    state->lines[state->numlines++] = line;\n}\n\n/* Populate the option -> list of line numbers map. */\nvoid rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {\n    list *l = dictFetchValue(state->option_to_line,option);\n\n    if (l == NULL) {\n        l = listCreate();\n        dictAdd(state->option_to_line,sdsdup(option),l);\n    }\n    listAddNodeTail(l,(void*)(long)linenum);\n}\n\n/* Add the specified option to the set of processed options.\n * This is useful as only unused lines of processed options will be blanked\n * in the config file, while options the rewrite process does not understand\n * remain untouched. */\nvoid rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {\n    sds opt = sdsnew(option);\n\n    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);\n}\n\n/* Read the old file, split it into lines to populate a newly created\n * config rewrite state, and return it to the caller.\n *\n * If it is impossible to read the old file, NULL is returned.\n * If the old file does not exist at all, an empty state is returned. */\nstruct rewriteConfigState *rewriteConfigReadOldFile(char *path) {\n    FILE *fp = fopen(path,\"r\");\n    if (fp == NULL && errno != ENOENT) return NULL;\n\n    char buf[CONFIG_MAX_LINE+1];\n    int linenum = -1;\n    struct rewriteConfigState *state = zmalloc(sizeof(*state));\n    state->option_to_line = dictCreate(&optionToLineDictType,NULL);\n    state->rewritten = dictCreate(&optionSetDictType,NULL);\n    state->numlines = 0;\n    state->lines = NULL;\n    state->has_tail = 0;\n    state->force_all = 0;\n    if (fp == NULL) return state;\n\n    /* Read the old file line by line, populate the state. */\n    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {\n        int argc;\n        sds *argv;\n        sds line = sdstrim(sdsnew(buf),\"\\r\\n\\t \");\n\n        linenum++; /* Zero based, so we init at -1 */\n\n        /* Handle comments and empty lines. */\n        if (line[0] == '#' || line[0] == '\\0') {\n            if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))\n                state->has_tail = 1;\n            rewriteConfigAppendLine(state,line);\n            continue;\n        }\n\n        /* Not a comment, split into arguments. */\n        argv = sdssplitargs(line,&argc);\n        if (argv == NULL) {\n            /* Apparently the line is unparsable for some reason, for\n             * instance it may have unbalanced quotes. Load it as a\n             * comment. */\n            sds aux = sdsnew(\"# ??? \");\n            aux = sdscatsds(aux,line);\n            sdsfree(line);\n            rewriteConfigAppendLine(state,aux);\n            continue;\n        }\n\n        sdstolower(argv[0]); /* We only want lowercase config directives. */\n\n        /* Now we populate the state according to the content of this line.\n         * Append the line and populate the option -> line numbers map. */\n        rewriteConfigAppendLine(state,line);\n\n        /* Translate options using the word \"slave\" to the corresponding name\n         * \"replica\", before adding such option to the config name -> lines\n         * mapping. */\n        char *p = strstr(argv[0],\"slave\");\n        if (p) {\n            sds alt = sdsempty();\n            alt = sdscatlen(alt,argv[0],p-argv[0]);;\n            alt = sdscatlen(alt,\"replica\",7);\n            alt = sdscatlen(alt,p+5,strlen(p+5));\n            sdsfree(argv[0]);\n            argv[0] = alt;\n        }\n        rewriteConfigAddLineNumberToOption(state,argv[0],linenum);\n        sdsfreesplitres(argv,argc);\n    }\n    fclose(fp);\n    return state;\n}\n\n/* Rewrite the specified configuration option with the new \"line\".\n * It progressively uses lines of the file that were already used for the same\n * configuration option in the old version of the file, removing that line from\n * the map of options -> line numbers.\n *\n * If there are lines associated with a given configuration option and\n * \"force\" is non-zero, the line is appended to the configuration file.\n * Usually \"force\" is true when an option has not its default value, so it\n * must be rewritten even if not present previously.\n *\n * The first time a line is appended into a configuration file, a comment\n * is added to show that starting from that point the config file was generated\n * by CONFIG REWRITE.\n *\n * \"line\" is either used, or freed, so the caller does not need to free it\n * in any way. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {\n    sds o = sdsnew(option);\n    list *l = dictFetchValue(state->option_to_line,o);\n\n    rewriteConfigMarkAsProcessed(state,option);\n\n    if (!l && !force && !state->force_all) {\n        /* Option not used previously, and we are not forced to use it. */\n        sdsfree(line);\n        sdsfree(o);\n        return;\n    }\n\n    if (l) {\n        listNode *ln = listFirst(l);\n        int linenum = (long) ln->value;\n\n        /* There are still lines in the old configuration file we can reuse\n         * for this option. Replace the line with the new one. */\n        listDelNode(l,ln);\n        if (listLength(l) == 0) dictDelete(state->option_to_line,o);\n        sdsfree(state->lines[linenum]);\n        state->lines[linenum] = line;\n    } else {\n        /* Append a new line. */\n        if (!state->has_tail) {\n            rewriteConfigAppendLine(state,\n                sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));\n            state->has_tail = 1;\n        }\n        rewriteConfigAppendLine(state,line);\n    }\n    sdsfree(o);\n}\n\n/* Write the long long 'bytes' value as a string in a way that is parsable\n * inside redis.conf. If possible uses the GB, MB, KB notation. */\nint rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {\n    int gb = 1024*1024*1024;\n    int mb = 1024*1024;\n    int kb = 1024;\n\n    if (bytes && (bytes % gb) == 0) {\n        return snprintf(buf,len,\"%lldgb\",bytes/gb);\n    } else if (bytes && (bytes % mb) == 0) {\n        return snprintf(buf,len,\"%lldmb\",bytes/mb);\n    } else if (bytes && (bytes % kb) == 0) {\n        return snprintf(buf,len,\"%lldkb\",bytes/kb);\n    } else {\n        return snprintf(buf,len,\"%lld\",bytes);\n    }\n}\n\n/* Rewrite a simple \"option-name <bytes>\" configuration option. */\nvoid rewriteConfigBytesOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {\n    char buf[64];\n    int force = value != defvalue;\n    sds line;\n\n    rewriteConfigFormatMemory(buf,sizeof(buf),value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,buf);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a yes/no option. */\nvoid rewriteConfigYesNoOption(struct rewriteConfigState *state, const char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %s\",option,\n        value ? \"yes\" : \"no\");\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a string option. */\nvoid rewriteConfigStringOption(struct rewriteConfigState *state, const char *option, char *value, const char *defvalue) {\n    int force = 1;\n    sds line;\n\n    /* String options set to NULL need to be not present at all in the\n     * configuration file to be set to NULL again at the next reboot. */\n    if (value == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Set force to zero if the value is set to its default. */\n    if (defvalue && strcmp(value,defvalue) == 0) force = 0;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, value, strlen(value));\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a numerical (long long range) option. */\nvoid rewriteConfigNumericalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %lld\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an octal option. */\nvoid rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %o\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an enumeration option. It takes as usually state and option name,\n * and in addition the enumeration array and the default value for the\n * option. */\nvoid rewriteConfigEnumOption(struct rewriteConfigState *state, const char *option, int value, configEnum *ce, int defval) {\n    sds line;\n    const char *name = configEnumGetNameOrUnknown(ce,value);\n    int force = value != defval;\n\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the save option. */\nvoid rewriteConfigSaveOption(struct rewriteConfigState *state) {\n    int j;\n    sds line;\n\n    /* In Sentinel mode we don't need to rewrite the save parameters */\n    if (server.sentinel_mode) {\n        rewriteConfigMarkAsProcessed(state,\"save\");\n        return;\n    }\n\n    /* Note that if there are no save parameters at all, all the current\n     * config line with \"save\" will be detected as orphaned and deleted,\n     * resulting into no RDB persistence as expected. */\n    for (j = 0; j < server.saveparamslen; j++) {\n        line = sdscatprintf(sdsempty(),\"save %ld %d\",\n            (long) server.saveparams[j].seconds, server.saveparams[j].changes);\n        rewriteConfigRewriteLine(state,\"save\",line,1);\n    }\n    /* Mark \"save\" as processed in case server.saveparamslen is zero. */\n    rewriteConfigMarkAsProcessed(state,\"save\");\n}\n\n/* Rewrite the user option. */\nvoid rewriteConfigUserOption(struct rewriteConfigState *state) {\n    /* If there is a user file defined we just mark this configuration\n     * directive as processed, so that all the lines containing users\n     * inside the config file gets discarded. */\n    if (server.acl_filename[0] != '\\0') {\n        rewriteConfigMarkAsProcessed(state,\"user\");\n        return;\n    }\n\n    /* Otherwise scan the list of users and rewrite every line. Note that\n     * in case the list here is empty, the effect will just be to comment\n     * all the users directive inside the config file. */\n    raxIterator ri;\n    raxStart(&ri,Users);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        user *u = ri.data;\n        sds line = sdsnew(\"user \");\n        line = sdscatsds(line,u->name);\n        line = sdscatlen(line,\" \",1);\n        sds descr = ACLDescribeUser(u);\n        line = sdscatsds(line,descr);\n        sdsfree(descr);\n        rewriteConfigRewriteLine(state,\"user\",line,1);\n    }\n    raxStop(&ri);\n\n    /* Mark \"user\" as processed in case there are no defined users. */\n    rewriteConfigMarkAsProcessed(state,\"user\");\n}\n\n/* Rewrite the dir option, always using absolute paths.*/\nvoid rewriteConfigDirOption(struct rewriteConfigState *state) {\n    char cwd[1024];\n\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"dir\");\n        return; /* no rewrite on error. */\n    }\n    rewriteConfigStringOption(state,\"dir\",cwd,NULL);\n}\n\n/* Rewrite the slaveof option. */\nvoid rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {\n    sds line;\n\n    /* If this is a master, we want all the slaveof config options\n     * in the file to be removed. Note that if this is a cluster instance\n     * we don't want a slaveof directive inside redis.conf. */\n    if (server.cluster_enabled || server.masterhost == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n    line = sdscatprintf(sdsempty(),\"%s %s %d\", option,\n        server.masterhost, server.masterport);\n    rewriteConfigRewriteLine(state,option,line,1);\n}\n\n/* Rewrite the notify-keyspace-events option. */\nvoid rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {\n    int force = server.notify_keyspace_events != 0;\n    char *option = \"notify-keyspace-events\";\n    sds line, flags;\n\n    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, flags, sdslen(flags));\n    sdsfree(flags);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the client-output-buffer-limit option. */\nvoid rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {\n    int j;\n    char *option = \"client-output-buffer-limit\";\n\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n        int force = (server.client_obuf_limits[j].hard_limit_bytes !=\n                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_bytes !=\n                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_seconds !=\n                    clientBufferLimitsDefaults[j].soft_limit_seconds);\n        sds line;\n        char hard[64], soft[64];\n\n        rewriteConfigFormatMemory(hard,sizeof(hard),\n                server.client_obuf_limits[j].hard_limit_bytes);\n        rewriteConfigFormatMemory(soft,sizeof(soft),\n                server.client_obuf_limits[j].soft_limit_bytes);\n\n        char *typename = getClientTypeName(j);\n        if (!strcmp(typename,\"slave\")) typename = \"replica\";\n        line = sdscatprintf(sdsempty(),\"%s %s %s %s %ld\",\n                option, typename, hard, soft,\n                (long) server.client_obuf_limits[j].soft_limit_seconds);\n        rewriteConfigRewriteLine(state,option,line,force);\n    }\n}\n\n/* Rewrite the oom-score-adj-values option. */\nvoid rewriteConfigOOMScoreAdjValuesOption(struct rewriteConfigState *state) {\n    int force = 0;\n    int j;\n    char *option = \"oom-score-adj-values\";\n    sds line;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    for (j = 0; j < CONFIG_OOM_COUNT; j++) {\n        if (server.oom_score_adj_values[j] != configOOMScoreAdjValuesDefaults[j])\n            force = 1;\n\n        line = sdscatprintf(line, \"%d\", server.oom_score_adj_values[j]);\n        if (j+1 != CONFIG_OOM_COUNT)\n            line = sdscatlen(line, \" \", 1);\n    }\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the bind option. */\nvoid rewriteConfigBindOption(struct rewriteConfigState *state) {\n    int force = 1;\n    sds line, addresses;\n    char *option = \"bind\";\n\n    /* Nothing to rewrite if we don't have bind addresses. */\n    if (server.bindaddr_count == 0) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Rewrite as bind <addr1> <addr2> ... <addrN> */\n    addresses = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, addresses);\n    sdsfree(addresses);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the requirepass option. */\nvoid rewriteConfigRequirepassOption(struct rewriteConfigState *state, char *option) {\n    int force = 1;\n    sds line;\n    sds password = server.requirepass;\n\n    /* If there is no password set, we don't want the requirepass option\n     * to be present in the configuration at all. */\n    if (password == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, password);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Glue together the configuration lines in the current configuration\n * rewrite state into a single string, stripping multiple empty lines. */\nsds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {\n    sds content = sdsempty();\n    int j, was_empty = 0;\n\n    for (j = 0; j < state->numlines; j++) {\n        /* Every cluster of empty lines is turned into a single empty line. */\n        if (sdslen(state->lines[j]) == 0) {\n            if (was_empty) continue;\n            was_empty = 1;\n        } else {\n            was_empty = 0;\n        }\n        content = sdscatsds(content,state->lines[j]);\n        content = sdscatlen(content,\"\\n\",1);\n    }\n    return content;\n}\n\n/* Free the configuration rewrite state. */\nvoid rewriteConfigReleaseState(struct rewriteConfigState *state) {\n    sdsfreesplitres(state->lines,state->numlines);\n    dictRelease(state->option_to_line);\n    dictRelease(state->rewritten);\n    zfree(state);\n}\n\n/* At the end of the rewrite process the state contains the remaining\n * map between \"option name\" => \"lines in the original config file\".\n * Lines used by the rewrite process were removed by the function\n * rewriteConfigRewriteLine(), all the other lines are \"orphaned\" and\n * should be replaced by empty lines.\n *\n * This function does just this, iterating all the option names and\n * blanking all the lines still associated. */\nvoid rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {\n    dictIterator *di = dictGetIterator(state->option_to_line);\n    dictEntry *de;\n\n    while((de = dictNext(di)) != NULL) {\n        list *l = dictGetVal(de);\n        sds option = dictGetKey(de);\n\n        /* Don't blank lines about options the rewrite process\n         * don't understand. */\n        if (dictFind(state->rewritten,option) == NULL) {\n            serverLog(LL_DEBUG,\"Not rewritten option: %s\", option);\n            continue;\n        }\n\n        while(listLength(l)) {\n            listNode *ln = listFirst(l);\n            int linenum = (long) ln->value;\n\n            sdsfree(state->lines[linenum]);\n            state->lines[linenum] = sdsempty();\n            listDelNode(l,ln);\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* This function replaces the old configuration file with the new content\n * in an atomic manner.\n *\n * The function returns 0 on success, otherwise -1 is returned and errno\n * is set accordingly. */\nint rewriteConfigOverwriteFile(char *configfile, sds content) {\n    int fd = -1;\n    int retval = -1;\n    char tmp_conffile[PATH_MAX];\n    const char *tmp_suffix = \".XXXXXX\";\n    size_t offset = 0;\n    ssize_t written_bytes = 0;\n\n    int tmp_path_len = snprintf(tmp_conffile, sizeof(tmp_conffile), \"%s%s\", configfile, tmp_suffix);\n    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof(tmp_conffile)) {\n        serverLog(LL_WARNING, \"Config file full path is too long\");\n        errno = ENAMETOOLONG;\n        return retval;\n    }\n\n#ifdef _GNU_SOURCE\n    fd = mkostemp(tmp_conffile, O_CLOEXEC);\n#else\n    /* There's a theoretical chance here to leak the FD if a module thread forks & execv in the middle */\n    fd = mkstemp(tmp_conffile);\n#endif\n\n    if (fd == -1) {\n        serverLog(LL_WARNING, \"Could not create tmp config file (%s)\", strerror(errno));\n        return retval;\n    }\n\n    while (offset < sdslen(content)) {\n         written_bytes = write(fd, content + offset, sdslen(content) - offset);\n         if (written_bytes <= 0) {\n             if (errno == EINTR) continue; /* FD is blocking, no other retryable errors */\n             serverLog(LL_WARNING, \"Failed after writing (%zd) bytes to tmp config file (%s)\", offset, strerror(errno));\n             goto cleanup;\n         }\n         offset+=written_bytes;\n    }\n\n    if (fsync(fd))\n        serverLog(LL_WARNING, \"Could not sync tmp config file to disk (%s)\", strerror(errno));\n    else if (fchmod(fd, 0644 & ~server.umask) == -1)\n        serverLog(LL_WARNING, \"Could not chmod config file (%s)\", strerror(errno));\n    else if (rename(tmp_conffile, configfile) == -1)\n        serverLog(LL_WARNING, \"Could not rename tmp config file (%s)\", strerror(errno));\n    else {\n        retval = 0;\n        serverLog(LL_DEBUG, \"Rewritten config file (%s) successfully\", configfile);\n    }\n\ncleanup:\n    close(fd);\n    if (retval) unlink(tmp_conffile);\n    return retval;\n}\n\n/* Rewrite the configuration file at \"path\".\n * If the configuration file already exists, we try at best to retain comments\n * and overall structure.\n *\n * Configuration parameters that are at their default value, unless already\n * explicitly included in the old configuration file, are not rewritten.\n * The force_all flag overrides this behavior and forces everything to be\n * written. This is currently only used for testing purposes.\n *\n * On error -1 is returned and errno is set accordingly, otherwise 0. */\nint rewriteConfig(char *path, int force_all) {\n    struct rewriteConfigState *state;\n    sds newcontent;\n    int retval;\n\n    /* Step 1: read the old config into our rewrite state. */\n    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;\n    if (force_all) state->force_all = 1;\n\n    /* Step 2: rewrite every single option, replacing or appending it inside\n     * the rewrite state. */\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        config->interface.rewrite(config->data, config->name, state);\n    }\n\n    rewriteConfigBindOption(state);\n    rewriteConfigOctalOption(state,\"unixsocketperm\",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);\n    rewriteConfigStringOption(state,\"logfile\",server.logfile,CONFIG_DEFAULT_LOGFILE);\n    rewriteConfigSaveOption(state);\n    rewriteConfigUserOption(state);\n    rewriteConfigDirOption(state);\n    rewriteConfigSlaveofOption(state,\"replicaof\");\n    rewriteConfigRequirepassOption(state,\"requirepass\");\n    rewriteConfigBytesOption(state,\"client-query-buffer-limit\",server.client_max_querybuf_len,PROTO_MAX_QUERYBUF_LEN);\n    rewriteConfigStringOption(state,\"cluster-config-file\",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    rewriteConfigNotifykeyspaceeventsOption(state);\n    rewriteConfigClientoutputbufferlimitOption(state);\n    rewriteConfigOOMScoreAdjValuesOption(state);\n\n    /* Rewrite Sentinel config if in Sentinel mode. */\n    if (server.sentinel_mode) rewriteConfigSentinelOption(state);\n\n    /* Step 3: remove all the orphaned lines in the old file, that is, lines\n     * that were used by a config option and are no longer used, like in case\n     * of multiple \"save\" options or duplicated options. */\n    rewriteConfigRemoveOrphaned(state);\n\n    /* Step 4: generate a new configuration file from the modified state\n     * and write it into the original file. */\n    newcontent = rewriteConfigGetContentFromState(state);\n    retval = rewriteConfigOverwriteFile(server.configfile,newcontent);\n\n    sdsfree(newcontent);\n    rewriteConfigReleaseState(state);\n    return retval;\n}\n\n/*-----------------------------------------------------------------------------\n * Configs that fit one of the major types and require no special handling\n *----------------------------------------------------------------------------*/\n#define LOADBUF_SIZE 256\nstatic char loadbuf[LOADBUF_SIZE];\n\n#define MODIFIABLE_CONFIG 1\n#define IMMUTABLE_CONFIG 0\n\n#define embedCommonConfig(config_name, config_alias, is_modifiable) \\\n    .name = (config_name), \\\n    .alias = (config_alias), \\\n    .modifiable = (is_modifiable),\n\n#define embedConfigInterface(initfn, setfn, getfn, rewritefn) .interface = { \\\n    .init = (initfn), \\\n    .set = (setfn), \\\n    .get = (getfn), \\\n    .rewrite = (rewritefn) \\\n},\n\n/* What follows is the generic config types that are supported. To add a new\n * config with one of these types, add it to the standardConfig table with\n * the creation macro for each type.\n *\n * Each type contains the following:\n * * A function defining how to load this type on startup.\n * * A function defining how to update this type on CONFIG SET.\n * * A function defining how to serialize this type on CONFIG SET.\n * * A function defining how to rewrite this type on CONFIG REWRITE.\n * * A Macro defining how to create this type.\n */\n\n/* Bool Configs */\nstatic void boolConfigInit(typeData data) {\n    *data.yesno.config = data.yesno.default_value;\n}\n\nstatic int boolConfigSet(typeData data, sds value, int update, char **err) {\n    int yn = yesnotoi(value);\n    if (yn == -1) {\n        *err = \"argument must be 'yes' or 'no'\";\n        return 0;\n    }\n    if (data.yesno.is_valid_fn && !data.yesno.is_valid_fn(yn, err))\n        return 0;\n    int prev = *(data.yesno.config);\n    *(data.yesno.config) = yn;\n    if (update && data.yesno.update_fn && !data.yesno.update_fn(yn, prev, err)) {\n        *(data.yesno.config) = prev;\n        return 0;\n    }\n    return 1;\n}\n\nstatic void boolConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, *data.yesno.config ? \"yes\" : \"no\");\n}\n\nstatic void boolConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigYesNoOption(state, name,*(data.yesno.config), data.yesno.default_value);\n}\n\n#define createBoolConfig(name, alias, modifiable, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(boolConfigInit, boolConfigSet, boolConfigGet, boolConfigRewrite) \\\n    .data.yesno = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n    } \\\n}\n\n/* String Configs */\nstatic void stringConfigInit(typeData data) {\n    if (data.string.convert_empty_to_null) {\n        *data.string.config = data.string.default_value ? zstrdup(data.string.default_value) : NULL;\n    } else {\n        *data.string.config = zstrdup(data.string.default_value);\n    }\n}\n\nstatic int stringConfigSet(typeData data, sds value, int update, char **err) {\n    if (data.string.is_valid_fn && !data.string.is_valid_fn(value, err))\n        return 0;\n    char *prev = *data.string.config;\n    if (data.string.convert_empty_to_null) {\n        *data.string.config = value[0] ? zstrdup(value) : NULL;\n    } else {\n        *data.string.config = zstrdup(value);\n    }\n    if (update && data.string.update_fn && !data.string.update_fn(*data.string.config, prev, err)) {\n        zfree(*data.string.config);\n        *data.string.config = prev;\n        return 0;\n    }\n    zfree(prev);\n    return 1;\n}\n\nstatic void stringConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, *data.string.config ? *data.string.config : \"\");\n}\n\nstatic void stringConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigStringOption(state, name,*(data.string.config), data.string.default_value);\n}\n\n#define ALLOW_EMPTY_STRING 0\n#define EMPTY_STRING_IS_NULL 1\n\n#define createStringConfig(name, alias, modifiable, empty_to_null, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(stringConfigInit, stringConfigSet, stringConfigGet, stringConfigRewrite) \\\n    .data.string = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .convert_empty_to_null = (empty_to_null), \\\n    } \\\n}\n\n/* Enum configs */\nstatic void enumConfigInit(typeData data) {\n    *data.enumd.config = data.enumd.default_value;\n}\n\nstatic int enumConfigSet(typeData data, sds value, int update, char **err) {\n    int enumval = configEnumGetValue(data.enumd.enum_value, value);\n    if (enumval == INT_MIN) {\n        sds enumerr = sdsnew(\"argument must be one of the following: \");\n        configEnum *enumNode = data.enumd.enum_value;\n        while(enumNode->name != NULL) {\n            enumerr = sdscatlen(enumerr, enumNode->name,\n                                strlen(enumNode->name));\n            enumerr = sdscatlen(enumerr, \", \", 2);\n            enumNode++;\n        }\n        sdsrange(enumerr,0,-3); /* Remove final \", \". */\n\n        strncpy(loadbuf, enumerr, LOADBUF_SIZE);\n        loadbuf[LOADBUF_SIZE - 1] = '\\0';\n\n        sdsfree(enumerr);\n        *err = loadbuf;\n        return 0;\n    }\n    if (data.enumd.is_valid_fn && !data.enumd.is_valid_fn(enumval, err))\n        return 0;\n    int prev = *(data.enumd.config);\n    *(data.enumd.config) = enumval;\n    if (update && data.enumd.update_fn && !data.enumd.update_fn(enumval, prev, err)) {\n        *(data.enumd.config) = prev;\n        return 0;\n    }\n    return 1;\n}\n\nstatic void enumConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, configEnumGetNameOrUnknown(data.enumd.enum_value,*data.enumd.config));\n}\n\nstatic void enumConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigEnumOption(state, name,*(data.enumd.config), data.enumd.enum_value, data.enumd.default_value);\n}\n\n#define createEnumConfig(name, alias, modifiable, enum, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(enumConfigInit, enumConfigSet, enumConfigGet, enumConfigRewrite) \\\n    .data.enumd = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .enum_value = (enum), \\\n    } \\\n}\n\n/* Gets a 'long long val' and sets it into the union, using a macro to get\n * compile time type check. */\n#define SET_NUMERIC_TYPE(val) \\\n    if (data.numeric.numeric_type == NUMERIC_TYPE_INT) { \\\n        *(data.numeric.config.i) = (int) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_UINT) { \\\n        *(data.numeric.config.ui) = (unsigned int) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG) { \\\n        *(data.numeric.config.l) = (long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG) { \\\n        *(data.numeric.config.ul) = (unsigned long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) { \\\n        *(data.numeric.config.ll) = (long long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) { \\\n        *(data.numeric.config.ull) = (unsigned long long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) { \\\n        *(data.numeric.config.st) = (size_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SSIZE_T) { \\\n        *(data.numeric.config.sst) = (ssize_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_OFF_T) { \\\n        *(data.numeric.config.ot) = (off_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_TIME_T) { \\\n        *(data.numeric.config.tt) = (time_t) val; \\\n    }\n\n/* Gets a 'long long val' and sets it with the value from the union, using a\n * macro to get compile time type check. */\n#define GET_NUMERIC_TYPE(val) \\\n    if (data.numeric.numeric_type == NUMERIC_TYPE_INT) { \\\n        val = *(data.numeric.config.i); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_UINT) { \\\n        val = *(data.numeric.config.ui); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG) { \\\n        val = *(data.numeric.config.l); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG) { \\\n        val = *(data.numeric.config.ul); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) { \\\n        val = *(data.numeric.config.ll); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) { \\\n        val = *(data.numeric.config.ull); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) { \\\n        val = *(data.numeric.config.st); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SSIZE_T) { \\\n        val = *(data.numeric.config.sst); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_OFF_T) { \\\n        val = *(data.numeric.config.ot); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_TIME_T) { \\\n        val = *(data.numeric.config.tt); \\\n    }\n\n/* Numeric configs */\nstatic void numericConfigInit(typeData data) {\n    SET_NUMERIC_TYPE(data.numeric.default_value)\n}\n\nstatic int numericBoundaryCheck(typeData data, long long ll, char **err) {\n    if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG ||\n        data.numeric.numeric_type == NUMERIC_TYPE_UINT ||\n        data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) {\n        /* Boundary check for unsigned types */\n        unsigned long long ull = ll;\n        unsigned long long upper_bound = data.numeric.upper_bound;\n        unsigned long long lower_bound = data.numeric.lower_bound;\n        if (ull > upper_bound || ull < lower_bound) {\n            snprintf(loadbuf, LOADBUF_SIZE,\n                \"argument must be between %llu and %llu inclusive\",\n                lower_bound,\n                upper_bound);\n            *err = loadbuf;\n            return 0;\n        }\n    } else {\n        /* Boundary check for signed types */\n        if (ll > data.numeric.upper_bound || ll < data.numeric.lower_bound) {\n            snprintf(loadbuf, LOADBUF_SIZE,\n                \"argument must be between %lld and %lld inclusive\",\n                data.numeric.lower_bound,\n                data.numeric.upper_bound);\n            *err = loadbuf;\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int numericConfigSet(typeData data, sds value, int update, char **err) {\n    long long ll, prev = 0;\n    if (data.numeric.is_memory) {\n        int memerr;\n        ll = memtoll(value, &memerr);\n        if (memerr || ll < 0) {\n            *err = \"argument must be a memory value\";\n            return 0;\n        }\n    } else {\n        if (!string2ll(value, sdslen(value),&ll)) {\n            *err = \"argument couldn't be parsed into an integer\" ;\n            return 0;\n        }\n    }\n\n    if (!numericBoundaryCheck(data, ll, err))\n        return 0;\n\n    if (data.numeric.is_valid_fn && !data.numeric.is_valid_fn(ll, err))\n        return 0;\n\n    GET_NUMERIC_TYPE(prev)\n    SET_NUMERIC_TYPE(ll)\n\n    if (update && data.numeric.update_fn && !data.numeric.update_fn(ll, prev, err)) {\n        SET_NUMERIC_TYPE(prev)\n        return 0;\n    }\n    return 1;\n}\n\nstatic void numericConfigGet(client *c, typeData data) {\n    char buf[128];\n    long long value = 0;\n\n    GET_NUMERIC_TYPE(value)\n\n    ll2string(buf, sizeof(buf), value);\n    addReplyBulkCString(c, buf);\n}\n\nstatic void numericConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    long long value = 0;\n\n    GET_NUMERIC_TYPE(value)\n\n    if (data.numeric.is_memory) {\n        rewriteConfigBytesOption(state, name, value, data.numeric.default_value);\n    } else {\n        rewriteConfigNumericalOption(state, name, value, data.numeric.default_value);\n    }\n}\n\n#define INTEGER_CONFIG 0\n#define MEMORY_CONFIG 1\n\n#define embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(numericConfigInit, numericConfigSet, numericConfigGet, numericConfigRewrite) \\\n    .data.numeric = { \\\n        .lower_bound = (lower), \\\n        .upper_bound = (upper), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .is_memory = (memory),\n\n#define createIntConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_INT, \\\n        .config.i = &(config_addr) \\\n    } \\\n}\n\n#define createUIntConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_UINT, \\\n        .config.ui = &(config_addr) \\\n    } \\\n}\n\n#define createLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_LONG, \\\n        .config.l = &(config_addr) \\\n    } \\\n}\n\n#define createULongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_ULONG, \\\n        .config.ul = &(config_addr) \\\n    } \\\n}\n\n#define createLongLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_LONG_LONG, \\\n        .config.ll = &(config_addr) \\\n    } \\\n}\n\n#define createULongLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_ULONG_LONG, \\\n        .config.ull = &(config_addr) \\\n    } \\\n}\n\n#define createSizeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_SIZE_T, \\\n        .config.st = &(config_addr) \\\n    } \\\n}\n\n#define createSSizeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_SSIZE_T, \\\n        .config.sst = &(config_addr) \\\n    } \\\n}\n\n#define createTimeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_TIME_T, \\\n        .config.tt = &(config_addr) \\\n    } \\\n}\n\n#define createOffTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_OFF_T, \\\n        .config.ot = &(config_addr) \\\n    } \\\n}\n\nstatic int isValidActiveDefrag(int val, char **err) {\n#ifndef HAVE_DEFRAG\n    if (val) {\n        *err = \"Active defragmentation cannot be enabled: it \"\n               \"requires a Redis server compiled with a modified Jemalloc \"\n               \"like the one shipped by default with the Redis source \"\n               \"distribution\";\n        return 0;\n    }\n#else\n    UNUSED(val);\n    UNUSED(err);\n#endif\n    return 1;\n}\n\nstatic int isValidDBfilename(char *val, char **err) {\n    if (!pathIsBaseName(val)) {\n        *err = \"dbfilename can't be a path, just a filename\";\n        return 0;\n    }\n    return 1;\n}\n\nstatic int isValidAOFfilename(char *val, char **err) {\n    if (!pathIsBaseName(val)) {\n        *err = \"appendfilename can't be a path, just a filename\";\n        return 0;\n    }\n    return 1;\n}\n\nstatic int updateHZ(long long val, long long prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    /* Hz is more a hint from the user, so we accept values out of range\n     * but cap them to reasonable values. */\n    server.config_hz = val;\n    if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;\n    if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;\n    server.hz = server.config_hz;\n    return 1;\n}\n\nstatic int updateJemallocBgThread(int val, int prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    set_jemalloc_bg_thread(val);\n    return 1;\n}\n\nstatic int updateReplBacklogSize(long long val, long long prev, char **err) {\n    /* resizeReplicationBacklog sets server.repl_backlog_size, and relies on\n     * being able to tell when the size changes, so restore prev before calling it. */\n    UNUSED(err);\n    server.repl_backlog_size = prev;\n    resizeReplicationBacklog(val);\n    return 1;\n}\n\nstatic int updateMaxmemory(long long val, long long prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    if (val) {\n        size_t used = zmalloc_used_memory()-freeMemoryGetNotCountedMemory();\n        if ((unsigned long long)val < used) {\n            serverLog(LL_WARNING,\"WARNING: the new maxmemory value set via CONFIG SET (%llu) is smaller than the current memory usage (%zu). This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy.\", server.maxmemory, used);\n        }\n        freeMemoryIfNeededAndSafe();\n    }\n    return 1;\n}\n\nstatic int updateGoodSlaves(long long val, long long prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    UNUSED(err);\n    refreshGoodSlavesCount();\n    return 1;\n}\n\nstatic int updateAppendonly(int val, int prev, char **err) {\n    UNUSED(prev);\n    if (val == 0 && server.aof_state != AOF_OFF) {\n        stopAppendOnly();\n    } else if (val && server.aof_state == AOF_OFF) {\n        if (startAppendOnly() == C_ERR) {\n            *err = \"Unable to turn on AOF. Check server logs.\";\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int updateMaxclients(long long val, long long prev, char **err) {\n    /* Try to check if the OS is capable of supporting so many FDs. */\n    if (val > prev) {\n        adjustOpenFilesLimit();\n        if (server.maxclients != val) {\n            static char msg[128];\n            sprintf(msg, \"The operating system is not able to handle the specified number of clients, try with %d\", server.maxclients);\n            *err = msg;\n            if (server.maxclients > prev) {\n                server.maxclients = prev;\n                adjustOpenFilesLimit();\n            }\n            return 0;\n        }\n        if ((unsigned int) aeGetSetSize(server.el) <\n            server.maxclients + CONFIG_FDSET_INCR)\n        {\n            if (aeResizeSetSize(server.el,\n                server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)\n            {\n                *err = \"The event loop API used by Redis is not able to handle the specified number of clients\";\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nstatic int updateOOMScoreAdj(int val, int prev, char **err) {\n    UNUSED(prev);\n\n    if (val) {\n        if (setOOMScoreAdj(-1) == C_ERR) {\n            *err = \"Failed to set current oom_score_adj. Check server logs.\";\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n#ifdef USE_OPENSSL\nstatic int updateTlsCfg(char *val, char *prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    UNUSED(err);\n\n    /* If TLS is enabled, try to configure OpenSSL. */\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n            && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        *err = \"Unable to update TLS configuration. Check server logs.\";\n        return 0;\n    }\n    return 1;\n}\nstatic int updateTlsCfgBool(int val, int prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    return updateTlsCfg(NULL, NULL, err);\n}\n\nstatic int updateTlsCfgInt(long long val, long long prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    return updateTlsCfg(NULL, NULL, err);\n}\n#endif  /* USE_OPENSSL */\n\nstandardConfig configs[] = {\n    /* Bool configs */\n    createBoolConfig(\"rdbchecksum\", NULL, IMMUTABLE_CONFIG, server.rdb_checksum, 1, NULL, NULL),\n    createBoolConfig(\"daemonize\", NULL, IMMUTABLE_CONFIG, server.daemonize, 0, NULL, NULL),\n    createBoolConfig(\"io-threads-do-reads\", NULL, IMMUTABLE_CONFIG, server.io_threads_do_reads, 0,NULL, NULL), /* Read + parse from threads? */\n    createBoolConfig(\"lua-replicate-commands\", NULL, MODIFIABLE_CONFIG, server.lua_always_replicate_commands, 1, NULL, NULL),\n    createBoolConfig(\"always-show-logo\", NULL, IMMUTABLE_CONFIG, server.always_show_logo, 0, NULL, NULL),\n    createBoolConfig(\"protected-mode\", NULL, MODIFIABLE_CONFIG, server.protected_mode, 1, NULL, NULL),\n    createBoolConfig(\"rdbcompression\", NULL, MODIFIABLE_CONFIG, server.rdb_compression, 1, NULL, NULL),\n    createBoolConfig(\"rdb-del-sync-files\", NULL, MODIFIABLE_CONFIG, server.rdb_del_sync_files, 0, NULL, NULL),\n    createBoolConfig(\"activerehashing\", NULL, MODIFIABLE_CONFIG, server.activerehashing, 1, NULL, NULL),\n    createBoolConfig(\"stop-writes-on-bgsave-error\", NULL, MODIFIABLE_CONFIG, server.stop_writes_on_bgsave_err, 1, NULL, NULL),\n    createBoolConfig(\"dynamic-hz\", NULL, MODIFIABLE_CONFIG, server.dynamic_hz, 1, NULL, NULL), /* Adapt hz to # of clients.*/\n    createBoolConfig(\"lazyfree-lazy-eviction\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_eviction, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-expire\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_expire, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-server-del\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_server_del, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-user-del\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_user_del , 0, NULL, NULL),\n    createBoolConfig(\"repl-disable-tcp-nodelay\", NULL, MODIFIABLE_CONFIG, server.repl_disable_tcp_nodelay, 0, NULL, NULL),\n    createBoolConfig(\"repl-diskless-sync\", NULL, MODIFIABLE_CONFIG, server.repl_diskless_sync, 0, NULL, NULL),\n    createBoolConfig(\"gopher-enabled\", NULL, MODIFIABLE_CONFIG, server.gopher_enabled, 0, NULL, NULL),\n    createBoolConfig(\"aof-rewrite-incremental-fsync\", NULL, MODIFIABLE_CONFIG, server.aof_rewrite_incremental_fsync, 1, NULL, NULL),\n    createBoolConfig(\"no-appendfsync-on-rewrite\", NULL, MODIFIABLE_CONFIG, server.aof_no_fsync_on_rewrite, 0, NULL, NULL),\n    createBoolConfig(\"cluster-require-full-coverage\", NULL, MODIFIABLE_CONFIG, server.cluster_require_full_coverage, 1, NULL, NULL),\n    createBoolConfig(\"rdb-save-incremental-fsync\", NULL, MODIFIABLE_CONFIG, server.rdb_save_incremental_fsync, 1, NULL, NULL),\n    createBoolConfig(\"aof-load-truncated\", NULL, MODIFIABLE_CONFIG, server.aof_load_truncated, 1, NULL, NULL),\n    createBoolConfig(\"aof-use-rdb-preamble\", NULL, MODIFIABLE_CONFIG, server.aof_use_rdb_preamble, 1, NULL, NULL),\n    createBoolConfig(\"cluster-replica-no-failover\", \"cluster-slave-no-failover\", MODIFIABLE_CONFIG, server.cluster_slave_no_failover, 0, NULL, NULL), /* Failover by default. */\n    createBoolConfig(\"replica-lazy-flush\", \"slave-lazy-flush\", MODIFIABLE_CONFIG, server.repl_slave_lazy_flush, 0, NULL, NULL),\n    createBoolConfig(\"replica-serve-stale-data\", \"slave-serve-stale-data\", MODIFIABLE_CONFIG, server.repl_serve_stale_data, 1, NULL, NULL),\n    createBoolConfig(\"replica-read-only\", \"slave-read-only\", MODIFIABLE_CONFIG, server.repl_slave_ro, 1, NULL, NULL),\n    createBoolConfig(\"replica-ignore-maxmemory\", \"slave-ignore-maxmemory\", MODIFIABLE_CONFIG, server.repl_slave_ignore_maxmemory, 1, NULL, NULL),\n    createBoolConfig(\"jemalloc-bg-thread\", NULL, MODIFIABLE_CONFIG, server.jemalloc_bg_thread, 1, NULL, updateJemallocBgThread),\n    createBoolConfig(\"activedefrag\", NULL, MODIFIABLE_CONFIG, server.active_defrag_enabled, 0, isValidActiveDefrag, NULL),\n    createBoolConfig(\"syslog-enabled\", NULL, IMMUTABLE_CONFIG, server.syslog_enabled, 0, NULL, NULL),\n    createBoolConfig(\"cluster-enabled\", NULL, IMMUTABLE_CONFIG, server.cluster_enabled, 0, NULL, NULL),\n    createBoolConfig(\"appendonly\", NULL, MODIFIABLE_CONFIG, server.aof_enabled, 0, NULL, updateAppendonly),\n    createBoolConfig(\"cluster-allow-reads-when-down\", NULL, MODIFIABLE_CONFIG, server.cluster_allow_reads_when_down, 0, NULL, NULL),\n\n    /* String Configs */\n    createStringConfig(\"aclfile\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.acl_filename, \"\", NULL, NULL),\n    createStringConfig(\"unixsocket\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.unixsocket, NULL, NULL, NULL),\n    createStringConfig(\"pidfile\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.pidfile, NULL, NULL, NULL),\n    createStringConfig(\"replica-announce-ip\", \"slave-announce-ip\", MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.slave_announce_ip, NULL, NULL, NULL),\n    createStringConfig(\"masteruser\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.masteruser, NULL, NULL, NULL),\n    createStringConfig(\"masterauth\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.masterauth, NULL, NULL, NULL),\n    createStringConfig(\"cluster-announce-ip\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.cluster_announce_ip, NULL, NULL, NULL),\n    createStringConfig(\"syslog-ident\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.syslog_ident, \"redis\", NULL, NULL),\n    createStringConfig(\"dbfilename\", NULL, MODIFIABLE_CONFIG, ALLOW_EMPTY_STRING, server.rdb_filename, \"dump.rdb\", isValidDBfilename, NULL),\n    createStringConfig(\"appendfilename\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.aof_filename, \"appendonly.aof\", isValidAOFfilename, NULL),\n    createStringConfig(\"server_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.server_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"bio_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.bio_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"aof_rewrite_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.aof_rewrite_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"bgsave_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.bgsave_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"ignore-warnings\", NULL, MODIFIABLE_CONFIG, ALLOW_EMPTY_STRING, server.ignore_warnings, \"ARM64-COW-BUG\", NULL, NULL),\n\n    /* Enum Configs */\n    createEnumConfig(\"supervised\", NULL, IMMUTABLE_CONFIG, supervised_mode_enum, server.supervised_mode, SUPERVISED_NONE, NULL, NULL),\n    createEnumConfig(\"syslog-facility\", NULL, IMMUTABLE_CONFIG, syslog_facility_enum, server.syslog_facility, LOG_LOCAL0, NULL, NULL),\n    createEnumConfig(\"repl-diskless-load\", NULL, MODIFIABLE_CONFIG, repl_diskless_load_enum, server.repl_diskless_load, REPL_DISKLESS_LOAD_DISABLED, NULL, NULL),\n    createEnumConfig(\"loglevel\", NULL, MODIFIABLE_CONFIG, loglevel_enum, server.verbosity, LL_NOTICE, NULL, NULL),\n    createEnumConfig(\"maxmemory-policy\", NULL, MODIFIABLE_CONFIG, maxmemory_policy_enum, server.maxmemory_policy, MAXMEMORY_NO_EVICTION, NULL, NULL),\n    createEnumConfig(\"appendfsync\", NULL, MODIFIABLE_CONFIG, aof_fsync_enum, server.aof_fsync, AOF_FSYNC_EVERYSEC, NULL, NULL),\n    createEnumConfig(\"oom-score-adj\", NULL, MODIFIABLE_CONFIG, oom_score_adj_enum, server.oom_score_adj, OOM_SCORE_ADJ_NO, NULL, updateOOMScoreAdj),\n\n    /* Integer configs */\n    createIntConfig(\"databases\", NULL, IMMUTABLE_CONFIG, 1, INT_MAX, server.dbnum, 16, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"port\", NULL, IMMUTABLE_CONFIG, 0, 65535, server.port, 6379, INTEGER_CONFIG, NULL, NULL), /* TCP port. */\n    createIntConfig(\"io-threads\", NULL, IMMUTABLE_CONFIG, 1, 128, server.io_threads_num, 1, INTEGER_CONFIG, NULL, NULL), /* Single threaded by default */\n    createIntConfig(\"auto-aof-rewrite-percentage\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.aof_rewrite_perc, 100, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"cluster-replica-validity-factor\", \"cluster-slave-validity-factor\", MODIFIABLE_CONFIG, 0, INT_MAX, server.cluster_slave_validity_factor, 10, INTEGER_CONFIG, NULL, NULL), /* Slave max data age factor. */\n    createIntConfig(\"list-max-ziplist-size\", NULL, MODIFIABLE_CONFIG, INT_MIN, INT_MAX, server.list_max_ziplist_size, -2, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"tcp-keepalive\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tcpkeepalive, 300, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"cluster-migration-barrier\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.cluster_migration_barrier, 1, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"active-defrag-cycle-min\", NULL, MODIFIABLE_CONFIG, 1, 99, server.active_defrag_cycle_min, 1, INTEGER_CONFIG, NULL, NULL), /* Default: 1% CPU min (at lower threshold) */\n    createIntConfig(\"active-defrag-cycle-max\", NULL, MODIFIABLE_CONFIG, 1, 99, server.active_defrag_cycle_max, 25, INTEGER_CONFIG, NULL, NULL), /* Default: 25% CPU max (at upper threshold) */\n    createIntConfig(\"active-defrag-threshold-lower\", NULL, MODIFIABLE_CONFIG, 0, 1000, server.active_defrag_threshold_lower, 10, INTEGER_CONFIG, NULL, NULL), /* Default: don't defrag when fragmentation is below 10% */\n    createIntConfig(\"active-defrag-threshold-upper\", NULL, MODIFIABLE_CONFIG, 0, 1000, server.active_defrag_threshold_upper, 100, INTEGER_CONFIG, NULL, NULL), /* Default: maximum defrag force at 100% fragmentation */\n    createIntConfig(\"lfu-log-factor\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.lfu_log_factor, 10, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"lfu-decay-time\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.lfu_decay_time, 1, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"replica-priority\", \"slave-priority\", MODIFIABLE_CONFIG, 0, INT_MAX, server.slave_priority, 100, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"repl-diskless-sync-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_diskless_sync_delay, 5, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"maxmemory-samples\", NULL, MODIFIABLE_CONFIG, 1, INT_MAX, server.maxmemory_samples, 5, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"timeout\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.maxidletime, 0, INTEGER_CONFIG, NULL, NULL), /* Default client timeout: infinite */\n    createIntConfig(\"replica-announce-port\", \"slave-announce-port\", MODIFIABLE_CONFIG, 0, 65535, server.slave_announce_port, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"tcp-backlog\", NULL, IMMUTABLE_CONFIG, 0, INT_MAX, server.tcp_backlog, 511, INTEGER_CONFIG, NULL, NULL), /* TCP listen backlog. */\n    createIntConfig(\"cluster-announce-bus-port\", NULL, MODIFIABLE_CONFIG, 0, 65535, server.cluster_announce_bus_port, 0, INTEGER_CONFIG, NULL, NULL), /* Default: Use +10000 offset. */\n    createIntConfig(\"cluster-announce-port\", NULL, MODIFIABLE_CONFIG, 0, 65535, server.cluster_announce_port, 0, INTEGER_CONFIG, NULL, NULL), /* Use server.port */\n    createIntConfig(\"repl-timeout\", NULL, MODIFIABLE_CONFIG, 1, INT_MAX, server.repl_timeout, 60, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"repl-ping-replica-period\", \"repl-ping-slave-period\", MODIFIABLE_CONFIG, 1, INT_MAX, server.repl_ping_slave_period, 10, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"list-compress-depth\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.list_compress_depth, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"rdb-key-save-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.rdb_key_save_delay, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"key-load-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.key_load_delay, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"active-expire-effort\", NULL, MODIFIABLE_CONFIG, 1, 10, server.active_expire_effort, 1, INTEGER_CONFIG, NULL, NULL), /* From 1 to 10. */\n    createIntConfig(\"hz\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.config_hz, CONFIG_DEFAULT_HZ, INTEGER_CONFIG, NULL, updateHZ),\n    createIntConfig(\"min-replicas-to-write\", \"min-slaves-to-write\", MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_min_slaves_to_write, 0, INTEGER_CONFIG, NULL, updateGoodSlaves),\n    createIntConfig(\"min-replicas-max-lag\", \"min-slaves-max-lag\", MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_min_slaves_max_lag, 10, INTEGER_CONFIG, NULL, updateGoodSlaves),\n\n    /* Unsigned int configs */\n    createUIntConfig(\"maxclients\", NULL, MODIFIABLE_CONFIG, 1, UINT_MAX, server.maxclients, 10000, INTEGER_CONFIG, NULL, updateMaxclients),\n\n    /* Unsigned Long configs */\n    createULongConfig(\"active-defrag-max-scan-fields\", NULL, MODIFIABLE_CONFIG, 1, LONG_MAX, server.active_defrag_max_scan_fields, 1000, INTEGER_CONFIG, NULL, NULL), /* Default: keys with more than 1000 fields will be processed separately */\n    createULongConfig(\"slowlog-max-len\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.slowlog_max_len, 128, INTEGER_CONFIG, NULL, NULL),\n    createULongConfig(\"acllog-max-len\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.acllog_max_len, 128, INTEGER_CONFIG, NULL, NULL),\n\n    /* Long Long configs */\n    createLongLongConfig(\"lua-time-limit\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.lua_time_limit, 5000, INTEGER_CONFIG, NULL, NULL),/* milliseconds */\n    createLongLongConfig(\"cluster-node-timeout\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.cluster_node_timeout, 15000, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"slowlog-log-slower-than\", NULL, MODIFIABLE_CONFIG, -1, LLONG_MAX, server.slowlog_log_slower_than, 10000, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"latency-monitor-threshold\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.latency_monitor_threshold, 0, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"proto-max-bulk-len\", NULL, MODIFIABLE_CONFIG, 1024*1024, LLONG_MAX, server.proto_max_bulk_len, 512ll*1024*1024, MEMORY_CONFIG, NULL, NULL), /* Bulk request max size */\n    createLongLongConfig(\"stream-node-max-entries\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.stream_node_max_entries, 100, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"repl-backlog-size\", NULL, MODIFIABLE_CONFIG, 1, LLONG_MAX, server.repl_backlog_size, 1024*1024, MEMORY_CONFIG, NULL, updateReplBacklogSize), /* Default: 1mb */\n\n    /* Unsigned Long Long configs */\n    createULongLongConfig(\"maxmemory\", NULL, MODIFIABLE_CONFIG, 0, ULLONG_MAX, server.maxmemory, 0, MEMORY_CONFIG, NULL, updateMaxmemory),\n\n    /* Size_t configs */\n    createSizeTConfig(\"hash-max-ziplist-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hash_max_ziplist_entries, 512, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"set-max-intset-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.set_max_intset_entries, 512, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"zset-max-ziplist-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.zset_max_ziplist_entries, 128, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"active-defrag-ignore-bytes\", NULL, MODIFIABLE_CONFIG, 1, LLONG_MAX, server.active_defrag_ignore_bytes, 100<<20, MEMORY_CONFIG, NULL, NULL), /* Default: don't defrag if frag overhead is below 100mb */\n    createSizeTConfig(\"hash-max-ziplist-value\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hash_max_ziplist_value, 64, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"stream-node-max-bytes\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.stream_node_max_bytes, 4096, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"zset-max-ziplist-value\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.zset_max_ziplist_value, 64, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"hll-sparse-max-bytes\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hll_sparse_max_bytes, 3000, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"tracking-table-max-keys\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.tracking_table_max_keys, 1000000, INTEGER_CONFIG, NULL, NULL), /* Default: 1 million keys max. */\n\n    /* Other configs */\n    createTimeTConfig(\"repl-backlog-ttl\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.repl_backlog_time_limit, 60*60, INTEGER_CONFIG, NULL, NULL), /* Default: 1 hour */\n    createOffTConfig(\"auto-aof-rewrite-min-size\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.aof_rewrite_min_size, 64*1024*1024, MEMORY_CONFIG, NULL, NULL),\n\n#ifdef USE_OPENSSL\n    createIntConfig(\"tls-port\", NULL, IMMUTABLE_CONFIG, 0, 65535, server.tls_port, 0, INTEGER_CONFIG, NULL, updateTlsCfgInt), /* TCP port. */\n    createIntConfig(\"tls-session-cache-size\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tls_ctx_config.session_cache_size, 20*1024, INTEGER_CONFIG, NULL, updateTlsCfgInt),\n    createIntConfig(\"tls-session-cache-timeout\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tls_ctx_config.session_cache_timeout, 300, INTEGER_CONFIG, NULL, updateTlsCfgInt),\n    createBoolConfig(\"tls-cluster\", NULL, MODIFIABLE_CONFIG, server.tls_cluster, 0, NULL, updateTlsCfgBool),\n    createBoolConfig(\"tls-replication\", NULL, MODIFIABLE_CONFIG, server.tls_replication, 0, NULL, updateTlsCfgBool),\n    createEnumConfig(\"tls-auth-clients\", NULL, MODIFIABLE_CONFIG, tls_auth_clients_enum, server.tls_auth_clients, TLS_CLIENT_AUTH_YES, NULL, NULL),\n    createBoolConfig(\"tls-prefer-server-ciphers\", NULL, MODIFIABLE_CONFIG, server.tls_ctx_config.prefer_server_ciphers, 0, NULL, updateTlsCfgBool),\n    createBoolConfig(\"tls-session-caching\", NULL, MODIFIABLE_CONFIG, server.tls_ctx_config.session_caching, 1, NULL, updateTlsCfgBool),\n    createStringConfig(\"tls-cert-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.cert_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-key-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.key_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-dh-params-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.dh_params_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ca-cert-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ca_cert_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ca-cert-dir\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ca_cert_dir, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-protocols\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.protocols, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ciphers\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ciphers, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ciphersuites\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ciphersuites, NULL, NULL, updateTlsCfg),\n#endif\n\n    /* NULL Terminator */\n    {NULL}\n};\n\n/*-----------------------------------------------------------------------------\n * CONFIG command entry point\n *----------------------------------------------------------------------------*/\n\nvoid configCommand(client *c) {\n    /* Only allow CONFIG GET while loading. */\n    if (server.loading && strcasecmp(c->argv[1]->ptr,\"get\")) {\n        addReplyError(c,\"Only CONFIG GET is allowed during loading\");\n        return;\n    }\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"GET <pattern> -- Return parameters matching the glob-like <pattern> and their values.\",\n\"SET <parameter> <value> -- Set parameter to value.\",\n\"RESETSTAT -- Reset statistics reported by INFO.\",\n\"REWRITE -- Rewrite the configuration file.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set\") && c->argc == 4) {\n        configSetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"get\") && c->argc == 3) {\n        configGetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"resetstat\") && c->argc == 2) {\n        resetServerStats();\n        resetCommandTableStats();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"rewrite\") && c->argc == 2) {\n        if (server.configfile == NULL) {\n            addReplyError(c,\"The server is running without a config file\");\n            return;\n        }\n        if (rewriteConfig(server.configfile, 0) == -1) {\n            serverLog(LL_WARNING,\"CONFIG REWRITE failed: %s\", strerror(errno));\n            addReplyErrorFormat(c,\"Rewriting config file: %s\", strerror(errno));\n        } else {\n            serverLog(LL_WARNING,\"CONFIG REWRITE executed with success.\");\n            addReply(c,shared.ok);\n        }\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n", "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <limits.h>\n#include \"sds.h\"\n#include \"sdsalloc.h\"\n\nconst char *SDS_NOINIT = \"SDS_NOINIT\";\n\nstatic inline int sdsHdrSize(char type) {\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            return sizeof(struct sdshdr8);\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16);\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32);\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64);\n    }\n    return 0;\n}\n\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5)\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-termined (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}\n\n/* Create an empty (zero length) sds string. Even in this case the string\n * always has an implicit null term. */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n\n/* Create a new sds string starting from a null terminated C string. */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n\n/* Duplicate an sds string. */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n\n/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n *\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\nvoid sdsupdatelen(sds s) {\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}\n\n/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\nvoid sdsclear(sds s) {\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}\n\n/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}\n\n/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdsRemoveFreeSpace(sds s) {\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);\n    size_t len = sdslen(s);\n    size_t avail = sdsavail(s);\n    sh = (char*)s-oldhdrlen;\n\n    /* Return ASAP if there is no space left. */\n    if (avail == 0) return s;\n\n    /* Check what would be the minimum SDS header that is just good enough to\n     * fit this string. */\n    type = sdsReqType(len);\n    hdrlen = sdsHdrSize(type);\n\n    /* If the type is the same, or at least a large enough type is still\n     * required, we just realloc(), letting the allocator to do the copy\n     * only if really needed. Otherwise if the change is huge, we manually\n     * reallocate the string to use the different header type. */\n    if (oldtype==type || type > SDS_TYPE_8) {\n        newsh = s_realloc(sh, oldhdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+oldhdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, len);\n    return s;\n}\n\n/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\nsize_t sdsAllocSize(sds s) {\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}\n\n/* Return the pointer of the actual SDS allocation (normally SDS strings\n * are referenced by the start of the string buffer). */\nvoid *sdsAllocPtr(sds s) {\n    return (void*) (s-sdsHdrSize(s[-1]));\n}\n\n/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\nvoid sdsIncrLen(sds s, ssize_t incr) {\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}\n\n/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\nsds sdsgrowzero(sds s, size_t len) {\n    size_t curlen = sdslen(s);\n\n    if (len <= curlen) return s;\n    s = sdsMakeRoomFor(s,len-curlen);\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s);\n\n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}\n\n/* Append the specified null terminated C string to the sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n\n/* Append the specified sds 't' to the existing sds 's'.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n\n/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\nsds sdscpylen(sds s, const char *t, size_t len) {\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Like sdscpylen() but 't' must be a null-termined string so that the length\n * of the string is obtained with strlen(). */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * a reversed string. */\n    v = (value < 0) ? -value : value;\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Identical sdsll2str(), but for unsigned long long type. */\nint sdsull2str(char *s, unsigned long long v) {\n    char *p, aux;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * a reversed string. */\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}\n\n/* Like sdscatprintf() but gets va_list instead of being variadic. */\nsds sdscatvprintf(sds s, const char *fmt, va_list ap) {\n    va_list cpy;\n    char staticbuf[1024], *buf = staticbuf, *t;\n    size_t buflen = strlen(fmt)*2;\n    int bufstrlen;\n\n    /* We try to start using a static buffer for speed.\n     * If not possible we revert to heap allocation. */\n    if (buflen > sizeof(staticbuf)) {\n        buf = s_malloc(buflen);\n        if (buf == NULL) return NULL;\n    } else {\n        buflen = sizeof(staticbuf);\n    }\n\n    /* Alloc enough space for buffer and \\0 after failing to\n     * fit the string in the current buffer size. */\n    while(1) {\n        va_copy(cpy,ap);\n        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);\n        va_end(cpy);\n        if (bufstrlen < 0) {\n            if (buf != staticbuf) s_free(buf);\n            return NULL;\n        }\n        if (((size_t)bufstrlen) >= buflen) {\n            if (buf != staticbuf) s_free(buf);\n            buflen = ((size_t)bufstrlen) + 1;\n            buf = s_malloc(buflen);\n            if (buf == NULL) return NULL;\n            continue;\n        }\n        break;\n    }\n\n    /* Finally concat the obtained string to the SDS string and return it. */\n    t = sdscatlen(s, buf, bufstrlen);\n    if (buf != staticbuf) s_free(buf);\n    return t;\n}\n\n/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\nsds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}\n\n/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\nsds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}\n\n/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminted C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\nsds sdstrim(sds s, const char *cset) {\n    char *start, *end, *sp, *ep;\n    size_t len;\n\n    sp = start = s;\n    ep = end = s+sdslen(s)-1;\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--;\n    len = (sp > ep) ? 0 : ((ep-sp)+1);\n    if (s != sp) memmove(s, sp, len);\n    s[len] = '\\0';\n    sdssetlen(s,len);\n    return s;\n}\n\n/* Turn the string into a smaller (or equal) string containing only the\n * substring specified by the 'start' and 'end' indexes.\n *\n * start and end can be negative, where -1 means the last character of the\n * string, -2 the penultimate character, and so forth.\n *\n * The interval is inclusive, so the start and end characters will be part\n * of the resulting string.\n *\n * The string is modified in-place.\n *\n * Example:\n *\n * s = sdsnew(\"Hello World\");\n * sdsrange(s,1,-1); => \"ello World\"\n */\nvoid sdsrange(sds s, ssize_t start, ssize_t end) {\n    size_t newlen, len = sdslen(s);\n\n    if (len == 0) return;\n    if (start < 0) {\n        start = len+start;\n        if (start < 0) start = 0;\n    }\n    if (end < 0) {\n        end = len+end;\n        if (end < 0) end = 0;\n    }\n    newlen = (start > end) ? 0 : (end-start)+1;\n    if (newlen != 0) {\n        if (start >= (ssize_t)len) {\n            newlen = 0;\n        } else if (end >= (ssize_t)len) {\n            end = len-1;\n            newlen = (start > end) ? 0 : (end-start)+1;\n        }\n    } else {\n        start = 0;\n    }\n    if (start && newlen) memmove(s, s+start, newlen);\n    s[newlen] = 0;\n    sdssetlen(s,newlen);\n}\n\n/* Apply tolower() to every character of the sds string 's'. */\nvoid sdstolower(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}\n\n/* Apply toupper() to every character of the sds string 's'. */\nvoid sdstoupper(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}\n\n/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\nint sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}\n\n/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5;\n    long start = 0, j;\n    sds *tokens;\n\n    if (seplen < 1 || len < 0) return NULL;\n\n    tokens = s_malloc(sizeof(sds)*slots);\n    if (tokens == NULL) return NULL;\n\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        if (slots < elements+2) {\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) goto cleanup;\n            tokens = newtokens;\n        }\n        /* search the separator */\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start);\n            if (tokens[elements] == NULL) goto cleanup;\n            elements++;\n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start);\n    if (tokens[elements] == NULL) goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        s_free(tokens);\n        *count = 0;\n        return NULL;\n    }\n}\n\n/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\nvoid sdsfreesplitres(sds *tokens, int count) {\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}\n\n/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s,\"\\\"\",1);\n    while(len--) {\n        switch(*p) {\n        case '\\\\':\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:\n            if (isprint(*p))\n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1);\n}\n\n/* Helper function for sdssplitargs() that returns non zero if 'c'\n * is a valid hex digit. */\nint is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n           (c >= 'A' && c <= 'F');\n}\n\n/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\nint hex_digit_to_int(char c) {\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}\n\n/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\nsds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */\n            int insq=0; /* set to 1 if we are in 'single quotes' */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);\n                        p += 3;\n                    } else if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) {\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    case '\\'':\n                        insq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}\n\n/* Modify the string substituting all the occurrences of the set of\n * characters specified in the 'from' string to the corresponding character\n * in the 'to' array.\n *\n * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2)\n * will have the effect of turning the string \"hello\" into \"0ell1\".\n *\n * The function returns the sds string pointer, that is always the same\n * as the input pointer since no resize is needed. */\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\nsds sdsjoin(char **argv, int argc, char *sep) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}\n\n/* Like sdsjoin, but joins an array of SDS strings. */\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}\n\n/* Wrappers to the allocators used by SDS. Note that SDS will actually\n * just use the macros defined into sdsalloc.h in order to avoid to pay\n * the overhead of function calls. Here we define these wrappers only for\n * the programs SDS is linked to, if they want to touch the SDS internals\n * even if they use a different allocator. */\nvoid *sds_malloc(size_t size) { return s_malloc(size); }\nvoid *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\nvoid sds_free(void *ptr) { s_free(ptr); }\n\n#if defined(SDS_TEST_MAIN)\n#include <stdio.h>\n#include \"testhelp.h\"\n#include \"limits.h\"\n\n#define UNUSED(x) (void)(x)\nint sdsTest(void) {\n    {\n        sds x = sdsnew(\"foo\"), y;\n\n        test_cond(\"Create a string and obtain the length\",\n            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnewlen(\"foo\",2);\n        test_cond(\"Create a string with specified length\",\n            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n\n        x = sdscat(x,\"bar\");\n        test_cond(\"Strings concatenation\",\n            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\n        x = sdscpy(x,\"a\");\n        test_cond(\"sdscpy() against an originally longer string\",\n            sdslen(x) == 1 && memcmp(x,\"a\\0\",2) == 0)\n\n        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\");\n        test_cond(\"sdscpy() against an originally shorter string\",\n            sdslen(x) == 33 &&\n            memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0\",33) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"%d\",123);\n        test_cond(\"sdscatprintf() seems working in the base case\",\n            sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"a%cb\",0);\n        test_cond(\"sdscatprintf() seems working with \\\\0 inside of result\",\n            sdslen(x) == 3 && memcmp(x,\"a\\0\"\"b\\0\",4) == 0)\n\n        {\n            sdsfree(x);\n            char etalon[1024*1024];\n            for (size_t i = 0; i < sizeof(etalon); i++) {\n                etalon[i] = '0';\n            }\n            x = sdscatprintf(sdsempty(),\"%0*d\",(int)sizeof(etalon),0);\n            test_cond(\"sdscatprintf() can print 1MB\",\n                sdslen(x) == sizeof(etalon) && memcmp(x,etalon,sizeof(etalon)) == 0)\n        }\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n        test_cond(\"sdscatfmt() seems working in the base case\",\n            sdslen(x) == 60 &&\n            memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\n                     \"9223372036854775807--\",60) == 0)\n        printf(\"[%s]\\n\",x);\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n        test_cond(\"sdscatfmt() seems working with unsigned numbers\",\n            sdslen(x) == 35 &&\n            memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" x\");\n        test_cond(\"sdstrim() works when all chars match\",\n            sdslen(x) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" \");\n        test_cond(\"sdstrim() works when a single char remains\",\n            sdslen(x) == 1 && x[0] == 'x')\n\n        sdsfree(x);\n        x = sdsnew(\"xxciaoyyy\");\n        sdstrim(x,\"xy\");\n        test_cond(\"sdstrim() correctly trims characters\",\n            sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n\n        y = sdsdup(x);\n        sdsrange(y,1,1);\n        test_cond(\"sdsrange(...,1,1)\",\n            sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,-1);\n        test_cond(\"sdsrange(...,1,-1)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,-2,-1);\n        test_cond(\"sdsrange(...,-2,-1)\",\n            sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,2,1);\n        test_cond(\"sdsrange(...,2,1)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,100);\n        test_cond(\"sdsrange(...,1,100)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,100,100);\n        test_cond(\"sdsrange(...,100,100)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"foo\");\n        y = sdsnew(\"foa\");\n        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y) > 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"bar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"aar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) < 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n        y = sdscatrepr(sdsempty(),x,sdslen(x));\n        test_cond(\"sdscatrepr(...data...)\",\n            memcmp(y,\"\\\"\\\\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n\n        {\n            unsigned int oldfree;\n            char *p;\n            int step = 10, j, i;\n\n            sdsfree(x);\n            sdsfree(y);\n            x = sdsnew(\"0\");\n            test_cond(\"sdsnew() free/len buffers\", sdslen(x) == 1 && sdsavail(x) == 0);\n\n            /* Run the test a few times in order to hit the first two\n             * SDS header types. */\n            for (i = 0; i < 10; i++) {\n                int oldlen = sdslen(x);\n                x = sdsMakeRoomFor(x,step);\n                int type = x[-1]&SDS_TYPE_MASK;\n\n                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n                if (type != SDS_TYPE_5) {\n                    test_cond(\"sdsMakeRoomFor() free\", sdsavail(x) >= step);\n                    oldfree = sdsavail(x);\n                }\n                p = x+oldlen;\n                for (j = 0; j < step; j++) {\n                    p[j] = 'A'+j;\n                }\n                sdsIncrLen(x,step);\n            }\n            test_cond(\"sdsMakeRoomFor() content\",\n                memcmp(\"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\",x,101) == 0);\n            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n\n            sdsfree(x);\n        }\n    }\n    test_report()\n    return 0;\n}\n#endif\n\n#ifdef SDS_TEST_MAIN\nint main(void) {\n    return sdsTest();\n}\n#endif\n", "/* zmalloc - total amount of allocated memory aware version of malloc()\n *\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n/* This function provide us access to the original libc free(). This is useful\n * for instance to free results obtained by backtrace_symbols(). We need\n * to define this function before including zmalloc.h that may shadow the\n * free implementation if we use jemalloc or another non standard allocator. */\nvoid zlibc_free(void *ptr) {\n    free(ptr);\n}\n\n#include <string.h>\n#include <pthread.h>\n#include \"config.h\"\n#include \"zmalloc.h\"\n#include \"atomicvar.h\"\n\n#ifdef HAVE_MALLOC_SIZE\n#define PREFIX_SIZE (0)\n#else\n#if defined(__sun) || defined(__sparc) || defined(__sparc__)\n#define PREFIX_SIZE (sizeof(long long))\n#else\n#define PREFIX_SIZE (sizeof(size_t))\n#endif\n#endif\n\n/* Explicitly override malloc/free etc when using tcmalloc. */\n#if defined(USE_TCMALLOC)\n#define malloc(size) tc_malloc(size)\n#define calloc(count,size) tc_calloc(count,size)\n#define realloc(ptr,size) tc_realloc(ptr,size)\n#define free(ptr) tc_free(ptr)\n#elif defined(USE_JEMALLOC)\n#define malloc(size) je_malloc(size)\n#define calloc(count,size) je_calloc(count,size)\n#define realloc(ptr,size) je_realloc(ptr,size)\n#define free(ptr) je_free(ptr)\n#define mallocx(size,flags) je_mallocx(size,flags)\n#define dallocx(ptr,flags) je_dallocx(ptr,flags)\n#endif\n\n#define update_zmalloc_stat_alloc(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicIncr(used_memory,__n); \\\n} while(0)\n\n#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0)\n\nstatic size_t used_memory = 0;\npthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void zmalloc_default_oom(size_t size) {\n    fprintf(stderr, \"zmalloc: Out of memory trying to allocate %zu bytes\\n\",\n        size);\n    fflush(stderr);\n    abort();\n}\n\nstatic void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;\n\nvoid *zmalloc(size_t size) {\n    void *ptr = malloc(size+PREFIX_SIZE);\n\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n\n/* Allocation and free functions that bypass the thread cache\n * and go straight to the allocator arena bins.\n * Currently implemented only for jemalloc. Used for online defragmentation. */\n#ifdef HAVE_DEFRAG\nvoid *zmalloc_no_tcache(size_t size) {\n    void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);\n    if (!ptr) zmalloc_oom_handler(size);\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n}\n\nvoid zfree_no_tcache(void *ptr) {\n    if (ptr == NULL) return;\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    dallocx(ptr, MALLOCX_TCACHE_NONE);\n}\n#endif\n\nvoid *zcalloc(size_t size) {\n    void *ptr = calloc(1, size+PREFIX_SIZE);\n\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n\nvoid *zrealloc(void *ptr, size_t size) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n#endif\n    size_t oldsize;\n    void *newptr;\n\n    if (size == 0 && ptr != NULL) {\n        zfree(ptr);\n        return NULL;\n    }\n    if (ptr == NULL) return zmalloc(size);\n#ifdef HAVE_MALLOC_SIZE\n    oldsize = zmalloc_size(ptr);\n    newptr = realloc(ptr,size);\n    if (!newptr) zmalloc_oom_handler(size);\n\n    update_zmalloc_stat_free(oldsize);\n    update_zmalloc_stat_alloc(zmalloc_size(newptr));\n    return newptr;\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    newptr = realloc(realptr,size+PREFIX_SIZE);\n    if (!newptr) zmalloc_oom_handler(size);\n\n    *((size_t*)newptr) = size;\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)newptr+PREFIX_SIZE;\n#endif\n}\n\n/* Provide zmalloc_size() for systems where this function is not provided by\n * malloc itself, given that in that case we store a header with this\n * information as the first bytes of every allocation. */\n#ifndef HAVE_MALLOC_SIZE\nsize_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    return size+PREFIX_SIZE;\n}\nsize_t zmalloc_usable(void *ptr) {\n    return zmalloc_size(ptr)-PREFIX_SIZE;\n}\n#endif\n\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n\nchar *zstrdup(const char *s) {\n    size_t l = strlen(s)+1;\n    char *p = zmalloc(l);\n\n    memcpy(p,s,l);\n    return p;\n}\n\nsize_t zmalloc_used_memory(void) {\n    size_t um;\n    atomicGet(used_memory,um);\n    return um;\n}\n\nvoid zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {\n    zmalloc_oom_handler = oom_handler;\n}\n\n/* Get the RSS information in an OS-specific way.\n *\n * WARNING: the function zmalloc_get_rss() is not designed to be fast\n * and may not be called in the busy loops where Redis tries to release\n * memory expiring or swapping out objects.\n *\n * For this kind of \"fast RSS reporting\" usages use instead the\n * function RedisEstimateRSS() that is a much faster (and less precise)\n * version of the function. */\n\n#if defined(HAVE_PROC_STAT)\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nsize_t zmalloc_get_rss(void) {\n    int page = sysconf(_SC_PAGESIZE);\n    size_t rss;\n    char buf[4096];\n    char filename[256];\n    int fd, count;\n    char *p, *x;\n\n    snprintf(filename,256,\"/proc/%d/stat\",getpid());\n    if ((fd = open(filename,O_RDONLY)) == -1) return 0;\n    if (read(fd,buf,4096) <= 0) {\n        close(fd);\n        return 0;\n    }\n    close(fd);\n\n    p = buf;\n    count = 23; /* RSS is the 24th field in /proc/<pid>/stat */\n    while(p && count--) {\n        p = strchr(p,' ');\n        if (p) p++;\n    }\n    if (!p) return 0;\n    x = strchr(p,' ');\n    if (!x) return 0;\n    *x = '\\0';\n\n    rss = strtoll(p,NULL,10);\n    rss *= page;\n    return rss;\n}\n#elif defined(HAVE_TASKINFO)\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <mach/task.h>\n#include <mach/mach_init.h>\n\nsize_t zmalloc_get_rss(void) {\n    task_t task = MACH_PORT_NULL;\n    struct task_basic_info t_info;\n    mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;\n\n    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)\n        return 0;\n    task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);\n\n    return t_info.resident_size;\n}\n#elif defined(__FreeBSD__)\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n#include <unistd.h>\n\nsize_t zmalloc_get_rss(void) {\n    struct kinfo_proc info;\n    size_t infolen = sizeof(info);\n    int mib[4];\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = getpid();\n\n    if (sysctl(mib, 4, &info, &infolen, NULL, 0) == 0)\n        return (size_t)info.ki_rssize;\n\n    return 0L;\n}\n#elif defined(__NetBSD__)\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <unistd.h>\n\nsize_t zmalloc_get_rss(void) {\n    struct kinfo_proc2 info;\n    size_t infolen = sizeof(info);\n    int mib[6];\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = getpid();\n    mib[4] = sizeof(info);\n    mib[5] = 1;\n    if (sysctl(mib, 4, &info, &infolen, NULL, 0) == 0)\n        return (size_t)info.p_vm_rssize;\n\n    return 0L;\n}\n#else\nsize_t zmalloc_get_rss(void) {\n    /* If we can't get the RSS in an OS-specific way for this system just\n     * return the memory usage we estimated in zmalloc()..\n     *\n     * Fragmentation will appear to be always 1 (no fragmentation)\n     * of course... */\n    return zmalloc_used_memory();\n}\n#endif\n\n#if defined(USE_JEMALLOC)\n\nint zmalloc_get_allocator_info(size_t *allocated,\n                               size_t *active,\n                               size_t *resident) {\n    uint64_t epoch = 1;\n    size_t sz;\n    *allocated = *resident = *active = 0;\n    /* Update the statistics cached by mallctl. */\n    sz = sizeof(epoch);\n    je_mallctl(\"epoch\", &epoch, &sz, &epoch, sz);\n    sz = sizeof(size_t);\n    /* Unlike RSS, this does not include RSS from shared libraries and other non\n     * heap mappings. */\n    je_mallctl(\"stats.resident\", resident, &sz, NULL, 0);\n    /* Unlike resident, this doesn't not include the pages jemalloc reserves\n     * for re-use (purge will clean that). */\n    je_mallctl(\"stats.active\", active, &sz, NULL, 0);\n    /* Unlike zmalloc_used_memory, this matches the stats.resident by taking\n     * into account all allocations done by this process (not only zmalloc). */\n    je_mallctl(\"stats.allocated\", allocated, &sz, NULL, 0);\n    return 1;\n}\n\nvoid set_jemalloc_bg_thread(int enable) {\n    /* let jemalloc do purging asynchronously, required when there's no traffic \n     * after flushdb */\n    char val = !!enable;\n    je_mallctl(\"background_thread\", NULL, 0, &val, 1);\n}\n\nint jemalloc_purge() {\n    /* return all unused (reserved) pages to the OS */\n    char tmp[32];\n    unsigned narenas = 0;\n    size_t sz = sizeof(unsigned);\n    if (!je_mallctl(\"arenas.narenas\", &narenas, &sz, NULL, 0)) {\n        sprintf(tmp, \"arena.%d.purge\", narenas);\n        if (!je_mallctl(tmp, NULL, 0, NULL, 0))\n            return 0;\n    }\n    return -1;\n}\n\n#else\n\nint zmalloc_get_allocator_info(size_t *allocated,\n                               size_t *active,\n                               size_t *resident) {\n    *allocated = *resident = *active = 0;\n    return 1;\n}\n\nvoid set_jemalloc_bg_thread(int enable) {\n    ((void)(enable));\n}\n\nint jemalloc_purge() {\n    return 0;\n}\n\n#endif\n\n#if defined(__APPLE__)\n/* For proc_pidinfo() used later in zmalloc_get_smap_bytes_by_field().\n * Note that this file cannot be included in zmalloc.h because it includes\n * a Darwin queue.h file where there is a \"LIST_HEAD\" macro (!) defined\n * conficting with Redis user code. */\n#include <libproc.h>\n#endif\n\n/* Get the sum of the specified field (converted form kb to bytes) in\n * /proc/self/smaps. The field must be specified with trailing \":\" as it\n * apperas in the smaps output.\n *\n * If a pid is specified, the information is extracted for such a pid,\n * otherwise if pid is -1 the information is reported is about the\n * current process.\n *\n * Example: zmalloc_get_smap_bytes_by_field(\"Rss:\",-1);\n */\n#if defined(HAVE_PROC_SMAPS)\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\n    char line[1024];\n    size_t bytes = 0;\n    int flen = strlen(field);\n    FILE *fp;\n\n    if (pid == -1) {\n        fp = fopen(\"/proc/self/smaps\",\"r\");\n    } else {\n        char filename[128];\n        snprintf(filename,sizeof(filename),\"/proc/%ld/smaps\",pid);\n        fp = fopen(filename,\"r\");\n    }\n\n    if (!fp) return 0;\n    while(fgets(line,sizeof(line),fp) != NULL) {\n        if (strncmp(line,field,flen) == 0) {\n            char *p = strchr(line,'k');\n            if (p) {\n                *p = '\\0';\n                bytes += strtol(line+flen,NULL,10) * 1024;\n            }\n        }\n    }\n    fclose(fp);\n    return bytes;\n}\n#else\n/* Get sum of the specified field from libproc api call.\n * As there are per page value basis we need to convert\n * them accordingly.\n *\n * Note that AnonHugePages is a no-op as THP feature\n * is not supported in this platform\n */\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\n#if defined(__APPLE__)\n    struct proc_regioninfo pri;\n    if (proc_pidinfo(pid, PROC_PIDREGIONINFO, 0, &pri, PROC_PIDREGIONINFO_SIZE) ==\n\tPROC_PIDREGIONINFO_SIZE) {\n\tif (!strcmp(field, \"Private_Dirty:\")) {\n            return (size_t)pri.pri_pages_dirtied * 4096;\n\t} else if (!strcmp(field, \"Rss:\")) {\n            return (size_t)pri.pri_pages_resident * 4096;\n\t} else if (!strcmp(field, \"AnonHugePages:\")) {\n            return 0;\n\t}\n    }\n    return 0;\n#endif\n    ((void) field);\n    ((void) pid);\n    return 0;\n}\n#endif\n\nsize_t zmalloc_get_private_dirty(long pid) {\n    return zmalloc_get_smap_bytes_by_field(\"Private_Dirty:\",pid);\n}\n\n/* Returns the size of physical memory (RAM) in bytes.\n * It looks ugly, but this is the cleanest way to achieve cross platform results.\n * Cleaned up from:\n *\n * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system\n *\n * Note that this function:\n * 1) Was released under the following CC attribution license:\n *    http://creativecommons.org/licenses/by/3.0/deed.en_US.\n * 2) Was originally implemented by David Robert Nadeau.\n * 3) Was modified for Redis by Matt Stancliff.\n * 4) This note exists in order to comply with the original license.\n */\nsize_t zmalloc_get_memory_size(void) {\n#if defined(__unix__) || defined(__unix) || defined(unix) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))\n    int mib[2];\n    mib[0] = CTL_HW;\n#if defined(HW_MEMSIZE)\n    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */\n#elif defined(HW_PHYSMEM64)\n    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */\n#endif\n    int64_t size = 0;               /* 64-bit */\n    size_t len = sizeof(size);\n    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)\n        return (size_t)size;\n    return 0L;          /* Failed? */\n\n#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)\n    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */\n    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);\n\n#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))\n    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */\n    int mib[2];\n    mib[0] = CTL_HW;\n#if defined(HW_REALMEM)\n    mib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */\n#elif defined(HW_PHYSMEM)\n    mib[1] = HW_PHYSMEM;        /* Others. ------------------ */\n#endif\n    unsigned int size = 0;      /* 32-bit */\n    size_t len = sizeof(size);\n    if (sysctl(mib, 2, &size, &len, NULL, 0) == 0)\n        return (size_t)size;\n    return 0L;          /* Failed? */\n#else\n    return 0L;          /* Unknown method to get the data. */\n#endif\n#else\n    return 0L;          /* Unknown OS. */\n#endif\n}\n\n#ifdef REDIS_TEST\n#define UNUSED(x) ((void)(x))\nint zmalloc_test(int argc, char **argv) {\n    void *ptr;\n\n    UNUSED(argc);\n    UNUSED(argv);\n    printf(\"Initial used memory: %zu\\n\", zmalloc_used_memory());\n    ptr = zmalloc(123);\n    printf(\"Allocated 123 bytes; used: %zu\\n\", zmalloc_used_memory());\n    ptr = zrealloc(ptr, 456);\n    printf(\"Reallocated to 456 bytes; used: %zu\\n\", zmalloc_used_memory());\n    zfree(ptr);\n    printf(\"Freed pointer; used: %zu\\n\", zmalloc_used_memory());\n    return 0;\n}\n#endif\n"], "fixing_code": ["/* Configuration file parsing and CONFIG GET/SET commands implementation.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/*-----------------------------------------------------------------------------\n * Config file name-value maps.\n *----------------------------------------------------------------------------*/\n\ntypedef struct configEnum {\n    const char *name;\n    const int val;\n} configEnum;\n\nconfigEnum maxmemory_policy_enum[] = {\n    {\"volatile-lru\", MAXMEMORY_VOLATILE_LRU},\n    {\"volatile-lfu\", MAXMEMORY_VOLATILE_LFU},\n    {\"volatile-random\",MAXMEMORY_VOLATILE_RANDOM},\n    {\"volatile-ttl\",MAXMEMORY_VOLATILE_TTL},\n    {\"allkeys-lru\",MAXMEMORY_ALLKEYS_LRU},\n    {\"allkeys-lfu\",MAXMEMORY_ALLKEYS_LFU},\n    {\"allkeys-random\",MAXMEMORY_ALLKEYS_RANDOM},\n    {\"noeviction\",MAXMEMORY_NO_EVICTION},\n    {NULL, 0}\n};\n\nconfigEnum syslog_facility_enum[] = {\n    {\"user\",    LOG_USER},\n    {\"local0\",  LOG_LOCAL0},\n    {\"local1\",  LOG_LOCAL1},\n    {\"local2\",  LOG_LOCAL2},\n    {\"local3\",  LOG_LOCAL3},\n    {\"local4\",  LOG_LOCAL4},\n    {\"local5\",  LOG_LOCAL5},\n    {\"local6\",  LOG_LOCAL6},\n    {\"local7\",  LOG_LOCAL7},\n    {NULL, 0}\n};\n\nconfigEnum loglevel_enum[] = {\n    {\"debug\", LL_DEBUG},\n    {\"verbose\", LL_VERBOSE},\n    {\"notice\", LL_NOTICE},\n    {\"warning\", LL_WARNING},\n    {NULL,0}\n};\n\nconfigEnum supervised_mode_enum[] = {\n    {\"upstart\", SUPERVISED_UPSTART},\n    {\"systemd\", SUPERVISED_SYSTEMD},\n    {\"auto\", SUPERVISED_AUTODETECT},\n    {\"no\", SUPERVISED_NONE},\n    {NULL, 0}\n};\n\nconfigEnum aof_fsync_enum[] = {\n    {\"everysec\", AOF_FSYNC_EVERYSEC},\n    {\"always\", AOF_FSYNC_ALWAYS},\n    {\"no\", AOF_FSYNC_NO},\n    {NULL, 0}\n};\n\nconfigEnum repl_diskless_load_enum[] = {\n    {\"disabled\", REPL_DISKLESS_LOAD_DISABLED},\n    {\"on-empty-db\", REPL_DISKLESS_LOAD_WHEN_DB_EMPTY},\n    {\"swapdb\", REPL_DISKLESS_LOAD_SWAPDB},\n    {NULL, 0}\n};\n\nconfigEnum tls_auth_clients_enum[] = {\n    {\"no\", TLS_CLIENT_AUTH_NO},\n    {\"yes\", TLS_CLIENT_AUTH_YES},\n    {\"optional\", TLS_CLIENT_AUTH_OPTIONAL},\n    {NULL, 0}\n};\n\nconfigEnum oom_score_adj_enum[] = {\n    {\"no\", OOM_SCORE_ADJ_NO},\n    {\"yes\", OOM_SCORE_RELATIVE},\n    {\"relative\", OOM_SCORE_RELATIVE},\n    {\"absolute\", OOM_SCORE_ADJ_ABSOLUTE},\n    {NULL, 0}\n};\n\n/* Output buffer limits presets. */\nclientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {\n    {0, 0, 0}, /* normal */\n    {1024*1024*256, 1024*1024*64, 60}, /* slave */\n    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */\n};\n\n/* OOM Score defaults */\nint configOOMScoreAdjValuesDefaults[CONFIG_OOM_COUNT] = { 0, 200, 800 };\n\n/* Generic config infrastructure function pointers\n * int is_valid_fn(val, err)\n *     Return 1 when val is valid, and 0 when invalid.\n *     Optionally set err to a static error string.\n * int update_fn(val, prev, err)\n *     This function is called only for CONFIG SET command (not at config file parsing)\n *     It is called after the actual config is applied,\n *     Return 1 for success, and 0 for failure.\n *     Optionally set err to a static error string.\n *     On failure the config change will be reverted.\n */\n\n/* Configuration values that require no special handling to set, get, load or\n * rewrite. */\ntypedef struct boolConfigData {\n    int *config; /* The pointer to the server config this value is stored in */\n    const int default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(int val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(int val, int prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} boolConfigData;\n\ntypedef struct stringConfigData {\n    char **config; /* Pointer to the server config this value is stored in. */\n    const char *default_value; /* Default value of the config on rewrite. */\n    int (*is_valid_fn)(char* val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(char* val, char* prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n    int convert_empty_to_null; /* Boolean indicating if empty strings should\n                                  be stored as a NULL value. */\n} stringConfigData;\n\ntypedef struct enumConfigData {\n    int *config; /* The pointer to the server config this value is stored in */\n    configEnum *enum_value; /* The underlying enum type this data represents */\n    const int default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(int val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(int val, int prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} enumConfigData;\n\ntypedef enum numericType {\n    NUMERIC_TYPE_INT,\n    NUMERIC_TYPE_UINT,\n    NUMERIC_TYPE_LONG,\n    NUMERIC_TYPE_ULONG,\n    NUMERIC_TYPE_LONG_LONG,\n    NUMERIC_TYPE_ULONG_LONG,\n    NUMERIC_TYPE_SIZE_T,\n    NUMERIC_TYPE_SSIZE_T,\n    NUMERIC_TYPE_OFF_T,\n    NUMERIC_TYPE_TIME_T,\n} numericType;\n\ntypedef struct numericConfigData {\n    union {\n        int *i;\n        unsigned int *ui;\n        long *l;\n        unsigned long *ul;\n        long long *ll;\n        unsigned long long *ull;\n        size_t *st;\n        ssize_t *sst;\n        off_t *ot;\n        time_t *tt;\n    } config; /* The pointer to the numeric config this value is stored in */\n    int is_memory; /* Indicates if this value can be loaded as a memory value */\n    numericType numeric_type; /* An enum indicating the type of this value */\n    long long lower_bound; /* The lower bound of this numeric value */\n    long long upper_bound; /* The upper bound of this numeric value */\n    const long long default_value; /* The default value of the config on rewrite */\n    int (*is_valid_fn)(long long val, char **err); /* Optional function to check validity of new value (generic doc above) */\n    int (*update_fn)(long long val, long long prev, char **err); /* Optional function to apply new value at runtime (generic doc above) */\n} numericConfigData;\n\ntypedef union typeData {\n    boolConfigData yesno;\n    stringConfigData string;\n    enumConfigData enumd;\n    numericConfigData numeric;\n} typeData;\n\ntypedef struct typeInterface {\n    /* Called on server start, to init the server with default value */\n    void (*init)(typeData data);\n    /* Called on server start, should return 1 on success, 0 on error and should set err */\n    int (*load)(typeData data, sds *argc, int argv, char **err);\n    /* Called on server startup and CONFIG SET, returns 1 on success, 0 on error\n     * and can set a verbose err string, update is true when called from CONFIG SET */\n    int (*set)(typeData data, sds value, int update, char **err);\n    /* Called on CONFIG GET, required to add output to the client */\n    void (*get)(client *c, typeData data);\n    /* Called on CONFIG REWRITE, required to rewrite the config state */\n    void (*rewrite)(typeData data, const char *name, struct rewriteConfigState *state);\n} typeInterface;\n\ntypedef struct standardConfig {\n    const char *name; /* The user visible name of this config */\n    const char *alias; /* An alias that can also be used for this config */\n    const int modifiable; /* Can this value be updated by CONFIG SET? */\n    typeInterface interface; /* The function pointers that define the type interface */\n    typeData data; /* The type specific data exposed used by the interface */\n} standardConfig;\n\nstandardConfig configs[];\n\n/*-----------------------------------------------------------------------------\n * Enum access functions\n *----------------------------------------------------------------------------*/\n\n/* Get enum value from name. If there is no match INT_MIN is returned. */\nint configEnumGetValue(configEnum *ce, char *name) {\n    while(ce->name != NULL) {\n        if (!strcasecmp(ce->name,name)) return ce->val;\n        ce++;\n    }\n    return INT_MIN;\n}\n\n/* Get enum name from value. If no match is found NULL is returned. */\nconst char *configEnumGetName(configEnum *ce, int val) {\n    while(ce->name != NULL) {\n        if (ce->val == val) return ce->name;\n        ce++;\n    }\n    return NULL;\n}\n\n/* Wrapper for configEnumGetName() returning \"unknown\" instead of NULL if\n * there is no match. */\nconst char *configEnumGetNameOrUnknown(configEnum *ce, int val) {\n    const char *name = configEnumGetName(ce,val);\n    return name ? name : \"unknown\";\n}\n\n/* Used for INFO generation. */\nconst char *evictPolicyToString(void) {\n    return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);\n}\n\n/*-----------------------------------------------------------------------------\n * Config file parsing\n *----------------------------------------------------------------------------*/\n\nint yesnotoi(char *s) {\n    if (!strcasecmp(s,\"yes\")) return 1;\n    else if (!strcasecmp(s,\"no\")) return 0;\n    else return -1;\n}\n\nvoid appendServerSaveParams(time_t seconds, int changes) {\n    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));\n    server.saveparams[server.saveparamslen].seconds = seconds;\n    server.saveparams[server.saveparamslen].changes = changes;\n    server.saveparamslen++;\n}\n\nvoid resetServerSaveParams(void) {\n    zfree(server.saveparams);\n    server.saveparams = NULL;\n    server.saveparamslen = 0;\n}\n\nvoid queueLoadModule(sds path, sds *argv, int argc) {\n    int i;\n    struct moduleLoadQueueEntry *loadmod;\n\n    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));\n    loadmod->argv = zmalloc(sizeof(robj*)*argc);\n    loadmod->path = sdsnew(path);\n    loadmod->argc = argc;\n    for (i = 0; i < argc; i++) {\n        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));\n    }\n    listAddNodeTail(server.loadmodule_queue,loadmod);\n}\n\n/* Parse an array of CONFIG_OOM_COUNT sds strings, validate and populate\n * server.oom_score_adj_values if valid.\n */\n\nstatic int updateOOMScoreAdjValues(sds *args, char **err, int apply) {\n    int i;\n    int values[CONFIG_OOM_COUNT];\n\n    for (i = 0; i < CONFIG_OOM_COUNT; i++) {\n        char *eptr;\n        long long val = strtoll(args[i], &eptr, 10);\n\n        if (*eptr != '\\0' || val < -2000 || val > 2000) {\n            if (err) *err = \"Invalid oom-score-adj-values, elements must be between -2000 and 2000.\";\n            return C_ERR;\n        }\n\n        values[i] = val;\n    }\n\n    /* Verify that the values make sense. If they don't omit a warning but\n     * keep the configuration, which may still be valid for privileged processes.\n     */\n\n    if (values[CONFIG_OOM_REPLICA] < values[CONFIG_OOM_MASTER] ||\n        values[CONFIG_OOM_BGCHILD] < values[CONFIG_OOM_REPLICA]) {\n            serverLog(LOG_WARNING,\n                    \"The oom-score-adj-values configuration may not work for non-privileged processes! \"\n                    \"Please consult the documentation.\");\n    }\n\n    /* Store values, retain previous config for rollback in case we fail. */\n    int old_values[CONFIG_OOM_COUNT];\n    for (i = 0; i < CONFIG_OOM_COUNT; i++) {\n        old_values[i] = server.oom_score_adj_values[i];\n        server.oom_score_adj_values[i] = values[i];\n    }\n    \n    /* When parsing the config file, we want to apply only when all is done. */\n    if (!apply)\n        return C_OK;\n\n    /* Update */\n    if (setOOMScoreAdj(-1) == C_ERR) {\n        /* Roll back */\n        for (i = 0; i < CONFIG_OOM_COUNT; i++)\n            server.oom_score_adj_values[i] = old_values[i];\n\n        if (err)\n            *err = \"Failed to apply oom-score-adj-values configuration, check server logs.\";\n\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\nvoid initConfigValues() {\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        config->interface.init(config->data);\n    }\n}\n\nvoid loadServerConfigFromString(char *config) {\n    char *err = NULL;\n    int linenum = 0, totlines, i;\n    int slaveof_linenum = 0;\n    sds *lines;\n\n    lines = sdssplitlen(config,strlen(config),\"\\n\",1,&totlines);\n\n    for (i = 0; i < totlines; i++) {\n        sds *argv;\n        int argc;\n\n        linenum = i+1;\n        lines[i] = sdstrim(lines[i],\" \\t\\r\\n\");\n\n        /* Skip comments and blank lines */\n        if (lines[i][0] == '#' || lines[i][0] == '\\0') continue;\n\n        /* Split into arguments */\n        argv = sdssplitargs(lines[i],&argc);\n        if (argv == NULL) {\n            err = \"Unbalanced quotes in configuration line\";\n            goto loaderr;\n        }\n\n        /* Skip this line if the resulting command vector is empty. */\n        if (argc == 0) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n        sdstolower(argv[0]);\n\n        /* Iterate the configs that are standard */\n        int match = 0;\n        for (standardConfig *config = configs; config->name != NULL; config++) {\n            if ((!strcasecmp(argv[0],config->name) ||\n                (config->alias && !strcasecmp(argv[0],config->alias))))\n            {\n                if (argc != 2) {\n                    err = \"wrong number of arguments\";\n                    goto loaderr;\n                }\n                if (!config->interface.set(config->data, argv[1], 0, &err)) {\n                    goto loaderr;\n                }\n\n                match = 1;\n                break;\n            }\n        }\n\n        if (match) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n\n        /* Execute config directives */\n        if (!strcasecmp(argv[0],\"bind\") && argc >= 2) {\n            int j, addresses = argc-1;\n\n            if (addresses > CONFIG_BINDADDR_MAX) {\n                err = \"Too many bind addresses specified\"; goto loaderr;\n            }\n            /* Free old bind addresses */\n            for (j = 0; j < server.bindaddr_count; j++) {\n                zfree(server.bindaddr[j]);\n            }\n            for (j = 0; j < addresses; j++)\n                server.bindaddr[j] = zstrdup(argv[j+1]);\n            server.bindaddr_count = addresses;\n        } else if (!strcasecmp(argv[0],\"unixsocketperm\") && argc == 2) {\n            errno = 0;\n            server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);\n            if (errno || server.unixsocketperm > 0777) {\n                err = \"Invalid socket file permissions\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"save\")) {\n            if (argc == 3) {\n                int seconds = atoi(argv[1]);\n                int changes = atoi(argv[2]);\n                if (seconds < 1 || changes < 0) {\n                    err = \"Invalid save parameters\"; goto loaderr;\n                }\n                appendServerSaveParams(seconds,changes);\n            } else if (argc == 2 && !strcasecmp(argv[1],\"\")) {\n                resetServerSaveParams();\n            }\n        } else if (!strcasecmp(argv[0],\"dir\") && argc == 2) {\n            if (chdir(argv[1]) == -1) {\n                serverLog(LL_WARNING,\"Can't chdir to '%s': %s\",\n                    argv[1], strerror(errno));\n                exit(1);\n            }\n        } else if (!strcasecmp(argv[0],\"logfile\") && argc == 2) {\n            FILE *logfp;\n\n            zfree(server.logfile);\n            server.logfile = zstrdup(argv[1]);\n            if (server.logfile[0] != '\\0') {\n                /* Test if we are able to open the file. The server will not\n                 * be able to abort just for this problem later... */\n                logfp = fopen(server.logfile,\"a\");\n                if (logfp == NULL) {\n                    err = sdscatprintf(sdsempty(),\n                        \"Can't open the log file: %s\", strerror(errno));\n                    goto loaderr;\n                }\n                fclose(logfp);\n            }\n        } else if (!strcasecmp(argv[0],\"include\") && argc == 2) {\n            loadServerConfig(argv[1],NULL);\n        } else if ((!strcasecmp(argv[0],\"client-query-buffer-limit\")) && argc == 2) {\n             server.client_max_querybuf_len = memtoll(argv[1],NULL);\n        } else if ((!strcasecmp(argv[0],\"slaveof\") ||\n                    !strcasecmp(argv[0],\"replicaof\")) && argc == 3) {\n            slaveof_linenum = linenum;\n            sdsfree(server.masterhost);\n            if (!strcasecmp(argv[1], \"no\") && !strcasecmp(argv[2], \"one\")) {\n                server.masterhost = NULL;\n                continue;\n            }\n            server.masterhost = sdsnew(argv[1]);\n            char *ptr;\n            server.masterport = strtol(argv[2], &ptr, 10);\n            if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\\0') {\n                err = \"Invalid master port\"; goto loaderr;\n            }\n            server.repl_state = REPL_STATE_CONNECT;\n        } else if (!strcasecmp(argv[0],\"requirepass\") && argc == 2) {\n            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {\n                err = \"Password is longer than CONFIG_AUTHPASS_MAX_LEN\";\n                goto loaderr;\n            }\n            /* The old \"requirepass\" directive just translates to setting\n             * a password to the default user. The only thing we do\n             * additionally is to remember the cleartext password in this\n             * case, for backward compatibility with Redis <= 5. */\n            ACLSetUser(DefaultUser,\"resetpass\",-1);\n            sdsfree(server.requirepass);\n            server.requirepass = NULL;\n            if (sdslen(argv[1])) {\n                sds aclop = sdscatprintf(sdsempty(),\">%s\",argv[1]);\n                ACLSetUser(DefaultUser,aclop,sdslen(aclop));\n                sdsfree(aclop);\n                server.requirepass = sdsnew(argv[1]);\n            } else {\n                ACLSetUser(DefaultUser,\"nopass\",-1);\n            }\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-entries\") && argc == 2){\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-value\") && argc == 2) {\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"rename-command\") && argc == 3) {\n            struct redisCommand *cmd = lookupCommand(argv[1]);\n            int retval;\n\n            if (!cmd) {\n                err = \"No such command in rename-command\";\n                goto loaderr;\n            }\n\n            /* If the target command name is the empty string we just\n             * remove it from the command table. */\n            retval = dictDelete(server.commands, argv[1]);\n            serverAssert(retval == DICT_OK);\n\n            /* Otherwise we re-add the command under a different name. */\n            if (sdslen(argv[2]) != 0) {\n                sds copy = sdsdup(argv[2]);\n\n                retval = dictAdd(server.commands, copy, cmd);\n                if (retval != DICT_OK) {\n                    sdsfree(copy);\n                    err = \"Target command name already exists\"; goto loaderr;\n                }\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-config-file\") && argc == 2) {\n            zfree(server.cluster_configfile);\n            server.cluster_configfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        } else if (!strcasecmp(argv[0],\"oom-score-adj-values\") && argc == 1 + CONFIG_OOM_COUNT) {\n            if (updateOOMScoreAdjValues(&argv[1], &err, 0) == C_ERR) goto loaderr;\n        } else if (!strcasecmp(argv[0],\"notify-keyspace-events\") && argc == 2) {\n            int flags = keyspaceEventsStringToFlags(argv[1]);\n\n            if (flags == -1) {\n                err = \"Invalid event class character. Use 'g$lshzxeA'.\";\n                goto loaderr;\n            }\n            server.notify_keyspace_events = flags;\n        } else if (!strcasecmp(argv[0],\"user\") && argc >= 2) {\n            int argc_err;\n            if (ACLAppendUserForLoading(argv,argc,&argc_err) == C_ERR) {\n                char buf[1024];\n                char *errmsg = ACLSetUserStringError();\n                snprintf(buf,sizeof(buf),\"Error in user declaration '%s': %s\",\n                    argv[argc_err],errmsg);\n                err = buf;\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"loadmodule\") && argc >= 2) {\n            queueLoadModule(argv[1],&argv[2],argc-2);\n        } else if (!strcasecmp(argv[0],\"sentinel\")) {\n            /* argc == 1 is handled by main() as we need to enter the sentinel\n             * mode ASAP. */\n            if (argc != 1) {\n                if (!server.sentinel_mode) {\n                    err = \"sentinel directive while not in sentinel mode\";\n                    goto loaderr;\n                }\n                err = sentinelHandleConfiguration(argv+1,argc-1);\n                if (err) goto loaderr;\n            }\n        } else {\n            err = \"Bad directive or wrong number of arguments\"; goto loaderr;\n        }\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Sanity checks. */\n    if (server.cluster_enabled && server.masterhost) {\n        linenum = slaveof_linenum;\n        i = linenum-1;\n        err = \"replicaof directive not allowed in cluster mode\";\n        goto loaderr;\n    }\n\n    sdsfreesplitres(lines,totlines);\n    return;\n\nloaderr:\n    fprintf(stderr, \"\\n*** FATAL CONFIG FILE ERROR (Redis %s) ***\\n\",\n        REDIS_VERSION);\n    fprintf(stderr, \"Reading the configuration file, at line %d\\n\", linenum);\n    fprintf(stderr, \">>> '%s'\\n\", lines[i]);\n    fprintf(stderr, \"%s\\n\", err);\n    exit(1);\n}\n\n/* Load the server configuration from the specified filename.\n * The function appends the additional configuration directives stored\n * in the 'options' string to the config file before loading.\n *\n * Both filename and options can be NULL, in such a case are considered\n * empty. This way loadServerConfig can be used to just load a file or\n * just load a string. */\nvoid loadServerConfig(char *filename, char *options) {\n    sds config = sdsempty();\n    char buf[CONFIG_MAX_LINE+1];\n\n    /* Load the file content */\n    if (filename) {\n        FILE *fp;\n\n        if (filename[0] == '-' && filename[1] == '\\0') {\n            fp = stdin;\n        } else {\n            if ((fp = fopen(filename,\"r\")) == NULL) {\n                serverLog(LL_WARNING,\n                    \"Fatal error, can't open config file '%s': %s\",\n                    filename, strerror(errno));\n                exit(1);\n            }\n        }\n        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)\n            config = sdscat(config,buf);\n        if (fp != stdin) fclose(fp);\n    }\n    /* Append the additional options */\n    if (options) {\n        config = sdscat(config,\"\\n\");\n        config = sdscat(config,options);\n    }\n    loadServerConfigFromString(config);\n    sdsfree(config);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG SET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_set_bool_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int yn = yesnotoi(o->ptr); \\\n        if (yn == -1) goto badfmt; \\\n        _var = yn;\n\n#define config_set_numerical_field(_name,_var,min,max) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        if (getLongLongFromObject(o,&ll) == C_ERR) goto badfmt; \\\n        if (min != LLONG_MIN && ll < min) goto badfmt; \\\n        if (max != LLONG_MAX && ll > max) goto badfmt; \\\n        _var = ll;\n\n#define config_set_memory_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        ll = memtoll(o->ptr,&err); \\\n        if (err || ll < 0) goto badfmt; \\\n        _var = ll;\n\n#define config_set_special_field(_name) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) {\n\n#define config_set_special_field_with_alias(_name1,_name2) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name1) || \\\n               !strcasecmp(c->argv[2]->ptr,_name2)) {\n\n#define config_set_else } else\n\nvoid configSetCommand(client *c) {\n    robj *o;\n    long long ll;\n    int err;\n    char *errstr = NULL;\n    serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));\n    serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));\n    o = c->argv[3];\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        if(config->modifiable && (!strcasecmp(c->argv[2]->ptr,config->name) ||\n            (config->alias && !strcasecmp(c->argv[2]->ptr,config->alias))))\n        {\n            if (!config->interface.set(config->data,o->ptr,1,&errstr)) {\n                goto badfmt;\n            }\n            addReply(c,shared.ok);\n            return;\n        }\n    }\n\n    if (0) { /* this starts the config_set macros else-if chain. */\n\n    /* Special fields that can't be handled with general macros. */\n    config_set_special_field(\"requirepass\") {\n        if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;\n        /* The old \"requirepass\" directive just translates to setting\n         * a password to the default user. The only thing we do\n         * additionally is to remember the cleartext password in this\n         * case, for backward compatibility with Redis <= 5. */\n        ACLSetUser(DefaultUser,\"resetpass\",-1);\n        sdsfree(server.requirepass);\n        server.requirepass = NULL;\n        if (sdslen(o->ptr)) {\n            sds aclop = sdscatprintf(sdsempty(),\">%s\",(char*)o->ptr);\n            ACLSetUser(DefaultUser,aclop,sdslen(aclop));\n            sdsfree(aclop);\n            server.requirepass = sdsnew(o->ptr);\n        } else {\n            ACLSetUser(DefaultUser,\"nopass\",-1);\n        }\n    } config_set_special_field(\"save\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* Perform sanity check before setting the new config:\n         * - Even number of args\n         * - Seconds >= 1, changes >= 0 */\n        if (vlen & 1) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n        for (j = 0; j < vlen; j++) {\n            char *eptr;\n            long val;\n\n            val = strtoll(v[j], &eptr, 10);\n            if (eptr[0] != '\\0' ||\n                ((j & 1) == 0 && val < 1) ||\n                ((j & 1) == 1 && val < 0)) {\n                sdsfreesplitres(v,vlen);\n                goto badfmt;\n            }\n        }\n        /* Finally set the new config */\n        resetServerSaveParams();\n        for (j = 0; j < vlen; j += 2) {\n            time_t seconds;\n            int changes;\n\n            seconds = strtoll(v[j],NULL,10);\n            changes = strtoll(v[j+1],NULL,10);\n            appendServerSaveParams(seconds, changes);\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"dir\") {\n        if (chdir((char*)o->ptr) == -1) {\n            addReplyErrorFormat(c,\"Changing directory: %s\", strerror(errno));\n            return;\n        }\n    } config_set_special_field(\"client-output-buffer-limit\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */\n        if (vlen % 4) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n\n        /* Sanity check of single arguments, so that we either refuse the\n         * whole configuration string or accept it all, even if a single\n         * error in a single client class is present. */\n        for (j = 0; j < vlen; j++) {\n            long val;\n\n            if ((j % 4) == 0) {\n                int class = getClientTypeByName(v[j]);\n                if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            } else {\n                val = memtoll(v[j], &err);\n                if (err || val < 0) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            }\n        }\n        /* Finally set the new config */\n        for (j = 0; j < vlen; j += 4) {\n            int class;\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            class = getClientTypeByName(v[j]);\n            hard = memtoll(v[j+1],NULL);\n            soft = memtoll(v[j+2],NULL);\n            soft_seconds = strtoll(v[j+3],NULL,10);\n\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"oom-score-adj-values\") {\n        int vlen;\n        int success = 1;\n\n        sds *v = sdssplitlen(o->ptr, sdslen(o->ptr), \" \", 1, &vlen);\n        if (vlen != CONFIG_OOM_COUNT || updateOOMScoreAdjValues(v, &errstr, 1) == C_ERR)\n            success = 0;\n\n        sdsfreesplitres(v, vlen);\n        if (!success)\n            goto badfmt;\n    } config_set_special_field(\"notify-keyspace-events\") {\n        int flags = keyspaceEventsStringToFlags(o->ptr);\n\n        if (flags == -1) goto badfmt;\n        server.notify_keyspace_events = flags;\n    /* Numerical fields.\n     * config_set_numerical_field(name,var,min,max) */\n    } config_set_numerical_field(\n      \"watchdog-period\",ll,0,INT_MAX) {\n        if (ll)\n            enableWatchdog(ll);\n        else\n            disableWatchdog();\n    /* Memory fields.\n     * config_set_memory_field(name,var) */\n    } config_set_memory_field(\n      \"client-query-buffer-limit\",server.client_max_querybuf_len) {\n    /* Everything else is an error... */\n    } config_set_else {\n        addReplyErrorFormat(c,\"Unsupported CONFIG parameter: %s\",\n            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* On success we just return a generic OK for all the options. */\n    addReply(c,shared.ok);\n    return;\n\nbadfmt: /* Bad format errors */\n    if (errstr) {\n        addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s' - %s\",\n                (char*)o->ptr,\n                (char*)c->argv[2]->ptr,\n                errstr);\n    } else {\n        addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s'\",\n                (char*)o->ptr,\n                (char*)c->argv[2]->ptr);\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG GET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_get_string_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? _var : \"\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_bool_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? \"yes\" : \"no\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_numerical_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        ll2string(buf,sizeof(buf),_var); \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,buf); \\\n        matches++; \\\n    } \\\n} while(0);\n\n\nvoid configGetCommand(client *c) {\n    robj *o = c->argv[2];\n    void *replylen = addReplyDeferredLen(c);\n    char *pattern = o->ptr;\n    char buf[128];\n    int matches = 0;\n    serverAssertWithInfo(c,o,sdsEncodedObject(o));\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        if (stringmatch(pattern,config->name,1)) {\n            addReplyBulkCString(c,config->name);\n            config->interface.get(c,config->data);\n            matches++;\n        }\n        if (config->alias && stringmatch(pattern,config->alias,1)) {\n            addReplyBulkCString(c,config->alias);\n            config->interface.get(c,config->data);\n            matches++;\n        }\n    }\n\n    /* String values */\n    config_get_string_field(\"logfile\",server.logfile);\n\n    /* Numerical values */\n    config_get_numerical_field(\"client-query-buffer-limit\",server.client_max_querybuf_len);\n    config_get_numerical_field(\"watchdog-period\",server.watchdog_period);\n\n    /* Everything we can't handle with macros follows. */\n\n    if (stringmatch(pattern,\"dir\",1)) {\n        char buf[1024];\n\n        if (getcwd(buf,sizeof(buf)) == NULL)\n            buf[0] = '\\0';\n\n        addReplyBulkCString(c,\"dir\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"save\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < server.saveparamslen; j++) {\n            buf = sdscatprintf(buf,\"%jd %d\",\n                    (intmax_t)server.saveparams[j].seconds,\n                    server.saveparams[j].changes);\n            if (j != server.saveparamslen-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"save\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"client-output-buffer-limit\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%s %llu %llu %ld\",\n                    getClientTypeName(j),\n                    server.client_obuf_limits[j].hard_limit_bytes,\n                    server.client_obuf_limits[j].soft_limit_bytes,\n                    (long) server.client_obuf_limits[j].soft_limit_seconds);\n            if (j != CLIENT_TYPE_OBUF_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"client-output-buffer-limit\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"unixsocketperm\",1)) {\n        char buf[32];\n        snprintf(buf,sizeof(buf),\"%o\",server.unixsocketperm);\n        addReplyBulkCString(c,\"unixsocketperm\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"slaveof\",1) ||\n        stringmatch(pattern,\"replicaof\",1))\n    {\n        char *optname = stringmatch(pattern,\"slaveof\",1) ?\n                        \"slaveof\" : \"replicaof\";\n        char buf[256];\n\n        addReplyBulkCString(c,optname);\n        if (server.masterhost)\n            snprintf(buf,sizeof(buf),\"%s %d\",\n                server.masterhost, server.masterport);\n        else\n            buf[0] = '\\0';\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"notify-keyspace-events\",1)) {\n        sds flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n\n        addReplyBulkCString(c,\"notify-keyspace-events\");\n        addReplyBulkSds(c,flags);\n        matches++;\n    }\n    if (stringmatch(pattern,\"bind\",1)) {\n        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n\n        addReplyBulkCString(c,\"bind\");\n        addReplyBulkCString(c,aux);\n        sdsfree(aux);\n        matches++;\n    }\n    if (stringmatch(pattern,\"requirepass\",1)) {\n        addReplyBulkCString(c,\"requirepass\");\n        sds password = server.requirepass;\n        if (password) {\n            addReplyBulkCBuffer(c,password,sdslen(password));\n        } else {\n            addReplyBulkCString(c,\"\");\n        }\n        matches++;\n    }\n\n    if (stringmatch(pattern,\"oom-score-adj-values\",0)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CONFIG_OOM_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%d\", server.oom_score_adj_values[j]);\n            if (j != CONFIG_OOM_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n\n        addReplyBulkCString(c,\"oom-score-adj-values\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n\n    setDeferredMapLen(c,replylen,matches);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG REWRITE implementation\n *----------------------------------------------------------------------------*/\n\n#define REDIS_CONFIG_REWRITE_SIGNATURE \"# Generated by CONFIG REWRITE\"\n\n/* We use the following dictionary type to store where a configuration\n * option is mentioned in the old configuration file, so it's\n * like \"maxmemory\" -> list of line numbers (first line is zero). */\nuint64_t dictSdsCaseHash(const void *key);\nint dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\nvoid dictListDestructor(void *privdata, void *val);\n\n/* Sentinel config rewriting is implemented inside sentinel.c by\n * rewriteConfigSentinelOption(). */\nvoid rewriteConfigSentinelOption(struct rewriteConfigState *state);\n\ndictType optionToLineDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\ndictType optionSetDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* The config rewrite state. */\nstruct rewriteConfigState {\n    dict *option_to_line; /* Option -> list of config file lines map */\n    dict *rewritten;      /* Dictionary of already processed options */\n    int numlines;         /* Number of lines in current config */\n    sds *lines;           /* Current lines as an array of sds strings */\n    int has_tail;         /* True if we already added directives that were\n                             not present in the original config file. */\n    int force_all;        /* True if we want all keywords to be force\n                             written. Currently only used for testing. */\n};\n\n/* Append the new line to the current configuration state. */\nvoid rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {\n    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));\n    state->lines[state->numlines++] = line;\n}\n\n/* Populate the option -> list of line numbers map. */\nvoid rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {\n    list *l = dictFetchValue(state->option_to_line,option);\n\n    if (l == NULL) {\n        l = listCreate();\n        dictAdd(state->option_to_line,sdsdup(option),l);\n    }\n    listAddNodeTail(l,(void*)(long)linenum);\n}\n\n/* Add the specified option to the set of processed options.\n * This is useful as only unused lines of processed options will be blanked\n * in the config file, while options the rewrite process does not understand\n * remain untouched. */\nvoid rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {\n    sds opt = sdsnew(option);\n\n    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);\n}\n\n/* Read the old file, split it into lines to populate a newly created\n * config rewrite state, and return it to the caller.\n *\n * If it is impossible to read the old file, NULL is returned.\n * If the old file does not exist at all, an empty state is returned. */\nstruct rewriteConfigState *rewriteConfigReadOldFile(char *path) {\n    FILE *fp = fopen(path,\"r\");\n    if (fp == NULL && errno != ENOENT) return NULL;\n\n    char buf[CONFIG_MAX_LINE+1];\n    int linenum = -1;\n    struct rewriteConfigState *state = zmalloc(sizeof(*state));\n    state->option_to_line = dictCreate(&optionToLineDictType,NULL);\n    state->rewritten = dictCreate(&optionSetDictType,NULL);\n    state->numlines = 0;\n    state->lines = NULL;\n    state->has_tail = 0;\n    state->force_all = 0;\n    if (fp == NULL) return state;\n\n    /* Read the old file line by line, populate the state. */\n    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {\n        int argc;\n        sds *argv;\n        sds line = sdstrim(sdsnew(buf),\"\\r\\n\\t \");\n\n        linenum++; /* Zero based, so we init at -1 */\n\n        /* Handle comments and empty lines. */\n        if (line[0] == '#' || line[0] == '\\0') {\n            if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))\n                state->has_tail = 1;\n            rewriteConfigAppendLine(state,line);\n            continue;\n        }\n\n        /* Not a comment, split into arguments. */\n        argv = sdssplitargs(line,&argc);\n        if (argv == NULL) {\n            /* Apparently the line is unparsable for some reason, for\n             * instance it may have unbalanced quotes. Load it as a\n             * comment. */\n            sds aux = sdsnew(\"# ??? \");\n            aux = sdscatsds(aux,line);\n            sdsfree(line);\n            rewriteConfigAppendLine(state,aux);\n            continue;\n        }\n\n        sdstolower(argv[0]); /* We only want lowercase config directives. */\n\n        /* Now we populate the state according to the content of this line.\n         * Append the line and populate the option -> line numbers map. */\n        rewriteConfigAppendLine(state,line);\n\n        /* Translate options using the word \"slave\" to the corresponding name\n         * \"replica\", before adding such option to the config name -> lines\n         * mapping. */\n        char *p = strstr(argv[0],\"slave\");\n        if (p) {\n            sds alt = sdsempty();\n            alt = sdscatlen(alt,argv[0],p-argv[0]);;\n            alt = sdscatlen(alt,\"replica\",7);\n            alt = sdscatlen(alt,p+5,strlen(p+5));\n            sdsfree(argv[0]);\n            argv[0] = alt;\n        }\n        rewriteConfigAddLineNumberToOption(state,argv[0],linenum);\n        sdsfreesplitres(argv,argc);\n    }\n    fclose(fp);\n    return state;\n}\n\n/* Rewrite the specified configuration option with the new \"line\".\n * It progressively uses lines of the file that were already used for the same\n * configuration option in the old version of the file, removing that line from\n * the map of options -> line numbers.\n *\n * If there are lines associated with a given configuration option and\n * \"force\" is non-zero, the line is appended to the configuration file.\n * Usually \"force\" is true when an option has not its default value, so it\n * must be rewritten even if not present previously.\n *\n * The first time a line is appended into a configuration file, a comment\n * is added to show that starting from that point the config file was generated\n * by CONFIG REWRITE.\n *\n * \"line\" is either used, or freed, so the caller does not need to free it\n * in any way. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {\n    sds o = sdsnew(option);\n    list *l = dictFetchValue(state->option_to_line,o);\n\n    rewriteConfigMarkAsProcessed(state,option);\n\n    if (!l && !force && !state->force_all) {\n        /* Option not used previously, and we are not forced to use it. */\n        sdsfree(line);\n        sdsfree(o);\n        return;\n    }\n\n    if (l) {\n        listNode *ln = listFirst(l);\n        int linenum = (long) ln->value;\n\n        /* There are still lines in the old configuration file we can reuse\n         * for this option. Replace the line with the new one. */\n        listDelNode(l,ln);\n        if (listLength(l) == 0) dictDelete(state->option_to_line,o);\n        sdsfree(state->lines[linenum]);\n        state->lines[linenum] = line;\n    } else {\n        /* Append a new line. */\n        if (!state->has_tail) {\n            rewriteConfigAppendLine(state,\n                sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));\n            state->has_tail = 1;\n        }\n        rewriteConfigAppendLine(state,line);\n    }\n    sdsfree(o);\n}\n\n/* Write the long long 'bytes' value as a string in a way that is parsable\n * inside redis.conf. If possible uses the GB, MB, KB notation. */\nint rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {\n    int gb = 1024*1024*1024;\n    int mb = 1024*1024;\n    int kb = 1024;\n\n    if (bytes && (bytes % gb) == 0) {\n        return snprintf(buf,len,\"%lldgb\",bytes/gb);\n    } else if (bytes && (bytes % mb) == 0) {\n        return snprintf(buf,len,\"%lldmb\",bytes/mb);\n    } else if (bytes && (bytes % kb) == 0) {\n        return snprintf(buf,len,\"%lldkb\",bytes/kb);\n    } else {\n        return snprintf(buf,len,\"%lld\",bytes);\n    }\n}\n\n/* Rewrite a simple \"option-name <bytes>\" configuration option. */\nvoid rewriteConfigBytesOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {\n    char buf[64];\n    int force = value != defvalue;\n    sds line;\n\n    rewriteConfigFormatMemory(buf,sizeof(buf),value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,buf);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a yes/no option. */\nvoid rewriteConfigYesNoOption(struct rewriteConfigState *state, const char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %s\",option,\n        value ? \"yes\" : \"no\");\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a string option. */\nvoid rewriteConfigStringOption(struct rewriteConfigState *state, const char *option, char *value, const char *defvalue) {\n    int force = 1;\n    sds line;\n\n    /* String options set to NULL need to be not present at all in the\n     * configuration file to be set to NULL again at the next reboot. */\n    if (value == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Set force to zero if the value is set to its default. */\n    if (defvalue && strcmp(value,defvalue) == 0) force = 0;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, value, strlen(value));\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a numerical (long long range) option. */\nvoid rewriteConfigNumericalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %lld\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an octal option. */\nvoid rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %o\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an enumeration option. It takes as usually state and option name,\n * and in addition the enumeration array and the default value for the\n * option. */\nvoid rewriteConfigEnumOption(struct rewriteConfigState *state, const char *option, int value, configEnum *ce, int defval) {\n    sds line;\n    const char *name = configEnumGetNameOrUnknown(ce,value);\n    int force = value != defval;\n\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the save option. */\nvoid rewriteConfigSaveOption(struct rewriteConfigState *state) {\n    int j;\n    sds line;\n\n    /* In Sentinel mode we don't need to rewrite the save parameters */\n    if (server.sentinel_mode) {\n        rewriteConfigMarkAsProcessed(state,\"save\");\n        return;\n    }\n\n    /* Note that if there are no save parameters at all, all the current\n     * config line with \"save\" will be detected as orphaned and deleted,\n     * resulting into no RDB persistence as expected. */\n    for (j = 0; j < server.saveparamslen; j++) {\n        line = sdscatprintf(sdsempty(),\"save %ld %d\",\n            (long) server.saveparams[j].seconds, server.saveparams[j].changes);\n        rewriteConfigRewriteLine(state,\"save\",line,1);\n    }\n    /* Mark \"save\" as processed in case server.saveparamslen is zero. */\n    rewriteConfigMarkAsProcessed(state,\"save\");\n}\n\n/* Rewrite the user option. */\nvoid rewriteConfigUserOption(struct rewriteConfigState *state) {\n    /* If there is a user file defined we just mark this configuration\n     * directive as processed, so that all the lines containing users\n     * inside the config file gets discarded. */\n    if (server.acl_filename[0] != '\\0') {\n        rewriteConfigMarkAsProcessed(state,\"user\");\n        return;\n    }\n\n    /* Otherwise scan the list of users and rewrite every line. Note that\n     * in case the list here is empty, the effect will just be to comment\n     * all the users directive inside the config file. */\n    raxIterator ri;\n    raxStart(&ri,Users);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        user *u = ri.data;\n        sds line = sdsnew(\"user \");\n        line = sdscatsds(line,u->name);\n        line = sdscatlen(line,\" \",1);\n        sds descr = ACLDescribeUser(u);\n        line = sdscatsds(line,descr);\n        sdsfree(descr);\n        rewriteConfigRewriteLine(state,\"user\",line,1);\n    }\n    raxStop(&ri);\n\n    /* Mark \"user\" as processed in case there are no defined users. */\n    rewriteConfigMarkAsProcessed(state,\"user\");\n}\n\n/* Rewrite the dir option, always using absolute paths.*/\nvoid rewriteConfigDirOption(struct rewriteConfigState *state) {\n    char cwd[1024];\n\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"dir\");\n        return; /* no rewrite on error. */\n    }\n    rewriteConfigStringOption(state,\"dir\",cwd,NULL);\n}\n\n/* Rewrite the slaveof option. */\nvoid rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {\n    sds line;\n\n    /* If this is a master, we want all the slaveof config options\n     * in the file to be removed. Note that if this is a cluster instance\n     * we don't want a slaveof directive inside redis.conf. */\n    if (server.cluster_enabled || server.masterhost == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n    line = sdscatprintf(sdsempty(),\"%s %s %d\", option,\n        server.masterhost, server.masterport);\n    rewriteConfigRewriteLine(state,option,line,1);\n}\n\n/* Rewrite the notify-keyspace-events option. */\nvoid rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {\n    int force = server.notify_keyspace_events != 0;\n    char *option = \"notify-keyspace-events\";\n    sds line, flags;\n\n    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, flags, sdslen(flags));\n    sdsfree(flags);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the client-output-buffer-limit option. */\nvoid rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {\n    int j;\n    char *option = \"client-output-buffer-limit\";\n\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n        int force = (server.client_obuf_limits[j].hard_limit_bytes !=\n                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_bytes !=\n                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_seconds !=\n                    clientBufferLimitsDefaults[j].soft_limit_seconds);\n        sds line;\n        char hard[64], soft[64];\n\n        rewriteConfigFormatMemory(hard,sizeof(hard),\n                server.client_obuf_limits[j].hard_limit_bytes);\n        rewriteConfigFormatMemory(soft,sizeof(soft),\n                server.client_obuf_limits[j].soft_limit_bytes);\n\n        char *typename = getClientTypeName(j);\n        if (!strcmp(typename,\"slave\")) typename = \"replica\";\n        line = sdscatprintf(sdsempty(),\"%s %s %s %s %ld\",\n                option, typename, hard, soft,\n                (long) server.client_obuf_limits[j].soft_limit_seconds);\n        rewriteConfigRewriteLine(state,option,line,force);\n    }\n}\n\n/* Rewrite the oom-score-adj-values option. */\nvoid rewriteConfigOOMScoreAdjValuesOption(struct rewriteConfigState *state) {\n    int force = 0;\n    int j;\n    char *option = \"oom-score-adj-values\";\n    sds line;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    for (j = 0; j < CONFIG_OOM_COUNT; j++) {\n        if (server.oom_score_adj_values[j] != configOOMScoreAdjValuesDefaults[j])\n            force = 1;\n\n        line = sdscatprintf(line, \"%d\", server.oom_score_adj_values[j]);\n        if (j+1 != CONFIG_OOM_COUNT)\n            line = sdscatlen(line, \" \", 1);\n    }\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the bind option. */\nvoid rewriteConfigBindOption(struct rewriteConfigState *state) {\n    int force = 1;\n    sds line, addresses;\n    char *option = \"bind\";\n\n    /* Nothing to rewrite if we don't have bind addresses. */\n    if (server.bindaddr_count == 0) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Rewrite as bind <addr1> <addr2> ... <addrN> */\n    addresses = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, addresses);\n    sdsfree(addresses);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the requirepass option. */\nvoid rewriteConfigRequirepassOption(struct rewriteConfigState *state, char *option) {\n    int force = 1;\n    sds line;\n    sds password = server.requirepass;\n\n    /* If there is no password set, we don't want the requirepass option\n     * to be present in the configuration at all. */\n    if (password == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, password);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Glue together the configuration lines in the current configuration\n * rewrite state into a single string, stripping multiple empty lines. */\nsds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {\n    sds content = sdsempty();\n    int j, was_empty = 0;\n\n    for (j = 0; j < state->numlines; j++) {\n        /* Every cluster of empty lines is turned into a single empty line. */\n        if (sdslen(state->lines[j]) == 0) {\n            if (was_empty) continue;\n            was_empty = 1;\n        } else {\n            was_empty = 0;\n        }\n        content = sdscatsds(content,state->lines[j]);\n        content = sdscatlen(content,\"\\n\",1);\n    }\n    return content;\n}\n\n/* Free the configuration rewrite state. */\nvoid rewriteConfigReleaseState(struct rewriteConfigState *state) {\n    sdsfreesplitres(state->lines,state->numlines);\n    dictRelease(state->option_to_line);\n    dictRelease(state->rewritten);\n    zfree(state);\n}\n\n/* At the end of the rewrite process the state contains the remaining\n * map between \"option name\" => \"lines in the original config file\".\n * Lines used by the rewrite process were removed by the function\n * rewriteConfigRewriteLine(), all the other lines are \"orphaned\" and\n * should be replaced by empty lines.\n *\n * This function does just this, iterating all the option names and\n * blanking all the lines still associated. */\nvoid rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {\n    dictIterator *di = dictGetIterator(state->option_to_line);\n    dictEntry *de;\n\n    while((de = dictNext(di)) != NULL) {\n        list *l = dictGetVal(de);\n        sds option = dictGetKey(de);\n\n        /* Don't blank lines about options the rewrite process\n         * don't understand. */\n        if (dictFind(state->rewritten,option) == NULL) {\n            serverLog(LL_DEBUG,\"Not rewritten option: %s\", option);\n            continue;\n        }\n\n        while(listLength(l)) {\n            listNode *ln = listFirst(l);\n            int linenum = (long) ln->value;\n\n            sdsfree(state->lines[linenum]);\n            state->lines[linenum] = sdsempty();\n            listDelNode(l,ln);\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* This function replaces the old configuration file with the new content\n * in an atomic manner.\n *\n * The function returns 0 on success, otherwise -1 is returned and errno\n * is set accordingly. */\nint rewriteConfigOverwriteFile(char *configfile, sds content) {\n    int fd = -1;\n    int retval = -1;\n    char tmp_conffile[PATH_MAX];\n    const char *tmp_suffix = \".XXXXXX\";\n    size_t offset = 0;\n    ssize_t written_bytes = 0;\n\n    int tmp_path_len = snprintf(tmp_conffile, sizeof(tmp_conffile), \"%s%s\", configfile, tmp_suffix);\n    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof(tmp_conffile)) {\n        serverLog(LL_WARNING, \"Config file full path is too long\");\n        errno = ENAMETOOLONG;\n        return retval;\n    }\n\n#ifdef _GNU_SOURCE\n    fd = mkostemp(tmp_conffile, O_CLOEXEC);\n#else\n    /* There's a theoretical chance here to leak the FD if a module thread forks & execv in the middle */\n    fd = mkstemp(tmp_conffile);\n#endif\n\n    if (fd == -1) {\n        serverLog(LL_WARNING, \"Could not create tmp config file (%s)\", strerror(errno));\n        return retval;\n    }\n\n    while (offset < sdslen(content)) {\n         written_bytes = write(fd, content + offset, sdslen(content) - offset);\n         if (written_bytes <= 0) {\n             if (errno == EINTR) continue; /* FD is blocking, no other retryable errors */\n             serverLog(LL_WARNING, \"Failed after writing (%zd) bytes to tmp config file (%s)\", offset, strerror(errno));\n             goto cleanup;\n         }\n         offset+=written_bytes;\n    }\n\n    if (fsync(fd))\n        serverLog(LL_WARNING, \"Could not sync tmp config file to disk (%s)\", strerror(errno));\n    else if (fchmod(fd, 0644 & ~server.umask) == -1)\n        serverLog(LL_WARNING, \"Could not chmod config file (%s)\", strerror(errno));\n    else if (rename(tmp_conffile, configfile) == -1)\n        serverLog(LL_WARNING, \"Could not rename tmp config file (%s)\", strerror(errno));\n    else {\n        retval = 0;\n        serverLog(LL_DEBUG, \"Rewritten config file (%s) successfully\", configfile);\n    }\n\ncleanup:\n    close(fd);\n    if (retval) unlink(tmp_conffile);\n    return retval;\n}\n\n/* Rewrite the configuration file at \"path\".\n * If the configuration file already exists, we try at best to retain comments\n * and overall structure.\n *\n * Configuration parameters that are at their default value, unless already\n * explicitly included in the old configuration file, are not rewritten.\n * The force_all flag overrides this behavior and forces everything to be\n * written. This is currently only used for testing purposes.\n *\n * On error -1 is returned and errno is set accordingly, otherwise 0. */\nint rewriteConfig(char *path, int force_all) {\n    struct rewriteConfigState *state;\n    sds newcontent;\n    int retval;\n\n    /* Step 1: read the old config into our rewrite state. */\n    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;\n    if (force_all) state->force_all = 1;\n\n    /* Step 2: rewrite every single option, replacing or appending it inside\n     * the rewrite state. */\n\n    /* Iterate the configs that are standard */\n    for (standardConfig *config = configs; config->name != NULL; config++) {\n        config->interface.rewrite(config->data, config->name, state);\n    }\n\n    rewriteConfigBindOption(state);\n    rewriteConfigOctalOption(state,\"unixsocketperm\",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);\n    rewriteConfigStringOption(state,\"logfile\",server.logfile,CONFIG_DEFAULT_LOGFILE);\n    rewriteConfigSaveOption(state);\n    rewriteConfigUserOption(state);\n    rewriteConfigDirOption(state);\n    rewriteConfigSlaveofOption(state,\"replicaof\");\n    rewriteConfigRequirepassOption(state,\"requirepass\");\n    rewriteConfigBytesOption(state,\"client-query-buffer-limit\",server.client_max_querybuf_len,PROTO_MAX_QUERYBUF_LEN);\n    rewriteConfigStringOption(state,\"cluster-config-file\",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    rewriteConfigNotifykeyspaceeventsOption(state);\n    rewriteConfigClientoutputbufferlimitOption(state);\n    rewriteConfigOOMScoreAdjValuesOption(state);\n\n    /* Rewrite Sentinel config if in Sentinel mode. */\n    if (server.sentinel_mode) rewriteConfigSentinelOption(state);\n\n    /* Step 3: remove all the orphaned lines in the old file, that is, lines\n     * that were used by a config option and are no longer used, like in case\n     * of multiple \"save\" options or duplicated options. */\n    rewriteConfigRemoveOrphaned(state);\n\n    /* Step 4: generate a new configuration file from the modified state\n     * and write it into the original file. */\n    newcontent = rewriteConfigGetContentFromState(state);\n    retval = rewriteConfigOverwriteFile(server.configfile,newcontent);\n\n    sdsfree(newcontent);\n    rewriteConfigReleaseState(state);\n    return retval;\n}\n\n/*-----------------------------------------------------------------------------\n * Configs that fit one of the major types and require no special handling\n *----------------------------------------------------------------------------*/\n#define LOADBUF_SIZE 256\nstatic char loadbuf[LOADBUF_SIZE];\n\n#define MODIFIABLE_CONFIG 1\n#define IMMUTABLE_CONFIG 0\n\n#define embedCommonConfig(config_name, config_alias, is_modifiable) \\\n    .name = (config_name), \\\n    .alias = (config_alias), \\\n    .modifiable = (is_modifiable),\n\n#define embedConfigInterface(initfn, setfn, getfn, rewritefn) .interface = { \\\n    .init = (initfn), \\\n    .set = (setfn), \\\n    .get = (getfn), \\\n    .rewrite = (rewritefn) \\\n},\n\n/* What follows is the generic config types that are supported. To add a new\n * config with one of these types, add it to the standardConfig table with\n * the creation macro for each type.\n *\n * Each type contains the following:\n * * A function defining how to load this type on startup.\n * * A function defining how to update this type on CONFIG SET.\n * * A function defining how to serialize this type on CONFIG SET.\n * * A function defining how to rewrite this type on CONFIG REWRITE.\n * * A Macro defining how to create this type.\n */\n\n/* Bool Configs */\nstatic void boolConfigInit(typeData data) {\n    *data.yesno.config = data.yesno.default_value;\n}\n\nstatic int boolConfigSet(typeData data, sds value, int update, char **err) {\n    int yn = yesnotoi(value);\n    if (yn == -1) {\n        *err = \"argument must be 'yes' or 'no'\";\n        return 0;\n    }\n    if (data.yesno.is_valid_fn && !data.yesno.is_valid_fn(yn, err))\n        return 0;\n    int prev = *(data.yesno.config);\n    *(data.yesno.config) = yn;\n    if (update && data.yesno.update_fn && !data.yesno.update_fn(yn, prev, err)) {\n        *(data.yesno.config) = prev;\n        return 0;\n    }\n    return 1;\n}\n\nstatic void boolConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, *data.yesno.config ? \"yes\" : \"no\");\n}\n\nstatic void boolConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigYesNoOption(state, name,*(data.yesno.config), data.yesno.default_value);\n}\n\n#define createBoolConfig(name, alias, modifiable, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(boolConfigInit, boolConfigSet, boolConfigGet, boolConfigRewrite) \\\n    .data.yesno = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n    } \\\n}\n\n/* String Configs */\nstatic void stringConfigInit(typeData data) {\n    if (data.string.convert_empty_to_null) {\n        *data.string.config = data.string.default_value ? zstrdup(data.string.default_value) : NULL;\n    } else {\n        *data.string.config = zstrdup(data.string.default_value);\n    }\n}\n\nstatic int stringConfigSet(typeData data, sds value, int update, char **err) {\n    if (data.string.is_valid_fn && !data.string.is_valid_fn(value, err))\n        return 0;\n    char *prev = *data.string.config;\n    if (data.string.convert_empty_to_null) {\n        *data.string.config = value[0] ? zstrdup(value) : NULL;\n    } else {\n        *data.string.config = zstrdup(value);\n    }\n    if (update && data.string.update_fn && !data.string.update_fn(*data.string.config, prev, err)) {\n        zfree(*data.string.config);\n        *data.string.config = prev;\n        return 0;\n    }\n    zfree(prev);\n    return 1;\n}\n\nstatic void stringConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, *data.string.config ? *data.string.config : \"\");\n}\n\nstatic void stringConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigStringOption(state, name,*(data.string.config), data.string.default_value);\n}\n\n#define ALLOW_EMPTY_STRING 0\n#define EMPTY_STRING_IS_NULL 1\n\n#define createStringConfig(name, alias, modifiable, empty_to_null, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(stringConfigInit, stringConfigSet, stringConfigGet, stringConfigRewrite) \\\n    .data.string = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .convert_empty_to_null = (empty_to_null), \\\n    } \\\n}\n\n/* Enum configs */\nstatic void enumConfigInit(typeData data) {\n    *data.enumd.config = data.enumd.default_value;\n}\n\nstatic int enumConfigSet(typeData data, sds value, int update, char **err) {\n    int enumval = configEnumGetValue(data.enumd.enum_value, value);\n    if (enumval == INT_MIN) {\n        sds enumerr = sdsnew(\"argument must be one of the following: \");\n        configEnum *enumNode = data.enumd.enum_value;\n        while(enumNode->name != NULL) {\n            enumerr = sdscatlen(enumerr, enumNode->name,\n                                strlen(enumNode->name));\n            enumerr = sdscatlen(enumerr, \", \", 2);\n            enumNode++;\n        }\n        sdsrange(enumerr,0,-3); /* Remove final \", \". */\n\n        strncpy(loadbuf, enumerr, LOADBUF_SIZE);\n        loadbuf[LOADBUF_SIZE - 1] = '\\0';\n\n        sdsfree(enumerr);\n        *err = loadbuf;\n        return 0;\n    }\n    if (data.enumd.is_valid_fn && !data.enumd.is_valid_fn(enumval, err))\n        return 0;\n    int prev = *(data.enumd.config);\n    *(data.enumd.config) = enumval;\n    if (update && data.enumd.update_fn && !data.enumd.update_fn(enumval, prev, err)) {\n        *(data.enumd.config) = prev;\n        return 0;\n    }\n    return 1;\n}\n\nstatic void enumConfigGet(client *c, typeData data) {\n    addReplyBulkCString(c, configEnumGetNameOrUnknown(data.enumd.enum_value,*data.enumd.config));\n}\n\nstatic void enumConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    rewriteConfigEnumOption(state, name,*(data.enumd.config), data.enumd.enum_value, data.enumd.default_value);\n}\n\n#define createEnumConfig(name, alias, modifiable, enum, config_addr, default, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(enumConfigInit, enumConfigSet, enumConfigGet, enumConfigRewrite) \\\n    .data.enumd = { \\\n        .config = &(config_addr), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .enum_value = (enum), \\\n    } \\\n}\n\n/* Gets a 'long long val' and sets it into the union, using a macro to get\n * compile time type check. */\n#define SET_NUMERIC_TYPE(val) \\\n    if (data.numeric.numeric_type == NUMERIC_TYPE_INT) { \\\n        *(data.numeric.config.i) = (int) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_UINT) { \\\n        *(data.numeric.config.ui) = (unsigned int) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG) { \\\n        *(data.numeric.config.l) = (long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG) { \\\n        *(data.numeric.config.ul) = (unsigned long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) { \\\n        *(data.numeric.config.ll) = (long long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) { \\\n        *(data.numeric.config.ull) = (unsigned long long) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) { \\\n        *(data.numeric.config.st) = (size_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SSIZE_T) { \\\n        *(data.numeric.config.sst) = (ssize_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_OFF_T) { \\\n        *(data.numeric.config.ot) = (off_t) val; \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_TIME_T) { \\\n        *(data.numeric.config.tt) = (time_t) val; \\\n    }\n\n/* Gets a 'long long val' and sets it with the value from the union, using a\n * macro to get compile time type check. */\n#define GET_NUMERIC_TYPE(val) \\\n    if (data.numeric.numeric_type == NUMERIC_TYPE_INT) { \\\n        val = *(data.numeric.config.i); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_UINT) { \\\n        val = *(data.numeric.config.ui); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG) { \\\n        val = *(data.numeric.config.l); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG) { \\\n        val = *(data.numeric.config.ul); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) { \\\n        val = *(data.numeric.config.ll); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) { \\\n        val = *(data.numeric.config.ull); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) { \\\n        val = *(data.numeric.config.st); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_SSIZE_T) { \\\n        val = *(data.numeric.config.sst); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_OFF_T) { \\\n        val = *(data.numeric.config.ot); \\\n    } else if (data.numeric.numeric_type == NUMERIC_TYPE_TIME_T) { \\\n        val = *(data.numeric.config.tt); \\\n    }\n\n/* Numeric configs */\nstatic void numericConfigInit(typeData data) {\n    SET_NUMERIC_TYPE(data.numeric.default_value)\n}\n\nstatic int numericBoundaryCheck(typeData data, long long ll, char **err) {\n    if (data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG ||\n        data.numeric.numeric_type == NUMERIC_TYPE_UINT ||\n        data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) {\n        /* Boundary check for unsigned types */\n        unsigned long long ull = ll;\n        unsigned long long upper_bound = data.numeric.upper_bound;\n        unsigned long long lower_bound = data.numeric.lower_bound;\n        if (ull > upper_bound || ull < lower_bound) {\n            snprintf(loadbuf, LOADBUF_SIZE,\n                \"argument must be between %llu and %llu inclusive\",\n                lower_bound,\n                upper_bound);\n            *err = loadbuf;\n            return 0;\n        }\n    } else {\n        /* Boundary check for signed types */\n        if (ll > data.numeric.upper_bound || ll < data.numeric.lower_bound) {\n            snprintf(loadbuf, LOADBUF_SIZE,\n                \"argument must be between %lld and %lld inclusive\",\n                data.numeric.lower_bound,\n                data.numeric.upper_bound);\n            *err = loadbuf;\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int numericConfigSet(typeData data, sds value, int update, char **err) {\n    long long ll, prev = 0;\n    if (data.numeric.is_memory) {\n        int memerr;\n        ll = memtoll(value, &memerr);\n        if (memerr || ll < 0) {\n            *err = \"argument must be a memory value\";\n            return 0;\n        }\n    } else {\n        if (!string2ll(value, sdslen(value),&ll)) {\n            *err = \"argument couldn't be parsed into an integer\" ;\n            return 0;\n        }\n    }\n\n    if (!numericBoundaryCheck(data, ll, err))\n        return 0;\n\n    if (data.numeric.is_valid_fn && !data.numeric.is_valid_fn(ll, err))\n        return 0;\n\n    GET_NUMERIC_TYPE(prev)\n    SET_NUMERIC_TYPE(ll)\n\n    if (update && data.numeric.update_fn && !data.numeric.update_fn(ll, prev, err)) {\n        SET_NUMERIC_TYPE(prev)\n        return 0;\n    }\n    return 1;\n}\n\nstatic void numericConfigGet(client *c, typeData data) {\n    char buf[128];\n    long long value = 0;\n\n    GET_NUMERIC_TYPE(value)\n\n    ll2string(buf, sizeof(buf), value);\n    addReplyBulkCString(c, buf);\n}\n\nstatic void numericConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {\n    long long value = 0;\n\n    GET_NUMERIC_TYPE(value)\n\n    if (data.numeric.is_memory) {\n        rewriteConfigBytesOption(state, name, value, data.numeric.default_value);\n    } else {\n        rewriteConfigNumericalOption(state, name, value, data.numeric.default_value);\n    }\n}\n\n#define INTEGER_CONFIG 0\n#define MEMORY_CONFIG 1\n\n#define embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) { \\\n    embedCommonConfig(name, alias, modifiable) \\\n    embedConfigInterface(numericConfigInit, numericConfigSet, numericConfigGet, numericConfigRewrite) \\\n    .data.numeric = { \\\n        .lower_bound = (lower), \\\n        .upper_bound = (upper), \\\n        .default_value = (default), \\\n        .is_valid_fn = (is_valid), \\\n        .update_fn = (update), \\\n        .is_memory = (memory),\n\n#define createIntConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_INT, \\\n        .config.i = &(config_addr) \\\n    } \\\n}\n\n#define createUIntConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_UINT, \\\n        .config.ui = &(config_addr) \\\n    } \\\n}\n\n#define createLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_LONG, \\\n        .config.l = &(config_addr) \\\n    } \\\n}\n\n#define createULongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_ULONG, \\\n        .config.ul = &(config_addr) \\\n    } \\\n}\n\n#define createLongLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_LONG_LONG, \\\n        .config.ll = &(config_addr) \\\n    } \\\n}\n\n#define createULongLongConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_ULONG_LONG, \\\n        .config.ull = &(config_addr) \\\n    } \\\n}\n\n#define createSizeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_SIZE_T, \\\n        .config.st = &(config_addr) \\\n    } \\\n}\n\n#define createSSizeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_SSIZE_T, \\\n        .config.sst = &(config_addr) \\\n    } \\\n}\n\n#define createTimeTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_TIME_T, \\\n        .config.tt = &(config_addr) \\\n    } \\\n}\n\n#define createOffTConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n    embedCommonNumericalConfig(name, alias, modifiable, lower, upper, config_addr, default, memory, is_valid, update) \\\n        .numeric_type = NUMERIC_TYPE_OFF_T, \\\n        .config.ot = &(config_addr) \\\n    } \\\n}\n\nstatic int isValidActiveDefrag(int val, char **err) {\n#ifndef HAVE_DEFRAG\n    if (val) {\n        *err = \"Active defragmentation cannot be enabled: it \"\n               \"requires a Redis server compiled with a modified Jemalloc \"\n               \"like the one shipped by default with the Redis source \"\n               \"distribution\";\n        return 0;\n    }\n#else\n    UNUSED(val);\n    UNUSED(err);\n#endif\n    return 1;\n}\n\nstatic int isValidDBfilename(char *val, char **err) {\n    if (!pathIsBaseName(val)) {\n        *err = \"dbfilename can't be a path, just a filename\";\n        return 0;\n    }\n    return 1;\n}\n\nstatic int isValidAOFfilename(char *val, char **err) {\n    if (!pathIsBaseName(val)) {\n        *err = \"appendfilename can't be a path, just a filename\";\n        return 0;\n    }\n    return 1;\n}\n\nstatic int updateHZ(long long val, long long prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    /* Hz is more a hint from the user, so we accept values out of range\n     * but cap them to reasonable values. */\n    server.config_hz = val;\n    if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;\n    if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;\n    server.hz = server.config_hz;\n    return 1;\n}\n\nstatic int updateJemallocBgThread(int val, int prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    set_jemalloc_bg_thread(val);\n    return 1;\n}\n\nstatic int updateReplBacklogSize(long long val, long long prev, char **err) {\n    /* resizeReplicationBacklog sets server.repl_backlog_size, and relies on\n     * being able to tell when the size changes, so restore prev before calling it. */\n    UNUSED(err);\n    server.repl_backlog_size = prev;\n    resizeReplicationBacklog(val);\n    return 1;\n}\n\nstatic int updateMaxmemory(long long val, long long prev, char **err) {\n    UNUSED(prev);\n    UNUSED(err);\n    if (val) {\n        size_t used = zmalloc_used_memory()-freeMemoryGetNotCountedMemory();\n        if ((unsigned long long)val < used) {\n            serverLog(LL_WARNING,\"WARNING: the new maxmemory value set via CONFIG SET (%llu) is smaller than the current memory usage (%zu). This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy.\", server.maxmemory, used);\n        }\n        freeMemoryIfNeededAndSafe();\n    }\n    return 1;\n}\n\nstatic int updateGoodSlaves(long long val, long long prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    UNUSED(err);\n    refreshGoodSlavesCount();\n    return 1;\n}\n\nstatic int updateAppendonly(int val, int prev, char **err) {\n    UNUSED(prev);\n    if (val == 0 && server.aof_state != AOF_OFF) {\n        stopAppendOnly();\n    } else if (val && server.aof_state == AOF_OFF) {\n        if (startAppendOnly() == C_ERR) {\n            *err = \"Unable to turn on AOF. Check server logs.\";\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int updateMaxclients(long long val, long long prev, char **err) {\n    /* Try to check if the OS is capable of supporting so many FDs. */\n    if (val > prev) {\n        adjustOpenFilesLimit();\n        if (server.maxclients != val) {\n            static char msg[128];\n            sprintf(msg, \"The operating system is not able to handle the specified number of clients, try with %d\", server.maxclients);\n            *err = msg;\n            if (server.maxclients > prev) {\n                server.maxclients = prev;\n                adjustOpenFilesLimit();\n            }\n            return 0;\n        }\n        if ((unsigned int) aeGetSetSize(server.el) <\n            server.maxclients + CONFIG_FDSET_INCR)\n        {\n            if (aeResizeSetSize(server.el,\n                server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)\n            {\n                *err = \"The event loop API used by Redis is not able to handle the specified number of clients\";\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nstatic int updateOOMScoreAdj(int val, int prev, char **err) {\n    UNUSED(prev);\n\n    if (val) {\n        if (setOOMScoreAdj(-1) == C_ERR) {\n            *err = \"Failed to set current oom_score_adj. Check server logs.\";\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n#ifdef USE_OPENSSL\nstatic int updateTlsCfg(char *val, char *prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    UNUSED(err);\n\n    /* If TLS is enabled, try to configure OpenSSL. */\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n            && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        *err = \"Unable to update TLS configuration. Check server logs.\";\n        return 0;\n    }\n    return 1;\n}\nstatic int updateTlsCfgBool(int val, int prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    return updateTlsCfg(NULL, NULL, err);\n}\n\nstatic int updateTlsCfgInt(long long val, long long prev, char **err) {\n    UNUSED(val);\n    UNUSED(prev);\n    return updateTlsCfg(NULL, NULL, err);\n}\n#endif  /* USE_OPENSSL */\n\nstandardConfig configs[] = {\n    /* Bool configs */\n    createBoolConfig(\"rdbchecksum\", NULL, IMMUTABLE_CONFIG, server.rdb_checksum, 1, NULL, NULL),\n    createBoolConfig(\"daemonize\", NULL, IMMUTABLE_CONFIG, server.daemonize, 0, NULL, NULL),\n    createBoolConfig(\"io-threads-do-reads\", NULL, IMMUTABLE_CONFIG, server.io_threads_do_reads, 0,NULL, NULL), /* Read + parse from threads? */\n    createBoolConfig(\"lua-replicate-commands\", NULL, MODIFIABLE_CONFIG, server.lua_always_replicate_commands, 1, NULL, NULL),\n    createBoolConfig(\"always-show-logo\", NULL, IMMUTABLE_CONFIG, server.always_show_logo, 0, NULL, NULL),\n    createBoolConfig(\"protected-mode\", NULL, MODIFIABLE_CONFIG, server.protected_mode, 1, NULL, NULL),\n    createBoolConfig(\"rdbcompression\", NULL, MODIFIABLE_CONFIG, server.rdb_compression, 1, NULL, NULL),\n    createBoolConfig(\"rdb-del-sync-files\", NULL, MODIFIABLE_CONFIG, server.rdb_del_sync_files, 0, NULL, NULL),\n    createBoolConfig(\"activerehashing\", NULL, MODIFIABLE_CONFIG, server.activerehashing, 1, NULL, NULL),\n    createBoolConfig(\"stop-writes-on-bgsave-error\", NULL, MODIFIABLE_CONFIG, server.stop_writes_on_bgsave_err, 1, NULL, NULL),\n    createBoolConfig(\"dynamic-hz\", NULL, MODIFIABLE_CONFIG, server.dynamic_hz, 1, NULL, NULL), /* Adapt hz to # of clients.*/\n    createBoolConfig(\"lazyfree-lazy-eviction\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_eviction, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-expire\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_expire, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-server-del\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_server_del, 0, NULL, NULL),\n    createBoolConfig(\"lazyfree-lazy-user-del\", NULL, MODIFIABLE_CONFIG, server.lazyfree_lazy_user_del , 0, NULL, NULL),\n    createBoolConfig(\"repl-disable-tcp-nodelay\", NULL, MODIFIABLE_CONFIG, server.repl_disable_tcp_nodelay, 0, NULL, NULL),\n    createBoolConfig(\"repl-diskless-sync\", NULL, MODIFIABLE_CONFIG, server.repl_diskless_sync, 0, NULL, NULL),\n    createBoolConfig(\"gopher-enabled\", NULL, MODIFIABLE_CONFIG, server.gopher_enabled, 0, NULL, NULL),\n    createBoolConfig(\"aof-rewrite-incremental-fsync\", NULL, MODIFIABLE_CONFIG, server.aof_rewrite_incremental_fsync, 1, NULL, NULL),\n    createBoolConfig(\"no-appendfsync-on-rewrite\", NULL, MODIFIABLE_CONFIG, server.aof_no_fsync_on_rewrite, 0, NULL, NULL),\n    createBoolConfig(\"cluster-require-full-coverage\", NULL, MODIFIABLE_CONFIG, server.cluster_require_full_coverage, 1, NULL, NULL),\n    createBoolConfig(\"rdb-save-incremental-fsync\", NULL, MODIFIABLE_CONFIG, server.rdb_save_incremental_fsync, 1, NULL, NULL),\n    createBoolConfig(\"aof-load-truncated\", NULL, MODIFIABLE_CONFIG, server.aof_load_truncated, 1, NULL, NULL),\n    createBoolConfig(\"aof-use-rdb-preamble\", NULL, MODIFIABLE_CONFIG, server.aof_use_rdb_preamble, 1, NULL, NULL),\n    createBoolConfig(\"cluster-replica-no-failover\", \"cluster-slave-no-failover\", MODIFIABLE_CONFIG, server.cluster_slave_no_failover, 0, NULL, NULL), /* Failover by default. */\n    createBoolConfig(\"replica-lazy-flush\", \"slave-lazy-flush\", MODIFIABLE_CONFIG, server.repl_slave_lazy_flush, 0, NULL, NULL),\n    createBoolConfig(\"replica-serve-stale-data\", \"slave-serve-stale-data\", MODIFIABLE_CONFIG, server.repl_serve_stale_data, 1, NULL, NULL),\n    createBoolConfig(\"replica-read-only\", \"slave-read-only\", MODIFIABLE_CONFIG, server.repl_slave_ro, 1, NULL, NULL),\n    createBoolConfig(\"replica-ignore-maxmemory\", \"slave-ignore-maxmemory\", MODIFIABLE_CONFIG, server.repl_slave_ignore_maxmemory, 1, NULL, NULL),\n    createBoolConfig(\"jemalloc-bg-thread\", NULL, MODIFIABLE_CONFIG, server.jemalloc_bg_thread, 1, NULL, updateJemallocBgThread),\n    createBoolConfig(\"activedefrag\", NULL, MODIFIABLE_CONFIG, server.active_defrag_enabled, 0, isValidActiveDefrag, NULL),\n    createBoolConfig(\"syslog-enabled\", NULL, IMMUTABLE_CONFIG, server.syslog_enabled, 0, NULL, NULL),\n    createBoolConfig(\"cluster-enabled\", NULL, IMMUTABLE_CONFIG, server.cluster_enabled, 0, NULL, NULL),\n    createBoolConfig(\"appendonly\", NULL, MODIFIABLE_CONFIG, server.aof_enabled, 0, NULL, updateAppendonly),\n    createBoolConfig(\"cluster-allow-reads-when-down\", NULL, MODIFIABLE_CONFIG, server.cluster_allow_reads_when_down, 0, NULL, NULL),\n\n    /* String Configs */\n    createStringConfig(\"aclfile\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.acl_filename, \"\", NULL, NULL),\n    createStringConfig(\"unixsocket\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.unixsocket, NULL, NULL, NULL),\n    createStringConfig(\"pidfile\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.pidfile, NULL, NULL, NULL),\n    createStringConfig(\"replica-announce-ip\", \"slave-announce-ip\", MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.slave_announce_ip, NULL, NULL, NULL),\n    createStringConfig(\"masteruser\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.masteruser, NULL, NULL, NULL),\n    createStringConfig(\"masterauth\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.masterauth, NULL, NULL, NULL),\n    createStringConfig(\"cluster-announce-ip\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.cluster_announce_ip, NULL, NULL, NULL),\n    createStringConfig(\"syslog-ident\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.syslog_ident, \"redis\", NULL, NULL),\n    createStringConfig(\"dbfilename\", NULL, MODIFIABLE_CONFIG, ALLOW_EMPTY_STRING, server.rdb_filename, \"dump.rdb\", isValidDBfilename, NULL),\n    createStringConfig(\"appendfilename\", NULL, IMMUTABLE_CONFIG, ALLOW_EMPTY_STRING, server.aof_filename, \"appendonly.aof\", isValidAOFfilename, NULL),\n    createStringConfig(\"server_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.server_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"bio_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.bio_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"aof_rewrite_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.aof_rewrite_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"bgsave_cpulist\", NULL, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, server.bgsave_cpulist, NULL, NULL, NULL),\n    createStringConfig(\"ignore-warnings\", NULL, MODIFIABLE_CONFIG, ALLOW_EMPTY_STRING, server.ignore_warnings, \"ARM64-COW-BUG\", NULL, NULL),\n\n    /* Enum Configs */\n    createEnumConfig(\"supervised\", NULL, IMMUTABLE_CONFIG, supervised_mode_enum, server.supervised_mode, SUPERVISED_NONE, NULL, NULL),\n    createEnumConfig(\"syslog-facility\", NULL, IMMUTABLE_CONFIG, syslog_facility_enum, server.syslog_facility, LOG_LOCAL0, NULL, NULL),\n    createEnumConfig(\"repl-diskless-load\", NULL, MODIFIABLE_CONFIG, repl_diskless_load_enum, server.repl_diskless_load, REPL_DISKLESS_LOAD_DISABLED, NULL, NULL),\n    createEnumConfig(\"loglevel\", NULL, MODIFIABLE_CONFIG, loglevel_enum, server.verbosity, LL_NOTICE, NULL, NULL),\n    createEnumConfig(\"maxmemory-policy\", NULL, MODIFIABLE_CONFIG, maxmemory_policy_enum, server.maxmemory_policy, MAXMEMORY_NO_EVICTION, NULL, NULL),\n    createEnumConfig(\"appendfsync\", NULL, MODIFIABLE_CONFIG, aof_fsync_enum, server.aof_fsync, AOF_FSYNC_EVERYSEC, NULL, NULL),\n    createEnumConfig(\"oom-score-adj\", NULL, MODIFIABLE_CONFIG, oom_score_adj_enum, server.oom_score_adj, OOM_SCORE_ADJ_NO, NULL, updateOOMScoreAdj),\n\n    /* Integer configs */\n    createIntConfig(\"databases\", NULL, IMMUTABLE_CONFIG, 1, INT_MAX, server.dbnum, 16, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"port\", NULL, IMMUTABLE_CONFIG, 0, 65535, server.port, 6379, INTEGER_CONFIG, NULL, NULL), /* TCP port. */\n    createIntConfig(\"io-threads\", NULL, IMMUTABLE_CONFIG, 1, 128, server.io_threads_num, 1, INTEGER_CONFIG, NULL, NULL), /* Single threaded by default */\n    createIntConfig(\"auto-aof-rewrite-percentage\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.aof_rewrite_perc, 100, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"cluster-replica-validity-factor\", \"cluster-slave-validity-factor\", MODIFIABLE_CONFIG, 0, INT_MAX, server.cluster_slave_validity_factor, 10, INTEGER_CONFIG, NULL, NULL), /* Slave max data age factor. */\n    createIntConfig(\"list-max-ziplist-size\", NULL, MODIFIABLE_CONFIG, INT_MIN, INT_MAX, server.list_max_ziplist_size, -2, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"tcp-keepalive\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tcpkeepalive, 300, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"cluster-migration-barrier\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.cluster_migration_barrier, 1, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"active-defrag-cycle-min\", NULL, MODIFIABLE_CONFIG, 1, 99, server.active_defrag_cycle_min, 1, INTEGER_CONFIG, NULL, NULL), /* Default: 1% CPU min (at lower threshold) */\n    createIntConfig(\"active-defrag-cycle-max\", NULL, MODIFIABLE_CONFIG, 1, 99, server.active_defrag_cycle_max, 25, INTEGER_CONFIG, NULL, NULL), /* Default: 25% CPU max (at upper threshold) */\n    createIntConfig(\"active-defrag-threshold-lower\", NULL, MODIFIABLE_CONFIG, 0, 1000, server.active_defrag_threshold_lower, 10, INTEGER_CONFIG, NULL, NULL), /* Default: don't defrag when fragmentation is below 10% */\n    createIntConfig(\"active-defrag-threshold-upper\", NULL, MODIFIABLE_CONFIG, 0, 1000, server.active_defrag_threshold_upper, 100, INTEGER_CONFIG, NULL, NULL), /* Default: maximum defrag force at 100% fragmentation */\n    createIntConfig(\"lfu-log-factor\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.lfu_log_factor, 10, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"lfu-decay-time\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.lfu_decay_time, 1, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"replica-priority\", \"slave-priority\", MODIFIABLE_CONFIG, 0, INT_MAX, server.slave_priority, 100, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"repl-diskless-sync-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_diskless_sync_delay, 5, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"maxmemory-samples\", NULL, MODIFIABLE_CONFIG, 1, INT_MAX, server.maxmemory_samples, 5, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"timeout\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.maxidletime, 0, INTEGER_CONFIG, NULL, NULL), /* Default client timeout: infinite */\n    createIntConfig(\"replica-announce-port\", \"slave-announce-port\", MODIFIABLE_CONFIG, 0, 65535, server.slave_announce_port, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"tcp-backlog\", NULL, IMMUTABLE_CONFIG, 0, INT_MAX, server.tcp_backlog, 511, INTEGER_CONFIG, NULL, NULL), /* TCP listen backlog. */\n    createIntConfig(\"cluster-announce-bus-port\", NULL, MODIFIABLE_CONFIG, 0, 65535, server.cluster_announce_bus_port, 0, INTEGER_CONFIG, NULL, NULL), /* Default: Use +10000 offset. */\n    createIntConfig(\"cluster-announce-port\", NULL, MODIFIABLE_CONFIG, 0, 65535, server.cluster_announce_port, 0, INTEGER_CONFIG, NULL, NULL), /* Use server.port */\n    createIntConfig(\"repl-timeout\", NULL, MODIFIABLE_CONFIG, 1, INT_MAX, server.repl_timeout, 60, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"repl-ping-replica-period\", \"repl-ping-slave-period\", MODIFIABLE_CONFIG, 1, INT_MAX, server.repl_ping_slave_period, 10, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"list-compress-depth\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.list_compress_depth, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"rdb-key-save-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.rdb_key_save_delay, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"key-load-delay\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.key_load_delay, 0, INTEGER_CONFIG, NULL, NULL),\n    createIntConfig(\"active-expire-effort\", NULL, MODIFIABLE_CONFIG, 1, 10, server.active_expire_effort, 1, INTEGER_CONFIG, NULL, NULL), /* From 1 to 10. */\n    createIntConfig(\"hz\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.config_hz, CONFIG_DEFAULT_HZ, INTEGER_CONFIG, NULL, updateHZ),\n    createIntConfig(\"min-replicas-to-write\", \"min-slaves-to-write\", MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_min_slaves_to_write, 0, INTEGER_CONFIG, NULL, updateGoodSlaves),\n    createIntConfig(\"min-replicas-max-lag\", \"min-slaves-max-lag\", MODIFIABLE_CONFIG, 0, INT_MAX, server.repl_min_slaves_max_lag, 10, INTEGER_CONFIG, NULL, updateGoodSlaves),\n\n    /* Unsigned int configs */\n    createUIntConfig(\"maxclients\", NULL, MODIFIABLE_CONFIG, 1, UINT_MAX, server.maxclients, 10000, INTEGER_CONFIG, NULL, updateMaxclients),\n\n    /* Unsigned Long configs */\n    createULongConfig(\"active-defrag-max-scan-fields\", NULL, MODIFIABLE_CONFIG, 1, LONG_MAX, server.active_defrag_max_scan_fields, 1000, INTEGER_CONFIG, NULL, NULL), /* Default: keys with more than 1000 fields will be processed separately */\n    createULongConfig(\"slowlog-max-len\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.slowlog_max_len, 128, INTEGER_CONFIG, NULL, NULL),\n    createULongConfig(\"acllog-max-len\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.acllog_max_len, 128, INTEGER_CONFIG, NULL, NULL),\n\n    /* Long Long configs */\n    createLongLongConfig(\"lua-time-limit\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.lua_time_limit, 5000, INTEGER_CONFIG, NULL, NULL),/* milliseconds */\n    createLongLongConfig(\"cluster-node-timeout\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.cluster_node_timeout, 15000, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"slowlog-log-slower-than\", NULL, MODIFIABLE_CONFIG, -1, LLONG_MAX, server.slowlog_log_slower_than, 10000, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"latency-monitor-threshold\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.latency_monitor_threshold, 0, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"proto-max-bulk-len\", NULL, MODIFIABLE_CONFIG, 1024*1024, LONG_MAX, server.proto_max_bulk_len, 512ll*1024*1024, MEMORY_CONFIG, NULL, NULL), /* Bulk request max size */\n    createLongLongConfig(\"stream-node-max-entries\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.stream_node_max_entries, 100, INTEGER_CONFIG, NULL, NULL),\n    createLongLongConfig(\"repl-backlog-size\", NULL, MODIFIABLE_CONFIG, 1, LLONG_MAX, server.repl_backlog_size, 1024*1024, MEMORY_CONFIG, NULL, updateReplBacklogSize), /* Default: 1mb */\n\n    /* Unsigned Long Long configs */\n    createULongLongConfig(\"maxmemory\", NULL, MODIFIABLE_CONFIG, 0, ULLONG_MAX, server.maxmemory, 0, MEMORY_CONFIG, NULL, updateMaxmemory),\n\n    /* Size_t configs */\n    createSizeTConfig(\"hash-max-ziplist-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hash_max_ziplist_entries, 512, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"set-max-intset-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.set_max_intset_entries, 512, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"zset-max-ziplist-entries\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.zset_max_ziplist_entries, 128, INTEGER_CONFIG, NULL, NULL),\n    createSizeTConfig(\"active-defrag-ignore-bytes\", NULL, MODIFIABLE_CONFIG, 1, LLONG_MAX, server.active_defrag_ignore_bytes, 100<<20, MEMORY_CONFIG, NULL, NULL), /* Default: don't defrag if frag overhead is below 100mb */\n    createSizeTConfig(\"hash-max-ziplist-value\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hash_max_ziplist_value, 64, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"stream-node-max-bytes\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.stream_node_max_bytes, 4096, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"zset-max-ziplist-value\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.zset_max_ziplist_value, 64, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"hll-sparse-max-bytes\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.hll_sparse_max_bytes, 3000, MEMORY_CONFIG, NULL, NULL),\n    createSizeTConfig(\"tracking-table-max-keys\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.tracking_table_max_keys, 1000000, INTEGER_CONFIG, NULL, NULL), /* Default: 1 million keys max. */\n\n    /* Other configs */\n    createTimeTConfig(\"repl-backlog-ttl\", NULL, MODIFIABLE_CONFIG, 0, LONG_MAX, server.repl_backlog_time_limit, 60*60, INTEGER_CONFIG, NULL, NULL), /* Default: 1 hour */\n    createOffTConfig(\"auto-aof-rewrite-min-size\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.aof_rewrite_min_size, 64*1024*1024, MEMORY_CONFIG, NULL, NULL),\n\n#ifdef USE_OPENSSL\n    createIntConfig(\"tls-port\", NULL, IMMUTABLE_CONFIG, 0, 65535, server.tls_port, 0, INTEGER_CONFIG, NULL, updateTlsCfgInt), /* TCP port. */\n    createIntConfig(\"tls-session-cache-size\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tls_ctx_config.session_cache_size, 20*1024, INTEGER_CONFIG, NULL, updateTlsCfgInt),\n    createIntConfig(\"tls-session-cache-timeout\", NULL, MODIFIABLE_CONFIG, 0, INT_MAX, server.tls_ctx_config.session_cache_timeout, 300, INTEGER_CONFIG, NULL, updateTlsCfgInt),\n    createBoolConfig(\"tls-cluster\", NULL, MODIFIABLE_CONFIG, server.tls_cluster, 0, NULL, updateTlsCfgBool),\n    createBoolConfig(\"tls-replication\", NULL, MODIFIABLE_CONFIG, server.tls_replication, 0, NULL, updateTlsCfgBool),\n    createEnumConfig(\"tls-auth-clients\", NULL, MODIFIABLE_CONFIG, tls_auth_clients_enum, server.tls_auth_clients, TLS_CLIENT_AUTH_YES, NULL, NULL),\n    createBoolConfig(\"tls-prefer-server-ciphers\", NULL, MODIFIABLE_CONFIG, server.tls_ctx_config.prefer_server_ciphers, 0, NULL, updateTlsCfgBool),\n    createBoolConfig(\"tls-session-caching\", NULL, MODIFIABLE_CONFIG, server.tls_ctx_config.session_caching, 1, NULL, updateTlsCfgBool),\n    createStringConfig(\"tls-cert-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.cert_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-key-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.key_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-dh-params-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.dh_params_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ca-cert-file\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ca_cert_file, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ca-cert-dir\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ca_cert_dir, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-protocols\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.protocols, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ciphers\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ciphers, NULL, NULL, updateTlsCfg),\n    createStringConfig(\"tls-ciphersuites\", NULL, MODIFIABLE_CONFIG, EMPTY_STRING_IS_NULL, server.tls_ctx_config.ciphersuites, NULL, NULL, updateTlsCfg),\n#endif\n\n    /* NULL Terminator */\n    {NULL}\n};\n\n/*-----------------------------------------------------------------------------\n * CONFIG command entry point\n *----------------------------------------------------------------------------*/\n\nvoid configCommand(client *c) {\n    /* Only allow CONFIG GET while loading. */\n    if (server.loading && strcasecmp(c->argv[1]->ptr,\"get\")) {\n        addReplyError(c,\"Only CONFIG GET is allowed during loading\");\n        return;\n    }\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"GET <pattern> -- Return parameters matching the glob-like <pattern> and their values.\",\n\"SET <parameter> <value> -- Set parameter to value.\",\n\"RESETSTAT -- Reset statistics reported by INFO.\",\n\"REWRITE -- Rewrite the configuration file.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set\") && c->argc == 4) {\n        configSetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"get\") && c->argc == 3) {\n        configGetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"resetstat\") && c->argc == 2) {\n        resetServerStats();\n        resetCommandTableStats();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"rewrite\") && c->argc == 2) {\n        if (server.configfile == NULL) {\n            addReplyError(c,\"The server is running without a config file\");\n            return;\n        }\n        if (rewriteConfig(server.configfile, 0) == -1) {\n            serverLog(LL_WARNING,\"CONFIG REWRITE failed: %s\", strerror(errno));\n            addReplyErrorFormat(c,\"Rewriting config file: %s\", strerror(errno));\n        } else {\n            serverLog(LL_WARNING,\"CONFIG REWRITE executed with success.\");\n            addReply(c,shared.ok);\n        }\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n", "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <limits.h>\n#include \"sds.h\"\n#include \"sdsalloc.h\"\n\nconst char *SDS_NOINIT = \"SDS_NOINIT\";\n\nstatic inline int sdsHdrSize(char type) {\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            return sizeof(struct sdshdr8);\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16);\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32);\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64);\n    }\n    return 0;\n}\n\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5)\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-termined (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}\n\n/* Create an empty (zero length) sds string. Even in this case the string\n * always has an implicit null term. */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n\n/* Create a new sds string starting from a null terminated C string. */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n\n/* Duplicate an sds string. */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n\n/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n *\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\nvoid sdsupdatelen(sds s) {\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}\n\n/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\nvoid sdsclear(sds s) {\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}\n\n/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}\n\n/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdsRemoveFreeSpace(sds s) {\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);\n    size_t len = sdslen(s);\n    size_t avail = sdsavail(s);\n    sh = (char*)s-oldhdrlen;\n\n    /* Return ASAP if there is no space left. */\n    if (avail == 0) return s;\n\n    /* Check what would be the minimum SDS header that is just good enough to\n     * fit this string. */\n    type = sdsReqType(len);\n    hdrlen = sdsHdrSize(type);\n\n    /* If the type is the same, or at least a large enough type is still\n     * required, we just realloc(), letting the allocator to do the copy\n     * only if really needed. Otherwise if the change is huge, we manually\n     * reallocate the string to use the different header type. */\n    if (oldtype==type || type > SDS_TYPE_8) {\n        newsh = s_realloc(sh, oldhdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+oldhdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, len);\n    return s;\n}\n\n/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\nsize_t sdsAllocSize(sds s) {\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}\n\n/* Return the pointer of the actual SDS allocation (normally SDS strings\n * are referenced by the start of the string buffer). */\nvoid *sdsAllocPtr(sds s) {\n    return (void*) (s-sdsHdrSize(s[-1]));\n}\n\n/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\nvoid sdsIncrLen(sds s, ssize_t incr) {\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}\n\n/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\nsds sdsgrowzero(sds s, size_t len) {\n    size_t curlen = sdslen(s);\n\n    if (len <= curlen) return s;\n    s = sdsMakeRoomFor(s,len-curlen);\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s);\n\n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}\n\n/* Append the specified null terminated C string to the sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n\n/* Append the specified sds 't' to the existing sds 's'.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n\n/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\nsds sdscpylen(sds s, const char *t, size_t len) {\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Like sdscpylen() but 't' must be a null-termined string so that the length\n * of the string is obtained with strlen(). */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * a reversed string. */\n    v = (value < 0) ? -value : value;\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Identical sdsll2str(), but for unsigned long long type. */\nint sdsull2str(char *s, unsigned long long v) {\n    char *p, aux;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * a reversed string. */\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}\n\n/* Like sdscatprintf() but gets va_list instead of being variadic. */\nsds sdscatvprintf(sds s, const char *fmt, va_list ap) {\n    va_list cpy;\n    char staticbuf[1024], *buf = staticbuf, *t;\n    size_t buflen = strlen(fmt)*2;\n    int bufstrlen;\n\n    /* We try to start using a static buffer for speed.\n     * If not possible we revert to heap allocation. */\n    if (buflen > sizeof(staticbuf)) {\n        buf = s_malloc(buflen);\n        if (buf == NULL) return NULL;\n    } else {\n        buflen = sizeof(staticbuf);\n    }\n\n    /* Alloc enough space for buffer and \\0 after failing to\n     * fit the string in the current buffer size. */\n    while(1) {\n        va_copy(cpy,ap);\n        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);\n        va_end(cpy);\n        if (bufstrlen < 0) {\n            if (buf != staticbuf) s_free(buf);\n            return NULL;\n        }\n        if (((size_t)bufstrlen) >= buflen) {\n            if (buf != staticbuf) s_free(buf);\n            buflen = ((size_t)bufstrlen) + 1;\n            buf = s_malloc(buflen);\n            if (buf == NULL) return NULL;\n            continue;\n        }\n        break;\n    }\n\n    /* Finally concat the obtained string to the SDS string and return it. */\n    t = sdscatlen(s, buf, bufstrlen);\n    if (buf != staticbuf) s_free(buf);\n    return t;\n}\n\n/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\nsds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}\n\n/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\nsds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}\n\n/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminted C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\nsds sdstrim(sds s, const char *cset) {\n    char *start, *end, *sp, *ep;\n    size_t len;\n\n    sp = start = s;\n    ep = end = s+sdslen(s)-1;\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--;\n    len = (sp > ep) ? 0 : ((ep-sp)+1);\n    if (s != sp) memmove(s, sp, len);\n    s[len] = '\\0';\n    sdssetlen(s,len);\n    return s;\n}\n\n/* Turn the string into a smaller (or equal) string containing only the\n * substring specified by the 'start' and 'end' indexes.\n *\n * start and end can be negative, where -1 means the last character of the\n * string, -2 the penultimate character, and so forth.\n *\n * The interval is inclusive, so the start and end characters will be part\n * of the resulting string.\n *\n * The string is modified in-place.\n *\n * Example:\n *\n * s = sdsnew(\"Hello World\");\n * sdsrange(s,1,-1); => \"ello World\"\n */\nvoid sdsrange(sds s, ssize_t start, ssize_t end) {\n    size_t newlen, len = sdslen(s);\n\n    if (len == 0) return;\n    if (start < 0) {\n        start = len+start;\n        if (start < 0) start = 0;\n    }\n    if (end < 0) {\n        end = len+end;\n        if (end < 0) end = 0;\n    }\n    newlen = (start > end) ? 0 : (end-start)+1;\n    if (newlen != 0) {\n        if (start >= (ssize_t)len) {\n            newlen = 0;\n        } else if (end >= (ssize_t)len) {\n            end = len-1;\n            newlen = (start > end) ? 0 : (end-start)+1;\n        }\n    } else {\n        start = 0;\n    }\n    if (start && newlen) memmove(s, s+start, newlen);\n    s[newlen] = 0;\n    sdssetlen(s,newlen);\n}\n\n/* Apply tolower() to every character of the sds string 's'. */\nvoid sdstolower(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}\n\n/* Apply toupper() to every character of the sds string 's'. */\nvoid sdstoupper(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}\n\n/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\nint sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}\n\n/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5;\n    long start = 0, j;\n    sds *tokens;\n\n    if (seplen < 1 || len < 0) return NULL;\n\n    tokens = s_malloc(sizeof(sds)*slots);\n    if (tokens == NULL) return NULL;\n\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        if (slots < elements+2) {\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) goto cleanup;\n            tokens = newtokens;\n        }\n        /* search the separator */\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start);\n            if (tokens[elements] == NULL) goto cleanup;\n            elements++;\n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start);\n    if (tokens[elements] == NULL) goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        s_free(tokens);\n        *count = 0;\n        return NULL;\n    }\n}\n\n/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\nvoid sdsfreesplitres(sds *tokens, int count) {\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}\n\n/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s,\"\\\"\",1);\n    while(len--) {\n        switch(*p) {\n        case '\\\\':\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:\n            if (isprint(*p))\n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1);\n}\n\n/* Helper function for sdssplitargs() that returns non zero if 'c'\n * is a valid hex digit. */\nint is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n           (c >= 'A' && c <= 'F');\n}\n\n/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\nint hex_digit_to_int(char c) {\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}\n\n/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\nsds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */\n            int insq=0; /* set to 1 if we are in 'single quotes' */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);\n                        p += 3;\n                    } else if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) {\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    case '\\'':\n                        insq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}\n\n/* Modify the string substituting all the occurrences of the set of\n * characters specified in the 'from' string to the corresponding character\n * in the 'to' array.\n *\n * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2)\n * will have the effect of turning the string \"hello\" into \"0ell1\".\n *\n * The function returns the sds string pointer, that is always the same\n * as the input pointer since no resize is needed. */\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\nsds sdsjoin(char **argv, int argc, char *sep) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}\n\n/* Like sdsjoin, but joins an array of SDS strings. */\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}\n\n/* Wrappers to the allocators used by SDS. Note that SDS will actually\n * just use the macros defined into sdsalloc.h in order to avoid to pay\n * the overhead of function calls. Here we define these wrappers only for\n * the programs SDS is linked to, if they want to touch the SDS internals\n * even if they use a different allocator. */\nvoid *sds_malloc(size_t size) { return s_malloc(size); }\nvoid *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\nvoid sds_free(void *ptr) { s_free(ptr); }\n\n#if defined(SDS_TEST_MAIN)\n#include <stdio.h>\n#include \"testhelp.h\"\n#include \"limits.h\"\n\n#define UNUSED(x) (void)(x)\nint sdsTest(void) {\n    {\n        sds x = sdsnew(\"foo\"), y;\n\n        test_cond(\"Create a string and obtain the length\",\n            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnewlen(\"foo\",2);\n        test_cond(\"Create a string with specified length\",\n            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n\n        x = sdscat(x,\"bar\");\n        test_cond(\"Strings concatenation\",\n            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\n        x = sdscpy(x,\"a\");\n        test_cond(\"sdscpy() against an originally longer string\",\n            sdslen(x) == 1 && memcmp(x,\"a\\0\",2) == 0)\n\n        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\");\n        test_cond(\"sdscpy() against an originally shorter string\",\n            sdslen(x) == 33 &&\n            memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0\",33) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"%d\",123);\n        test_cond(\"sdscatprintf() seems working in the base case\",\n            sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"a%cb\",0);\n        test_cond(\"sdscatprintf() seems working with \\\\0 inside of result\",\n            sdslen(x) == 3 && memcmp(x,\"a\\0\"\"b\\0\",4) == 0)\n\n        {\n            sdsfree(x);\n            char etalon[1024*1024];\n            for (size_t i = 0; i < sizeof(etalon); i++) {\n                etalon[i] = '0';\n            }\n            x = sdscatprintf(sdsempty(),\"%0*d\",(int)sizeof(etalon),0);\n            test_cond(\"sdscatprintf() can print 1MB\",\n                sdslen(x) == sizeof(etalon) && memcmp(x,etalon,sizeof(etalon)) == 0)\n        }\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n        test_cond(\"sdscatfmt() seems working in the base case\",\n            sdslen(x) == 60 &&\n            memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\n                     \"9223372036854775807--\",60) == 0)\n        printf(\"[%s]\\n\",x);\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n        test_cond(\"sdscatfmt() seems working with unsigned numbers\",\n            sdslen(x) == 35 &&\n            memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" x\");\n        test_cond(\"sdstrim() works when all chars match\",\n            sdslen(x) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" \");\n        test_cond(\"sdstrim() works when a single char remains\",\n            sdslen(x) == 1 && x[0] == 'x')\n\n        sdsfree(x);\n        x = sdsnew(\"xxciaoyyy\");\n        sdstrim(x,\"xy\");\n        test_cond(\"sdstrim() correctly trims characters\",\n            sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n\n        y = sdsdup(x);\n        sdsrange(y,1,1);\n        test_cond(\"sdsrange(...,1,1)\",\n            sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,-1);\n        test_cond(\"sdsrange(...,1,-1)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,-2,-1);\n        test_cond(\"sdsrange(...,-2,-1)\",\n            sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,2,1);\n        test_cond(\"sdsrange(...,2,1)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,100);\n        test_cond(\"sdsrange(...,1,100)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,100,100);\n        test_cond(\"sdsrange(...,100,100)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"foo\");\n        y = sdsnew(\"foa\");\n        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y) > 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"bar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"aar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) < 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n        y = sdscatrepr(sdsempty(),x,sdslen(x));\n        test_cond(\"sdscatrepr(...data...)\",\n            memcmp(y,\"\\\"\\\\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n\n        {\n            unsigned int oldfree;\n            char *p;\n            int step = 10, j, i;\n\n            sdsfree(x);\n            sdsfree(y);\n            x = sdsnew(\"0\");\n            test_cond(\"sdsnew() free/len buffers\", sdslen(x) == 1 && sdsavail(x) == 0);\n\n            /* Run the test a few times in order to hit the first two\n             * SDS header types. */\n            for (i = 0; i < 10; i++) {\n                int oldlen = sdslen(x);\n                x = sdsMakeRoomFor(x,step);\n                int type = x[-1]&SDS_TYPE_MASK;\n\n                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n                if (type != SDS_TYPE_5) {\n                    test_cond(\"sdsMakeRoomFor() free\", sdsavail(x) >= step);\n                    oldfree = sdsavail(x);\n                }\n                p = x+oldlen;\n                for (j = 0; j < step; j++) {\n                    p[j] = 'A'+j;\n                }\n                sdsIncrLen(x,step);\n            }\n            test_cond(\"sdsMakeRoomFor() content\",\n                memcmp(\"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\",x,101) == 0);\n            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n\n            sdsfree(x);\n        }\n    }\n    test_report()\n    return 0;\n}\n#endif\n\n#ifdef SDS_TEST_MAIN\nint main(void) {\n    return sdsTest();\n}\n#endif\n", "/* zmalloc - total amount of allocated memory aware version of malloc()\n *\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n/* This function provide us access to the original libc free(). This is useful\n * for instance to free results obtained by backtrace_symbols(). We need\n * to define this function before including zmalloc.h that may shadow the\n * free implementation if we use jemalloc or another non standard allocator. */\nvoid zlibc_free(void *ptr) {\n    free(ptr);\n}\n\n#include <string.h>\n#include <pthread.h>\n#include \"config.h\"\n#include \"zmalloc.h\"\n#include \"atomicvar.h\"\n\n#ifdef HAVE_MALLOC_SIZE\n#define PREFIX_SIZE (0)\n#else\n#if defined(__sun) || defined(__sparc) || defined(__sparc__)\n#define PREFIX_SIZE (sizeof(long long))\n#else\n#define PREFIX_SIZE (sizeof(size_t))\n#endif\n#endif\n\n#if PREFIX_SIZE > 0\n#define ASSERT_NO_SIZE_OVERFLOW(sz) assert((sz) + PREFIX_SIZE > (sz))\n#else\n#define ASSERT_NO_SIZE_OVERFLOW(sz)\n#endif\n\n/* Explicitly override malloc/free etc when using tcmalloc. */\n#if defined(USE_TCMALLOC)\n#define malloc(size) tc_malloc(size)\n#define calloc(count,size) tc_calloc(count,size)\n#define realloc(ptr,size) tc_realloc(ptr,size)\n#define free(ptr) tc_free(ptr)\n#elif defined(USE_JEMALLOC)\n#define malloc(size) je_malloc(size)\n#define calloc(count,size) je_calloc(count,size)\n#define realloc(ptr,size) je_realloc(ptr,size)\n#define free(ptr) je_free(ptr)\n#define mallocx(size,flags) je_mallocx(size,flags)\n#define dallocx(ptr,flags) je_dallocx(ptr,flags)\n#endif\n\n#define update_zmalloc_stat_alloc(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicIncr(used_memory,__n); \\\n} while(0)\n\n#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0)\n\nstatic size_t used_memory = 0;\npthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void zmalloc_default_oom(size_t size) {\n    fprintf(stderr, \"zmalloc: Out of memory trying to allocate %zu bytes\\n\",\n        size);\n    fflush(stderr);\n    abort();\n}\n\nstatic void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;\n\nvoid *zmalloc(size_t size) {\n    ASSERT_NO_SIZE_OVERFLOW(size);\n    void *ptr = malloc(size+PREFIX_SIZE);\n\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n\n/* Allocation and free functions that bypass the thread cache\n * and go straight to the allocator arena bins.\n * Currently implemented only for jemalloc. Used for online defragmentation. */\n#ifdef HAVE_DEFRAG\nvoid *zmalloc_no_tcache(size_t size) {\n    ASSERT_NO_SIZE_OVERFLOW(size);\n    void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);\n    if (!ptr) zmalloc_oom_handler(size);\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n}\n\nvoid zfree_no_tcache(void *ptr) {\n    if (ptr == NULL) return;\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    dallocx(ptr, MALLOCX_TCACHE_NONE);\n}\n#endif\n\nvoid *zcalloc(size_t size) {\n    ASSERT_NO_SIZE_OVERFLOW(size);\n    void *ptr = calloc(1, size+PREFIX_SIZE);\n\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n\nvoid *zrealloc(void *ptr, size_t size) {\n    ASSERT_NO_SIZE_OVERFLOW(size);\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n#endif\n    size_t oldsize;\n    void *newptr;\n\n    if (size == 0 && ptr != NULL) {\n        zfree(ptr);\n        return NULL;\n    }\n    if (ptr == NULL) return zmalloc(size);\n#ifdef HAVE_MALLOC_SIZE\n    oldsize = zmalloc_size(ptr);\n    newptr = realloc(ptr,size);\n    if (!newptr) zmalloc_oom_handler(size);\n\n    update_zmalloc_stat_free(oldsize);\n    update_zmalloc_stat_alloc(zmalloc_size(newptr));\n    return newptr;\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    newptr = realloc(realptr,size+PREFIX_SIZE);\n    if (!newptr) zmalloc_oom_handler(size);\n\n    *((size_t*)newptr) = size;\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)newptr+PREFIX_SIZE;\n#endif\n}\n\n/* Provide zmalloc_size() for systems where this function is not provided by\n * malloc itself, given that in that case we store a header with this\n * information as the first bytes of every allocation. */\n#ifndef HAVE_MALLOC_SIZE\nsize_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    return size+PREFIX_SIZE;\n}\nsize_t zmalloc_usable(void *ptr) {\n    return zmalloc_size(ptr)-PREFIX_SIZE;\n}\n#endif\n\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n\nchar *zstrdup(const char *s) {\n    size_t l = strlen(s)+1;\n    char *p = zmalloc(l);\n\n    memcpy(p,s,l);\n    return p;\n}\n\nsize_t zmalloc_used_memory(void) {\n    size_t um;\n    atomicGet(used_memory,um);\n    return um;\n}\n\nvoid zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {\n    zmalloc_oom_handler = oom_handler;\n}\n\n/* Get the RSS information in an OS-specific way.\n *\n * WARNING: the function zmalloc_get_rss() is not designed to be fast\n * and may not be called in the busy loops where Redis tries to release\n * memory expiring or swapping out objects.\n *\n * For this kind of \"fast RSS reporting\" usages use instead the\n * function RedisEstimateRSS() that is a much faster (and less precise)\n * version of the function. */\n\n#if defined(HAVE_PROC_STAT)\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nsize_t zmalloc_get_rss(void) {\n    int page = sysconf(_SC_PAGESIZE);\n    size_t rss;\n    char buf[4096];\n    char filename[256];\n    int fd, count;\n    char *p, *x;\n\n    snprintf(filename,256,\"/proc/%d/stat\",getpid());\n    if ((fd = open(filename,O_RDONLY)) == -1) return 0;\n    if (read(fd,buf,4096) <= 0) {\n        close(fd);\n        return 0;\n    }\n    close(fd);\n\n    p = buf;\n    count = 23; /* RSS is the 24th field in /proc/<pid>/stat */\n    while(p && count--) {\n        p = strchr(p,' ');\n        if (p) p++;\n    }\n    if (!p) return 0;\n    x = strchr(p,' ');\n    if (!x) return 0;\n    *x = '\\0';\n\n    rss = strtoll(p,NULL,10);\n    rss *= page;\n    return rss;\n}\n#elif defined(HAVE_TASKINFO)\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <mach/task.h>\n#include <mach/mach_init.h>\n\nsize_t zmalloc_get_rss(void) {\n    task_t task = MACH_PORT_NULL;\n    struct task_basic_info t_info;\n    mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;\n\n    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)\n        return 0;\n    task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);\n\n    return t_info.resident_size;\n}\n#elif defined(__FreeBSD__)\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n#include <unistd.h>\n\nsize_t zmalloc_get_rss(void) {\n    struct kinfo_proc info;\n    size_t infolen = sizeof(info);\n    int mib[4];\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = getpid();\n\n    if (sysctl(mib, 4, &info, &infolen, NULL, 0) == 0)\n        return (size_t)info.ki_rssize;\n\n    return 0L;\n}\n#elif defined(__NetBSD__)\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <unistd.h>\n\nsize_t zmalloc_get_rss(void) {\n    struct kinfo_proc2 info;\n    size_t infolen = sizeof(info);\n    int mib[6];\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = getpid();\n    mib[4] = sizeof(info);\n    mib[5] = 1;\n    if (sysctl(mib, 4, &info, &infolen, NULL, 0) == 0)\n        return (size_t)info.p_vm_rssize;\n\n    return 0L;\n}\n#else\nsize_t zmalloc_get_rss(void) {\n    /* If we can't get the RSS in an OS-specific way for this system just\n     * return the memory usage we estimated in zmalloc()..\n     *\n     * Fragmentation will appear to be always 1 (no fragmentation)\n     * of course... */\n    return zmalloc_used_memory();\n}\n#endif\n\n#if defined(USE_JEMALLOC)\n\nint zmalloc_get_allocator_info(size_t *allocated,\n                               size_t *active,\n                               size_t *resident) {\n    uint64_t epoch = 1;\n    size_t sz;\n    *allocated = *resident = *active = 0;\n    /* Update the statistics cached by mallctl. */\n    sz = sizeof(epoch);\n    je_mallctl(\"epoch\", &epoch, &sz, &epoch, sz);\n    sz = sizeof(size_t);\n    /* Unlike RSS, this does not include RSS from shared libraries and other non\n     * heap mappings. */\n    je_mallctl(\"stats.resident\", resident, &sz, NULL, 0);\n    /* Unlike resident, this doesn't not include the pages jemalloc reserves\n     * for re-use (purge will clean that). */\n    je_mallctl(\"stats.active\", active, &sz, NULL, 0);\n    /* Unlike zmalloc_used_memory, this matches the stats.resident by taking\n     * into account all allocations done by this process (not only zmalloc). */\n    je_mallctl(\"stats.allocated\", allocated, &sz, NULL, 0);\n    return 1;\n}\n\nvoid set_jemalloc_bg_thread(int enable) {\n    /* let jemalloc do purging asynchronously, required when there's no traffic \n     * after flushdb */\n    char val = !!enable;\n    je_mallctl(\"background_thread\", NULL, 0, &val, 1);\n}\n\nint jemalloc_purge() {\n    /* return all unused (reserved) pages to the OS */\n    char tmp[32];\n    unsigned narenas = 0;\n    size_t sz = sizeof(unsigned);\n    if (!je_mallctl(\"arenas.narenas\", &narenas, &sz, NULL, 0)) {\n        sprintf(tmp, \"arena.%d.purge\", narenas);\n        if (!je_mallctl(tmp, NULL, 0, NULL, 0))\n            return 0;\n    }\n    return -1;\n}\n\n#else\n\nint zmalloc_get_allocator_info(size_t *allocated,\n                               size_t *active,\n                               size_t *resident) {\n    *allocated = *resident = *active = 0;\n    return 1;\n}\n\nvoid set_jemalloc_bg_thread(int enable) {\n    ((void)(enable));\n}\n\nint jemalloc_purge() {\n    return 0;\n}\n\n#endif\n\n#if defined(__APPLE__)\n/* For proc_pidinfo() used later in zmalloc_get_smap_bytes_by_field().\n * Note that this file cannot be included in zmalloc.h because it includes\n * a Darwin queue.h file where there is a \"LIST_HEAD\" macro (!) defined\n * conficting with Redis user code. */\n#include <libproc.h>\n#endif\n\n/* Get the sum of the specified field (converted form kb to bytes) in\n * /proc/self/smaps. The field must be specified with trailing \":\" as it\n * apperas in the smaps output.\n *\n * If a pid is specified, the information is extracted for such a pid,\n * otherwise if pid is -1 the information is reported is about the\n * current process.\n *\n * Example: zmalloc_get_smap_bytes_by_field(\"Rss:\",-1);\n */\n#if defined(HAVE_PROC_SMAPS)\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\n    char line[1024];\n    size_t bytes = 0;\n    int flen = strlen(field);\n    FILE *fp;\n\n    if (pid == -1) {\n        fp = fopen(\"/proc/self/smaps\",\"r\");\n    } else {\n        char filename[128];\n        snprintf(filename,sizeof(filename),\"/proc/%ld/smaps\",pid);\n        fp = fopen(filename,\"r\");\n    }\n\n    if (!fp) return 0;\n    while(fgets(line,sizeof(line),fp) != NULL) {\n        if (strncmp(line,field,flen) == 0) {\n            char *p = strchr(line,'k');\n            if (p) {\n                *p = '\\0';\n                bytes += strtol(line+flen,NULL,10) * 1024;\n            }\n        }\n    }\n    fclose(fp);\n    return bytes;\n}\n#else\n/* Get sum of the specified field from libproc api call.\n * As there are per page value basis we need to convert\n * them accordingly.\n *\n * Note that AnonHugePages is a no-op as THP feature\n * is not supported in this platform\n */\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\n#if defined(__APPLE__)\n    struct proc_regioninfo pri;\n    if (proc_pidinfo(pid, PROC_PIDREGIONINFO, 0, &pri, PROC_PIDREGIONINFO_SIZE) ==\n\tPROC_PIDREGIONINFO_SIZE) {\n\tif (!strcmp(field, \"Private_Dirty:\")) {\n            return (size_t)pri.pri_pages_dirtied * 4096;\n\t} else if (!strcmp(field, \"Rss:\")) {\n            return (size_t)pri.pri_pages_resident * 4096;\n\t} else if (!strcmp(field, \"AnonHugePages:\")) {\n            return 0;\n\t}\n    }\n    return 0;\n#endif\n    ((void) field);\n    ((void) pid);\n    return 0;\n}\n#endif\n\nsize_t zmalloc_get_private_dirty(long pid) {\n    return zmalloc_get_smap_bytes_by_field(\"Private_Dirty:\",pid);\n}\n\n/* Returns the size of physical memory (RAM) in bytes.\n * It looks ugly, but this is the cleanest way to achieve cross platform results.\n * Cleaned up from:\n *\n * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system\n *\n * Note that this function:\n * 1) Was released under the following CC attribution license:\n *    http://creativecommons.org/licenses/by/3.0/deed.en_US.\n * 2) Was originally implemented by David Robert Nadeau.\n * 3) Was modified for Redis by Matt Stancliff.\n * 4) This note exists in order to comply with the original license.\n */\nsize_t zmalloc_get_memory_size(void) {\n#if defined(__unix__) || defined(__unix) || defined(unix) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))\n    int mib[2];\n    mib[0] = CTL_HW;\n#if defined(HW_MEMSIZE)\n    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */\n#elif defined(HW_PHYSMEM64)\n    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */\n#endif\n    int64_t size = 0;               /* 64-bit */\n    size_t len = sizeof(size);\n    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)\n        return (size_t)size;\n    return 0L;          /* Failed? */\n\n#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)\n    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */\n    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);\n\n#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))\n    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */\n    int mib[2];\n    mib[0] = CTL_HW;\n#if defined(HW_REALMEM)\n    mib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */\n#elif defined(HW_PHYSMEM)\n    mib[1] = HW_PHYSMEM;        /* Others. ------------------ */\n#endif\n    unsigned int size = 0;      /* 32-bit */\n    size_t len = sizeof(size);\n    if (sysctl(mib, 2, &size, &len, NULL, 0) == 0)\n        return (size_t)size;\n    return 0L;          /* Failed? */\n#else\n    return 0L;          /* Unknown method to get the data. */\n#endif\n#else\n    return 0L;          /* Unknown OS. */\n#endif\n}\n\n#ifdef REDIS_TEST\n#define UNUSED(x) ((void)(x))\nint zmalloc_test(int argc, char **argv) {\n    void *ptr;\n\n    UNUSED(argc);\n    UNUSED(argv);\n    printf(\"Initial used memory: %zu\\n\", zmalloc_used_memory());\n    ptr = zmalloc(123);\n    printf(\"Allocated 123 bytes; used: %zu\\n\", zmalloc_used_memory());\n    ptr = zrealloc(ptr, 456);\n    printf(\"Reallocated to 456 bytes; used: %zu\\n\", zmalloc_used_memory());\n    zfree(ptr);\n    printf(\"Freed pointer; used: %zu\\n\", zmalloc_used_memory());\n    return 0;\n}\n#endif\n"], "filenames": ["src/config.c", "src/sds.c", "src/zmalloc.c"], "buggy_code_start_loc": [2377, 98, 56], "buggy_code_end_loc": [2378, 229, 144], "fixing_code_start_loc": [2377, 99, 57], "fixing_code_end_loc": [2378, 233, 155], "type": "CWE-190", "message": "Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the \u201cCONFIG SET proto-max-bulk-len\u201d to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways.", "other": {"cve": {"id": "CVE-2021-21309", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-26T22:15:19.457", "lastModified": "2022-10-19T13:21:42.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the \u201cCONFIG SET proto-max-bulk-len\u201d to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways."}, {"lang": "es", "value": "Redis es una base de datos en memoria de c\u00f3digo abierto que persiste en el disco.&#xa0;En las versiones afectadas de Redis, un error de desbordamiento de enteros en Redis de 32 bits versi\u00f3n 4.0 o m\u00e1s reciente podr\u00eda ser explotada para corromper la pila y potencialmente resultar en una ejecuci\u00f3n de c\u00f3digo remota.&#xa0;Redis versiones 4.0 o posteriores, usa un l\u00edmite configurable para el tama\u00f1o m\u00e1ximo de la entrada masiva admitida.&#xa0;Por defecto, es de 512 MB, que es un valor seguro para todas las plataformas.&#xa0;Si el l\u00edmite aumenta significativamente, recibir una petici\u00f3n grande de un cliente puede desencadenar varios escenarios de desbordamiento de enteros, que podr\u00eda resultar en un desbordamiento del b\u00fafer y una corrupci\u00f3n de la pila.&#xa0;Creemos que, en determinadas condiciones, esta podr\u00eda ser explotada para una ejecuci\u00f3n de c\u00f3digo remota.&#xa0;Por defecto,  usuarios de Redis autenticados poseen acceso a todos los par\u00e1metros de configuraci\u00f3n y, por lo tanto, pueden usar \"CONFIG SET proto-max-bulk-len\" para cambiar el valor predeterminado seguro,&#xa0;haciendo que el sistema sea vulnerable.** Este problema solo afecta a Redis de 32 bits (en un sistema de 32 bits o como un ejecutable de 32 bits que se ejecuta en un sistema de 64 bits). ** El problema se corrigi\u00f3 en la versi\u00f3n 6.2 y la soluci\u00f3n se ha modificado a versiones  6.0.11 y 5.0.11.&#xa0;Aseg\u00farese de usar una de estas versiones si est\u00e1 ejecutando Redis de 32 bits.&#xa0;Una soluci\u00f3n alternativa para mitigar el problema sin parchear el ejecutable de redis-server es impedir que los clientes ejecuten directamente `CONFIG SET`: Con Redis versiones 6.0 o m\u00e1s recientes, la configuraci\u00f3n de ACL puede ser usada para bloquear el comando.&#xa0;Utilizando versiones anteriores, la directiva de configuraci\u00f3n \"rename-command\" puede ser usada para cambiar el nombre del comando a una cadena aleatoria desconocida para usuarios, haci\u00e9ndolo inaccesible.&#xa0;Tome en cuenta que esta soluci\u00f3n puede tener un impacto adicional en los usuarios o los sistemas operativos que esperan que \"CONFIG SET\" se comporte de determinadas formas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "5.0.11", "matchCriteriaId": "366C8910-66E7-4AB6-873C-70595AD42ADA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.11", "matchCriteriaId": "C345BCBB-EB73-4DA5-93F0-42AB9E903CE5"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/pull/8522", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-hgj8-vff2-7cjf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202103-02", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0"}}