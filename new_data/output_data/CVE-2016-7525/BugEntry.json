{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  short int\n    type;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[256],\n    visible;\n\n  unsigned short\n    channels;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(CompositeOperator op)\n{\n  const char\n    *blend_mode;\n\n  switch (op)\n  {\n    case ColorBurnCompositeOp:  blend_mode = \"idiv\";  break;\n    case ColorDodgeCompositeOp: blend_mode = \"div \";  break;\n    case ColorizeCompositeOp:   blend_mode = \"colr\";  break;\n    case DarkenCompositeOp:     blend_mode = \"dark\";  break;\n    case DifferenceCompositeOp: blend_mode = \"diff\";  break;\n    case DissolveCompositeOp:   blend_mode = \"diss\";  break;\n    case ExclusionCompositeOp:  blend_mode = \"smud\";  break;\n    case HardLightCompositeOp:  blend_mode = \"hLit\";  break;\n    case HardMixCompositeOp:    blend_mode = \"hMix\";  break;\n    case HueCompositeOp:        blend_mode = \"hue \";  break;\n    case LightenCompositeOp:    blend_mode = \"lite\";  break;\n    case LinearBurnCompositeOp: blend_mode = \"lbrn\";  break;\n    case LinearDodgeCompositeOp:blend_mode = \"lddg\";  break;\n    case LinearLightCompositeOp:blend_mode = \"lLit\";  break;\n    case LuminizeCompositeOp:   blend_mode = \"lum \";  break;\n    case MultiplyCompositeOp:   blend_mode = \"mul \";  break;\n    case OverCompositeOp:       blend_mode = \"norm\";  break;\n    case OverlayCompositeOp:    blend_mode = \"over\";  break;\n    case PinLightCompositeOp:   blend_mode = \"pLit\";  break;\n    case SaturateCompositeOp:   blend_mode = \"sat \";  break;\n    case ScreenCompositeOp:     blend_mode = \"scrn\";  break;\n    case SoftLightCompositeOp:  blend_mode = \"sLit\";  break;\n    case VividLightCompositeOp: blend_mode = \"vLit\";  break;\n    default:                    blend_mode = \"norm\";\n  }\n  return(blend_mode);\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait != BlendPixelTrait || image->colorspace != sRGBColorspace)\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n    {\n      status=MagickFalse;\n      continue;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      register ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType CorrectPSDOpacity(LayerInfo *layer_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (layer_info->opacity == OpaqueAlpha)\n    return(MagickTrue);\n\n  layer_info->image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(layer_info->image,layer_info->image,layer_info->image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) layer_info->image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(layer_info->image,0,y,layer_info->image->columns,1,\n      exception);\n    if (q == (Quantum *)NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) layer_info->image->columns; x++)\n    {\n      SetPixelAlpha(layer_info->image,(Quantum) (QuantumScale*(GetPixelAlpha(\n        layer_info->image,q))*layer_info->opacity),q);\n      q+=GetPixelChannels(layer_info->image);\n    }\n    if (SyncAuthenticPixels(layer_info->image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n      else if (image->depth > 8)\n        return(2);\n    }\n  else\n    if (image->depth > 8)\n      return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic void ParseImageResourceBlocks(Image *image,\n  const unsigned char *blocks,size_t length,\n  MagickBooleanType *has_merged_image,ExceptionInfo *exception)\n{\n  const unsigned char\n    *p;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return;\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  (void) SetImageProfile(image,\"8bim\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-16)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (p+count > blocks+length)\n      return;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        char\n          value[MagickPathExtent];\n\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.x);\n        (void) SetImageProperty(image,\"tiff:XResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.y);\n        (void) SetImageProperty(image,\"tiff:YResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if (*(p+4) == 0)\n          *has_merged_image=MagickFalse;\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n  return;\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline void ReversePSDString(Image *image,char *p,size_t length)\n{\n  char\n    *q;\n\n  if (image->endian == MSBEndian)\n    return;\n\n  q=p+length;\n  for(--q; p < q; ++p, --q)\n  {\n    *p = *p ^ *q,\n    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n      \n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    count,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLEOffsets(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *offsets;\n\n  ssize_t\n    y;\n\n  offsets=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*offsets));\n  if(offsets != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          offsets[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          offsets[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return offsets;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *offsets,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < offsets[y])\n      length=(size_t) offsets[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) offsets[y],compact_pixels);\n    if (count != (ssize_t) offsets[y])\n      break;\n\n    count=DecodePSDPixels((size_t) offsets[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream, 0, sizeof(z_stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(unsigned int) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(unsigned int) count;\n\n  if(inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream, Z_SYNC_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END)\n        {\n          compact_pixels=(unsigned char *) RelinquishMagickMemory(\n            compact_pixels);\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          return(MagickFalse);\n        }\n      }\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while(count > 0)\n     {\n       length=image->columns;\n       while(--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,const PSDInfo *psd_info,\n  LayerInfo* layer_info,const size_t channel,\n  const PSDCompressionType compression,ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n  {\n    /*\n      Ignore mask that is not a user supplied layer mask, if the mask is\n      disabled or if the flags have unsupported values.\n    */\n    if (layer_info->channel_info[channel].type != -2 ||\n        (layer_info->mask.flags > 3) || (layer_info->mask.flags & 0x02))\n    {\n      SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n      return(MagickTrue);\n    }\n    mask=CloneImage(image,layer_info->mask.page.width,\n      layer_info->mask.page.height,MagickFalse,exception);\n    SetImageType(mask,GrayscaleType,exception);\n    channel_image=mask;\n  }\n\n  offset=TellBlob(channel_image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *offsets;\n\n        offsets=ReadPSDRLEOffsets(channel_image,psd_info,channel_image->rows);\n        if (offsets == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,offsets,exception);\n        offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n  {\n    if (status != MagickFalse)\n      {\n        PixelInfo\n          color;\n\n        layer_info->mask.image=CloneImage(image,image->columns,image->rows,\n          MagickTrue,exception);\n        layer_info->mask.image->alpha_trait=UndefinedPixelTrait;\n        GetPixelInfo(layer_info->mask.image,&color);\n        color.red=layer_info->mask.background == 0 ? 0 : QuantumRange;\n        SetImageColor(layer_info->mask.image,&color,exception);\n        (void) CompositeImage(layer_info->mask.image,mask,OverCompositeOp,\n          MagickTrue,layer_info->mask.page.x,layer_info->mask.page.y,\n          exception);\n      }\n    DestroyImage(mask);\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const PSDInfo *psd_info,\n  LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  if (psd_info->mode == CMYKMode)\n    SetImageColorspace(layer_info->image,CMYKColorspace,exception);\n  if ((psd_info->mode == BitmapMode) || (psd_info->mode == GrayscaleMode) ||\n      (psd_info->mode == DuotoneMode))\n    SetImageColorspace(layer_info->image,GRAYColorspace,exception);\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,psd_info,layer_info,j,\n      compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=CorrectPSDOpacity(layer_info,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      status=CompositeImage(layer_info->image,layer_info->mask.image,\n        CopyAlphaCompositeOp,MagickTrue,0,0,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=(int) ReadBlobLong(image);\n        layer_info[i].page.x=(int) ReadBlobLong(image);\n        y=(int) ReadBlobLong(image);\n        x=(int) ReadBlobLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.x=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double) \n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) (length); j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(size_t) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            /*\n               Skip the rest of the variable data until we support it.\n             */\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      unsupported data: length=%.20g\",(double)\n                 ((MagickOffsetType) (size-combined_length)));\n             if (DiscardBlobBytes(image,(MagickSizeType) (size-combined_length)) == MagickFalse)\n               {\n                 layer_info=DestroyLayerInfo(layer_info,number_layers);\n                 ThrowBinaryException(CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n               }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,psd_info,&layer_info[i],exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n      {\n        for (i=0; i < number_layers; i++)\n        {\n          if (layer_info[i].image == (Image *) NULL)\n          {\n            for (j=i; j < number_layers - 1; j++)\n              layer_info[j] = layer_info[j+1];\n            number_layers--;\n            i--;\n          }\n        }\n\n        if (number_layers > 0)\n          {\n            for (i=0; i < number_layers; i++)\n            {\n              if (i > 0)\n                layer_info[i].image->previous=layer_info[i-1].image;\n              if (i < (number_layers-1))\n                layer_info[i].image->next=layer_info[i+1].image;\n              layer_info[i].image->page=layer_info[i].page;\n            }\n            image->next=layer_info[0].image;\n            layer_info[0].image->previous=image;\n          }\n        layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n      }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *offsets;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  register ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  offsets=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n  {\n    offsets=ReadPSDRLEOffsets(image,psd_info,image->rows*psd_info->channels);\n    if (offsets == (MagickOffsetType *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n  }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,offsets+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  if (offsets != (MagickOffsetType *) NULL)\n    offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned short) offset));\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBLong(image,(unsigned int) size));\n  return(WriteBlobMSBLongLong(image,size));\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  size_t\n    length,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n      exception);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}\n\nstatic void WriteOneChannel(const PSDInfo *psd_info,const ImageInfo *image_info,\n  Image *image,Image *next_image,unsigned char *compact_pixels,\n  const QuantumType quantum_type,const MagickBooleanType compression_flag,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    packet_size;\n\n  unsigned char\n    *pixels;\n\n  (void) psd_info;\n  if ((compression_flag != MagickFalse) &&\n      (next_image->compression != RLECompression))\n    (void) WriteBlobMSBShort(image,0);\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression != RLECompression)\n      (void) WriteBlob(image,length,pixels);\n    else\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        (void) WriteBlob(image,length,compact_pixels);\n      }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}\n\nstatic MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const MagickBooleanType separate,ExceptionInfo *exception)\n{\n  size_t\n    channels,\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  /*\n    Write uncompressed pixels as separate planes.\n  */\n  channels=1;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*\n        next_image->columns)+1,packet_size*sizeof(*compact_pixels));\n      if (compact_pixels == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (IsImageGray(next_image) != MagickFalse)\n    {\n      if (next_image->compression == RLECompression)\n        {\n          /*\n            Packbits compression.\n          */\n          (void) WriteBlobMSBShort(image,1);\n          WritePackbitsLength(psd_info,image_info,image,next_image,\n            compact_pixels,GrayQuantum,exception);\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,AlphaQuantum,exception);\n        }\n      WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n        GrayQuantum,MagickTrue,exception);\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          AlphaQuantum,separate,exception);\n      (void) SetImageProgress(image,SaveImagesTag,0,1);\n    }\n  else\n    if (next_image->storage_class == PseudoClass)\n      {\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,IndexQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          IndexQuantum,MagickTrue,exception);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,0,1);\n      }\n    else\n      {\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,RedQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,GreenQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,BlueQuantum,exception);\n            if (next_image->colorspace == CMYKColorspace)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,BlackQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        (void) SetImageProgress(image,SaveImagesTag,0,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          RedQuantum,MagickTrue,exception);\n        (void) SetImageProgress(image,SaveImagesTag,1,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          GreenQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,2,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          BlueQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,3,6);\n        if (next_image->colorspace == CMYKColorspace)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            BlackQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,4,6);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,5,6);\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n      }\n  if (next_image->compression == RLECompression)\n    compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  return(MagickTrue);\n}\n\nstatic void WritePascalString(Image* inImage,const char *inString,int inPad)\n{\n  size_t\n    length;\n\n  register ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  length=(strlen(inString) > 255UL ) ? 255UL : strlen(inString);\n  if (length ==  0)\n    (void) WriteBlobByte(inImage,0);\n  else\n    {\n      (void) WriteBlobByte(inImage,(unsigned char) length);\n      (void) WriteBlob(inImage, length, (const unsigned char *) inString);\n    }\n  length++;\n  if ((length % inPad) == 0)\n    return;\n  for (i=0; i < (ssize_t) (inPad-(length % inPad)); i++)\n    (void) WriteBlobByte(inImage,0);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *property;\n\n  const StringInfo\n    *icc_profile;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    channel_size,\n    channelLength,\n    layer_count,\n    layer_info_size,\n    length,\n    num_channels,\n    packet_size,\n    rounded_layer_info_size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  layer_count=0;\n  layer_info_size=2;\n  base_image=GetNextImageInList(image);\n  if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))\n    base_image=image;\n  next_image=base_image;\n  while ( next_image != NULL )\n  {\n    packet_size=next_image->depth > 8 ? 2UL : 1UL;\n    if (IsImageGray(next_image) != MagickFalse)\n      num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n    else\n      if (next_image->storage_class == PseudoClass)\n        num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n      else\n        if (next_image->colorspace != CMYKColorspace)\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;\n        else\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;\n    channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);\n    layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :\n      16)+4*1+4+num_channels*channelLength);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      layer_info_size+=16;\n    else\n      {\n        size_t\n          layer_length;\n\n        layer_length=strlen(property);\n        layer_info_size+=8+layer_length+(4-(layer_length % 4));\n      }\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (layer_count == 0)\n    (void) SetPSDSize(&psd_info,image,0);\n  else\n    {\n      CompressionType\n        compression;\n\n      (void) SetPSDSize(&psd_info,image,layer_info_size+\n        (psd_info.version == 1 ? 8 : 16));\n      if ((layer_info_size/2) != ((layer_info_size+1)/2))\n        rounded_layer_info_size=layer_info_size+1;\n      else\n        rounded_layer_info_size=layer_info_size;\n      (void) SetPSDSize(&psd_info,image,rounded_layer_info_size);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) WriteBlobMSBShort(image,-(unsigned short) layer_count);\n      else\n        (void) WriteBlobMSBShort(image,(unsigned short) layer_count);\n      layer_count=1;\n      compression=base_image->compression;\n      for (next_image=base_image; next_image != NULL; )\n      {\n        next_image->compression=NoCompression;\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n          next_image->rows));\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n          next_image->columns));\n        packet_size=next_image->depth > 8 ? 2UL : 1UL;\n        channel_size=(unsigned int) ((packet_size*next_image->rows*\n          next_image->columns)+2);\n        if ((IsImageGray(next_image) != MagickFalse) ||\n            (next_image->storage_class == PseudoClass))\n          {\n             (void) WriteBlobMSBShort(image,(unsigned short)\n               (next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));\n             (void) WriteBlobMSBShort(image,0);\n             (void) SetPSDSize(&psd_info,image,channel_size);\n             if (next_image->alpha_trait != UndefinedPixelTrait)\n               {\n                 (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                 (void) SetPSDSize(&psd_info,image,channel_size);\n               }\n           }\n          else\n            if (next_image->colorspace != CMYKColorspace)\n              {\n                (void) WriteBlobMSBShort(image,(unsigned short)\n                  (next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait != UndefinedPixelTrait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n           else\n             {\n               (void) WriteBlobMSBShort(image,(unsigned short)\n                 (next_image->alpha_trait ? 5 : 4));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,3);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n        (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n        (void) WriteBlob(image,4,(const unsigned char *)\n          CompositeOperatorToPSDBlendMode(next_image->compose));\n        (void) WriteBlobByte(image,255); /* layer opacity */\n        (void) WriteBlobByte(image,0);\n        (void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n          1 << 0x02 : 1); /* layer properties - visible, etc. */\n        (void) WriteBlobByte(image,0);\n        property=(const char *) GetImageProperty(next_image,\"label\",exception);\n        if (property == (const char *) NULL)\n          {\n            char\n              layer_name[MagickPathExtent];\n\n            (void) WriteBlobMSBLong(image,16);\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%04ld\",(long)\n              layer_count++);\n            WritePascalString(image,layer_name,4);\n          }\n        else\n          {\n            size_t\n              label_length;\n\n            label_length=strlen(property);\n            (void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-\n              (label_length % 4))+8));\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            WritePascalString(image,property,4);\n          }\n        next_image=GetNextImageInList(next_image);\n      }\n      /*\n        Now the image data!\n      */\n      next_image=base_image;\n      while (next_image != NULL)\n      {\n        status=WriteImageChannels(&psd_info,image_info,image,next_image,\n          MagickTrue,exception);\n        next_image=GetNextImageInList(next_image);\n      }\n      (void) WriteBlobMSBLong(image,0);  /* user mask data */\n      base_image->compression=compression;\n    }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,\n      exception);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  short int\n    type;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[256],\n    visible;\n\n  unsigned short\n    channels;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(CompositeOperator op)\n{\n  const char\n    *blend_mode;\n\n  switch (op)\n  {\n    case ColorBurnCompositeOp:  blend_mode = \"idiv\";  break;\n    case ColorDodgeCompositeOp: blend_mode = \"div \";  break;\n    case ColorizeCompositeOp:   blend_mode = \"colr\";  break;\n    case DarkenCompositeOp:     blend_mode = \"dark\";  break;\n    case DifferenceCompositeOp: blend_mode = \"diff\";  break;\n    case DissolveCompositeOp:   blend_mode = \"diss\";  break;\n    case ExclusionCompositeOp:  blend_mode = \"smud\";  break;\n    case HardLightCompositeOp:  blend_mode = \"hLit\";  break;\n    case HardMixCompositeOp:    blend_mode = \"hMix\";  break;\n    case HueCompositeOp:        blend_mode = \"hue \";  break;\n    case LightenCompositeOp:    blend_mode = \"lite\";  break;\n    case LinearBurnCompositeOp: blend_mode = \"lbrn\";  break;\n    case LinearDodgeCompositeOp:blend_mode = \"lddg\";  break;\n    case LinearLightCompositeOp:blend_mode = \"lLit\";  break;\n    case LuminizeCompositeOp:   blend_mode = \"lum \";  break;\n    case MultiplyCompositeOp:   blend_mode = \"mul \";  break;\n    case OverCompositeOp:       blend_mode = \"norm\";  break;\n    case OverlayCompositeOp:    blend_mode = \"over\";  break;\n    case PinLightCompositeOp:   blend_mode = \"pLit\";  break;\n    case SaturateCompositeOp:   blend_mode = \"sat \";  break;\n    case ScreenCompositeOp:     blend_mode = \"scrn\";  break;\n    case SoftLightCompositeOp:  blend_mode = \"sLit\";  break;\n    case VividLightCompositeOp: blend_mode = \"vLit\";  break;\n    default:                    blend_mode = \"norm\";\n  }\n  return(blend_mode);\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait != BlendPixelTrait || image->colorspace != sRGBColorspace)\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n    {\n      status=MagickFalse;\n      continue;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      register ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType CorrectPSDOpacity(LayerInfo *layer_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (layer_info->opacity == OpaqueAlpha)\n    return(MagickTrue);\n\n  layer_info->image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(layer_info->image,layer_info->image,layer_info->image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) layer_info->image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(layer_info->image,0,y,layer_info->image->columns,1,\n      exception);\n    if (q == (Quantum *)NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) layer_info->image->columns; x++)\n    {\n      SetPixelAlpha(layer_info->image,(Quantum) (QuantumScale*(GetPixelAlpha(\n        layer_info->image,q))*layer_info->opacity),q);\n      q+=GetPixelChannels(layer_info->image);\n    }\n    if (SyncAuthenticPixels(layer_info->image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n      else if (image->depth > 8)\n        return(2);\n    }\n  else\n    if (image->depth > 8)\n      return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic void ParseImageResourceBlocks(Image *image,\n  const unsigned char *blocks,size_t length,\n  MagickBooleanType *has_merged_image,ExceptionInfo *exception)\n{\n  const unsigned char\n    *p;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return;\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  (void) SetImageProfile(image,\"8bim\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-16)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (p+count > blocks+length)\n      return;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        char\n          value[MagickPathExtent];\n\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.x);\n        (void) SetImageProperty(image,\"tiff:XResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.y);\n        (void) SetImageProperty(image,\"tiff:YResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if (*(p+4) == 0)\n          *has_merged_image=MagickFalse;\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n  return;\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline void ReversePSDString(Image *image,char *p,size_t length)\n{\n  char\n    *q;\n\n  if (image->endian == MSBEndian)\n    return;\n\n  q=p+length;\n  for(--q; p < q; ++p, --q)\n  {\n    *p = *p ^ *q,\n    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n      \n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    count,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLEOffsets(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *offsets;\n\n  ssize_t\n    y;\n\n  offsets=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*offsets));\n  if(offsets != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          offsets[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          offsets[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return offsets;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *offsets,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < offsets[y])\n      length=(size_t) offsets[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) offsets[y],compact_pixels);\n    if (count != (ssize_t) offsets[y])\n      break;\n\n    count=DecodePSDPixels((size_t) offsets[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream, 0, sizeof(z_stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(unsigned int) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(unsigned int) count;\n\n  if(inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream, Z_SYNC_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END)\n        {\n          compact_pixels=(unsigned char *) RelinquishMagickMemory(\n            compact_pixels);\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          return(MagickFalse);\n        }\n      }\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while(count > 0)\n     {\n       length=image->columns;\n       while(--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,const PSDInfo *psd_info,\n  LayerInfo* layer_info,const size_t channel,\n  const PSDCompressionType compression,ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n  {\n    /*\n      Ignore mask that is not a user supplied layer mask, if the mask is\n      disabled or if the flags have unsupported values.\n    */\n    if (layer_info->channel_info[channel].type != -2 ||\n        (layer_info->mask.flags > 3) || (layer_info->mask.flags & 0x02))\n    {\n      SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n      return(MagickTrue);\n    }\n    mask=CloneImage(image,layer_info->mask.page.width,\n      layer_info->mask.page.height,MagickFalse,exception);\n    SetImageType(mask,GrayscaleType,exception);\n    channel_image=mask;\n  }\n\n  offset=TellBlob(channel_image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *offsets;\n\n        offsets=ReadPSDRLEOffsets(channel_image,psd_info,channel_image->rows);\n        if (offsets == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,offsets,exception);\n        offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n  {\n    if (status != MagickFalse)\n      {\n        PixelInfo\n          color;\n\n        layer_info->mask.image=CloneImage(image,image->columns,image->rows,\n          MagickTrue,exception);\n        layer_info->mask.image->alpha_trait=UndefinedPixelTrait;\n        GetPixelInfo(layer_info->mask.image,&color);\n        color.red=layer_info->mask.background == 0 ? 0 : QuantumRange;\n        SetImageColor(layer_info->mask.image,&color,exception);\n        (void) CompositeImage(layer_info->mask.image,mask,OverCompositeOp,\n          MagickTrue,layer_info->mask.page.x,layer_info->mask.page.y,\n          exception);\n      }\n    DestroyImage(mask);\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const PSDInfo *psd_info,\n  LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  if (psd_info->mode == CMYKMode)\n    SetImageColorspace(layer_info->image,CMYKColorspace,exception);\n  if ((psd_info->mode == BitmapMode) || (psd_info->mode == GrayscaleMode) ||\n      (psd_info->mode == DuotoneMode))\n    SetImageColorspace(layer_info->image,GRAYColorspace,exception);\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,psd_info,layer_info,j,\n      compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=CorrectPSDOpacity(layer_info,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      status=CompositeImage(layer_info->image,layer_info->mask.image,\n        CopyAlphaCompositeOp,MagickTrue,0,0,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=(int) ReadBlobLong(image);\n        layer_info[i].page.x=(int) ReadBlobLong(image);\n        y=(int) ReadBlobLong(image);\n        x=(int) ReadBlobLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.x=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double) \n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) (length); j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(size_t) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            /*\n               Skip the rest of the variable data until we support it.\n             */\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      unsupported data: length=%.20g\",(double)\n                 ((MagickOffsetType) (size-combined_length)));\n             if (DiscardBlobBytes(image,(MagickSizeType) (size-combined_length)) == MagickFalse)\n               {\n                 layer_info=DestroyLayerInfo(layer_info,number_layers);\n                 ThrowBinaryException(CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n               }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,psd_info,&layer_info[i],exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n      {\n        for (i=0; i < number_layers; i++)\n        {\n          if (layer_info[i].image == (Image *) NULL)\n          {\n            for (j=i; j < number_layers - 1; j++)\n              layer_info[j] = layer_info[j+1];\n            number_layers--;\n            i--;\n          }\n        }\n\n        if (number_layers > 0)\n          {\n            for (i=0; i < number_layers; i++)\n            {\n              if (i > 0)\n                layer_info[i].image->previous=layer_info[i-1].image;\n              if (i < (number_layers-1))\n                layer_info[i].image->next=layer_info[i+1].image;\n              layer_info[i].image->page=layer_info[i].page;\n            }\n            image->next=layer_info[0].image;\n            layer_info[0].image->previous=image;\n          }\n        layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n      }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *offsets;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  register ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  offsets=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n  {\n    offsets=ReadPSDRLEOffsets(image,psd_info,image->rows*psd_info->channels);\n    if (offsets == (MagickOffsetType *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n  }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,offsets+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  if (offsets != (MagickOffsetType *) NULL)\n    offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned short) offset));\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBLong(image,(unsigned int) size));\n  return(WriteBlobMSBLongLong(image,size));\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  size_t\n    length,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n      exception);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}\n\nstatic void WriteOneChannel(const PSDInfo *psd_info,const ImageInfo *image_info,\n  Image *image,Image *next_image,unsigned char *compact_pixels,\n  const QuantumType quantum_type,const MagickBooleanType compression_flag,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    packet_size;\n\n  unsigned char\n    *pixels;\n\n  (void) psd_info;\n  if ((compression_flag != MagickFalse) &&\n      (next_image->compression != RLECompression))\n    (void) WriteBlobMSBShort(image,0);\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression != RLECompression)\n      (void) WriteBlob(image,length,pixels);\n    else\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        (void) WriteBlob(image,length,compact_pixels);\n      }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}\n\nstatic MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const MagickBooleanType separate,ExceptionInfo *exception)\n{\n  size_t\n    channels,\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  /*\n    Write uncompressed pixels as separate planes.\n  */\n  channels=1;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*\n        next_image->columns)+1,packet_size*sizeof(*compact_pixels));\n      if (compact_pixels == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (IsImageGray(next_image) != MagickFalse)\n    {\n      if (next_image->compression == RLECompression)\n        {\n          /*\n            Packbits compression.\n          */\n          (void) WriteBlobMSBShort(image,1);\n          WritePackbitsLength(psd_info,image_info,image,next_image,\n            compact_pixels,GrayQuantum,exception);\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,AlphaQuantum,exception);\n        }\n      WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n        GrayQuantum,MagickTrue,exception);\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          AlphaQuantum,separate,exception);\n      (void) SetImageProgress(image,SaveImagesTag,0,1);\n    }\n  else\n    if (next_image->storage_class == PseudoClass)\n      {\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,IndexQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          IndexQuantum,MagickTrue,exception);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,0,1);\n      }\n    else\n      {\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,RedQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,GreenQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,BlueQuantum,exception);\n            if (next_image->colorspace == CMYKColorspace)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,BlackQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        (void) SetImageProgress(image,SaveImagesTag,0,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          RedQuantum,MagickTrue,exception);\n        (void) SetImageProgress(image,SaveImagesTag,1,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          GreenQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,2,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          BlueQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,3,6);\n        if (next_image->colorspace == CMYKColorspace)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            BlackQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,4,6);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,5,6);\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n      }\n  if (next_image->compression == RLECompression)\n    compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  return(MagickTrue);\n}\n\nstatic void WritePascalString(Image* inImage,const char *inString,int inPad)\n{\n  size_t\n    length;\n\n  register ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  length=(strlen(inString) > 255UL ) ? 255UL : strlen(inString);\n  if (length ==  0)\n    (void) WriteBlobByte(inImage,0);\n  else\n    {\n      (void) WriteBlobByte(inImage,(unsigned char) length);\n      (void) WriteBlob(inImage, length, (const unsigned char *) inString);\n    }\n  length++;\n  if ((length % inPad) == 0)\n    return;\n  for (i=0; i < (ssize_t) (inPad-(length % inPad)); i++)\n    (void) WriteBlobByte(inImage,0);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *property;\n\n  const StringInfo\n    *icc_profile;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    channel_size,\n    channelLength,\n    layer_count,\n    layer_info_size,\n    length,\n    num_channels,\n    packet_size,\n    rounded_layer_info_size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  layer_count=0;\n  layer_info_size=2;\n  base_image=GetNextImageInList(image);\n  if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))\n    base_image=image;\n  next_image=base_image;\n  while ( next_image != NULL )\n  {\n    packet_size=next_image->depth > 8 ? 2UL : 1UL;\n    if (IsImageGray(next_image) != MagickFalse)\n      num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n    else\n      if (next_image->storage_class == PseudoClass)\n        num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n      else\n        if (next_image->colorspace != CMYKColorspace)\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;\n        else\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;\n    channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);\n    layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :\n      16)+4*1+4+num_channels*channelLength);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      layer_info_size+=16;\n    else\n      {\n        size_t\n          layer_length;\n\n        layer_length=strlen(property);\n        layer_info_size+=8+layer_length+(4-(layer_length % 4));\n      }\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (layer_count == 0)\n    (void) SetPSDSize(&psd_info,image,0);\n  else\n    {\n      CompressionType\n        compression;\n\n      (void) SetPSDSize(&psd_info,image,layer_info_size+\n        (psd_info.version == 1 ? 8 : 16));\n      if ((layer_info_size/2) != ((layer_info_size+1)/2))\n        rounded_layer_info_size=layer_info_size+1;\n      else\n        rounded_layer_info_size=layer_info_size;\n      (void) SetPSDSize(&psd_info,image,rounded_layer_info_size);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) WriteBlobMSBShort(image,-(unsigned short) layer_count);\n      else\n        (void) WriteBlobMSBShort(image,(unsigned short) layer_count);\n      layer_count=1;\n      compression=base_image->compression;\n      for (next_image=base_image; next_image != NULL; )\n      {\n        next_image->compression=NoCompression;\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n          next_image->rows));\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n          next_image->columns));\n        packet_size=next_image->depth > 8 ? 2UL : 1UL;\n        channel_size=(unsigned int) ((packet_size*next_image->rows*\n          next_image->columns)+2);\n        if ((IsImageGray(next_image) != MagickFalse) ||\n            (next_image->storage_class == PseudoClass))\n          {\n             (void) WriteBlobMSBShort(image,(unsigned short)\n               (next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));\n             (void) WriteBlobMSBShort(image,0);\n             (void) SetPSDSize(&psd_info,image,channel_size);\n             if (next_image->alpha_trait != UndefinedPixelTrait)\n               {\n                 (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                 (void) SetPSDSize(&psd_info,image,channel_size);\n               }\n           }\n          else\n            if (next_image->colorspace != CMYKColorspace)\n              {\n                (void) WriteBlobMSBShort(image,(unsigned short)\n                  (next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait != UndefinedPixelTrait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n           else\n             {\n               (void) WriteBlobMSBShort(image,(unsigned short)\n                 (next_image->alpha_trait ? 5 : 4));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,3);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n        (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n        (void) WriteBlob(image,4,(const unsigned char *)\n          CompositeOperatorToPSDBlendMode(next_image->compose));\n        (void) WriteBlobByte(image,255); /* layer opacity */\n        (void) WriteBlobByte(image,0);\n        (void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n          1 << 0x02 : 1); /* layer properties - visible, etc. */\n        (void) WriteBlobByte(image,0);\n        property=(const char *) GetImageProperty(next_image,\"label\",exception);\n        if (property == (const char *) NULL)\n          {\n            char\n              layer_name[MagickPathExtent];\n\n            (void) WriteBlobMSBLong(image,16);\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%04ld\",(long)\n              layer_count++);\n            WritePascalString(image,layer_name,4);\n          }\n        else\n          {\n            size_t\n              label_length;\n\n            label_length=strlen(property);\n            (void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-\n              (label_length % 4))+8));\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            WritePascalString(image,property,4);\n          }\n        next_image=GetNextImageInList(next_image);\n      }\n      /*\n        Now the image data!\n      */\n      next_image=base_image;\n      while (next_image != NULL)\n      {\n        status=WriteImageChannels(&psd_info,image_info,image,next_image,\n          MagickTrue,exception);\n        next_image=GetNextImageInList(next_image);\n      }\n      (void) WriteBlobMSBLong(image,0);  /* user mask data */\n      base_image->compression=compression;\n    }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,\n      exception);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/psd.c"], "buggy_code_start_loc": [583], "buggy_code_end_loc": [584], "fixing_code_start_loc": [583], "fixing_code_end_loc": [584], "type": "CWE-125", "message": "Heap-based buffer overflow in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.", "other": {"cve": {"id": "CVE-2016-7525", "sourceIdentifier": "security@debian.org", "published": "2017-04-20T18:59:01.140", "lastModified": "2017-05-09T12:39:38.103", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en coders/psd.c en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de un archivo PSD manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E6BE7A5-6FF7-4916-B671-9EE11CA54F65"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93131", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1537424", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378757", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/98", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8"}}