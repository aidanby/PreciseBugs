{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE\t\t\"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT\t0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",\t\t\t/* 0 */\n    \"Binding\",\t\t\t/* 1 */\n    \"SharedSecret\",\t\t/* 2 */\n    \"Allocate\",\t\t\t/* 3 */\n    \"Refresh\",\t\t\t/* 4 */\n    \"???\",\t\t\t/* 5 */\n    \"Send\",\t\t\t/* 6 */\n    \"Data\",\t\t\t/* 7 */\n    \"CreatePermission\",\t\t/* 8 */\n    \"ChannelBind\",\t\t/* 9 */\n    \"Connect\",\t\t\t/* 10 */\n    \"ConnectionBind\",\t\t/* 11 */\n    \"ConnectionAttempt\",\t/* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,\t\t    \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,\t\t    \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,\t\t    \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,\t\t    \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,\t    \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,\t    \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,\t    \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,\t\t    \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,\t    \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,\t    \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,\t    \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,\t    \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,\t\t    \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,\t\t    \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,\t    \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,\t\t    \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,\t    \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,\t    \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,\t\t    \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,\t\t    \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,\t    \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,\t    \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t\t(*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n\t\t\t       const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n\t\t\t       unsigned len, const pj_stun_msg_hdr *msghdr,\n\t\t\t       unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t        const pj_uint8_t *buf, \n\t\t\t\t        const pj_stun_msg_hdr *msghdr,\n\t\t\t\t        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t        unsigned len, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr,\n\t\t\t\t        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n\t\t\t\t    const pj_uint8_t *buf, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr, \n\t\t\t\t    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t    unsigned len, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr,\n\t\t\t\t    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n\t\t\t\t     const pj_uint8_t *buf, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr, \n\t\t\t\t     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t     unsigned len, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n\t/* type zero */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_MAPPED_ADDR, */\n\t\"MAPPED-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_RESPONSE_ADDR, */\n\t\"RESPONSE-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANGE_REQUEST, */\n\t\"CHANGE-REQUEST\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_SOURCE_ADDR, */\n\t\"SOURCE-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANGED_ADDR, */\n\t\"CHANGED-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_USERNAME, */\n\t\"USERNAME\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_PASSWORD, */\n\t\"PASSWORD\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n\t\"MESSAGE-INTEGRITY\",\n\t&decode_msgint_attr,\n\t&encode_msgint_attr,\n\t&clone_msgint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ERROR_CODE, */\n\t\"ERROR-CODE\",\n\t&decode_errcode_attr,\n\t&encode_errcode_attr,\n\t&clone_errcode_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n\t\"UNKNOWN-ATTRIBUTES\",\n\t&decode_unknown_attr,\n\t&encode_unknown_attr,\n\t&clone_unknown_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REFLECTED_FROM, */\n\t\"REFLECTED-FROM\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n\t\"CHANNEL-NUMBER\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_LIFETIME, */\n\t\"LIFETIME\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x000E is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_MAGIC_COOKIE */\n\t\"MAGIC-COOKIE\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_BANDWIDTH, */\n\t\"BANDWIDTH\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x0011 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n\t\"XOR-PEER-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_DATA, */\n\t\"DATA\",\n\t&decode_binary_attr,\n\t&encode_binary_attr,\n\t&clone_binary_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REALM, */\n\t\"REALM\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_NONCE, */\n\t\"NONCE\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n\t\"XOR-RELAYED-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n\t\"REQUESTED-ADDRESS-FAMILY\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_EVEN_PORT, */\n\t\"EVEN-PORT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n\t\"REQUESTED-TRANSPORT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_DONT_FRAGMENT */\n\t\"DONT-FRAGMENT\",\n\t&decode_empty_attr,\n\t&encode_empty_attr,\n\t&clone_empty_attr\n    },\n    {\n\t/* ID 0x001B is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001C is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001D is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001E is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001F is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n\t\"XOR-MAPPED-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_TIMER_VAL, */\n\t\"TIMER-VAL\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n\t\"RESERVATION-TOKEN\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n\t\"XOR-REFLECTED-FROM\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_PRIORITY, */\n\t\"PRIORITY\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_USE_CANDIDATE, */\n\t\"USE-CANDIDATE\",\n\t&decode_empty_attr,\n\t&encode_empty_attr,\n\t&clone_empty_attr\n    },\n    {\n\t/* ID 0x0026 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0027 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0028 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0029 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_CONNECTION_ID, */\n\t\"CONNECTION-ID\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x002b is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002c is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002d is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002e is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002f is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_ICMP, */\n\t\"ICMP\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n\t/* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n\t/* ID 0x8021 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_SOFTWARE, */\n\t\"SOFTWARE\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n\t\"ALTERNATE-SERVER\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n\t\"REFRESH-INTERVAL\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x8025 is not assigned*/\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PADDING, 0x8026 */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* CACHE-TIMEOUT, 0x8027 */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_FINGERPRINT, */\n\t\"FINGERPRINT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ICE_CONTROLLED, */\n\t\"ICE-CONTROLLED\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ICE_CONTROLLING, */\n\t\"ICE-CONTROLLING\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n\treturn \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n\treturn \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n\treturn \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n\treturn \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n\treturn \"indication\";\n    else\n\treturn \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n\t      PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n\t      == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n\t      == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n\t      PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n\tdesc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n\t     attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n\tdesc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n\treturn NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n\treturn \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n\tif (stun_err_msg_map[i].err_code == err_code)\n\t    return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n\tint half = n/2;\n\tint mid = first + half;\n\n\tif (stun_err_msg_map[mid].err_code < err_code) {\n\t    first = mid+1;\n\t    n -= (half+1);\n\t} else if (stun_err_msg_map[mid].err_code > err_code) {\n\t    n = half;\n\t} else {\n\t    first = mid;\n\t    break;\n\t}\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n\treturn pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n\treturn pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n\t\t\t    (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN\t    4\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) ((buf[pos + 0] << 8) | \\\n\t\t\t  (buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) ((buf[pos + 0] << 24UL) | \\\n\t                  (buf[pos + 1] << 16UL) | \\\n\t                  (buf[pos + 2] <<  8UL) | \\\n\t\t\t  (buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN\t8\n#define STUN_GENERIC_IPV6_ADDR_LEN\t20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n\t\t\t\t\t\tint attr_type, \n\t\t\t\t\t\tpj_bool_t xor_ed,\n\t\t\t\t\t\tconst pj_sockaddr_t *addr,\n\t\t\t\t\t\tunsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n\t\t     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\t int attr_type,\n\t\t\t\t\t\t pj_bool_t xor_ed,\n\t\t\t\t\t\t const pj_sockaddr_t *addr,\n\t\t\t\t\t\t unsigned addr_len,\n\t\t\t\t\t\t pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n\t\t\t\t      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n\t\t\t\t\t\t  pj_stun_msg *msg,\n\t\t\t\t\t\t  int attr_type, \n\t\t\t\t\t\t  pj_bool_t xor_ed,\n\t\t\t\t\t\t  const pj_sockaddr_t *addr,\n\t\t\t\t\t\t  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n\t\t\t\t\t         addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t        const pj_uint8_t *buf, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr, \n\t\t\t\t        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n\tattr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n\treturn PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n\tif (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n\t    return PJNATH_ESTUNINATTRLEN;\n\taf = pj_AF_INET();\n\taddr_len = 4;\n    } else if (val == 2) {\n\tif (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n\t    return PJNATH_ESTUNINATTRLEN;\n\taf = pj_AF_INET6();\n\taddr_len = 16;\n    } else {\n\t/* Invalid address family */\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n\t\t\t GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n\t      buf+ATTR_HDR_LEN+4,\n\t      addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t\t      void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n\tattr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\tattr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n\tunsigned i;\n\tpj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n\tpj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n\tattr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n\t/* If the IP address family is IPv6, X-Address is computed by\n\t * taking the mapped IP address in host byte order, XOR'ing it\n\t * with the concatenation of the magic cookie and the 96-bit \n\t * transaction ID, and converting the result to network byte \n\t * order.\n\t */\n\tfor (i=0; i<4; ++i) {\n\t    dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n\t}\n\tpj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n\tfor (i=0; i<12; ++i) {\n\t    dst[i+4] ^= msghdr->tsx_id[i];\n\t}\n\n    } else {\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t        unsigned len, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr,\n\t\t\t\t\tunsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n\t(const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n\tenum {\n\t    ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n\t};\n\n\tif (len < ATTR_LEN) \n\t    return PJ_ETOOSMALL;\n\n\t/* attribute len */\n\tPUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n\tbuf += ATTR_HDR_LEN;\n    \n\t/* Ignored */\n\t*buf++ = '\\0';\n\n\t/* Address family, 1 for IPv4 */\n\t*buf++ = 1;\n\n\t/* IPv4 address */\n\tif (ca->xor_ed) {\n\t    pj_uint32_t addr;\n\t    pj_uint16_t port;\n\n\t    addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n\t    port = ca->sockaddr.ipv4.sin_port;\n\n\t    port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\t    addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n\t    /* Port */\n\t    pj_memcpy(buf, &port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &addr, 4);\n\t    buf += 4;\n\n\t} else {\n\t    /* Port */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n\t    buf += 4;\n\t}\n\n\tpj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n\t/* IPv6 address */\n\tenum {\n\t    ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n\t};\n\n\tif (len < ATTR_LEN) \n\t    return PJ_ETOOSMALL;\n\n\t/* attribute len */\n\tPUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n\tbuf += ATTR_HDR_LEN;\n    \n\t/* Ignored */\n\t*buf++ = '\\0';\n\n\t/* Address family, 2 for IPv6 */\n\t*buf++ = 2;\n\n\t/* IPv6 address */\n\tif (ca->xor_ed) {\n\t    unsigned i;\n\t    pj_uint8_t *dst;\n\t    const pj_uint8_t *src;\n\t    pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\t    pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n\t    /* Port */\n\t    port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\t    pj_memcpy(buf, &port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    dst = buf;\n\t    src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n\t    for (i=0; i<4; ++i) {\n\t\tdst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n\t    }\n\t    pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n\t    for (i=0; i<12; ++i) {\n\t\tdst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n\t    }\n\n\t    buf += 16;\n\n\t} else {\n\t    /* Port */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n\t    buf += 16;\n\t}\n\n\tpj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      const pj_str_t *value)\n{\n    if (value && value->slen) {\n\tINIT_ATTR(attr, attr_type, value->slen);\n\tattr->value.slen = value->slen;\n\tpj_strdup(pool, &attr->value, value);\n    } else {\n\tINIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_str_t *value,\n\t\t\t\t\t       pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type,\n\t\t\t\t\t\tconst pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n\t\t\t\t\t\t&attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n\t(const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n\t*printed = 0;\n\treturn PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n\tca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n\t/* Set the length to be 4-bytes aligned so that we can\n\t * communicate with RFC 3489 endpoints\n\t */\n\tPUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n\t/* Use RFC 5389 rule */\n\tPUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n\tpj_uint8_t pad[3];\n\tpj_memset(pad, padding_char, sizeof(pad));\n\tpj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n\t\t  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n\t\t\t\t     const pj_uint8_t *buf, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t     unsigned len, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n\t\t\t\t\t     int attr_type,\n\t\t\t\t\t     pj_uint32_t value,\n\t\t\t\t\t     pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n\t\t\t\t\t      pj_stun_msg *msg,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n\t\t\t\t    const pj_uint8_t *buf, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr, \n\t\t\t\t    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t    unsigned len, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr,\n\t\t\t\t    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_timestamp *value,\n\t\t\t\t\t       pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n\tattr->value.u32.hi = value->u32.hi;\n\tattr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n\t\t\t\t\t         pj_stun_msg *msg,\n\t\t\t\t\t         int attr_type,\n\t\t\t\t\t         const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);\t\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n\treturn PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\tint err_code,\n\t\t\t\t\t\tconst pj_str_t *err_reason,\n\t\t\t\t\t\tpj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n\tstr = pj_stun_get_err_reason(err_code);\n\tif (str.slen == 0) {\n\t    str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n\t\t\t\t        \"Unknown error %d\", err_code);\n\t    str.ptr = err_buf;\n\t}\n\terr_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n\t\t\t\t\t\t pj_stun_msg *msg,\n\t\t\t\t\t\t int err_code,\n\t\t\t\t\t\t const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n\t\t\t\t\t &err_attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n\t(const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n\treturn PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool\t\tThe pool to allocate memory from.\n * @param p_attr\tPointer to receive the attribute.\n *\n * @return\t\tPJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\tunsigned attr_cnt,\n\t\t\t\t\t\tconst pj_uint16_t attr_array[],\n\t\t\t\t\t\tpj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n\tattr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n\tattr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n\t\t\t\t\t\t pj_stun_msg *msg,\n\t\t\t\t\t\t unsigned attr_cnt,\n\t\t\t\t\t\t const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n\treturn PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n\tattr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n\t*dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      const pj_uint8_t *data,\n\t\t\t\t\t      unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n\tattr->length = length;\n\tattr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n\tpj_memcpy(attr->data, data, length);\n    } else {\n\tattr->data = NULL;\n\tattr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_uint8_t *data,\n\t\t\t\t\t       unsigned length,\n\t\t\t\t\t       pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type,\n\t\t\t\t\t\tconst pj_uint8_t *data,\n\t\t\t\t\t\tunsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n\t\t\t\t\tdata, length, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n\tdst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n\tpj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n\t\t\t\t      unsigned msg_type,\n\t\t\t\t      pj_uint32_t magic,\n\t\t\t\t      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n\tpj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n\tstruct transaction_id\n\t{\n\t    pj_uint32_t\t    proc_id;\n\t    pj_uint32_t\t    random;\n\t    pj_uint32_t\t    counter;\n\t} id;\n\tstatic pj_uint32_t pj_stun_tsx_id_counter;\n\n\tif (!pj_stun_tsx_id_counter)\n\t    pj_stun_tsx_id_counter = pj_rand();\n\n\tid.proc_id = pj_getpid();\n\tid.random = pj_rand();\n\tid.counter = pj_stun_tsx_id_counter++;\n\n\tpj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n\t\t\t\t\tunsigned msg_type,\n\t\t\t\t\tpj_uint32_t magic,\n\t\t\t\t\tconst pj_uint8_t tsx_id[12],\n\t\t\t\t\tpj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n\t\t\t\t\tconst pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n\tdst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n\tif (dst->attr[dst->attr_count])\n\t    ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n\t\t\t\t\t pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n\t\t\t\t      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n\treturn PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n\treturn PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n\t((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n\t/* Check if FINGERPRINT attribute is present */\n\tif ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n\t    GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n\t{\n\t    pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n\t    pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n\t    pj_uint32_t crc;\n\n\t    if (attr_len != 4)\n\t\treturn PJNATH_ESTUNINATTRLEN;\n\n\t    crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n\t    crc ^= STUN_XOR_FINGERPRINT;\n\n\t    if (crc != fingerprint)\n\t\treturn PJNATH_ESTUNFINGERPRINT;\n\t}\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_stun_msg *req_msg,\n\t\t\t\t\t\tunsigned err_code,\n\t\t\t\t\t\tconst pj_str_t *err_msg,\n\t\t\t\t\t\tpj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n\t\t     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n\tmsg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n\tmsg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n\t\t\t\treq_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n\treturn status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n\tstatus = pj_stun_msg_add_errcode_attr(pool, response, \n\t\t\t\t\t      err_code, err_msg);\n\tif (status != PJ_SUCCESS) {\n\t    return status;\n\t}\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n\t\t\t\t       const pj_uint8_t *pdu,\n\t\t\t\t       pj_size_t pdu_len,\n\t\t\t\t       unsigned options,\n\t\t\t\t       pj_stun_msg **p_msg,\n\t\t\t\t       pj_size_t *p_parsed_len,\n\t\t\t\t       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n\t*p_parsed_len = 0;\n    if (p_response)\n\t*p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n\tstatus = pj_stun_msg_check(pdu, pdu_len, options);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n\tp_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= 4) {\n\tunsigned attr_type, attr_val_len;\n\tconst struct attr_desc *adesc;\n\n\t/* Get attribute type and length. If length is not aligned\n\t * to 4 bytes boundary, add padding.\n\t */\n\tattr_type = GETVAL16H(pdu, 0);\n\tattr_val_len = GETVAL16H(pdu, 2);\n\tattr_val_len = (attr_val_len + 3) & (~3);\n\n\t/* Check length */\n\tif (pdu_len < attr_val_len) {\n\t    pj_str_t err_msg;\n\t    char err_msg_buf[80];\n\n\t    err_msg.ptr = err_msg_buf;\n\t    err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n\t\t\t\t\t    \"Attribute %s has invalid length\",\n\t\t\t\t\t    pj_stun_get_attr_name(attr_type));\n\n\t    PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n\t\t      (int)err_msg.slen, err_msg.ptr));\n\n\t    if (p_response) {\n\t\tpj_stun_msg_create_response(pool, msg, \n\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST, \n\t\t\t\t\t    &err_msg, p_response);\n\t    }\n\t    return PJNATH_ESTUNINATTRLEN;\n\t}\n\n\t/* Get the attribute descriptor */\n\tadesc = find_attr_desc(attr_type);\n\n\tif (adesc == NULL) {\n\t    /* Unrecognized attribute */\n\t    pj_stun_binary_attr *attr = NULL;\n\n\t    PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n\t\t      attr_type));\n\n\t    /* Is this a fatal condition? */\n\t    if (attr_type <= 0x7FFF) {\n\t\t/* This is a mandatory attribute, we must return error\n\t\t * if we don't understand the attribute.\n\t\t */\n\t\tif (p_response) {\n\t\t    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n\t\t    status = pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t\t err_code, NULL, \n\t\t\t\t\t\t\t p_response);\n\t\t    if (status==PJ_SUCCESS) {\n\t\t\tpj_uint16_t d = (pj_uint16_t)attr_type;\n\t\t\tpj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n\t\t    }\n\t\t}\n\n\t\treturn PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n\t    }\n\n\t    /* Make sure we have rooms for the new attribute */\n\t    if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\t\treturn PJNATH_ESTUNTOOMANYATTR;\n\t    }\n\n\t    /* Create binary attribute to represent this */\n\t    status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n\t\t\t\t\t\tGETVAL16H(pdu, 2), &attr);\n\t    if (status != PJ_SUCCESS) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Error parsing unknown STUN attribute type %d\",\n\t\t\t  attr_type));\n\n\t\treturn status;\n\t    }\n\n\t    /* Add the attribute */\n\t    msg->attr[msg->attr_count++] = &attr->hdr;\n\n\t} else {\n\t    void *attr;\n\t    char err_msg1[PJ_ERR_MSG_SIZE],\n\t\t err_msg2[PJ_ERR_MSG_SIZE];\n\n\t    /* Parse the attribute */\n\t    status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n\t    if (status != PJ_SUCCESS) {\n\t\tpj_strerror(status, err_msg1, sizeof(err_msg1));\n\n\t\tif (p_response) {\n\t\t    pj_str_t e;\n\n\t\t    e.ptr = err_msg2;\n\t\t    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n\t\t\t\t\t     \"%s in %s\",\n\t\t\t\t\t     err_msg1,\n\t\t\t\t\t     pj_stun_get_attr_name(attr_type));\n\t\t    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n\t\t\te.slen = sizeof(err_msg2) - 1;\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t&e, p_response);\n\t\t}\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Error parsing STUN attribute %s: %s\",\n\t\t\t  pj_stun_get_attr_name(attr_type), \n\t\t\t  err_msg1));\n\n\t\treturn status;\n\t    }\n\n\t    if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n\t\t!has_fingerprint) \n\t    {\n\t\tif (has_msg_int) {\n\t\t    /* Already has MESSAGE-INTEGRITY */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNDUPATTR;\n\t\t}\n\t\thas_msg_int = PJ_TRUE;\n\n\t    } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n\t\tif (has_fingerprint) {\n\t\t    /* Already has FINGERPRINT */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNDUPATTR;\n\t\t}\n\t\thas_fingerprint = PJ_TRUE;\n\t    } else {\n\t\tif (has_fingerprint) {\n\t\t    /* Another attribute is found which is not FINGERPRINT\n\t\t     * after FINGERPRINT. Note that non-FINGERPRINT is\n\t\t     * allowed to appear after M-I\n\t\t     */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNFINGERPOS;\n\t\t}\n\t    }\n\n\t    /* Make sure we have rooms for the new attribute */\n\t    if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\t\treturn PJNATH_ESTUNTOOMANYATTR;\n\t    }\n\n\t    /* Add the attribute */\n\t    msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n\t}\n\n\t/* Next attribute */\n\tif (attr_val_len + 4 >= pdu_len) {\n\t    pdu += pdu_len;\n\t    pdu_len = 0;\n\t} else {\n\t    pdu += (attr_val_len + 4);\n\t    pdu_len -= (attr_val_len + 4);\n\t}\n    }\n\n    if (pdu_len > 0) {\n\t/* Stray trailing bytes */\n\tPJ_LOG(4,(THIS_FILE, \n\t\t  \"Error decoding STUN message: unparsed trailing %d bytes\",\n\t\t  pdu_len));\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n\t*p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n\treturn \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n\tpj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n\tbuffer += 2;\n\tdata++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n\t\t\t\t       pj_uint8_t *buf, pj_size_t buf_size,\n\t\t\t\t       unsigned options,\n\t\t\t\t       const pj_str_t *key,\n\t\t\t\t       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n\treturn PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n\tconst struct attr_desc *adesc;\n\tconst pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n\tif (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n\t    pj_assert(amsgint == NULL);\n\t    amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n\t    /* Stop when encountering MESSAGE-INTEGRITY */\n\t    break;\n\n\t} else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n\t    afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n\t    break;\n\t}\n\n\tadesc = find_attr_desc(attr_hdr->type);\n\tif (adesc) {\n\t    status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n\t\t\t\t\t&msg->hdr, &printed);\n\t} else {\n\t    /* This may be a generic attribute */\n\t    const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n\t\t\t\t\t\t   attr_hdr;\n\t    PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n\t    status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n\t\t\t\t\t&msg->hdr, &printed);\n\t}\n\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n\tconst pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n\t/* There mustn't any attribute after FINGERPRINT */\n\tPJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n\tif (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n\t    /* There mustn't be MESSAGE-INTEGRITY before */\n\t    PJ_ASSERT_RETURN(amsgint == NULL, \n\t\t\t     PJNATH_ESTUNMSGINTPOS);\n\t    amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n\t} else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n\t    afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n\t}\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n\tbody_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n\tbody_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif\t/* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n\tpj_hmac_sha1_context ctx;\n\n\t/* Key MUST be specified */\n\tPJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n\t/* MESSAGE-INTEGRITY must be the last attribute in the message, or\n\t * the last attribute before FINGERPRINT.\n\t */\n\tif (msg->attr_count>1 && i < msg->attr_count-2) {\n\t    /* Should not happen for message generated by us */\n\t    pj_assert(PJ_FALSE);\n\t    return PJNATH_ESTUNMSGINTPOS;\n\n\t} else if (i == msg->attr_count-2)  {\n\t    if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n\t\t/* Should not happen for message generated by us */\n\t\tpj_assert(PJ_FALSE);\n\t\treturn PJNATH_ESTUNMSGINTPOS;\n\t    } else {\n\t\tafingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n\t    }\n\t}\n\n\t/* Calculate HMAC-SHA1 digest, add zero padding to input\n\t * if necessary to make the input 64 bytes aligned.\n\t */\n\tpj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n\t\t\t  (unsigned)key->slen);\n\tpj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n\t\t\t    (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n\t// These are obsoleted in rfc3489bis-08\n\tif ((buf-start) & 0x3F) {\n\t    pj_uint8_t zeroes[64];\n\t    pj_bzero(zeroes, sizeof(zeroes));\n\t    pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n\t}\n#endif\t/* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\tpj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n\t/* Put this attribute in the message */\n\tstatus = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n\t\t\t            &msg->hdr, &printed);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n\t/* Update message length */\n\tPUTVAL16H(start, 2, \n\t\t (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n\tafingerprint->value = pj_crc32_calc(start, buf-start);\n\tafingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n\t/* Put this attribute in the message */\n\tstatus = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n\t\t\t\t  &msg->hdr, &printed);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n\t*p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n\t\t\t\t\t\t int attr_type,\n\t\t\t\t\t\t unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n\tif (msg->attr[index]->type == attr_type)\n\t    return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n\t\t\t\t\t      const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n\treturn (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n\t/* Clone generic attribute */\n\tconst pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n\t\t\t\t\t       attr;\n\tPJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n\tif (bin_attr->magic == PJ_STUN_MAGIC) {\n\t    return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n\t} else {\n\t    return NULL;\n\t}\n    }\n}\n\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE\t\t\"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT\t0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",\t\t\t/* 0 */\n    \"Binding\",\t\t\t/* 1 */\n    \"SharedSecret\",\t\t/* 2 */\n    \"Allocate\",\t\t\t/* 3 */\n    \"Refresh\",\t\t\t/* 4 */\n    \"???\",\t\t\t/* 5 */\n    \"Send\",\t\t\t/* 6 */\n    \"Data\",\t\t\t/* 7 */\n    \"CreatePermission\",\t\t/* 8 */\n    \"ChannelBind\",\t\t/* 9 */\n    \"Connect\",\t\t\t/* 10 */\n    \"ConnectionBind\",\t\t/* 11 */\n    \"ConnectionAttempt\",\t/* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,\t\t    \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,\t\t    \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,\t\t    \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,\t\t    \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,\t    \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,\t    \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,\t    \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,\t\t    \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,\t    \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,\t    \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,\t    \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,\t    \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,\t\t    \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,\t\t    \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,\t    \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,\t\t    \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,\t    \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,\t    \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,\t\t    \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,\t\t    \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,\t    \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,\t    \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t\t(*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n\t\t\t       const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n\t\t\t       unsigned len, const pj_stun_msg_hdr *msghdr,\n\t\t\t       unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t        const pj_uint8_t *buf, \n\t\t\t\t        const pj_stun_msg_hdr *msghdr,\n\t\t\t\t        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t        unsigned len, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr,\n\t\t\t\t        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n\t\t\t\t    const pj_uint8_t *buf, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr, \n\t\t\t\t    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t    unsigned len, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr,\n\t\t\t\t    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n\t\t\t\t     const pj_uint8_t *buf, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr, \n\t\t\t\t     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t     unsigned len, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n\t/* type zero */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_MAPPED_ADDR, */\n\t\"MAPPED-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_RESPONSE_ADDR, */\n\t\"RESPONSE-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANGE_REQUEST, */\n\t\"CHANGE-REQUEST\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_SOURCE_ADDR, */\n\t\"SOURCE-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANGED_ADDR, */\n\t\"CHANGED-ADDRESS\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_USERNAME, */\n\t\"USERNAME\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_PASSWORD, */\n\t\"PASSWORD\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n\t\"MESSAGE-INTEGRITY\",\n\t&decode_msgint_attr,\n\t&encode_msgint_attr,\n\t&clone_msgint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ERROR_CODE, */\n\t\"ERROR-CODE\",\n\t&decode_errcode_attr,\n\t&encode_errcode_attr,\n\t&clone_errcode_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n\t\"UNKNOWN-ATTRIBUTES\",\n\t&decode_unknown_attr,\n\t&encode_unknown_attr,\n\t&clone_unknown_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REFLECTED_FROM, */\n\t\"REFLECTED-FROM\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n\t\"CHANNEL-NUMBER\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_LIFETIME, */\n\t\"LIFETIME\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x000E is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_MAGIC_COOKIE */\n\t\"MAGIC-COOKIE\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_BANDWIDTH, */\n\t\"BANDWIDTH\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x0011 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n\t\"XOR-PEER-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_DATA, */\n\t\"DATA\",\n\t&decode_binary_attr,\n\t&encode_binary_attr,\n\t&clone_binary_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REALM, */\n\t\"REALM\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_NONCE, */\n\t\"NONCE\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n\t\"XOR-RELAYED-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n\t\"REQUESTED-ADDRESS-FAMILY\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_EVEN_PORT, */\n\t\"EVEN-PORT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n\t\"REQUESTED-TRANSPORT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_DONT_FRAGMENT */\n\t\"DONT-FRAGMENT\",\n\t&decode_empty_attr,\n\t&encode_empty_attr,\n\t&clone_empty_attr\n    },\n    {\n\t/* ID 0x001B is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001C is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001D is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001E is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x001F is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n\t\"XOR-MAPPED-ADDRESS\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_TIMER_VAL, */\n\t\"TIMER-VAL\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n\t\"RESERVATION-TOKEN\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n\t\"XOR-REFLECTED-FROM\",\n\t&decode_xored_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_PRIORITY, */\n\t\"PRIORITY\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_USE_CANDIDATE, */\n\t\"USE-CANDIDATE\",\n\t&decode_empty_attr,\n\t&encode_empty_attr,\n\t&clone_empty_attr\n    },\n    {\n\t/* ID 0x0026 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0027 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0028 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x0029 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_CONNECTION_ID, */\n\t\"CONNECTION-ID\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x002b is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002c is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002d is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002e is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* ID 0x002f is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_ICMP, */\n\t\"ICMP\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n\t/* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n\t/* ID 0x8021 is not assigned */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_SOFTWARE, */\n\t\"SOFTWARE\",\n\t&decode_string_attr,\n\t&encode_string_attr,\n\t&clone_string_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n\t\"ALTERNATE-SERVER\",\n\t&decode_sockaddr_attr,\n\t&encode_sockaddr_attr,\n\t&clone_sockaddr_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n\t\"REFRESH-INTERVAL\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* ID 0x8025 is not assigned*/\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PADDING, 0x8026 */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* CACHE-TIMEOUT, 0x8027 */\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n    },\n    {\n\t/* PJ_STUN_ATTR_FINGERPRINT, */\n\t\"FINGERPRINT\",\n\t&decode_uint_attr,\n\t&encode_uint_attr,\n\t&clone_uint_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ICE_CONTROLLED, */\n\t\"ICE-CONTROLLED\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    },\n    {\n\t/* PJ_STUN_ATTR_ICE_CONTROLLING, */\n\t\"ICE-CONTROLLING\",\n\t&decode_uint64_attr,\n\t&encode_uint64_attr,\n\t&clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n\treturn \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n\treturn \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n\treturn \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n\treturn \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n\treturn \"indication\";\n    else\n\treturn \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n\t      PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n\t      == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n\t      == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n\t      PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n\tdesc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n\t     attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n\tdesc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n\treturn NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n\treturn \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n\tif (stun_err_msg_map[i].err_code == err_code)\n\t    return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n\tint half = n/2;\n\tint mid = first + half;\n\n\tif (stun_err_msg_map[mid].err_code < err_code) {\n\t    first = mid+1;\n\t    n -= (half+1);\n\t} else if (stun_err_msg_map[mid].err_code > err_code) {\n\t    n = half;\n\t} else {\n\t    first = mid;\n\t    break;\n\t}\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n\treturn pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n\treturn pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n\t\t\t    (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN\t    4\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) ((buf[pos + 0] << 8) | \\\n\t\t\t  (buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) ((buf[pos + 0] << 24UL) | \\\n\t                  (buf[pos + 1] << 16UL) | \\\n\t                  (buf[pos + 2] <<  8UL) | \\\n\t\t\t  (buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN\t8\n#define STUN_GENERIC_IPV6_ADDR_LEN\t20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n\t\t\t\t\t\tint attr_type, \n\t\t\t\t\t\tpj_bool_t xor_ed,\n\t\t\t\t\t\tconst pj_sockaddr_t *addr,\n\t\t\t\t\t\tunsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n\t\t     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\t int attr_type,\n\t\t\t\t\t\t pj_bool_t xor_ed,\n\t\t\t\t\t\t const pj_sockaddr_t *addr,\n\t\t\t\t\t\t unsigned addr_len,\n\t\t\t\t\t\t pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n\t\t\t\t      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n\t\t\t\t\t\t  pj_stun_msg *msg,\n\t\t\t\t\t\t  int attr_type, \n\t\t\t\t\t\t  pj_bool_t xor_ed,\n\t\t\t\t\t\t  const pj_sockaddr_t *addr,\n\t\t\t\t\t\t  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n\t\t\t\t\t         addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t        const pj_uint8_t *buf, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr, \n\t\t\t\t        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n\tattr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n\treturn PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n\tif (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n\t    return PJNATH_ESTUNINATTRLEN;\n\taf = pj_AF_INET();\n\taddr_len = 4;\n    } else if (val == 2) {\n\tif (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n\t    return PJNATH_ESTUNINATTRLEN;\n\taf = pj_AF_INET6();\n\taddr_len = 16;\n    } else {\n\t/* Invalid address family */\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n\t\t\t GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n\t      buf+ATTR_HDR_LEN+4,\n\t      addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n\t\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t\t      void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n\tattr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\tattr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n\tunsigned i;\n\tpj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n\tpj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n\tattr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n\t/* If the IP address family is IPv6, X-Address is computed by\n\t * taking the mapped IP address in host byte order, XOR'ing it\n\t * with the concatenation of the magic cookie and the 96-bit \n\t * transaction ID, and converting the result to network byte \n\t * order.\n\t */\n\tfor (i=0; i<4; ++i) {\n\t    dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n\t}\n\tpj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n\tfor (i=0; i<12; ++i) {\n\t    dst[i+4] ^= msghdr->tsx_id[i];\n\t}\n\n    } else {\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t        unsigned len, \n\t\t\t\t\tconst pj_stun_msg_hdr *msghdr,\n\t\t\t\t\tunsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n\t(const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n\tenum {\n\t    ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n\t};\n\n\tif (len < ATTR_LEN) \n\t    return PJ_ETOOSMALL;\n\n\t/* attribute len */\n\tPUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n\tbuf += ATTR_HDR_LEN;\n    \n\t/* Ignored */\n\t*buf++ = '\\0';\n\n\t/* Address family, 1 for IPv4 */\n\t*buf++ = 1;\n\n\t/* IPv4 address */\n\tif (ca->xor_ed) {\n\t    pj_uint32_t addr;\n\t    pj_uint16_t port;\n\n\t    addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n\t    port = ca->sockaddr.ipv4.sin_port;\n\n\t    port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\t    addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n\t    /* Port */\n\t    pj_memcpy(buf, &port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &addr, 4);\n\t    buf += 4;\n\n\t} else {\n\t    /* Port */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n\t    buf += 4;\n\t}\n\n\tpj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n\t/* IPv6 address */\n\tenum {\n\t    ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n\t};\n\n\tif (len < ATTR_LEN) \n\t    return PJ_ETOOSMALL;\n\n\t/* attribute len */\n\tPUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n\tbuf += ATTR_HDR_LEN;\n    \n\t/* Ignored */\n\t*buf++ = '\\0';\n\n\t/* Address family, 2 for IPv6 */\n\t*buf++ = 2;\n\n\t/* IPv6 address */\n\tif (ca->xor_ed) {\n\t    unsigned i;\n\t    pj_uint8_t *dst;\n\t    const pj_uint8_t *src;\n\t    pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\t    pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n\t    /* Port */\n\t    port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\t    pj_memcpy(buf, &port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    dst = buf;\n\t    src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n\t    for (i=0; i<4; ++i) {\n\t\tdst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n\t    }\n\t    pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n\t    for (i=0; i<12; ++i) {\n\t\tdst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n\t    }\n\n\t    buf += 16;\n\n\t} else {\n\t    /* Port */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n\t    buf += 2;\n\n\t    /* Address */\n\t    pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n\t    buf += 16;\n\t}\n\n\tpj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n\treturn PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      const pj_str_t *value)\n{\n    if (value && value->slen) {\n\tINIT_ATTR(attr, attr_type, value->slen);\n\tattr->value.slen = value->slen;\n\tpj_strdup(pool, &attr->value, value);\n    } else {\n\tINIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_str_t *value,\n\t\t\t\t\t       pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type,\n\t\t\t\t\t\tconst pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n\t\t\t\t\t\t&attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n\t(const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n\t*printed = 0;\n\treturn PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n\tca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n\t/* Set the length to be 4-bytes aligned so that we can\n\t * communicate with RFC 3489 endpoints\n\t */\n\tPUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n\t/* Use RFC 5389 rule */\n\tPUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n\tpj_uint8_t pad[3];\n\tpj_memset(pad, padding_char, sizeof(pad));\n\tpj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n\t\t  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n\t\t\t\t     const pj_uint8_t *buf, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t     unsigned len, \n\t\t\t\t     const pj_stun_msg_hdr *msghdr,\n\t\t\t\t     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n\t\t\t\t\t     int attr_type,\n\t\t\t\t\t     pj_uint32_t value,\n\t\t\t\t\t     pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n\t\t\t\t\t      pj_stun_msg *msg,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n\t\t\t\t    const pj_uint8_t *buf, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr, \n\t\t\t\t    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t    unsigned len, \n\t\t\t\t    const pj_stun_msg_hdr *msghdr,\n\t\t\t\t    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_timestamp *value,\n\t\t\t\t\t       pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n\tattr->value.u32.hi = value->u32.hi;\n\tattr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n\t\t\t\t\t         pj_stun_msg *msg,\n\t\t\t\t\t         int attr_type,\n\t\t\t\t\t         const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);\t\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr, \n\t\t\t\t      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n\treturn PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n\treturn PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\tint err_code,\n\t\t\t\t\t\tconst pj_str_t *err_reason,\n\t\t\t\t\t\tpj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n\tstr = pj_stun_get_err_reason(err_code);\n\tif (str.slen == 0) {\n\t    str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n\t\t\t\t        \"Unknown error %d\", err_code);\n\t    str.ptr = err_buf;\n\t}\n\terr_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n\t\t\t\t\t\t pj_stun_msg *msg,\n\t\t\t\t\t\t int err_code,\n\t\t\t\t\t\t const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n\t\t\t\t\t &err_attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n    \tvalue.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n\t(const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n\treturn PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool\t\tThe pool to allocate memory from.\n * @param p_attr\tPointer to receive the attribute.\n *\n * @return\t\tPJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n\t\t\t\t\t\tunsigned attr_cnt,\n\t\t\t\t\t\tconst pj_uint16_t attr_array[],\n\t\t\t\t\t\tpj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n\tattr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n\tattr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n\t\t\t\t\t\t pj_stun_msg *msg,\n\t\t\t\t\t\t unsigned attr_cnt,\n\t\t\t\t\t\t const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n\treturn PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n\tattr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t       unsigned len, \n\t\t\t\t       const pj_stun_msg_hdr *msghdr,\n\t\t\t\t       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n\t*dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      int attr_type,\n\t\t\t\t\t      const pj_uint8_t *data,\n\t\t\t\t\t      unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n\tattr->length = length;\n\tattr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n\tpj_memcpy(attr->data, data, length);\n    } else {\n\tattr->data = NULL;\n\tattr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n\t\t\t\t\t       int attr_type,\n\t\t\t\t\t       const pj_uint8_t *data,\n\t\t\t\t\t       unsigned length,\n\t\t\t\t\t       pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n\t\t\t\t\t\tpj_stun_msg *msg,\n\t\t\t\t\t\tint attr_type,\n\t\t\t\t\t\tconst pj_uint8_t *data,\n\t\t\t\t\t\tunsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n\t\t\t\t\tdata, length, &attr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n\t\t\t\t      const pj_uint8_t *buf,\n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n\t\t\t\t      unsigned len, \n\t\t\t\t      const pj_stun_msg_hdr *msghdr,\n\t\t\t\t      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n\treturn PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n\tdst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n\tpj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n\t\t\t\t      unsigned msg_type,\n\t\t\t\t      pj_uint32_t magic,\n\t\t\t\t      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n\tpj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n\tstruct transaction_id\n\t{\n\t    pj_uint32_t\t    proc_id;\n\t    pj_uint32_t\t    random;\n\t    pj_uint32_t\t    counter;\n\t} id;\n\tstatic pj_uint32_t pj_stun_tsx_id_counter;\n\n\tif (!pj_stun_tsx_id_counter)\n\t    pj_stun_tsx_id_counter = pj_rand();\n\n\tid.proc_id = pj_getpid();\n\tid.random = pj_rand();\n\tid.counter = pj_stun_tsx_id_counter++;\n\n\tpj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n\t\t\t\t\tunsigned msg_type,\n\t\t\t\t\tpj_uint32_t magic,\n\t\t\t\t\tconst pj_uint8_t tsx_id[12],\n\t\t\t\t\tpj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n\t\t\t\t\tconst pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n\tdst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n\tif (dst->attr[dst->attr_count])\n\t    ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n\t\t\t\t\t pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n\t\t\t\t      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n\treturn PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n\treturn PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n\t((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n\t/* Check if FINGERPRINT attribute is present */\n\tif ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n\t    GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n\t{\n\t    pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n\t    pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n\t    pj_uint32_t crc;\n\n\t    if (attr_len != 4)\n\t\treturn PJNATH_ESTUNINATTRLEN;\n\n\t    crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n\t    crc ^= STUN_XOR_FINGERPRINT;\n\n\t    if (crc != fingerprint)\n\t\treturn PJNATH_ESTUNFINGERPRINT;\n\t}\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_stun_msg *req_msg,\n\t\t\t\t\t\tunsigned err_code,\n\t\t\t\t\t\tconst pj_str_t *err_msg,\n\t\t\t\t\t\tpj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n\t\t     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n\tmsg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n\tmsg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n\t\t\t\treq_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n\treturn status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n\tstatus = pj_stun_msg_add_errcode_attr(pool, response, \n\t\t\t\t\t      err_code, err_msg);\n\tif (status != PJ_SUCCESS) {\n\t    return status;\n\t}\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n\t\t\t\t       const pj_uint8_t *pdu,\n\t\t\t\t       pj_size_t pdu_len,\n\t\t\t\t       unsigned options,\n\t\t\t\t       pj_stun_msg **p_msg,\n\t\t\t\t       pj_size_t *p_parsed_len,\n\t\t\t\t       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n\t*p_parsed_len = 0;\n    if (p_response)\n\t*p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n\tstatus = pj_stun_msg_check(pdu, pdu_len, options);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n\tp_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= 4) {\n\tunsigned attr_type, attr_val_len;\n\tconst struct attr_desc *adesc;\n\n\t/* Get attribute type and length. If length is not aligned\n\t * to 4 bytes boundary, add padding.\n\t */\n\tattr_type = GETVAL16H(pdu, 0);\n\tattr_val_len = GETVAL16H(pdu, 2);\n\tattr_val_len = (attr_val_len + 3) & (~3);\n\n\t/* Check length */\n\tif (pdu_len < attr_val_len) {\n\t    pj_str_t err_msg;\n\t    char err_msg_buf[80];\n\n\t    err_msg.ptr = err_msg_buf;\n\t    err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n\t\t\t\t\t    \"Attribute %s has invalid length\",\n\t\t\t\t\t    pj_stun_get_attr_name(attr_type));\n\n\t    PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n\t\t      (int)err_msg.slen, err_msg.ptr));\n\n\t    if (p_response) {\n\t\tpj_stun_msg_create_response(pool, msg, \n\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST, \n\t\t\t\t\t    &err_msg, p_response);\n\t    }\n\t    return PJNATH_ESTUNINATTRLEN;\n\t}\n\n\t/* Get the attribute descriptor */\n\tadesc = find_attr_desc(attr_type);\n\n\tif (adesc == NULL) {\n\t    /* Unrecognized attribute */\n\t    pj_stun_binary_attr *attr = NULL;\n\n\t    PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n\t\t      attr_type));\n\n\t    /* Is this a fatal condition? */\n\t    if (attr_type <= 0x7FFF) {\n\t\t/* This is a mandatory attribute, we must return error\n\t\t * if we don't understand the attribute.\n\t\t */\n\t\tif (p_response) {\n\t\t    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n\t\t    status = pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t\t err_code, NULL, \n\t\t\t\t\t\t\t p_response);\n\t\t    if (status==PJ_SUCCESS) {\n\t\t\tpj_uint16_t d = (pj_uint16_t)attr_type;\n\t\t\tpj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n\t\t    }\n\t\t}\n\n\t\treturn PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n\t    }\n\n\t    /* Make sure we have rooms for the new attribute */\n\t    if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\t\treturn PJNATH_ESTUNTOOMANYATTR;\n\t    }\n\n\t    /* Create binary attribute to represent this */\n\t    status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n\t\t\t\t\t\tGETVAL16H(pdu, 2), &attr);\n\t    if (status != PJ_SUCCESS) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Error parsing unknown STUN attribute type %d\",\n\t\t\t  attr_type));\n\n\t\treturn status;\n\t    }\n\n\t    /* Add the attribute */\n\t    msg->attr[msg->attr_count++] = &attr->hdr;\n\n\t} else {\n\t    void *attr;\n\t    char err_msg1[PJ_ERR_MSG_SIZE],\n\t\t err_msg2[PJ_ERR_MSG_SIZE];\n\n\t    /* Parse the attribute */\n\t    status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n\t    if (status != PJ_SUCCESS) {\n\t\tpj_strerror(status, err_msg1, sizeof(err_msg1));\n\n\t\tif (p_response) {\n\t\t    pj_str_t e;\n\n\t\t    e.ptr = err_msg2;\n\t\t    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n\t\t\t\t\t     \"%s in %s\",\n\t\t\t\t\t     err_msg1,\n\t\t\t\t\t     pj_stun_get_attr_name(attr_type));\n\t\t    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n\t\t\te.slen = sizeof(err_msg2) - 1;\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t&e, p_response);\n\t\t}\n\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Error parsing STUN attribute %s: %s\",\n\t\t\t  pj_stun_get_attr_name(attr_type), \n\t\t\t  err_msg1));\n\n\t\treturn status;\n\t    }\n\n\t    if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n\t\t!has_fingerprint) \n\t    {\n\t\tif (has_msg_int) {\n\t\t    /* Already has MESSAGE-INTEGRITY */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNDUPATTR;\n\t\t}\n\t\thas_msg_int = PJ_TRUE;\n\n\t    } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n\t\tif (has_fingerprint) {\n\t\t    /* Already has FINGERPRINT */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNDUPATTR;\n\t\t}\n\t\thas_fingerprint = PJ_TRUE;\n\t    } else {\n\t\tif (has_fingerprint) {\n\t\t    /* Another attribute is found which is not FINGERPRINT\n\t\t     * after FINGERPRINT. Note that non-FINGERPRINT is\n\t\t     * allowed to appear after M-I\n\t\t     */\n\t\t    if (p_response) {\n\t\t\tpj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\t    PJ_STUN_SC_BAD_REQUEST,\n\t\t\t\t\t\t    NULL, p_response);\n\t\t    }\n\t\t    return PJNATH_ESTUNFINGERPOS;\n\t\t}\n\t    }\n\n\t    /* Make sure we have rooms for the new attribute */\n\t    if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n\t\tif (p_response) {\n\t\t    pj_stun_msg_create_response(pool, msg,\n\t\t\t\t\t\tPJ_STUN_SC_SERVER_ERROR,\n\t\t\t\t\t\tNULL, p_response);\n\t\t}\n\t\treturn PJNATH_ESTUNTOOMANYATTR;\n\t    }\n\n\t    /* Add the attribute */\n\t    msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n\t}\n\n\t/* Next attribute */\n\tif (attr_val_len + 4 >= pdu_len) {\n\t    pdu += pdu_len;\n\t    pdu_len = 0;\n\t} else {\n\t    pdu += (attr_val_len + 4);\n\t    pdu_len -= (attr_val_len + 4);\n\t}\n    }\n\n    if (pdu_len > 0) {\n\t/* Stray trailing bytes */\n\tPJ_LOG(4,(THIS_FILE, \n\t\t  \"Error decoding STUN message: unparsed trailing %d bytes\",\n\t\t  pdu_len));\n\treturn PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n\t*p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n\treturn \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n\tpj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n\tbuffer += 2;\n\tdata++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n\t\t\t\t       pj_uint8_t *buf, pj_size_t buf_size,\n\t\t\t\t       unsigned options,\n\t\t\t\t       const pj_str_t *key,\n\t\t\t\t       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n\treturn PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n\tconst struct attr_desc *adesc;\n\tconst pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n\tif (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n\t    pj_assert(amsgint == NULL);\n\t    amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n\t    /* Stop when encountering MESSAGE-INTEGRITY */\n\t    break;\n\n\t} else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n\t    afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n\t    break;\n\t}\n\n\tadesc = find_attr_desc(attr_hdr->type);\n\tif (adesc) {\n\t    status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n\t\t\t\t\t&msg->hdr, &printed);\n\t} else {\n\t    /* This may be a generic attribute */\n\t    const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n\t\t\t\t\t\t   attr_hdr;\n\t    PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n\t    status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n\t\t\t\t\t&msg->hdr, &printed);\n\t}\n\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n\tconst pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n\t/* There mustn't any attribute after FINGERPRINT */\n\tPJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n\tif (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n\t    /* There mustn't be MESSAGE-INTEGRITY before */\n\t    PJ_ASSERT_RETURN(amsgint == NULL, \n\t\t\t     PJNATH_ESTUNMSGINTPOS);\n\t    amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n\t} else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n\t    afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n\t}\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n\tbody_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n\tbody_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n\tbody_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif\t/* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n\tpj_hmac_sha1_context ctx;\n\n\t/* Key MUST be specified */\n\tPJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n\t/* MESSAGE-INTEGRITY must be the last attribute in the message, or\n\t * the last attribute before FINGERPRINT.\n\t */\n\tif (msg->attr_count>1 && i < msg->attr_count-2) {\n\t    /* Should not happen for message generated by us */\n\t    pj_assert(PJ_FALSE);\n\t    return PJNATH_ESTUNMSGINTPOS;\n\n\t} else if (i == msg->attr_count-2)  {\n\t    if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n\t\t/* Should not happen for message generated by us */\n\t\tpj_assert(PJ_FALSE);\n\t\treturn PJNATH_ESTUNMSGINTPOS;\n\t    } else {\n\t\tafingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n\t    }\n\t}\n\n\t/* Calculate HMAC-SHA1 digest, add zero padding to input\n\t * if necessary to make the input 64 bytes aligned.\n\t */\n\tpj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n\t\t\t  (unsigned)key->slen);\n\tpj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n\t\t\t    (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n\t// These are obsoleted in rfc3489bis-08\n\tif ((buf-start) & 0x3F) {\n\t    pj_uint8_t zeroes[64];\n\t    pj_bzero(zeroes, sizeof(zeroes));\n\t    pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n\t}\n#endif\t/* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\tpj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n\t/* Put this attribute in the message */\n\tstatus = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n\t\t\t            &msg->hdr, &printed);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n\t/* Update message length */\n\tPUTVAL16H(start, 2, \n\t\t (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n\tafingerprint->value = pj_crc32_calc(start, buf-start);\n\tafingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n\t/* Put this attribute in the message */\n\tstatus = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n\t\t\t\t  &msg->hdr, &printed);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\n\tbuf += printed;\n\tbuf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n\t*p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n\t\t\t\t\t\t int attr_type,\n\t\t\t\t\t\t unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n\tif (msg->attr[index]->type == attr_type)\n\t    return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n\t\t\t\t\t      const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n\treturn (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n\t/* Clone generic attribute */\n\tconst pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n\t\t\t\t\t       attr;\n\tPJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n\tif (bin_attr->magic == PJ_STUN_MAGIC) {\n\t    return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n\t} else {\n\t    return NULL;\n\t}\n    }\n}\n\n\n"], "filenames": ["pjnath/src/pjnath/stun_msg.c"], "buggy_code_start_loc": [1765], "buggy_code_end_loc": [1765], "fixing_code_start_loc": [1766], "fixing_code_end_loc": [1769], "type": "CWE-191", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming STUN message contains an ERROR-CODE attribute, the header length is not checked before performing a subtraction operation, potentially resulting in an integer underflow scenario. This issue affects all users that use STUN. A malicious actor located within the victim\u2019s network may forge and send a specially crafted UDP (STUN) message that could remotely execute arbitrary code on the victim\u2019s machine. Users are advised to upgrade as soon as possible. There are no known workarounds.", "other": {"cve": {"id": "CVE-2021-37706", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-22T18:15:07.487", "lastModified": "2023-02-02T18:08:22.203", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming STUN message contains an ERROR-CODE attribute, the header length is not checked before performing a subtraction operation, potentially resulting in an integer underflow scenario. This issue affects all users that use STUN. A malicious actor located within the victim\u2019s network may forge and send a specially crafted UDP (STUN) message that could remotely execute arbitrary code on the victim\u2019s machine. Users are advised to upgrade as soon as possible. There are no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En las versiones afectadas, si el mensaje STUN entrante contiene un atributo ERROR-CODE, no se comprueba la longitud del encabezado antes de llevar a cabo una operaci\u00f3n de sustracci\u00f3n, resultando en un escenario de desbordamiento de enteros. Este problema afecta a todos los usuarios que usan STUN. Un actor malicioso situado en la red de la v\u00edctima puede falsificar y enviar un mensaje UDP (STUN) especialmente dise\u00f1ado que podr\u00eda ejecutar remotamente c\u00f3digo arbitrario en la m\u00e1quina de la v\u00edctima. Se aconseja a usuarios que actualicen lo antes posible. No se presentan soluciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:*:*:*:*:*:*:*:*", "versionEndExcluding": "16.8.0", "matchCriteriaId": "02200524-98C1-49E2-8DFE-7BE82E1181E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "FC49FD2F-9A64-4F92-9B73-50E37BEB207E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "E64BCD44-2298-4710-9CC3-DF82E6A8DF94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "91CCAB0C-C0F8-4619-AAE1-F6F13FF31570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "F2B7CBB3-E037-416B-AD16-9A553D6A4775"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "DE7DDFE1-6A06-477A-AB45-D00053CFA7EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "A35C117A-6EFB-42EB-AD2A-EA7866606927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "40003CBE-792F-4875-9E60-6F1CE0BBAA8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "46A7AA7B-13F2-496A-99ED-1CC13234E8CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "147663CB-B48D-4D89-96BF-F92FF96F347F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "27DBBC83-930A-4ECE-8C1E-47481D881B0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "B987A13D-A363-4DCE-BBA1-E35E81ACBA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "01A5B7F9-FAD2-4C0C-937D-CF1086512130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "F60B4271-F987-4932-86EE-45ED099661E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.0.0", "versionEndExcluding": "16.24.1", "matchCriteriaId": "DE99C3B4-20EC-4AC8-9A0A-C690E2DBED99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.0.0", "versionEndExcluding": "18.10.1", "matchCriteriaId": "C109B569-DE0D-4AE4-A128-239077CCC05F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndExcluding": "19.2.1", "matchCriteriaId": "44E4E3A7-8CB3-491C-98F6-F78345533E3B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/166225/Asterisk-Project-Security-Advisory-AST-2022-004.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/0", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/commit/15663e3f37091069b8c98a7fce680dc04bc8e865", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-2qpg-f6wf-w984", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/15663e3f37091069b8c98a7fce680dc04bc8e865"}}