{"buggy_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Controller;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Backend\\Template\\ModuleTemplateFactory;\nuse TYPO3\\CMS\\Core\\Authentication\\AbstractAuthenticationService;\nuse TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\InvalidPasswordHashException;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\RedirectResponse;\nuse TYPO3\\CMS\\Core\\Http\\Uri;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\nuse TYPO3\\CMS\\Install\\Service\\SessionService;\n\n/**\n * Backend module controller to the Install Tool. Sets an Install Tool session\n * marked as \"initialized by a valid system administrator backend user\" and\n * redirects to the Install Tool entry point.\n *\n * This is a classic backend module that does not interfere with other code\n * within the Install Tool, it can be seen as a facade around Install Tool just\n * to embed the Install Tool in backend.\n *\n * @internal This class is a specific controller implementation and is not considered part of the Public TYPO3 API.\n */\nclass BackendModuleController\n{\n    protected const FLAG_CONFIRMATION_REQUEST = 1;\n    protected const FLAG_INSTALL_TOOL_PASSWORD = 2;\n    protected const ALLOWED_ACTIONS = ['maintenance', 'settings', 'upgrade', 'environment'];\n\n    protected ?SessionService $sessionService = null;\n\n    public function __construct(\n        protected readonly UriBuilder $uriBuilder,\n        protected readonly ModuleTemplateFactory $moduleTemplateFactory\n    ) {\n    }\n\n    /**\n     * Shows and handles backend user session confirmation (\"sudo mode\") for\n     * accessing a particular Install Tool controller (as given in `$targetController`).\n     */\n    public function backendUserConfirmationAction(ServerRequestInterface $request): ResponseInterface\n    {\n        $flags = (int)($request->getQueryParams()['flags'] ?? 0);\n        $targetController = (string)($request->getQueryParams()['targetController'] ?? '');\n        $targetHash = (string)($request->getQueryParams()['targetHash'] ?? '');\n        $expectedTargetHash = GeneralUtility::hmac($targetController, BackendModuleController::class);\n        $flagInstallToolPassword = (bool)($flags & self::FLAG_INSTALL_TOOL_PASSWORD);\n        $flagInvalidPassword = false;\n\n        if (!in_array($targetController, self::ALLOWED_ACTIONS, true)\n            || !hash_equals($expectedTargetHash, $targetHash)) {\n            return new HtmlResponse('', 403);\n        }\n        if ($flags & self::FLAG_CONFIRMATION_REQUEST) {\n            if ($flagInstallToolPassword && $this->verifyInstallToolPassword($request)) {\n                return $this->setAuthorizedAndRedirect($targetController);\n            }\n            if (!$flagInstallToolPassword && $this->verifyBackendUserPassword($request)) {\n                return $this->setAuthorizedAndRedirect($targetController);\n            }\n            $flagInvalidPassword = true;\n        }\n\n        $view = $this->moduleTemplateFactory->create($request);\n        $view->assignMultiple([\n            'flagInvalidPassword' => $flagInvalidPassword,\n            'flagInstallToolPassword' => $flagInstallToolPassword,\n            'passwordModeUri' => $this->getBackendUserConfirmationUri([\n                'targetController' => $targetController,\n                'targetHash' => $targetHash,\n                // current flags, unset FLAG_CONFIRMATION_REQUEST, toggle FLAG_INSTALL_TOOL_PASSWORD\n                'flags' => $flags & ~self::FLAG_CONFIRMATION_REQUEST ^ self::FLAG_INSTALL_TOOL_PASSWORD,\n            ]),\n            'verifyUri' => $this->getBackendUserConfirmationUri([\n                'targetController' => $targetController,\n                'targetHash' => $targetHash,\n                // current flags, add FLAG_CONFIRMATION_REQUEST\n                'flags' => $flags | self::FLAG_CONFIRMATION_REQUEST,\n            ]),\n        ]);\n\n        $view->setModuleName('tools_tools' . $targetController);\n        return $view->renderResponse('BackendModule/BackendUserConfirmation');\n    }\n\n    /**\n     * Initialize session and redirect to \"maintenance\"\n     */\n    public function maintenanceAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('maintenance')\n            ?? $this->setAuthorizedAndRedirect('maintenance');\n    }\n\n    /**\n     * Initialize session and redirect to \"settings\"\n     */\n    public function settingsAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('settings')\n            ?? $this->setAuthorizedAndRedirect('settings');\n    }\n\n    /**\n     * Initialize session and redirect to \"upgrade\"\n     */\n    public function upgradeAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('upgrade')\n            ?? $this->setAuthorizedAndRedirect('upgrade');\n    }\n\n    /**\n     * Initialize session and redirect to \"environment\"\n     */\n    public function environmentAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('environment')\n            ?? $this->setAuthorizedAndRedirect('environment');\n    }\n\n    /**\n     * Creates redirect response to backend user confirmation (if required).\n     */\n    protected function getBackendUserConfirmationRedirect(string $targetController): ?ResponseInterface\n    {\n        if ($this->getSessionService()->isAuthorizedBackendUserSession()) {\n            return null;\n        }\n        if (Environment::getContext()->isDevelopment()) {\n            return null;\n        }\n        $redirectUri = $this->getBackendUserConfirmationUri([\n            'targetController' => $targetController,\n            'targetHash' => GeneralUtility::hmac($targetController, BackendModuleController::class),\n        ]);\n        return new RedirectResponse((string)$redirectUri, 403);\n    }\n\n    protected function getBackendUserConfirmationUri(array $parameters): Uri\n    {\n        return $this->uriBuilder->buildUriFromRoute(\n            'install.backend-user-confirmation',\n            $parameters\n        );\n    }\n\n    /**\n     * Starts / updates the session and redirects to the Install Tool\n     * with given action.\n     */\n    protected function setAuthorizedAndRedirect(string $controller): ResponseInterface\n    {\n        $this->getSessionService()->setAuthorizedBackendSession();\n        $redirectLocation = PathUtility::getAbsoluteWebPath('install.php?install[controller]=' . $controller . '&install[context]=backend');\n        return new RedirectResponse($redirectLocation, 303);\n    }\n\n    /**\n     * Verifies that provided password matches Install Tool password.\n     */\n    protected function verifyInstallToolPassword(ServerRequestInterface $request): bool\n    {\n        $parsedBody = $request->getParsedBody();\n        $password = $parsedBody['confirmationPassword'] ?? null;\n        $installToolPassword = $GLOBALS['TYPO3_CONF_VARS']['BE']['installToolPassword'] ?? null;\n        if (!is_string($password) || empty($installToolPassword)) {\n            return false;\n        }\n\n        try {\n            $hashFactory = GeneralUtility::makeInstance(PasswordHashFactory::class);\n            $hashInstance = $hashFactory->get($installToolPassword, 'BE');\n            return $hashInstance->checkPassword($password, $installToolPassword);\n        } catch (InvalidPasswordHashException $exception) {\n            return false;\n        }\n    }\n\n    /**\n     * Verifies that provided password is actually correct for current backend user\n     * by stepping through authentication chain in `$GLOBALS['BE_USER]`.\n     */\n    protected function verifyBackendUserPassword(ServerRequestInterface $request): bool\n    {\n        $parsedBody = $request->getParsedBody();\n        $password = $parsedBody['confirmationPassword'] ?? null;\n        if (!is_string($password)) {\n            return false;\n        }\n\n        // clone current backend user object to avoid\n        // possible side effects for the real instance\n        $backendUser = clone $this->getBackendUser();\n        $loginData = [\n            'status' => 'sudo-mode',\n            'origin' => BackendModuleController::class,\n            'uname'  => $backendUser->user['username'],\n            'uident' => $password,\n        ];\n        // currently there is no dedicated API to perform authentication\n        // that's why this process partially has to be simulated here\n        $loginData = $backendUser->processLoginData($loginData);\n        $authInfo = $backendUser->getAuthInfoArray();\n\n        $authenticated = false;\n        /** @var AbstractAuthenticationService $service or any other service (sic!) */\n        foreach ($this->getAuthServices($backendUser, $loginData, $authInfo) as $service) {\n            $ret = (int)$service->authUser($backendUser->user);\n            if ($ret <= 0) {\n                return false;\n            }\n            if ($ret >= 200) {\n                return true;\n            }\n            if ($ret < 100) {\n                $authenticated = true;\n                continue;\n            }\n        }\n        return $authenticated;\n    }\n\n    /**\n     * Initializes authentication services to be used in a foreach loop\n     *\n     * @return \\Generator<int, object>\n     */\n    protected function getAuthServices(BackendUserAuthentication $backendUser, array $loginData, array $authInfo): \\Generator\n    {\n        $serviceChain = [];\n        $subType = 'authUserBE';\n        while ($service = GeneralUtility::makeInstanceService('auth', $subType, $serviceChain)) {\n            $serviceChain[] = $service->getServiceKey();\n            if (!is_object($service)) {\n                break;\n            }\n            $service->initAuth($subType, $loginData, $authInfo, $backendUser);\n            yield $service;\n        }\n    }\n\n    protected function getBackendUser(): BackendUserAuthentication\n    {\n        return $GLOBALS['BE_USER'];\n    }\n\n    /**\n     * Install Tool modified sessions meta-data (handler, storage, name) which\n     * conflicts with existing session that for instance.\n     */\n    protected function getSessionService(): SessionService\n    {\n        if ($this->sessionService === null) {\n            $this->sessionService = new SessionService();\n            $this->sessionService->startSession();\n        }\n        return $this->sessionService;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Middleware;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse TYPO3\\CMS\\Core\\Configuration\\ConfigurationManager;\nuse TYPO3\\CMS\\Core\\Configuration\\Features;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\FormProtection\\FormProtectionFactory;\nuse TYPO3\\CMS\\Core\\FormProtection\\InstallToolFormProtection;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\JsonResponse;\nuse TYPO3\\CMS\\Core\\Http\\Security\\ReferrerEnforcer;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessage;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessageQueue;\nuse TYPO3\\CMS\\Core\\Package\\FailsafePackageManager;\nuse TYPO3\\CMS\\Install\\Authentication\\AuthenticationService;\nuse TYPO3\\CMS\\Install\\Controller\\AbstractController;\nuse TYPO3\\CMS\\Install\\Controller\\EnvironmentController;\nuse TYPO3\\CMS\\Install\\Controller\\IconController;\nuse TYPO3\\CMS\\Install\\Controller\\LayoutController;\nuse TYPO3\\CMS\\Install\\Controller\\LoginController;\nuse TYPO3\\CMS\\Install\\Controller\\MaintenanceController;\nuse TYPO3\\CMS\\Install\\Controller\\SettingsController;\nuse TYPO3\\CMS\\Install\\Controller\\UpgradeController;\nuse TYPO3\\CMS\\Install\\Service\\EnableFileService;\nuse TYPO3\\CMS\\Install\\Service\\SessionService;\n\n/**\n * Default middleware for all requests inside the TYPO3 Install Tool, which does a simple hardcoded\n * dispatching to a controller based on the get/post variable.\n * @internal This class is only meant to be used within EXT:install and is not part of the TYPO3 Core API.\n */\nclass Maintenance implements MiddlewareInterface\n{\n    /**\n     * @var FailsafePackageManager\n     */\n    protected $packageManager;\n\n    /**\n     * @var ConfigurationManager\n     */\n    protected $configurationManager;\n\n    /**\n     * @var PasswordHashFactory\n     */\n    protected $passwordHashFactory;\n\n    /**\n     * @var ContainerInterface\n     */\n    private $container;\n\n    /**\n     * @var array List of valid controllers\n     */\n    protected $controllers = [\n        'icon' => IconController::class,\n        'layout' => LayoutController::class,\n        'login' => LoginController::class,\n        'maintenance' => MaintenanceController::class,\n        'settings' => SettingsController::class,\n        'upgrade' => UpgradeController::class,\n        'environment' => EnvironmentController::class,\n    ];\n\n    public function __construct(\n        FailsafePackageManager $packageManager,\n        ConfigurationManager $configurationManager,\n        PasswordHashFactory $passwordHashFactory,\n        ContainerInterface $container\n    ) {\n        $this->packageManager = $packageManager;\n        $this->configurationManager = $configurationManager;\n        $this->passwordHashFactory = $passwordHashFactory;\n        $this->container = $container;\n    }\n\n    /**\n     * Handles an Install Tool request for normal operations\n     *\n     * @param ServerRequestInterface $request\n     * @param RequestHandlerInterface $handler\n     * @return ResponseInterface\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        if (!$this->canHandleRequest($request)) {\n            return $handler->handle($request);\n        }\n\n        $controllerName = $request->getQueryParams()['install']['controller'] ?? 'layout';\n        $actionName = $request->getParsedBody()['install']['action'] ?? $request->getQueryParams()['install']['action'] ?? 'init';\n\n        if ($actionName === 'showEnableInstallToolFile' && EnableFileService::isInstallToolEnableFilePermanent()) {\n            $actionName = 'showLogin';\n        }\n\n        $action = $actionName . 'Action';\n\n        // not session related actions\n        if ($actionName === 'init') {\n            $controller = $this->container->get(LayoutController::class);\n            return $controller->initAction($request);\n        }\n        if ($actionName === 'checkEnableInstallToolFile') {\n            return new JsonResponse([\n                'success' => $this->checkEnableInstallToolFile(),\n            ]);\n        }\n        if ($actionName === 'showEnableInstallToolFile') {\n            $controller = $this->container->get(LoginController::class);\n            return $controller->showEnableInstallToolFileAction($request);\n        }\n        if ($actionName === 'showLogin') {\n            if (!$this->checkEnableInstallToolFile()) {\n                throw new \\RuntimeException('Not authorized', 1505564888);\n            }\n            $controller = $this->container->get(LoginController::class);\n            return $controller->showLoginAction($request);\n        }\n\n        // session related actions\n        $session = new SessionService();\n        if ($actionName === 'preAccessCheck') {\n            $response = new JsonResponse([\n                'installToolLocked' => !$this->checkEnableInstallToolFile(),\n                'isAuthorized' => $session->isAuthorized(),\n            ]);\n        } elseif ($actionName === 'checkLogin') {\n            if (!$this->checkEnableInstallToolFile() && !$session->isAuthorizedBackendUserSession()) {\n                throw new \\RuntimeException('Not authorized', 1505563556);\n            }\n            if ($session->isAuthorized()) {\n                $session->refreshSession();\n                $response = new JsonResponse([\n                    'success' => true,\n                ]);\n            } else {\n                // Session expired, log out user, start new session\n                $session->resetSession();\n                $session->startSession();\n                $response = new JsonResponse([\n                    'success' => false,\n                ]);\n            }\n        } elseif ($actionName === 'login') {\n            $session->initializeSession();\n            if (!$this->checkEnableInstallToolFile()) {\n                throw new \\RuntimeException('Not authorized', 1505567462);\n            }\n            $this->checkSessionToken($request, $session);\n            $this->checkSessionLifetime($session);\n            $password = $request->getParsedBody()['install']['password'] ?? null;\n            $authService = new AuthenticationService($session);\n            if ($authService->loginWithPassword($password, $request)) {\n                $response = new JsonResponse([\n                    'success' => true,\n                ]);\n            } else {\n                if ($password === null || empty($password)) {\n                    $messageQueue = (new FlashMessageQueue('install'))->enqueue(\n                        new FlashMessage('Please enter the install tool password', '', FlashMessage::ERROR)\n                    );\n                } else {\n                    $hashInstance = $this->passwordHashFactory->getDefaultHashInstance('BE');\n                    $hashedPassword = $hashInstance->getHashedPassword($password);\n                    $messageQueue = (new FlashMessageQueue('install'))->enqueue(\n                        new FlashMessage(\n                            'Given password does not match the install tool login password. Calculated hash: ' . $hashedPassword,\n                            '',\n                            FlashMessage::ERROR\n                        )\n                    );\n                }\n                $response = new JsonResponse([\n                    'success' => false,\n                    'status' => $messageQueue,\n                ]);\n            }\n        } elseif ($actionName === 'logout') {\n            if (EnableFileService::installToolEnableFileExists() && !EnableFileService::isInstallToolEnableFilePermanent()) {\n                EnableFileService::removeInstallToolEnableFile();\n            }\n            $formProtection = FormProtectionFactory::get(\n                InstallToolFormProtection::class\n            );\n            $formProtection->clean();\n            $session->destroySession();\n            $response = new JsonResponse([\n                'success' => true,\n            ]);\n        } else {\n            $enforceReferrerResponse = $this->enforceReferrer($request);\n            if ($enforceReferrerResponse instanceof ResponseInterface) {\n                return $enforceReferrerResponse;\n            }\n            $session->initializeSession();\n            if (\n                !$this->checkSessionToken($request, $session)\n                || !$this->checkSessionLifetime($session)\n                || !$session->isAuthorized()\n            ) {\n                return new HtmlResponse('', 403);\n            }\n            $session->refreshSession();\n            if (!array_key_exists($controllerName, $this->controllers)) {\n                throw new \\RuntimeException(\n                    'Unknown controller ' . $controllerName,\n                    1505215756\n                );\n            }\n            $this->packageManager->recreatePackageStatesFileIfMissing();\n            $className = $this->controllers[$controllerName];\n            /** @var AbstractController $controller */\n            $controller = $this->container->get($className);\n            if (!method_exists($controller, $action)) {\n                throw new \\RuntimeException(\n                    'Unknown action method ' . $action . ' in controller ' . $controllerName,\n                    1505216027\n                );\n            }\n            $response = $controller->$action($request);\n        }\n\n        return $response;\n    }\n\n    /**\n     * This request handler can handle any request when not in CLI mode.\n     * Warning: Order of these methods is security relevant and interferes with different access\n     * conditions (new/existing installation). See the single method comments for details.\n     *\n     * @param ServerRequestInterface $request\n     * @return bool Returns always TRUE\n     */\n    protected function canHandleRequest(ServerRequestInterface $request): bool\n    {\n        $basicIntegrity = $this->checkIfEssentialConfigurationExists()\n            && !empty($GLOBALS['TYPO3_CONF_VARS']['BE']['installToolPassword'])\n            && !EnableFileService::isFirstInstallAllowed();\n        if (!$basicIntegrity) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Checks if ENABLE_INSTALL_TOOL exists.\n     *\n     * @return bool\n     */\n    protected function checkEnableInstallToolFile()\n    {\n        return EnableFileService::checkInstallToolEnableFile();\n    }\n\n    /**\n     * Use form protection API to find out if protected POST forms are ok.\n     *\n     * @param ServerRequestInterface $request\n     * @param SessionService $session\n     * @return bool\n     */\n    protected function checkSessionToken(ServerRequestInterface $request, SessionService $session): bool\n    {\n        $postValues = $request->getParsedBody()['install'] ?? null;\n        // no post data is there, so no token check necessary\n        if (empty($postValues)) {\n            return true;\n        }\n        $tokenOk = false;\n        // A token must be given as soon as there is POST data\n        if (isset($postValues['token'])) {\n            $formProtection = FormProtectionFactory::get(\n                InstallToolFormProtection::class\n            );\n            $action = (string)$postValues['action'];\n            if ($action === '') {\n                throw new \\RuntimeException(\n                    'No POST action given for token check',\n                    1369326593\n                );\n            }\n            $tokenOk = $formProtection->validateToken($postValues['token'], 'installTool', $action);\n        }\n        if (!$tokenOk) {\n            $session->resetSession();\n            $session->startSession();\n        }\n        return $tokenOk;\n    }\n\n    /**\n     * Check if session expired.\n     * If the session has expired, the login form is displayed.\n     *\n     * @param SessionService $session\n     * @return bool True if session lifetime is OK\n     */\n    protected function checkSessionLifetime(SessionService $session): bool\n    {\n        $isExpired = $session->isExpired();\n        if ($isExpired) {\n            // Session expired, log out user, start new session\n            $session->resetSession();\n            $session->startSession();\n        }\n        return !$isExpired;\n    }\n\n    /**\n     * Check if LocalConfiguration.php exists (PackageStates is optional)\n     *\n     * @return bool TRUE when the essential configuration is available, otherwise FALSE\n     */\n    protected function checkIfEssentialConfigurationExists(): bool\n    {\n        return file_exists($this->configurationManager->getLocalConfigurationFileLocation());\n    }\n\n    /**\n     * Evaluates HTTP `Referer` header (which is denied by client to be a custom\n     * value) - attempts to ensure the value is given using a HTML client refresh.\n     * see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer\n     *\n     * @param ServerRequestInterface $request\n     * @return ResponseInterface|null\n     */\n    protected function enforceReferrer(ServerRequestInterface $request): ?ResponseInterface\n    {\n        if (!(new Features())->isFeatureEnabled('security.backend.enforceReferrer')) {\n            return null;\n        }\n        return (new ReferrerEnforcer($request))->handle([\n            'flags' => ['refresh-always'],\n            'subject' => 'Install Tool',\n        ]);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessage;\nuse TYPO3\\CMS\\Core\\Security\\BlockSerializationTrait;\nuse TYPO3\\CMS\\Core\\SingletonInterface;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Install\\Exception;\nuse TYPO3\\CMS\\Install\\Service\\Session\\FileSessionHandler;\n\n/**\n * Secure session handling for the install tool.\n *\n * @internal This class is only meant to be used within EXT:install and is not part of the TYPO3 Core API.\n */\nclass SessionService implements SingletonInterface\n{\n    use BlockSerializationTrait;\n\n    /**\n     * the cookie to store the session ID of the install tool\n     *\n     * @var string\n     */\n    private $cookieName = 'Typo3InstallTool';\n\n    /**\n     * time (minutes) to expire an unused session\n     *\n     * @var int\n     */\n    private $expireTimeInMinutes = 15;\n\n    /**\n     * time (minutes) to generate a new session id for our current session\n     *\n     * @var int\n     */\n    private $regenerateSessionIdTime = 5;\n\n    /**\n     * Constructor. Starts PHP session handling in our own private store\n     *\n     * Side-effect: might set a cookie, so must be called before any other output.\n     */\n    public function __construct()\n    {\n        // Register our \"save\" session handler\n        $sessionHandler = GeneralUtility::makeInstance(\n            FileSessionHandler::class,\n            Environment::getVarPath() . '/session',\n            $this->expireTimeInMinutes\n        );\n        session_set_save_handler($sessionHandler);\n        session_name($this->cookieName);\n        ini_set('session.cookie_secure', GeneralUtility::getIndpEnv('TYPO3_SSL') ? 'On' : 'Off');\n        ini_set('session.cookie_httponly', 'On');\n        ini_set('session.cookie_samesite', Cookie::SAMESITE_STRICT);\n        ini_set('session.cookie_path', (string)GeneralUtility::getIndpEnv('TYPO3_SITE_PATH'));\n        // Always call the garbage collector to clean up stale session files\n        ini_set('session.gc_probability', (string)100);\n        ini_set('session.gc_divisor', (string)100);\n        ini_set('session.gc_maxlifetime', (string)($this->expireTimeInMinutes * 2 * 60));\n        if ($this->isSessionAutoStartEnabled()) {\n            $sessionCreationError = 'Error: session.auto-start is enabled.<br />';\n            $sessionCreationError .= 'The PHP option session.auto-start is enabled. Disable this option in php.ini or .htaccess:<br />';\n            $sessionCreationError .= '<pre>php_value session.auto_start Off</pre>';\n            throw new Exception($sessionCreationError, 1294587485);\n        }\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $sessionCreationError = 'Session already started by session_start().<br />';\n            $sessionCreationError .= 'Make sure no installed extension is starting a session in its ext_localconf.php or ext_tables.php.';\n            throw new Exception($sessionCreationError, 1294587486);\n        }\n    }\n\n    public function initializeSession()\n    {\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            return;\n        }\n        session_start();\n    }\n\n    /**\n     * Starts a new session\n     *\n     * @return string|false The session ID\n     */\n    public function startSession()\n    {\n        $this->initializeSession();\n        // check if session is already active\n        if ($_SESSION['active'] ?? false) {\n            return session_id();\n        }\n        $_SESSION['active'] = true;\n        // Be sure to use our own session id, so create a new one\n        return $this->renewSession();\n    }\n\n    /**\n     * Destroys a session\n     */\n    public function destroySession()\n    {\n        if ($this->hasSessionCookie()) {\n            $this->initializeSession();\n            $_SESSION = [];\n            $params = session_get_cookie_params();\n            $cookie = Cookie::create(($sessionName = session_name()) !== false ? $sessionName : $this->cookieName)\n                ->withValue('0')\n                ->withPath($params['path'])\n                ->withDomain($params['domain'])\n                ->withSecure($params['samesite'] === Cookie::SAMESITE_NONE || GeneralUtility::getIndpEnv('TYPO3_SSL'))\n                ->withHttpOnly($params['httponly'])\n                ->withSameSite($params['samesite']);\n\n            header('Set-Cookie: ' . $cookie);\n            session_destroy();\n        }\n    }\n\n    /**\n     * Reset session. Sets _SESSION to empty array.\n     */\n    public function resetSession()\n    {\n        $this->initializeSession();\n        $_SESSION = [];\n        $_SESSION['active'] = false;\n    }\n\n    /**\n     * Generates a new session ID and sends it to the client.\n     *\n     * @return string|false the new session ID\n     */\n    private function renewSession()\n    {\n        // we do not have parallel ajax requests so we can safely remove the old session data\n        session_regenerate_id(true);\n        return session_id();\n    }\n\n    /**\n     * Checks whether whether is session cookie is set\n     *\n     * @return bool\n     */\n    public function hasSessionCookie(): bool\n    {\n        return isset($_COOKIE[$this->cookieName]);\n    }\n\n    /**\n     * Marks this session as an \"authorized\" one (login successful).\n     * Should only be called if:\n     * a) we have a valid session running\n     * b) the \"password\" or some other authorization mechanism really matched\n     */\n    public function setAuthorized()\n    {\n        $_SESSION['authorized'] = true;\n        $_SESSION['lastSessionId'] = time();\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        // Renew the session id to avoid session fixation\n        $this->renewSession();\n    }\n\n    /**\n     * Marks this session as an \"authorized by backend user\" one.\n     * This is called by BackendModuleController from backend context.\n     */\n    public function setAuthorizedBackendSession()\n    {\n        $_SESSION['authorized'] = true;\n        $_SESSION['lastSessionId'] = time();\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        $_SESSION['isBackendSession'] = true;\n        // Renew the session id to avoid session fixation\n        $this->renewSession();\n    }\n\n    /**\n     * Check if we have an already authorized session\n     *\n     * @return bool TRUE if this session has been authorized before (by a correct password)\n     */\n    public function isAuthorized()\n    {\n        if (!$this->hasSessionCookie()) {\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized'])) {\n            return false;\n        }\n        return !$this->isExpired();\n    }\n\n    /**\n     * Check if we have an authorized session from a system maintainer\n     *\n     * @return bool TRUE if this session has been authorized before and initialized by a backend system maintainer\n     */\n    public function isAuthorizedBackendUserSession()\n    {\n        if (!$this->hasSessionCookie()) {\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized']) || empty($_SESSION['isBackendSession'])) {\n            return false;\n        }\n        return !$this->isExpired();\n    }\n\n    /**\n     * Check if our session is expired.\n     * Useful only right after a FALSE \"isAuthorized\" to see if this is the\n     * reason for not being authorized anymore.\n     *\n     * @return bool TRUE if an authorized session exists, but is expired\n     */\n    public function isExpired()\n    {\n        if (!$this->hasSessionCookie()) {\n            // Session never existed, means it is not \"expired\"\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized'])) {\n            // Session never authorized, means it is not \"expired\"\n            return false;\n        }\n        return $_SESSION['expires'] <= time();\n    }\n\n    /**\n     * Refreshes our session information, rising the expire time.\n     * Also generates a new session ID every 5 minutes to minimize the risk of\n     * session hijacking.\n     */\n    public function refreshSession()\n    {\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        if (time() > $_SESSION['lastSessionId'] + $this->regenerateSessionIdTime * 60) {\n            // Renew our session ID\n            $_SESSION['lastSessionId'] = time();\n            $this->renewSession();\n        }\n    }\n\n    /**\n     * Add a message to \"Flash\" message storage.\n     *\n     * @param FlashMessage $message A message to add\n     */\n    public function addMessage(FlashMessage $message)\n    {\n        if (!is_array($_SESSION['messages'])) {\n            $_SESSION['messages'] = [];\n        }\n        $_SESSION['messages'][] = $message;\n    }\n\n    /**\n     * Return stored session messages and flush.\n     *\n     * @return FlashMessage[] Messages\n     */\n    public function getMessagesAndFlush()\n    {\n        $messages = [];\n        if (is_array($_SESSION['messages'])) {\n            $messages = $_SESSION['messages'];\n        }\n        $_SESSION['messages'] = [];\n        return $messages;\n    }\n\n    /**\n     * Check if php session.auto_start is enabled\n     *\n     * @return bool TRUE if session.auto_start is enabled, FALSE if disabled\n     */\n    protected function isSessionAutoStartEnabled()\n    {\n        return $this->getIniValueBoolean('session.auto_start');\n    }\n\n    /**\n     * Cast an on/off php ini value to boolean\n     *\n     * @param string $configOption\n     * @return bool TRUE if the given option is enabled, FALSE if disabled\n     */\n    protected function getIniValueBoolean($configOption)\n    {\n        return filter_var(\n            ini_get($configOption),\n            FILTER_VALIDATE_BOOLEAN,\n            [FILTER_REQUIRE_SCALAR, FILTER_NULL_ON_FAILURE]\n        );\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Tests\\Functional\\Controller;\n\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Backend\\Template\\ModuleTemplateFactory;\nuse TYPO3\\CMS\\Core\\Core\\ApplicationContext;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Install\\Controller\\BackendModuleController;\nuse TYPO3\\TestingFramework\\Core\\Functional\\FunctionalTestCase;\n\nclass BackendModuleControllerTest extends FunctionalTestCase\n{\n    protected bool $initializeDatabase = false;\n\n    protected int $oldErrorReporting;\n\n    public function setUp(): void\n    {\n        parent::setUp();\n        // @todo: The install tool session handler is hardcoded within install tool.\n        //        FileSessionHandler calls session_save_path() which basically can\n        //        be done exactly once per process. After that it throws warnings.\n        //        We can't mitigate this until the install tool session handler is\n        //        refactored and enables us to add a mock here.\n        //        To not disable the tests, we for now suppress warnings in this test.\n        //        Even though the phpunit error handler is before the native PHP handler,\n        //        phpunit currently ignores the warning as well: if (!($errorNumber & error_reporting())) {\n        $this->oldErrorReporting = error_reporting(E_ALL & ~E_WARNING);\n    }\n\n    public function tearDown(): void\n    {\n        error_reporting($this->oldErrorReporting);\n    }\n\n    /**\n     * @test\n     * @dataProvider environmentContextIsRespectedTestDataProvider\n     *\n     * @param string $module\n     */\n    public function environmentContextIsRespectedTest(string $module): void\n    {\n        $subject = new BackendModuleController(\n            $this->get(UriBuilder::class),\n            $this->get(ModuleTemplateFactory::class)\n        );\n        $action = $module . 'Action';\n\n        self::assertIsCallable([$subject, $action]);\n\n        // Ensure we are not in development context\n        self::assertFalse(Environment::getContext()->isDevelopment());\n\n        // Sudo mode is required\n        self::assertEquals(403, $subject->{$action}()->getStatusCode());\n\n        // Initialize environment with development context\n        Environment::initialize(\n            new ApplicationContext('Development'),\n            Environment::isComposerMode(),\n            Environment::isComposerMode(),\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getBackendPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n\n        // Authorized redirect to the install tool is performed, sudo mode is not required\n        $response = $subject->{$action}();\n        self::assertEquals(303, $response->getStatusCode());\n        self::assertNotEmpty($response->getHeader('location'));\n        self::assertStringContainsString(\n            'typo3/install.php?install[controller]=' . $module . '&install[context]=backend',\n            $response->getHeaderLine('location')\n        );\n    }\n\n    public function environmentContextIsRespectedTestDataProvider(): \\Generator\n    {\n        yield 'maintenance module' => ['maintenance'];\n        yield 'settings module' => ['settings'];\n        yield 'upgrade module' => ['upgrade'];\n        yield 'environment module' => ['environment'];\n    }\n}\n"], "fixing_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Controller;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Backend\\Template\\ModuleTemplateFactory;\nuse TYPO3\\CMS\\Core\\Authentication\\AbstractAuthenticationService;\nuse TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\InvalidPasswordHashException;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\RedirectResponse;\nuse TYPO3\\CMS\\Core\\Http\\Uri;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\nuse TYPO3\\CMS\\Install\\Service\\SessionService;\n\n/**\n * Backend module controller to the Install Tool. Sets an Install Tool session\n * marked as \"initialized by a valid system administrator backend user\" and\n * redirects to the Install Tool entry point.\n *\n * This is a classic backend module that does not interfere with other code\n * within the Install Tool, it can be seen as a facade around Install Tool just\n * to embed the Install Tool in backend.\n *\n * @internal This class is a specific controller implementation and is not considered part of the Public TYPO3 API.\n */\nclass BackendModuleController\n{\n    protected const FLAG_CONFIRMATION_REQUEST = 1;\n    protected const FLAG_INSTALL_TOOL_PASSWORD = 2;\n    protected const ALLOWED_ACTIONS = ['maintenance', 'settings', 'upgrade', 'environment'];\n\n    protected ?SessionService $sessionService = null;\n\n    public function __construct(\n        protected readonly UriBuilder $uriBuilder,\n        protected readonly ModuleTemplateFactory $moduleTemplateFactory\n    ) {\n    }\n\n    /**\n     * Shows and handles backend user session confirmation (\"sudo mode\") for\n     * accessing a particular Install Tool controller (as given in `$targetController`).\n     */\n    public function backendUserConfirmationAction(ServerRequestInterface $request): ResponseInterface\n    {\n        $flags = (int)($request->getQueryParams()['flags'] ?? 0);\n        $targetController = (string)($request->getQueryParams()['targetController'] ?? '');\n        $targetHash = (string)($request->getQueryParams()['targetHash'] ?? '');\n        $expectedTargetHash = GeneralUtility::hmac($targetController, BackendModuleController::class);\n        $flagInstallToolPassword = (bool)($flags & self::FLAG_INSTALL_TOOL_PASSWORD);\n        $flagInvalidPassword = false;\n\n        if (!in_array($targetController, self::ALLOWED_ACTIONS, true)\n            || !hash_equals($expectedTargetHash, $targetHash)) {\n            return new HtmlResponse('', 403);\n        }\n        if ($flags & self::FLAG_CONFIRMATION_REQUEST) {\n            if ($flagInstallToolPassword && $this->verifyInstallToolPassword($request)) {\n                return $this->setAuthorizedAndRedirect($targetController);\n            }\n            if (!$flagInstallToolPassword && $this->verifyBackendUserPassword($request)) {\n                return $this->setAuthorizedAndRedirect($targetController);\n            }\n            $flagInvalidPassword = true;\n        }\n\n        $view = $this->moduleTemplateFactory->create($request);\n        $view->assignMultiple([\n            'flagInvalidPassword' => $flagInvalidPassword,\n            'flagInstallToolPassword' => $flagInstallToolPassword,\n            'passwordModeUri' => $this->getBackendUserConfirmationUri([\n                'targetController' => $targetController,\n                'targetHash' => $targetHash,\n                // current flags, unset FLAG_CONFIRMATION_REQUEST, toggle FLAG_INSTALL_TOOL_PASSWORD\n                'flags' => $flags & ~self::FLAG_CONFIRMATION_REQUEST ^ self::FLAG_INSTALL_TOOL_PASSWORD,\n            ]),\n            'verifyUri' => $this->getBackendUserConfirmationUri([\n                'targetController' => $targetController,\n                'targetHash' => $targetHash,\n                // current flags, add FLAG_CONFIRMATION_REQUEST\n                'flags' => $flags | self::FLAG_CONFIRMATION_REQUEST,\n            ]),\n        ]);\n\n        $view->setModuleName('tools_tools' . $targetController);\n        return $view->renderResponse('BackendModule/BackendUserConfirmation');\n    }\n\n    /**\n     * Initialize session and redirect to \"maintenance\"\n     */\n    public function maintenanceAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('maintenance')\n            ?? $this->setAuthorizedAndRedirect('maintenance');\n    }\n\n    /**\n     * Initialize session and redirect to \"settings\"\n     */\n    public function settingsAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('settings')\n            ?? $this->setAuthorizedAndRedirect('settings');\n    }\n\n    /**\n     * Initialize session and redirect to \"upgrade\"\n     */\n    public function upgradeAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('upgrade')\n            ?? $this->setAuthorizedAndRedirect('upgrade');\n    }\n\n    /**\n     * Initialize session and redirect to \"environment\"\n     */\n    public function environmentAction(): ResponseInterface\n    {\n        return $this->getBackendUserConfirmationRedirect('environment')\n            ?? $this->setAuthorizedAndRedirect('environment');\n    }\n\n    /**\n     * Creates redirect response to backend user confirmation (if required).\n     */\n    protected function getBackendUserConfirmationRedirect(string $targetController): ?ResponseInterface\n    {\n        if ($this->getSessionService()->isAuthorizedBackendUserSession()) {\n            return null;\n        }\n        if (Environment::getContext()->isDevelopment()) {\n            return null;\n        }\n        $redirectUri = $this->getBackendUserConfirmationUri([\n            'targetController' => $targetController,\n            'targetHash' => GeneralUtility::hmac($targetController, BackendModuleController::class),\n        ]);\n        return new RedirectResponse((string)$redirectUri, 403);\n    }\n\n    protected function getBackendUserConfirmationUri(array $parameters): Uri\n    {\n        return $this->uriBuilder->buildUriFromRoute(\n            'install.backend-user-confirmation',\n            $parameters\n        );\n    }\n\n    /**\n     * Starts / updates the session and redirects to the Install Tool\n     * with given action.\n     */\n    protected function setAuthorizedAndRedirect(string $controller): ResponseInterface\n    {\n        $userSession = $this->getBackendUser()->getSession();\n        $this->getSessionService()->setAuthorizedBackendSession($userSession);\n        $redirectLocation = PathUtility::getAbsoluteWebPath('install.php?install[controller]=' . $controller . '&install[context]=backend');\n        return new RedirectResponse($redirectLocation, 303);\n    }\n\n    /**\n     * Verifies that provided password matches Install Tool password.\n     */\n    protected function verifyInstallToolPassword(ServerRequestInterface $request): bool\n    {\n        $parsedBody = $request->getParsedBody();\n        $password = $parsedBody['confirmationPassword'] ?? null;\n        $installToolPassword = $GLOBALS['TYPO3_CONF_VARS']['BE']['installToolPassword'] ?? null;\n        if (!is_string($password) || empty($installToolPassword)) {\n            return false;\n        }\n\n        try {\n            $hashFactory = GeneralUtility::makeInstance(PasswordHashFactory::class);\n            $hashInstance = $hashFactory->get($installToolPassword, 'BE');\n            return $hashInstance->checkPassword($password, $installToolPassword);\n        } catch (InvalidPasswordHashException $exception) {\n            return false;\n        }\n    }\n\n    /**\n     * Verifies that provided password is actually correct for current backend user\n     * by stepping through authentication chain in `$GLOBALS['BE_USER]`.\n     */\n    protected function verifyBackendUserPassword(ServerRequestInterface $request): bool\n    {\n        $parsedBody = $request->getParsedBody();\n        $password = $parsedBody['confirmationPassword'] ?? null;\n        if (!is_string($password)) {\n            return false;\n        }\n\n        // clone current backend user object to avoid\n        // possible side effects for the real instance\n        $backendUser = clone $this->getBackendUser();\n        $loginData = [\n            'status' => 'sudo-mode',\n            'origin' => BackendModuleController::class,\n            'uname'  => $backendUser->user['username'],\n            'uident' => $password,\n        ];\n        // currently there is no dedicated API to perform authentication\n        // that's why this process partially has to be simulated here\n        $loginData = $backendUser->processLoginData($loginData);\n        $authInfo = $backendUser->getAuthInfoArray();\n\n        $authenticated = false;\n        /** @var AbstractAuthenticationService $service or any other service (sic!) */\n        foreach ($this->getAuthServices($backendUser, $loginData, $authInfo) as $service) {\n            $ret = (int)$service->authUser($backendUser->user);\n            if ($ret <= 0) {\n                return false;\n            }\n            if ($ret >= 200) {\n                return true;\n            }\n            if ($ret < 100) {\n                $authenticated = true;\n                continue;\n            }\n        }\n        return $authenticated;\n    }\n\n    /**\n     * Initializes authentication services to be used in a foreach loop\n     *\n     * @return \\Generator<int, object>\n     */\n    protected function getAuthServices(BackendUserAuthentication $backendUser, array $loginData, array $authInfo): \\Generator\n    {\n        $serviceChain = [];\n        $subType = 'authUserBE';\n        while ($service = GeneralUtility::makeInstanceService('auth', $subType, $serviceChain)) {\n            $serviceChain[] = $service->getServiceKey();\n            if (!is_object($service)) {\n                break;\n            }\n            $service->initAuth($subType, $loginData, $authInfo, $backendUser);\n            yield $service;\n        }\n    }\n\n    protected function getBackendUser(): BackendUserAuthentication\n    {\n        return $GLOBALS['BE_USER'];\n    }\n\n    /**\n     * Install Tool modified sessions meta-data (handler, storage, name) which\n     * conflicts with existing session that for instance.\n     */\n    protected function getSessionService(): SessionService\n    {\n        if ($this->sessionService === null) {\n            $this->sessionService = new SessionService();\n            $this->sessionService->startSession();\n        }\n        return $this->sessionService;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Middleware;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse TYPO3\\CMS\\Core\\Configuration\\ConfigurationManager;\nuse TYPO3\\CMS\\Core\\Configuration\\Features;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\FormProtection\\FormProtectionFactory;\nuse TYPO3\\CMS\\Core\\FormProtection\\InstallToolFormProtection;\nuse TYPO3\\CMS\\Core\\Http\\HtmlResponse;\nuse TYPO3\\CMS\\Core\\Http\\JsonResponse;\nuse TYPO3\\CMS\\Core\\Http\\Security\\ReferrerEnforcer;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessage;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessageQueue;\nuse TYPO3\\CMS\\Core\\Package\\FailsafePackageManager;\nuse TYPO3\\CMS\\Install\\Authentication\\AuthenticationService;\nuse TYPO3\\CMS\\Install\\Controller\\AbstractController;\nuse TYPO3\\CMS\\Install\\Controller\\EnvironmentController;\nuse TYPO3\\CMS\\Install\\Controller\\IconController;\nuse TYPO3\\CMS\\Install\\Controller\\LayoutController;\nuse TYPO3\\CMS\\Install\\Controller\\LoginController;\nuse TYPO3\\CMS\\Install\\Controller\\MaintenanceController;\nuse TYPO3\\CMS\\Install\\Controller\\SettingsController;\nuse TYPO3\\CMS\\Install\\Controller\\UpgradeController;\nuse TYPO3\\CMS\\Install\\Service\\EnableFileService;\nuse TYPO3\\CMS\\Install\\Service\\SessionService;\n\n/**\n * Default middleware for all requests inside the TYPO3 Install Tool, which does a simple hardcoded\n * dispatching to a controller based on the get/post variable.\n * @internal This class is only meant to be used within EXT:install and is not part of the TYPO3 Core API.\n */\nclass Maintenance implements MiddlewareInterface\n{\n    /**\n     * @var FailsafePackageManager\n     */\n    protected $packageManager;\n\n    /**\n     * @var ConfigurationManager\n     */\n    protected $configurationManager;\n\n    /**\n     * @var PasswordHashFactory\n     */\n    protected $passwordHashFactory;\n\n    /**\n     * @var ContainerInterface\n     */\n    private $container;\n\n    /**\n     * @var array List of valid controllers\n     */\n    protected $controllers = [\n        'icon' => IconController::class,\n        'layout' => LayoutController::class,\n        'login' => LoginController::class,\n        'maintenance' => MaintenanceController::class,\n        'settings' => SettingsController::class,\n        'upgrade' => UpgradeController::class,\n        'environment' => EnvironmentController::class,\n    ];\n\n    public function __construct(\n        FailsafePackageManager $packageManager,\n        ConfigurationManager $configurationManager,\n        PasswordHashFactory $passwordHashFactory,\n        ContainerInterface $container\n    ) {\n        $this->packageManager = $packageManager;\n        $this->configurationManager = $configurationManager;\n        $this->passwordHashFactory = $passwordHashFactory;\n        $this->container = $container;\n    }\n\n    /**\n     * Handles an Install Tool request for normal operations\n     *\n     * @param ServerRequestInterface $request\n     * @param RequestHandlerInterface $handler\n     * @return ResponseInterface\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        if (!$this->canHandleRequest($request)) {\n            return $handler->handle($request);\n        }\n\n        $controllerName = $request->getQueryParams()['install']['controller'] ?? 'layout';\n        $actionName = $request->getParsedBody()['install']['action'] ?? $request->getQueryParams()['install']['action'] ?? 'init';\n\n        if ($actionName === 'showEnableInstallToolFile' && EnableFileService::isInstallToolEnableFilePermanent()) {\n            $actionName = 'showLogin';\n        }\n\n        $action = $actionName . 'Action';\n\n        // not session related actions\n        if ($actionName === 'init') {\n            $controller = $this->container->get(LayoutController::class);\n            return $controller->initAction($request);\n        }\n        if ($actionName === 'checkEnableInstallToolFile') {\n            return new JsonResponse([\n                'success' => $this->checkEnableInstallToolFile(),\n            ]);\n        }\n        if ($actionName === 'showEnableInstallToolFile') {\n            $controller = $this->container->get(LoginController::class);\n            return $controller->showEnableInstallToolFileAction($request);\n        }\n        if ($actionName === 'showLogin') {\n            if (!$this->checkEnableInstallToolFile()) {\n                throw new \\RuntimeException('Not authorized', 1505564888);\n            }\n            $controller = $this->container->get(LoginController::class);\n            return $controller->showLoginAction($request);\n        }\n\n        // session related actions\n        $session = new SessionService();\n\n        // the backend user has an active session but the admin / maintainer\n        // rights have been revoked or the user was disabled or deleted in the meantime\n        if ($session->isAuthorizedBackendUserSession() && !$session->hasActiveBackendUserRoleAndSession()) {\n            // log out the user and destroy the session\n            $session->resetSession();\n            $session->destroySession();\n            $formProtection = FormProtectionFactory::get(\n                InstallToolFormProtection::class\n            );\n            $formProtection->clean();\n\n            return new HtmlResponse('', 403);\n        }\n\n        if ($actionName === 'preAccessCheck') {\n            $response = new JsonResponse([\n                'installToolLocked' => !$this->checkEnableInstallToolFile(),\n                'isAuthorized' => $session->isAuthorized(),\n            ]);\n        } elseif ($actionName === 'checkLogin') {\n            if (!$this->checkEnableInstallToolFile() && !$session->isAuthorizedBackendUserSession()) {\n                throw new \\RuntimeException('Not authorized', 1505563556);\n            }\n            if ($session->isAuthorized()) {\n                $session->refreshSession();\n                $response = new JsonResponse([\n                    'success' => true,\n                ]);\n            } else {\n                // Session expired, log out user, start new session\n                $session->resetSession();\n                $session->startSession();\n                $response = new JsonResponse([\n                    'success' => false,\n                ]);\n            }\n        } elseif ($actionName === 'login') {\n            $session->initializeSession();\n            if (!$this->checkEnableInstallToolFile()) {\n                throw new \\RuntimeException('Not authorized', 1505567462);\n            }\n            $this->checkSessionToken($request, $session);\n            $this->checkSessionLifetime($session);\n            $password = $request->getParsedBody()['install']['password'] ?? null;\n            $authService = new AuthenticationService($session);\n            if ($authService->loginWithPassword($password, $request)) {\n                $response = new JsonResponse([\n                    'success' => true,\n                ]);\n            } else {\n                if ($password === null || empty($password)) {\n                    $messageQueue = (new FlashMessageQueue('install'))->enqueue(\n                        new FlashMessage('Please enter the install tool password', '', FlashMessage::ERROR)\n                    );\n                } else {\n                    $hashInstance = $this->passwordHashFactory->getDefaultHashInstance('BE');\n                    $hashedPassword = $hashInstance->getHashedPassword($password);\n                    $messageQueue = (new FlashMessageQueue('install'))->enqueue(\n                        new FlashMessage(\n                            'Given password does not match the install tool login password. Calculated hash: ' . $hashedPassword,\n                            '',\n                            FlashMessage::ERROR\n                        )\n                    );\n                }\n                $response = new JsonResponse([\n                    'success' => false,\n                    'status' => $messageQueue,\n                ]);\n            }\n        } elseif ($actionName === 'logout') {\n            if (EnableFileService::installToolEnableFileExists() && !EnableFileService::isInstallToolEnableFilePermanent()) {\n                EnableFileService::removeInstallToolEnableFile();\n            }\n            $formProtection = FormProtectionFactory::get(\n                InstallToolFormProtection::class\n            );\n            $formProtection->clean();\n            $session->destroySession();\n            $response = new JsonResponse([\n                'success' => true,\n            ]);\n        } else {\n            $enforceReferrerResponse = $this->enforceReferrer($request);\n            if ($enforceReferrerResponse instanceof ResponseInterface) {\n                return $enforceReferrerResponse;\n            }\n            $session->initializeSession();\n            if (\n                !$this->checkSessionToken($request, $session)\n                || !$this->checkSessionLifetime($session)\n                || !$session->isAuthorized()\n            ) {\n                return new HtmlResponse('', 403);\n            }\n            $session->refreshSession();\n            if (!array_key_exists($controllerName, $this->controllers)) {\n                throw new \\RuntimeException(\n                    'Unknown controller ' . $controllerName,\n                    1505215756\n                );\n            }\n            $this->packageManager->recreatePackageStatesFileIfMissing();\n            $className = $this->controllers[$controllerName];\n            /** @var AbstractController $controller */\n            $controller = $this->container->get($className);\n            if (!method_exists($controller, $action)) {\n                throw new \\RuntimeException(\n                    'Unknown action method ' . $action . ' in controller ' . $controllerName,\n                    1505216027\n                );\n            }\n            $response = $controller->$action($request);\n        }\n\n        return $response;\n    }\n\n    /**\n     * This request handler can handle any request when not in CLI mode.\n     * Warning: Order of these methods is security relevant and interferes with different access\n     * conditions (new/existing installation). See the single method comments for details.\n     *\n     * @param ServerRequestInterface $request\n     * @return bool Returns always TRUE\n     */\n    protected function canHandleRequest(ServerRequestInterface $request): bool\n    {\n        $basicIntegrity = $this->checkIfEssentialConfigurationExists()\n            && !empty($GLOBALS['TYPO3_CONF_VARS']['BE']['installToolPassword'])\n            && !EnableFileService::isFirstInstallAllowed();\n        if (!$basicIntegrity) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Checks if ENABLE_INSTALL_TOOL exists.\n     *\n     * @return bool\n     */\n    protected function checkEnableInstallToolFile()\n    {\n        return EnableFileService::checkInstallToolEnableFile();\n    }\n\n    /**\n     * Use form protection API to find out if protected POST forms are ok.\n     *\n     * @param ServerRequestInterface $request\n     * @param SessionService $session\n     * @return bool\n     */\n    protected function checkSessionToken(ServerRequestInterface $request, SessionService $session): bool\n    {\n        $postValues = $request->getParsedBody()['install'] ?? null;\n        // no post data is there, so no token check necessary\n        if (empty($postValues)) {\n            return true;\n        }\n        $tokenOk = false;\n        // A token must be given as soon as there is POST data\n        if (isset($postValues['token'])) {\n            $formProtection = FormProtectionFactory::get(\n                InstallToolFormProtection::class\n            );\n            $action = (string)$postValues['action'];\n            if ($action === '') {\n                throw new \\RuntimeException(\n                    'No POST action given for token check',\n                    1369326593\n                );\n            }\n            $tokenOk = $formProtection->validateToken($postValues['token'], 'installTool', $action);\n        }\n        if (!$tokenOk) {\n            $session->resetSession();\n            $session->startSession();\n        }\n        return $tokenOk;\n    }\n\n    /**\n     * Check if session expired.\n     * If the session has expired, the login form is displayed.\n     *\n     * @param SessionService $session\n     * @return bool True if session lifetime is OK\n     */\n    protected function checkSessionLifetime(SessionService $session): bool\n    {\n        $isExpired = $session->isExpired();\n        if ($isExpired) {\n            // Session expired, log out user, start new session\n            $session->resetSession();\n            $session->startSession();\n        }\n        return !$isExpired;\n    }\n\n    /**\n     * Check if LocalConfiguration.php exists (PackageStates is optional)\n     *\n     * @return bool TRUE when the essential configuration is available, otherwise FALSE\n     */\n    protected function checkIfEssentialConfigurationExists(): bool\n    {\n        return file_exists($this->configurationManager->getLocalConfigurationFileLocation());\n    }\n\n    /**\n     * Evaluates HTTP `Referer` header (which is denied by client to be a custom\n     * value) - attempts to ensure the value is given using a HTML client refresh.\n     * see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer\n     *\n     * @param ServerRequestInterface $request\n     * @return ResponseInterface|null\n     */\n    protected function enforceReferrer(ServerRequestInterface $request): ?ResponseInterface\n    {\n        if (!(new Features())->isFeatureEnabled('security.backend.enforceReferrer')) {\n            return null;\n        }\n        return (new ReferrerEnforcer($request))->handle([\n            'flags' => ['refresh-always'],\n            'subject' => 'Install Tool',\n        ]);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Database\\ConnectionPool;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\DefaultRestrictionContainer;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\RootLevelRestriction;\nuse TYPO3\\CMS\\Core\\Messaging\\FlashMessage;\nuse TYPO3\\CMS\\Core\\Security\\BlockSerializationTrait;\nuse TYPO3\\CMS\\Core\\Session\\Backend\\HashableSessionBackendInterface;\nuse TYPO3\\CMS\\Core\\Session\\Backend\\SessionBackendInterface;\nuse TYPO3\\CMS\\Core\\Session\\SessionManager;\nuse TYPO3\\CMS\\Core\\Session\\UserSession;\nuse TYPO3\\CMS\\Core\\SingletonInterface;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Install\\Exception;\nuse TYPO3\\CMS\\Install\\Service\\Session\\FileSessionHandler;\n\n/**\n * Secure session handling for the install tool.\n *\n * @internal This class is only meant to be used within EXT:install and is not part of the TYPO3 Core API.\n */\nclass SessionService implements SingletonInterface\n{\n    use BlockSerializationTrait;\n\n    /**\n     * the cookie to store the session ID of the install tool\n     *\n     * @var string\n     */\n    private $cookieName = 'Typo3InstallTool';\n\n    /**\n     * time (minutes) to expire an unused session\n     *\n     * @var int\n     */\n    private $expireTimeInMinutes = 15;\n\n    /**\n     * time (minutes) to generate a new session id for our current session\n     *\n     * @var int\n     */\n    private $regenerateSessionIdTime = 5;\n\n    /**\n     * Constructor. Starts PHP session handling in our own private store\n     *\n     * Side-effect: might set a cookie, so must be called before any other output.\n     */\n    public function __construct()\n    {\n        // Register our \"save\" session handler\n        $sessionHandler = GeneralUtility::makeInstance(\n            FileSessionHandler::class,\n            Environment::getVarPath() . '/session',\n            $this->expireTimeInMinutes\n        );\n        session_set_save_handler($sessionHandler);\n        session_name($this->cookieName);\n        ini_set('session.cookie_secure', GeneralUtility::getIndpEnv('TYPO3_SSL') ? 'On' : 'Off');\n        ini_set('session.cookie_httponly', 'On');\n        ini_set('session.cookie_samesite', Cookie::SAMESITE_STRICT);\n        ini_set('session.cookie_path', (string)GeneralUtility::getIndpEnv('TYPO3_SITE_PATH'));\n        // Always call the garbage collector to clean up stale session files\n        ini_set('session.gc_probability', (string)100);\n        ini_set('session.gc_divisor', (string)100);\n        ini_set('session.gc_maxlifetime', (string)($this->expireTimeInMinutes * 2 * 60));\n        if ($this->isSessionAutoStartEnabled()) {\n            $sessionCreationError = 'Error: session.auto-start is enabled.<br />';\n            $sessionCreationError .= 'The PHP option session.auto-start is enabled. Disable this option in php.ini or .htaccess:<br />';\n            $sessionCreationError .= '<pre>php_value session.auto_start Off</pre>';\n            throw new Exception($sessionCreationError, 1294587485);\n        }\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $sessionCreationError = 'Session already started by session_start().<br />';\n            $sessionCreationError .= 'Make sure no installed extension is starting a session in its ext_localconf.php or ext_tables.php.';\n            throw new Exception($sessionCreationError, 1294587486);\n        }\n    }\n\n    public function initializeSession()\n    {\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            return;\n        }\n        session_start();\n    }\n\n    /**\n     * Starts a new session\n     *\n     * @return string|false The session ID\n     */\n    public function startSession()\n    {\n        $this->initializeSession();\n        // check if session is already active\n        if ($_SESSION['active'] ?? false) {\n            return session_id();\n        }\n        $_SESSION['active'] = true;\n        // Be sure to use our own session id, so create a new one\n        return $this->renewSession();\n    }\n\n    /**\n     * Destroys a session\n     */\n    public function destroySession()\n    {\n        if ($this->hasSessionCookie()) {\n            $this->initializeSession();\n            $_SESSION = [];\n            $params = session_get_cookie_params();\n            $cookie = Cookie::create(($sessionName = session_name()) !== false ? $sessionName : $this->cookieName)\n                ->withValue('0')\n                ->withPath($params['path'])\n                ->withDomain($params['domain'])\n                ->withSecure($params['samesite'] === Cookie::SAMESITE_NONE || GeneralUtility::getIndpEnv('TYPO3_SSL'))\n                ->withHttpOnly($params['httponly'])\n                ->withSameSite($params['samesite']);\n\n            header('Set-Cookie: ' . $cookie);\n            session_destroy();\n        }\n    }\n\n    /**\n     * Reset session. Sets _SESSION to empty array.\n     */\n    public function resetSession()\n    {\n        $this->initializeSession();\n        $_SESSION = [];\n        $_SESSION['active'] = false;\n    }\n\n    /**\n     * Generates a new session ID and sends it to the client.\n     *\n     * @return string|false the new session ID\n     */\n    private function renewSession()\n    {\n        // we do not have parallel ajax requests so we can safely remove the old session data\n        session_regenerate_id(true);\n        return session_id();\n    }\n\n    /**\n     * Checks whether whether is session cookie is set\n     *\n     * @return bool\n     */\n    public function hasSessionCookie(): bool\n    {\n        return isset($_COOKIE[$this->cookieName]);\n    }\n\n    /**\n     * Marks this session as an \"authorized\" one (login successful).\n     * Should only be called if:\n     * a) we have a valid session running\n     * b) the \"password\" or some other authorization mechanism really matched\n     */\n    public function setAuthorized()\n    {\n        $_SESSION['authorized'] = true;\n        $_SESSION['lastSessionId'] = time();\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        // Renew the session id to avoid session fixation\n        $this->renewSession();\n    }\n\n    /**\n     * Marks this session as an \"authorized by backend user\" one.\n     * This is called by BackendModuleController from backend context.\n     *\n     * @param UserSession $userSession session of the current backend user\n     */\n    public function setAuthorizedBackendSession(UserSession $userSession)\n    {\n        $nonce = bin2hex(random_bytes(20));\n        $sessionBackend = $this->getBackendUserSessionBackend();\n        // use hash mechanism of session backend, or pass plain value through generic hmac\n        $sessionHmac = $sessionBackend instanceof HashableSessionBackendInterface\n            ? $sessionBackend->hash($userSession->getIdentifier())\n            : hash_hmac('sha256', $userSession->getIdentifier(), $nonce);\n\n        $_SESSION['authorized'] = true;\n        $_SESSION['lastSessionId'] = time();\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        $_SESSION['isBackendSession'] = true;\n        $_SESSION['backendUserSession'] = [\n            'nonce' => $nonce,\n            'userId' => $userSession->getUserId(),\n            'hmac' => $sessionHmac,\n        ];\n        // Renew the session id to avoid session fixation\n        $this->renewSession();\n    }\n\n    /**\n     * Check if we have an already authorized session\n     *\n     * @return bool TRUE if this session has been authorized before (by a correct password)\n     */\n    public function isAuthorized()\n    {\n        if (!$this->hasSessionCookie()) {\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized'])) {\n            return false;\n        }\n        return !$this->isExpired();\n    }\n\n    /**\n     * Check if we have an authorized session from a system maintainer\n     *\n     * @return bool TRUE if this session has been authorized before and initialized by a backend system maintainer\n     */\n    public function isAuthorizedBackendUserSession(): bool\n    {\n        if (!$this->hasSessionCookie()) {\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized']) || empty($_SESSION['isBackendSession'])) {\n            return false;\n        }\n        return !$this->isExpired();\n    }\n\n    /**\n     * Evaluates whether the backend user that initiated this admin tool session,\n     * has an active role (is still admin & system maintainer) and has an active backend user interface session.\n     *\n     * @return bool whether the backend user has an active role and backend user interface session\n     */\n    public function hasActiveBackendUserRoleAndSession(): bool\n    {\n        // @see \\TYPO3\\CMS\\Install\\Controller\\BackendModuleController::setAuthorizedAndRedirect()\n        $backendUserSession = $this->getBackendUserSession();\n        $backendUserRecord = $this->getBackendUserRecord($backendUserSession['userId']);\n        if ($backendUserRecord === null || empty($backendUserRecord['uid'])) {\n            return false;\n        }\n        $isAdmin = (($backendUserRecord['admin'] ?? 0) & 1) === 1;\n        $systemMaintainers = array_map('intval', $GLOBALS['TYPO3_CONF_VARS']['SYS']['systemMaintainers'] ?? []);\n        // stop here, in case the current admin tool session does not belong to a backend user having admin & maintainer privileges\n        if (!$isAdmin || !in_array((int)$backendUserRecord['uid'], $systemMaintainers, true)) {\n            return false;\n        }\n\n        $sessionBackend = $this->getBackendUserSessionBackend();\n        foreach ($sessionBackend->getAll() as $sessionRecord) {\n            $sessionUserId = (int)($sessionRecord['ses_userid'] ?? 0);\n            // skip, in case backend user id does not match\n            if ($backendUserSession['userId'] !== $sessionUserId) {\n                continue;\n            }\n            $sessionId = (string)($sessionRecord['ses_id'] ?? '');\n            // use persisted hashed `ses_id` directly, or pass through hmac for plain values\n            $sessionHmac = $sessionBackend instanceof HashableSessionBackendInterface\n                ? $sessionId\n                : hash_hmac('sha256', $sessionId, $backendUserSession['nonce']);\n            // skip, in case backend user session id does not match\n            if ($backendUserSession['hmac'] !== $sessionHmac) {\n                continue;\n            }\n            // backend user id and session id matched correctly\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if our session is expired.\n     * Useful only right after a FALSE \"isAuthorized\" to see if this is the\n     * reason for not being authorized anymore.\n     *\n     * @return bool TRUE if an authorized session exists, but is expired\n     */\n    public function isExpired()\n    {\n        if (!$this->hasSessionCookie()) {\n            // Session never existed, means it is not \"expired\"\n            return false;\n        }\n        $this->initializeSession();\n        if (empty($_SESSION['authorized'])) {\n            // Session never authorized, means it is not \"expired\"\n            return false;\n        }\n        return $_SESSION['expires'] <= time();\n    }\n\n    /**\n     * Refreshes our session information, rising the expire time.\n     * Also generates a new session ID every 5 minutes to minimize the risk of\n     * session hijacking.\n     */\n    public function refreshSession()\n    {\n        $_SESSION['tstamp'] = time();\n        $_SESSION['expires'] = time() + $this->expireTimeInMinutes * 60;\n        if (time() > $_SESSION['lastSessionId'] + $this->regenerateSessionIdTime * 60) {\n            // Renew our session ID\n            $_SESSION['lastSessionId'] = time();\n            $this->renewSession();\n        }\n    }\n\n    /**\n     * Add a message to \"Flash\" message storage.\n     *\n     * @param FlashMessage $message A message to add\n     */\n    public function addMessage(FlashMessage $message)\n    {\n        if (!is_array($_SESSION['messages'])) {\n            $_SESSION['messages'] = [];\n        }\n        $_SESSION['messages'][] = $message;\n    }\n\n    /**\n     * Return stored session messages and flush.\n     *\n     * @return FlashMessage[] Messages\n     */\n    public function getMessagesAndFlush()\n    {\n        $messages = [];\n        if (is_array($_SESSION['messages'])) {\n            $messages = $_SESSION['messages'];\n        }\n        $_SESSION['messages'] = [];\n        return $messages;\n    }\n\n    /**\n     * @return array{userId: int, nonce: string, hmac: string} backend user session references\n     */\n    public function getBackendUserSession(): array\n    {\n        if (empty($_SESSION['backendUserSession'])) {\n            throw new Exception(\n                'The backend user session is only available if invoked via the backend user interface.',\n                1624879295\n            );\n        }\n        return $_SESSION['backendUserSession'];\n    }\n\n    /**\n     * Check if php session.auto_start is enabled\n     *\n     * @return bool TRUE if session.auto_start is enabled, FALSE if disabled\n     */\n    protected function isSessionAutoStartEnabled()\n    {\n        return $this->getIniValueBoolean('session.auto_start');\n    }\n\n    /**\n     * Cast an on/off php ini value to boolean\n     *\n     * @param string $configOption\n     * @return bool TRUE if the given option is enabled, FALSE if disabled\n     */\n    protected function getIniValueBoolean($configOption)\n    {\n        return filter_var(\n            ini_get($configOption),\n            FILTER_VALIDATE_BOOLEAN,\n            [FILTER_REQUIRE_SCALAR, FILTER_NULL_ON_FAILURE]\n        );\n    }\n\n    /**\n     * Fetching a user record with uid=$uid.\n     * Functionally similar to TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication::setBeUserByUid().\n     *\n     * @param int $uid The UID of the backend user\n     * @return array<string, int>|null The backend user record or NULL\n     */\n    protected function getBackendUserRecord(int $uid): ?array\n    {\n        $restrictionContainer = GeneralUtility::makeInstance(DefaultRestrictionContainer::class);\n        $restrictionContainer->add(GeneralUtility::makeInstance(RootLevelRestriction::class, ['be_users']));\n\n        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('be_users');\n        $queryBuilder->setRestrictions($restrictionContainer);\n        $queryBuilder->select('uid', 'admin')\n            ->from('be_users')\n            ->where($queryBuilder->expr()->eq('uid', $queryBuilder->createNamedParameter($uid, \\PDO::PARAM_INT)));\n\n        $resetBeUsersTca = false;\n        if (!isset($GLOBALS['TCA']['be_users'])) {\n            // The admin tool intentionally does not load any TCA information at this time.\n            // The database restictions, needs the enablecolumns TCA information\n            // for 'be_users' to load the user correctly.\n            // That is why this part of the TCA ($GLOBALS['TCA']['be_users']['ctrl']['enablecolumns'])\n            // is simulated.\n            // The simulation state will be removed later to avoid unexpected side effects.\n            $GLOBALS['TCA']['be_users']['ctrl']['enablecolumns'] = [\n                'rootLevel' => 1,\n                'deleted' => 'deleted',\n                'disabled' => 'disable',\n                'starttime' => 'starttime',\n                'endtime' => 'endtime',\n            ];\n            $resetBeUsersTca = true;\n        }\n        $result = $queryBuilder->executeQuery()->fetchAssociative();\n        if ($resetBeUsersTca) {\n            unset($GLOBALS['TCA']['be_users']);\n        }\n\n        return is_array($result) ? $result : null;\n    }\n\n    protected function getBackendUserSessionBackend(): SessionBackendInterface\n    {\n        return GeneralUtility::makeInstance(SessionManager::class)->getSessionBackend('BE');\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Install\\Tests\\Functional\\Controller;\n\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Backend\\Template\\ModuleTemplateFactory;\nuse TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Core\\ApplicationContext;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Install\\Controller\\BackendModuleController;\nuse TYPO3\\TestingFramework\\Core\\Functional\\FunctionalTestCase;\n\nclass BackendModuleControllerTest extends FunctionalTestCase\n{\n    protected bool $initializeDatabase = false;\n\n    protected int $oldErrorReporting;\n\n    public function setUp(): void\n    {\n        parent::setUp();\n        // @todo: The install tool session handler is hardcoded within install tool.\n        //        FileSessionHandler calls session_save_path() which basically can\n        //        be done exactly once per process. After that it throws warnings.\n        //        We can't mitigate this until the install tool session handler is\n        //        refactored and enables us to add a mock here.\n        //        To not disable the tests, we for now suppress warnings in this test.\n        //        Even though the phpunit error handler is before the native PHP handler,\n        //        phpunit currently ignores the warning as well: if (!($errorNumber & error_reporting())) {\n        $this->oldErrorReporting = error_reporting(E_ALL & ~E_WARNING);\n    }\n\n    public function tearDown(): void\n    {\n        error_reporting($this->oldErrorReporting);\n    }\n\n    /**\n     * @test\n     * @dataProvider environmentContextIsRespectedTestDataProvider\n     *\n     * @param string $module\n     */\n    public function environmentContextIsRespectedTest(string $module): void\n    {\n        $subject = new BackendModuleController(\n            $this->get(UriBuilder::class),\n            $this->get(ModuleTemplateFactory::class)\n        );\n        $action = $module . 'Action';\n\n        self::assertIsCallable([$subject, $action]);\n\n        // Ensure we are not in development context\n        self::assertFalse(Environment::getContext()->isDevelopment());\n\n        // Sudo mode is required\n        self::assertEquals(403, $subject->{$action}()->getStatusCode());\n\n        // Initialize environment with development context\n        Environment::initialize(\n            new ApplicationContext('Development'),\n            Environment::isComposerMode(),\n            Environment::isComposerMode(),\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getBackendPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n\n        // Authorized redirect to the admin tool is performed\n        // sudo mode is not required (due to development context)\n        $GLOBALS['BE_USER'] = new BackendUserAuthentication();\n        // using anonymous user session, which is fine for this test case\n        $GLOBALS['BE_USER']->initializeUserSessionManager();\n        $GLOBALS['BE_USER']->user = ['uid' => 1];\n\n        $response = $subject->{$action}();\n        self::assertEquals(303, $response->getStatusCode());\n        self::assertNotEmpty($response->getHeader('location'));\n        self::assertStringContainsString(\n            'typo3/install.php?install[controller]=' . $module . '&install[context]=backend',\n            $response->getHeaderLine('location')\n        );\n    }\n\n    public function environmentContextIsRespectedTestDataProvider(): \\Generator\n    {\n        yield 'maintenance module' => ['maintenance'];\n        yield 'settings module' => ['settings'];\n        yield 'upgrade module' => ['upgrade'];\n        yield 'environment module' => ['environment'];\n    }\n}\n"], "filenames": ["typo3/sysext/install/Classes/Controller/BackendModuleController.php", "typo3/sysext/install/Classes/Middleware/Maintenance.php", "typo3/sysext/install/Classes/Service/SessionService.php", "typo3/sysext/install/Tests/Functional/Controller/BackendModuleControllerTest.php"], "buggy_code_start_loc": [178, 145, 19, 21], "buggy_code_end_loc": [179, 145, 325, 88], "fixing_code_start_loc": [178, 146, 20, 22], "fixing_code_end_loc": [180, 161, 452, 95], "type": "CWE-613", "message": "TYPO3 is an open source web content management system. Prior to versions 9.5.34 ELTS, 10.4.29, and 11.5.11, Admin Tool sessions initiated via the TYPO3 backend user interface had not been revoked even if the corresponding user account was degraded to lower permissions or disabled completely. This way, sessions in the admin tool theoretically could have been prolonged without any limit. TYPO3 versions 9.5.34 ELTS, 10.4.29, and 11.5.11 contain a fix for the problem.", "other": {"cve": {"id": "CVE-2022-31050", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-14T21:15:16.247", "lastModified": "2022-06-23T13:24:43.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TYPO3 is an open source web content management system. Prior to versions 9.5.34 ELTS, 10.4.29, and 11.5.11, Admin Tool sessions initiated via the TYPO3 backend user interface had not been revoked even if the corresponding user account was degraded to lower permissions or disabled completely. This way, sessions in the admin tool theoretically could have been prolonged without any limit. TYPO3 versions 9.5.34 ELTS, 10.4.29, and 11.5.11 contain a fix for the problem."}, {"lang": "es", "value": "TYPO3 es un sistema de administraci\u00f3n de contenidos web de c\u00f3digo abierto. En versiones anteriores a 9.5.34 ELTS, 10.4.29 y 11.5.11, las sesiones de la herramienta de administraci\u00f3n iniciadas por medio de la interfaz de usuario del backend de TYPO3 no son revocadas aunque la cuenta de usuario correspondiente es degradado a permisos inferiores o es deshabilitado por completo. De esta manera, las sesiones en la herramienta de administraci\u00f3n te\u00f3ricamente podr\u00edan haberse prolongado sin ning\u00fan l\u00edmite. TYPO3 versiones 9.5.34 ELTS, 10.4.29 y 11.5.11 contienen una correcci\u00f3n del problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:elts:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.5.35", "matchCriteriaId": "83732441-A020-4401-A274-067B95354BB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.4.29", "matchCriteriaId": "272C6A8B-94DB-4A74-BB3A-24CD0486DFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0.0", "versionEndExcluding": "11.5.11", "matchCriteriaId": "772D645D-5158-416C-BF2C-74E5E43EF1DC"}]}]}], "references": [{"url": "https://github.com/TYPO3/typo3/commit/592387972912290c135ebecc91768a67f83a3a4d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TYPO3/typo3/security/advisories/GHSA-wwjw-r3gj-39fq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2022-005", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/TYPO3/typo3/commit/592387972912290c135ebecc91768a67f83a3a4d"}}